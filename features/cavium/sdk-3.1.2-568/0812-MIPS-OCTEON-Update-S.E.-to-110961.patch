From 83abad9269650fa11460cddc5f463954f51b14ac Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sat, 5 Jul 2014 18:05:50 -0700
Subject: [PATCH 812/974] MIPS: OCTEON: Update S.E. to 110961

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bch.c       |    8 +-
 arch/mips/cavium-octeon/executive/cvmx-bootmem.c   |    6 +-
 arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c |  153 +-
 .../mips/cavium-octeon/executive/cvmx-dma-engine.c |    6 +-
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |    6 +-
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |   16 +-
 .../mips/cavium-octeon/executive/cvmx-helper-ipd.c |   30 +-
 .../cavium-octeon/executive/cvmx-helper-loop.c     |   11 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |    8 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |  681 ++--
 .../cavium-octeon/executive/cvmx-helper-util.c     |   36 +
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |  204 +-
 arch/mips/cavium-octeon/executive/cvmx-l2c.c       |   47 +-
 arch/mips/cavium-octeon/executive/cvmx-lap.c       |    2 +-
 .../cavium-octeon/executive/cvmx-pki-resources.c   |    7 +-
 arch/mips/cavium-octeon/executive/cvmx-pki.c       |   20 +-
 .../mips/cavium-octeon/executive/cvmx-pko3-queue.c |  282 +-
 .../cavium-octeon/executive/cvmx-pko3-resources.c  |   46 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |  123 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |   79 +-
 .../cavium-octeon/executive/cvmx-sso-resources.c   |    2 +
 arch/mips/cavium-octeon/executive/octeon-feature.c |    1 -
 arch/mips/cavium-octeon/executive/octeon-model.c   |   13 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-ase-defs.h       |   32 +-
 arch/mips/include/asm/octeon/cvmx-asxx-defs.h      |  300 +-
 arch/mips/include/asm/octeon/cvmx-bch-defs.h       |  176 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |  684 +++-
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h       |  119 +-
 arch/mips/include/asm/octeon/cvmx-ciu2-defs.h      | 1830 ++++-----
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |   63 +-
 arch/mips/include/asm/octeon/cvmx-cmd-queue.h      |  230 +-
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       |  375 +-
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h       |  698 +++-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |  125 +-
 arch/mips/include/asm/octeon/cvmx-fpa3.h           |    6 +-
 arch/mips/include/asm/octeon/cvmx-gmx.h            |    4 +-
 arch/mips/include/asm/octeon/cvmx-gmxx-defs.h      |  994 ++---
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h      |  268 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     | 1543 ++++++--
 arch/mips/include/asm/octeon/cvmx-helper-board.h   |    3 +-
 arch/mips/include/asm/octeon/cvmx-helper.h         |    7 +-
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       |  179 +-
 arch/mips/include/asm/octeon/cvmx-ila-defs.h       |  168 +-
 arch/mips/include/asm/octeon/cvmx-iobn-defs.h      |   37 +-
 arch/mips/include/asm/octeon/cvmx-iobp-defs.h      |   15 +-
 arch/mips/include/asm/octeon/cvmx-ipd-defs.h       |   24 +-
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |  892 +++--
 arch/mips/include/asm/octeon/cvmx-l2c.h            |   12 +-
 arch/mips/include/asm/octeon/cvmx-lap.h            |   20 +-
 arch/mips/include/asm/octeon/cvmx-lapx-defs.h      |  140 +-
 arch/mips/include/asm/octeon/cvmx-lbk-defs.h       |   49 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      | 4093 +++++++++++++++-----
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       | 1003 ++++-
 arch/mips/include/asm/octeon/cvmx-mixx-defs.h      |  129 +-
 arch/mips/include/asm/octeon/cvmx-mpi-defs.h       |   77 +-
 arch/mips/include/asm/octeon/cvmx-ndf-defs.h       |  487 ++-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |  310 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-osm-defs.h       |  286 +-
 arch/mips/include/asm/octeon/cvmx-pcie.h           |    2 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |  700 ++--
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   | 2426 +++++++-----
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   | 2046 ++++++----
 arch/mips/include/asm/octeon/cvmx-pcsx-defs.h      |   20 +-
 arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h     |  428 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      |  820 ++--
 arch/mips/include/asm/octeon/cvmx-pescx-defs.h     |  168 +-
 arch/mips/include/asm/octeon/cvmx-pexp-defs.h      |  112 +-
 arch/mips/include/asm/octeon/cvmx-pip-defs.h       |    8 +-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  694 +++-
 arch/mips/include/asm/octeon/cvmx-pki.h            |   34 +-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 3071 +++++++++++++--
 arch/mips/include/asm/octeon/cvmx-pko3-queue.h     |   33 +-
 arch/mips/include/asm/octeon/cvmx-pko3.h           |  184 +-
 arch/mips/include/asm/octeon/cvmx-pow.h            |   34 +-
 arch/mips/include/asm/octeon/cvmx-qlm.h            |    4 +-
 arch/mips/include/asm/octeon/cvmx-rnm-defs.h       |   11 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |  275 +-
 arch/mips/include/asm/octeon/cvmx-sata-defs.h      |  468 ++-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       | 1960 ++++++++--
 arch/mips/include/asm/octeon/cvmx-smix-defs.h      |   35 +
 arch/mips/include/asm/octeon/cvmx-spinlock.h       |  158 +-
 arch/mips/include/asm/octeon/cvmx-spxx-defs.h      |  192 +-
 .../mips/include/asm/octeon/cvmx-sriomaintx-defs.h |  650 ++--
 arch/mips/include/asm/octeon/cvmx-sriox-defs.h     |  430 +-
 arch/mips/include/asm/octeon/cvmx-srxx-defs.h      |   60 +-
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |  618 ++-
 arch/mips/include/asm/octeon/cvmx-stxx-defs.h      |  180 +-
 arch/mips/include/asm/octeon/cvmx-uahcx-defs.h     | 1112 +++---
 arch/mips/include/asm/octeon/cvmx-uctlx-defs.h     |  240 +-
 arch/mips/include/asm/octeon/cvmx-usbcx-defs.h     |  702 ++--
 arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h   | 1668 +++++---
 arch/mips/include/asm/octeon/cvmx-usbnx-defs.h     |  414 +-
 arch/mips/include/asm/octeon/octeon-feature.h      |   39 +-
 95 files changed, 25343 insertions(+), 11830 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index 06598d6..832010a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -152,10 +152,10 @@ int cvmx_bch_initialize(void)
 	}
 
 	bch_cmd_buf.u64 = 0;
-	bch_cmd_buf.s.dwb = bch_pool_size / 128;
-	bch_cmd_buf.s.pool = bch_pool;
-	bch_cmd_buf.s.size = bch_pool_size / 8;
-	bch_cmd_buf.s.ptr = cvmx_ptr_to_phys(
+	bch_cmd_buf.cn70xx.dwb = bch_pool_size / 128;
+	bch_cmd_buf.cn70xx.pool = bch_pool;
+	bch_cmd_buf.cn70xx.size = bch_pool_size / 8;
+	bch_cmd_buf.cn70xx.ptr = cvmx_ptr_to_phys(
 		cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_BCH)) >> 7;
 	cvmx_write_csr(CVMX_BCH_CMD_BUF, bch_cmd_buf.u64);
 	cvmx_write_csr(CVMX_BCH_GEN_INT, 7);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
index fb4bee4..5d341fa 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
@@ -43,7 +43,7 @@
  * Simple allocate only memory allocator.  Used to allocate memory at
  * application start time.
  *
- * <hr>$Revision: 109570 $<hr>
+ * <hr>$Revision: 110299 $<hr>
  *
  */
 
@@ -1367,7 +1367,7 @@ frees_done:
 	cvmx_dprintf("cvmx_bootmem_phy_mem_list_init: named_block_array_addr:"
 		     "0x%llx)\n", CAST_ULL(addr));
 #endif
-	if (!addr) {
+	if (addr < 0) {
 		cvmx_dprintf("FATAL ERROR: unable to allocate memory for "
 			     "bootmem descriptor!\n");
 		return 0;
@@ -1500,7 +1500,7 @@ int64_t cvmx_bootmem_phy_mem_list_init_multi(uint8_t node_mask,
 	cvmx_dprintf("cvmx_bootmem_phy_mem_list_init: named_block_array_addr:"
 		     "0x%llx)\n", CAST_ULL(addr));
 #endif
-	if (!addr) {
+	if (addr < 0) {
 		cvmx_dprintf("FATAL ERROR: unable to allocate memory for "
 			     "bootmem descriptor!\n");
 		return 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c b/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
index 781c3fd..5c73812 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
@@ -43,7 +43,7 @@
  * Support functions for managing command queues used for
  * various hardware blocks.
  *
- * <hr>$Revision: 106435 $<hr>
+ * <hr>$Revision: 110896 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/export.h>
@@ -66,8 +66,8 @@
  * This application uses this pointer to access the global queue
  * state. It points to a bootmem named block.
  */
-CVMX_SHARED __cvmx_cmd_queue_all_state_t *__cvmx_cmd_queue_state_ptr;
-EXPORT_SYMBOL(__cvmx_cmd_queue_state_ptr);
+CVMX_SHARED __cvmx_cmd_queue_all_state_t *__cvmx_cmd_queue_state_ptrs[CVMX_MAX_NODES];
+EXPORT_SYMBOL(__cvmx_cmd_queue_state_ptrs);
 
 /**
  * @INTERNAL
@@ -75,42 +75,65 @@ EXPORT_SYMBOL(__cvmx_cmd_queue_state_ptr);
  *
  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code
  */
-static cvmx_cmd_queue_result_t __cvmx_cmd_queue_init_state_ptr(void)
+cvmx_cmd_queue_result_t __cvmx_cmd_queue_init_state_ptr(unsigned node)
 {
-	char *alloc_name = "cvmx_cmd_queues";
+	char *alloc_name = "cvmx_cmd_queues\0\0";
+	char s[4] = "_0";
+	const cvmx_bootmem_named_block_desc_t *block_desc = NULL;
+	unsigned size;
+	uint64_t paddr_min = 0, paddr_max = 0;
+	void *ptr;
+
 #if defined(CONFIG_CAVIUM_RESERVE32) && CONFIG_CAVIUM_RESERVE32
-	extern uint64_t octeon_reserve32_memory;
 #endif
 
-	if (cvmx_likely(__cvmx_cmd_queue_state_ptr))
+	if (cvmx_likely(__cvmx_cmd_queue_state_ptrs[node]))
+		return CVMX_CMD_QUEUE_SUCCESS;
+
+	/* Add node# to block name */
+	if (node > 0) {
+		s[1] += node;
+		strcat(alloc_name, s);
+	}
+
+	/* Find the named block in case it has been created already */
+	block_desc = cvmx_bootmem_find_named_block(alloc_name);
+	if (block_desc) {
+		__cvmx_cmd_queue_state_ptrs[node] =
+			cvmx_phys_to_ptr(block_desc->base_addr);
 		return CVMX_CMD_QUEUE_SUCCESS;
+	}
+
+	size = sizeof(*__cvmx_cmd_queue_state_ptrs[node]);
 
+	/* Rest f the code is to allocate a new named block */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #if defined(CONFIG_CAVIUM_RESERVE32) && CONFIG_CAVIUM_RESERVE32
+	{
+	/* Special address range for SE-UM apps in 32-bit mode */
+	extern uint64_t octeon_reserve32_memory;
 	if (octeon_reserve32_memory)
-		__cvmx_cmd_queue_state_ptr = cvmx_bootmem_alloc_named_range(sizeof(*__cvmx_cmd_queue_state_ptr),
-									    octeon_reserve32_memory,
-									    octeon_reserve32_memory + (CONFIG_CAVIUM_RESERVE32 << 20) - 1,
-									    128, alloc_name);
-	else
+		paddr_min = octeon_reserve32_memory;
+		paddr_max = octeon_reserve32_memory +
+			(CONFIG_CAVIUM_RESERVE32 << 20) - 1,
+	}
 #endif
-		__cvmx_cmd_queue_state_ptr = cvmx_bootmem_alloc_named(sizeof(*__cvmx_cmd_queue_state_ptr), 128, alloc_name);
-#else
-	__cvmx_cmd_queue_state_ptr = cvmx_bootmem_alloc_named(sizeof(*__cvmx_cmd_queue_state_ptr), 128, alloc_name);
 #endif
-	if (__cvmx_cmd_queue_state_ptr)
-		memset(__cvmx_cmd_queue_state_ptr, 0, sizeof(*__cvmx_cmd_queue_state_ptr));
-	else {
-		const cvmx_bootmem_named_block_desc_t *block_desc = cvmx_bootmem_find_named_block(alloc_name);
-		if (block_desc)
-			__cvmx_cmd_queue_state_ptr = cvmx_phys_to_ptr(block_desc->base_addr);
-		else {
-			cvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: Unable to get named block %s.\n", alloc_name);
-			return CVMX_CMD_QUEUE_NO_MEMORY;
-		}
+
+	/* Atomically allocate named block once, and zero it by default */
+	ptr = cvmx_bootmem_alloc_named_range_once(size, paddr_min, paddr_max, 
+			128, alloc_name, NULL);
+
+	if (ptr != NULL) {
+		__cvmx_cmd_queue_state_ptrs[node] = ptr;
+	} else {
+		cvmx_dprintf("ERROR: %s: Unable to get named block %s.\n", 
+			__func__, alloc_name);
+		return CVMX_CMD_QUEUE_NO_MEMORY;
 	}
 	return CVMX_CMD_QUEUE_SUCCESS;
 }
+EXPORT_SYMBOL(__cvmx_cmd_queue_init_state_ptr);
 
 /**
  * Initialize a command queue for use. The initial FPA buffer is
@@ -129,7 +152,21 @@ cvmx_cmd_queue_result_t cvmx_cmd_queue_initialize(cvmx_cmd_queue_id_t queue_id,
 						  int pool_size)
 {
 	__cvmx_cmd_queue_state_t *qstate;
-	cvmx_cmd_queue_result_t result = __cvmx_cmd_queue_init_state_ptr();
+	cvmx_cmd_queue_result_t result;
+	unsigned node;
+	unsigned index;
+	int fpa_pool_min, fpa_pool_max;
+
+	node = __cvmx_cmd_queue_get_node(queue_id);
+
+	index = __cvmx_cmd_queue_get_index(queue_id);
+	if (index >= NUM_ELEMENTS(__cvmx_cmd_queue_state_ptrs[node]->state)){
+		cvmx_printf("ERROR: %s: queue %#x out of range\n",
+			__func__, queue_id);
+		return CVMX_CMD_QUEUE_INVALID_PARAM;
+	}
+
+	result = __cvmx_cmd_queue_init_state_ptr(node);
 	if (result != CVMX_CMD_QUEUE_SUCCESS)
 		return result;
 
@@ -147,29 +184,40 @@ cvmx_cmd_queue_result_t cvmx_cmd_queue_initialize(cvmx_cmd_queue_id_t queue_id,
 	} else if (max_depth != 0)
 		return CVMX_CMD_QUEUE_INVALID_PARAM;
 
-	if ((fpa_pool < 0) || (fpa_pool >= CVMX_FPA_NUM_POOLS))
+	/* CVMX_FPA_NUM_POOLS maps to cvmx_fpa3_num_auras for FPA3 */
+	fpa_pool_min = node << 10;
+	fpa_pool_max = fpa_pool_min + CVMX_FPA_NUM_POOLS;
+
+	if ((fpa_pool < fpa_pool_min) || (fpa_pool >= fpa_pool_max))
 		return CVMX_CMD_QUEUE_INVALID_PARAM;
+
 	if ((pool_size < 128) || (pool_size > 65536))
 		return CVMX_CMD_QUEUE_INVALID_PARAM;
+	if (pool_size & 3)
+		cvmx_dprintf("WARNING: %s: pool_size %d not multiple of 8\n",
+			__func__, pool_size);
 
 	/* See if someone else has already initialized the queue */
-	if (qstate->base_ptr_div128) {
+	if (qstate->base_paddr) {
+		static const char emsg[] = /* Common error message part */
+			"Queue already initialized with different ";
+
 		if (max_depth != (int)qstate->max_depth) {
-			cvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: Queue already initialized with different max_depth (%d).\n",
-				     (int)qstate->max_depth);
+			cvmx_dprintf("ERROR: %s: %s max_depth (%d).\n",
+				__func__, emsg, (int)qstate->max_depth);
 			return CVMX_CMD_QUEUE_INVALID_PARAM;
 		}
 		if (fpa_pool != qstate->fpa_pool) {
-			cvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: Queue already initialized with different FPA pool (%u).\n",
-				     qstate->fpa_pool);
+			cvmx_dprintf("ERROR: %s: %s FPA pool (%u).\n",
+				__func__, emsg, qstate->fpa_pool);
 			return CVMX_CMD_QUEUE_INVALID_PARAM;
 		}
 		if ((pool_size >> 3) - 1 != qstate->pool_size_m1) {
-			cvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: Queue already initialized with different FPA pool size (%u).\n",
-				     (qstate->pool_size_m1 + 1) << 3);
+			cvmx_dprintf("ERROR: %s: %s FPA pool size (%u).\n",
+				__func__, emsg,
+				(qstate->pool_size_m1 + 1) << 3);
 			return CVMX_CMD_QUEUE_INVALID_PARAM;
 		}
-		CVMX_SYNCWS;
 		return CVMX_CMD_QUEUE_ALREADY_SETUP;
 	} else {
 		union cvmx_fpa_ctl_status status;
@@ -178,14 +226,15 @@ cvmx_cmd_queue_result_t cvmx_cmd_queue_initialize(cvmx_cmd_queue_id_t queue_id,
 		if (!(octeon_has_feature(OCTEON_FEATURE_FPA3))) {
 			status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
 			if (!status.s.enb) {
-				cvmx_dprintf("ERROR: cvmx_cmd_queue_initialize:"
-					     " FPA is not enabled.\n");
+				cvmx_dprintf("ERROR: %s: FPA is not enabled.\n",
+					__func__);
 				return CVMX_CMD_QUEUE_NO_MEMORY;
 			}
 		}
 		buffer = __cvmx_cmd_queue_alloc_buffer(fpa_pool);
 		if (buffer == NULL) {
-			cvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: Unable to allocate initial buffer.\n");
+			cvmx_dprintf("ERROR: %s: allocating first buffer.\n",
+				__func__);
 			return CVMX_CMD_QUEUE_NO_MEMORY;
 		}
 
@@ -193,16 +242,14 @@ cvmx_cmd_queue_result_t cvmx_cmd_queue_initialize(cvmx_cmd_queue_id_t queue_id,
 		qstate->max_depth = max_depth;
 		qstate->fpa_pool = fpa_pool;
 		qstate->pool_size_m1 = (pool_size >> 3) - 1;
-		qstate->base_ptr_div128 = cvmx_ptr_to_phys(buffer) / 128;
-		/*
-		 * We zeroed the now serving field so we need to also
-		 * zero the ticket.
-		 */
-		__cvmx_cmd_queue_state_ptr->ticket[__cvmx_cmd_queue_get_index(queue_id)] = 0;
-		CVMX_SYNCWS;
+		qstate->base_paddr = cvmx_ptr_to_phys(buffer);
+
+		/* Initialize lock */
+		__cvmx_cmd_queue_lock_init(queue_id);
 		return CVMX_CMD_QUEUE_SUCCESS;
 	}
 }
+
 EXPORT_SYMBOL(cvmx_cmd_queue_initialize);
 
 /**
@@ -217,6 +264,8 @@ EXPORT_SYMBOL(cvmx_cmd_queue_initialize);
 cvmx_cmd_queue_result_t cvmx_cmd_queue_shutdown(cvmx_cmd_queue_id_t queue_id)
 {
 	__cvmx_cmd_queue_state_t *qptr = __cvmx_cmd_queue_get_state(queue_id);
+
+	/* FIXME: This will not complain if the queue was never initialized */
 	if (qptr == NULL) {
 		cvmx_dprintf("ERROR: cvmx_cmd_queue_shutdown: Unable to get queue information.\n");
 		return CVMX_CMD_QUEUE_INVALID_PARAM;
@@ -227,14 +276,14 @@ cvmx_cmd_queue_result_t cvmx_cmd_queue_shutdown(cvmx_cmd_queue_id_t queue_id)
 		return CVMX_CMD_QUEUE_FULL;
 	}
 
-	__cvmx_cmd_queue_lock(queue_id, qptr);
-	if (qptr->base_ptr_div128) {
+	__cvmx_cmd_queue_lock(queue_id);
+	if (qptr->base_paddr) {
 		cvmx_fpa_free(cvmx_phys_to_ptr(
-				       (uint64_t) qptr->base_ptr_div128 << 7),
+				       (uint64_t) qptr->base_paddr),
 				       qptr->fpa_pool, 0);
-		qptr->base_ptr_div128 = 0;
+		qptr->base_paddr = 0;
 	}
-	__cvmx_cmd_queue_unlock(qptr);
+	__cvmx_cmd_queue_unlock(queue_id);
 
 	return CVMX_CMD_QUEUE_SUCCESS;
 }
@@ -318,8 +367,8 @@ int cvmx_cmd_queue_length(cvmx_cmd_queue_id_t queue_id)
 void *cvmx_cmd_queue_buffer(cvmx_cmd_queue_id_t queue_id)
 {
 	__cvmx_cmd_queue_state_t *qptr = __cvmx_cmd_queue_get_state(queue_id);
-	if (qptr && qptr->base_ptr_div128)
-		return cvmx_phys_to_ptr((uint64_t) qptr->base_ptr_div128 << 7);
+	if (qptr && qptr->base_paddr)
+		return cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
 	else
 		return NULL;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c b/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
index dfcc12a..11db7ab 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
@@ -43,7 +43,7 @@
  * Interface to the PCI / PCIe DMA engines. These are only avialable
  * on chips with PCI / PCIe.
  *
- * <hr>$Revision: 103836 $<hr>
+ * <hr>$Revision: 110895 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/export.h>
@@ -333,7 +333,7 @@ int cvmx_dma_engine_submit(int engine, cvmx_dma_engine_header_t header, int num_
 	   ring the doorbell for the DMA engines. This prevents doorbells from
 	   possibly arriving out of order with respect to the command queue
 	   entries */
-	__cvmx_cmd_queue_lock(CVMX_CMD_QUEUE_DMA(engine), __cvmx_cmd_queue_get_state(CVMX_CMD_QUEUE_DMA(engine)));
+	__cvmx_cmd_queue_lock(CVMX_CMD_QUEUE_DMA(engine));
 	result = cvmx_cmd_queue_write(CVMX_CMD_QUEUE_DMA(engine), 0, cmd_count, cmds);
 	/* This SYNCWS is needed since the command queue didn't do locking, which
 	   normally implies the SYNCWS. This one makes sure the command queue
@@ -354,7 +354,7 @@ int cvmx_dma_engine_submit(int engine, cvmx_dma_engine_header_t header, int num_
 		}
 	}
 	/* Here is the unlock for the above errata workaround */
-	__cvmx_cmd_queue_unlock(__cvmx_cmd_queue_get_state(CVMX_CMD_QUEUE_DMA(engine)));
+	__cvmx_cmd_queue_unlock((CVMX_CMD_QUEUE_DMA(engine)));
 	return result;
 }
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 8c07fdd..7266fd8 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -78,7 +78,11 @@ int __cvmx_helper_bgx_enumerate(int xiface)
 	if (qlm == -1)
 		return 0;
 
-	mode = cvmx_qlm_get_mode_cn78xx(node, qlm);
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+		mode = cvmx_qlm_get_mode_cn78xx(node, qlm);
+	else
+		mode = cvmx_qlm_get_mode(qlm);
+
 	if (mode == CVMX_QLM_MODE_SGMII) {
 		return 4;
 	} else if (mode == CVMX_QLM_MODE_XAUI
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index c670ac3..5c726ea 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -506,22 +506,24 @@ void cvmx_helper_cfg_set_jabber_and_frame_max()
 {
 	int interface, port;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+	if (octeon_has_feature(OCTEON_FEATURE_BGX)) {
 		int ipd_port;
+		int node = cvmx_get_node_num();
 
 		/*Set the frame max size and jabber size to 65535. */
 		for (interface = 0; interface < cvmx_helper_get_number_of_interfaces(); interface++) {
 			/* Set the frame max size and jabber size to 65535, as the defaults
 		   	are too small. */
-			cvmx_helper_interface_mode_t imode = cvmx_helper_interface_get_mode(interface);
+			int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
+			cvmx_helper_interface_mode_t imode = cvmx_helper_interface_get_mode(xiface);
 			int num_ports = cvmx_helper_ports_on_interface(interface);
 
 			switch (imode) {
 			case CVMX_HELPER_INTERFACE_MODE_SGMII:
 				for (port = 0; port < num_ports; port++) {
-					ipd_port = cvmx_helper_get_ipd_port(interface, port);
+					ipd_port = cvmx_helper_get_ipd_port(xiface, port);
 					cvmx_pki_set_max_frm_len(ipd_port, -1);
-					cvmx_write_csr(CVMX_BGXX_GMP_GMI_RXX_JABBER(port, interface), 65535);
+					cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_RXX_JABBER(port, interface), 65535);
 				}
 				break;
 			case CVMX_HELPER_INTERFACE_MODE_XAUI:
@@ -531,9 +533,9 @@ void cvmx_helper_cfg_set_jabber_and_frame_max()
 			case CVMX_HELPER_INTERFACE_MODE_10G_KR:
 			case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 				for (port = 0; port < num_ports; port++) {
-					ipd_port = cvmx_helper_get_ipd_port(interface, port);
+					ipd_port = cvmx_helper_get_ipd_port(xiface, port);
 					cvmx_pki_set_max_frm_len(ipd_port, -1);
-					cvmx_write_csr(CVMX_BGXX_SMUX_RX_JABBER(port, interface), 65535);
+					cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_JABBER(port, interface), 65535);
 				}
 				break;
 			default:
@@ -605,7 +607,7 @@ void cvmx_helper_cfg_store_short_packets_in_wqe()
 	cvmx_ipd_ctl_status_t ipd_ctl_status;
 	unsigned dyn_rs = 1;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+	if (octeon_has_feature(OCTEON_FEATURE_PKI))
 		return;
 
 	/* NO_WPTR combines WQE with 1st MBUF, RS is redundant */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-ipd.c b/arch/mips/cavium-octeon/executive/cvmx-helper-ipd.c
index b4455df..779c842 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-ipd.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-ipd.c
@@ -120,12 +120,12 @@ static int cvmx_helper_fcs_op(int interface, int nports, int has_fcs)
 	int pknd;
 	union cvmx_pip_sub_pkind_fcsx pkind_fcsx;
 	union cvmx_pip_prt_cfgx port_cfg;
-	unsigned int node = cvmx_get_node_num();
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(interface);
 
 	if (!octeon_has_feature(OCTEON_FEATURE_PKND))
 		return 0;
 	if (octeon_has_feature(OCTEON_FEATURE_PKI)) {
-		cvmx_helper_pki_set_fcs_op(node, interface, nports, has_fcs);
+		cvmx_helper_pki_set_fcs_op(xi.node, xi.interface, nports, has_fcs);
 		return 0;
 	}
 
@@ -236,41 +236,41 @@ static int __cvmx_helper_ipd_port_setup(int ipd_port)
  *
  * @return Zero on success, negative on failure
  */
-int __cvmx_helper_ipd_setup_interface(int interface)
+int __cvmx_helper_ipd_setup_interface(int xiface)
 {
 	cvmx_helper_interface_mode_t mode;
-	int ipd_port = cvmx_helper_get_ipd_port(interface, 0);
-	int num_ports = cvmx_helper_ports_on_interface(interface);
+	int num_ports = cvmx_helper_ports_on_interface(xiface);
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	int ipd_port = cvmx_helper_get_ipd_port(xiface, 0);
 	int delta;
-	unsigned int node = cvmx_get_node_num();
 
 	if (num_ports == CVMX_HELPER_CFG_INVALID_VALUE)
 		return 0;
 
 	delta = 1;
 	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
-		if (interface < CVMX_HELPER_MAX_GMX)
+		if (xi.interface < CVMX_HELPER_MAX_GMX)
 			delta = 16;
 	}
 
 	while (num_ports--) {
-		if (!cvmx_helper_is_port_valid(interface, num_ports))
+		if (!cvmx_helper_is_port_valid(xiface, num_ports))
 			continue;
 		if (octeon_has_feature(OCTEON_FEATURE_PKI))
-			__cvmx_helper_pki_port_setup(node, ipd_port);
+			__cvmx_helper_pki_port_setup(xi.node, ipd_port);
 		else
 			__cvmx_helper_ipd_port_setup(ipd_port);
 		ipd_port += delta;
 	}
 	/* FCS settings */
-	cvmx_helper_fcs_op(interface,
-			   cvmx_helper_ports_on_interface(interface),
-			   __cvmx_helper_get_has_fcs(interface));
+	cvmx_helper_fcs_op(xiface,
+			   cvmx_helper_ports_on_interface(xiface),
+			   __cvmx_helper_get_has_fcs(xiface));
+
+	mode = cvmx_helper_interface_get_mode(xiface);
 
-	mode = cvmx_helper_interface_get_mode(interface);
-	
 	if (mode == CVMX_HELPER_INTERFACE_MODE_LOOP)
-			__cvmx_helper_loop_enable(interface);
+			__cvmx_helper_loop_enable(xiface);
 
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c b/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
index 7dcae9d6..39e426b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
@@ -43,7 +43,7 @@
  * Functions for LOOP initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 97657 $<hr>
+ * <hr>$Revision: 109369 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -93,9 +93,9 @@ int __cvmx_helper_loop_enable(int interface)
 	cvmx_pip_prt_cfgx_t port_cfg;
 	int num_ports, index;
 	unsigned long offset;
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(interface);
 
 	num_ports = __cvmx_helper_get_num_ipd_ports(interface);
-
 	/*
 	 * We need to disable length checking so packet < 64 bytes and jumbo
 	 * frames don't get errors
@@ -104,9 +104,8 @@ int __cvmx_helper_loop_enable(int interface)
 		offset = ((octeon_has_feature(OCTEON_FEATURE_PKND)) ? cvmx_helper_get_pknd(interface, index) : cvmx_helper_get_ipd_port(interface, index));
 
 		if (octeon_has_feature(OCTEON_FEATURE_PKI)) {
-			int node = cvmx_get_node_num();
-			cvmx_pki_endis_l2_errs(node, offset, 1, 0, 0);
-                        cvmx_pki_endis_fcs_check(node, offset, 0, 0);
+			cvmx_pki_endis_l2_errs(xi.node, offset, 1, 0, 0);
+                        cvmx_pki_endis_fcs_check(xi.node, offset, 0, 0);
 		} else {
 			port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(offset));
 			port_cfg.s.maxerr_en = 0;
@@ -123,7 +122,7 @@ int __cvmx_helper_loop_enable(int interface)
 		ipd_sub_port_fcs.u64 = cvmx_read_csr(CVMX_IPD_SUB_PORT_FCS);
 		ipd_sub_port_fcs.s.port_bit2 = 0;
 		cvmx_write_csr(CVMX_IPD_SUB_PORT_FCS, ipd_sub_port_fcs.u64);
-	} 
+	}
 	/*
  	 * Set PKND and BPID for loopback ports.
  	 */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index a59b7b5..a04ac3d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -934,7 +934,7 @@ int cvmx_helper_pki_set_gbl_schd(int node, struct cvmx_pki_global_schd *gblsch)
 {
 	int rs;
 
-	if (gblsch->setup_pool) {
+	if (gblsch->setup_pool && gblsch->pool_num < 0) {
 		if (pki_helper_debug)
 			cvmx_dprintf("%s: gbl setup global pool %d buff_size %d blocks %d\n",
 				__func__, gblsch->pool_num,
@@ -957,7 +957,7 @@ int cvmx_helper_pki_set_gbl_schd(int node, struct cvmx_pki_global_schd *gblsch)
 		if (pki_helper_debug)
 			cvmx_dprintf("pool alloced is %d\n", gblsch->pool_num);
 	}
-	if (gblsch->setup_aura) {
+	if (gblsch->setup_aura && gblsch->aura_num < 0) {
 		if (pki_helper_debug)
 			cvmx_dprintf("%s: gbl setup global aura %d pool %d blocks %d\n",
 				__func__, gblsch->aura_num, gblsch->pool_num,
@@ -981,7 +981,7 @@ int cvmx_helper_pki_set_gbl_schd(int node, struct cvmx_pki_global_schd *gblsch)
 			cvmx_dprintf("aura alloced is %d\n", gblsch->aura_num);
 
 	}
-	if (gblsch->setup_sso_grp) {
+	if (gblsch->setup_sso_grp && gblsch->sso_grp < 0) {
 		//unsigned grp_node;
 		//grp_node = (abs)(gblsch->setup_sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);/*vinita_to_do to extract node*/
 		rs = cvmx_sso_allocate_group(node);
@@ -1689,7 +1689,7 @@ void cvmx_helper_pki_set_fcs_op(int node, int interface, int nports, int has_fcs
 {
 	int index;
 	int pknd;
-	int cluster = 0;
+	unsigned cluster = 0;
 	cvmx_pki_clx_pkindx_cfg_t pkind_cfg;
 
 	for (index = 0; index < nports; index++) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 7ef2813..63911b0 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -106,7 +106,8 @@
 #endif
 
 /* channels are present at L2 queue level by default */
-static const int cvmx_pko_default_channel_level = 0;
+static const enum cvmx_pko3_level_e
+cvmx_pko_default_channel_level = CVMX_PKO_L2_QUEUES;
 
 static const int debug = 0;
 
@@ -186,153 +187,34 @@ static int __cvmx_pko3_config_memory(unsigned node)
 
 	return aura_num;
 }
-
-
-#endif
-
-/** Initialize a single ILK link
- *
- * Each ILK link is one interface, the port portion of IPD
- * represents a logical channel.
- * The number of channels for each interface is derived from the ILK
- * module configuration.
- */
-static int __cvmx_pko3_config_ilk_interface(int xiface,
-	unsigned num_dq, bool prioritized)
-{
-	int l1_q_num;
-	int l2_q_num;
-	int res;
-	int res_owner;
-	int pko_mac_num;
-	unsigned num_chans, i;
-	uint16_t ipd_port;
-	int prio;
-	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-
-	if (prioritized && num_dq > 1)
-		prio = num_dq;
-	else
-		prio = -1;
-
-	num_chans = __cvmx_helper_ilk_enumerate(xiface);
-
-	if(debug)
-		cvmx_dprintf("%s: configuring ILK xiface %u:%u with "
-				"%u chans %u queues each\n",
-				__FUNCTION__, xi.node, xi.interface,
-				num_chans, num_dq);
-
-	/* ILK channels all go to the same mac */
-	pko_mac_num = __cvmx_pko3_get_mac_num(xiface, 0);
-	if (pko_mac_num < 0) {
-                cvmx_dprintf ("%s: ERROR Invalid interface\n", __FUNCTION__);
-		return -1;
-	}
-
-	/* Resources of all channels on this link have common owner */
-	ipd_port = cvmx_helper_get_ipd_port(xiface, 0);
-
-	/* Build an identifiable owner */
-	res_owner = __cvmx_helper_pko3_res_owner(ipd_port);
-
-	/* Reserve port queue to make sure the MAC is not already configured */
-	l1_q_num = pko_mac_num;
-        l1_q_num = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_PORT_QUEUES,
-				res_owner, l1_q_num, 1);
-
-	if (l1_q_num != pko_mac_num) {
-                cvmx_dprintf ("%s: ERROR Reserving L1 PQ\n", __FUNCTION__);
-		return -1;
-	}
-
-
-        /* allocate level 2 queues, one per channel */
-        l2_q_num = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L2_QUEUES, res_owner,
-					 -1, num_chans);
-        if (l2_q_num < 0) {
-                cvmx_dprintf ("%s: ERROR allocation L2 SQ\n", __FUNCTION__);
-                return -1;
-        }
-
-
-	/* Configre <num_chans> children for MAC, with Fair-RR scheduling */
-	res = cvmx_pko3_pq_config_children( xi.node,
-			pko_mac_num, l2_q_num, num_chans, -1);
-
-	if (res < 0) {
-		cvmx_dprintf("%s: ERROR: Could not setup ILK Channel queues\n",
-			__FUNCTION__);
-		return -1;
-	}
-
-	/* Configure children with one DQ per channel */
-	for (i = 0; i < num_chans; i++) {
-		int l3_q, l4_q, l5_q, dq, res;
-
-		l3_q = l4_q = l5_q = dq = -1;
-		ipd_port = cvmx_helper_get_ipd_port(xiface, i);
-
-		/* map channels to l2 queues */
-		cvmx_pko3_map_channel(xi.node, l1_q_num, l2_q_num+i, ipd_port);
-
-		l3_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L3_QUEUES,
-			res_owner, -1, 1);
-		if(l3_q < 0) goto _fail;
-
-		res = cvmx_pko3_sq_config_children(xi.node, 2, l2_q_num+i, l3_q, 1, 1);
-		if(res < 0) goto _fail;
-
-		l4_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L4_QUEUES,
-			res_owner, -1, 1);
-		if(l4_q < 0) goto _fail;
-		res = cvmx_pko3_sq_config_children(xi.node, 3, l3_q, l4_q, 1, 1);
-		if(res < 0) goto _fail;
-
-		l5_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L5_QUEUES,
-			res_owner, -1, 1);
-		if(l5_q < 0) goto _fail;
-		res = cvmx_pko3_sq_config_children(xi.node, 4, l4_q, l5_q, 1, 1);
-		if(res < 0) goto _fail;
-
-		dq = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_DESCR_QUEUES,
-			res_owner, -1, num_dq);
-		if(dq < 0) goto _fail;
-
-		res = cvmx_pko3_sq_config_children(xi.node, 5, l5_q,
-			dq, num_dq, prio);
-		if(res < 0) goto _fail;
-
-		/* register DQ range with the translation table */
-		res = __cvmx_pko3_ipd_dq_register(xiface, i, dq, num_dq);
-		if(res < 0) goto _fail;
-	}
-
-	return 0;
-  _fail:
-	cvmx_dprintf("ERROR: %s: configuring queues for xiface %u:%u chan %u\n",
-				__FUNCTION__, xi.node, xi.interface, i);
-	return -1;
-}
+#endif /* !CVMX_BUILD_FOR_LINUX_KERNEL */
 
 
 /** Initialize a channelized port
- * This is intended for LOOP and NPI interfaces which have one MAC
+ * This is intended for LOOP, ILK and NPI interfaces which have one MAC
  * per interface and need a channel per subinterface (e.g. ring).
- * This function is somewhat similar to __cvmx_pko3_config_ilk_interface()
- * but are kept separate for easier maintenance.
+ * Each channel then may have 'num_queues' descriptor queues
+ * attached to it, which can also be prioritized or fair.
  */
 static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
 	uint8_t num_queues, bool prioritized)
 {
 	int l1_q_num;
-	int l2_q_num;
+	int l2_q_base;
+	enum cvmx_pko3_level_e level;
 	int res;
+	int parent_q, child_q;
+	unsigned chan, dq;
 	int pko_mac_num;
 	uint16_t ipd_port;
 	int res_owner, prio;
 	unsigned i;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	unsigned node = xi.node;
+	char b1[12];
+
+	if (num_queues == 0)
+		num_queues = 1;
 
 	if (prioritized && num_queues > 1)
 		prio = num_queues;
@@ -348,7 +230,7 @@ static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
 	/* all channels all go to the same mac */
 	pko_mac_num = __cvmx_pko3_get_mac_num(xiface, 0);
 	if (pko_mac_num < 0) {
-                cvmx_dprintf ("%s: ERROR Invalid interface\n", __FUNCTION__);
+                cvmx_printf ("ERROR: %s: Invalid interface\n", __func__);
 		return -1;
 	}
 
@@ -358,86 +240,110 @@ static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
 	/* Build an identifiable owner */
 	res_owner = __cvmx_helper_pko3_res_owner(ipd_port);
 
+	/* Start configuration at L1/PQ */
+	level = CVMX_PKO_PORT_QUEUES;
+
 	/* Reserve port queue to make sure the MAC is not already configured */
-	l1_q_num = pko_mac_num;
-        l1_q_num = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_PORT_QUEUES,
-				res_owner, l1_q_num, 1);
+        l1_q_num = cvmx_pko_alloc_queues(node, level, res_owner, -1, 1);
 
-	if (l1_q_num != pko_mac_num) {
-                cvmx_dprintf ("%s: ERROR Reserving L1 PQ\n", __FUNCTION__);
+	if (l1_q_num < 0) {
+                cvmx_printf ("ERROR: %s: Reserving L1 PQ\n", __func__);
 		return -1;
 	}
 
+	res = cvmx_pko3_pq_config(node, pko_mac_num, l1_q_num);
+	if (res < 0) {
+                cvmx_printf ("ERROR: %s: Configuring L1 PQ\n", __func__);
+		return -1;
+	}
+
+	/* next queue level = L2/SQ */
+	level = __cvmx_pko3_sq_lvl_next(level);
 
         /* allocate level 2 queues, one per channel */
-        l2_q_num = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L2_QUEUES, res_owner,
+        l2_q_base = cvmx_pko_alloc_queues(node, level, res_owner,
 					 -1, num_chans);
-        if (l2_q_num < 0) {
-                cvmx_dprintf ("%s: ERROR allocation L2 SQ\n", __FUNCTION__);
+        if (l2_q_base < 0) {
+                cvmx_printf ("ERROR: %s: allocation L2 SQ\n", __func__);
                 return -1;
         }
 
-
-	/* Configre <num_chans> children for MAC, non-prioritized */
-	res = cvmx_pko3_pq_config_children( xi.node,
-			l1_q_num, l2_q_num, num_chans, -1);
+	/* Configre <num_chans> L2 children for PQ, non-prioritized */
+	res = cvmx_pko3_sq_config_children(node, level,
+			l1_q_num, l2_q_base, num_chans, -1);
 
 	if (res < 0) {
-		cvmx_dprintf("%s: ERROR: Failed channel queues\n",
-			__FUNCTION__);
+		cvmx_printf("ERROR: %s: Failed channel queues\n", __func__);
 		return -1;
 	}
 
-	/* Configure children with one DQ per channel */
-	for (i = 0; i < num_chans; i++) {
-		int l3_q, l4_q, l5_q, dq, res;
-		unsigned chan = i;
+	/* map channels to l2 queues */
+	for (chan = 0; chan < num_chans; chan++) {
+		ipd_port = cvmx_helper_get_ipd_port(xiface, chan);
+		cvmx_pko3_map_channel(node,
+			l1_q_num, l2_q_base + chan, ipd_port);
+	}
 
-		l3_q = l4_q = l5_q = dq = -1;
+	/* next queue level = L3/SQ */
+	level = __cvmx_pko3_sq_lvl_next(level);
+	parent_q = l2_q_base;
 
-		ipd_port = cvmx_helper_get_ipd_port(xiface, chan);
+	do {
+		child_q = cvmx_pko_alloc_queues(node, level,
+			res_owner, -1, num_chans);
 
-		/* map channels to l2 queues */
-		cvmx_pko3_map_channel(xi.node, l1_q_num, l2_q_num+chan,
-			ipd_port);
+		if (child_q < 0) {
+			cvmx_printf ("ERROR: %s: allocating %s\n",
+				__func__,
+				__cvmx_pko3_sq_str(b1, level, child_q));
+			return -1;
+		}
 
-		l3_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L3_QUEUES,
-			res_owner, -1, 1);
-		if(l3_q < 0) goto _fail;
+		for (i = 0; i < num_chans; i++) {
+			res = cvmx_pko3_sq_config_children(node, level,
+				parent_q + i, child_q + i, 1, 1);
 
-		res = cvmx_pko3_sq_config_children(xi.node, 2, l2_q_num+chan,
-			l3_q, 1, 1);
-		if(res < 0) goto _fail;
+			if (res < 0) {
+				cvmx_printf ("ERROR: %s: configuring %s\n",
+					__func__,
+					__cvmx_pko3_sq_str(b1, level, child_q));
+				return -1;
+			}
 
-		l4_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L4_QUEUES,
-			res_owner, -1, 1);
-		if(l4_q < 0) goto _fail;
+		} /* for i */
 
-		res = cvmx_pko3_sq_config_children(xi.node, 3,
-			l3_q, l4_q, 1, 1);
-		if(res < 0) goto _fail;
+		parent_q = child_q;
+		level = __cvmx_pko3_sq_lvl_next(level);
 
-		l5_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L5_QUEUES,
-			res_owner, -1, 1);
-		if(l5_q < 0) goto _fail;
-		res = cvmx_pko3_sq_config_children(xi.node, 4,
-			l4_q, l5_q, 1, 1);
-		if(res < 0) goto _fail;
+	/* Terminate loop on DQ level, it has special handling */
+	} while (level != CVMX_PKO_DESCR_QUEUES &&
+		level != CVMX_PKO_LEVEL_INVAL);
+
+	if (level != CVMX_PKO_DESCR_QUEUES) {
+		cvmx_printf("ERROR: %s: level sequence error\n", __func__);
+		return -1;
+	}
+
+	/* Configure DQs, num_dqs per chan */
+	for (chan = 0; chan < num_chans; chan++) {
 
-		dq = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_DESCR_QUEUES,
+		res = cvmx_pko_alloc_queues(node, level,
 			res_owner, -1, num_queues);
-		if(dq < 0) goto _fail;
+
+		if(res < 0) goto _fail;
+		dq = res;
 
 		if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0) && (dq & 7))
 			cvmx_dprintf("WARNING: %s: DQ# %u not integral of 8\n",
 				__func__, dq);
 
-		res = cvmx_pko3_sq_config_children(xi.node, 5, l5_q,
+		res = cvmx_pko3_sq_config_children(node, level, parent_q + chan,
 			dq, num_queues, prio);
 		if(res < 0) goto _fail;
 
 		/* register DQ range with the translation table */
-		res = __cvmx_pko3_ipd_dq_register(xiface, chan, dq, num_queues);
+		res = __cvmx_pko3_ipd_dq_register(xiface,
+				chan, dq, num_queues);
 		if(res < 0) goto _fail;
 	}
 
@@ -462,26 +368,29 @@ static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
  */
 static int __cvmx_pko3_config_pfc_interface(int xiface, unsigned port)
 {
-	int l1_q_num;
-	int l2_q_num;
-	int res;
+	enum cvmx_pko3_level_e level;
 	int pko_mac_num;
-	int l3_q, l4_q, l5_q, dq;
+	int l1_q_num, l2_q_base;
+	int child_q, parent_q;
+	int dq_base;
+	int res;
 	const unsigned num_chans = 8;
 	cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
 	unsigned node = xi.node;
 	uint16_t ipd_port;
 	int res_owner;
+	char b1[12];
 	unsigned i;
 
-	if(debug)
-		cvmx_dprintf("%s: configuring xiface %u:%u port %u with %u PFC channels\n",
-			__FUNCTION__, node, xi.interface, port, num_chans);
+	if (debug)
+		cvmx_dprintf("%s: configuring xiface %u:%u port %u "
+			"with %u PFC channels\n",
+			__func__, node, xi.interface, port, num_chans);
 
 	/* Get MAC number for the iface/port */
 	pko_mac_num = __cvmx_pko3_get_mac_num(xiface, port);
 	if (pko_mac_num < 0) {
-		cvmx_dprintf ("%s: ERROR Invalid interface\n", __FUNCTION__);
+		cvmx_printf ("ERROR: %s: Invalid interface\n", __func__);
 		return -1;
 	}
 
@@ -490,74 +399,121 @@ static int __cvmx_pko3_config_pfc_interface(int xiface, unsigned port)
 	/* Build an identifiable owner identifier */
 	res_owner = __cvmx_helper_pko3_res_owner(ipd_port);
 
+	level = CVMX_PKO_PORT_QUEUES;
+
 	/* Allocate port queue to make sure the MAC is not already configured */
-	l1_q_num = cvmx_pko_alloc_queues(node, CVMX_PKO_PORT_QUEUES,
-				res_owner, pko_mac_num, 1);
+	l1_q_num = cvmx_pko_alloc_queues(node, level, res_owner, -1, 1);
 
-	if (l1_q_num != pko_mac_num) {
-		cvmx_dprintf ("%s: ERROR allocation L1 SQ\n", __FUNCTION__);
+	if (l1_q_num < 0) {
+		cvmx_printf ("ERROR: %s: allocation L1 PQ\n", __func__);
 		return -1;
 	}
 
-
-	/* allocate or reserve level 2 queues */
-	l2_q_num = cvmx_pko_alloc_queues(node, CVMX_PKO_L2_QUEUES, res_owner,
-					 -1, num_chans);
-	if (l2_q_num < 0) {
-		cvmx_dprintf ("%s: ERROR allocation L2 SQ\n", __FUNCTION__);
+	res = cvmx_pko3_pq_config(xi.node, pko_mac_num, l1_q_num);
+	if (res < 0) {
+                cvmx_printf ("ERROR: %s: Configuring %s\n", __func__,
+				__cvmx_pko3_sq_str(b1, level, l1_q_num));
 		return -1;
 	}
 
+	/* Determine the next queue level */
+	level = __cvmx_pko3_sq_lvl_next(level);
 
-	/* Configre <num_chans> children for MAC, with static priority */
-	res = cvmx_pko3_pq_config_children( node,
-			pko_mac_num, l2_q_num, num_chans, num_chans);
-
-	if (res < 0) {
-		cvmx_dprintf("Error: Could not setup PFC Channel queues\n");
+	/* Allocate 'num_chans' L2 queues, one per channel */
+	l2_q_base = cvmx_pko_alloc_queues(node, level, res_owner,
+		-1, num_chans);
+	if (l2_q_base < 0) {
+		cvmx_printf ("ERROR: %s: allocation L2 SQ\n", __func__);
 		return -1;
 	}
 
-	/* Allocate all SQ levels at once to assure contigous range */
-	l3_q = cvmx_pko_alloc_queues(node, CVMX_PKO_L3_QUEUES,
-			res_owner, -1, num_chans);
-	l4_q = cvmx_pko_alloc_queues(node, CVMX_PKO_L4_QUEUES,
-			res_owner, -1, num_chans);
-	l5_q = cvmx_pko_alloc_queues(node, CVMX_PKO_L5_QUEUES,
-			res_owner, -1, num_chans);
-	dq = cvmx_pko_alloc_queues(node, CVMX_PKO_DESCR_QUEUES,
-			res_owner, -1, num_chans);
-	if (l3_q < 0 || l4_q < 0 || l5_q < 0 ||dq < 0) {
-		cvmx_dprintf("%s: ERROR:could not allocate queues, "
-			"xiface %u:%u port %u\n",
-			__FUNCTION__, xi.node, xi.interface, port);
+	/* Configre <num_chans> L2 children for PQ, with static priority */
+	res = cvmx_pko3_sq_config_children(node, level,
+			l1_q_num, l2_q_base, num_chans, num_chans);
+
+	if (res < 0) {
+                cvmx_printf ("ERROR: %s: Configuring %s for PFC\n", __func__,
+				__cvmx_pko3_sq_str(b1, level, l1_q_num));
 		return -1;
 	}
 
-	/* Configure children with one DQ per channel */
+	/* Map each of the allocated channels */
 	for (i = 0; i < num_chans; i++) {
-		uint16_t chan, dq_num;
-		/* <i> moves in priority order, 0=highest, 7=lowest */
+		uint16_t chan;
 
 		/* Get CHAN_E value for this PFC channel, PCP in low 3 bits */
 		chan = ipd_port | cvmx_helper_prio2qos(i);
 
-		/* map channels to L2 queues */
-		cvmx_pko3_map_channel(node, l1_q_num, l2_q_num+i, chan);
+		cvmx_pko3_map_channel(node, l1_q_num, l2_q_base + i, chan);
 
-		cvmx_pko3_sq_config_children(node, 2, l2_q_num+i, l3_q+i, 1, 1);
+	}
+
+	/* Iterate through the levels until DQ and allocate 'num_chans'
+	 * consecutive queues at each level and hook them up
+	 * one-to-one with the parent level queues
+	 */
+
+	parent_q = l2_q_base;
+	level = __cvmx_pko3_sq_lvl_next(level);
+
+	do {
+
+		child_q = cvmx_pko_alloc_queues(node, level,
+			res_owner, -1, num_chans);
 
-		cvmx_pko3_sq_config_children(node, 3, l3_q+i, l4_q+i, 1, 1);
+		if (child_q < 0) {
+			cvmx_printf ("ERROR: %s: allocating %s\n",
+				__func__,
+				__cvmx_pko3_sq_str(b1, level, child_q));
+			return -1;
+		}
+
+		for (i = 0; i < num_chans; i++) {
+			res = cvmx_pko3_sq_config_children(node, level,
+				parent_q + i, child_q + i, 1, 1);
+
+			if (res < 0) {
+				cvmx_printf ("ERROR: %s: configuring %s\n",
+					__func__,
+					__cvmx_pko3_sq_str(b1, level, child_q));
+				return -1;
+			}
 
-		cvmx_pko3_sq_config_children(node, 4, l4_q+i, l5_q+i, 1, 1);
+		} /* for i */
 
-		/* Configure DQs in QoS order, so that QoS/PCP can be index */
-		dq_num = dq + cvmx_helper_prio2qos(i);
-		cvmx_pko3_sq_config_children(node, 5, l5_q+i, dq_num, 1, 1);
+		parent_q = child_q;
+		level = __cvmx_pko3_sq_lvl_next(level);
+
+	/* Terminate loop on DQ level, it has special handling */
+	} while (level != CVMX_PKO_DESCR_QUEUES &&
+		level != CVMX_PKO_LEVEL_INVAL);
+
+	if (level != CVMX_PKO_DESCR_QUEUES) {
+		cvmx_printf("ERROR: %s: level sequence error\n", __func__);
+		return -1;
+	}
+
+	dq_base = cvmx_pko_alloc_queues(node, level, res_owner, -1, num_chans);
+	if (dq_base < 0) {
+		cvmx_printf ("ERROR: %s: allocating %s\n", __func__,
+				__cvmx_pko3_sq_str(b1, level, dq_base));
+		return -1;
+	}
+
+	/* Configure DQs in QoS order, so that QoS/PCP can be index */
+	for (i = 0; i < num_chans; i++) {
+		int dq_num = dq_base + cvmx_helper_prio2qos(i);
+		res = cvmx_pko3_sq_config_children(node, level,
+			parent_q + i, dq_num, 1, 1);
+		if (res < 0) {
+			cvmx_printf ("ERROR: %s: configuring %s\n", __func__,
+				__cvmx_pko3_sq_str(b1, level, dq_num));
+			return -1;
+		}
 	}
 
 	/* register entire DQ range with the IPD translation table */
-	__cvmx_pko3_ipd_dq_register(xiface, port, dq, num_chans);
+	__cvmx_pko3_ipd_dq_register(xiface, port, dq_base, num_chans);
 
 	return 0;
 }
@@ -570,14 +526,17 @@ static int __cvmx_pko3_config_pfc_interface(int xiface, unsigned port)
 int __cvmx_pko3_config_gen_interface(int xiface, uint8_t subif,
 	uint8_t num_queues, bool prioritized)
 {
+	cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
+	uint8_t node = xi.node;
 	int l1_q_num;
-	int l2_q_num;
+	int parent_q, child_q;
+	int dq;
 	int res, res_owner;
 	int pko_mac_num;
-	int l3_q, l4_q, l5_q, dq;
+	enum cvmx_pko3_level_e level;
 	uint16_t ipd_port;
-	cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int static_pri;
+	char b1[12];
 
 #if defined(__U_BOOT__)
 	num_queues = 1;
@@ -585,10 +544,19 @@ int __cvmx_pko3_config_gen_interface(int xiface, uint8_t subif,
 
 	if (num_queues == 0) {
 		num_queues = 1;
-		cvmx_dprintf("%s: WARNING xiface %#x misconfigured\n",
+		cvmx_printf("WARNING: %s: xiface %#x misconfigured\n",
 			__func__, xiface);
 	}
 
+	/* Configure DQs relative priority (a.k.a. scheduling) */
+	if (prioritized) {
+		/* With 8 queues or fewer, use static priority, else WRR */
+		static_pri = (num_queues < 9)? num_queues: 0;
+	} else {
+		/* Set equal-RR scheduling among queues */
+		static_pri = -1;
+	}
+
 	if (debug)
 		cvmx_dprintf("%s: configuring xiface %u:%u/%u nq=%u %s\n",
 			     __FUNCTION__, xi.node, xi.interface, subif,
@@ -597,8 +565,8 @@ int __cvmx_pko3_config_gen_interface(int xiface, uint8_t subif,
 	/* Get MAC number for the iface/port */
 	pko_mac_num = __cvmx_pko3_get_mac_num(xiface, subif);
 	if (pko_mac_num < 0) {
-		cvmx_dprintf ("%s: ERROR Invalid interface %u:%u\n",
-			__FUNCTION__, xi.node, xi.interface);
+		cvmx_printf ("ERROR: %s: Invalid interface %u:%u\n",
+			__func__, xi.node, xi.interface);
 		return -1;
 	}
 
@@ -612,74 +580,86 @@ int __cvmx_pko3_config_gen_interface(int xiface, uint8_t subif,
 	/* Build an identifiable owner identifier */
 	res_owner = __cvmx_helper_pko3_res_owner(ipd_port);
 
+	level = CVMX_PKO_PORT_QUEUES;
+
 	/* Reserve port queue to make sure the MAC is not already configured */
-	l1_q_num = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_PORT_QUEUES,
-					 res_owner, pko_mac_num, 1);
+	l1_q_num = cvmx_pko_alloc_queues(node, level, res_owner, -1, 1);
 
-	if (l1_q_num != pko_mac_num) {
-		cvmx_dprintf("%s: ERROR xiface %u:%u/%u"
-			" failed allocation L1 SQ\n",
-			__FUNCTION__, xi.node, xi.interface, subif);
+	if (l1_q_num < 0) {
+		cvmx_printf("ERROR %s: xiface %u:%u/%u"
+			" failed allocation L1 PQ\n",
+			__func__, xi.node, xi.interface, subif);
 		return -1;
 	}
 
-	/* allocate or reserve level 2 queues */
-	l2_q_num = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L2_QUEUES, res_owner,
-				-1, 1);
-	if (l2_q_num < 0) {
-		cvmx_dprintf("%s: ERROR xiface %u:%u/%u"
-			"  failed allocation L2 SQ\n",
-			__FUNCTION__, xi.node, xi.interface, subif);
+	res = cvmx_pko3_pq_config(node, pko_mac_num, l1_q_num);
+	if (res < 0) {
+                cvmx_printf ("ERROR %s: Configuring L1 PQ\n", __func__);
 		return -1;
 	}
 
+	parent_q = l1_q_num;
 
-	/* Configre L2 SQ */
-	res = cvmx_pko3_pq_config_children(xi.node, pko_mac_num,
-				l2_q_num, 1, 1);
+	/* Determine the next queue level */
+	level = __cvmx_pko3_sq_lvl_next(level);
 
-	if (res < 0) {
-		cvmx_dprintf("%s: ERROR xiface %u:%u/%u"
-			" failed configuring PQ\n",
-			__FUNCTION__, xi.node, xi.interface, subif);
+	/* Simply chain queues 1-to-1 from L2 to one before DQ level */
+	do {
+
+		/* allocate next level queue */
+		child_q = cvmx_pko_alloc_queues(node, level, res_owner, -1, 1);
+
+		if (child_q < 0) {
+			cvmx_printf ("ERROR: %s: allocating %s\n",
+				__func__,
+				__cvmx_pko3_sq_str(b1, level, child_q));
+			return -1;
+		}
+
+		/* Configre newly allocated queue */
+		res = cvmx_pko3_sq_config_children(node, level,
+			parent_q, child_q, 1, 1);
+
+		if (res < 0) {
+			cvmx_printf ("ERROR: %s: configuring %s\n",
+				__func__,
+				__cvmx_pko3_sq_str(b1, level, child_q));
+			return -1;
+		}
+
+		/* map IPD/channel to L2/L3 queues */
+		if (level == cvmx_pko_default_channel_level)
+			cvmx_pko3_map_channel(node,
+				l1_q_num, child_q, ipd_port);
+
+		/* Prepare for next level */
+		level = __cvmx_pko3_sq_lvl_next(level);
+		parent_q = child_q;
+
+	/* Terminate loop on DQ level, it has special handling */
+	} while (level != CVMX_PKO_DESCR_QUEUES &&
+		level != CVMX_PKO_LEVEL_INVAL);
+
+	if (level != CVMX_PKO_DESCR_QUEUES) {
+		cvmx_printf("ERROR: %s: level sequence error\n", __func__);
 		return -1;
 	}
 
-	l3_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L3_QUEUES,
-				res_owner, -1, 1);
-	l4_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L4_QUEUES,
-				res_owner, -1, 1);
-	l5_q = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_L5_QUEUES,
-				res_owner, -1, 1);
-	dq = cvmx_pko_alloc_queues(xi.node, CVMX_PKO_DESCR_QUEUES,
-				res_owner, -1, num_queues);
+	/* Allocate descriptor queues for the port */
+	dq = cvmx_pko_alloc_queues(node, level, res_owner, -1, num_queues);
 	if (dq < 0) {
-		cvmx_dprintf("%s: ERROR xiface %u:%u/%u"
-			" failed configuring DQs\n",
-			__FUNCTION__, xi.node, xi.interface, subif);
+		cvmx_printf("ERROR: %s: could not reserve DQs\n", __func__);
 		return -1;
 	}
 
-	/* Configure hierarchy */
-	cvmx_pko3_sq_config_children(xi.node, 2, l2_q_num, l3_q, 1, 1);
-	cvmx_pko3_sq_config_children(xi.node, 3, l3_q, l4_q, 1, 1);
-	cvmx_pko3_sq_config_children(xi.node, 4, l4_q, l5_q, 1, 1);
-
-	/* Configure DQs relative priority (a.k.a. scheduling) */
-	if (prioritized) {
-		/* With 8 queues or fewer, use static priority, else WRR */
-		static_pri = (num_queues < 9)? num_queues: 0;
-	} else {
-		/* Set equal-RR scheduling among queues */
-		static_pri = -1;
+	res = cvmx_pko3_sq_config_children(node, level, parent_q,
+		dq, num_queues, static_pri);
+	if (res < 0) {
+		cvmx_printf ("ERROR: %s: configuring %s\n", __func__,
+				__cvmx_pko3_sq_str(b1, level, dq));
+		return -1;
 	}
 
-	cvmx_pko3_sq_config_children(xi.node, 5, l5_q, dq,
-		num_queues, static_pri);
-
-	/* map IPD/channel to L2 queues */
-	cvmx_pko3_map_channel(xi.node, l1_q_num, l2_q_num, ipd_port);
-
 	/* register DQ/IPD translation */
 	__cvmx_pko3_ipd_dq_register(xiface, subif, dq, num_queues);
 
@@ -705,13 +685,21 @@ EXPORT_SYMBOL(__cvmx_pko3_config_gen_interface);
 static int __cvmx_pko3_config_null_interface(unsigned int node)
 {
 	int l1_q_num;
-	int l2_q_num;
-	int l3_q, l4_q, l5_q;
+	int parent_q, child_q;
+	enum cvmx_pko3_level_e level;
 	int i, res, res_owner;
 	int xiface, ipd_port;
 	int num_dq = 1;	/* # of DQs for NULL */
 	const int dq = 0;	/* Reserve DQ#0 for NULL */
-	const int pko_mac_num = 0x1C; /* MAC# 28 virtual MAC for NULL */
+	char pko_mac_num;
+	char b1[12];
+
+	if(OCTEON_IS_MODEL(OCTEON_CN78XX))
+		pko_mac_num = 0x1C; /* MAC# 28 virtual MAC for NULL */
+	else if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+		pko_mac_num = 0x0F; /* MAC# 16 !? virtual MAC for NULL */
+	else
+		return -1;
 
 	if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0))
 		num_dq = 8;
@@ -729,50 +717,79 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 		return -1;
 	}
 
-	/* Reserve port queue to make sure the MAC is not already configured */
-	l1_q_num = cvmx_pko_alloc_queues(node, CVMX_PKO_PORT_QUEUES,
-				res_owner, pko_mac_num, 1);
+	level = CVMX_PKO_PORT_QUEUES;
+
+	/* Allocate a port queue */
+	l1_q_num = cvmx_pko_alloc_queues(node, level, res_owner, -1, 1);
 
-	if (l1_q_num != pko_mac_num) {
-		cvmx_dprintf ("%s: ERROR reserving L1 SQ\n", __FUNCTION__);
+	if (l1_q_num < 0) {
+		cvmx_dprintf ("%s: ERROR reserving L1 SQ\n", __func__);
 		return -1;
 	}
 
-	/* allocate or reserve level 2 queues */
-	l2_q_num = cvmx_pko_alloc_queues(node, CVMX_PKO_L2_QUEUES, res_owner,
-				-1, 1);
-	if (l2_q_num < 0) {
-		cvmx_dprintf ("%s: ERROR allocating L2 SQ\n", __FUNCTION__);
+	res = cvmx_pko3_pq_config(node, pko_mac_num, l1_q_num);
+	if (res < 0) {
+		cvmx_printf("ERROR: %s: PQ/L1 queue configuration\n", __func__);
 		return -1;
 	}
 
+	parent_q = l1_q_num;
 
-	/* Configre L2 SQ */
-	res = cvmx_pko3_pq_config_children(node, pko_mac_num, l2_q_num, 1, 1);
+	/* Determine the next queue level */
+	level = __cvmx_pko3_sq_lvl_next(level);
 
-	if (res < 0) {
-		cvmx_dprintf("%s: ERROR: L2 queue\n", __FUNCTION__);
+	/* Simply chain queues 1-to-1 from L2 to one before DQ level */
+	do {
+
+		/* allocate next level queue */
+		child_q = cvmx_pko_alloc_queues(node, level, res_owner, -1, 1);
+
+		if (child_q < 0) {
+			cvmx_printf ("ERROR: %s: allocating %s\n",
+				__func__,
+				__cvmx_pko3_sq_str(b1, level, child_q));
+			return -1;
+		}
+
+		/* Configre newly allocated queue */
+		res = cvmx_pko3_sq_config_children(node, level,
+			parent_q, child_q, 1, 1);
+
+		if (res < 0) {
+			cvmx_printf ("ERROR: %s: configuring %s\n",
+				__func__,
+				__cvmx_pko3_sq_str(b1, level, child_q));
+			return -1;
+		}
+
+		/* Prepare for next level */
+		level = __cvmx_pko3_sq_lvl_next(level);
+		parent_q = child_q;
+
+	/* Terminate loop on DQ level, it has special handling */
+	} while (level != CVMX_PKO_DESCR_QUEUES &&
+		level != CVMX_PKO_LEVEL_INVAL);
+
+	if (level != CVMX_PKO_DESCR_QUEUES) {
+		cvmx_printf("ERROR: %s: level sequence error\n", __func__);
 		return -1;
 	}
 
-	l3_q = cvmx_pko_alloc_queues(node, CVMX_PKO_L3_QUEUES, res_owner,-1, 1);
-	l4_q = cvmx_pko_alloc_queues(node, CVMX_PKO_L4_QUEUES, res_owner,-1, 1);
-	l5_q = cvmx_pko_alloc_queues(node, CVMX_PKO_L5_QUEUES, res_owner,-1, 1);
-
-	/* Reserve DQ at 0 by convention */
-	res = cvmx_pko_alloc_queues(node, CVMX_PKO_DESCR_QUEUES, res_owner,
-		dq, num_dq);
+	/* Reserve 'num_dq' DQ's at 0 by convention */
+	res = cvmx_pko_alloc_queues(node, level, res_owner, dq, num_dq);
 	if (dq != res) {
 		cvmx_dprintf("%s: ERROR: could not reserve DQs\n",
 			__FUNCTION__);
 		return -1;
 	}
 
-	/* Configure hierarchy */
-	cvmx_pko3_sq_config_children(node, 2, l2_q_num, l3_q, 1, 1);
-	cvmx_pko3_sq_config_children(node, 3, l3_q, l4_q, 1, 1);
-	cvmx_pko3_sq_config_children(node, 4, l4_q, l5_q, 1, 1);
-	cvmx_pko3_sq_config_children(node, 5, l5_q, dq, num_dq, num_dq);
+	res = cvmx_pko3_sq_config_children(node, level, parent_q,
+		dq, num_dq, num_dq);
+	if (res < 0) {
+		cvmx_printf ("ERROR: %s: configuring %s\n", __func__,
+				__cvmx_pko3_sq_str(b1, level, dq));
+		return -1;
+	}
 
 	/* NULL interface does not need to map to a CHAN_E */
 
@@ -798,7 +815,7 @@ int __cvmx_pko3_helper_dqs_activate(int xiface, int index, bool min_pad)
 	/* Get local IPD port for the interface */
 	ipd_port = cvmx_helper_get_ipd_port(xiface, index);
 	if(ipd_port < 0) {
-		cvmx_dprintf("%s: ERROR: No IPD port for interface %d port %d\n",
+		cvmx_printf("ERROR: %s: No IPD port for interface %d port %d\n",
 			     __FUNCTION__, xiface, index);
 		return -1;
 	}
@@ -807,7 +824,7 @@ int __cvmx_pko3_helper_dqs_activate(int xiface, int index, bool min_pad)
 	dq_base = cvmx_pko3_get_queue_base(ipd_port);
 	dq_count = cvmx_pko3_get_queue_num(ipd_port);
 	if( dq_base < 0 || dq_count <= 0) {
-		cvmx_dprintf("%s: ERROR: No descriptor queues for interface %d port %d\n",
+		cvmx_printf("ERROR: %s: No descriptor queues for interface %d port %d\n",
 			     __FUNCTION__, xiface, index);
 		return -1;
 	}
@@ -872,10 +889,15 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		num_ports =  __cvmx_helper_ilk_enumerate(xiface);
 
 	/* Skip non-existent interfaces */
-	if(num_ports < 1) {
+	if (num_ports < 1) {
 		cvmx_dprintf("ERROR: %s: invalid iface %u:%u\n",
 			     __FUNCTION__, xi.node, xi.interface);
 		return -1;
+	} else if (num_ports == 1 && (
+		mode == CVMX_HELPER_INTERFACE_MODE_XAUI ||
+		mode == CVMX_HELPER_INTERFACE_MODE_XLAUI)) {
+		/* Force PFC for 4-lane interfaces */
+		pfc = true;
 	}
 
 	if (mode == CVMX_HELPER_INTERFACE_MODE_LOOP) {
@@ -916,8 +938,11 @@ int cvmx_helper_pko3_init_interface(int xiface)
 
 	/* ILK-specific queue configuration */
 	else if (mode == CVMX_HELPER_INTERFACE_MODE_ILK) {
+		unsigned num_chans = __cvmx_helper_ilk_enumerate(xiface);
 		num_queues = 8; qos = true; pfc = false;
-		res = __cvmx_pko3_config_ilk_interface(xiface, num_queues, qos);
+//		res = __cvmx_pko3_config_ilk_interface(xiface, num_queues, qos);
+		res = __cvmx_pko3_config_chan_interface(xiface, num_chans,
+				num_queues, qos);
 	}
 
 	/* Setup all ethernet configured for PFC */
@@ -962,6 +987,12 @@ int cvmx_helper_pko3_init_interface(int xiface)
 
 	/* Setup interface options */
 	for (subif = 0; subif < num_ports; subif++) {
+		int num_bgx_interfaces = 0;
+
+		if(OCTEON_IS_MODEL(OCTEON_CN78XX))
+			num_bgx_interfaces = 6;
+		if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+			num_bgx_interfaces = 3;
 
 		/* Open interface/port DQs to allow transmission to begin */
 		res = __cvmx_pko3_helper_dqs_activate(xiface,
@@ -982,7 +1013,7 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		if (mode == CVMX_HELPER_INTERFACE_MODE_NPI && subif > 0)
 			continue;
 
-		if (xi.interface > 5) {
+		if (xi.interface >= num_bgx_interfaces) {
 			/* Non-BGX interface, use PKO for FCS/PAD */
 			res = cvmx_pko3_interface_options(xiface, subif,
 				fcs_enable, pad_enable_pko, fcs_sof_off);
@@ -1038,8 +1069,7 @@ int __cvmx_helper_pko3_init_global(unsigned int node, uint16_t gaura)
 	}
 
 	/* configure channel level */
-	cvmx_pko_setup_channel_credit_level(node,
-		cvmx_pko_default_channel_level);
+	cvmx_pko3_channel_credit_level(node, cvmx_pko_default_channel_level);
 
 	/* add NULL MAC/DQ setup */
 	res = __cvmx_pko3_config_null_interface(node);
@@ -1158,6 +1188,7 @@ int cvmx_helper_pko3_shut_interface(int xiface)
 	int dq_base, dq_count;
 	uint16_t ipd_port;
 	int i, res_owner, res;
+	enum cvmx_pko3_level_e level;
 	uint64_t cycles;
 	const unsigned timeout = 10;	/* milliseconds */
 	cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
@@ -1256,12 +1287,12 @@ int cvmx_helper_pko3_shut_interface(int xiface)
 			continue;
 		}
 
-		cvmx_pko_free_queues(xi.node, CVMX_PKO_DESCR_QUEUES, res_owner);
-		cvmx_pko_free_queues(xi.node, CVMX_PKO_L5_QUEUES, res_owner);
-		cvmx_pko_free_queues(xi.node, CVMX_PKO_L4_QUEUES, res_owner);
-		cvmx_pko_free_queues(xi.node, CVMX_PKO_L3_QUEUES, res_owner);
-		cvmx_pko_free_queues(xi.node, CVMX_PKO_L2_QUEUES, res_owner);
-		cvmx_pko_free_queues(xi.node, CVMX_PKO_PORT_QUEUES, res_owner);
+		/* Actuall PQ/SQ/DQ associations left intact */
+		for(level = CVMX_PKO_PORT_QUEUES;
+		    level != CVMX_PKO_LEVEL_INVAL;
+		    level = __cvmx_pko3_sq_lvl_next(level)) {
+			cvmx_pko_free_queues(xi.node, level, res_owner);
+		}
 
 	} /* for port */
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 432ec88..3c5cdb0 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -160,6 +160,23 @@ static const struct ipd_port_map ipd_port_map_78xx[CVMX_HELPER_MAX_IFACE] = {
 	{LB,	0x000,	0x03f,	0x00},		/* Interface 9 - LOOPBACK */
 };
 
+/**
+ * @INTERNAL
+ * Interface number to ipd port map for the octeon 78xx.
+ *
+ * This mapping corresponds to WQE(CHAN) enumeration in
+ * HRM Sections 11.15, MKI_CHAN_E, Section 11.6
+ *
+ */
+static const struct ipd_port_map ipd_port_map_73xx[CVMX_HELPER_MAX_IFACE] = {
+	{GMII,	0x800,	0x83f,	0x00},		/* Interface 0 - BGX0 */
+	{GMII,	0x900,	0x93f,	0x00},		/* Interface 1  -BGX1 */
+	{GMII,	0xa00,	0xa3f,	0x00},		/* Interface 2  -BGX2 */
+	{NPI,	0x100,	0x13f,	0x00},		/* Interface 3 - DPI */
+	{LB,	0x000,	0x03f,	0x00},		/* Interface 4 - LOOPBACK */
+};
+
+
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 /**
  * Get the version of the CVMX libraries.
@@ -942,6 +959,9 @@ int cvmx_helper_get_ipd_port(int xiface, int index)
 		} else if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 			port_map = ipd_port_map_78xx;
 			ipd_port = cvmx_helper_node_to_ipd_port(xi.node, 0);
+		} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+			port_map = ipd_port_map_73xx;
+			ipd_port = 0;
 		}
 		else
 			return -1;
@@ -1074,6 +1094,17 @@ int cvmx_helper_get_interface_num(int ipd_port)
 				return cvmx_helper_node_interface_to_xiface(xp.node, i);
 		}
 		return -1;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		const struct ipd_port_map	*port_map;
+		int				i;
+		struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+		port_map = ipd_port_map_73xx;
+		for (i = 0; i < CVMX_HELPER_MAX_IFACE; i++) {
+			if (xp.port >= port_map[i].first_ipd_port &&
+			    xp.port <= port_map[i].last_ipd_port)
+				return cvmx_helper_node_interface_to_xiface(xp.node, i);
+		}
+		return -1;
 	} else if (OCTEON_IS_MODEL(OCTEON_CN70XX) && ipd_port == 24) {
 		return 4;
 	} else {
@@ -1124,6 +1155,11 @@ int cvmx_helper_get_interface_index_num(int ipd_port)
 			port_map = ipd_port_map_78xx;
 			ipd_port = xp.port;
 		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+			struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+			port_map = ipd_port_map_73xx;
+			ipd_port = xp.port;
+		}
 		else
 			return -1;
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index 6d627a4..5ab09ba 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -683,6 +683,8 @@ int cvmx_helper_get_number_of_interfaces(void)
 		return 5;
 	else if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 10;
+	else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return 5;
 	else
 		return 3;
 }
@@ -824,6 +826,49 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn78xx(int xiface)
 
 /**
  * @INTERNAL
+ * Return interface mode for CN73XX.
+ */
+static cvmx_helper_interface_mode_t __cvmx_get_mode_cn73xx(int interface)
+{
+	/* SGMII/XAUI/XLAUI/XFI */
+	if (interface < 3) {
+		int qlm = cvmx_qlm_interface(interface);
+		enum cvmx_qlm_mode qlm_mode;
+
+		if (qlm == -1) {
+			iface_ops[interface] = &iface_ops_dis;
+			return iface_ops[interface]->mode;
+		}
+		qlm_mode = cvmx_qlm_get_mode(qlm);
+
+		if (qlm_mode == CVMX_QLM_MODE_SGMII)
+			iface_ops[interface] = &iface_ops_bgx_sgmii;
+		else if (qlm_mode == CVMX_QLM_MODE_XAUI)
+			iface_ops[interface] = &iface_ops_bgx_xaui;
+		else if (qlm_mode == CVMX_QLM_MODE_RXAUI)
+			iface_ops[interface] = &iface_ops_bgx_rxaui;
+		else if (qlm_mode == CVMX_QLM_MODE_XLAUI)
+			iface_ops[interface] = &iface_ops_bgx_xlaui;
+		else if (qlm_mode == CVMX_QLM_MODE_XFI)
+			iface_ops[interface] = &iface_ops_bgx_xfi;
+		else if (qlm_mode == CVMX_QLM_MODE_10G_KR)
+			iface_ops[interface] = &iface_ops_bgx_10G_KR;
+		else if (qlm_mode == CVMX_QLM_MODE_40G_KR4)
+			iface_ops[interface] = &iface_ops_bgx_40G_KR4;
+		else
+			iface_ops[interface] = &iface_ops_dis;
+	} else if (interface == 3) /* DPI */
+		iface_ops[interface] = &iface_ops_npi;
+	else if (interface == 4) /* LOOP */
+		iface_ops[interface] = &iface_ops_loop;
+	else
+		iface_ops[interface] = &iface_ops_dis;
+
+	return iface_ops[interface]->mode;
+}
+
+/**
+ * @INTERNAL
  * Return interface mode for CN68xx.
  */
 static cvmx_helper_interface_mode_t __cvmx_get_mode_cn68xx(int interface)
@@ -1073,6 +1118,9 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int xiface)
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return __cvmx_get_mode_cn78xx(xiface);
 
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return __cvmx_get_mode_cn73xx(xiface);
+
 	/*
 	 * Octeon II models
 	 */
@@ -1292,7 +1340,7 @@ EXPORT_SYMBOL(cvmx_helper_interface_probe);
  *
  * @return Zero on success, negative on failure
  */
-static int __cvmx_helper_global_setup_backpressure(void)
+static int __cvmx_helper_global_setup_backpressure(int node)
 {
 	if (cvmx_rgmii_backpressure_dis) {
 		/* Disable backpressure if configured to do so */
@@ -1300,7 +1348,8 @@ static int __cvmx_helper_global_setup_backpressure(void)
 		int num_interfaces = cvmx_helper_get_number_of_interfaces();
 		int interface;
 		for (interface = 0; interface < num_interfaces; interface++) {
-			switch (cvmx_helper_interface_get_mode(interface)) {
+			int xiface = cvmx_helper_node_interface_to_xiface(node, interface);	
+			switch (cvmx_helper_interface_get_mode(xiface)) {
 			case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 			case CVMX_HELPER_INTERFACE_MODE_PCIE:
 			case CVMX_HELPER_INTERFACE_MODE_SRIO:
@@ -1321,7 +1370,7 @@ static int __cvmx_helper_global_setup_backpressure(void)
 			case CVMX_HELPER_INTERFACE_MODE_QSGMII:
 			case CVMX_HELPER_INTERFACE_MODE_PICMG:
 				if (octeon_has_feature(OCTEON_FEATURE_BGX))
-					cvmx_bgx_set_backpressure_override(interface, 0xf);
+					cvmx_bgx_set_backpressure_override(xiface, 0xf);
 				else
 					cvmx_gmx_set_backpressure_override(interface, 0xf);
 				break;
@@ -1470,7 +1519,6 @@ int __cvmx_helper_packet_hardware_enable(int xiface)
 	int result = 0;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
-	cvmx_helper_interface_get_mode(xiface);
 	if (iface_node_ops[xi.node][xi.interface]->enable)
 		result = iface_node_ops[xi.node][xi.interface]->enable(xiface);
 	result |= __cvmx_helper_board_hardware_enable(xiface);
@@ -1547,6 +1595,7 @@ int cvmx_helper_initialize_packet_io_node(unsigned int node)
 {
 	int result = 0;
 	int interface;
+	int xiface;
 	union cvmx_l2c_cfg l2c_cfg;
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	union cvmx_smix_en smix_en;
@@ -1587,6 +1636,8 @@ int cvmx_helper_initialize_packet_io_node(unsigned int node)
 		if (OCTEON_IS_MODEL(OCTEON_CN68XX) ||
 		    OCTEON_IS_MODEL(OCTEON_CN78XX))
 			smi_inf = 4;
+		else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+			smi_inf = 2;
 		else if (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
 			 OCTEON_IS_MODEL(OCTEON_CN58XX) ||
 			 OCTEON_IS_MODEL(OCTEON_CN50XX))
@@ -1605,10 +1656,12 @@ int cvmx_helper_initialize_packet_io_node(unsigned int node)
 	}
 #endif
 
-	__cvmx_helper_init_port_valid();
+	__cvmx_helper_init_port_valid();//vinita_to_do ask it need to be modify for multinode
 
-	for (interface = 0; interface < num_interfaces; interface++)
-		result |= cvmx_helper_interface_probe(interface);
+	for (interface = 0; interface < num_interfaces; interface++) {
+		xiface = cvmx_helper_node_interface_to_xiface(node, interface);
+		result |= cvmx_helper_interface_probe(xiface);
+	}
 
 	/* PKO3 init precedes that of interfaces */
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
@@ -1623,17 +1676,18 @@ int cvmx_helper_initialize_packet_io_node(unsigned int node)
 		return result;
 
 	for (interface = 0; interface < num_interfaces; interface++) {
+		xiface = cvmx_helper_node_interface_to_xiface(node, interface);
 		/* Skip invalid/disabled interfaces */
-		if (cvmx_helper_ports_on_interface(interface) <= 0)
+		if (cvmx_helper_ports_on_interface(xiface) <= 0)
 			continue;
-		cvmx_printf("Interface %d has %d ports (%s)\n",
+		cvmx_printf("Node %d Interface %d has %d ports (%s)\n", node,
 			    interface,
-			    cvmx_helper_ports_on_interface(interface),
-			    cvmx_helper_interface_mode_to_string(cvmx_helper_interface_get_mode(interface)));
+			    cvmx_helper_ports_on_interface(xiface),
+			    cvmx_helper_interface_mode_to_string(cvmx_helper_interface_get_mode(xiface)));
 
-		result |= __cvmx_helper_ipd_setup_interface(interface);
+		result |= __cvmx_helper_ipd_setup_interface(xiface);
 		if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
-			result |= cvmx_helper_pko3_init_interface(cvmx_helper_node_interface_to_xiface(node, interface));
+			result |= cvmx_helper_pko3_init_interface(xiface);
 		else
 			result |= __cvmx_helper_interface_setup_pko(interface);
 	}
@@ -1644,7 +1698,7 @@ int cvmx_helper_initialize_packet_io_node(unsigned int node)
 		result |= __cvmx_helper_ipd_global_setup();
 
 	/* Enable any flow control and backpressure */
-	result |= __cvmx_helper_global_setup_backpressure();
+	result |= __cvmx_helper_global_setup_backpressure(node);
 
 	/* export app config if set */
 	if (cvmx_export_app_config) {
@@ -1760,22 +1814,25 @@ int cvmx_agl_set_backpressure_override(uint32_t interface, uint32_t port_mask)
  * @return 0 on success
  *         -1 on error
  */
-int cvmx_bgx_set_backpressure_override(uint32_t interface, uint32_t port_mask)
+int cvmx_bgx_set_backpressure_override(uint32_t xiface, uint32_t port_mask)
 {
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	cvmx_bgxx_cmr_rx_ovr_bp_t rx_ovr_bp;
+	int node = xi.node;
+	int interface = xi.interface;
 
 	/* Check for valid arguments */
 	rx_ovr_bp.u64 = 0;
 	rx_ovr_bp.s.en = port_mask;	/* Per port Enable back pressure override */
 	rx_ovr_bp.s.ign_fifo_bp = port_mask;	/* Ignore the RX FIFO full when computing BP */
-	cvmx_write_csr(CVMX_BGXX_CMR_RX_OVR_BP(interface), rx_ovr_bp.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_OVR_BP(interface), rx_ovr_bp.u64);
 	return 0;
 }
 
 /**
  * Helper function for global packet IO shutdown
  */
-static int __cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
+int cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
 {
 	int num_interfaces = cvmx_helper_get_number_of_interfaces();
 	int interface;
@@ -1783,7 +1840,8 @@ static int __cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
 
 	/* Shut down all interfaces and disable TX and RX on all ports */
 	for (interface = 0; interface < num_interfaces; interface++) {
-		switch (cvmx_helper_interface_get_mode(interface)) {
+		int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
+		switch (cvmx_helper_interface_get_mode(xiface)) {
 		case CVMX_HELPER_INTERFACE_MODE_XAUI:
 		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		case CVMX_HELPER_INTERFACE_MODE_XLAUI:
@@ -1793,34 +1851,34 @@ static int __cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
 		{
 			cvmx_bgxx_cmrx_config_t cmr_config;
 			int index;
-			int num_ports = cvmx_helper_ports_on_interface(interface);
+			int num_ports = cvmx_helper_ports_on_interface(xiface);
 			if (num_ports > 4)
 				num_ports = 4;
 
-			cvmx_bgx_set_backpressure_override(interface, 0xf);
+			cvmx_bgx_set_backpressure_override(xiface, 0xf);
 			for (index = 0; index < num_ports; index++) {
-				if (!cvmx_helper_is_port_valid(interface, index))
+				if (!cvmx_helper_is_port_valid(xiface, index))
 					continue;
 
 				/* Disable GMX before we make any changes. Remember the enable state */
-				cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(index, interface));
+				cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
 				cmr_config.s.enable = 0;
-				cvmx_write_csr(CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+				cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
 
 				/* Clear all error interrupts before enabling the interface. */
 				if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-					cvmx_write_csr(CVMX_BGXX_SMUX_RX_INT(index, interface), ~0x0ull);
-					cvmx_write_csr(CVMX_BGXX_SMUX_TX_INT(index, interface), ~0x0ull);
-					cvmx_write_csr(CVMX_BGXX_SPUX_INT(index, interface), ~0x0ull);
+					cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface), ~0x0ull);
+					cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface), ~0x0ull);
+					cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), ~0x0ull);
 				}
 
 				/* Wait for GMX RX to be idle */
-				if (CVMX_WAIT_FOR_FIELD64(CVMX_BGXX_SMUX_CTRL(index, interface),
+				if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
 				  			cvmx_bgxx_smux_ctrl_t, rx_idle, ==, 1, 10000))
 					return -1;
 
 				/* Wait for GMX TX to be idle */
-				if (CVMX_WAIT_FOR_FIELD64(CVMX_BGXX_SMUX_CTRL(index, interface),
+				if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SMUX_CTRL(index, interface),
 				  			cvmx_bgxx_smux_ctrl_t, tx_idle, ==, 1, 10000))
 					return -1;
 
@@ -1832,31 +1890,31 @@ static int __cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
 		{
 			cvmx_bgxx_cmrx_config_t cmr_config;
 			int index;
-			int num_ports = cvmx_helper_ports_on_interface(interface);
+			int num_ports = cvmx_helper_ports_on_interface(xiface);
 			if (num_ports > 4)
 				num_ports = 4;
 
-			cvmx_bgx_set_backpressure_override(interface, 0xf);
+			cvmx_bgx_set_backpressure_override(xiface, 0xf);
 			for (index = 0; index < num_ports; index++) {
-				if (!cvmx_helper_is_port_valid(interface, index))
+				if (!cvmx_helper_is_port_valid(xiface, index))
 					continue;
 				/* Disable GMX before we make any changes. Remember the enable state */
-				cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(index, interface));
+				cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
 				cmr_config.s.enable = 0;
-				cvmx_write_csr(CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+				cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
 
 				/* Wait for GMX to be idle */
-				if (CVMX_WAIT_FOR_FIELD64(CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface),
+				if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface),
 				  		cvmx_bgxx_gmp_gmi_prtx_cfg_t, rx_idle, ==, 1, 10000) ||
-	    		    	CVMX_WAIT_FOR_FIELD64(CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface),
+	    		    	CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface),
 						cvmx_bgxx_gmp_gmi_prtx_cfg_t, tx_idle, ==, 1, 10000)) {
-					cvmx_dprintf("SGMII%d: Timeout waiting for port %d to be idle\n",
-			     				interface, index);
+					cvmx_dprintf("%d:SGMII%d: Timeout waiting for port %d to be idle\n",
+			     				node, interface, index);
 					return -1;
 				}
 
 				/* Read GMX CFG again to make sure the disable completed */
-				cvmx_read_csr(CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface));
+				cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(index, interface));
 			}
 			break;
 		}
@@ -1948,7 +2006,7 @@ int cvmx_helper_shutdown_packet_io_global(void)
 	cvmx_pcsx_mrx_control_reg_t control_reg;
 
 	if (octeon_has_feature(OCTEON_FEATURE_BGX)) {
-		return __cvmx_helper_shutdown_packet_io_global_cn78xx(node);
+		return cvmx_helper_shutdown_packet_io_global_cn78xx(node);
 	}
 
 	/* Step 1: Disable all backpressure */
@@ -2344,37 +2402,39 @@ int cvmx_helper_shutdown_packet_io_local(void)
  * function basically does the equivalent of:
  * cvmx_helper_link_set(ipd_port, cvmx_helper_link_get(ipd_port));
  *
- * @param ipd_port IPD/PKO port to auto configure
+ * @param xipd_port IPD/PKO port to auto configure
  *
  * @return Link state after configure
  */
-cvmx_helper_link_info_t cvmx_helper_link_autoconf(int ipd_port)
+cvmx_helper_link_info_t cvmx_helper_link_autoconf(int xipd_port)
 {
 	cvmx_helper_link_info_t link_info;
-	int interface = cvmx_helper_get_interface_num(ipd_port);
-	int index = cvmx_helper_get_interface_index_num(ipd_port);
+	int xiface = cvmx_helper_get_interface_num(xipd_port);
+	int index = cvmx_helper_get_interface_index_num(xipd_port);
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	int interface = xi.interface;
 
 	if (interface == -1 || index == -1 ||
-	    index >= cvmx_helper_ports_on_interface(interface)) {
+	    index >= cvmx_helper_ports_on_interface(xiface)) {
 		link_info.u64 = 0;
 		return link_info;
 	}
 
-	link_info = cvmx_helper_link_get(ipd_port);
-	if (link_info.u64 == (__cvmx_helper_get_link_info(interface, index)).u64)
+	link_info = cvmx_helper_link_get(xipd_port);
+	if (link_info.u64 == (__cvmx_helper_get_link_info(xiface, index)).u64)
 		return link_info;
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	if (!link_info.s.link_up)
-		cvmx_error_disable_group(CVMX_ERROR_GROUP_ETHERNET, ipd_port);
+		cvmx_error_disable_group(CVMX_ERROR_GROUP_ETHERNET, xipd_port);
 #endif
 
 	/* If we fail to set the link speed, port_link_info will not change */
-	cvmx_helper_link_set(ipd_port, link_info);
+	cvmx_helper_link_set(xipd_port, link_info);
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	if (link_info.s.link_up)
-		cvmx_error_enable_group(CVMX_ERROR_GROUP_ETHERNET, ipd_port);
+		cvmx_error_enable_group(CVMX_ERROR_GROUP_ETHERNET, xipd_port);
 #endif
 
 	return link_info;
@@ -2387,15 +2447,15 @@ EXPORT_SYMBOL(cvmx_helper_link_autoconf);
  * Octeon's link config if auto negotiation has changed since
  * the last call to cvmx_helper_link_set().
  *
- * @param ipd_port IPD/PKO port to query
+ * @param xipd_port IPD/PKO port to query
  *
  * @return Link state
  */
-cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port)
+cvmx_helper_link_info_t cvmx_helper_link_get(int xipd_port)
 {
 	cvmx_helper_link_info_t result;
-	int xiface = cvmx_helper_get_interface_num(ipd_port);
-	int index = cvmx_helper_get_interface_index_num(ipd_port);
+	int xiface = cvmx_helper_get_interface_num(xipd_port);
+	int index = cvmx_helper_get_interface_index_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
 	/*
@@ -2408,9 +2468,8 @@ cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port)
 	    index >= cvmx_helper_ports_on_interface(xiface))
 		return result;
 
-	cvmx_helper_interface_get_mode(xiface);
 	if (iface_node_ops[xi.node][xi.interface]->link_get)
-		result = iface_node_ops[xi.node][xi.interface]->link_get(ipd_port);
+		result = iface_node_ops[xi.node][xi.interface]->link_get(xipd_port);
 
 	return result;
 }
@@ -2423,25 +2482,24 @@ EXPORT_SYMBOL(cvmx_helper_link_get);
  * by cvmx_helper_link_get(). It is normally best to use
  * cvmx_helper_link_autoconf() instead.
  *
- * @param ipd_port  IPD/PKO port to configure
+ * @param xipd_port  IPD/PKO port to configure
  * @param link_info The new link state
  *
  * @return Zero on success, negative on failure
  */
-int cvmx_helper_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
+int cvmx_helper_link_set(int xipd_port, cvmx_helper_link_info_t link_info)
 {
 	int result = -1;
-	int xiface = cvmx_helper_get_interface_num(ipd_port);
+	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int index = cvmx_helper_get_interface_index_num(ipd_port);
+	int index = cvmx_helper_get_interface_index_num(xipd_port);
 
 	if (__cvmx_helper_xiface_is_null(xiface) || index == -1 ||
 	    index >= cvmx_helper_ports_on_interface(xiface))
 		return -1;
 
-	cvmx_helper_interface_get_mode(xiface);
 	if (iface_node_ops[xi.node][xi.interface]->link_set)
-		result = iface_node_ops[xi.node][xi.interface]->link_set(ipd_port, link_info);
+		result = iface_node_ops[xi.node][xi.interface]->link_set(xipd_port, link_info);
 
 	/*
 	 * Set the port_link_info here so that the link status is
@@ -2459,7 +2517,7 @@ EXPORT_SYMBOL(cvmx_helper_link_set);
  * causes packets sent by the port to be received by Octeon. External loopback
  * causes packets received from the wire to sent out again.
  *
- * @param ipd_port IPD/PKO port to loopback.
+ * @param xipd_port IPD/PKO port to loopback.
  * @param enable_internal
  *                 Non zero if you want internal loopback
  * @param enable_external
@@ -2467,20 +2525,20 @@ EXPORT_SYMBOL(cvmx_helper_link_set);
  *
  * @return Zero on success, negative on failure.
  */
-int cvmx_helper_configure_loopback(int ipd_port, int enable_internal,
+int cvmx_helper_configure_loopback(int xipd_port, int enable_internal,
 				   int enable_external)
 {
 	int result = -1;
-	int xiface = cvmx_helper_get_interface_num(ipd_port);
+	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int index = cvmx_helper_get_interface_index_num(ipd_port);
+	int index = cvmx_helper_get_interface_index_num(xipd_port);
 
 	if (index >= cvmx_helper_ports_on_interface(xiface))
 		return -1;
 
 	cvmx_helper_interface_get_mode(xiface);
 	if (iface_node_ops[xi.node][xi.interface]->loopback)
-		result = iface_node_ops[xi.node][xi.interface]->loopback(ipd_port,
+		result = iface_node_ops[xi.node][xi.interface]->loopback(xipd_port,
 									 enable_internal,
 									 enable_external);
 
@@ -2506,9 +2564,17 @@ void *cvmx_helper_mem_alloc(int node, uint64_t alloc_size, uint64_t align)
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 	return kmalloc(alloc_size, GFP_NOIO | GFP_DMA);
 #else
-	return cvmx_phys_to_ptr(cvmx_bootmem_phy_alloc_range(alloc_size, align,
-							     cvmx_addr_on_node(node, 0ull),
-							     cvmx_addr_on_node(node, 0xffffffffff)));
+	int64_t paddr;
+
+	paddr = cvmx_bootmem_phy_alloc_range(alloc_size, align,
+				     cvmx_addr_on_node(node, 0ull),
+				     cvmx_addr_on_node(node, 0xffffffffff));
+	if (paddr <= 0ll) {
+		cvmx_printf("ERROR: %s failed size %u\n",
+			__func__, (unsigned) alloc_size);
+		return NULL;
+	}
+	return cvmx_phys_to_ptr(paddr);
 #endif
 }
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-l2c.c b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
index 1da4117..deeba09 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-l2c.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -43,7 +43,7 @@
  * Implementation of the Level 2 Cache (L2C) control,
  * measurement, and debugging facilities.
  *
- * <hr>$Revision: 105520 $<hr>
+ * <hr>$Revision: 110377 $<hr>
  *
  */
 
@@ -192,7 +192,7 @@ int cvmx_l2c_set_hw_way_partition2(uint32_t mask)
 	uint32_t valid_mask;
 	int node = cvmx_get_node_num();
 
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (CVMX_L2C_IOBS < 2)
 		return -1;
 
 	valid_mask = (0x1 << cvmx_l2c_get_num_assoc()) - 1;
@@ -204,10 +204,9 @@ int cvmx_l2c_set_hw_way_partition2(uint32_t mask)
 int cvmx_l2c_get_hw_way_partition2(void)
 {
 	int node = cvmx_get_node_num();
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX))) {
-		cvmx_warn("only one IOB on this chip");
+	if (CVMX_L2C_IOBS < 2)
 		return -1;
-	}
+
 	return cvmx_read_csr_node(node, CVMX_L2C_WPAR_IOBX(1)) & 0xffff;
 }
 
@@ -394,6 +393,9 @@ int cvmx_l2c_lock_line(uint64_t addr)
 				 && l2c_tadx_tag.cn70xx.valid
 				 && l2c_tadx_tag.cn70xx.tag == tag)
 				break;
+			else if (OCTEON_IS_MODEL(OCTEON_CN73XX)
+				 && l2c_tadx_tag.cn73xx.tag == tag)
+				break;
 			else if (l2c_tadx_tag.cn78xx.ts != 0
 				 && l2c_tadx_tag.cn78xx.tag == tag)
 			        break;
@@ -782,6 +784,13 @@ union cvmx_l2c_tag cvmx_l2c_get_tag_v2(uint32_t association, uint32_t index, uin
 			tag.s.L = l2c_tadx_tag.cn78xx.lock;
 			tag.s.U = l2c_tadx_tag.cn78xx.used;
 			tag.s.addr = l2c_tadx_tag.cn78xx.tag;
+		} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+			if (l2c_tadx_tag.cn73xx.ts != 0)
+				tag.s.V = 1;
+			tag.s.D = l2c_tadx_tag.cn73xx.sblkdty;
+			tag.s.L = l2c_tadx_tag.cn73xx.lock;
+			tag.s.U = l2c_tadx_tag.cn73xx.used;
+			tag.s.addr = l2c_tadx_tag.cn73xx.tag;
 		} else {
 			tag.s.V = l2c_tadx_tag.cn61xx.valid;
 			tag.s.D = l2c_tadx_tag.cn61xx.dirty;
@@ -875,6 +884,13 @@ union cvmx_l2c_tag cvmx_l2c_get_tag(uint32_t association, uint32_t index)
 			tag.s.L = l2c_tadx_tag.cn78xx.lock;
 			tag.s.U = l2c_tadx_tag.cn78xx.used;
 			tag.s.addr = l2c_tadx_tag.cn78xx.tag;
+		} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+			if (l2c_tadx_tag.cn73xx.ts == 0)
+				tag.s.V = 1;
+			tag.s.D = l2c_tadx_tag.cn73xx.sblkdty;
+			tag.s.L = l2c_tadx_tag.cn73xx.lock;
+			tag.s.U = l2c_tadx_tag.cn73xx.used;
+			tag.s.addr = l2c_tadx_tag.cn73xx.tag;
 		} else {
 			tag.s.V = l2c_tadx_tag.cn61xx.valid;
 			tag.s.D = l2c_tadx_tag.cn61xx.dirty;
@@ -934,7 +950,8 @@ union cvmx_l2c_tag cvmx_l2c_get_tag(uint32_t association, uint32_t index)
 int cvmx_l2c_address_to_tad(uint64_t addr)
 {
 	uint32_t tad;
-	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)
+	    || OCTEON_IS_MODEL(OCTEON_CN73XX)) {
 		cvmx_l2c_ctl_t l2c_ctl;
 		l2c_ctl.u64 = cvmx_read_csr(CVMX_L2C_CTL);
 		if (!l2c_ctl.s.disidxalias) {
@@ -988,11 +1005,14 @@ uint32_t cvmx_l2c_address_to_index(uint64_t addr)
 	}
 
 	if (indxalias) {
-		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		/* For 4 TADs */
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX)
+		    || OCTEON_IS_MODEL(OCTEON_CN73XX)) {
 			uint32_t a_14_12 = (idx / (CVMX_L2C_MEMBANK_SELECT_SIZE / (1 << CVMX_L2C_IDX_ADDR_SHIFT))) & 0x7;
 			idx ^= (idx / cvmx_l2c_get_num_sets()) & 0x3ff;
 			idx ^= a_14_12 & 0x3;
 			idx ^= a_14_12 << 2;
+		/* For 8 TADs */
 		} else if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 			uint32_t a_14_12 = (idx / (CVMX_L2C_MEMBANK_SELECT_SIZE / (1 << CVMX_L2C_IDX_ADDR_SHIFT))) & 0x7;
 			uint64_t above_normal_index = (idx / cvmx_l2c_get_num_sets()) & 0xff;	// A<27:20>
@@ -1029,7 +1049,8 @@ int cvmx_l2c_get_set_bits(void)
 		l2_set_bits = 13;	/* 8192 sets */
 	else if (OCTEON_IS_MODEL(OCTEON_CN56XX)
 		 || OCTEON_IS_MODEL(OCTEON_CN58XX)
-		 || OCTEON_IS_MODEL(OCTEON_CN68XX))
+		 || OCTEON_IS_MODEL(OCTEON_CN68XX)
+		 || OCTEON_IS_MODEL(OCTEON_CN73XX))
 		l2_set_bits = 11;	/* 2048 sets */
 	else if (OCTEON_IS_MODEL(OCTEON_CN38XX)
 		 || OCTEON_IS_MODEL(OCTEON_CN63XX)
@@ -1069,7 +1090,9 @@ int cvmx_l2c_get_num_assoc(void)
 		|| OCTEON_IS_MODEL(OCTEON_CN50XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN38XX))
 		l2_assoc = 8;
-	else if (OCTEON_IS_OCTEON2() || OCTEON_IS_MODEL(OCTEON_CN78XX))
+	else if (OCTEON_IS_OCTEON2()
+		 || OCTEON_IS_MODEL(OCTEON_CN78XX)
+		 || OCTEON_IS_MODEL(OCTEON_CN73XX))
 		l2_assoc = 16;
 	else if (OCTEON_IS_MODEL(OCTEON_CN31XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN30XX))
@@ -1100,7 +1123,7 @@ int cvmx_l2c_get_num_assoc(void)
 	}
 
 	/* Check to see if part of the cache is disabled */
-	if (OCTEON_IS_OCTEON2() || OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+	if (OCTEON_IS_OCTEON2() || OCTEON_IS_OCTEON3()) {
 		union cvmx_mio_fus_dat3 mio_fus_dat3;
 
 		mio_fus_dat3.u64 = cvmx_read_csr(CVMX_MIO_FUS_DAT3);
@@ -1123,7 +1146,7 @@ int cvmx_l2c_get_num_assoc(void)
 			l2_assoc = 8;
 		else if (mio_fus_dat3.cn63xx.l2c_crip == 1)
 			l2_assoc = 12;
-	} else if (!OCTEON_IS_OCTEON3()) {
+	} else {
 		union cvmx_l2d_fus3 val;
 		val.u64 = cvmx_read_csr(CVMX_L2D_FUS3);
 		/*
diff --git a/arch/mips/cavium-octeon/executive/cvmx-lap.c b/arch/mips/cavium-octeon/executive/cvmx-lap.c
index bcc724c..948c61b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-lap.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-lap.c
@@ -271,7 +271,7 @@ int cvmx_lap_init(int lap_num, cvmx_lap_config_t *lap_config)
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
 			/* Apply workaround for Errata (LAP-20300) */
 			que_cfg.u64 = cvmx_read_csr(CVMX_LAPX_QUEX_CFG(lap_num, itr));
-			que_cfg.s.max_labs = lap_config->max_labs[CVMX_LAP_QUEUES_PER_LAP-itr];
+			que_cfg.s.max_labs = lap_config->max_labs[CVMX_LAP_QUEUES_PER_LAP-1-itr];
 			cvmx_write_csr(CVMX_LAPX_QUEX_CFG(lap_num, itr),que_cfg.u64); 
 		} else {
 			que_cfg.u64 = cvmx_read_csr(CVMX_LAPX_QUEX_CFG(lap_num, itr));
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki-resources.c b/arch/mips/cavium-octeon/executive/cvmx-pki-resources.c
index 10a18f3..93efb29 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki-resources.c
@@ -204,7 +204,7 @@ int cvmx_pki_cluster_grp_free(int node, int cl_grp)
  */
 int cvmx_pki_cluster_alloc(int node, int num_clusters, uint64_t *cluster_mask)
 {
-	int cluster = 0;
+	unsigned cluster = 0;
 	int clusters[CVMX_PKI_NUM_CLUSTER];
 
 	if (node >= CVMX_MAX_NODES) {
@@ -246,7 +246,7 @@ int cvmx_pki_cluster_alloc(int node, int num_clusters, uint64_t *cluster_mask)
  */
 int cvmx_pki_cluster_free(int node, uint64_t cluster_mask)
 {
-	int cluster = 0;
+	unsigned cluster = 0;
 	if (cluster_mask > 0) {
 		while (cluster < CVMX_PKI_NUM_CLUSTER) {
 			if (cluster_mask & (0x01L << cluster)) {
@@ -393,7 +393,8 @@ int cvmx_pki_qpg_entry_free(int node, int base_offset, int count)
 void __cvmx_pki_global_rsrc_free(int node)
 {
 	int cnt;
-	int cluster, bank;
+	unsigned  cluster;
+	int  bank;
 
 	cnt = CVMX_PKI_NUM_CLUSTER_GROUP;
 	if (cvmx_free_global_resource_range_with_base(CVMX_GR_TAG_CLUSTER_GRP(node), 0, cnt) == -1) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki.c b/arch/mips/cavium-octeon/executive/cvmx-pki.c
index 574bf69..10a5978 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki.c
@@ -167,7 +167,7 @@ void cvmx_pki_read_global_config(int node, struct cvmx_pki_global_config *gbl_cf
 	cvmx_pki_tag_secret_t tag_secret_reg;
 	cvmx_pki_frm_len_chkx_t frm_len_chk;
 	cvmx_pki_buf_ctl_t buf_ctl;
-	int cl_grp;
+	unsigned cl_grp;
 	int id;
 
 	stat_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_STAT_CTL);
@@ -235,7 +235,7 @@ void cvmx_pki_write_global_config(int node, struct cvmx_pki_global_config *gbl_c
 {
 	cvmx_pki_stat_ctl_t stat_ctl;
 	cvmx_pki_buf_ctl_t buf_ctl;
-	int cl_grp;
+	unsigned cl_grp;
 
 	for (cl_grp = 0; cl_grp < CVMX_PKI_NUM_CLUSTER_GROUP; cl_grp++)
 		cvmx_pki_attach_cluster_to_group(node, cl_grp, gbl_cfg->cluster_mask[cl_grp]);
@@ -319,7 +319,7 @@ int cvmx_pki_read_pkind_config(int node, int pkind, struct cvmx_pki_pkind_config
  */
 int cvmx_pki_write_pkind_config(int node, int pkind, struct cvmx_pki_pkind_config *pkind_cfg)
 {
-	int cluster = 0;
+	unsigned cluster = 0;
 	uint64_t cluster_mask;
 
 	cvmx_pki_pkindx_icgsel_t pkind_clsel;
@@ -429,7 +429,7 @@ void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 {
 	cvmx_pki_clx_stylex_cfg2_t style_cfg2_reg;
 	cvmx_pki_clx_stylex_alg_t style_alg_reg;
-	int cluster = 0;
+	unsigned cluster = 0;
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
 		if (cluster_mask & (0x01L << cluster)) {
@@ -557,7 +557,7 @@ void cvmx_pki_write_style_config(int node, uint64_t style, uint64_t cluster_mask
 	cvmx_pki_clx_stylex_cfg2_t style_cfg2_reg;
 	cvmx_pki_clx_stylex_alg_t style_alg_reg;
 	cvmx_pki_stylex_buf_t     style_buf_reg;
-	int cluster = 0;
+	unsigned cluster = 0;
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
 		if (cluster_mask & (0x01L << cluster)) {
@@ -679,7 +679,7 @@ int cvmx_pki_pcam_write_entry(int node, int index, uint64_t cluster_mask,
 	struct cvmx_pki_pcam_input input, struct cvmx_pki_pcam_action action)
 {
 	int bank;
-	int cluster = 0;
+	unsigned cluster = 0;
 	cvmx_pki_clx_pcamx_termx_t	pcam_term;
 	cvmx_pki_clx_pcamx_matchx_t	pcam_match;
 	cvmx_pki_clx_pcamx_actionx_t	pcam_action;
@@ -869,7 +869,7 @@ void cvmx_pki_set_little_endian(int node, uint64_t style)
 void cvmx_pki_endis_fcs_check(int node, int pknd, bool fcs_chk, bool fcs_strip)
 {
 	int style;
-	int cluster = 0;
+	unsigned cluster = 0;
 	cvmx_pki_clx_pkindx_style_t pkind_style;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
@@ -901,7 +901,7 @@ void cvmx_pki_endis_l2_errs(int node, int pknd, bool l2len_err,
 			 bool maxframe_err, bool minframe_err)
 {
 	int style;
-	int cluster = 0;
+	unsigned cluster = 0;
 	cvmx_pki_clx_pkindx_style_t pkind_style;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
@@ -928,7 +928,7 @@ void cvmx_pki_endis_l2_errs(int node, int pknd, bool l2len_err,
 void cvmx_pki_dis_frame_len_chk(int node, int pknd)
 {
 	int style;
-	int cluster = 0;
+	unsigned cluster = 0;
 	cvmx_pki_clx_pkindx_style_t pkind_style;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
@@ -1052,7 +1052,7 @@ void cvmx_pki_show_valid_pcam_entries(int node)
  */
 void cvmx_pki_show_pkind_attributes(int node, int pkind)
 {
-	int cluster = 0;
+	unsigned cluster = 0;
 	int index;
 	cvmx_pki_pkindx_icgsel_t pkind_clsel;
 	cvmx_pki_clx_pkindx_style_t pkind_cfg_style;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
index 8e62784..46d2bc8 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
@@ -322,14 +322,14 @@ int __cvmx_pko3_ipd_dq_unregister(int xiface, int index)
  * Convert normal CHAN_E (i.e. IPD port) value to compressed channel form
  * that is used to populate PKO_LUT.
  *
- * Note: This code may be CN78XX specific, not the same for all PKO3
- * implementations.
+ * Note: This code may be model specific.
  */
 static uint16_t cvmx_pko3_chan_2_xchan(uint16_t ipd_port)
 {
 	uint16_t xchan;
 	uint8_t off;
-	static const uint8_t xchan_base[16] = {
+	static const uint8_t *xchan_base = NULL;
+	static const uint8_t xchan_base_cn78xx[16] = {
 		/* IPD 0x000 */ 0x3c0 >> 4,	/* LBK */
 		/* IPD 0x100 */ 0x380 >> 4,	/* DPI */
 		/* IPD 0x200 */ 0xfff >> 4,	/* not used */
@@ -347,11 +347,37 @@ static uint16_t cvmx_pko3_chan_2_xchan(uint16_t ipd_port)
 		/* IPD 0xe00 */ 0xfff >> 4,	/* not used */
 		/* IPD 0xf00 */ 0xfff >> 4	/* not used */
 	};
+	static const uint8_t xchan_base_cn73xx[16] = {
+		/* IPD 0x000 */ 0x0c0 >> 4,	/* LBK */
+		/* IPD 0x100 */ 0x100 >> 4,	/* DPI */
+		/* IPD 0x200 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x300 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x400 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x500 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x600 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x700 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x800 */ 0x000 >> 4,	/* BGX0 */
+		/* IPD 0x900 */ 0x040 >> 4,	/* BGX1 */
+		/* IPD 0xa00 */ 0x080 >> 4,	/* BGX2 */
+		/* IPD 0xb00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xc00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xd00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xe00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xf00 */ 0xfff >> 4	/* not used */
+	};
+
+        if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		xchan_base = xchan_base_cn73xx;
+        if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+		xchan_base = xchan_base_cn78xx;
+
+	if (xchan_base == NULL)
+		return 0xffff;
 
 	xchan = ipd_port >> 8;
 
-	/* ILKx has 8 bits logical channels, others just 6 */
-	if (((xchan & 0xfe) == 0x04))
+	/* ILKx, DPI has 8 bits logical channels, others just 6 */
+	if (((xchan & 0xfe) == 0x04) || xchan == 0x01)
 		off = ipd_port & 0xff;
 	else
 		off = ipd_port & 0x3f;
@@ -421,22 +447,16 @@ void cvmx_pko3_map_channel(unsigned node,
  *
  * @param node is to specify the node to which this configuration is applied.
  * @param port_queue is the port queue number to be configured.
- * @param child_base is the first child queue number in the static prioriy childs.
- * @param child_rr_prio is the round robin childs priority.
  * @param mac_num is the mac number of the mac that will be tied to this port_queue.
  */
-static void cvmx_pko_configure_port_queue(int node, int port_queue,
-					 int child_base, int child_rr_prio,
-					 int mac_num)
+static void cvmx_pko_configure_port_queue(int node, int port_queue, int mac_num)
 {
 	cvmx_pko_l1_sqx_topology_t pko_l1_topology;
 	cvmx_pko_l1_sqx_shape_t pko_l1_shape;
 	cvmx_pko_l1_sqx_link_t pko_l1_link;
 
 	pko_l1_topology.u64 = 0;
-	pko_l1_topology.s.prio_anchor = child_base;
 	pko_l1_topology.s.link = mac_num;
-	pko_l1_topology.s.rr_prio = child_rr_prio;
 	cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_TOPOLOGY(port_queue), pko_l1_topology.u64);
 
 	pko_l1_shape.u64 = 0;
@@ -454,17 +474,34 @@ static void cvmx_pko_configure_port_queue(int node, int port_queue,
  * in hardware.
  *
  * @param node is to specify the node to which this configuration is applied.
- * @param queue is the level2 queue number to be configured.
- * @param parent_queue is the parent queue at next level for this l2 queue.
+ * @param queue is the level3 queue number to be configured.
+ * @param parent_queue is the parent queue at next level for this l3 queue.
  * @param prio is this queue's priority in parent's scheduler.
  * @param rr_quantum is this queue's round robin quantum value.
- * @return returns none.
+ * @param child_base is the first child queue number in the static prioriy childs.
+ * @param child_rr_prio is the round robin childs priority.
  */
 static void cvmx_pko_configure_l2_queue(int node, int queue, int parent_queue,
-					       int prio, int rr_quantum)
+					       int prio, int rr_quantum,
+					       int child_base, int child_rr_prio)
 {
-	cvmx_pko_l2_sqx_schedule_t pko_sq_sched;
-	cvmx_pko_l2_sqx_topology_t pko_sq_topology;
+	cvmx_pko_l3_sqx_schedule_t pko_sq_sched;
+	cvmx_pko_l3_sqx_topology_t pko_child_topology;
+	cvmx_pko_l2_sqx_topology_t pko_parent_topology;
+
+	/* parent topology configuration */
+	pko_parent_topology.u64 = cvmx_read_csr_node(node,
+			CVMX_PKO_L1_SQX_TOPOLOGY(parent_queue));
+	pko_parent_topology.s.prio_anchor = child_base;
+	pko_parent_topology.s.rr_prio = child_rr_prio;
+	cvmx_write_csr_node(node,
+			CVMX_PKO_L1_SQX_TOPOLOGY(parent_queue),
+			pko_parent_topology.u64);
+
+	if (debug>1) cvmx_dprintf("CVMX_PKO_L1_SQX_TOPOLOGY(%u): "
+		"PRIO_ANCHOR=%u PARENT=%u\n",
+		parent_queue, pko_parent_topology.s.prio_anchor,
+		pko_parent_topology.s.parent);
 
 	/* scheduler configuration for this sq in the parent queue */
 	pko_sq_sched.u64 = 0;
@@ -472,13 +509,14 @@ static void cvmx_pko_configure_l2_queue(int node, int queue, int parent_queue,
 	pko_sq_sched.s.rr_quantum = rr_quantum;
 	cvmx_write_csr_node(node, CVMX_PKO_L2_SQX_SCHEDULE(queue), pko_sq_sched.u64);
 
-	/* topology configuration */
-	pko_sq_topology.u64 = 0;
-	pko_sq_topology.s.parent = parent_queue;
-	cvmx_write_csr_node(node, CVMX_PKO_L2_SQX_TOPOLOGY(queue), pko_sq_topology.u64);
+	/* child topology configuration */
+	pko_child_topology.u64 = 0;
+	pko_child_topology.s.parent = parent_queue;
+	cvmx_write_csr_node(node, CVMX_PKO_L2_SQX_TOPOLOGY(queue), pko_child_topology.u64);
 
 }
 
+
 /*
  * @INTERNAL
  * This function configures level 3 queues scheduling and topology parameters
@@ -642,22 +680,35 @@ static void cvmx_pko_configure_dq(int node, int dq, int parent_queue,
 	cvmx_pko_dqx_topology_t pko_dq_topology;
 	cvmx_pko_l5_sqx_topology_t pko_parent_topology;
 	cvmx_pko_dqx_wm_ctl_t pko_dq_wm_ctl;
+	unsigned long long parent_topology_reg;
+	char lvl;
 
 	if (debug)
 		cvmx_dprintf("%s: dq %u parent %u child_base %u\n",
 			     __func__, dq, parent_queue, child_base);
 
+	if (__cvmx_pko3_sq_lvl_max() == CVMX_PKO_L5_QUEUES) {
+		parent_topology_reg = CVMX_PKO_L5_SQX_TOPOLOGY(parent_queue);
+		lvl = 5;
+	} else if (__cvmx_pko3_sq_lvl_max() == CVMX_PKO_L3_QUEUES) {
+		parent_topology_reg = CVMX_PKO_L3_SQX_TOPOLOGY(parent_queue);
+		lvl = 3;
+	} else
+		return;
+
+	if (debug)
+		cvmx_dprintf("%s: parent_topology_reg=%#llx\n",
+			__func__, parent_topology_reg);
+
 	/* parent topology configuration */
-	pko_parent_topology.u64 = cvmx_read_csr_node(node,
-			CVMX_PKO_L5_SQX_TOPOLOGY(parent_queue));
+	pko_parent_topology.u64 = cvmx_read_csr_node(node, parent_topology_reg);
 	pko_parent_topology.s.prio_anchor = child_base;
 	pko_parent_topology.s.rr_prio = child_rr_prio;
-	cvmx_write_csr_node(node,
-			CVMX_PKO_L5_SQX_TOPOLOGY(parent_queue),
+	cvmx_write_csr_node(node, parent_topology_reg,
 			pko_parent_topology.u64);
 
-	if (debug>1) cvmx_dprintf("CVMX_PKO_L5_SQX_TOPOLOGY(%u): "
-		"PRIO_ANCHOR=%u PARENT=%u\n",
+	if (debug>1) cvmx_dprintf("CVMX_PKO_L%d_SQX_TOPOLOGY(%u): "
+		"PRIO_ANCHOR=%u PARENT=%u\n", lvl,
 		parent_queue, pko_parent_topology.s.prio_anchor,
 		pko_parent_topology.s.parent);
 
@@ -698,21 +749,42 @@ static void cvmx_pko_configure_dq(int node, int dq, int parent_queue,
  * The initial content of the table will be setup in accordance
  * to the specific SoC model and its implemented resources
  */
-static const struct {
-	unsigned sq_level_base,
-		sq_level_count;
-	/* 4 function pointers for L3 .. L6=DQ */
-	void (*cfg_sq_func[])(
+struct pko3_cfg_tab_s {
+	/* function pointer for to configure the given level, last=DQ */
+	struct {
+		uint8_t parent_level;
+		void (*cfg_sq_func)(
 			int node, int queue, int parent_queue,
 			int prio, int rr_quantum,
 			int child_base, int child_rr_prio);
-} __cvmx_pko3_sq_config_table = {
-	3, 4,
+	//XXX for debugging exagerated size
+	} lvl[256];
+};
+
+
+static const struct pko3_cfg_tab_s pko3_cn78xx_cfg = {
 	{
-	cvmx_pko_configure_l3_queue,
-	cvmx_pko_configure_l4_queue,
-	cvmx_pko_configure_l5_queue,
-	cvmx_pko_configure_dq
+	[CVMX_PKO_L2_QUEUES] =
+		{CVMX_PKO_PORT_QUEUES, cvmx_pko_configure_l2_queue },
+	[CVMX_PKO_L3_QUEUES] =
+		{CVMX_PKO_L2_QUEUES, cvmx_pko_configure_l3_queue },
+	[CVMX_PKO_L4_QUEUES] =
+		{CVMX_PKO_L3_QUEUES, cvmx_pko_configure_l4_queue },
+	[CVMX_PKO_L5_QUEUES] =
+		{CVMX_PKO_L4_QUEUES, cvmx_pko_configure_l5_queue },
+	[CVMX_PKO_DESCR_QUEUES] =
+		{CVMX_PKO_L5_QUEUES, cvmx_pko_configure_dq }
+	}
+};
+
+static const struct pko3_cfg_tab_s pko3_cn73xx_cfg = {
+	{
+	[CVMX_PKO_L2_QUEUES] =
+		{CVMX_PKO_PORT_QUEUES, cvmx_pko_configure_l2_queue },
+	[CVMX_PKO_L3_QUEUES] =
+		{CVMX_PKO_L2_QUEUES, cvmx_pko_configure_l3_queue },
+	[CVMX_PKO_DESCR_QUEUES] =
+		{CVMX_PKO_L3_QUEUES, cvmx_pko_configure_dq }
 	}
 };
 
@@ -726,85 +798,20 @@ static const struct {
  *
  * @param node on which to operate
  * @param mac_num is the LMAC number to that is associated with the Port Queue,
- * @param which is identical to the Port Queue number that is configured
- * @param child_base is the number of the first L2 SQ attached to the PQ
- * @param child_count is the number of L2 SQ children to attach to PQ
- * @param stat_prio_count is the priority setting for the children L2 SQs
- *
- * If <stat_prio_count> is -1, the L2 children will have equal Round-Robin
- * relationship with eachother. If <stat_prio_count> is 0, all L2 children
- * will be arranged in Weighted-Round-Robin, with the first having the most
- * precedence. If <stat_prio_count> is between 1 and 8, it indicates how
- * many children will have static priority settings (with the first having
- * the most precedence), with the remaining L2 children having WRR scheduling.
+ * @param pq_num is the number of the L1 PQ attached to the MAC
  *
  * @returns 0 on success, -1 on failure.
- *
- * Note: this function supports the configuration of node-local unit.
  */
-int cvmx_pko3_pq_config_children(unsigned node, unsigned mac_num,
-			 unsigned child_base,
-			unsigned child_count, int stat_prio_count)
+int cvmx_pko3_pq_config(unsigned node, unsigned mac_num, unsigned pq_num)
 {
-	unsigned pq_num;
-	unsigned rr_quantum, rr_count;
-	unsigned child, prio, rr_prio;
-
-	/* L1/PQ number is 1-to-1 from MAC number */
-	pq_num = mac_num;
-
-	/* First static priority is 0 - wuth the most precedence */
-	prio = 0;
-
-	if (stat_prio_count > (signed) child_count)
-		stat_prio_count = child_count;
-
-	/* Valid PRIO field is 0..9, limit maximum static priorities */
-	if (stat_prio_count > 9)
-		stat_prio_count = 9;
-
-	/* Special case of a single child */
-	if (child_count == 1) {
-		rr_count = 0;
-		rr_prio = 0xF;
-	/* Special case for Fair-RR */
-	} else if (stat_prio_count < 0) {
-		rr_count = child_count;
-		rr_prio = 0;
-	} else {
-		rr_count = child_count - stat_prio_count;
-		rr_prio = stat_prio_count;
-	}
-
-	/* Compute highest RR_QUANTUM */
-	if (stat_prio_count > 0)
-		rr_quantum = CVMX_PKO3_RR_QUANTUM_MIN * rr_count;
-	else
-		rr_quantum = CVMX_PKO3_RR_QUANTUM_MIN;
+	char b1[10];
 
 	if(debug)
-		cvmx_dprintf("%s: L1/PQ%u MAC%u child_base %u rr_pri %u\n",
-		__func__, pq_num, mac_num, child_base, rr_prio);
-
-	cvmx_pko_configure_port_queue(node,
-		pq_num, child_base, rr_prio, mac_num);
-
+		cvmx_dprintf("%s: MAC%u -> %s\n",
+			__func__, mac_num,
+			 __cvmx_pko3_sq_str(b1, CVMX_PKO_PORT_QUEUES, pq_num));
 
-	for(child = child_base; child < (child_base + child_count); child ++) {
-		if (debug)
-			cvmx_dprintf("%s: "
-				"L2/SQ%u->PQ%u prio %u rr_quantum %#x\n",
-				__func__,
-				child, pq_num, prio, rr_quantum);
-
-		cvmx_pko_configure_l2_queue(node,
-			child, pq_num, prio, rr_quantum);
-
-		if (prio < rr_prio)
-			prio ++;
-		else if (stat_prio_count > 0)
-			rr_quantum -= CVMX_PKO3_RR_QUANTUM_MIN;
-	} /* for child */
+	cvmx_pko_configure_port_queue(node, pq_num, mac_num);
 
 	return 0;
 }
@@ -820,7 +827,7 @@ int cvmx_pko3_pq_config_children(unsigned node, unsigned mac_num,
  * when multiple children are assigned a single parent.
  *
  * @param node on which to operate
- * @param parent_level is the level of the parent queue, 2 to 5.
+ * @param child_level  is the level of the child queue
  * @param parent_queue is the number of the parent Scheduler Queue
  * @param child_base is the number of the first child SQ or DQ to assign to
  * @param child_count is the number of consecutive children to assign
@@ -837,23 +844,41 @@ int cvmx_pko3_pq_config_children(unsigned node, unsigned mac_num,
  *
  * Note: this function supports the configuration of node-local unit.
  */
-int cvmx_pko3_sq_config_children(unsigned int node, unsigned parent_level,
+int cvmx_pko3_sq_config_children(unsigned int node,
+			enum cvmx_pko3_level_e child_level,
 			unsigned parent_queue, unsigned child_base,
 			unsigned child_count, int stat_prio_count)
 {
-	unsigned child_level;
+	enum cvmx_pko3_level_e parent_level;
+	unsigned num_elem = 0;
 	unsigned rr_quantum, rr_count;
 	unsigned child, prio, rr_prio;
-	unsigned func_idx;
+	const struct pko3_cfg_tab_s *cfg_tbl = NULL;
+	char b1[10], b2[10];
 
-	child_level = parent_level + 1;
+        if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		num_elem = NUM_ELEMENTS(pko3_cn78xx_cfg.lvl);
+		cfg_tbl = &pko3_cn78xx_cfg;
+	}
+        if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		num_elem = NUM_ELEMENTS(pko3_cn73xx_cfg.lvl);
+		cfg_tbl = &pko3_cn73xx_cfg;
+	}
 
-	if (child_level < __cvmx_pko3_sq_config_table.sq_level_base ||
-	    child_level >= __cvmx_pko3_sq_config_table.sq_level_base +
-			__cvmx_pko3_sq_config_table.sq_level_count)
+	if (cfg_tbl == NULL || child_level >= num_elem) {
+		cvmx_dprintf("ERROR: %s: model or level %#x invalid\n",
+			__func__, child_level);
 		return -1;
+	}
 
-	func_idx = child_level - __cvmx_pko3_sq_config_table.sq_level_base;
+	parent_level = cfg_tbl->lvl[child_level].parent_level;
+
+	if (cfg_tbl->lvl[child_level].cfg_sq_func == NULL ||
+	    cfg_tbl->lvl[child_level].parent_level == 0) {
+		cvmx_dprintf("ERROR: %s: queue level %#x invalid\n",
+			__func__, child_level);
+		return -1;
+	}
 
 	/* First static priority is 0 - top precedence */
 	prio = 0;
@@ -885,21 +910,22 @@ int cvmx_pko3_sq_config_children(unsigned int node, unsigned parent_level,
 		rr_quantum = CVMX_PKO3_RR_QUANTUM_MIN;
 
 	if(debug)
-		cvmx_dprintf("%s: Parent L%u/SQ%u child_base %u rr_pri %u\n",
-		__func__, parent_level, parent_queue, child_base, rr_prio);
+		cvmx_dprintf("%s: Parent %s child_base %u rr_pri %u\n",
+		__func__, __cvmx_pko3_sq_str(b1, parent_level, parent_queue),
+		child_base, rr_prio);
 
 	/* Parent is configured with child */
 
 	for(child = child_base; child < (child_base + child_count); child ++) {
 		if (debug)
 			cvmx_dprintf("%s: "
-				"L%u/SQ%u->L%u/SQ%u prio %u rr_quantum %#x\n",
-				__func__,
-				child_level, child,
-				parent_level, parent_queue,
-				prio, rr_quantum);
+			    "Child %s of %s prio %u rr_quantum %#x\n",
+			    __func__,
+			    __cvmx_pko3_sq_str(b1, child_level, child),
+			    __cvmx_pko3_sq_str(b2, parent_level, parent_queue),
+			    prio, rr_quantum);
 
-		__cvmx_pko3_sq_config_table.cfg_sq_func[func_idx](
+		cfg_tbl->lvl[child_level].cfg_sq_func(
 			node, child, parent_queue, prio, rr_quantum,
 			child_base, rr_prio);
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
index d3043af..62c952e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
@@ -66,7 +66,7 @@
 #define CVMX_GR_TAG_PKO_DESCR_QUEUES(x)  cvmx_get_gr_tag('c','v','m','_','p','k','o','d','e','q','_',(x+'0'),'.','.','.','.')
 #define CVMX_GR_TAG_PKO_PORT_INDEX(x)  	 cvmx_get_gr_tag('c','v','m','_','p','k','o','p','i','d','_',(x+'0'),'.','.','.','.')
 
-const int cvmx_pko_num_queues_78XX[CVMX_PKO_NUM_QUEUE_LEVELS] = 
+static const short cvmx_pko_num_queues_78XX[256] = 
 {
 	[CVMX_PKO_PORT_QUEUES] = 32,
 	[CVMX_PKO_L2_QUEUES] = 512,
@@ -76,15 +76,47 @@ const int cvmx_pko_num_queues_78XX[CVMX_PKO_NUM_QUEUE_LEVELS] =
 	[CVMX_PKO_DESCR_QUEUES] = 1024
 };
 
-static inline int __cvmx_pko3_get_num_queues(int level)
+static const short cvmx_pko_num_queues_73XX[256] = 
 {
-	if(OCTEON_IS_MODEL(OCTEON_CN78XX))
-		return cvmx_pko_num_queues_78XX[level];
-	return -1;
+	[CVMX_PKO_PORT_QUEUES] = 16,
+	[CVMX_PKO_L2_QUEUES] = 256,
+	[CVMX_PKO_L3_QUEUES] = 256,
+	[CVMX_PKO_L4_QUEUES] = 0,
+	[CVMX_PKO_L5_QUEUES] = 0,
+	[CVMX_PKO_DESCR_QUEUES] = 256
+};
+
+static inline int __cvmx_pko3_get_num_queues(enum cvmx_pko3_level_e level)
+{
+	unsigned nq = 0, ne = 0;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		ne = NUM_ELEMENTS(cvmx_pko_num_queues_78XX);
+		nq =  cvmx_pko_num_queues_78XX[level];
+	}
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		ne = NUM_ELEMENTS(cvmx_pko_num_queues_73XX);
+		nq =  cvmx_pko_num_queues_73XX[level];
+	}
+
+	if (nq == 0 || level >= ne) {
+		cvmx_printf("ERROR: %s: queue level %#x invalid\n",
+			__func__, level);
+		return -1;
+	}
+
+	return nq;
 }
 
-static inline struct global_resource_tag __cvmx_pko_get_queues_resource_tag(int node, int queue_level)
+static inline struct global_resource_tag
+__cvmx_pko_get_queues_resource_tag(int node, enum cvmx_pko3_level_e queue_level)
 {
+	if (__cvmx_pko3_get_num_queues(queue_level) == 0) {
+		cvmx_printf("ERROR: %s: queue level %#x invalid\n",
+				__func__, queue_level);
+		return CVMX_GR_TAG_INVALID;
+	}
+
 	switch(queue_level) {
 		case CVMX_PKO_PORT_QUEUES:
 			return CVMX_GR_TAG_PKO_PORT_QUEUES(node);
@@ -99,6 +131,8 @@ static inline struct global_resource_tag __cvmx_pko_get_queues_resource_tag(int
 		case CVMX_PKO_DESCR_QUEUES:
 			return CVMX_GR_TAG_PKO_DESCR_QUEUES(node);
 		default:
+			cvmx_printf("ERROR: %s: queue level %#x invalid\n",
+				__func__, queue_level);
 			return CVMX_GR_TAG_INVALID;
 	}
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index a63622f..64d0ca7 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -222,11 +222,12 @@ int cvmx_pko3_hw_disable(int node)
 	uint64_t cycles;
 	const unsigned timeout = 10;	/* 10 milliseconds */
 	unsigned mac_num, fifo, i;
+	unsigned null_mac_num, null_fifo_num, fifo_grp_count, pq_count;
 
 	(void) pko_status;
 
 	/* Wait until there are no in-flight packets */
-	for(i = mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
+	for(i = mac_num = 0; mac_num < __cvmx_pko3_num_macs(); mac_num++) {
 		cvmx_pko_ptfx_status_t ptf_status;
 		ptf_status.u64 =
 			cvmx_read_csr_node(node, CVMX_PKO_PTFX_STATUS(mac_num));
@@ -245,44 +246,56 @@ int cvmx_pko3_hw_disable(int node)
 		}
 	}
 
-	//XXX- try to disable PKO first, then flush the DPFI
 	/* disable PKO - all packets should be out by now */
 	pko_enable.u64 = 0;
 	pko_enable.s.enable = 0;
 	cvmx_write_csr_node(node, CVMX_PKO_ENABLE, pko_enable.u64);
 
-	/* Reset L1_SQ */
-	for(i = 0; i < 32; i++) {
+	/* Assign NULL MAC# for L1/SQ disabled state */
+        if(OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		null_mac_num = 0x0f;
+		null_fifo_num = 0x1f;
+		fifo_grp_count = 4;
+		pq_count = 16;
+	} else {
+		null_mac_num = 0x1c;
+		null_fifo_num = 0x1f;
+		fifo_grp_count = 8;
+		pq_count = 32;
+	}
+
+	/* Reset L1_PQ */
+	for(i = 0; i < pq_count; i++) {
 		cvmx_pko_l1_sqx_topology_t pko_l1_topology;
 		cvmx_pko_l1_sqx_shape_t pko_l1_shape;
 		cvmx_pko_l1_sqx_link_t pko_l1_link;
 		pko_l1_topology.u64 = 0;
-		pko_l1_topology.s.link = 0x1c;
+		pko_l1_topology.s.link = null_mac_num;
 		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_TOPOLOGY(i),
 			pko_l1_topology.u64);
 
 		pko_l1_shape.u64 = 0;
-		pko_l1_shape.s.link = 0x1c;
+		pko_l1_shape.s.link = null_mac_num;
 		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_SHAPE(i), pko_l1_shape.u64);
 
 		pko_l1_link.u64 = 0;
-		pko_l1_link.s.link = 0x1c;
+		pko_l1_link.s.link = null_mac_num;
 		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_LINK(i), pko_l1_link.u64);
 
 	}
 
 	/* Reset all MAC configurations */
-	for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
+	for(mac_num = 0; mac_num < __cvmx_pko3_num_macs(); mac_num++) {
 		cvmx_pko_macx_cfg_t pko_mac_cfg;
 
 		pko_mac_cfg.u64 = 0;
-		pko_mac_cfg.s.fifo_num = 0x1f;
+		pko_mac_cfg.s.fifo_num = null_fifo_num;
 		cvmx_write_csr_node(node, CVMX_PKO_MACX_CFG(mac_num),
 			pko_mac_cfg.u64);
 	}
 
 	/* Reset all FIFO groups */
-	for(fifo = 0; fifo < 8; fifo++) {
+	for(fifo = 0; fifo < fifo_grp_count; fifo++) {
 		cvmx_pko_ptgfx_cfg_t pko_ptgfx_cfg;
 
 		pko_ptgfx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_PTGFX_CFG(fifo));
@@ -334,6 +347,32 @@ int cvmx_pko3_hw_disable(int node)
 	return 0;
 }
 
+/*
+ * Configure Channel credit level in PKO.
+ *
+ * @param node is to specify the node to which this configuration is applied.
+ * @param level specifies the level at which pko channel queues will be configured,
+ * @return returns 0 if successful and -1 on failure.
+ */
+int cvmx_pko3_channel_credit_level(int node, enum cvmx_pko3_level_e level)
+{
+	union cvmx_pko_channel_level channel_level;
+
+	channel_level.u64 = 0;
+
+	if (level == CVMX_PKO_L2_QUEUES)
+		channel_level.s.cc_level = 0;
+	else if (level == CVMX_PKO_L3_QUEUES)
+		channel_level.s.cc_level = 1;
+	else
+		return -1;
+
+	cvmx_write_csr_node(node, CVMX_PKO_CHANNEL_LEVEL, channel_level.u64);
+
+	return 0;
+
+}
+
 /** Open configured descriptor queues before queueing packets into them.
  *
  * @param node is to specify the node to which this configuration is applied.
@@ -471,6 +510,8 @@ int cvmx_pko3_dq_query(int node, int dq)
  *
  * @param node is to specify which node's pko block for this setup.
  * @return returns 0 if successful and -1 on failure.
+ *
+ * Note: This function contains model-specific code.
  */
 static int cvmx_pko_setup_macs(int node)
 {
@@ -482,6 +523,7 @@ static int cvmx_pko_setup_macs(int node)
 	uint8_t fifo_group_cfg[8];
 	uint8_t fifo_group_spd[8];
 	unsigned fifo_count = 0;
+	unsigned max_fifos = 0, fifo_groups = 0;
 	struct {
 		cvmx_helper_interface_mode_t mac_mode;
 		uint8_t fifo_cnt;
@@ -489,7 +531,16 @@ static int cvmx_pko_setup_macs(int node)
 		uint8_t pri;
 		uint8_t spd;
 		uint8_t mac_fifo_cnt;
-	} cvmx_pko3_mac_table[CVMX_PKO_MAX_MACS];
+	} cvmx_pko3_mac_table[32];
+
+        if(OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		max_fifos = 28;	/* exclusive of NULL FIFO */
+		fifo_groups = 8;/* inclusive of NULL PTGF */
+	}
+        if(OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		max_fifos = 16;
+		fifo_groups = 5;
+	}
 
 	/* Initialize FIFO allocation table */
 	memset(&fifo_group_cfg, 0, sizeof(fifo_group_cfg));
@@ -497,7 +548,7 @@ static int cvmx_pko_setup_macs(int node)
 	memset(cvmx_pko3_mac_table, 0, sizeof(cvmx_pko3_mac_table));
 
 	/* Initialize all MACs as disabled */
-	for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
+	for(mac_num = 0; mac_num < __cvmx_pko3_num_macs(); mac_num++) {
 		cvmx_pko3_mac_table[mac_num].mac_mode =
 			CVMX_HELPER_INTERFACE_MODE_DISABLED;
 		cvmx_pko3_mac_table[mac_num].pri = 0;
@@ -525,9 +576,11 @@ static int cvmx_pko_setup_macs(int node)
 
 			/* convert interface/port to mac number */
 			i = __cvmx_pko3_get_mac_num(xiface, port);
-			if (i < 0 || i>= CVMX_PKO_MAX_MACS) {
-				cvmx_dprintf("%s: ERROR: interface %d:%u port %d has no MAC\n",
-					     __func__, node, interface, port);
+			if (i < 0 || i >= (int) __cvmx_pko3_num_macs()) {
+				cvmx_dprintf("%s: ERROR: interface %d:%u "
+				    "port %d has no MAC %d/%d\n",
+				    __func__, node, interface, port,
+				    i, __cvmx_pko3_num_macs());
 				continue;
 			}
 
@@ -577,7 +630,7 @@ static int cvmx_pko_setup_macs(int node)
 	} /* for interface */
 
 	/* Count the number of requested FIFOs */
-	for(fifo_count = mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num ++)
+	for(fifo_count = mac_num = 0; mac_num < __cvmx_pko3_num_macs(); mac_num ++)
 		fifo_count += cvmx_pko3_mac_table[mac_num].fifo_cnt;
 
 	if(debug)
@@ -586,15 +639,15 @@ static int cvmx_pko_setup_macs(int node)
 
 	/* Heuristically trim FIFO count to fit in available number */
 	pri = 1; cnt = 4;
-	while(fifo_count > 28) {
-		for(mac_num=0; mac_num < CVMX_PKO_MAX_MACS; mac_num ++) {
+	while(fifo_count > max_fifos) {
+		for(mac_num=0; mac_num < __cvmx_pko3_num_macs(); mac_num ++) {
 			if (cvmx_pko3_mac_table[mac_num].fifo_cnt == cnt &&
 			    cvmx_pko3_mac_table[mac_num].pri <= pri) {
 				cvmx_pko3_mac_table[mac_num].fifo_cnt >>= 1;
 				fifo_count -=
 					cvmx_pko3_mac_table[mac_num].fifo_cnt;
 			}
-			if (fifo_count <= 28)
+			if (fifo_count <= max_fifos)
 				break;
 		}
 		if (pri >= 4) {
@@ -612,13 +665,13 @@ static int cvmx_pko_setup_macs(int node)
 
 
 	/* Special case for NULL Virtual FIFO */
-	fifo_group_cfg[28 >> 2] = 0;
+	fifo_group_cfg[fifo_groups-1] = 0;
 	/* there is no MAC connected to NULL FIFO */
 
 	/* Configure MAC units, and attach a FIFO to each */
 	for(fifo = 0, cnt = 4; cnt > 0; cnt >>= 1 ) {
 		unsigned g;
-		for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
+		for(mac_num = 0; mac_num < __cvmx_pko3_num_macs(); mac_num++) {
 			if(cvmx_pko3_mac_table[mac_num].fifo_cnt < cnt ||
 			  cvmx_pko3_mac_table[mac_num].fifo_id != 0x1f)
 				continue;
@@ -650,9 +703,9 @@ static int cvmx_pko_setup_macs(int node)
 	}
 
 	/* Check if there was no error in FIFO allocation */
-	if( fifo > 28 ){
-		cvmx_dprintf("%s: ERROR: Internal error FIFO %u\n",
-			__FUNCTION__, fifo);
+	if (fifo > max_fifos) {
+		cvmx_printf("ERROR: %s: Internal error FIFO %u\n",
+			__func__, fifo);
 		return -1;
 	}
 
@@ -661,7 +714,7 @@ static int cvmx_pko_setup_macs(int node)
 			__FUNCTION__, fifo);
 
 	/* Now configure all FIFO groups */
-	for(fifo = 0; fifo < 8; fifo++) {
+	for(fifo = 0; fifo < fifo_groups; fifo++) {
 		cvmx_pko_ptgfx_cfg_t pko_ptgfx_cfg;
 
 		pko_ptgfx_cfg.u64 =
@@ -693,8 +746,8 @@ static int cvmx_pko_setup_macs(int node)
 					pko_ptgfx_cfg.u64);
 	}
 
-	/* Configure all 28 MACs assigned FIFO number */
-	for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
+	/* Configure all MACs assigned FIFO number */
+	for(mac_num = 0; mac_num < __cvmx_pko3_num_macs(); mac_num++) {
 		cvmx_pko_macx_cfg_t pko_mac_cfg;
 
 		if(debug)
@@ -711,9 +764,8 @@ static int cvmx_pko_setup_macs(int node)
 			pko_mac_cfg.u64);
 	}
 
-
 	/* Setup PKO MCI0/MCI1/SKID credits */
-	for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
+	for(mac_num = 0; mac_num < __cvmx_pko3_num_macs(); mac_num++) {
 		cvmx_pko_mci0_max_credx_t pko_mci0_max_cred;
 		cvmx_pko_mci1_max_credx_t pko_mci1_max_cred;
 		cvmx_pko_macx_cfg_t pko_mac_cfg;
@@ -771,7 +823,10 @@ static int cvmx_pko_setup_macs(int node)
 			pko_mci0_max_cred.s.max_cred_lim = 0xfff;
 		}
 
-		cvmx_write_csr_node(node, CVMX_PKO_MCI0_MAX_CREDX(mac_num),
+		/* Pass 2 PKO hardware does not use the MCI0 credits */
+		if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+			cvmx_write_csr_node(node,
+					CVMX_PKO_MCI0_MAX_CREDX(mac_num),
 					pko_mci0_max_cred.u64);
 
 		/* The original CSR formula is the correct one after all */
@@ -1331,10 +1386,12 @@ static int cvmx_pko3_pdesc_subdc_add(cvmx_pko3_pdesc_t *pdesc,
  *
  * @param pdesc Packet Desciptor.
  * @param dq Descriptor Queue associated with the desired output port
+ * @param tag Flow Tag pointer for packet ordering or NULL
  * @return Returns 0 on success, -1 on error.
  *
  */
-int cvmx_pko3_pdesc_transmit(cvmx_pko3_pdesc_t *pdesc, uint16_t dq)
+int cvmx_pko3_pdesc_transmit(cvmx_pko3_pdesc_t *pdesc, uint16_t dq,
+	uint32_t *tag)
 {
         cvmx_pko_query_rtn_t pko_status;
 	cvmx_pko_send_aura_t aura_s;
@@ -1368,6 +1425,10 @@ int cvmx_pko3_pdesc_transmit(cvmx_pko3_pdesc_t *pdesc, uint16_t dq)
 	port_node = dq >> 10;
 	dq &= (1<<10)-1;
 
+	/* To preserve packet order, go atomic with DQ-specific tag */
+	if (tag != NULL)
+		cvmx_pow_tag_sw_nocheck(*tag ^ dq, CVMX_POW_TAG_TYPE_ATOMIC);
+
         /* Send the PKO3 command into the Descriptor Queue */
         pko_status = __cvmx_pko3_do_dma(port_node, dq,
                 pdesc->word, pdesc->num_words, CVMX_PKO_DQ_SEND);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 8fc247b..d603929 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 107037 $<hr>
+ * <hr>$Revision: 110744 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -150,6 +150,8 @@ int cvmx_qlm_get_num(void)
 		return 2;
 	else if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 8;
+	else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return 7;
 	//cvmx_dprintf("Warning: cvmx_qlm_get_num: This chip does not have QLMs\n");
 	return 0;
 }
@@ -212,6 +214,38 @@ int cvmx_qlm_interface(int xiface)
 			}
 		}
 		return -1;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		cvmx_gserx_phy_ctl_t phy_ctl;
+		cvmx_gserx_cfg_t gserx_cfg;
+		int qlm;
+
+		if (xi.interface < 2) {
+			qlm = xi.interface + 2;
+
+			phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
+			if (phy_ctl.s.phy_pd || phy_ctl.s.phy_reset) {
+				return -1;
+			}
+			gserx_cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
+			if (gserx_cfg.s.bgx)
+				return qlm;
+			else
+				return -1;
+		} else if (xi.interface == 2) {
+			qlm = 5;	/* Represents GSER 5,6 DLM pair */
+			/* If either of the two DLMs is set to BGX, match */
+			phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
+			gserx_cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
+			if (! phy_ctl.s.phy_pd && !phy_ctl.s.phy_reset &&
+			    gserx_cfg.s.bgx)
+				return qlm;
+			qlm = 6;
+			phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
+			gserx_cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
+			if (! phy_ctl.s.phy_pd && !phy_ctl.s.phy_reset &&
+			    gserx_cfg.s.bgx)
+				return qlm;
+		}
 	} else {
 		/* Must be cn68XX */
 		switch (xi.interface) {
@@ -650,6 +684,7 @@ int cvmx_qlm_get_gbaud_mhz_node(int node, int qlm)
 	cvmx_gserx_lane_mode_t lane_mode;
 	cvmx_gserx_cfg_t cfg;
 
+	//FIXME: 73XX has QLM bot not OCI, wrong feature
 	if (!octeon_has_feature(OCTEON_FEATURE_MULTINODE))
 		return 0;
 
@@ -1370,6 +1405,46 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 		return CVMX_QLM_MODE_DISABLED;
 }
 
+enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
+{
+	cvmx_gserx_cfg_t gserx_cfg;
+
+	if (qlm > 6)
+		return CVMX_QLM_MODE_DISABLED;
+
+	gserx_cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
+	if (gserx_cfg.s.pcie) {
+		/* FIXME later */
+	} else if (gserx_cfg.s.bgx) {
+		cvmx_bgxx_cmrx_config_t cmr_config;
+		cvmx_bgxx_spux_br_pmd_control_t pmd_control;
+		int bgx = (qlm < 4) ? qlm - 2 : qlm - 3;
+		
+		cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(0, bgx));
+		pmd_control.u64 = cvmx_read_csr(CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx));
+		
+		switch(cmr_config.s.lmac_type) {
+		case 0: return CVMX_QLM_MODE_SGMII;
+		case 1:	return CVMX_QLM_MODE_XAUI;
+		case 2:	return CVMX_QLM_MODE_RXAUI;
+		case 3:	
+			/* Use training to determine if we're in 10GBASE-KR or XFI */
+			if (pmd_control.s.train_en)
+				return CVMX_QLM_MODE_10G_KR;
+			else
+				return CVMX_QLM_MODE_XFI;
+		case 4:	
+			/* Use training to determine if we're in 10GBASE-KR or XFI */
+			if (pmd_control.s.train_en)
+				return CVMX_QLM_MODE_40G_KR4;
+			else
+				return CVMX_QLM_MODE_XLAUI;
+		default: return CVMX_QLM_MODE_DISABLED;
+		}
+	}
+	return CVMX_QLM_MODE_DISABLED;
+}
+
 /*
  * Read QLM and return mode.
  */
@@ -1381,6 +1456,8 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode(int qlm)
 		return __cvmx_qlm_get_mode_cn70xx(qlm);
 	else if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return cvmx_qlm_get_mode_cn78xx(cvmx_get_node_num(), qlm);
+	else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return __cvmx_qlm_get_mode_cn73xx(qlm);
 
 	return CVMX_QLM_MODE_DISABLED;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c b/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
index d7fb307..ceb5c56 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
@@ -72,6 +72,8 @@ int cvmx_sso_allocate_group_range(int node, int *base_group, int count)
 
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		num_grp = 256;
+	else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		num_grp = 64;
 	else if (OCTEON_IS_MODEL(OCTEON_CN68XX))
 		num_grp = 64;
 	else
diff --git a/arch/mips/cavium-octeon/executive/octeon-feature.c b/arch/mips/cavium-octeon/executive/octeon-feature.c
index 3dd4c5b..6e70280 100644
--- a/arch/mips/cavium-octeon/executive/octeon-feature.c
+++ b/arch/mips/cavium-octeon/executive/octeon-feature.c
@@ -143,7 +143,6 @@ void __init octeon_feature_init(void)
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_HNA);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX_MIX);
-	OCTEON_FEATURE_SET(OCTEON_FEATURE_OCX);
 	val = OCTEON_FEATURE_SUCCESS;
 
 feature_check:
diff --git a/arch/mips/cavium-octeon/executive/octeon-model.c b/arch/mips/cavium-octeon/executive/octeon-model.c
index 008c7c7..b7ca2be 100644
--- a/arch/mips/cavium-octeon/executive/octeon-model.c
+++ b/arch/mips/cavium-octeon/executive/octeon-model.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -43,7 +43,7 @@
  * File defining functions for working with different Octeon
  * models.
  *
- * <hr>$Revision: 105060 $<hr>
+ * <hr>$Revision: 110379 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/octeon.h>
@@ -474,6 +474,15 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 		else
 			suffix = "AAP";
 		break;
+	case 0x97:		/* CN73XX */
+		family = "73";
+		if (fus_dat3.cn78xx.nozip
+		    && fus_dat3.cn78xx.nodfa_dte
+		    && fus_dat3.cn78xx.nohna_dte)
+			suffix = "SCP";
+		else
+			suffix = "AAP";
+		break;
 	default:
 		family = "XX";
 		core_model = "XX";
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index dbe212e..888c02f 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 105233 $<hr>
+ * <hr>$Revision: 109613 $<hr>
  *
  */
 
@@ -288,6 +288,8 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_EBB7800_CFG0 = 70, /* Only required to support cn78xx p1.0 */
 	CVMX_BOARD_TYPE_EBB7804_CFG0 = 71, /* Only required to support cn78xx p1.0 */
 	CVMX_BOARD_TYPE_SWORDFISH = 72,
+	CVMX_BOARD_TYPE_SFF7800 = 73,	/* Embedded Planet board */
+	CVMX_BOARD_TYPE_EAP7000_10G = 74,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -428,6 +430,8 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7800_CFG0)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7804_CFG0)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SWORDFISH)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SFF7800)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EAP7000_10G)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-ase-defs.h b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
index 23ceb72..e74b14d 100644
--- a/arch/mips/include/asm/octeon/cvmx-ase-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
@@ -1188,26 +1188,26 @@ union cvmx_ase_lue_error_log_enable {
 	struct cvmx_ase_lue_error_log_enable_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
-	uint64_t kdt_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[KDT_DBE] errors. */
+	uint64_t kdt_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::KDT_DBE errors. */
 	uint64_t reserved_52_52               : 1;
-	uint64_t rul_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[RUL_DBE] errors. */
-	uint64_t rft_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[RFT_DBE] errors. */
-	uint64_t tat_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[TAT_DBE] errors. */
-	uint64_t kdb_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[KDB_DBE] errors. */
+	uint64_t rul_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::RUL_DBE errors. */
+	uint64_t rft_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::RFT_DBE errors. */
+	uint64_t tat_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::TAT_DBE errors. */
+	uint64_t kdb_dbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::KDB_DBE errors. */
 	uint64_t reserved_37_47               : 11;
-	uint64_t kdt_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[KDT_SBE] errors. */
-	uint64_t rul_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[RUL_SBE] errors. */
-	uint64_t rft_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[RFT_SBE] errors. */
-	uint64_t tat_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[TAT_SBE] errors. */
-	uint64_t kdb_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[KDB_SBE] errors. */
+	uint64_t kdt_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::KDT_SBE errors. */
+	uint64_t rul_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::RUL_SBE errors. */
+	uint64_t rft_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::RFT_SBE errors. */
+	uint64_t tat_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::TAT_SBE errors. */
+	uint64_t kdb_sbe                      : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::KDB_SBE errors. */
 	uint64_t reserved_8_31                : 24;
-	uint64_t rme_fatal                    : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[RME_FATAL] errors. */
-	uint64_t invalid_req                  : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[INVALID_REQ] errors. */
-	uint64_t hr_err_log                   : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[HR_ERR_LOG] errors. */
+	uint64_t rme_fatal                    : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::RME_FATAL errors. */
+	uint64_t invalid_req                  : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::INVALID_REQ errors. */
+	uint64_t hr_err_log                   : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::HR_ERR_LOG errors. */
 	uint64_t reserved_3_4                 : 2;
-	uint64_t tic_bad_write                : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[TIC_BAD_WRITE] errors. */
-	uint64_t tic_multi_hit                : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[TIC_MULTI_HIT] errors. */
-	uint64_t tic_miss                     : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E[TIC_MISS] errors. */
+	uint64_t tic_bad_write                : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::TIC_BAD_WRITE errors. */
+	uint64_t tic_multi_hit                : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::TIC_MULTI_HIT errors. */
+	uint64_t tic_miss                     : 1;  /**< Enables logging for ASE_LUE_ERROR_ID_E::TIC_MISS errors. */
 #else
 	uint64_t tic_miss                     : 1;
 	uint64_t tic_multi_hit                : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-asxx-defs.h b/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
index 7cb9866..4d38c46 100644
--- a/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
@@ -53,206 +53,206 @@
 #define __CVMX_ASXX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_GMII_RX_CLK_SET(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_GMII_RX_CLK_SET(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ASXX_GMII_RX_CLK_SET(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ASXX_GMII_RX_CLK_SET(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800B0000180ull);
 }
 #else
-#define CVMX_ASXX_GMII_RX_CLK_SET(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000180ull))
+#define CVMX_ASXX_GMII_RX_CLK_SET(offset) (CVMX_ADD_IO_SEG(0x00011800B0000180ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_GMII_RX_DAT_SET(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_GMII_RX_DAT_SET(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ASXX_GMII_RX_DAT_SET(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ASXX_GMII_RX_DAT_SET(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800B0000188ull);
 }
 #else
-#define CVMX_ASXX_GMII_RX_DAT_SET(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000188ull))
+#define CVMX_ASXX_GMII_RX_DAT_SET(offset) (CVMX_ADD_IO_SEG(0x00011800B0000188ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_INT_EN(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_INT_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_INT_EN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_INT_EN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_INT_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_INT_EN(offset) (CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_INT_REG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_INT_REG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_INT_REG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_INT_REG(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_INT_REG(offset) (CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_MII_RX_DAT_SET(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_MII_RX_DAT_SET(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ASXX_MII_RX_DAT_SET(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ASXX_MII_RX_DAT_SET(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800B0000190ull);
 }
 #else
-#define CVMX_ASXX_MII_RX_DAT_SET(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000190ull))
+#define CVMX_ASXX_MII_RX_DAT_SET(offset) (CVMX_ADD_IO_SEG(0x00011800B0000190ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_PRT_LOOP(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_PRT_LOOP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_PRT_LOOP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000040ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_PRT_LOOP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000040ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_PRT_LOOP(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000040ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_PRT_LOOP(offset) (CVMX_ADD_IO_SEG(0x00011800B0000040ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_BYPASS(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_BYPASS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_BYPASS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000248ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_BYPASS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000248ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_BYPASS(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000248ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_BYPASS(offset) (CVMX_ADD_IO_SEG(0x00011800B0000248ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_BYPASS_SETTING(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_BYPASS_SETTING(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_BYPASS_SETTING(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000250ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_BYPASS_SETTING(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000250ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_BYPASS_SETTING(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000250ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_BYPASS_SETTING(offset) (CVMX_ADD_IO_SEG(0x00011800B0000250ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_COMP(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_COMP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_COMP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000220ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_COMP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000220ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_COMP(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000220ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_COMP(offset) (CVMX_ADD_IO_SEG(0x00011800B0000220ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_DATA_DRV(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_DATA_DRV(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_DATA_DRV(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000218ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_DATA_DRV(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000218ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_DATA_DRV(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000218ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_DATA_DRV(offset) (CVMX_ADD_IO_SEG(0x00011800B0000218ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_FCRAM_MODE(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_FCRAM_MODE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_FCRAM_MODE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000210ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_FCRAM_MODE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000210ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_FCRAM_MODE(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000210ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_FCRAM_MODE(offset) (CVMX_ADD_IO_SEG(0x00011800B0000210ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_NCTL_STRONG(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_NCTL_STRONG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_NCTL_STRONG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000230ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_NCTL_STRONG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000230ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_NCTL_STRONG(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000230ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_NCTL_STRONG(offset) (CVMX_ADD_IO_SEG(0x00011800B0000230ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_NCTL_WEAK(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_NCTL_WEAK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_NCTL_WEAK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000240ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_NCTL_WEAK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000240ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_NCTL_WEAK(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000240ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_NCTL_WEAK(offset) (CVMX_ADD_IO_SEG(0x00011800B0000240ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_PCTL_STRONG(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_PCTL_STRONG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_PCTL_STRONG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000228ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_PCTL_STRONG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000228ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_PCTL_STRONG(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000228ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_PCTL_STRONG(offset) (CVMX_ADD_IO_SEG(0x00011800B0000228ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_PCTL_WEAK(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_PCTL_WEAK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_PCTL_WEAK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000238ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_PCTL_WEAK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000238ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_PCTL_WEAK(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000238ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_PCTL_WEAK(offset) (CVMX_ADD_IO_SEG(0x00011800B0000238ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RLD_SETTING(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RLD_SETTING(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RLD_SETTING(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000258ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RLD_SETTING(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000258ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RLD_SETTING(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000258ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RLD_SETTING(offset) (CVMX_ADD_IO_SEG(0x00011800B0000258ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ASXX_RX_CLK_SETX(unsigned long offset, unsigned long block_id)
@@ -270,63 +270,63 @@ static inline uint64_t CVMX_ASXX_RX_CLK_SETX(unsigned long offset, unsigned long
 #define CVMX_ASXX_RX_CLK_SETX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800B0000020ull) + (((offset) & 3) + ((block_id) & 1) * 0x1000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RX_PRT_EN(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RX_PRT_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RX_PRT_EN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000000ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RX_PRT_EN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000000ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RX_PRT_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000000ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RX_PRT_EN(offset) (CVMX_ADD_IO_SEG(0x00011800B0000000ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RX_WOL(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RX_WOL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RX_WOL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000100ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RX_WOL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000100ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RX_WOL(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000100ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RX_WOL(offset) (CVMX_ADD_IO_SEG(0x00011800B0000100ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RX_WOL_MSK(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RX_WOL_MSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RX_WOL_MSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000108ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RX_WOL_MSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000108ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RX_WOL_MSK(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000108ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RX_WOL_MSK(offset) (CVMX_ADD_IO_SEG(0x00011800B0000108ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RX_WOL_POWOK(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RX_WOL_POWOK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RX_WOL_POWOK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000118ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RX_WOL_POWOK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000118ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RX_WOL_POWOK(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000118ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RX_WOL_POWOK(offset) (CVMX_ADD_IO_SEG(0x00011800B0000118ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_RX_WOL_SIG(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_RX_WOL_SIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_RX_WOL_SIG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000110ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_RX_WOL_SIG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000110ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_RX_WOL_SIG(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000110ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_RX_WOL_SIG(offset) (CVMX_ADD_IO_SEG(0x00011800B0000110ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ASXX_TX_CLK_SETX(unsigned long offset, unsigned long block_id)
@@ -344,19 +344,19 @@ static inline uint64_t CVMX_ASXX_TX_CLK_SETX(unsigned long offset, unsigned long
 #define CVMX_ASXX_TX_CLK_SETX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800B0000048ull) + (((offset) & 3) + ((block_id) & 1) * 0x1000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_TX_COMP_BYP(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_TX_COMP_BYP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_TX_COMP_BYP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000068ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_TX_COMP_BYP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000068ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_TX_COMP_BYP(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000068ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_TX_COMP_BYP(offset) (CVMX_ADD_IO_SEG(0x00011800B0000068ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ASXX_TX_HI_WATERX(unsigned long offset, unsigned long block_id)
@@ -374,19 +374,19 @@ static inline uint64_t CVMX_ASXX_TX_HI_WATERX(unsigned long offset, unsigned lon
 #define CVMX_ASXX_TX_HI_WATERX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800B0000080ull) + (((offset) & 3) + ((block_id) & 1) * 0x1000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ASXX_TX_PRT_EN(unsigned long block_id)
+static inline uint64_t CVMX_ASXX_TX_PRT_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_ASXX_TX_PRT_EN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000008ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_ASXX_TX_PRT_EN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000008ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_ASXX_TX_PRT_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000008ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_ASXX_TX_PRT_EN(offset) (CVMX_ADD_IO_SEG(0x00011800B0000008ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-bch-defs.h b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
index 3837c93..aa8c420 100644
--- a/arch/mips/include/asm/octeon/cvmx-bch-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_BCH_BIST_RESULT CVMX_BCH_BIST_RESULT_FUNC()
 static inline uint64_t CVMX_BCH_BIST_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_BCH_BIST_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000080ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_BCH_BIST_RESULT_FUNC(void)
 #define CVMX_BCH_CMD_BUF CVMX_BCH_CMD_BUF_FUNC()
 static inline uint64_t CVMX_BCH_CMD_BUF_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_BCH_CMD_BUF not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000008ull);
 }
@@ -75,10 +75,21 @@ static inline uint64_t CVMX_BCH_CMD_BUF_FUNC(void)
 #define CVMX_BCH_CMD_BUF (CVMX_ADD_IO_SEG(0x0001180071000008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_BCH_CMD_PTR CVMX_BCH_CMD_PTR_FUNC()
+static inline uint64_t CVMX_BCH_CMD_PTR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_BCH_CMD_PTR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180071000020ull);
+}
+#else
+#define CVMX_BCH_CMD_PTR (CVMX_ADD_IO_SEG(0x0001180071000020ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_BCH_CTL CVMX_BCH_CTL_FUNC()
 static inline uint64_t CVMX_BCH_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_BCH_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000000ull);
 }
@@ -86,10 +97,21 @@ static inline uint64_t CVMX_BCH_CTL_FUNC(void)
 #define CVMX_BCH_CTL (CVMX_ADD_IO_SEG(0x0001180071000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_BCH_ECO CVMX_BCH_ECO_FUNC()
+static inline uint64_t CVMX_BCH_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_BCH_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180071000030ull);
+}
+#else
+#define CVMX_BCH_ECO (CVMX_ADD_IO_SEG(0x0001180071000030ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_BCH_ERR_CFG CVMX_BCH_ERR_CFG_FUNC()
 static inline uint64_t CVMX_BCH_ERR_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_BCH_ERR_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000010ull);
 }
@@ -118,6 +140,17 @@ static inline uint64_t CVMX_BCH_GEN_INT_EN_FUNC(void)
 #else
 #define CVMX_BCH_GEN_INT_EN (CVMX_ADD_IO_SEG(0x0001180071000090ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_BCH_REG_ERROR CVMX_BCH_REG_ERROR_FUNC()
+static inline uint64_t CVMX_BCH_REG_ERROR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_BCH_REG_ERROR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180071000088ull);
+}
+#else
+#define CVMX_BCH_REG_ERROR (CVMX_ADD_IO_SEG(0x0001180071000088ull))
+#endif
 
 /**
  * cvmx_bch_bist_result
@@ -142,6 +175,7 @@ union cvmx_bch_bist_result {
 	} s;
 	struct cvmx_bch_bist_result_s         cn70xx;
 	struct cvmx_bch_bist_result_s         cn70xxp1;
+	struct cvmx_bch_bist_result_s         cn73xx;
 };
 typedef union cvmx_bch_bist_result cvmx_bch_bist_result_t;
 
@@ -155,6 +189,17 @@ union cvmx_bch_cmd_buf {
 	uint64_t u64;
 	struct cvmx_bch_cmd_buf_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_46_63               : 18;
+	uint64_t size                         : 13; /**< Number of uint64s per command buffer segment. */
+	uint64_t ptr                          : 33; /**< Initial command buffer pointer[39:7] (128B-aligned). */
+#else
+	uint64_t ptr                          : 33;
+	uint64_t size                         : 13;
+	uint64_t reserved_46_63               : 18;
+#endif
+	} s;
+	struct cvmx_bch_cmd_buf_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
 	uint64_t dwb                          : 9;  /**< Number of DontWriteBacks. */
 	uint64_t pool                         : 3;  /**< Free list used to free command buffer segments. */
@@ -167,13 +212,53 @@ union cvmx_bch_cmd_buf {
 	uint64_t dwb                          : 9;
 	uint64_t reserved_58_63               : 6;
 #endif
-	} s;
-	struct cvmx_bch_cmd_buf_s             cn70xx;
-	struct cvmx_bch_cmd_buf_s             cn70xxp1;
+	} cn70xx;
+	struct cvmx_bch_cmd_buf_cn70xx        cn70xxp1;
+	struct cvmx_bch_cmd_buf_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t aura                         : 12; /**< Aura to use when freeing command-buffer segments */
+	uint64_t ldwb                         : 1;  /**< When reading commands that end on cache line boundaries, use load-and-don't write back commands. */
+	uint64_t dfb                          : 1;  /**< Don't free buffers to the FPA. */
+	uint64_t size                         : 13; /**< Number of uint64s per command buffer segment. */
+	uint64_t reserved_0_32                : 33;
+#else
+	uint64_t reserved_0_32                : 33;
+	uint64_t size                         : 13;
+	uint64_t dfb                          : 1;
+	uint64_t ldwb                         : 1;
+	uint64_t aura                         : 12;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_bch_cmd_buf cvmx_bch_cmd_buf_t;
 
 /**
+ * cvmx_bch_cmd_ptr
+ *
+ * This register sets the command-buffer parameters.
+ *
+ */
+union cvmx_bch_cmd_ptr {
+	uint64_t u64;
+	struct cvmx_bch_cmd_ptr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t ptr                          : 35; /**< Initial command-buffer pointer bits <41:7> (128-byte aligned). Overwritten each time the
+                                                         command-buffer segment is exhausted. */
+	uint64_t reserved_0_6                 : 7;
+#else
+	uint64_t reserved_0_6                 : 7;
+	uint64_t ptr                          : 35;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} s;
+	struct cvmx_bch_cmd_ptr_s             cn73xx;
+};
+typedef union cvmx_bch_cmd_ptr cvmx_bch_cmd_ptr_t;
+
+/**
  * cvmx_bch_ctl
  */
 union cvmx_bch_ctl {
@@ -183,12 +268,12 @@ union cvmx_bch_ctl {
 	uint64_t reserved_23_63               : 41;
 	uint64_t free_ena                     : 1;  /**< Enable freeing of command buffers. */
 	uint64_t early_term                   : 4;  /**< Threshold of zero delta interations before declaring early termination.
-                                                         0 will force all iterations to run.  Diagnostic only. */
-	uint64_t one_cmd                      : 1;  /**< Execute a single operation at a time.  Diagnostic only. */
+                                                         0 will force all iterations to run.  For diagnostic use only. */
+	uint64_t one_cmd                      : 1;  /**< Execute a single operation at a time.  For diagnostic use only. */
 	uint64_t erase_disable                : 1;  /**< When ERASE_DISABLE=0, erased blocks bypass the BCH correction.   The 16B result word
                                                          contains an erased block indication.
                                                          A block is considered erased if the number of zeros found in the block (data+ECC) is
-                                                         less than half the ECC level.   For instance, a 2KB block using ECC32 is considered
+                                                         less than half the ECC level.   For instance, a 2 KB block using ECC32 is considered
                                                          erased if few than 16 zeroes are found in the 2048+60 bytes. */
 	uint64_t reserved_6_15                : 10;
 	uint64_t max_read                     : 4;  /**< Maximum number of outstanding data read commands. MAX_READ is a throttle to control IOB
@@ -209,10 +294,55 @@ union cvmx_bch_ctl {
 	} s;
 	struct cvmx_bch_ctl_s                 cn70xx;
 	struct cvmx_bch_ctl_s                 cn70xxp1;
+	struct cvmx_bch_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_22_63               : 42;
+	uint64_t early_term                   : 4;  /**< Threshold of zero delta interations before declaring early termination.
+                                                         0 will force all iterations to run.  For diagnostic use only. */
+	uint64_t one_cmd                      : 1;  /**< Execute a single operation at a time.  For diagnostic use only. */
+	uint64_t erase_disable                : 1;  /**< When ERASE_DISABLE=0, erased blocks bypass the BCH correction.   The 16B result word
+                                                         contains an erased block indication.
+                                                         A block is considered erased if the number of zeros found in the block (data+ECC) is
+                                                         less than half the ECC level.   For instance, a 2 KB block using ECC32 is considered
+                                                         erased if few than 16 zeroes are found in the 2048+60 bytes. */
+	uint64_t reserved_6_15                : 10;
+	uint64_t max_read                     : 4;  /**< Maximum number of outstanding data read commands. MAX_READ is a throttle to control IOB
+                                                         usage. Values greater than 0x8 are illegal. */
+	uint64_t store_le                     : 1;  /**< Force STORE0 byte write address to little endian. */
+	uint64_t reset                        : 1;  /**< Reset oneshot pulse (lasts for 4 cycles). */
+#else
+	uint64_t reset                        : 1;
+	uint64_t store_le                     : 1;
+	uint64_t max_read                     : 4;
+	uint64_t reserved_6_15                : 10;
+	uint64_t erase_disable                : 1;
+	uint64_t one_cmd                      : 1;
+	uint64_t early_term                   : 4;
+	uint64_t reserved_22_63               : 42;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_bch_ctl cvmx_bch_ctl_t;
 
 /**
+ * cvmx_bch_eco
+ */
+union cvmx_bch_eco {
+	uint64_t u64;
+	struct cvmx_bch_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_bch_eco_s                 cn73xx;
+};
+typedef union cvmx_bch_eco cvmx_bch_eco_t;
+
+/**
  * cvmx_bch_err_cfg
  */
 union cvmx_bch_err_cfg {
@@ -233,6 +363,7 @@ union cvmx_bch_err_cfg {
 	} s;
 	struct cvmx_bch_err_cfg_s             cn70xx;
 	struct cvmx_bch_err_cfg_s             cn70xxp1;
+	struct cvmx_bch_err_cfg_s             cn73xx;
 };
 typedef union cvmx_bch_err_cfg cvmx_bch_err_cfg_t;
 
@@ -285,4 +416,29 @@ union cvmx_bch_gen_int_en {
 };
 typedef union cvmx_bch_gen_int_en cvmx_bch_gen_int_en_t;
 
+/**
+ * cvmx_bch_reg_error
+ */
+union cvmx_bch_reg_error {
+	uint64_t u64;
+	struct cvmx_bch_reg_error_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_3_63                : 61;
+	uint64_t dat_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the DAT RAM.
+                                                         Throws BCH_INTSN_E::BCH_FIFO_DBE. */
+	uint64_t dat_sbe                      : 1;  /**< An ECC correctable error has occurred in the DAT RAM.
+                                                         Throws BCH_INTSN_E::BCH_FIFO_SBE. */
+	uint64_t doorbell                     : 1;  /**< Error bit indicating a doorbell count has overflowed.
+                                                         Throws BCH_INTSN_E::BCH_FIFO_DOORBELL. */
+#else
+	uint64_t doorbell                     : 1;
+	uint64_t dat_sbe                      : 1;
+	uint64_t dat_dbe                      : 1;
+	uint64_t reserved_3_63                : 61;
+#endif
+	} s;
+	struct cvmx_bch_reg_error_s           cn73xx;
+};
+typedef union cvmx_bch_reg_error cvmx_bch_reg_error_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 971eba2..49085f9 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -56,6 +56,7 @@
 static inline uint64_t CVMX_BGXX_CMRX_CONFIG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_CONFIG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -67,6 +68,7 @@ static inline uint64_t CVMX_BGXX_CMRX_CONFIG(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_CMRX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -78,6 +80,7 @@ static inline uint64_t CVMX_BGXX_CMRX_INT(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_BGXX_CMRX_PRT_CBFC_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_PRT_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000408ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -89,6 +92,7 @@ static inline uint64_t CVMX_BGXX_CMRX_PRT_CBFC_CTL(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_CMRX_RX_ADR_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ADR_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000A0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -100,6 +104,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ADR_CTL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_RX_BP_DROP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_DROP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -111,6 +116,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_DROP(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_RX_BP_OFF(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_OFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000090ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -122,6 +128,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_OFF(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_RX_BP_ON(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_ON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000088ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -133,6 +140,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_ON(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_BP_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000A8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -144,6 +152,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_STATUS(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_CMRX_RX_FIFO_LEN(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000C0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -155,6 +164,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_FIFO_LEN(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_RX_ID_MAP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ID_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -166,6 +176,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ID_MAP(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XOFF(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XOFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000B0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -177,6 +188,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XOFF(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XON(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000B8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -188,6 +200,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XON(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -199,6 +212,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long offset, u
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -210,6 +224,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT0(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -221,6 +236,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT1(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -232,6 +248,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT2(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT3(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -243,6 +260,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT3(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT4(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -254,6 +272,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT4(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT5(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -265,6 +284,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT5(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT6(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -276,6 +296,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT6(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT7(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -287,6 +308,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT7(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT8(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -298,6 +320,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT8(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_WEIGHT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_WEIGHT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000098ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -309,6 +332,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_WEIGHT(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_CHANNEL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_CHANNEL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000400ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -320,6 +344,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_CHANNEL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_TX_FIFO_LEN(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000418ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -331,6 +356,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_FIFO_LEN(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_TX_HG2_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_HG2_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000410ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -342,6 +368,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_HG2_STATUS(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_CMRX_TX_OVR_BP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_OVR_BP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000420ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -353,6 +380,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_OVR_BP(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000508ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -364,6 +392,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT0(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000510ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -375,6 +404,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT1(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT10(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT10(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000558ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -386,6 +416,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT10(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT11(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT11(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000560ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -397,6 +428,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT11(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT12(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT12(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000568ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -408,6 +440,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT12(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT13(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT13(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000570ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -419,6 +452,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT13(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT14(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT14(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000578ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -430,6 +464,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT14(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT15(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT15(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000580ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -441,6 +476,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT15(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT16(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT16(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000588ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -452,6 +488,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT16(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT17(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT17(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000590ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -463,6 +500,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT17(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000518ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -474,6 +512,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT2(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT3(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000520ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -485,6 +524,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT3(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT4(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000528ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -496,6 +536,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT4(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT5(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000530ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -507,6 +548,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT5(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT6(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000538ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -518,6 +560,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT6(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT7(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000540ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -529,6 +572,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT7(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT8(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000548ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -540,6 +584,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT8(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT9(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT9(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000550ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -548,97 +593,118 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT9(unsigned long offset, unsigned lo
 #define CVMX_BGXX_CMRX_TX_STAT9(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800E0000550ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_BAD(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_BAD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_BAD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0001020ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_BAD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0001020ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_BAD(block_id) (CVMX_ADD_IO_SEG(0x00011800E0001020ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_BAD(offset) (CVMX_ADD_IO_SEG(0x00011800E0001020ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0000300ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0000300ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000300ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800E0000300ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_AND(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_AND(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_AND(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0000200ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_AND(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0000200ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_CHAN_MSK_AND(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000200ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_CHAN_MSK_AND(offset) (CVMX_ADD_IO_SEG(0x00011800E0000200ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_OR(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_OR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_OR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_OR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_CHAN_MSK_OR(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_CHAN_MSK_OR(offset) (CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_GLOBAL_CONFIG(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_ECO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_GLOBAL_CONFIG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_ECO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0001028ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_GLOBAL_CONFIG(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_ECO(offset) (CVMX_ADD_IO_SEG(0x00011800E0001028ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_MEM_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_GLOBAL_CONFIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_MEM_CTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0000018ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_GLOBAL_CONFIG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_MEM_CTRL(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000018ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_GLOBAL_CONFIG(offset) (CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_MEM_INT(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_MEM_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_MEM_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0000010ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_MEM_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0000018ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_MEM_INT(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000010ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_MEM_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800E0000018ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_NXC_ADR(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_MEM_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_NXC_ADR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0001018ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_MEM_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0000010ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_NXC_ADR(block_id) (CVMX_ADD_IO_SEG(0x00011800E0001018ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_MEM_INT(offset) (CVMX_ADD_IO_SEG(0x00011800E0000010ull) + ((offset) & 7) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_BGXX_CMR_NXC_ADR(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_NXC_ADR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0001018ull) + ((offset) & 7) * 0x1000000ull;
+}
+#else
+#define CVMX_BGXX_CMR_NXC_ADR(offset) (CVMX_ADD_IO_SEG(0x00011800E0001018ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_BGXX_CMR_RX_ADRX_CAM(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 31)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 31)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_ADRX_CAM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000100ull) + (((offset) & 31) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -647,42 +713,46 @@ static inline uint64_t CVMX_BGXX_CMR_RX_ADRX_CAM(unsigned long offset, unsigned
 #define CVMX_BGXX_CMR_RX_ADRX_CAM(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800E0000100ull) + (((offset) & 31) + ((block_id) & 7) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_RX_LMACS(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_RX_LMACS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_RX_LMACS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0000308ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_RX_LMACS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0000308ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_RX_LMACS(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000308ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_RX_LMACS(offset) (CVMX_ADD_IO_SEG(0x00011800E0000308ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_RX_OVR_BP(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_RX_OVR_BP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_RX_OVR_BP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0000318ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_RX_OVR_BP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0000318ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_RX_OVR_BP(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000318ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_RX_OVR_BP(offset) (CVMX_ADD_IO_SEG(0x00011800E0000318ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_CMR_TX_LMACS(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_CMR_TX_LMACS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_CMR_TX_LMACS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0001000ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_CMR_TX_LMACS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0001000ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_CMR_TX_LMACS(block_id) (CVMX_ADD_IO_SEG(0x00011800E0001000ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_CMR_TX_LMACS(offset) (CVMX_ADD_IO_SEG(0x00011800E0001000ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_BGXX_GMP_GMI_PRTX_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_PRTX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -694,6 +764,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_PRTX_CFG(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_DECISION(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -705,6 +776,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_DECISION(unsigned long offset, unsi
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -716,6 +788,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -727,6 +800,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_IFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -738,6 +812,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_IFG(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -749,6 +824,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_INT(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_JABBER(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -760,6 +836,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_JABBER(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -771,6 +848,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_GMI_SMACX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_SMACX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038230ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -782,6 +860,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_SMACX(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_APPEND(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -793,6 +872,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_APPEND(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_BURST(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_BURST(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038228ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -804,6 +884,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_BURST(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038270ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -815,6 +896,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_CTL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038500ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -826,6 +908,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_INT(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038240ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -837,6 +920,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038248ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -848,6 +932,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long of
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038238ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -859,6 +944,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long offset
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038258ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -870,6 +956,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038260ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -881,6 +968,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038300ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -892,6 +980,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long offset, uns
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SLOT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SLOT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038220ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -903,6 +992,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SLOT(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038250ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -914,6 +1004,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_THRESH(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -922,75 +1013,82 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_THRESH(unsigned long offset, unsign
 #define CVMX_BGXX_GMP_GMI_TXX_THRESH(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800E0038210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0039010ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0039010ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(block_id) (CVMX_ADD_IO_SEG(0x00011800E0039010ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(offset) (CVMX_ADD_IO_SEG(0x00011800E0039010ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_GMP_GMI_TX_IFG(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_GMP_GMI_TX_IFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_IFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0039000ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_IFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0039000ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_GMP_GMI_TX_IFG(block_id) (CVMX_ADD_IO_SEG(0x00011800E0039000ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_GMP_GMI_TX_IFG(offset) (CVMX_ADD_IO_SEG(0x00011800E0039000ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_GMP_GMI_TX_JAM(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_GMP_GMI_TX_JAM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_JAM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0039008ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_JAM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0039008ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_GMP_GMI_TX_JAM(block_id) (CVMX_ADD_IO_SEG(0x00011800E0039008ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_GMP_GMI_TX_JAM(offset) (CVMX_ADD_IO_SEG(0x00011800E0039008ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_GMP_GMI_TX_LFSR(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_GMP_GMI_TX_LFSR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_LFSR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0039028ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_LFSR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0039028ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_GMP_GMI_TX_LFSR(block_id) (CVMX_ADD_IO_SEG(0x00011800E0039028ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_GMP_GMI_TX_LFSR(offset) (CVMX_ADD_IO_SEG(0x00011800E0039028ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0039018ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0039018ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(block_id) (CVMX_ADD_IO_SEG(0x00011800E0039018ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(offset) (CVMX_ADD_IO_SEG(0x00011800E0039018ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0039020ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0039020ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(block_id) (CVMX_ADD_IO_SEG(0x00011800E0039020ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(offset) (CVMX_ADD_IO_SEG(0x00011800E0039020ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_ADV(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1002,6 +1100,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_ADV(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_EXT_ST(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_EXT_ST(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1013,6 +1112,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_EXT_ST(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1024,6 +1124,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_RESULTS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_RESULTS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1035,6 +1136,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_RESULTS(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_INTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_INTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1046,6 +1148,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_INTX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_BGXX_GMP_PCS_LINKX_TIMER(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_LINKX_TIMER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1057,6 +1160,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_LINKX_TIMER(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_MISCX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MISCX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1068,6 +1172,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MISCX_CTL(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1079,6 +1184,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_CONTROL(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1090,6 +1196,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_STATUS(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_STATES(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1101,6 +1208,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_STATES(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_SYNC(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_SYNC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1112,6 +1220,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_SYNC(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1123,6 +1232,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1134,6 +1244,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_TXX_STATES(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1145,6 +1256,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TXX_STATES(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1156,6 +1268,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long offset, u
 static inline uint64_t CVMX_BGXX_SMUX_CBFC_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1167,6 +1280,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CBFC_CTL(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SMUX_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020200ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1178,6 +1292,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CTRL(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_BGXX_SMUX_EXT_LOOPBACK(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_EXT_LOOPBACK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020208ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1189,6 +1304,7 @@ static inline uint64_t CVMX_BGXX_SMUX_EXT_LOOPBACK(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_SMUX_HG2_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_HG2_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1200,6 +1316,7 @@ static inline uint64_t CVMX_BGXX_SMUX_HG2_CONTROL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_HI(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_HI(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1211,6 +1328,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_HI(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_LO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_LO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1222,6 +1340,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_LO(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_RX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1233,6 +1352,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_CTL(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_RX_DECISION(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1244,6 +1364,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_DECISION(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CHK(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1255,6 +1376,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CHK(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1266,6 +1388,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CTL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_RX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1277,6 +1400,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_INT(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_RX_JABBER(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1288,6 +1412,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_JABBER(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SMUX_RX_UDD_SKP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1299,6 +1424,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_UDD_SKP(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_SMAC(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_SMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020108ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1310,6 +1436,7 @@ static inline uint64_t CVMX_BGXX_SMUX_SMAC(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_BGXX_SMUX_TX_APPEND(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020100ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1321,6 +1448,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_APPEND(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SMUX_TX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020160ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1332,6 +1460,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_CTL(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_TX_IFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020148ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1343,6 +1472,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_IFG(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_TX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1354,6 +1484,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_INT(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_TX_MIN_PKT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020118ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1365,6 +1496,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_MIN_PKT(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020150ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1376,6 +1508,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020120ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1387,6 +1520,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long offset
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020110ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1398,6 +1532,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020158ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1409,6 +1544,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_TOGO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1420,6 +1556,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_TOGO(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_ZERO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1431,6 +1568,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_ZERO(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_TX_SOFT_PAUSE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020128ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1442,6 +1580,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_SOFT_PAUSE(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_TX_THRESH(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020168ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1453,6 +1592,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_THRESH(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_AN_ADV(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100D8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1464,6 +1604,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_ADV(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SPUX_AN_BP_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100F8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1475,6 +1616,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_BP_STATUS(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_SPUX_AN_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100C8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1486,6 +1628,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_CONTROL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_AN_LP_BASE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_BASE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100E0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1497,6 +1640,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_BASE(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_AN_LP_XNP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_XNP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100F0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1508,6 +1652,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_XNP(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_AN_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100D0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1519,6 +1664,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_STATUS(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_AN_XNP_TX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_XNP_TX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100E8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1530,6 +1676,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_XNP_TX(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_BR_ALGN_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_ALGN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1541,6 +1688,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_ALGN_STATUS(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1552,6 +1700,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_SPUX_BR_LANE_MAP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_LANE_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1563,6 +1712,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_LANE_MAP(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1574,6 +1724,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_CONTROL(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_CUP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010088ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1585,6 +1736,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_CUP(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_REP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010090ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1596,6 +1748,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_REP(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_CUP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1607,6 +1760,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_CUP(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_REP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1618,6 +1772,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_REP(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1629,6 +1784,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_STATUS(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1640,6 +1796,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS1(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1651,6 +1808,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS2(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_BR_TP_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1662,6 +1820,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_CONTROL(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_TP_ERR_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1673,6 +1832,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_ERR_CNT(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BX_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1684,6 +1844,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BX_STATUS(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_CONTROL1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1695,6 +1856,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL1(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SPUX_CONTROL2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1706,6 +1868,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL2(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SPUX_FEC_ABIL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010098ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1717,6 +1880,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_ABIL(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SPUX_FEC_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100A0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1728,6 +1892,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CONTROL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS01(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100A8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1739,6 +1904,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS01(unsigned long offset, unsi
 static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS23(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100B0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1750,6 +1916,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS23(unsigned long offset, unsi
 static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100B8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1761,6 +1928,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100C0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1772,6 +1940,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SPUX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010220ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1783,6 +1952,7 @@ static inline uint64_t CVMX_BGXX_SPUX_INT(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_BGXX_SPUX_LPCS_STATES(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_LPCS_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010208ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1794,6 +1964,7 @@ static inline uint64_t CVMX_BGXX_SPUX_LPCS_STATES(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_MISC_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_MISC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1805,6 +1976,7 @@ static inline uint64_t CVMX_BGXX_SPUX_MISC_CONTROL(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_SPUX_SPD_ABIL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_SPD_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1816,6 +1988,7 @@ static inline uint64_t CVMX_BGXX_SPUX_SPD_ABIL(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SPUX_STATUS1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1827,6 +2000,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS1(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_BGXX_SPUX_STATUS2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1835,53 +2009,58 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS2(unsigned long offset, unsigned lon
 #define CVMX_BGXX_SPUX_STATUS2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800E0010020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_SPU_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_SPU_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_SPU_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0010318ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_SPU_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0010318ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_SPU_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800E0010318ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_SPU_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800E0010318ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_SPU_DBG_CONTROL(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_SPU_DBG_CONTROL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_SPU_DBG_CONTROL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0010300ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_SPU_DBG_CONTROL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0010300ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_SPU_DBG_CONTROL(block_id) (CVMX_ADD_IO_SEG(0x00011800E0010300ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_SPU_DBG_CONTROL(offset) (CVMX_ADD_IO_SEG(0x00011800E0010300ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_SPU_MEM_INT(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_SPU_MEM_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_SPU_MEM_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0010310ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_SPU_MEM_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0010310ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_SPU_MEM_INT(block_id) (CVMX_ADD_IO_SEG(0x00011800E0010310ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_SPU_MEM_INT(offset) (CVMX_ADD_IO_SEG(0x00011800E0010310ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_BGXX_SPU_MEM_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_BGXX_SPU_MEM_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
-		cvmx_warn("CVMX_BGXX_SPU_MEM_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800E0010308ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_BGXX_SPU_MEM_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800E0010308ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_BGXX_SPU_MEM_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800E0010308ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_BGXX_SPU_MEM_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800E0010308ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_BGXX_SPU_SDSX_SKEW_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_SKEW_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010320ull) + (((offset) & 3) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -1893,6 +2072,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_SKEW_STATUS(unsigned long offset, unsi
 static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010340ull) + (((offset) & 3) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -1940,6 +2120,11 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned
  *                                  BGXn_CMR2_CONFIG     1           0
  *                                  BGXn_CMR3_CONFIG     1           0
  *   ---------------------------------------------------------------------------
+ *   3xSGMIII/1000BASE-X     4      BGXn_CMR0_CONFIG     1           5
+ *   + 1xRGMII                      BGXn_CMR1_CONFIG     1           0
+ *                                  BGXn_CMR2_CONFIG     1           0
+ *                                  BGXn_CMR3_CONFIG     1           0
+ *   ---------------------------------------------------------------------------
  * </pre>
  */
 union cvmx_bgxx_cmrx_config {
@@ -2027,6 +2212,7 @@ union cvmx_bgxx_cmrx_config {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_config_s        cn73xx;
 	struct cvmx_bgxx_cmrx_config_s        cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_config cvmx_bgxx_cmrx_config_t;
@@ -2050,6 +2236,7 @@ union cvmx_bgxx_cmrx_int {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_int_s           cn73xx;
 	struct cvmx_bgxx_cmrx_int_s           cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_int cvmx_bgxx_cmrx_int_t;
@@ -2076,6 +2263,7 @@ union cvmx_bgxx_cmrx_prt_cbfc_ctl {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s  cn73xx;
 	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s  cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_prt_cbfc_ctl cvmx_bgxx_cmrx_prt_cbfc_ctl_t;
@@ -2106,6 +2294,7 @@ union cvmx_bgxx_cmrx_rx_adr_ctl {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_adr_ctl_s    cn73xx;
 	struct cvmx_bgxx_cmrx_rx_adr_ctl_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_adr_ctl cvmx_bgxx_cmrx_rx_adr_ctl_t;
@@ -2128,6 +2317,7 @@ union cvmx_bgxx_cmrx_rx_bp_drop {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_bp_drop_s    cn73xx;
 	struct cvmx_bgxx_cmrx_rx_bp_drop_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_drop cvmx_bgxx_cmrx_rx_bp_drop_t;
@@ -2147,6 +2337,7 @@ union cvmx_bgxx_cmrx_rx_bp_off {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_bp_off_s     cn73xx;
 	struct cvmx_bgxx_cmrx_rx_bp_off_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_off cvmx_bgxx_cmrx_rx_bp_off_t;
@@ -2174,6 +2365,7 @@ union cvmx_bgxx_cmrx_rx_bp_on {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_bp_on_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_bp_on_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_on cvmx_bgxx_cmrx_rx_bp_on_t;
@@ -2194,6 +2386,7 @@ union cvmx_bgxx_cmrx_rx_bp_status {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_bp_status_s  cn73xx;
 	struct cvmx_bgxx_cmrx_rx_bp_status_s  cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_status cvmx_bgxx_cmrx_rx_bp_status_t;
@@ -2212,6 +2405,7 @@ union cvmx_bgxx_cmrx_rx_fifo_len {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_fifo_len_s   cn73xx;
 	struct cvmx_bgxx_cmrx_rx_fifo_len_s   cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_fifo_len cvmx_bgxx_cmrx_rx_fifo_len_t;
@@ -2242,6 +2436,25 @@ union cvmx_bgxx_cmrx_rx_id_map {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_id_map_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t rid                          : 7;  /**< Reassembly ID map for this LMAC. A shared pool of 96 reassembly IDs (RIDs) exists for all
+                                                         MACs.
+                                                         The RID for this LMAC must be constrained such that it does not overlap with any other MAC
+                                                         in the system. Its reset value has been chosen such that this condition is satisfied:
+                                                         _ RID reset value = 4*(BGX_ID + 1) + LMAC_ID
+                                                         Changes to RID must only occur when the LMAC is quiescent (i.e. the LMAC receive interface
+                                                         is down and the RX FIFO is empty). */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t pknd                         : 6;  /**< Port kind for this LMAC. */
+#else
+	uint64_t pknd                         : 6;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t rid                          : 7;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} cn73xx;
 	struct cvmx_bgxx_cmrx_rx_id_map_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_id_map cvmx_bgxx_cmrx_rx_id_map_t;
@@ -2263,6 +2476,7 @@ union cvmx_bgxx_cmrx_rx_logl_xoff {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_logl_xoff_s  cn73xx;
 	struct cvmx_bgxx_cmrx_rx_logl_xoff_s  cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_logl_xoff cvmx_bgxx_cmrx_rx_logl_xoff_t;
@@ -2284,6 +2498,7 @@ union cvmx_bgxx_cmrx_rx_logl_xon {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_logl_xon_s   cn73xx;
 	struct cvmx_bgxx_cmrx_rx_logl_xon_s   cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_logl_xon cvmx_bgxx_cmrx_rx_logl_xon_t;
@@ -2302,6 +2517,7 @@ union cvmx_bgxx_cmrx_rx_pause_drop_time {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s cn73xx;
 	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_pause_drop_time cvmx_bgxx_cmrx_rx_pause_drop_time_t;
@@ -2327,6 +2543,7 @@ union cvmx_bgxx_cmrx_rx_stat0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat0_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat0_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat0 cvmx_bgxx_cmrx_rx_stat0_t;
@@ -2349,6 +2566,7 @@ union cvmx_bgxx_cmrx_rx_stat1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat1_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat1_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat1 cvmx_bgxx_cmrx_rx_stat1_t;
@@ -2375,6 +2593,7 @@ union cvmx_bgxx_cmrx_rx_stat2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat2_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat2_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat2 cvmx_bgxx_cmrx_rx_stat2_t;
@@ -2397,6 +2616,7 @@ union cvmx_bgxx_cmrx_rx_stat3 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat3_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat3_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat3 cvmx_bgxx_cmrx_rx_stat3_t;
@@ -2422,6 +2642,7 @@ union cvmx_bgxx_cmrx_rx_stat4 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat4_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat4_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat4 cvmx_bgxx_cmrx_rx_stat4_t;
@@ -2444,6 +2665,7 @@ union cvmx_bgxx_cmrx_rx_stat5 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat5_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat5_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat5 cvmx_bgxx_cmrx_rx_stat5_t;
@@ -2468,6 +2690,7 @@ union cvmx_bgxx_cmrx_rx_stat6 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat6_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat6_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat6 cvmx_bgxx_cmrx_rx_stat6_t;
@@ -2490,6 +2713,7 @@ union cvmx_bgxx_cmrx_rx_stat7 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat7_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat7_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat7 cvmx_bgxx_cmrx_rx_stat7_t;
@@ -2529,6 +2753,7 @@ union cvmx_bgxx_cmrx_rx_stat8 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat8_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat8_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat8 cvmx_bgxx_cmrx_rx_stat8_t;
@@ -2549,6 +2774,7 @@ union cvmx_bgxx_cmrx_rx_weight {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_weight_s     cn73xx;
 	struct cvmx_bgxx_cmrx_rx_weight_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_weight cvmx_bgxx_cmrx_rx_weight_t;
@@ -2573,6 +2799,7 @@ union cvmx_bgxx_cmrx_tx_channel {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_channel_s    cn73xx;
 	struct cvmx_bgxx_cmrx_tx_channel_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_channel cvmx_bgxx_cmrx_tx_channel_t;
@@ -2595,6 +2822,7 @@ union cvmx_bgxx_cmrx_tx_fifo_len {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_fifo_len_s   cn73xx;
 	struct cvmx_bgxx_cmrx_tx_fifo_len_s   cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_fifo_len cvmx_bgxx_cmrx_tx_fifo_len_t;
@@ -2618,6 +2846,7 @@ union cvmx_bgxx_cmrx_tx_hg2_status {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_hg2_status_s cn73xx;
 	struct cvmx_bgxx_cmrx_tx_hg2_status_s cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_hg2_status cvmx_bgxx_cmrx_tx_hg2_status_t;
@@ -2638,6 +2867,7 @@ union cvmx_bgxx_cmrx_tx_ovr_bp {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_ovr_bp_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_ovr_bp_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_ovr_bp cvmx_bgxx_cmrx_tx_ovr_bp_t;
@@ -2651,7 +2881,8 @@ union cvmx_bgxx_cmrx_tx_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t xscol                        : 48; /**< Number of packets dropped (never successfully sent) due to excessive collision. Defined by
-                                                         BGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. SGMII/1000Base-X half-duplex only.
+                                                         BGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. Half-duplex mode only and does not account for late
+                                                         collisions.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2659,6 +2890,7 @@ union cvmx_bgxx_cmrx_tx_stat0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat0_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat0_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat0 cvmx_bgxx_cmrx_tx_stat0_t;
@@ -2671,8 +2903,9 @@ union cvmx_bgxx_cmrx_tx_stat1 {
 	struct cvmx_bgxx_cmrx_tx_stat1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t xsdef                        : 48; /**< Number of packets dropped (never successfully sent) due to excessive deferral.
-                                                         SGMII/1000BASE-X half-duplex only.
+	uint64_t xsdef                        : 48; /**< A count of the number of times any frame was deferred for an excessive period of time.
+                                                         See maxDeferTime in the IEEE 802.3 specification. Half-duplex mode only and not updated
+                                                         for late collision
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2680,6 +2913,7 @@ union cvmx_bgxx_cmrx_tx_stat1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat1_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat1_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat1 cvmx_bgxx_cmrx_tx_stat1_t;
@@ -2694,8 +2928,7 @@ union cvmx_bgxx_cmrx_tx_stat10 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist4                        : 48; /**< Number of packets sent with an octet count between 256-511. Packet length is the sum of
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
-                                                         FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
-                                                         EXTEND cycles.
+                                                         FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2703,6 +2936,7 @@ union cvmx_bgxx_cmrx_tx_stat10 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat10_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat10_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat10 cvmx_bgxx_cmrx_tx_stat10_t;
@@ -2717,8 +2951,7 @@ union cvmx_bgxx_cmrx_tx_stat11 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist5                        : 48; /**< Number of packets sent with an octet count between 512-1023. Packet length is the sum of
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
-                                                         FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
-                                                         EXTEND cycles.
+                                                         FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2726,6 +2959,7 @@ union cvmx_bgxx_cmrx_tx_stat11 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat11_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat11_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat11 cvmx_bgxx_cmrx_tx_stat11_t;
@@ -2740,8 +2974,7 @@ union cvmx_bgxx_cmrx_tx_stat12 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist6                        : 48; /**< Number of packets sent with an octet count between 1024-1518. Packet length is the sum of
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
-                                                         FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
-                                                         EXTEND cycles.
+                                                         FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2749,6 +2982,7 @@ union cvmx_bgxx_cmrx_tx_stat12 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat12_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat12_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat12 cvmx_bgxx_cmrx_tx_stat12_t;
@@ -2763,8 +2997,7 @@ union cvmx_bgxx_cmrx_tx_stat13 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist7                        : 48; /**< Number of packets sent with an octet count > 1518. Packet length is the sum of all data
                                                          transmitted on the wire for the given packet including packet data, pad bytes, FCS bytes,
-                                                         PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
-                                                         cycles.
+                                                         and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2772,6 +3005,7 @@ union cvmx_bgxx_cmrx_tx_stat13 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat13_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat13_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat13 cvmx_bgxx_cmrx_tx_stat13_t;
@@ -2784,7 +3018,8 @@ union cvmx_bgxx_cmrx_tx_stat14 {
 	struct cvmx_bgxx_cmrx_tx_stat14_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t bcst                         : 48; /**< Number of packets sent to broadcast DMAC. Does not include MCST packets.
+	uint64_t bcst                         : 48; /**< Number of packets sent to broadcast DMAC, excluding PAUSE or PFC control packets generated
+                                                         by BGX. Does not include MCST packets.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap.
                                                          Note that BGX determines if the packet is MCST or BCST from the DMAC of the packet. BGX
                                                          assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
@@ -2796,6 +3031,7 @@ union cvmx_bgxx_cmrx_tx_stat14 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat14_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat14_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat14 cvmx_bgxx_cmrx_tx_stat14_t;
@@ -2808,7 +3044,8 @@ union cvmx_bgxx_cmrx_tx_stat15 {
 	struct cvmx_bgxx_cmrx_tx_stat15_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t mcst                         : 48; /**< Number of packets sent to multicast DMAC. Does not include BCST packets.
+	uint64_t mcst                         : 48; /**< Number of packets sent to multicast DMAC, excluding PAUSE or PFC control packets generated
+                                                         by BGX. Does not include BCST packets.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap.
                                                          Note that BGX determines if the packet is MCST or BCST from the DMAC of the packet. BGX
                                                          assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
@@ -2820,6 +3057,7 @@ union cvmx_bgxx_cmrx_tx_stat15 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat15_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat15_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat15 cvmx_bgxx_cmrx_tx_stat15_t;
@@ -2840,6 +3078,7 @@ union cvmx_bgxx_cmrx_tx_stat16 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat16_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat16_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat16 cvmx_bgxx_cmrx_tx_stat16_t;
@@ -2852,10 +3091,9 @@ union cvmx_bgxx_cmrx_tx_stat17 {
 	struct cvmx_bgxx_cmrx_tx_stat17_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t ctl                          : 48; /**< Number of control packets (PAUSE flow control) generated by BGX. It does not include
-                                                         control packets forwarded or generated by the cores.
-                                                         CTL counts the number of generated PFC frames and does not track the number of generated
-                                                         HG2 messages.
+	uint64_t ctl                          : 48; /**< Number of PAUSE or PFC control packets generated by BGX. It does not include control
+                                                         packets forwarded or generated by the cores. Does not track the number of generated HG2
+                                                         messages.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2863,6 +3101,7 @@ union cvmx_bgxx_cmrx_tx_stat17 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat17_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat17_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat17 cvmx_bgxx_cmrx_tx_stat17_t;
@@ -2876,7 +3115,8 @@ union cvmx_bgxx_cmrx_tx_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t mcol                         : 48; /**< Number of packets sent with multiple collisions. Must be less than
-                                                         BGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. SGMII/1000BASE-X half-duplex only.
+                                                         BGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. Half-duplex mode only and not updated for late
+                                                         collisions.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2884,6 +3124,7 @@ union cvmx_bgxx_cmrx_tx_stat2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat2_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat2_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat2 cvmx_bgxx_cmrx_tx_stat2_t;
@@ -2896,7 +3137,8 @@ union cvmx_bgxx_cmrx_tx_stat3 {
 	struct cvmx_bgxx_cmrx_tx_stat3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t scol                         : 48; /**< Number of packets sent with a single collision. SGMII/1000BASE-X half-duplex only.
+	uint64_t scol                         : 48; /**< Number of packets sent with a single collision. Half-duplex mode only and not updated for
+                                                         late collisions.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2904,6 +3146,7 @@ union cvmx_bgxx_cmrx_tx_stat3 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat3_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat3_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat3 cvmx_bgxx_cmrx_tx_stat3_t;
@@ -2916,11 +3159,12 @@ union cvmx_bgxx_cmrx_tx_stat4 {
 	struct cvmx_bgxx_cmrx_tx_stat4_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t octs                         : 48; /**< Number of total octets sent on the interface. Does not count octets from frames that were
-                                                         truncated due to collisions in half-duplex mode.
+	uint64_t octs                         : 48; /**< Number of total octets sent on the interface, excluding PAUSE or PFC control packets
+                                                         generated by BGX. Does not count octets from frames that were truncated due to collisions
+                                                         in half-duplex mode.
                                                          Octet counts are the sum of all data transmitted on the wire including packet data, pad
-                                                         bytes, FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE
-                                                         byte or EXTEND cycles.
+                                                         bytes, FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
+                                                         cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2928,6 +3172,7 @@ union cvmx_bgxx_cmrx_tx_stat4 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat4_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat4_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat4 cvmx_bgxx_cmrx_tx_stat4_t;
@@ -2940,8 +3185,9 @@ union cvmx_bgxx_cmrx_tx_stat5 {
 	struct cvmx_bgxx_cmrx_tx_stat5_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t pkts                         : 48; /**< Number of total frames sent on the interface. Does not count octets from frames that were
-                                                         truncated due to collisions in half-duplex mode.
+	uint64_t pkts                         : 48; /**< Number of total frames sent on the interface, excluding PAUSE or PFC control packets
+                                                         generated by BGX. Does not count octets from frames that were truncated due to collisions
+                                                         in half-duplex mode.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2949,6 +3195,7 @@ union cvmx_bgxx_cmrx_tx_stat5 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat5_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat5_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat5 cvmx_bgxx_cmrx_tx_stat5_t;
@@ -2961,10 +3208,10 @@ union cvmx_bgxx_cmrx_tx_stat6 {
 	struct cvmx_bgxx_cmrx_tx_stat6_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t hist0                        : 48; /**< Number of packets sent with an octet count < 64. Packet length is the sum of all data
-                                                         transmitted on the wire for the given packet including packet data, pad bytes, FCS bytes,
-                                                         PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
-                                                         cycles.
+	uint64_t hist0                        : 48; /**< Number of packets sent with an octet count < 64, excluding PAUSE or PFC control packets
+                                                         generated by BGX. Packet length is the sum of all data transmitted on the wire for the
+                                                         given packet including packet data, pad bytes, FCS bytes, and JAM bytes. The octet counts
+                                                         do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2972,6 +3219,7 @@ union cvmx_bgxx_cmrx_tx_stat6 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat6_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat6_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat6 cvmx_bgxx_cmrx_tx_stat6_t;
@@ -2984,10 +3232,10 @@ union cvmx_bgxx_cmrx_tx_stat7 {
 	struct cvmx_bgxx_cmrx_tx_stat7_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t hist1                        : 48; /**< Number of packets sent with an octet count of 64. Packet length is the sum of all data
-                                                         transmitted on the wire for the given packet including packet data, pad bytes, FCS bytes,
-                                                         PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
-                                                         cycles.
+	uint64_t hist1                        : 48; /**< Number of packets sent with an octet count of 64, excluding PAUSE or PFC control packets
+                                                         generated by BGX. Packet length is the sum of all data transmitted on the wire for the
+                                                         given packet including packet data, pad bytes, FCS bytes, and JAM bytes. The octet counts
+                                                         do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2995,6 +3243,7 @@ union cvmx_bgxx_cmrx_tx_stat7 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat7_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat7_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat7 cvmx_bgxx_cmrx_tx_stat7_t;
@@ -3009,8 +3258,7 @@ union cvmx_bgxx_cmrx_tx_stat8 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist2                        : 48; /**< Number of packets sent with an octet count between 65-127. Packet length is the sum of all
                                                          data transmitted on the wire for the given packet including packet data, pad bytes, FCS
-                                                         bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
-                                                         cycles.
+                                                         bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -3018,6 +3266,7 @@ union cvmx_bgxx_cmrx_tx_stat8 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat8_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat8_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat8 cvmx_bgxx_cmrx_tx_stat8_t;
@@ -3032,8 +3281,7 @@ union cvmx_bgxx_cmrx_tx_stat9 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist3                        : 48; /**< Number of packets sent with an octet count between 128-255. Packet length is the sum of
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
-                                                         FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
-                                                         EXTEND cycles.
+                                                         FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -3041,6 +3289,7 @@ union cvmx_bgxx_cmrx_tx_stat9 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat9_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat9_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat9 cvmx_bgxx_cmrx_tx_stat9_t;
@@ -3059,6 +3308,7 @@ union cvmx_bgxx_cmr_bad {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_bad_s            cn73xx;
 	struct cvmx_bgxx_cmr_bad_s            cn78xx;
 };
 typedef union cvmx_bgxx_cmr_bad cvmx_bgxx_cmr_bad_t;
@@ -3094,6 +3344,7 @@ union cvmx_bgxx_cmr_bist_status {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_bist_status_s    cn73xx;
 	struct cvmx_bgxx_cmr_bist_status_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmr_bist_status cvmx_bgxx_cmr_bist_status_t;
@@ -3119,6 +3370,7 @@ union cvmx_bgxx_cmr_chan_msk_and {
 	uint64_t msk_and                      : 64;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_chan_msk_and_s   cn73xx;
 	struct cvmx_bgxx_cmr_chan_msk_and_s   cn78xx;
 };
 typedef union cvmx_bgxx_cmr_chan_msk_and cvmx_bgxx_cmr_chan_msk_and_t;
@@ -3144,11 +3396,31 @@ union cvmx_bgxx_cmr_chan_msk_or {
 	uint64_t msk_or                       : 64;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_chan_msk_or_s    cn73xx;
 	struct cvmx_bgxx_cmr_chan_msk_or_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmr_chan_msk_or cvmx_bgxx_cmr_chan_msk_or_t;
 
 /**
+ * cvmx_bgx#_cmr_eco
+ */
+union cvmx_bgxx_cmr_eco {
+	uint64_t u64;
+	struct cvmx_bgxx_cmr_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t eco_ro                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t eco_ro                       : 32;
+#endif
+	} s;
+	struct cvmx_bgxx_cmr_eco_s            cn73xx;
+	struct cvmx_bgxx_cmr_eco_s            cn78xx;
+};
+typedef union cvmx_bgxx_cmr_eco cvmx_bgxx_cmr_eco_t;
+
+/**
  * cvmx_bgx#_cmr_global_config
  *
  * These registers configure the global CMR, PCS, and MAC.
@@ -3200,6 +3472,7 @@ union cvmx_bgxx_cmr_global_config {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_global_config_s  cn73xx;
 	struct cvmx_bgxx_cmr_global_config_s  cn78xx;
 };
 typedef union cvmx_bgxx_cmr_global_config cvmx_bgxx_cmr_global_config_t;
@@ -3248,6 +3521,7 @@ union cvmx_bgxx_cmr_mem_ctrl {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_mem_ctrl_s       cn73xx;
 	struct cvmx_bgxx_cmr_mem_ctrl_s       cn78xx;
 };
 typedef union cvmx_bgxx_cmr_mem_ctrl cvmx_bgxx_cmr_mem_ctrl_t;
@@ -3300,6 +3574,7 @@ union cvmx_bgxx_cmr_mem_int {
 	uint64_t reserved_18_63               : 46;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_mem_int_s        cn73xx;
 	struct cvmx_bgxx_cmr_mem_int_s        cn78xx;
 };
 typedef union cvmx_bgxx_cmr_mem_int cvmx_bgxx_cmr_mem_int_t;
@@ -3320,6 +3595,7 @@ union cvmx_bgxx_cmr_nxc_adr {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_nxc_adr_s        cn73xx;
 	struct cvmx_bgxx_cmr_nxc_adr_s        cn78xx;
 };
 typedef union cvmx_bgxx_cmr_nxc_adr cvmx_bgxx_cmr_nxc_adr_t;
@@ -3360,6 +3636,7 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_rx_adrx_cam_s    cn73xx;
 	struct cvmx_bgxx_cmr_rx_adrx_cam_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmr_rx_adrx_cam cvmx_bgxx_cmr_rx_adrx_cam_t;
@@ -3389,6 +3666,7 @@ union cvmx_bgxx_cmr_rx_lmacs {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_rx_lmacs_s       cn73xx;
 	struct cvmx_bgxx_cmr_rx_lmacs_s       cn78xx;
 };
 typedef union cvmx_bgxx_cmr_rx_lmacs cvmx_bgxx_cmr_rx_lmacs_t;
@@ -3425,6 +3703,7 @@ union cvmx_bgxx_cmr_rx_ovr_bp {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_rx_ovr_bp_s      cn73xx;
 	struct cvmx_bgxx_cmr_rx_ovr_bp_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmr_rx_ovr_bp cvmx_bgxx_cmr_rx_ovr_bp_t;
@@ -3457,6 +3736,7 @@ union cvmx_bgxx_cmr_tx_lmacs {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_tx_lmacs_s       cn73xx;
 	struct cvmx_bgxx_cmr_tx_lmacs_s       cn78xx;
 };
 typedef union cvmx_bgxx_cmr_tx_lmacs cvmx_bgxx_cmr_tx_lmacs_t;
@@ -3504,6 +3784,7 @@ union cvmx_bgxx_gmp_gmi_prtx_cfg {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_prtx_cfg_s   cn73xx;
 	struct cvmx_bgxx_gmp_gmi_prtx_cfg_s   cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_prtx_cfg cvmx_bgxx_gmp_gmi_prtx_cfg_t;
@@ -3549,6 +3830,7 @@ union cvmx_bgxx_gmp_gmi_rxx_decision {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_decision_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_decision_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_decision cvmx_bgxx_gmp_gmi_rxx_decision_t;
@@ -3581,6 +3863,7 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_chk {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_frm_chk_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_chk_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_frm_chk cvmx_bgxx_gmp_gmi_rxx_frm_chk_t;
@@ -3675,6 +3958,7 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_frm_ctl cvmx_bgxx_gmp_gmi_rxx_frm_ctl_t;
@@ -3701,6 +3985,7 @@ union cvmx_bgxx_gmp_gmi_rxx_ifg {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_ifg_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_ifg_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_ifg cvmx_bgxx_gmp_gmi_rxx_ifg_t;
@@ -3816,6 +4101,7 @@ union cvmx_bgxx_gmp_gmi_rxx_int {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_int_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_int_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_int cvmx_bgxx_gmp_gmi_rxx_int_t;
@@ -3839,6 +4125,7 @@ union cvmx_bgxx_gmp_gmi_rxx_jabber {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_jabber_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_jabber_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_jabber cvmx_bgxx_gmp_gmi_rxx_jabber_t;
@@ -3898,6 +4185,7 @@ union cvmx_bgxx_gmp_gmi_rxx_udd_skp {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_udd_skp_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_udd_skp_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_udd_skp cvmx_bgxx_gmp_gmi_rxx_udd_skp_t;
@@ -3916,6 +4204,7 @@ union cvmx_bgxx_gmp_gmi_smacx {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_smacx_s      cn73xx;
 	struct cvmx_bgxx_gmp_gmi_smacx_s      cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_smacx cvmx_bgxx_gmp_gmi_smacx_t;
@@ -3940,6 +4229,7 @@ union cvmx_bgxx_gmp_gmi_txx_append {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_append_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_append_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_append cvmx_bgxx_gmp_gmi_txx_append_t;
@@ -3962,6 +4252,7 @@ union cvmx_bgxx_gmp_gmi_txx_burst {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_burst_s  cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_burst_s  cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_burst cvmx_bgxx_gmp_gmi_txx_burst_t;
@@ -3984,6 +4275,7 @@ union cvmx_bgxx_gmp_gmi_txx_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_ctl_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_ctl_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_ctl cvmx_bgxx_gmp_gmi_txx_ctl_t;
@@ -4010,6 +4302,7 @@ union cvmx_bgxx_gmp_gmi_txx_int {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_int_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_int_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_int cvmx_bgxx_gmp_gmi_txx_int_t;
@@ -4031,6 +4324,7 @@ union cvmx_bgxx_gmp_gmi_txx_min_pkt {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_min_pkt_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_min_pkt_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_min_pkt cvmx_bgxx_gmp_gmi_txx_min_pkt_t;
@@ -4072,6 +4366,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_t;
@@ -4093,6 +4388,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_t;
@@ -4111,6 +4407,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_togo {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_togo_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_togo_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_togo cvmx_bgxx_gmp_gmi_txx_pause_togo_t;
@@ -4130,6 +4427,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_zero {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_zero_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_zero_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_zero cvmx_bgxx_gmp_gmi_txx_pause_zero_t;
@@ -4158,6 +4456,7 @@ union cvmx_bgxx_gmp_gmi_txx_sgmii_ctl {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_sgmii_ctl cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_t;
@@ -4179,6 +4478,7 @@ union cvmx_bgxx_gmp_gmi_txx_slot {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_slot_s   cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_slot_s   cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_slot cvmx_bgxx_gmp_gmi_txx_slot_t;
@@ -4197,6 +4497,7 @@ union cvmx_bgxx_gmp_gmi_txx_soft_pause {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_soft_pause cvmx_bgxx_gmp_gmi_txx_soft_pause_t;
@@ -4222,6 +4523,7 @@ union cvmx_bgxx_gmp_gmi_txx_thresh {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_thresh_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_thresh_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_thresh cvmx_bgxx_gmp_gmi_txx_thresh_t;
@@ -4240,6 +4542,7 @@ union cvmx_bgxx_gmp_gmi_tx_col_attempt {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_col_attempt_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_col_attempt_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_col_attempt cvmx_bgxx_gmp_gmi_tx_col_attempt_t;
@@ -4272,6 +4575,7 @@ union cvmx_bgxx_gmp_gmi_tx_ifg {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_ifg_s     cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_ifg_s     cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_ifg cvmx_bgxx_gmp_gmi_tx_ifg_t;
@@ -4293,6 +4597,7 @@ union cvmx_bgxx_gmp_gmi_tx_jam {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_jam_s     cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_jam_s     cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_jam cvmx_bgxx_gmp_gmi_tx_jam_t;
@@ -4315,6 +4620,7 @@ union cvmx_bgxx_gmp_gmi_tx_lfsr {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_lfsr_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_lfsr_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_lfsr cvmx_bgxx_gmp_gmi_tx_lfsr_t;
@@ -4333,6 +4639,7 @@ union cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_t;
@@ -4354,6 +4661,7 @@ union cvmx_bgxx_gmp_gmi_tx_pause_pkt_type {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_pause_pkt_type cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_t;
@@ -4395,6 +4703,7 @@ union cvmx_bgxx_gmp_pcs_anx_adv {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_anx_adv_s    cn73xx;
 	struct cvmx_bgxx_gmp_pcs_anx_adv_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_adv cvmx_bgxx_gmp_pcs_anx_adv_t;
@@ -4421,6 +4730,7 @@ union cvmx_bgxx_gmp_pcs_anx_ext_st {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_anx_ext_st_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_anx_ext_st_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_ext_st cvmx_bgxx_gmp_pcs_anx_ext_st_t;
@@ -4466,6 +4776,7 @@ union cvmx_bgxx_gmp_pcs_anx_lp_abil {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_lp_abil cvmx_bgxx_gmp_pcs_anx_lp_abil_t;
@@ -4506,6 +4817,7 @@ union cvmx_bgxx_gmp_pcs_anx_results {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_anx_results_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_anx_results_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_results cvmx_bgxx_gmp_pcs_anx_results_t;
@@ -4558,6 +4870,7 @@ union cvmx_bgxx_gmp_pcs_intx {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_intx_s       cn73xx;
 	struct cvmx_bgxx_gmp_pcs_intx_s       cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_intx cvmx_bgxx_gmp_pcs_intx_t;
@@ -4581,6 +4894,7 @@ union cvmx_bgxx_gmp_pcs_linkx_timer {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_linkx_timer_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_linkx_timer_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_linkx_timer cvmx_bgxx_gmp_pcs_linkx_timer_t;
@@ -4645,6 +4959,7 @@ union cvmx_bgxx_gmp_pcs_miscx_ctl {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s  cn73xx;
 	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s  cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_miscx_ctl cvmx_bgxx_gmp_pcs_miscx_ctl_t;
@@ -4661,7 +4976,8 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
                                                          0 = Normal operation.
                                                          1 = Software PCS reset.
                                                          The bit returns to 0 after PCS has been reset. Takes 32 coprocessor-clock cycles to reset
-                                                         PCS. */
+                                                         PCS.   This bit, when set, also drains the tx gmi fifo and can be used as a fifo draining
+                                                         mechanism. */
 	uint64_t loopbck1                     : 1;  /**< Enable loopback:
                                                            0 = Normal operation.
                                                            1 = Internal loopback mode.
@@ -4715,6 +5031,7 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_mrx_control_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_mrx_control_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_mrx_control cvmx_bgxx_gmp_pcs_mrx_control_t;
@@ -4779,6 +5096,7 @@ union cvmx_bgxx_gmp_pcs_mrx_status {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_mrx_status_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_mrx_status_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_mrx_status cvmx_bgxx_gmp_pcs_mrx_status_t;
@@ -4807,6 +5125,7 @@ union cvmx_bgxx_gmp_pcs_rxx_states {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_rxx_states_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_rxx_states_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_rxx_states cvmx_bgxx_gmp_pcs_rxx_states_t;
@@ -4827,6 +5146,7 @@ union cvmx_bgxx_gmp_pcs_rxx_sync {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_rxx_sync_s   cn73xx;
 	struct cvmx_bgxx_gmp_pcs_rxx_sync_s   cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_rxx_sync cvmx_bgxx_gmp_pcs_rxx_sync_t;
@@ -4867,6 +5187,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_an_adv {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_sgmx_an_adv_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_sgmx_an_adv_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_sgmx_an_adv cvmx_bgxx_gmp_pcs_sgmx_an_adv_t;
@@ -4902,6 +5223,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_lp_adv {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_sgmx_lp_adv_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_sgmx_lp_adv_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_sgmx_lp_adv cvmx_bgxx_gmp_pcs_sgmx_lp_adv_t;
@@ -4927,6 +5249,7 @@ union cvmx_bgxx_gmp_pcs_txx_states {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_txx_states_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_txx_states_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_txx_states cvmx_bgxx_gmp_pcs_txx_states_t;
@@ -4960,6 +5283,7 @@ union cvmx_bgxx_gmp_pcs_tx_rxx_polarity {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_tx_rxx_polarity_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_tx_rxx_polarity_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_tx_rxx_polarity cvmx_bgxx_gmp_pcs_tx_rxx_polarity_t;
@@ -4996,6 +5320,7 @@ union cvmx_bgxx_smux_cbfc_ctl {
 	uint64_t phys_en                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_cbfc_ctl_s      cn73xx;
 	struct cvmx_bgxx_smux_cbfc_ctl_s      cn78xx;
 };
 typedef union cvmx_bgxx_smux_cbfc_ctl cvmx_bgxx_smux_cbfc_ctl_t;
@@ -5018,6 +5343,7 @@ union cvmx_bgxx_smux_ctrl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_ctrl_s          cn73xx;
 	struct cvmx_bgxx_smux_ctrl_s          cn78xx;
 };
 typedef union cvmx_bgxx_smux_ctrl cvmx_bgxx_smux_ctrl_t;
@@ -5043,6 +5369,7 @@ union cvmx_bgxx_smux_ext_loopback {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_ext_loopback_s  cn73xx;
 	struct cvmx_bgxx_smux_ext_loopback_s  cn78xx;
 };
 typedef union cvmx_bgxx_smux_ext_loopback cvmx_bgxx_smux_ext_loopback_t;
@@ -5095,6 +5422,7 @@ union cvmx_bgxx_smux_hg2_control {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_hg2_control_s   cn73xx;
 	struct cvmx_bgxx_smux_hg2_control_s   cn78xx;
 };
 typedef union cvmx_bgxx_smux_hg2_control cvmx_bgxx_smux_hg2_control_t;
@@ -5118,6 +5446,7 @@ union cvmx_bgxx_smux_rx_bad_col_hi {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_bad_col_hi_s cn73xx;
 	struct cvmx_bgxx_smux_rx_bad_col_hi_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_bad_col_hi cvmx_bgxx_smux_rx_bad_col_hi_t;
@@ -5135,6 +5464,7 @@ union cvmx_bgxx_smux_rx_bad_col_lo {
 	uint64_t lane_rxd                     : 64;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_bad_col_lo_s cn73xx;
 	struct cvmx_bgxx_smux_rx_bad_col_lo_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_bad_col_lo cvmx_bgxx_smux_rx_bad_col_lo_t;
@@ -5157,6 +5487,7 @@ union cvmx_bgxx_smux_rx_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_ctl_s        cn73xx;
 	struct cvmx_bgxx_smux_rx_ctl_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_ctl cvmx_bgxx_smux_rx_ctl_t;
@@ -5181,6 +5512,7 @@ union cvmx_bgxx_smux_rx_decision {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_decision_s   cn73xx;
 	struct cvmx_bgxx_smux_rx_decision_s   cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_decision cvmx_bgxx_smux_rx_decision_t;
@@ -5214,6 +5546,7 @@ union cvmx_bgxx_smux_rx_frm_chk {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_frm_chk_s    cn73xx;
 	struct cvmx_bgxx_smux_rx_frm_chk_s    cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_frm_chk cvmx_bgxx_smux_rx_frm_chk_t;
@@ -5285,6 +5618,7 @@ union cvmx_bgxx_smux_rx_frm_ctl {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_frm_ctl_s    cn73xx;
 	struct cvmx_bgxx_smux_rx_frm_ctl_s    cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_frm_ctl cvmx_bgxx_smux_rx_frm_ctl_t;
@@ -5346,6 +5680,7 @@ union cvmx_bgxx_smux_rx_int {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_int_s        cn73xx;
 	struct cvmx_bgxx_smux_rx_int_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_int cvmx_bgxx_smux_rx_int_t;
@@ -5378,6 +5713,7 @@ union cvmx_bgxx_smux_rx_jabber {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_jabber_s     cn73xx;
 	struct cvmx_bgxx_smux_rx_jabber_s     cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_jabber cvmx_bgxx_smux_rx_jabber_t;
@@ -5434,6 +5770,7 @@ union cvmx_bgxx_smux_rx_udd_skp {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_udd_skp_s    cn73xx;
 	struct cvmx_bgxx_smux_rx_udd_skp_s    cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_udd_skp cvmx_bgxx_smux_rx_udd_skp_t;
@@ -5452,6 +5789,7 @@ union cvmx_bgxx_smux_smac {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_smac_s          cn73xx;
 	struct cvmx_bgxx_smux_smac_s          cn78xx;
 };
 typedef union cvmx_bgxx_smux_smac cvmx_bgxx_smux_smac_t;
@@ -5481,6 +5819,7 @@ union cvmx_bgxx_smux_tx_append {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_append_s     cn73xx;
 	struct cvmx_bgxx_smux_tx_append_s     cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_append cvmx_bgxx_smux_tx_append_t;
@@ -5527,13 +5866,15 @@ union cvmx_bgxx_smux_tx_ctl {
                                                          1 = Local fault. RS layer sends continuous remote fault sequences.
                                                          2 = Remote fault. RS layer sends continuous idle sequences.
                                                          3 = Link drain. RS layer drops full packets to allow BGX and PKO to drain their FIFOs. */
-	uint64_t reserved_2_3                 : 2;
+	uint64_t reserved_3_3                 : 1;
+	uint64_t x4a_dis                      : 1;  /**< Reserved. */
 	uint64_t uni_en                       : 1;  /**< Enable unidirectional mode (IEEE Clause 66). */
 	uint64_t dic_en                       : 1;  /**< Enable the deficit idle counter for IFG averaging. */
 #else
 	uint64_t dic_en                       : 1;
 	uint64_t uni_en                       : 1;
-	uint64_t reserved_2_3                 : 2;
+	uint64_t x4a_dis                      : 1;
+	uint64_t reserved_3_3                 : 1;
 	uint64_t ls                           : 2;
 	uint64_t ls_byp                       : 1;
 	uint64_t l2p_bp_conv                  : 1;
@@ -5543,6 +5884,7 @@ union cvmx_bgxx_smux_tx_ctl {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_ctl_s        cn73xx;
 	struct cvmx_bgxx_smux_tx_ctl_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_ctl cvmx_bgxx_smux_tx_ctl_t;
@@ -5569,6 +5911,7 @@ union cvmx_bgxx_smux_tx_ifg {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_ifg_s        cn73xx;
 	struct cvmx_bgxx_smux_tx_ifg_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_ifg cvmx_bgxx_smux_tx_ifg_t;
@@ -5596,6 +5939,7 @@ union cvmx_bgxx_smux_tx_int {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_int_s        cn73xx;
 	struct cvmx_bgxx_smux_tx_int_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_int cvmx_bgxx_smux_tx_int_t;
@@ -5616,6 +5960,7 @@ union cvmx_bgxx_smux_tx_min_pkt {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_min_pkt_s    cn73xx;
 	struct cvmx_bgxx_smux_tx_min_pkt_s    cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_min_pkt cvmx_bgxx_smux_tx_min_pkt_t;
@@ -5637,6 +5982,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_dmac {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_pkt_dmac_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_dmac_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_dmac cvmx_bgxx_smux_tx_pause_pkt_dmac_t;
@@ -5668,6 +6014,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_interval {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_pkt_interval_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_interval_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_interval cvmx_bgxx_smux_tx_pause_pkt_interval_t;
@@ -5689,6 +6036,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_time {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_pkt_time_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_time_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_time cvmx_bgxx_smux_tx_pause_pkt_time_t;
@@ -5710,6 +6058,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_type {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_pkt_type_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_type_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_type cvmx_bgxx_smux_tx_pause_pkt_type_t;
@@ -5731,6 +6080,7 @@ union cvmx_bgxx_smux_tx_pause_togo {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_togo_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_togo_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_togo cvmx_bgxx_smux_tx_pause_togo_t;
@@ -5750,6 +6100,7 @@ union cvmx_bgxx_smux_tx_pause_zero {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_zero_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_zero_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_zero cvmx_bgxx_smux_tx_pause_zero_t;
@@ -5768,6 +6119,7 @@ union cvmx_bgxx_smux_tx_soft_pause {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_soft_pause_s cn73xx;
 	struct cvmx_bgxx_smux_tx_soft_pause_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_soft_pause cvmx_bgxx_smux_tx_soft_pause_t;
@@ -5794,6 +6146,7 @@ union cvmx_bgxx_smux_tx_thresh {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_thresh_s     cn73xx;
 	struct cvmx_bgxx_smux_tx_thresh_s     cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_thresh cvmx_bgxx_smux_tx_thresh_t;
@@ -5857,6 +6210,7 @@ union cvmx_bgxx_spux_an_adv {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_adv_s        cn73xx;
 	struct cvmx_bgxx_spux_an_adv_s        cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_adv cvmx_bgxx_spux_an_adv_t;
@@ -5898,6 +6252,7 @@ union cvmx_bgxx_spux_an_bp_status {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_bp_status_s  cn73xx;
 	struct cvmx_bgxx_spux_an_bp_status_s  cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_bp_status cvmx_bgxx_spux_an_bp_status_t;
@@ -5937,6 +6292,7 @@ union cvmx_bgxx_spux_an_control {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_control_s    cn73xx;
 	struct cvmx_bgxx_spux_an_control_s    cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_control cvmx_bgxx_spux_an_control_t;
@@ -5993,6 +6349,7 @@ union cvmx_bgxx_spux_an_lp_base {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_lp_base_s    cn73xx;
 	struct cvmx_bgxx_spux_an_lp_base_s    cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_lp_base cvmx_bgxx_spux_an_lp_base_t;
@@ -6026,6 +6383,7 @@ union cvmx_bgxx_spux_an_lp_xnp {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_lp_xnp_s     cn73xx;
 	struct cvmx_bgxx_spux_an_lp_xnp_s     cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_lp_xnp cvmx_bgxx_spux_an_lp_xnp_t;
@@ -6080,6 +6438,7 @@ union cvmx_bgxx_spux_an_status {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_status_s     cn73xx;
 	struct cvmx_bgxx_spux_an_status_s     cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_status cvmx_bgxx_spux_an_status_t;
@@ -6124,6 +6483,7 @@ union cvmx_bgxx_spux_an_xnp_tx {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_xnp_tx_s     cn73xx;
 	struct cvmx_bgxx_spux_an_xnp_tx_s     cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_xnp_tx cvmx_bgxx_spux_an_xnp_tx_t;
@@ -6163,6 +6523,7 @@ union cvmx_bgxx_spux_br_algn_status {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_algn_status_s cn73xx;
 	struct cvmx_bgxx_spux_br_algn_status_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_algn_status cvmx_bgxx_spux_br_algn_status_t;
@@ -6198,6 +6559,7 @@ union cvmx_bgxx_spux_br_bip_err_cnt {
 	uint64_t bip_err_cnt_ln3              : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_bip_err_cnt_s cn73xx;
 	struct cvmx_bgxx_spux_br_bip_err_cnt_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_bip_err_cnt cvmx_bgxx_spux_br_bip_err_cnt_t;
@@ -6243,6 +6605,7 @@ union cvmx_bgxx_spux_br_lane_map {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_lane_map_s   cn73xx;
 	struct cvmx_bgxx_spux_br_lane_map_s   cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_lane_map cvmx_bgxx_spux_br_lane_map_t;
@@ -6266,6 +6629,7 @@ union cvmx_bgxx_spux_br_pmd_control {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_control_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_control_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_control cvmx_bgxx_spux_br_pmd_control_t;
@@ -6309,6 +6673,7 @@ union cvmx_bgxx_spux_br_pmd_ld_cup {
 	uint64_t ln3_cup                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_ld_cup_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_ld_cup_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_ld_cup cvmx_bgxx_spux_br_pmd_ld_cup_t;
@@ -6349,6 +6714,7 @@ union cvmx_bgxx_spux_br_pmd_ld_rep {
 	uint64_t ln3_rep                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_ld_rep_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_ld_rep_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_ld_rep cvmx_bgxx_spux_br_pmd_ld_rep_t;
@@ -6385,6 +6751,7 @@ union cvmx_bgxx_spux_br_pmd_lp_cup {
 	uint64_t ln3_cup                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_lp_cup_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_lp_cup_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_lp_cup cvmx_bgxx_spux_br_pmd_lp_cup_t;
@@ -6421,6 +6788,7 @@ union cvmx_bgxx_spux_br_pmd_lp_rep {
 	uint64_t ln3_rep                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_lp_rep_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_lp_rep_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_lp_rep cvmx_bgxx_spux_br_pmd_lp_rep_t;
@@ -6452,6 +6820,7 @@ union cvmx_bgxx_spux_br_pmd_status {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_status_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_status_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_status cvmx_bgxx_spux_br_pmd_status_t;
@@ -6495,6 +6864,7 @@ union cvmx_bgxx_spux_br_status1 {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_status1_s    cn73xx;
 	struct cvmx_bgxx_spux_br_status1_s    cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_status1 cvmx_bgxx_spux_br_status1_t;
@@ -6562,6 +6932,7 @@ union cvmx_bgxx_spux_br_status2 {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_status2_s    cn73xx;
 	struct cvmx_bgxx_spux_br_status2_s    cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_status2 cvmx_bgxx_spux_br_status2_t;
@@ -6602,6 +6973,7 @@ union cvmx_bgxx_spux_br_tp_control {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_tp_control_s cn73xx;
 	struct cvmx_bgxx_spux_br_tp_control_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_tp_control cvmx_bgxx_spux_br_tp_control_t;
@@ -6631,6 +7003,7 @@ union cvmx_bgxx_spux_br_tp_err_cnt {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_tp_err_cnt_s cn73xx;
 	struct cvmx_bgxx_spux_br_tp_err_cnt_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_tp_err_cnt cvmx_bgxx_spux_br_tp_err_cnt_t;
@@ -6660,6 +7033,7 @@ union cvmx_bgxx_spux_bx_status {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_bx_status_s     cn73xx;
 	struct cvmx_bgxx_spux_bx_status_s     cn78xx;
 };
 typedef union cvmx_bgxx_spux_bx_status cvmx_bgxx_spux_bx_status_t;
@@ -6717,6 +7091,7 @@ union cvmx_bgxx_spux_control1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_control1_s      cn73xx;
 	struct cvmx_bgxx_spux_control1_s      cn78xx;
 };
 typedef union cvmx_bgxx_spux_control1 cvmx_bgxx_spux_control1_t;
@@ -6750,6 +7125,7 @@ union cvmx_bgxx_spux_control2 {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_control2_s      cn73xx;
 	struct cvmx_bgxx_spux_control2_s      cn78xx;
 };
 typedef union cvmx_bgxx_spux_control2 cvmx_bgxx_spux_control2_t;
@@ -6772,6 +7148,7 @@ union cvmx_bgxx_spux_fec_abil {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_abil_s      cn73xx;
 	struct cvmx_bgxx_spux_fec_abil_s      cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_abil cvmx_bgxx_spux_fec_abil_t;
@@ -6800,6 +7177,7 @@ union cvmx_bgxx_spux_fec_control {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_control_s   cn73xx;
 	struct cvmx_bgxx_spux_fec_control_s   cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_control cvmx_bgxx_spux_fec_control_t;
@@ -6837,6 +7215,7 @@ union cvmx_bgxx_spux_fec_corr_blks01 {
 	uint64_t ln1_corr_blks                : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_corr_blks01_s cn73xx;
 	struct cvmx_bgxx_spux_fec_corr_blks01_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_corr_blks01 cvmx_bgxx_spux_fec_corr_blks01_t;
@@ -6869,6 +7248,7 @@ union cvmx_bgxx_spux_fec_corr_blks23 {
 	uint64_t ln3_corr_blks                : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_corr_blks23_s cn73xx;
 	struct cvmx_bgxx_spux_fec_corr_blks23_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_corr_blks23 cvmx_bgxx_spux_fec_corr_blks23_t;
@@ -6906,6 +7286,7 @@ union cvmx_bgxx_spux_fec_uncorr_blks01 {
 	uint64_t ln1_uncorr_blks              : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_uncorr_blks01_s cn73xx;
 	struct cvmx_bgxx_spux_fec_uncorr_blks01_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_uncorr_blks01 cvmx_bgxx_spux_fec_uncorr_blks01_t;
@@ -6938,6 +7319,7 @@ union cvmx_bgxx_spux_fec_uncorr_blks23 {
 	uint64_t ln3_uncorr_blks              : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_uncorr_blks23_s cn73xx;
 	struct cvmx_bgxx_spux_fec_uncorr_blks23_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_uncorr_blks23 cvmx_bgxx_spux_fec_uncorr_blks23_t;
@@ -7024,6 +7406,7 @@ union cvmx_bgxx_spux_int {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_int_s           cn73xx;
 	struct cvmx_bgxx_spux_int_s           cn78xx;
 };
 typedef union cvmx_bgxx_spux_int cvmx_bgxx_spux_int_t;
@@ -7052,6 +7435,7 @@ union cvmx_bgxx_spux_lpcs_states {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_lpcs_states_s   cn73xx;
 	struct cvmx_bgxx_spux_lpcs_states_s   cn78xx;
 };
 typedef union cvmx_bgxx_spux_lpcs_states cvmx_bgxx_spux_lpcs_states_t;
@@ -7124,6 +7508,7 @@ union cvmx_bgxx_spux_misc_control {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_misc_control_s  cn73xx;
 	struct cvmx_bgxx_spux_misc_control_s  cn78xx;
 };
 typedef union cvmx_bgxx_spux_misc_control cvmx_bgxx_spux_misc_control_t;
@@ -7148,6 +7533,7 @@ union cvmx_bgxx_spux_spd_abil {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_spd_abil_s      cn73xx;
 	struct cvmx_bgxx_spux_spd_abil_s      cn78xx;
 };
 typedef union cvmx_bgxx_spux_spd_abil cvmx_bgxx_spux_spd_abil_t;
@@ -7185,6 +7571,7 @@ union cvmx_bgxx_spux_status1 {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_status1_s       cn73xx;
 	struct cvmx_bgxx_spux_status1_s       cn78xx;
 };
 typedef union cvmx_bgxx_spux_status1 cvmx_bgxx_spux_status1_t;
@@ -7226,6 +7613,7 @@ union cvmx_bgxx_spux_status2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_status2_s       cn73xx;
 	struct cvmx_bgxx_spux_status2_s       cn78xx;
 };
 typedef union cvmx_bgxx_spux_status2 cvmx_bgxx_spux_status2_t;
@@ -7248,6 +7636,7 @@ union cvmx_bgxx_spu_bist_status {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_bist_status_s    cn73xx;
 	struct cvmx_bgxx_spu_bist_status_s    cn78xx;
 };
 typedef union cvmx_bgxx_spu_bist_status cvmx_bgxx_spu_bist_status_t;
@@ -7365,6 +7754,7 @@ union cvmx_bgxx_spu_dbg_control {
 	uint64_t reserved_56_63               : 8;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_dbg_control_s    cn73xx;
 	struct cvmx_bgxx_spu_dbg_control_s    cn78xx;
 };
 typedef union cvmx_bgxx_spu_dbg_control cvmx_bgxx_spu_dbg_control_t;
@@ -7387,6 +7777,7 @@ union cvmx_bgxx_spu_mem_int {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_mem_int_s        cn73xx;
 	struct cvmx_bgxx_spu_mem_int_s        cn78xx;
 };
 typedef union cvmx_bgxx_spu_mem_int cvmx_bgxx_spu_mem_int_t;
@@ -7411,6 +7802,7 @@ union cvmx_bgxx_spu_mem_status {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_mem_status_s     cn73xx;
 	struct cvmx_bgxx_spu_mem_status_s     cn78xx;
 };
 typedef union cvmx_bgxx_spu_mem_status cvmx_bgxx_spu_mem_status_t;
@@ -7432,6 +7824,7 @@ union cvmx_bgxx_spu_sdsx_skew_status {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_sdsx_skew_status_s cn73xx;
 	struct cvmx_bgxx_spu_sdsx_skew_status_s cn78xx;
 };
 typedef union cvmx_bgxx_spu_sdsx_skew_status cvmx_bgxx_spu_sdsx_skew_status_t;
@@ -7489,6 +7882,7 @@ union cvmx_bgxx_spu_sdsx_states {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_sdsx_states_s    cn73xx;
 	struct cvmx_bgxx_spu_sdsx_states_s    cn78xx;
 };
 typedef union cvmx_bgxx_spu_sdsx_states cvmx_bgxx_spu_sdsx_states_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index ca48ab7..ab2aa80 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -65,26 +65,26 @@ static inline uint64_t CVMX_CIU_BLOCK_INT_FUNC(void)
 #define CVMX_CIU_BLOCK_INT (CVMX_ADD_IO_SEG(0x00010700000007C0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU_CIB_L2C_ENX(unsigned long block_id)
+static inline uint64_t CVMX_CIU_CIB_L2C_ENX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_CIU_CIB_L2C_ENX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_CIU_CIB_L2C_ENX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000107000000E100ull);
 }
 #else
-#define CVMX_CIU_CIB_L2C_ENX(block_id) (CVMX_ADD_IO_SEG(0x000107000000E100ull))
+#define CVMX_CIU_CIB_L2C_ENX(offset) (CVMX_ADD_IO_SEG(0x000107000000E100ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU_CIB_L2C_RAWX(unsigned long block_id)
+static inline uint64_t CVMX_CIU_CIB_L2C_RAWX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_CIU_CIB_L2C_RAWX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_CIU_CIB_L2C_RAWX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000107000000E000ull);
 }
 #else
-#define CVMX_CIU_CIB_L2C_RAWX(block_id) (CVMX_ADD_IO_SEG(0x000107000000E000ull))
+#define CVMX_CIU_CIB_L2C_RAWX(offset) (CVMX_ADD_IO_SEG(0x000107000000E000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_CIU_CIB_LMCX_ENX(unsigned long offset, unsigned long block_id)
@@ -131,48 +131,48 @@ static inline uint64_t CVMX_CIU_CIB_OCLAX_RAWX(unsigned long offset, unsigned lo
 #define CVMX_CIU_CIB_OCLAX_RAWX(offset, block_id) (CVMX_ADD_IO_SEG(0x000107000000EC00ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU_CIB_RST_ENX(unsigned long block_id)
+static inline uint64_t CVMX_CIU_CIB_RST_ENX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_CIU_CIB_RST_ENX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_CIU_CIB_RST_ENX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000107000000E500ull);
 }
 #else
-#define CVMX_CIU_CIB_RST_ENX(block_id) (CVMX_ADD_IO_SEG(0x000107000000E500ull))
+#define CVMX_CIU_CIB_RST_ENX(offset) (CVMX_ADD_IO_SEG(0x000107000000E500ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU_CIB_RST_RAWX(unsigned long block_id)
+static inline uint64_t CVMX_CIU_CIB_RST_RAWX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_CIU_CIB_RST_RAWX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_CIU_CIB_RST_RAWX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000107000000E400ull);
 }
 #else
-#define CVMX_CIU_CIB_RST_RAWX(block_id) (CVMX_ADD_IO_SEG(0x000107000000E400ull))
+#define CVMX_CIU_CIB_RST_RAWX(offset) (CVMX_ADD_IO_SEG(0x000107000000E400ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU_CIB_SATA_ENX(unsigned long block_id)
+static inline uint64_t CVMX_CIU_CIB_SATA_ENX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_CIU_CIB_SATA_ENX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_CIU_CIB_SATA_ENX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000107000000E700ull);
 }
 #else
-#define CVMX_CIU_CIB_SATA_ENX(block_id) (CVMX_ADD_IO_SEG(0x000107000000E700ull))
+#define CVMX_CIU_CIB_SATA_ENX(offset) (CVMX_ADD_IO_SEG(0x000107000000E700ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU_CIB_SATA_RAWX(unsigned long block_id)
+static inline uint64_t CVMX_CIU_CIB_SATA_RAWX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_CIU_CIB_SATA_RAWX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_CIU_CIB_SATA_RAWX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000107000000E600ull);
 }
 #else
-#define CVMX_CIU_CIB_SATA_RAWX(block_id) (CVMX_ADD_IO_SEG(0x000107000000E600ull))
+#define CVMX_CIU_CIB_SATA_RAWX(offset) (CVMX_ADD_IO_SEG(0x000107000000E600ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_CIU_CIB_USBDRDX_ENX(unsigned long offset, unsigned long block_id)
@@ -217,6 +217,7 @@ static inline uint64_t CVMX_CIU_DINT_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000720ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 			break;
 	}
@@ -243,6 +244,7 @@ static inline uint64_t CVMX_CIU_DINT_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000720ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000720ull);
@@ -437,6 +439,7 @@ static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000728ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 			break;
 	}
@@ -463,6 +466,7 @@ static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000728ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000728ull);
@@ -962,6 +966,7 @@ static inline uint64_t CVMX_CIU_PP_DBG_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000708ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 			break;
 	}
@@ -988,6 +993,7 @@ static inline uint64_t CVMX_CIU_PP_DBG_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000708ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000708ull);
@@ -1034,6 +1040,10 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 			if ((offset <= 47))
 				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 15))
+				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 15) * 8;
+			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001070100100200ull) + ((offset) & 31) * 8;
@@ -1067,6 +1077,8 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001070000000580ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100200ull) + (offset) * 8;
 	}
@@ -1094,6 +1106,7 @@ static inline uint64_t CVMX_CIU_PP_RST_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000700ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 			break;
 	}
@@ -1120,6 +1133,7 @@ static inline uint64_t CVMX_CIU_PP_RST_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000700ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000700ull);
@@ -1134,6 +1148,7 @@ static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000740ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 			break;
 	}
@@ -1148,6 +1163,7 @@ static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000740ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001010000000110ull);
@@ -1485,6 +1501,10 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 			if ((offset <= 47))
 				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 15))
+				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 15) * 8;
+			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001070100100000ull) + ((offset) & 31) * 8;
@@ -1518,6 +1538,8 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001070000000500ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100000ull) + (offset) * 8;
 	}
@@ -2759,6 +2781,7 @@ union cvmx_ciu_dint {
 	struct cvmx_ciu_dint_cn68xx           cn68xxp1;
 	struct cvmx_ciu_dint_cn52xx           cn70xx;
 	struct cvmx_ciu_dint_cn52xx           cn70xxp1;
+	struct cvmx_ciu_dint_cn38xx           cn73xx;
 	struct cvmx_ciu_dint_s                cn78xx;
 	struct cvmx_ciu_dint_cn52xx           cnf71xx;
 };
@@ -3936,6 +3959,7 @@ union cvmx_ciu_fuse {
 	struct cvmx_ciu_fuse_cn68xx           cn68xxp1;
 	struct cvmx_ciu_fuse_cn52xx           cn70xx;
 	struct cvmx_ciu_fuse_cn52xx           cn70xxp1;
+	struct cvmx_ciu_fuse_cn38xx           cn73xx;
 	struct cvmx_ciu_fuse_s                cn78xx;
 	struct cvmx_ciu_fuse_cn52xx           cnf71xx;
 };
@@ -5737,7 +5761,7 @@ union cvmx_ciu_intx_en1 {
 	uint64_t agl                          : 1;  /**< AGL interrupt enable */
 	uint64_t reserved_41_45               : 5;
 	uint64_t dpi_dma                      : 1;  /**< DPI_DMA interrupt enable */
-	uint64_t reserved_38_39               : 2;
+	uint64_t reserved_39_38               : 2;
 	uint64_t agx1                         : 1;  /**< GMX1 interrupt enable */
 	uint64_t agx0                         : 1;  /**< GMX0 interrupt enable */
 	uint64_t dpi                          : 1;  /**< DPI interrupt enable */
@@ -5785,7 +5809,7 @@ union cvmx_ciu_intx_en1 {
 	uint64_t dpi                          : 1;
 	uint64_t agx0                         : 1;
 	uint64_t agx1                         : 1;
-	uint64_t reserved_38_39               : 2;
+	uint64_t reserved_39_38               : 2;
 	uint64_t dpi_dma                      : 1;
 	uint64_t reserved_41_45               : 5;
 	uint64_t agl                          : 1;
@@ -8526,7 +8550,7 @@ union cvmx_ciu_intx_en4_1 {
 	uint64_t agl                          : 1;  /**< AGL interrupt enable */
 	uint64_t reserved_41_45               : 5;
 	uint64_t dpi_dma                      : 1;  /**< DPI_DMA interrupt enable */
-	uint64_t reserved_38_39               : 2;
+	uint64_t reserved_39_38               : 2;
 	uint64_t agx1                         : 1;  /**< GMX1 interrupt enable */
 	uint64_t agx0                         : 1;  /**< GMX0 interrupt enable */
 	uint64_t dpi                          : 1;  /**< DPI interrupt enable */
@@ -8574,7 +8598,7 @@ union cvmx_ciu_intx_en4_1 {
 	uint64_t dpi                          : 1;
 	uint64_t agx0                         : 1;
 	uint64_t agx1                         : 1;
-	uint64_t reserved_38_39               : 2;
+	uint64_t reserved_39_38               : 2;
 	uint64_t dpi_dma                      : 1;
 	uint64_t reserved_41_45               : 5;
 	uint64_t agl                          : 1;
@@ -11608,7 +11632,7 @@ union cvmx_ciu_int33_sum0 {
                                                          Set any time PIP/IPD drops a packet */
 	uint64_t gmx_drp                      : 2;  /**< GMX packet drop interrupt
                                                          Set any time corresponding GMX drops a packet */
-	uint64_t reserved_46_47               : 2;
+	uint64_t reserved_47_46               : 2;
 	uint64_t twsi                         : 1;  /**< TWSI Interrupt
                                                          See MIO_TWS0_INT */
 	uint64_t wdog_sum                     : 1;  /**< SUM1&EN1 summary bit
@@ -11653,7 +11677,7 @@ union cvmx_ciu_int33_sum0 {
 	uint64_t pci_msi                      : 4;
 	uint64_t wdog_sum                     : 1;
 	uint64_t twsi                         : 1;
-	uint64_t reserved_46_47               : 2;
+	uint64_t reserved_47_46               : 2;
 	uint64_t gmx_drp                      : 2;
 	uint64_t ipd_drp                      : 1;
 	uint64_t sum2                         : 1;
@@ -12388,7 +12412,8 @@ union cvmx_ciu_int_sum1 {
 	uint64_t pem0                         : 1;  /**< PEM0 interrupt
                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB) */
 	uint64_t ptp                          : 1;  /**< PTP interrupt
-                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero */
+                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero
+                                                         See MIO_PTP_EVT_CNT for details. */
 	uint64_t agl                          : 1;  /**< AGL interrupt
                                                          See AGL_GMX_RX*_INT_REG, AGL_GMX_TX_INT_REG */
 	uint64_t reserved_38_45               : 8;
@@ -12919,6 +12944,7 @@ union cvmx_ciu_pp_dbg {
 	struct cvmx_ciu_pp_dbg_cn68xx         cn68xxp1;
 	struct cvmx_ciu_pp_dbg_cn52xx         cn70xx;
 	struct cvmx_ciu_pp_dbg_cn52xx         cn70xxp1;
+	struct cvmx_ciu_pp_dbg_cn38xx         cn73xx;
 	struct cvmx_ciu_pp_dbg_s              cn78xx;
 	struct cvmx_ciu_pp_dbg_cn52xx         cnf71xx;
 };
@@ -12958,7 +12984,7 @@ union cvmx_ciu_pp_pokex {
 	struct cvmx_ciu_pp_pokex_s            cn68xxp1;
 	struct cvmx_ciu_pp_pokex_s            cn70xx;
 	struct cvmx_ciu_pp_pokex_s            cn70xxp1;
-	struct cvmx_ciu_pp_pokex_cn78xx {
+	struct cvmx_ciu_pp_pokex_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t poke                         : 1;  /**< Core poke. Writing any value to this register does the following:
@@ -12970,7 +12996,8 @@ union cvmx_ciu_pp_pokex {
 	uint64_t poke                         : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_ciu_pp_pokex_cn73xx       cn78xx;
 	struct cvmx_ciu_pp_pokex_s            cnf71xx;
 };
 typedef union cvmx_ciu_pp_pokex cvmx_ciu_pp_pokex_t;
@@ -13102,6 +13129,7 @@ union cvmx_ciu_pp_rst {
 	struct cvmx_ciu_pp_rst_cn68xx         cn68xxp1;
 	struct cvmx_ciu_pp_rst_cn52xx         cn70xx;
 	struct cvmx_ciu_pp_rst_cn52xx         cn70xxp1;
+	struct cvmx_ciu_pp_rst_cn38xx         cn73xx;
 	struct cvmx_ciu_pp_rst_s              cn78xx;
 	struct cvmx_ciu_pp_rst_cn52xx         cnf71xx;
 };
@@ -13129,6 +13157,18 @@ union cvmx_ciu_pp_rst_pending {
 	} s;
 	struct cvmx_ciu_pp_rst_pending_s      cn70xx;
 	struct cvmx_ciu_pp_rst_pending_s      cn70xxp1;
+	struct cvmx_ciu_pp_rst_pending_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pend                         : 16; /**< Set if corresponding core is waiting to change its reset state. Normally a reset change
+                                                         occurs immediately but if RST_PP_POWER[GATE] bit is set and the core is released from
+                                                         reset a delay of 64K core clocks between each core reset will apply to satisfy power
+                                                         management. */
+#else
+	uint64_t pend                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_ciu_pp_rst_pending_s      cn78xx;
 };
 typedef union cvmx_ciu_pp_rst_pending cvmx_ciu_pp_rst_pending_t;
@@ -14305,7 +14345,8 @@ union cvmx_ciu_sum1_iox_int {
 	uint64_t pem0                         : 1;  /**< PEM0 interrupt
                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB) */
 	uint64_t ptp                          : 1;  /**< PTP interrupt
-                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero */
+                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero.
+                                                         See MIO_PTP_EVT_CNT for details. */
 	uint64_t agl                          : 1;  /**< AGL interrupt
                                                          See AGL_GMX_RX*_INT_REG, AGL_GMX_TX_INT_REG */
 	uint64_t reserved_41_45               : 5;
@@ -14840,7 +14881,8 @@ union cvmx_ciu_sum1_ppx_ip2 {
 	uint64_t pem0                         : 1;  /**< PEM0 interrupt
                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB) */
 	uint64_t ptp                          : 1;  /**< PTP interrupt
-                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero */
+                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero.
+                                                         See MIO_PTP_EVT_CNT for details. */
 	uint64_t agl                          : 1;  /**< AGL interrupt
                                                          See AGL_GMX_RX*_INT_REG, AGL_GMX_TX_INT_REG */
 	uint64_t reserved_41_45               : 5;
@@ -15376,7 +15418,8 @@ union cvmx_ciu_sum1_ppx_ip3 {
 	uint64_t pem0                         : 1;  /**< PEM0 interrupt
                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB) */
 	uint64_t ptp                          : 1;  /**< PTP interrupt
-                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero */
+                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero.
+                                                         See MIO_PTP_EVT_CNT for details. */
 	uint64_t agl                          : 1;  /**< AGL interrupt
                                                          See AGL_GMX_RX*_INT_REG, AGL_GMX_TX_INT_REG */
 	uint64_t reserved_41_45               : 5;
@@ -15912,7 +15955,8 @@ union cvmx_ciu_sum1_ppx_ip4 {
 	uint64_t pem0                         : 1;  /**< PEM0 interrupt
                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB) */
 	uint64_t ptp                          : 1;  /**< PTP interrupt
-                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero */
+                                                         Set when HW decrements MIO_PTP_EVT_CNT to zero.
+                                                         See MIO_PTP_EVT_CNT for details. */
 	uint64_t agl                          : 1;  /**< AGL interrupt
                                                          See AGL_GMX_RX*_INT_REG, AGL_GMX_TX_INT_REG */
 	uint64_t reserved_41_45               : 5;
@@ -16755,6 +16799,7 @@ union cvmx_ciu_wdogx {
 	struct cvmx_ciu_wdogx_s               cn68xxp1;
 	struct cvmx_ciu_wdogx_s               cn70xx;
 	struct cvmx_ciu_wdogx_s               cn70xxp1;
+	struct cvmx_ciu_wdogx_s               cn73xx;
 	struct cvmx_ciu_wdogx_s               cn78xx;
 	struct cvmx_ciu_wdogx_s               cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
index 992ca6b..ee9588d 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
@@ -53,1236 +53,1236 @@
 #define __CVMX_CIU2_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_ACK_IOX_INT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_ACK_IOX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_ACK_IOX_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080C0800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_ACK_IOX_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080C0800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_ACK_IOX_INT(block_id) (CVMX_ADD_IO_SEG(0x00010701080C0800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_ACK_IOX_INT(offset) (CVMX_ADD_IO_SEG(0x00010701080C0800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_ACK_PPX_IP2(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_ACK_PPX_IP2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_ACK_PPX_IP2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000C0000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_ACK_PPX_IP2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000C0000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_ACK_PPX_IP2(block_id) (CVMX_ADD_IO_SEG(0x00010701000C0000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_ACK_PPX_IP2(offset) (CVMX_ADD_IO_SEG(0x00010701000C0000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_ACK_PPX_IP3(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_ACK_PPX_IP3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_ACK_PPX_IP3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000C0200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_ACK_PPX_IP3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000C0200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_ACK_PPX_IP3(block_id) (CVMX_ADD_IO_SEG(0x00010701000C0200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_ACK_PPX_IP3(offset) (CVMX_ADD_IO_SEG(0x00010701000C0200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_ACK_PPX_IP4(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_ACK_PPX_IP4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_ACK_PPX_IP4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000C0400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_ACK_PPX_IP4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000C0400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_ACK_PPX_IP4(block_id) (CVMX_ADD_IO_SEG(0x00010701000C0400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_ACK_PPX_IP4(offset) (CVMX_ADD_IO_SEG(0x00010701000C0400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108097800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108097800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070108097800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070108097800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_GPIO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_GPIO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_GPIO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B7800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_GPIO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B7800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_GPIO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B7800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_GPIO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B7800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_GPIO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_GPIO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_GPIO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A7800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_GPIO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A7800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_GPIO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A7800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_GPIO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A7800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108094800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108094800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070108094800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_IO(offset) (CVMX_ADD_IO_SEG(0x0001070108094800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_IO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_IO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_IO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B4800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_IO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B4800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_IO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B4800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_IO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B4800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_IO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_IO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_IO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A4800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_IO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A4800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_IO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A4800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_IO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A4800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MBOX(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MBOX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MBOX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108098800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MBOX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108098800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MBOX(block_id) (CVMX_ADD_IO_SEG(0x0001070108098800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MBOX(offset) (CVMX_ADD_IO_SEG(0x0001070108098800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MBOX_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MBOX_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MBOX_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B8800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MBOX_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B8800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MBOX_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B8800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MBOX_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B8800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MBOX_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MBOX_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MBOX_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A8800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MBOX_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A8800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MBOX_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A8800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MBOX_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A8800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108095800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108095800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070108095800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070108095800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MEM_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MEM_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MEM_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B5800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MEM_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B5800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MEM_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B5800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MEM_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B5800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MEM_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MEM_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MEM_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A5800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MEM_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A5800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MEM_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A5800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MEM_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A5800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108093800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108093800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070108093800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070108093800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MIO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MIO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MIO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B3800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MIO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B3800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MIO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B3800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MIO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B3800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_MIO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_MIO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MIO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A3800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_MIO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A3800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_MIO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A3800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_MIO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A3800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108096800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108096800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070108096800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070108096800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_PKT_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_PKT_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_PKT_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B6800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_PKT_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B6800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_PKT_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B6800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_PKT_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B6800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_PKT_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_PKT_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_PKT_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A6800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_PKT_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A6800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_PKT_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A6800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_PKT_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A6800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108092800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108092800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070108092800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_RML(offset) (CVMX_ADD_IO_SEG(0x0001070108092800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_RML_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_RML_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_RML_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B2800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_RML_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B2800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_RML_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B2800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_RML_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B2800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_RML_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_RML_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_RML_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A2800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_RML_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A2800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_RML_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A2800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_RML_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A2800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108091800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108091800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070108091800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070108091800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_WDOG_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_WDOG_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WDOG_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B1800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WDOG_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B1800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_WDOG_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B1800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_WDOG_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B1800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_WDOG_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_WDOG_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WDOG_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A1800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WDOG_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A1800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_WDOG_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A1800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_WDOG_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A1800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108090800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108090800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070108090800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070108090800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_WRKQ_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_WRKQ_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WRKQ_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080B0800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WRKQ_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080B0800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_WRKQ_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701080B0800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_WRKQ_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701080B0800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_IOX_INT_WRKQ_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_IOX_INT_WRKQ_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WRKQ_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701080A0800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_EN_IOX_INT_WRKQ_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701080A0800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_IOX_INT_WRKQ_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701080A0800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_EN_IOX_INT_WRKQ_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701080A0800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100097000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100097000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100097000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100097000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_GPIO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_GPIO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_GPIO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B7000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_GPIO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B7000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_GPIO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B7000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_GPIO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B7000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_GPIO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_GPIO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_GPIO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A7000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_GPIO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A7000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_GPIO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A7000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_GPIO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A7000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100094000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100094000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100094000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100094000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_IO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_IO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_IO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B4000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_IO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B4000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_IO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B4000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_IO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B4000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_IO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_IO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_IO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A4000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_IO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A4000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_IO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A4000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_IO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A4000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MBOX(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MBOX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MBOX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100098000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MBOX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100098000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MBOX(block_id) (CVMX_ADD_IO_SEG(0x0001070100098000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MBOX(offset) (CVMX_ADD_IO_SEG(0x0001070100098000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MBOX_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MBOX_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MBOX_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B8000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MBOX_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B8000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MBOX_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B8000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MBOX_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B8000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MBOX_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MBOX_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MBOX_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A8000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MBOX_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A8000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MBOX_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A8000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MBOX_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A8000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100095000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100095000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100095000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100095000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MEM_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MEM_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MEM_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B5000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MEM_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B5000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MEM_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B5000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MEM_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B5000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MEM_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MEM_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MEM_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A5000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MEM_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A5000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MEM_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A5000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MEM_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A5000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100093000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100093000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100093000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100093000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MIO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MIO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MIO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B3000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MIO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B3000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MIO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B3000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MIO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B3000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MIO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_MIO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MIO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A3000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_MIO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A3000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_MIO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A3000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_MIO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A3000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100096000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100096000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100096000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100096000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_PKT_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_PKT_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_PKT_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B6000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_PKT_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B6000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_PKT_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B6000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_PKT_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B6000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_PKT_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_PKT_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_PKT_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A6000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_PKT_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A6000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_PKT_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A6000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_PKT_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A6000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100092000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100092000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100092000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100092000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_RML_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_RML_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_RML_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B2000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_RML_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B2000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_RML_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B2000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_RML_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B2000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_RML_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_RML_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_RML_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A2000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_RML_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A2000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_RML_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A2000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_RML_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A2000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100091000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100091000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100091000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100091000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WDOG_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WDOG_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WDOG_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B1000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WDOG_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B1000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_WDOG_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B1000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_WDOG_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B1000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WDOG_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WDOG_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WDOG_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A1000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WDOG_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A1000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_WDOG_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A1000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_WDOG_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A1000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100090000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100090000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100090000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100090000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B0000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B0000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B0000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B0000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A0000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A0000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A0000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A0000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100097200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100097200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100097200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100097200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_GPIO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_GPIO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_GPIO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B7200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_GPIO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B7200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_GPIO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B7200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_GPIO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B7200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_GPIO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_GPIO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_GPIO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A7200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_GPIO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A7200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_GPIO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A7200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_GPIO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A7200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100094200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100094200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100094200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100094200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_IO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_IO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_IO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B4200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_IO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B4200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_IO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B4200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_IO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B4200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_IO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_IO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_IO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A4200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_IO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A4200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_IO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A4200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_IO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A4200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MBOX(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MBOX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MBOX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100098200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MBOX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100098200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MBOX(block_id) (CVMX_ADD_IO_SEG(0x0001070100098200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MBOX(offset) (CVMX_ADD_IO_SEG(0x0001070100098200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MBOX_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MBOX_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MBOX_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B8200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MBOX_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B8200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MBOX_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B8200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MBOX_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B8200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MBOX_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MBOX_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MBOX_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A8200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MBOX_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A8200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MBOX_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A8200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MBOX_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A8200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100095200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100095200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100095200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100095200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MEM_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MEM_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MEM_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B5200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MEM_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B5200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MEM_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B5200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MEM_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B5200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MEM_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MEM_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MEM_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A5200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MEM_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A5200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MEM_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A5200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MEM_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A5200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100093200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100093200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100093200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100093200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MIO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MIO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MIO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B3200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MIO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B3200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MIO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B3200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MIO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B3200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MIO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_MIO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MIO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A3200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_MIO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A3200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_MIO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A3200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_MIO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A3200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100096200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100096200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100096200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100096200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_PKT_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_PKT_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_PKT_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B6200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_PKT_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B6200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_PKT_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B6200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_PKT_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B6200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_PKT_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_PKT_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_PKT_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A6200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_PKT_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A6200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_PKT_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A6200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_PKT_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A6200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100092200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100092200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100092200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100092200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_RML_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_RML_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_RML_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B2200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_RML_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B2200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_RML_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B2200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_RML_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B2200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_RML_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_RML_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_RML_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A2200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_RML_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A2200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_RML_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A2200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_RML_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A2200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100091200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100091200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100091200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100091200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WDOG_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WDOG_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WDOG_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B1200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WDOG_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B1200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_WDOG_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B1200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_WDOG_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B1200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WDOG_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WDOG_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WDOG_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A1200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WDOG_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A1200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_WDOG_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A1200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_WDOG_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A1200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100090200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100090200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100090200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100090200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WRKQ_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WRKQ_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WRKQ_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B0200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WRKQ_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B0200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_WRKQ_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B0200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_WRKQ_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B0200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WRKQ_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP3_WRKQ_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WRKQ_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A0200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP3_WRKQ_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A0200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP3_WRKQ_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A0200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP3_WRKQ_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A0200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100097400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100097400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100097400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100097400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_GPIO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_GPIO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_GPIO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B7400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_GPIO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B7400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_GPIO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B7400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_GPIO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B7400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_GPIO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_GPIO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_GPIO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A7400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_GPIO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A7400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_GPIO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A7400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_GPIO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A7400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100094400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100094400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100094400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100094400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_IO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_IO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_IO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B4400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_IO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B4400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_IO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B4400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_IO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B4400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_IO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_IO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_IO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A4400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_IO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A4400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_IO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A4400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_IO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A4400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MBOX(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MBOX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MBOX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100098400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MBOX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100098400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MBOX(block_id) (CVMX_ADD_IO_SEG(0x0001070100098400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MBOX(offset) (CVMX_ADD_IO_SEG(0x0001070100098400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MBOX_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MBOX_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MBOX_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B8400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MBOX_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B8400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MBOX_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B8400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MBOX_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B8400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MBOX_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MBOX_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MBOX_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A8400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MBOX_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A8400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MBOX_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A8400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MBOX_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A8400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100095400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100095400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100095400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100095400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MEM_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MEM_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MEM_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B5400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MEM_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B5400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MEM_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B5400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MEM_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B5400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MEM_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MEM_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MEM_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A5400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MEM_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A5400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MEM_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A5400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MEM_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A5400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100093400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100093400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100093400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100093400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MIO_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MIO_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MIO_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B3400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MIO_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B3400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MIO_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B3400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MIO_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B3400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MIO_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_MIO_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MIO_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A3400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_MIO_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A3400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_MIO_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A3400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_MIO_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A3400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100096400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100096400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100096400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100096400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_PKT_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_PKT_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_PKT_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B6400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_PKT_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B6400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_PKT_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B6400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_PKT_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B6400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_PKT_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_PKT_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_PKT_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A6400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_PKT_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A6400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_PKT_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A6400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_PKT_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A6400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100092400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100092400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100092400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100092400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_RML_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_RML_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_RML_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B2400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_RML_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B2400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_RML_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B2400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_RML_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B2400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_RML_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_RML_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_RML_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A2400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_RML_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A2400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_RML_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A2400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_RML_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A2400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100091400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100091400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100091400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100091400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WDOG_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WDOG_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WDOG_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B1400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WDOG_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B1400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_WDOG_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B1400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_WDOG_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B1400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WDOG_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WDOG_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WDOG_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A1400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WDOG_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A1400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_WDOG_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A1400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_WDOG_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A1400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100090400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100090400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100090400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100090400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WRKQ_W1C(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WRKQ_W1C(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WRKQ_W1C(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000B0400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WRKQ_W1C(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000B0400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_WRKQ_W1C(block_id) (CVMX_ADD_IO_SEG(0x00010701000B0400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_WRKQ_W1C(offset) (CVMX_ADD_IO_SEG(0x00010701000B0400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WRKQ_W1S(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_EN_PPX_IP4_WRKQ_W1S(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WRKQ_W1S(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000A0400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_EN_PPX_IP4_WRKQ_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000A0400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_EN_PPX_IP4_WRKQ_W1S(block_id) (CVMX_ADD_IO_SEG(0x00010701000A0400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_EN_PPX_IP4_WRKQ_W1S(offset) (CVMX_ADD_IO_SEG(0x00010701000A0400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_CIU2_INTR_CIU_READY CVMX_CIU2_INTR_CIU_READY_FUNC()
@@ -1329,37 +1329,37 @@ static inline uint64_t CVMX_CIU2_INTR_SLOWDOWN_FUNC(void)
 #define CVMX_CIU2_INTR_SLOWDOWN (CVMX_ADD_IO_SEG(0x0001070100102000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_MSIRED_PPX_IP2(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_MSIRED_PPX_IP2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_MSIRED_PPX_IP2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000C1000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_MSIRED_PPX_IP2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000C1000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_MSIRED_PPX_IP2(block_id) (CVMX_ADD_IO_SEG(0x00010701000C1000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_MSIRED_PPX_IP2(offset) (CVMX_ADD_IO_SEG(0x00010701000C1000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_MSIRED_PPX_IP3(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_MSIRED_PPX_IP3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_MSIRED_PPX_IP3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000C1200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_MSIRED_PPX_IP3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000C1200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_MSIRED_PPX_IP3(block_id) (CVMX_ADD_IO_SEG(0x00010701000C1200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_MSIRED_PPX_IP3(offset) (CVMX_ADD_IO_SEG(0x00010701000C1200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_MSIRED_PPX_IP4(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_MSIRED_PPX_IP4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_MSIRED_PPX_IP4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00010701000C1400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_MSIRED_PPX_IP4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00010701000C1400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_MSIRED_PPX_IP4(block_id) (CVMX_ADD_IO_SEG(0x00010701000C1400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_MSIRED_PPX_IP4(offset) (CVMX_ADD_IO_SEG(0x00010701000C1400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_CIU2_MSI_RCVX(unsigned long offset)
@@ -1384,752 +1384,752 @@ static inline uint64_t CVMX_CIU2_MSI_SELX(unsigned long offset)
 #define CVMX_CIU2_MSI_SELX(offset) (CVMX_ADD_IO_SEG(0x00010701000C3000ull) + ((offset) & 255) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_IOX_INT_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_IOX_INT_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108047800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108047800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_IOX_INT_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070108047800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_RAW_IOX_INT_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070108047800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_IOX_INT_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_IOX_INT_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108044800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108044800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_IOX_INT_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070108044800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_RAW_IOX_INT_IO(offset) (CVMX_ADD_IO_SEG(0x0001070108044800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_IOX_INT_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_IOX_INT_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108045800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108045800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_IOX_INT_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070108045800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_RAW_IOX_INT_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070108045800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_IOX_INT_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_IOX_INT_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108043800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108043800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_IOX_INT_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070108043800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_RAW_IOX_INT_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070108043800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_IOX_INT_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_IOX_INT_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108046800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108046800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_IOX_INT_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070108046800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_RAW_IOX_INT_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070108046800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_IOX_INT_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_IOX_INT_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108042800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108042800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_IOX_INT_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070108042800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_RAW_IOX_INT_RML(offset) (CVMX_ADD_IO_SEG(0x0001070108042800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_IOX_INT_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_IOX_INT_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108041800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108041800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_IOX_INT_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070108041800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_RAW_IOX_INT_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070108041800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_IOX_INT_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_IOX_INT_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108040800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_RAW_IOX_INT_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108040800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_IOX_INT_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070108040800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_RAW_IOX_INT_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070108040800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100047000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100047000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP2_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100047000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP2_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100047000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100044000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100044000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP2_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100044000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP2_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100044000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100045000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100045000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP2_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100045000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP2_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100045000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100043000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100043000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP2_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100043000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP2_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100043000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100046000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100046000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP2_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100046000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP2_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100046000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100042000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100042000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP2_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100042000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP2_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100042000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100041000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100041000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP2_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100041000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP2_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100041000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP2_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100040000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP2_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100040000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP2_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100040000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP2_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100040000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100047200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100047200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP3_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100047200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP3_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100047200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100044200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100044200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP3_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100044200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP3_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100044200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100045200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100045200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP3_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100045200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP3_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100045200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100043200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100043200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP3_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100043200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP3_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100043200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100046200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100046200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP3_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100046200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP3_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100046200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100042200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100042200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP3_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100042200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP3_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100042200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100041200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100041200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP3_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100041200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP3_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100041200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP3_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100040200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP3_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100040200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP3_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100040200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP3_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100040200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100047400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100047400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP4_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100047400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP4_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100047400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100044400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100044400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP4_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100044400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP4_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100044400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100045400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100045400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP4_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100045400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP4_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100045400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100043400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100043400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP4_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100043400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP4_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100043400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100046400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100046400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP4_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100046400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP4_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100046400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100042400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100042400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP4_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100042400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP4_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100042400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100041400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100041400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP4_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100041400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP4_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100041400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_RAW_PPX_IP4_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100040400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_RAW_PPX_IP4_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100040400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_RAW_PPX_IP4_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100040400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_RAW_PPX_IP4_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100040400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108087800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108087800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070108087800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070108087800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108084800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108084800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070108084800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_IO(offset) (CVMX_ADD_IO_SEG(0x0001070108084800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_MBOX(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_MBOX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_MBOX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108088800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_MBOX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108088800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_MBOX(block_id) (CVMX_ADD_IO_SEG(0x0001070108088800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_MBOX(offset) (CVMX_ADD_IO_SEG(0x0001070108088800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108085800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108085800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070108085800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070108085800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108083800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108083800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070108083800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070108083800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108086800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108086800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070108086800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070108086800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108082800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108082800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070108082800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_RML(offset) (CVMX_ADD_IO_SEG(0x0001070108082800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108081800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108081800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070108081800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070108081800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_IOX_INT_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_IOX_INT_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070108080800ull) + ((block_id) & 1) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_CIU2_SRC_IOX_INT_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070108080800ull) + ((offset) & 1) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_IOX_INT_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070108080800ull) + ((block_id) & 1) * 0x200000ull)
+#define CVMX_CIU2_SRC_IOX_INT_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070108080800ull) + ((offset) & 1) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100087000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100087000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100087000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100087000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100084000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100084000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100084000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100084000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_MBOX(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_MBOX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_MBOX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100088000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_MBOX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100088000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_MBOX(block_id) (CVMX_ADD_IO_SEG(0x0001070100088000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_MBOX(offset) (CVMX_ADD_IO_SEG(0x0001070100088000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100085000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100085000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100085000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100085000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100083000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100083000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100083000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100083000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100086000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100086000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100086000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100086000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100082000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100082000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100082000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100082000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100081000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100081000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100081000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100081000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP2_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100080000ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP2_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100080000ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP2_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100080000ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP2_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100080000ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100087200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100087200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100087200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100087200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100084200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100084200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100084200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100084200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_MBOX(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_MBOX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_MBOX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100088200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_MBOX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100088200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_MBOX(block_id) (CVMX_ADD_IO_SEG(0x0001070100088200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_MBOX(offset) (CVMX_ADD_IO_SEG(0x0001070100088200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100085200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100085200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100085200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100085200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100083200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100083200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100083200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100083200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100086200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100086200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100086200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100086200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100082200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100082200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100082200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100082200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100081200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100081200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100081200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100081200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP3_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100080200ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP3_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100080200ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP3_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100080200ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP3_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100080200ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_GPIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_GPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_GPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100087400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_GPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100087400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_GPIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100087400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_GPIO(offset) (CVMX_ADD_IO_SEG(0x0001070100087400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_IO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_IO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_IO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100084400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_IO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100084400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_IO(block_id) (CVMX_ADD_IO_SEG(0x0001070100084400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_IO(offset) (CVMX_ADD_IO_SEG(0x0001070100084400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_MBOX(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_MBOX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_MBOX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100088400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_MBOX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100088400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_MBOX(block_id) (CVMX_ADD_IO_SEG(0x0001070100088400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_MBOX(offset) (CVMX_ADD_IO_SEG(0x0001070100088400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_MEM(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_MEM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_MEM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100085400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_MEM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100085400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_MEM(block_id) (CVMX_ADD_IO_SEG(0x0001070100085400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_MEM(offset) (CVMX_ADD_IO_SEG(0x0001070100085400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_MIO(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_MIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_MIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100083400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_MIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100083400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_MIO(block_id) (CVMX_ADD_IO_SEG(0x0001070100083400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_MIO(offset) (CVMX_ADD_IO_SEG(0x0001070100083400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_PKT(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_PKT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_PKT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100086400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_PKT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100086400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_PKT(block_id) (CVMX_ADD_IO_SEG(0x0001070100086400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_PKT(offset) (CVMX_ADD_IO_SEG(0x0001070100086400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_RML(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_RML(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_RML(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100082400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_RML(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100082400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_RML(block_id) (CVMX_ADD_IO_SEG(0x0001070100082400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_RML(offset) (CVMX_ADD_IO_SEG(0x0001070100082400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_WDOG(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_WDOG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_WDOG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100081400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_WDOG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100081400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_WDOG(block_id) (CVMX_ADD_IO_SEG(0x0001070100081400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_WDOG(offset) (CVMX_ADD_IO_SEG(0x0001070100081400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_WRKQ(unsigned long block_id)
+static inline uint64_t CVMX_CIU2_SRC_PPX_IP4_WRKQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 31)))))
-		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_WRKQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001070100080400ull) + ((block_id) & 31) * 0x200000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_CIU2_SRC_PPX_IP4_WRKQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070100080400ull) + ((offset) & 31) * 0x200000ull;
 }
 #else
-#define CVMX_CIU2_SRC_PPX_IP4_WRKQ(block_id) (CVMX_ADD_IO_SEG(0x0001070100080400ull) + ((block_id) & 31) * 0x200000ull)
+#define CVMX_CIU2_SRC_PPX_IP4_WRKQ(offset) (CVMX_ADD_IO_SEG(0x0001070100080400ull) + ((offset) & 31) * 0x200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_CIU2_SUM_IOX_INT(unsigned long offset)
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index 59d6038..3be9e88 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_CIU3_BIST CVMX_CIU3_BIST_FUNC()
 static inline uint64_t CVMX_CIU3_BIST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_BIST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000001C0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_CIU3_BIST_FUNC(void)
 #define CVMX_CIU3_CONST CVMX_CIU3_CONST_FUNC()
 static inline uint64_t CVMX_CIU3_CONST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_CONST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000220ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_CIU3_CONST_FUNC(void)
 #define CVMX_CIU3_CTL CVMX_CIU3_CTL_FUNC()
 static inline uint64_t CVMX_CIU3_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000000E0ull);
 }
@@ -89,6 +89,7 @@ static inline uint64_t CVMX_CIU3_CTL_FUNC(void)
 static inline uint64_t CVMX_CIU3_DESTX_IO_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_CIU3_DESTX_IO_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000210000ull) + ((offset) & 7) * 8;
@@ -100,6 +101,7 @@ static inline uint64_t CVMX_CIU3_DESTX_IO_INT(unsigned long offset)
 static inline uint64_t CVMX_CIU3_DESTX_PP_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 143)))))
 		cvmx_warn("CVMX_CIU3_DESTX_PP_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000200000ull) + ((offset) & 255) * 8;
@@ -111,7 +113,7 @@ static inline uint64_t CVMX_CIU3_DESTX_PP_INT(unsigned long offset)
 #define CVMX_CIU3_GSTOP CVMX_CIU3_GSTOP_FUNC()
 static inline uint64_t CVMX_CIU3_GSTOP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_GSTOP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000140ull);
 }
@@ -122,6 +124,7 @@ static inline uint64_t CVMX_CIU3_GSTOP_FUNC(void)
 static inline uint64_t CVMX_CIU3_IDTX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_CIU3_IDTX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000110000ull) + ((offset) & 255) * 8;
@@ -133,6 +136,7 @@ static inline uint64_t CVMX_CIU3_IDTX_CTL(unsigned long offset)
 static inline uint64_t CVMX_CIU3_IDTX_IO(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_CIU3_IDTX_IO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000130000ull) + ((offset) & 255) * 8;
@@ -144,6 +148,7 @@ static inline uint64_t CVMX_CIU3_IDTX_IO(unsigned long offset)
 static inline uint64_t CVMX_CIU3_IDTX_PPX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 255)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id <= 255))))))
 		cvmx_warn("CVMX_CIU3_IDTX_PPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001010000120000ull) + ((block_id) & 255) * 0x20ull;
@@ -155,7 +160,7 @@ static inline uint64_t CVMX_CIU3_IDTX_PPX(unsigned long offset, unsigned long bl
 #define CVMX_CIU3_INTR_RAM_ECC_CTL CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_RAM_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000260ull);
 }
@@ -166,7 +171,7 @@ static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC(void)
 #define CVMX_CIU3_INTR_RAM_ECC_ST CVMX_CIU3_INTR_RAM_ECC_ST_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_ST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_RAM_ECC_ST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000280ull);
 }
@@ -177,7 +182,7 @@ static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_ST_FUNC(void)
 #define CVMX_CIU3_INTR_READY CVMX_CIU3_INTR_READY_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_READY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_READY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000002A0ull);
 }
@@ -188,7 +193,7 @@ static inline uint64_t CVMX_CIU3_INTR_READY_FUNC(void)
 #define CVMX_CIU3_INTR_SLOWDOWN CVMX_CIU3_INTR_SLOWDOWN_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_SLOWDOWN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_SLOWDOWN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000240ull);
 }
@@ -199,6 +204,7 @@ static inline uint64_t CVMX_CIU3_INTR_SLOWDOWN_FUNC(void)
 static inline uint64_t CVMX_CIU3_ISCX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010080000000ull) + ((offset) & 1048575) * 8;
@@ -210,6 +216,7 @@ static inline uint64_t CVMX_CIU3_ISCX_CTL(unsigned long offset)
 static inline uint64_t CVMX_CIU3_ISCX_W1C(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010090000000ull) + ((offset) & 1048575) * 8;
@@ -221,6 +228,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1C(unsigned long offset)
 static inline uint64_t CVMX_CIU3_ISCX_W1S(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_W1S(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00010100A0000000ull) + ((offset) & 1048575) * 8;
@@ -232,7 +240,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1S(unsigned long offset)
 #define CVMX_CIU3_NMI CVMX_CIU3_NMI_FUNC()
 static inline uint64_t CVMX_CIU3_NMI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_NMI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000160ull);
 }
@@ -243,6 +251,7 @@ static inline uint64_t CVMX_CIU3_NMI_FUNC(void)
 static inline uint64_t CVMX_CIU3_SISCX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 191))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 191)))))
 		cvmx_warn("CVMX_CIU3_SISCX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000220000ull) + ((offset) & 255) * 8;
@@ -254,6 +263,7 @@ static inline uint64_t CVMX_CIU3_SISCX(unsigned long offset)
 static inline uint64_t CVMX_CIU3_TIMX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 9)))))
 		cvmx_warn("CVMX_CIU3_TIMX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000010000ull) + ((offset) & 15) * 8;
@@ -285,6 +295,7 @@ union cvmx_ciu3_bist {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_ciu3_bist_s               cn73xx;
 	struct cvmx_ciu3_bist_s               cn78xx;
 };
 typedef union cvmx_ciu3_bist cvmx_ciu3_bist_t;
@@ -307,6 +318,7 @@ union cvmx_ciu3_const {
 	uint64_t dests_io                     : 16;
 #endif
 	} s;
+	struct cvmx_ciu3_const_s              cn73xx;
 	struct cvmx_ciu3_const_s              cn78xx;
 };
 typedef union cvmx_ciu3_const cvmx_ciu3_const_t;
@@ -336,6 +348,7 @@ union cvmx_ciu3_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_ciu3_ctl_s                cn73xx;
 	struct cvmx_ciu3_ctl_s                cn78xx;
 };
 typedef union cvmx_ciu3_ctl cvmx_ciu3_ctl_t;
@@ -368,6 +381,7 @@ union cvmx_ciu3_destx_io_int {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_ciu3_destx_io_int_s       cn73xx;
 	struct cvmx_ciu3_destx_io_int_s       cn78xx;
 };
 typedef union cvmx_ciu3_destx_io_int cvmx_ciu3_destx_io_int_t;
@@ -400,6 +414,7 @@ union cvmx_ciu3_destx_pp_int {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_ciu3_destx_pp_int_s       cn73xx;
 	struct cvmx_ciu3_destx_pp_int_s       cn78xx;
 };
 typedef union cvmx_ciu3_destx_pp_int cvmx_ciu3_destx_pp_int_t;
@@ -418,6 +433,7 @@ union cvmx_ciu3_gstop {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_ciu3_gstop_s              cn73xx;
 	struct cvmx_ciu3_gstop_s              cn78xx;
 };
 typedef union cvmx_ciu3_gstop cvmx_ciu3_gstop_t;
@@ -454,6 +470,7 @@ union cvmx_ciu3_idtx_ctl {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_ciu3_idtx_ctl_s           cn73xx;
 	struct cvmx_ciu3_idtx_ctl_s           cn78xx;
 };
 typedef union cvmx_ciu3_idtx_ctl cvmx_ciu3_idtx_ctl_t;
@@ -476,6 +493,7 @@ union cvmx_ciu3_idtx_io {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_ciu3_idtx_io_s            cn73xx;
 	struct cvmx_ciu3_idtx_io_s            cn78xx;
 };
 typedef union cvmx_ciu3_idtx_io cvmx_ciu3_idtx_io_t;
@@ -497,6 +515,15 @@ union cvmx_ciu3_idtx_ppx {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_ciu3_idtx_ppx_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pp                           : 16; /**< Bitmask of which cores receive interrupts via this IDT. */
+#else
+	uint64_t pp                           : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_ciu3_idtx_ppx_s           cn78xx;
 };
 typedef union cvmx_ciu3_idtx_ppx cvmx_ciu3_idtx_ppx_t;
@@ -520,6 +547,7 @@ union cvmx_ciu3_intr_ram_ecc_ctl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_ciu3_intr_ram_ecc_ctl_s   cn73xx;
 	struct cvmx_ciu3_intr_ram_ecc_ctl_s   cn78xx;
 };
 typedef union cvmx_ciu3_intr_ram_ecc_ctl cvmx_ciu3_intr_ram_ecc_ctl_t;
@@ -552,6 +580,7 @@ union cvmx_ciu3_intr_ram_ecc_st {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_ciu3_intr_ram_ecc_st_s    cn73xx;
 	struct cvmx_ciu3_intr_ram_ecc_st_s    cn78xx;
 };
 typedef union cvmx_ciu3_intr_ram_ecc_st cvmx_ciu3_intr_ram_ecc_st_t;
@@ -576,6 +605,7 @@ union cvmx_ciu3_intr_ready {
 	uint64_t reserved_46_63               : 18;
 #endif
 	} s;
+	struct cvmx_ciu3_intr_ready_s         cn73xx;
 	struct cvmx_ciu3_intr_ready_s         cn78xx;
 };
 typedef union cvmx_ciu3_intr_ready cvmx_ciu3_intr_ready_t;
@@ -599,6 +629,7 @@ union cvmx_ciu3_intr_slowdown {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_ciu3_intr_slowdown_s      cn73xx;
 	struct cvmx_ciu3_intr_slowdown_s      cn78xx;
 };
 typedef union cvmx_ciu3_intr_slowdown cvmx_ciu3_intr_slowdown_t;
@@ -638,6 +669,7 @@ union cvmx_ciu3_iscx_ctl {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_ciu3_iscx_ctl_s           cn73xx;
 	struct cvmx_ciu3_iscx_ctl_s           cn78xx;
 };
 typedef union cvmx_ciu3_iscx_ctl cvmx_ciu3_iscx_ctl_t;
@@ -658,6 +690,7 @@ union cvmx_ciu3_iscx_w1c {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_ciu3_iscx_w1c_s           cn73xx;
 	struct cvmx_ciu3_iscx_w1c_s           cn78xx;
 };
 typedef union cvmx_ciu3_iscx_w1c cvmx_ciu3_iscx_w1c_t;
@@ -678,6 +711,7 @@ union cvmx_ciu3_iscx_w1s {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_ciu3_iscx_w1s_s           cn73xx;
 	struct cvmx_ciu3_iscx_w1s_s           cn78xx;
 };
 typedef union cvmx_ciu3_iscx_w1s cvmx_ciu3_iscx_w1s_t;
@@ -696,6 +730,15 @@ union cvmx_ciu3_nmi {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_ciu3_nmi_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t nmi                          : 16; /**< Writing a 1 to a bit sends an NMI pulse to the corresponding core vector. */
+#else
+	uint64_t nmi                          : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_ciu3_nmi_s                cn78xx;
 };
 typedef union cvmx_ciu3_nmi cvmx_ciu3_nmi_t;
@@ -712,6 +755,7 @@ union cvmx_ciu3_siscx {
 	uint64_t en                           : 64;
 #endif
 	} s;
+	struct cvmx_ciu3_siscx_s              cn73xx;
 	struct cvmx_ciu3_siscx_s              cn78xx;
 };
 typedef union cvmx_ciu3_siscx cvmx_ciu3_siscx_t;
@@ -735,6 +779,7 @@ union cvmx_ciu3_timx {
 	uint64_t reserved_37_63               : 27;
 #endif
 	} s;
+	struct cvmx_ciu3_timx_s               cn73xx;
 	struct cvmx_ciu3_timx_s               cn78xx;
 };
 typedef union cvmx_ciu3_timx cvmx_ciu3_timx_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-cmd-queue.h b/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
index 927fd26..51dd1ff 100644
--- a/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
+++ b/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
@@ -82,12 +82,14 @@
  * internal cycle counter to completely eliminate any causes of
  * bus traffic.
  *
- * <hr> $Revision: 103822 $ <hr>
+ * <hr> $Revision: 110896 $ <hr>
  */
 
 #ifndef __CVMX_CMD_QUEUE_H__
 #define __CVMX_CMD_QUEUE_H__
 
+#include "cvmx-atomic.h"
+
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
 extern "C" {
@@ -103,6 +105,8 @@ extern "C" {
 #define CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH 0
 #endif
 
+#define	NUM_ELEMENTS(arr) (sizeof(arr)/sizeof((arr)[0]))
+
 /**
  * Enumeration representing all hardware blocks that use command
  * queues. Each hardware block has up to 65536 sub identifiers for
@@ -124,6 +128,9 @@ typedef enum {
 	CVMX_CMD_QUEUE_END = 0x70000,
 } cvmx_cmd_queue_id_t;
 
+#define CVMX_CMD_QUEUE_ZIP3_QUE(node,queue) \
+  ((cvmx_cmd_queue_id_t)((node) << 24 | CVMX_CMD_QUEUE_ZIP | (0xffff&(queue))))
+
 /**
  * Command write operations can fail if the command queue needs
  * a new buffer and the associated FPA pool is empty. It can also
@@ -140,29 +147,36 @@ typedef enum {
 
 typedef struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t now_serving;	    /**< You have lock when this is your ticket */
-	uint32_t max_depth;	    /**< Maximum outstanding command words */
-
-	uint64_t fpa_pool:3;	    /**< FPA pool buffers come from */
-	uint64_t base_ptr_div128:33;
-				    /**< Top of command buffer pointer shifted 7 */
-	uint64_t unused2:2;
-	uint64_t pool_size_m1:13;
-				    /**< FPA buffer size in 64bit words minus 1 */
-	uint64_t index:13;	    /**< Number of commands already used in buffer */
+	/* First 64-bit word: */
+	uint64_t fpa_pool:16;		/**< FPA1:POOL/FPA3:GAURA for buffers */
+	uint64_t base_paddr:48;		/**< command buffer physical address */
+	/* Second 64-bit word: */
+	uint64_t max_depth: 32;		/**< Maximum outstanding cmd words */
+	uint64_t pool_size_m1:16;	/**< FPA buffer size in dwords - 1 */
+	uint64_t index:16;		/**< Number of cmd words in buffer */
 #else
-	uint32_t max_depth;
-	uint32_t now_serving;
-
-	uint64_t index:13;
-	uint64_t pool_size_m1:13;
-	uint64_t unused2:2;
-	uint64_t base_ptr_div128:33;
-	uint64_t fpa_pool:3;
+	/* First 64-bit word: */
+	uint64_t base_paddr:48;
+	uint64_t fpa_pool:16;
+	/* Second 64-bit word: */
+	uint64_t index:16;
+	uint64_t pool_size_m1:16;
+	uint64_t max_depth: 32;
 #endif
 } __cvmx_cmd_queue_state_t;
 
 /**
+ * command-queue locking uses a fair ticket spinlock algo,
+ * with 64-bit tickets for endianness-neutrality and
+ * counter overflow protection.
+ * Lock is free when both counters are of equal value.
+ */
+typedef struct {
+	uint64_t ticket;
+	uint64_t now_serving;
+} __cvmx_cmd_queue_lock_t;
+
+/**
  * This structure contains the global state of all command queues.
  * It is stored in a bootmem named block and shared by all
  * applications running on Octeon. Tickets are stored in a different
@@ -171,10 +185,13 @@ typedef struct {
  * of queue state causes the ll/sc to fail quite often.
  */
 typedef struct {
-	uint64_t ticket[(CVMX_CMD_QUEUE_END >> 16) * 256];
+	__cvmx_cmd_queue_lock_t lock[(CVMX_CMD_QUEUE_END >> 16) * 256];
 	__cvmx_cmd_queue_state_t state[(CVMX_CMD_QUEUE_END >> 16) * 256];
 } __cvmx_cmd_queue_all_state_t;
 
+extern CVMX_SHARED __cvmx_cmd_queue_all_state_t *
+__cvmx_cmd_queue_state_ptrs[CVMX_MAX_NODES];
+
 /**
  * Initialize a command queue for use. The initial FPA buffer is
  * allocated and the hardware unit is configured to point to the
@@ -226,13 +243,19 @@ void *cvmx_cmd_queue_buffer(cvmx_cmd_queue_id_t queue_id);
 
 /**
  * @INTERNAL
+ * Retreive or allocate command queue state named block
+ */
+extern cvmx_cmd_queue_result_t __cvmx_cmd_queue_init_state_ptr(unsigned node);
+
+/**
+ * @INTERNAL
  * Get the index into the state arrays for the supplied queue id.
  *
  * @param queue_id Queue ID to get an index for
  *
  * @return Index into the state arrays
  */
-static inline int __cvmx_cmd_queue_get_index(cvmx_cmd_queue_id_t queue_id)
+static inline unsigned __cvmx_cmd_queue_get_index(cvmx_cmd_queue_id_t queue_id)
 {
 	/* Warning: This code currently only works with devices that have 256
 	 * queues or less.  Devices with more than 16 queues are laid out in
@@ -240,10 +263,16 @@ static inline int __cvmx_cmd_queue_get_index(cvmx_cmd_queue_id_t queue_id)
 	 * cache thrashing when you are running 16 queues per port to support
 	 * lockless operation
 	 */
-	int unit = queue_id >> 16;
-	int q = (queue_id >> 4) & 0xf;
-	int core = queue_id & 0xf;
-	return unit * 256 + core * 16 + q;
+	unsigned unit = (queue_id >> 16) & 0xff;
+	unsigned q = (queue_id >> 4) & 0xf;
+	unsigned core = queue_id & 0xf;
+	return (unit << 8) | (core << 4) | q;
+}
+
+static inline int __cvmx_cmd_queue_get_node(cvmx_cmd_queue_id_t queue_id)
+{
+	unsigned node = queue_id >> 24;
+	return node;
 }
 
 /**
@@ -254,41 +283,39 @@ static inline int __cvmx_cmd_queue_get_index(cvmx_cmd_queue_id_t queue_id)
  * @param queue_id Queue ID to lock
  * @param qptr     Pointer to the queue's global state
  */
-static inline void __cvmx_cmd_queue_lock(cvmx_cmd_queue_id_t queue_id,
-					 __cvmx_cmd_queue_state_t * qptr)
+static inline void __cvmx_cmd_queue_lock(cvmx_cmd_queue_id_t queue_id)
 {
 #ifndef __U_BOOT__
-	extern CVMX_SHARED __cvmx_cmd_queue_all_state_t *__cvmx_cmd_queue_state_ptr;
-	int tmp;
-	int my_ticket;
-	CVMX_PREFETCH(qptr, 0);
+	__cvmx_cmd_queue_lock_t *lock_ptr;
+	unsigned node;
+	uint64_t tmp;
+	uint64_t my_ticket;
+
+	tmp = __cvmx_cmd_queue_get_index(queue_id);
+	node = __cvmx_cmd_queue_get_node(queue_id);
+	lock_ptr = &__cvmx_cmd_queue_state_ptrs[node]->lock[tmp];
+
 	asm volatile (".set push\n"
 		      ".set noreorder\n"
+		      /* Atomic incremebt of 'ticket' with LL/SC */
 		      "1:\n"
 		      "lld     %[my_ticket], %[ticket_ptr]\n"
-		      /* Atomic add one to ticket_ptr 64-bit operation for
-		       * endian nutral access.
-		       */
 		      "daddiu  %[ticket], %[my_ticket], 1\n"
-		      /*    and store the original value  in my_ticket */
 		      "scd     %[ticket], %[ticket_ptr]\n"
-		      "beqz   %[ticket], 1b\n"
-		      " sll	%[my_ticket],%[my_ticket],0\n"        /* truncate to 32 bits */
-		      "lw    %[ticket], %[now_serving]\n"	/* Load the current now_serving ticket */
+		      "beqz    %[ticket], 1b\n"
+		      " lld    %[ticket], %[now_serving]\n"
 		      "2:\n"
-		      "beq    %[ticket], %[my_ticket], 4f\n"	/* Jump out if now_serving == my_ticket */
-		      " subu   %[ticket], %[my_ticket], %[ticket]\n"	/* Find out how many tickets are in front of me */
-		      "subu  %[ticket], 1\n"	/* Use tickets in front of me minus one to delay */
-		      "sll   %[ticket], %[ticket], 5\n"	/* Delay will be ((tickets in front)-1)*32 loops */
+		      /* Wait until 'now_serving == ticket' with LL/PAUSE */
+		      "beq    %[ticket], %[my_ticket], 3f\n"
+		      " nop\n pause\n"	/* PAUSE is not allowed in delay slot */
+		      "b      2b\n"	/* check now_serving again */
+		      " lld    %[ticket], %[now_serving]\n"
 		      "3:\n"
-		      "bnez   %[ticket], 3b\n"	/* Loop here until our ticket might be up */
-		      " subu  %[ticket], 1\n"
-		      "b      2b\n"	/* Jump back up to check out ticket again */
-		      " lw    %[ticket], %[now_serving]\n"	/* Load the current now_serving ticket */
-		      "4:\n"
 		      ".set pop\n"
-		      : [ticket_ptr] "=m"(__cvmx_cmd_queue_state_ptr->ticket[__cvmx_cmd_queue_get_index(queue_id)]),
-		      [now_serving] "=m"(qptr->now_serving),[ticket] "=&r"(tmp),[my_ticket] "=&r"(my_ticket)
+                      : [ticket_ptr] "=m"(lock_ptr->ticket),
+                      [now_serving] "=m"(lock_ptr->now_serving),
+                      [ticket] "=&r"(tmp),
+                      [my_ticket] "=&r"(my_ticket)
 	    );
 #endif
 }
@@ -299,16 +326,43 @@ static inline void __cvmx_cmd_queue_lock(cvmx_cmd_queue_id_t queue_id,
  *
  * @param qptr   Queue to unlock
  */
-static inline void __cvmx_cmd_queue_unlock(__cvmx_cmd_queue_state_t * qptr)
+static inline void __cvmx_cmd_queue_unlock(cvmx_cmd_queue_id_t queue_id)
 {
 #ifndef __U_BOOT__
-	uint32_t ns;
+	__cvmx_cmd_queue_lock_t *lock_ptr;
+	uint64_t *ns_ptr;
+	uint64_t ns;
+	unsigned node;
+	int tmp;
 
-	ns = qptr->now_serving + 1;
-	CVMX_SYNCWS;		/* Order queue manipulation with respect to the unlock.  */
-	qptr->now_serving = ns;
-	CVMX_SYNCWS;		/* nudge out the unlock. */
+	/* Order queue manipulation with respect to the unlock.  */
+	CVMX_SYNCWS;
+
+	tmp = __cvmx_cmd_queue_get_index(queue_id);
+	node = __cvmx_cmd_queue_get_node(queue_id);
+
+	lock_ptr = &__cvmx_cmd_queue_state_ptrs[node]->lock[tmp];
+	ns_ptr = &lock_ptr->now_serving;
+
+	/* Incremebt 'now_sercving to allow next contender in */
+	ns = (*ns_ptr) + 1;
+	(*ns_ptr) = ns;
 #endif
+	CVMX_SYNCWS;		/* nudge out the unlock. */
+}
+
+/**
+ * @INTERNAL
+ * Initialize a command-queue lock to "unlocked" state.
+ */
+static inline void __cvmx_cmd_queue_lock_init(cvmx_cmd_queue_id_t queue_id)
+{
+	unsigned index = __cvmx_cmd_queue_get_index(queue_id);
+	unsigned node = __cvmx_cmd_queue_get_node(queue_id);
+
+	__cvmx_cmd_queue_state_ptrs[node]->lock[index] =
+			(__cvmx_cmd_queue_lock_t){0, 0};
+	CVMX_SYNCWS;
 }
 
 /**
@@ -322,14 +376,24 @@ static inline void __cvmx_cmd_queue_unlock(__cvmx_cmd_queue_state_t * qptr)
 static inline __cvmx_cmd_queue_state_t *
 __cvmx_cmd_queue_get_state(cvmx_cmd_queue_id_t queue_id)
 {
-	extern CVMX_SHARED __cvmx_cmd_queue_all_state_t *__cvmx_cmd_queue_state_ptr;
+	unsigned index;
+	unsigned node;
+	__cvmx_cmd_queue_state_t *qptr;
+
 	if (CVMX_ENABLE_PARAMETER_CHECKING) {
 		if (cvmx_unlikely(queue_id >= CVMX_CMD_QUEUE_END))
 			return NULL;
 		if (cvmx_unlikely((queue_id & 0xffff) >= 256))
 			return NULL;
 	}
-	return &__cvmx_cmd_queue_state_ptr->state[__cvmx_cmd_queue_get_index(queue_id)];
+	node = __cvmx_cmd_queue_get_node(queue_id);
+	index = __cvmx_cmd_queue_get_index(queue_id);
+
+	if (cvmx_unlikely(__cvmx_cmd_queue_state_ptrs[node] == NULL))
+		__cvmx_cmd_queue_init_state_ptr(node);
+
+	qptr = &__cvmx_cmd_queue_state_ptrs[node]->state[index];
+	return qptr;
 }
 
 static inline uint64_t *__cvmx_cmd_queue_alloc_buffer(int pool)
@@ -371,7 +435,7 @@ cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
 
 	/* Make sure nobody else is updating the same queue */
 	if (cvmx_likely(use_locking))
-		__cvmx_cmd_queue_lock(queue_id, qptr);
+		__cvmx_cmd_queue_lock(queue_id);
 
 	/* If a max queue length was specified then make sure we don't
 	   exceed it. If any part of the command would be below the limit
@@ -379,14 +443,14 @@ cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
 	if (CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH && cvmx_unlikely(qptr->max_depth)) {
 		if (cvmx_unlikely(cvmx_cmd_queue_length(queue_id) > (int)qptr->max_depth)) {
 			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(qptr);
+				__cvmx_cmd_queue_unlock(queue_id);
 			return CVMX_CMD_QUEUE_FULL;
 		}
 	}
 
 	/* Normally there is plenty of room in the current buffer for the command */
 	if (cvmx_likely(qptr->index + cmd_count < qptr->pool_size_m1)) {
-		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_ptr_div128 << 7);
+		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
 		ptr += qptr->index;
 		qptr->index += cmd_count;
 		while (cmd_count--)
@@ -398,10 +462,10 @@ cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
 		uint64_t *new_buffer = __cvmx_cmd_queue_alloc_buffer(qptr->fpa_pool);
 		if (cvmx_unlikely(new_buffer == NULL)) {
 			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(qptr);
+				__cvmx_cmd_queue_unlock(queue_id);
 			return CVMX_CMD_QUEUE_NO_MEMORY;
 		}
-		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_ptr_div128 << 7);
+		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
 		/* Figure out how many command words will fit in this buffer.
 		 * One location will be needed for the next buffer pointer
 		 */
@@ -414,7 +478,7 @@ cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
 		/* The current buffer is full and has a link to the next buffer.
 		 * Time to write the rest of the commands into the new buffer
 		 */
-		qptr->base_ptr_div128 = *ptr >> 7;
+		qptr->base_paddr = *ptr;
 		qptr->index = cmd_count;
 		ptr = new_buffer;
 		while (cmd_count--)
@@ -423,10 +487,10 @@ cvmx_cmd_queue_write(cvmx_cmd_queue_id_t queue_id, int use_locking,
 
 	/* All updates are complete. Release the lock and return */
 	if (cvmx_likely(use_locking))
-		__cvmx_cmd_queue_unlock(qptr);
-#ifdef __U_BOOT__
-	CVMX_SYNCWS;
-#endif
+		__cvmx_cmd_queue_unlock(queue_id);
+	else
+		CVMX_SYNCWS;
+
 	return CVMX_CMD_QUEUE_SUCCESS;
 }
 
@@ -457,7 +521,7 @@ cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
 
 	/* Make sure nobody else is updating the same queue */
 	if (cvmx_likely(use_locking))
-		__cvmx_cmd_queue_lock(queue_id, qptr);
+		__cvmx_cmd_queue_lock(queue_id);
 
 	/* If a max queue length was specified then make sure we don't
 	   exceed it. If any part of the command would be below the limit
@@ -465,14 +529,14 @@ cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
 	if (CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH && cvmx_unlikely(qptr->max_depth)) {
 		if (cvmx_unlikely(cvmx_cmd_queue_length(queue_id) > (int)qptr->max_depth)) {
 			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(qptr);
+				__cvmx_cmd_queue_unlock(queue_id);
 			return CVMX_CMD_QUEUE_FULL;
 		}
 	}
 
 	/* Normally there is plenty of room in the current buffer for the command */
 	if (cvmx_likely(qptr->index + 2 < qptr->pool_size_m1)) {
-		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_ptr_div128 << 7);
+		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
 		ptr += qptr->index;
 		qptr->index += 2;
 		ptr[0] = cmd1;
@@ -486,11 +550,11 @@ cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
 		uint64_t *new_buffer = __cvmx_cmd_queue_alloc_buffer(qptr->fpa_pool);
 		if (cvmx_unlikely(new_buffer == NULL)) {
 			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(qptr);
+				__cvmx_cmd_queue_unlock(queue_id);
 			return CVMX_CMD_QUEUE_NO_MEMORY;
 		}
 		count--;
-		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_ptr_div128 << 7);
+		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
 		ptr += qptr->index;
 		*ptr++ = cmd1;
 		if (cvmx_likely(count))
@@ -498,7 +562,7 @@ cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
 		*ptr = cvmx_ptr_to_phys(new_buffer);
 		/* The current buffer is full and has a link to the next buffer. Time
 		   to write the rest of the commands into the new buffer */
-		qptr->base_ptr_div128 = *ptr >> 7;
+		qptr->base_paddr = *ptr;
 		qptr->index = 0;
 		if (cvmx_unlikely(count == 0)) {
 			qptr->index = 1;
@@ -508,7 +572,9 @@ cvmx_cmd_queue_write2(cvmx_cmd_queue_id_t queue_id, int use_locking,
 
 	/* All updates are complete. Release the lock and return */
 	if (cvmx_likely(use_locking))
-		__cvmx_cmd_queue_unlock(qptr);
+		__cvmx_cmd_queue_unlock(queue_id);
+	else
+		CVMX_SYNCWS;
 	return CVMX_CMD_QUEUE_SUCCESS;
 }
 
@@ -540,7 +606,7 @@ cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, int use_locking,
 
 	/* Make sure nobody else is updating the same queue */
 	if (cvmx_likely(use_locking))
-		__cvmx_cmd_queue_lock(queue_id, qptr);
+		__cvmx_cmd_queue_lock(queue_id);
 
 	/* If a max queue length was specified then make sure we don't
 	   exceed it. If any part of the command would be below the limit
@@ -548,14 +614,14 @@ cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, int use_locking,
 	if (CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH && cvmx_unlikely(qptr->max_depth)) {
 		if (cvmx_unlikely(cvmx_cmd_queue_length(queue_id) > (int)qptr->max_depth)) {
 			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(qptr);
+				__cvmx_cmd_queue_unlock(queue_id);
 			return CVMX_CMD_QUEUE_FULL;
 		}
 	}
 
 	/* Normally there is plenty of room in the current buffer for the command */
 	if (cvmx_likely(qptr->index + 3 < qptr->pool_size_m1)) {
-		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_ptr_div128 << 7);
+		uint64_t *ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
 		ptr += qptr->index;
 		qptr->index += 3;
 		ptr[0] = cmd1;
@@ -571,11 +637,11 @@ cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, int use_locking,
 		uint64_t *new_buffer = __cvmx_cmd_queue_alloc_buffer(qptr->fpa_pool);
 		if (cvmx_unlikely(new_buffer == NULL)) {
 			if (cvmx_likely(use_locking))
-				__cvmx_cmd_queue_unlock(qptr);
+				__cvmx_cmd_queue_unlock(queue_id);
 			return CVMX_CMD_QUEUE_NO_MEMORY;
 		}
 		count--;
-		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_ptr_div128 << 7);
+		ptr = (uint64_t *) cvmx_phys_to_ptr((uint64_t) qptr->base_paddr);
 		ptr += qptr->index;
 		*ptr++ = cmd1;
 		if (count) {
@@ -587,7 +653,7 @@ cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, int use_locking,
 		/* The current buffer is full and has a link to the next buffer.
 		 * Time to write the rest of the commands into the new buffer
 		 */
-		qptr->base_ptr_div128 = *ptr >> 7;
+		qptr->base_paddr = *ptr;
 		qptr->index = 0;
 		ptr = new_buffer;
 		if (count == 0) {
@@ -602,7 +668,9 @@ cvmx_cmd_queue_write3(cvmx_cmd_queue_id_t queue_id, int use_locking,
 
 	/* All updates are complete. Release the lock and return */
 	if (cvmx_likely(use_locking))
-		__cvmx_cmd_queue_unlock(qptr);
+		__cvmx_cmd_queue_unlock(queue_id);
+	else
+		CVMX_SYNCWS;
 	return CVMX_CMD_QUEUE_SUCCESS;
 }
 
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index ed35782..f8610db 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_DPI_BIST_STATUS CVMX_DPI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_DPI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000000ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_DPI_BIST_STATUS_FUNC(void)
 #define CVMX_DPI_CTL CVMX_DPI_CTL_FUNC()
 static inline uint64_t CVMX_DPI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000040ull);
 }
@@ -83,6 +83,7 @@ static inline uint64_t CVMX_DPI_DMAX_COUNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_COUNTS(%lu) is invalid on this chip\n", offset);
@@ -100,6 +101,7 @@ static inline uint64_t CVMX_DPI_DMAX_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_DBELL(%lu) is invalid on this chip\n", offset);
@@ -116,6 +118,7 @@ static inline uint64_t CVMX_DPI_DMAX_ERR_RSP_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_ERR_RSP_STATUS(%lu) is invalid on this chip\n", offset);
@@ -133,6 +136,7 @@ static inline uint64_t CVMX_DPI_DMAX_IBUFF_SADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_IBUFF_SADDR(%lu) is invalid on this chip\n", offset);
@@ -149,6 +153,7 @@ static inline uint64_t CVMX_DPI_DMAX_IFLIGHT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_IFLIGHT(%lu) is invalid on this chip\n", offset);
@@ -166,6 +171,7 @@ static inline uint64_t CVMX_DPI_DMAX_NADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_NADDR(%lu) is invalid on this chip\n", offset);
@@ -183,6 +189,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQBNK0(%lu) is invalid on this chip\n", offset);
@@ -200,6 +207,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQBNK1(%lu) is invalid on this chip\n", offset);
@@ -212,6 +220,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK1(unsigned long offset)
 static inline uint64_t CVMX_DPI_DMAX_REQQ_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQQ_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001DF0000000180ull) + ((offset) & 7) * 8;
@@ -223,7 +232,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQQ_CTL(unsigned long offset)
 #define CVMX_DPI_DMA_CONTROL CVMX_DPI_DMA_CONTROL_FUNC()
 static inline uint64_t CVMX_DPI_DMA_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_DMA_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000048ull);
 }
@@ -239,6 +248,7 @@ static inline uint64_t CVMX_DPI_DMA_ENGX_EN(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DPI_DMA_ENGX_EN(%lu) is invalid on this chip\n", offset);
@@ -265,6 +275,10 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 			if ((offset <= 47))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 15))
+				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 15) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_DPI_DMA_PPX_CNT (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001DF0000000B00ull) + ((offset) & 3) * 8;
@@ -281,6 +295,8 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001DF0000000B00ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001DF0000000B00ull) + (offset) * 8;
 }
@@ -289,7 +305,7 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 #define CVMX_DPI_DMA_PP_INT CVMX_DPI_DMA_PP_INT_FUNC()
 static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_DMA_PP_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000038ull);
 }
@@ -300,7 +316,7 @@ static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
 #define CVMX_DPI_ECC_CTL CVMX_DPI_ECC_CTL_FUNC()
 static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000018ull);
 }
@@ -311,7 +327,7 @@ static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 #define CVMX_DPI_ECC_INT CVMX_DPI_ECC_INT_FUNC()
 static inline uint64_t CVMX_DPI_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000020ull);
 }
@@ -327,6 +343,7 @@ static inline uint64_t CVMX_DPI_ENGX_BUF(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DPI_ENGX_BUF(%lu) is invalid on this chip\n", offset);
@@ -339,7 +356,7 @@ static inline uint64_t CVMX_DPI_ENGX_BUF(unsigned long offset)
 #define CVMX_DPI_INFO_REG CVMX_DPI_INFO_REG_FUNC()
 static inline uint64_t CVMX_DPI_INFO_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_INFO_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000980ull);
 }
@@ -361,7 +378,7 @@ static inline uint64_t CVMX_DPI_INT_EN_FUNC(void)
 #define CVMX_DPI_INT_REG CVMX_DPI_INT_REG_FUNC()
 static inline uint64_t CVMX_DPI_INT_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_INT_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000008ull);
 }
@@ -369,26 +386,27 @@ static inline uint64_t CVMX_DPI_INT_REG_FUNC(void)
 #define CVMX_DPI_INT_REG (CVMX_ADD_IO_SEG(0x0001DF0000000008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_DPI_NCBX_CFG(unsigned long block_id)
+static inline uint64_t CVMX_DPI_NCBX_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_DPI_NCBX_CFG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_DPI_NCBX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001DF0000000800ull);
 }
 #else
-#define CVMX_DPI_NCBX_CFG(block_id) (CVMX_ADD_IO_SEG(0x0001DF0000000800ull))
+#define CVMX_DPI_NCBX_CFG(offset) (CVMX_ADD_IO_SEG(0x0001DF0000000800ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_DPI_NCB_CTL CVMX_DPI_NCB_CTL_FUNC()
 static inline uint64_t CVMX_DPI_NCB_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_NCB_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000028ull);
 }
@@ -399,7 +417,7 @@ static inline uint64_t CVMX_DPI_NCB_CTL_FUNC(void)
 #define CVMX_DPI_PINT_INFO CVMX_DPI_PINT_INFO_FUNC()
 static inline uint64_t CVMX_DPI_PINT_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_PINT_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000830ull);
 }
@@ -410,7 +428,7 @@ static inline uint64_t CVMX_DPI_PINT_INFO_FUNC(void)
 #define CVMX_DPI_PKT_ERR_RSP CVMX_DPI_PKT_ERR_RSP_FUNC()
 static inline uint64_t CVMX_DPI_PKT_ERR_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_PKT_ERR_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000078ull);
 }
@@ -421,7 +439,7 @@ static inline uint64_t CVMX_DPI_PKT_ERR_RSP_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RSP CVMX_DPI_REQ_ERR_RSP_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000058ull);
 }
@@ -432,7 +450,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RSP_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RSP_EN CVMX_DPI_REQ_ERR_RSP_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RSP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RSP_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000068ull);
 }
@@ -443,7 +461,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RSP_EN_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RST CVMX_DPI_REQ_ERR_RST_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000060ull);
 }
@@ -454,7 +472,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RST_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RST_EN CVMX_DPI_REQ_ERR_RST_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RST_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RST_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000070ull);
 }
@@ -465,7 +483,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RST_EN_FUNC(void)
 #define CVMX_DPI_REQ_ERR_SKIP_COMP CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_SKIP_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000838ull);
 }
@@ -476,7 +494,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC(void)
 #define CVMX_DPI_REQ_GBL_EN CVMX_DPI_REQ_GBL_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_GBL_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_GBL_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000050ull);
 }
@@ -492,6 +510,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_CFG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DPI_SLI_PRTX_CFG(%lu) is invalid on this chip\n", offset);
@@ -518,15 +537,16 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR(unsigned long offset)
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 1) * 8;
 			break;
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 2))
-				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
+			break;
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000928ull) + ((offset) & 1) * 8;
@@ -549,10 +569,11 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR(unsigned long offset)
 			if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000928ull) + (offset) * 8;
@@ -569,6 +590,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR_INFO(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DPI_SLI_PRTX_ERR_INFO(%lu) is invalid on this chip\n", offset);
@@ -581,7 +603,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR_INFO(unsigned long offset)
 #define CVMX_DPI_SWA_Q_VMID CVMX_DPI_SWA_Q_VMID_FUNC()
 static inline uint64_t CVMX_DPI_SWA_Q_VMID_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_SWA_Q_VMID not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000030ull);
 }
@@ -646,6 +668,7 @@ union cvmx_dpi_bist_status {
 	struct cvmx_dpi_bist_status_cn63xx    cn68xxp1;
 	struct cvmx_dpi_bist_status_cn61xx    cn70xx;
 	struct cvmx_dpi_bist_status_cn61xx    cn70xxp1;
+	struct cvmx_dpi_bist_status_s         cn73xx;
 	struct cvmx_dpi_bist_status_s         cn78xx;
 	struct cvmx_dpi_bist_status_cn61xx    cnf71xx;
 };
@@ -686,6 +709,7 @@ union cvmx_dpi_ctl {
 	struct cvmx_dpi_ctl_s                 cn68xxp1;
 	struct cvmx_dpi_ctl_cn61xx            cn70xx;
 	struct cvmx_dpi_ctl_cn61xx            cn70xxp1;
+	struct cvmx_dpi_ctl_cn61xx            cn73xx;
 	struct cvmx_dpi_ctl_cn61xx            cn78xx;
 	struct cvmx_dpi_ctl_cn61xx            cnf71xx;
 };
@@ -719,6 +743,7 @@ union cvmx_dpi_dmax_counts {
 	struct cvmx_dpi_dmax_counts_s         cn68xxp1;
 	struct cvmx_dpi_dmax_counts_s         cn70xx;
 	struct cvmx_dpi_dmax_counts_s         cn70xxp1;
+	struct cvmx_dpi_dmax_counts_s         cn73xx;
 	struct cvmx_dpi_dmax_counts_s         cn78xx;
 	struct cvmx_dpi_dmax_counts_s         cnf71xx;
 };
@@ -751,6 +776,7 @@ union cvmx_dpi_dmax_dbell {
 	struct cvmx_dpi_dmax_dbell_s          cn68xxp1;
 	struct cvmx_dpi_dmax_dbell_s          cn70xx;
 	struct cvmx_dpi_dmax_dbell_s          cn70xxp1;
+	struct cvmx_dpi_dmax_dbell_s          cn73xx;
 	struct cvmx_dpi_dmax_dbell_s          cn78xx;
 	struct cvmx_dpi_dmax_dbell_s          cnf71xx;
 };
@@ -783,6 +809,7 @@ union cvmx_dpi_dmax_err_rsp_status {
 	struct cvmx_dpi_dmax_err_rsp_status_s cn68xxp1;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn70xx;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn70xxp1;
+	struct cvmx_dpi_dmax_err_rsp_status_s cn73xx;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn78xx;
 	struct cvmx_dpi_dmax_err_rsp_status_s cnf71xx;
 };
@@ -872,7 +899,7 @@ union cvmx_dpi_dmax_ibuff_saddr {
 	struct cvmx_dpi_dmax_ibuff_saddr_cn68xx cn68xxp1;
 	struct cvmx_dpi_dmax_ibuff_saddr_cn61xx cn70xx;
 	struct cvmx_dpi_dmax_ibuff_saddr_cn61xx cn70xxp1;
-	struct cvmx_dpi_dmax_ibuff_saddr_cn78xx {
+	struct cvmx_dpi_dmax_ibuff_saddr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t idle                         : 1;  /**< DMA request queue is idle. When asserted, the associated request queue is idle. */
 	uint64_t reserved_62_62               : 1;
@@ -894,7 +921,8 @@ union cvmx_dpi_dmax_ibuff_saddr {
 	uint64_t reserved_62_62               : 1;
 	uint64_t idle                         : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_dpi_dmax_ibuff_saddr_cn73xx cn78xx;
 	struct cvmx_dpi_dmax_ibuff_saddr_cn61xx cnf71xx;
 };
 typedef union cvmx_dpi_dmax_ibuff_saddr cvmx_dpi_dmax_ibuff_saddr_t;
@@ -921,6 +949,7 @@ union cvmx_dpi_dmax_iflight {
 	struct cvmx_dpi_dmax_iflight_s        cn68xxp1;
 	struct cvmx_dpi_dmax_iflight_s        cn70xx;
 	struct cvmx_dpi_dmax_iflight_s        cn70xxp1;
+	struct cvmx_dpi_dmax_iflight_s        cn73xx;
 	struct cvmx_dpi_dmax_iflight_s        cn78xx;
 	struct cvmx_dpi_dmax_iflight_s        cnf71xx;
 };
@@ -970,6 +999,7 @@ union cvmx_dpi_dmax_naddr {
 	struct cvmx_dpi_dmax_naddr_cn68xx     cn68xxp1;
 	struct cvmx_dpi_dmax_naddr_cn61xx     cn70xx;
 	struct cvmx_dpi_dmax_naddr_cn61xx     cn70xxp1;
+	struct cvmx_dpi_dmax_naddr_s          cn73xx;
 	struct cvmx_dpi_dmax_naddr_s          cn78xx;
 	struct cvmx_dpi_dmax_naddr_cn61xx     cnf71xx;
 };
@@ -998,6 +1028,7 @@ union cvmx_dpi_dmax_reqbnk0 {
 	struct cvmx_dpi_dmax_reqbnk0_s        cn68xxp1;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn70xx;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn70xxp1;
+	struct cvmx_dpi_dmax_reqbnk0_s        cn73xx;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn78xx;
 	struct cvmx_dpi_dmax_reqbnk0_s        cnf71xx;
 };
@@ -1026,6 +1057,7 @@ union cvmx_dpi_dmax_reqbnk1 {
 	struct cvmx_dpi_dmax_reqbnk1_s        cn68xxp1;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn70xx;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn70xxp1;
+	struct cvmx_dpi_dmax_reqbnk1_s        cn73xx;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn78xx;
 	struct cvmx_dpi_dmax_reqbnk1_s        cnf71xx;
 };
@@ -1060,6 +1092,7 @@ union cvmx_dpi_dmax_reqq_ctl {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_dpi_dmax_reqq_ctl_s       cn73xx;
 	struct cvmx_dpi_dmax_reqq_ctl_s       cn78xx;
 };
 typedef union cvmx_dpi_dmax_reqq_ctl cvmx_dpi_dmax_reqq_ctl_t;
@@ -1122,7 +1155,10 @@ union cvmx_dpi_dma_control {
                                                          not be disabled while processing instructions.
                                                          When PKT_EN=1,  then DMA_ENB<5>=0.
                                                          When PKT_EN1=1, then DMA_ENB<4>=0. */
-	uint64_t reserved_35_47               : 13;
+	uint64_t wqecsdis                     : 1;  /**< Reserved. */
+	uint64_t wqecsoff                     : 7;  /**< Reserved. */
+	uint64_t zbwcsen                      : 1;  /**< Reserved. */
+	uint64_t reserved_35_38               : 4;
 	uint64_t ncb_tag                      : 1;  /**< Reserved. */
 	uint64_t b0_lend                      : 1;  /**< When set '1' and the DPI is in the mode to write
                                                          0 to L2C memory when a DMA is done, the address
@@ -1154,7 +1190,10 @@ union cvmx_dpi_dma_control {
 	uint64_t reserved_20_32               : 13;
 	uint64_t b0_lend                      : 1;
 	uint64_t ncb_tag                      : 1;
-	uint64_t reserved_35_47               : 13;
+	uint64_t reserved_35_38               : 4;
+	uint64_t zbwcsen                      : 1;
+	uint64_t wqecsoff                     : 7;
+	uint64_t wqecsdis                     : 1;
 	uint64_t dma_enb                      : 6;
 	uint64_t reserved_54_55               : 2;
 	uint64_t pkt_en                       : 1;
@@ -1451,7 +1490,7 @@ union cvmx_dpi_dma_control {
 	struct cvmx_dpi_dma_control_cn63xx    cn68xxp1;
 	struct cvmx_dpi_dma_control_cn61xx    cn70xx;
 	struct cvmx_dpi_dma_control_cn61xx    cn70xxp1;
-	struct cvmx_dpi_dma_control_cn78xx {
+	struct cvmx_dpi_dma_control_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t ffp_dis                      : 1;  /**< Force forward progress disable. The DMA engines will compete for shared resources. If the
@@ -1473,8 +1512,13 @@ union cvmx_dpi_dma_control {
 	uint64_t dma_enb                      : 6;  /**< DMA engine enable. Enables the operation of the DMA engine. After being enabled an engine
                                                          should not be disabled while processing instructions.
                                                          When PKT_EN=1, then DMA_ENB<5>=0 and DMA_ENB<4>=0. */
-	uint64_t reserved_35_47               : 13;
-	uint64_t ncb_tag                      : 1;  /**< Reserved. */
+	uint64_t wqecsdis                     : 1;  /**< Work queue completion status disable. */
+	uint64_t wqecsoff                     : 7;  /**< Work queue completion status offset. */
+	uint64_t zbwcsen                      : 1;  /**< Zero-byte-write completion status enable. */
+	uint64_t reserved_35_38               : 4;
+	uint64_t ncb_tag                      : 1;  /**< NCB tag enable. It allows DMA Read/Write transactions over NCB to be mapped to
+                                                         individual request queues by using tags. This enables more parallelism, giving a
+                                                         performance boost. */
 	uint64_t b0_lend                      : 1;  /**< Little-endian. When set to 1 and the DPI is in the mode to write 0 to L2C when a DMA
                                                          transaction is done, the address to be written is treated as a little-endian address. */
 	uint64_t ldwb                         : 1;  /**< Load don't write back. When set, the hardware is able to issue LDWB commands to the cache.
@@ -1510,7 +1554,10 @@ union cvmx_dpi_dma_control {
 	uint64_t ldwb                         : 1;
 	uint64_t b0_lend                      : 1;
 	uint64_t ncb_tag                      : 1;
-	uint64_t reserved_35_47               : 13;
+	uint64_t reserved_35_38               : 4;
+	uint64_t zbwcsen                      : 1;
+	uint64_t wqecsoff                     : 7;
+	uint64_t wqecsdis                     : 1;
 	uint64_t dma_enb                      : 6;
 	uint64_t reserved_54_55               : 2;
 	uint64_t pkt_en                       : 1;
@@ -1519,7 +1566,8 @@ union cvmx_dpi_dma_control {
 	uint64_t ffp_dis                      : 1;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_dpi_dma_control_cn73xx    cn78xx;
 	struct cvmx_dpi_dma_control_cn61xx    cnf71xx;
 };
 typedef union cvmx_dpi_dma_control cvmx_dpi_dma_control_t;
@@ -1555,6 +1603,7 @@ union cvmx_dpi_dma_engx_en {
 	struct cvmx_dpi_dma_engx_en_s         cn68xxp1;
 	struct cvmx_dpi_dma_engx_en_s         cn70xx;
 	struct cvmx_dpi_dma_engx_en_s         cn70xxp1;
+	struct cvmx_dpi_dma_engx_en_s         cn73xx;
 	struct cvmx_dpi_dma_engx_en_s         cn78xx;
 	struct cvmx_dpi_dma_engx_en_s         cnf71xx;
 };
@@ -1589,6 +1638,7 @@ union cvmx_dpi_dma_ppx_cnt {
 	struct cvmx_dpi_dma_ppx_cnt_s         cn68xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn70xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn70xxp1;
+	struct cvmx_dpi_dma_ppx_cnt_s         cn73xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn78xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cnf71xx;
 };
@@ -1608,6 +1658,15 @@ union cvmx_dpi_dma_pp_int {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_dpi_dma_pp_int_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t complete                     : 16; /**< DPI DMA per-core instruction completion interrupt. See DPI_DMA_PP()_CNT. */
+#else
+	uint64_t complete                     : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_dpi_dma_pp_int_s          cn78xx;
 };
 typedef union cvmx_dpi_dma_pp_int cvmx_dpi_dma_pp_int_t;
@@ -1639,6 +1698,7 @@ union cvmx_dpi_ecc_ctl {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_dpi_ecc_ctl_s             cn73xx;
 	struct cvmx_dpi_ecc_ctl_s             cn78xx;
 };
 typedef union cvmx_dpi_ecc_ctl cvmx_dpi_ecc_ctl_t;
@@ -1697,6 +1757,7 @@ union cvmx_dpi_ecc_int {
 	uint64_t reserved_47_63               : 17;
 #endif
 	} s;
+	struct cvmx_dpi_ecc_int_s             cn73xx;
 	struct cvmx_dpi_ecc_int_s             cn78xx;
 };
 typedef union cvmx_dpi_ecc_int cvmx_dpi_ecc_int_t;
@@ -1791,6 +1852,7 @@ union cvmx_dpi_engx_buf {
 	struct cvmx_dpi_engx_buf_cn61xx       cn68xxp1;
 	struct cvmx_dpi_engx_buf_cn61xx       cn70xx;
 	struct cvmx_dpi_engx_buf_cn61xx       cn70xxp1;
+	struct cvmx_dpi_engx_buf_s            cn73xx;
 	struct cvmx_dpi_engx_buf_s            cn78xx;
 	struct cvmx_dpi_engx_buf_cn61xx       cnf71xx;
 };
@@ -1846,6 +1908,7 @@ union cvmx_dpi_info_reg {
 	struct cvmx_dpi_info_reg_s            cn68xxp1;
 	struct cvmx_dpi_info_reg_s            cn70xx;
 	struct cvmx_dpi_info_reg_s            cn70xxp1;
+	struct cvmx_dpi_info_reg_s            cn73xx;
 	struct cvmx_dpi_info_reg_s            cn78xx;
 	struct cvmx_dpi_info_reg_s            cnf71xx;
 };
@@ -1947,8 +2010,54 @@ union cvmx_dpi_int_en {
 	struct cvmx_dpi_int_en_s              cn66xx;
 	struct cvmx_dpi_int_en_cn63xx         cn68xx;
 	struct cvmx_dpi_int_en_cn63xx         cn68xxp1;
-	struct cvmx_dpi_int_en_s              cn70xx;
-	struct cvmx_dpi_int_en_s              cn70xxp1;
+	struct cvmx_dpi_int_en_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_28_63               : 36;
+	uint64_t sprt3_rst                    : 1;  /**< DMA instruction was dropped because the source or
+                                                         destination port was in reset.
+                                                         this bit is set. */
+	uint64_t sprt2_rst                    : 1;  /**< DMA instruction was dropped because the source or
+                                                         destination port was in reset.
+                                                         this bit is set. */
+	uint64_t sprt1_rst                    : 1;  /**< DMA instruction was dropped because the source or
+                                                         destination port was in reset.
+                                                         this bit is set. */
+	uint64_t sprt0_rst                    : 1;  /**< DMA instruction was dropped because the source or
+                                                         destination port was in reset.
+                                                         this bit is set. */
+	uint64_t reserved_23_23               : 1;
+	uint64_t req_badfil                   : 1;  /**< DMA instruction unexpected fill */
+	uint64_t req_inull                    : 1;  /**< DMA instruction filled with NULL pointer */
+	uint64_t req_anull                    : 1;  /**< DMA instruction filled with bad instruction */
+	uint64_t req_undflw                   : 1;  /**< DMA instruction FIFO underflow */
+	uint64_t req_ovrflw                   : 1;  /**< DMA instruction FIFO overflow */
+	uint64_t req_badlen                   : 1;  /**< DMA instruction fetch with length */
+	uint64_t req_badadr                   : 1;  /**< DMA instruction fetch with bad pointer */
+	uint64_t dmadbo                       : 8;  /**< DMAx doorbell overflow. */
+	uint64_t reserved_7_2                 : 6;
+	uint64_t nfovr                        : 1;  /**< CSR Fifo Overflow */
+	uint64_t nderr                        : 1;  /**< NCB Decode Error */
+#else
+	uint64_t nderr                        : 1;
+	uint64_t nfovr                        : 1;
+	uint64_t reserved_7_2                 : 6;
+	uint64_t dmadbo                       : 8;
+	uint64_t req_badadr                   : 1;
+	uint64_t req_badlen                   : 1;
+	uint64_t req_ovrflw                   : 1;
+	uint64_t req_undflw                   : 1;
+	uint64_t req_anull                    : 1;
+	uint64_t req_inull                    : 1;
+	uint64_t req_badfil                   : 1;
+	uint64_t reserved_23_23               : 1;
+	uint64_t sprt0_rst                    : 1;
+	uint64_t sprt1_rst                    : 1;
+	uint64_t sprt2_rst                    : 1;
+	uint64_t sprt3_rst                    : 1;
+	uint64_t reserved_28_63               : 36;
+#endif
+	} cn70xx;
+	struct cvmx_dpi_int_en_cn70xx         cn70xxp1;
 	struct cvmx_dpi_int_en_s              cnf71xx;
 };
 typedef union cvmx_dpi_int_en cvmx_dpi_int_en_t;
@@ -2092,6 +2201,7 @@ union cvmx_dpi_int_reg {
 	struct cvmx_dpi_int_reg_cn63xx        cn68xxp1;
 	struct cvmx_dpi_int_reg_s             cn70xx;
 	struct cvmx_dpi_int_reg_s             cn70xxp1;
+	struct cvmx_dpi_int_reg_s             cn73xx;
 	struct cvmx_dpi_int_reg_s             cn78xx;
 	struct cvmx_dpi_int_reg_s             cnf71xx;
 };
@@ -2121,6 +2231,7 @@ union cvmx_dpi_ncbx_cfg {
 	struct cvmx_dpi_ncbx_cfg_s            cn68xx;
 	struct cvmx_dpi_ncbx_cfg_s            cn70xx;
 	struct cvmx_dpi_ncbx_cfg_s            cn70xxp1;
+	struct cvmx_dpi_ncbx_cfg_s            cn73xx;
 	struct cvmx_dpi_ncbx_cfg_s            cn78xx;
 	struct cvmx_dpi_ncbx_cfg_s            cnf71xx;
 };
@@ -2163,6 +2274,41 @@ union cvmx_dpi_ncb_ctl {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_dpi_ncb_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t ncbsel_prt_xor_dis           : 1;  /**< Disable the inclusion of the instruction header LPORT field when computing the NCB bus. */
+	uint64_t reserved_21_23               : 3;
+	uint64_t ncbsel_zbw                   : 1;  /**< ZBW select.
+                                                         0 = Zero-byte-write transaction will make requests and receive responses using NCB2.
+                                                         1 = Zero-byte-write transaction will make requests and receive responses using NCB3. */
+	uint64_t reserved_17_19               : 3;
+	uint64_t ncbsel_req                   : 1;  /**< Request select.
+                                                         0 = Instruction request transaction will make requests and receive responses using NCB2.
+                                                         1 = Instruction request transaction will make requests and receive responses using NCB3. */
+	uint64_t reserved_13_15               : 3;
+	uint64_t ncbsel_dst                   : 1;  /**< Destination select.
+                                                         0 = Transaction will make requests and receive responses using NCB2.
+                                                         1 = Transaction will make requests and receive responses using NCB3. */
+	uint64_t reserved_9_11                : 3;
+	uint64_t ncbsel_src                   : 1;  /**< Source select.
+                                                         0 = Transaction will make requests and receive responses using NCB2.
+                                                         1 = Transaction will make requests and receive responses using NCB3. */
+	uint64_t reserved_0_7                 : 8;
+#else
+	uint64_t reserved_0_7                 : 8;
+	uint64_t ncbsel_src                   : 1;
+	uint64_t reserved_9_11                : 3;
+	uint64_t ncbsel_dst                   : 1;
+	uint64_t reserved_13_15               : 3;
+	uint64_t ncbsel_req                   : 1;
+	uint64_t reserved_17_19               : 3;
+	uint64_t ncbsel_zbw                   : 1;
+	uint64_t reserved_21_23               : 3;
+	uint64_t ncbsel_prt_xor_dis           : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn73xx;
 	struct cvmx_dpi_ncb_ctl_s             cn78xx;
 };
 typedef union cvmx_dpi_ncb_ctl cvmx_dpi_ncb_ctl_t;
@@ -2196,6 +2342,7 @@ union cvmx_dpi_pint_info {
 	struct cvmx_dpi_pint_info_s           cn68xxp1;
 	struct cvmx_dpi_pint_info_s           cn70xx;
 	struct cvmx_dpi_pint_info_s           cn70xxp1;
+	struct cvmx_dpi_pint_info_s           cn73xx;
 	struct cvmx_dpi_pint_info_s           cn78xx;
 	struct cvmx_dpi_pint_info_s           cnf71xx;
 };
@@ -2224,6 +2371,7 @@ union cvmx_dpi_pkt_err_rsp {
 	struct cvmx_dpi_pkt_err_rsp_s         cn68xxp1;
 	struct cvmx_dpi_pkt_err_rsp_s         cn70xx;
 	struct cvmx_dpi_pkt_err_rsp_s         cn70xxp1;
+	struct cvmx_dpi_pkt_err_rsp_s         cn73xx;
 	struct cvmx_dpi_pkt_err_rsp_s         cn78xx;
 	struct cvmx_dpi_pkt_err_rsp_s         cnf71xx;
 };
@@ -2255,6 +2403,7 @@ union cvmx_dpi_req_err_rsp {
 	struct cvmx_dpi_req_err_rsp_s         cn68xxp1;
 	struct cvmx_dpi_req_err_rsp_s         cn70xx;
 	struct cvmx_dpi_req_err_rsp_s         cn70xxp1;
+	struct cvmx_dpi_req_err_rsp_s         cn73xx;
 	struct cvmx_dpi_req_err_rsp_s         cn78xx;
 	struct cvmx_dpi_req_err_rsp_s         cnf71xx;
 };
@@ -2284,6 +2433,7 @@ union cvmx_dpi_req_err_rsp_en {
 	struct cvmx_dpi_req_err_rsp_en_s      cn68xxp1;
 	struct cvmx_dpi_req_err_rsp_en_s      cn70xx;
 	struct cvmx_dpi_req_err_rsp_en_s      cn70xxp1;
+	struct cvmx_dpi_req_err_rsp_en_s      cn73xx;
 	struct cvmx_dpi_req_err_rsp_en_s      cn78xx;
 	struct cvmx_dpi_req_err_rsp_en_s      cnf71xx;
 };
@@ -2316,6 +2466,7 @@ union cvmx_dpi_req_err_rst {
 	struct cvmx_dpi_req_err_rst_s         cn68xxp1;
 	struct cvmx_dpi_req_err_rst_s         cn70xx;
 	struct cvmx_dpi_req_err_rst_s         cn70xxp1;
+	struct cvmx_dpi_req_err_rst_s         cn73xx;
 	struct cvmx_dpi_req_err_rst_s         cn78xx;
 	struct cvmx_dpi_req_err_rst_s         cnf71xx;
 };
@@ -2346,6 +2497,7 @@ union cvmx_dpi_req_err_rst_en {
 	struct cvmx_dpi_req_err_rst_en_s      cn68xxp1;
 	struct cvmx_dpi_req_err_rst_en_s      cn70xx;
 	struct cvmx_dpi_req_err_rst_en_s      cn70xxp1;
+	struct cvmx_dpi_req_err_rst_en_s      cn73xx;
 	struct cvmx_dpi_req_err_rst_en_s      cn78xx;
 	struct cvmx_dpi_req_err_rst_en_s      cnf71xx;
 };
@@ -2389,6 +2541,7 @@ union cvmx_dpi_req_err_skip_comp {
 	struct cvmx_dpi_req_err_skip_comp_s   cn68xxp1;
 	struct cvmx_dpi_req_err_skip_comp_s   cn70xx;
 	struct cvmx_dpi_req_err_skip_comp_s   cn70xxp1;
+	struct cvmx_dpi_req_err_skip_comp_s   cn73xx;
 	struct cvmx_dpi_req_err_skip_comp_s   cn78xx;
 	struct cvmx_dpi_req_err_skip_comp_s   cnf71xx;
 };
@@ -2417,6 +2570,7 @@ union cvmx_dpi_req_gbl_en {
 	struct cvmx_dpi_req_gbl_en_s          cn68xxp1;
 	struct cvmx_dpi_req_gbl_en_s          cn70xx;
 	struct cvmx_dpi_req_gbl_en_s          cn70xxp1;
+	struct cvmx_dpi_req_gbl_en_s          cn73xx;
 	struct cvmx_dpi_req_gbl_en_s          cn78xx;
 	struct cvmx_dpi_req_gbl_en_s          cnf71xx;
 };
@@ -2467,8 +2621,8 @@ union cvmx_dpi_sli_prtx_cfg {
                                                            order to minimize the number of operations
                                                            necessary to complete the operation.
                                                            The memory region must be memory like. */
-	uint64_t reserved_14_15               : 2;
-	uint64_t molr                         : 6;  /**< Max Outstanding Load Requests
+	uint64_t reserved_15_15               : 1;
+	uint64_t molr                         : 7;  /**< Max Outstanding Load Requests
                                                          Limits the number of oustanding load requests on
                                                          the port by restricting the number of tags
                                                          used by the SLI to track load responses.  This
@@ -2525,8 +2679,8 @@ union cvmx_dpi_sli_prtx_cfg {
 	uint64_t mps                          : 1;
 	uint64_t reserved_5_6                 : 2;
 	uint64_t mps_lim                      : 1;
-	uint64_t molr                         : 6;
-	uint64_t reserved_14_15               : 2;
+	uint64_t molr                         : 7;
+	uint64_t reserved_15_15               : 1;
 	uint64_t rd_mode                      : 1;
 	uint64_t reserved_17_19               : 3;
 	uint64_t qlm_cfg                      : 4;
@@ -2826,10 +2980,12 @@ union cvmx_dpi_sli_prtx_cfg {
 #endif
 	} cn70xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn70xx   cn70xxp1;
-	struct cvmx_dpi_sli_prtx_cfg_cn78xx {
+	struct cvmx_dpi_sli_prtx_cfg_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t ncbsel                       : 1;  /**< Reserved. */
+	uint64_t ncbsel                       : 1;  /**< NCB select.
+                                                         0 = Inbound/outbound transaction will make requests and receive responses using NCB2.
+                                                         1 = Inbound/outbound transaction will make requests and receive responses using NCB3. */
 	uint64_t reserved_25_27               : 3;
 	uint64_t halt                         : 1;  /**< When set, HALT indicates that the MAC has detected a reset condition. No further
                                                          instructions that reference the MAC from any instruction queue will be issued until the
@@ -2848,11 +3004,12 @@ union cvmx_dpi_sli_prtx_cfg {
                                                          1 = Block mode. The hardware reads more data than requested in order to minimize the
                                                          number of operations necessary to complete the operation. The memory region must be memory
                                                          like. */
-	uint64_t reserved_14_15               : 2;
-	uint64_t molr                         : 6;  /**< Maximum outstanding load requests. Limits the number of outstanding load requests on the
+	uint64_t reserved_15_15               : 1;
+	uint64_t molr                         : 7;  /**< Maximum outstanding load requests. Limits the number of outstanding load requests on the
                                                          port by restricting the number of tags used by the SLI to track load responses. This value
-                                                         can range from 1 to 32. Setting MOLR to a value of 0 halts all read traffic to the port.
-                                                         There are no restrictions on when this value can be changed. */
+                                                         can range from 1 to 64 (maximum of 32 if port not configured for 8 lanes). Setting MOLR
+                                                         to a value of 0 halts all read traffic to the port. There are no restrictions on when this
+                                                         value can be changed. */
 	uint64_t mps_lim                      : 1;  /**< MAC memory space write requests cannot cross the (naturally-aligned) MPS boundary.
                                                          When clear, DPI is allowed to issue a MAC memory- space read that crosses the naturally-
                                                          aligned boundary of size defined by MPS. (DPI will still only cross the boundary when it
@@ -2884,8 +3041,8 @@ union cvmx_dpi_sli_prtx_cfg {
 	uint64_t mps                          : 1;
 	uint64_t reserved_5_6                 : 2;
 	uint64_t mps_lim                      : 1;
-	uint64_t molr                         : 6;
-	uint64_t reserved_14_15               : 2;
+	uint64_t molr                         : 7;
+	uint64_t reserved_15_15               : 1;
 	uint64_t rd_mode                      : 1;
 	uint64_t reserved_17_19               : 3;
 	uint64_t qlm_cfg                      : 1;
@@ -2895,7 +3052,8 @@ union cvmx_dpi_sli_prtx_cfg {
 	uint64_t ncbsel                       : 1;
 	uint64_t reserved_29_63               : 35;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_dpi_sli_prtx_cfg_cn73xx   cn78xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn61xx   cnf71xx;
 };
 typedef union cvmx_dpi_sli_prtx_cfg cvmx_dpi_sli_prtx_cfg_t;
@@ -2929,6 +3087,7 @@ union cvmx_dpi_sli_prtx_err {
 	struct cvmx_dpi_sli_prtx_err_s        cn68xxp1;
 	struct cvmx_dpi_sli_prtx_err_s        cn70xx;
 	struct cvmx_dpi_sli_prtx_err_s        cn70xxp1;
+	struct cvmx_dpi_sli_prtx_err_s        cn73xx;
 	struct cvmx_dpi_sli_prtx_err_s        cn78xx;
 	struct cvmx_dpi_sli_prtx_err_s        cnf71xx;
 };
@@ -2944,9 +3103,7 @@ union cvmx_dpi_sli_prtx_err_info {
 	uint64_t u64;
 	struct cvmx_dpi_sli_prtx_err_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_23_63               : 41;
-	uint64_t vf                           : 7;  /**< Virtual function that caused the ErrorResponse. */
-	uint64_t reserved_9_15                : 7;
+	uint64_t reserved_9_63                : 55;
 	uint64_t lock                         : 1;  /**< DPI_SLI_PRTx_ERR and DPI_SLI_PRTx_ERR_INFO have
                                                          captured and locked contents.
                                                          When Octeon first detects an ErrorResponse, the
@@ -2976,35 +3133,36 @@ union cvmx_dpi_sli_prtx_err_info {
 	uint64_t type                         : 1;
 	uint64_t reserved_5_7                 : 3;
 	uint64_t lock                         : 1;
-	uint64_t reserved_9_15                : 7;
-	uint64_t vf                           : 7;
-	uint64_t reserved_23_63               : 41;
+	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx {
+	struct cvmx_dpi_sli_prtx_err_info_s   cn61xx;
+	struct cvmx_dpi_sli_prtx_err_info_s   cn63xx;
+	struct cvmx_dpi_sli_prtx_err_info_s   cn63xxp1;
+	struct cvmx_dpi_sli_prtx_err_info_s   cn66xx;
+	struct cvmx_dpi_sli_prtx_err_info_s   cn68xx;
+	struct cvmx_dpi_sli_prtx_err_info_s   cn68xxp1;
+	struct cvmx_dpi_sli_prtx_err_info_s   cn70xx;
+	struct cvmx_dpi_sli_prtx_err_info_s   cn70xxp1;
+	struct cvmx_dpi_sli_prtx_err_info_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_9_63                : 55;
-	uint64_t lock                         : 1;  /**< DPI_SLI_PRTx_ERR and DPI_SLI_PRTx_ERR_INFO have
-                                                         captured and locked contents.
-                                                         When Octeon first detects an ErrorResponse, the
-                                                         TYPE, REQQ, and ADDR of the error is saved and an
-                                                         internal lock state is set so the data associated
-                                                         with the initial error is perserved.
-                                                         Subsequent ErrorResponses will optionally raise
-                                                         an interrupt, but will not modify the TYPE, REQQ,
-                                                         or ADDR fields until the internal lock state is
-                                                         cleared.
-                                                         SW can clear the internal lock state by writting
-                                                         a '1' to the appropriate bit in either
-                                                         DPI_REQ_ERR_RSP or DPI_PKT_ERR_RSP depending on
-                                                         the TYPE field.
-                                                         Once the internal lock state is cleared,
-                                                         the next ErrorResponse will set the TYPE, REQQ,
-                                                         and ADDR for the new transaction. */
+	uint64_t reserved_32_63               : 32;
+	uint64_t pvf                          : 16; /**< Physical/Virtual function that caused the ErrorResponse. */
+	uint64_t reserved_9_15                : 7;
+	uint64_t lock                         : 1;  /**< DPI_SLI_PRT()_ERR and DPI_SLI_PRT()_ERR_INFO have captured and locked contents.
+                                                         When CNXXXX first detects an ErrorResponse, the TYPE, REQQ, and ADDR of the error is saved
+                                                         and an internal lock state is set so the data associated with the initial error is
+                                                         preserved.
+                                                         Subsequent ErrorResponses will optionally raise an interrupt, but will not modify the
+                                                         TYPE, REQQ, or ADDR fields until the internal lock state is cleared.
+                                                         Software can clear the internal lock state by writing a 1 to the appropriate bit in either
+                                                         DPI_REQ_ERR_RSP or DPI_PKT_ERR_RSP depending on the TYPE field. Once the internal lock
+                                                         state is cleared, the next ErrorResponse will set the TYPE, REQQ, and ADDR for the new
+                                                         transaction. */
 	uint64_t reserved_5_7                 : 3;
 	uint64_t type                         : 1;  /**< Type of transaction that caused the ErrorResponse.
-                                                         0=DMA Instruction
-                                                         1=PKT Instruction */
+                                                         0 = DMA Instruction.
+                                                         1 = PKT Instruction. */
 	uint64_t reserved_3_3                 : 1;
 	uint64_t reqq                         : 3;  /**< Request queue that made the failed load request. */
 #else
@@ -3013,18 +3171,44 @@ union cvmx_dpi_sli_prtx_err_info {
 	uint64_t type                         : 1;
 	uint64_t reserved_5_7                 : 3;
 	uint64_t lock                         : 1;
-	uint64_t reserved_9_63                : 55;
+	uint64_t reserved_9_15                : 7;
+	uint64_t pvf                          : 16;
+	uint64_t reserved_32_63               : 32;
 #endif
-	} cn61xx;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn63xx;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn63xxp1;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn66xx;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn68xx;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn68xxp1;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn70xx;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn70xxp1;
-	struct cvmx_dpi_sli_prtx_err_info_s   cn78xx;
-	struct cvmx_dpi_sli_prtx_err_info_cn61xx cnf71xx;
+	} cn73xx;
+	struct cvmx_dpi_sli_prtx_err_info_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_23_63               : 41;
+	uint64_t vf                           : 7;  /**< Virtual function that caused the ErrorResponse. */
+	uint64_t reserved_9_15                : 7;
+	uint64_t lock                         : 1;  /**< DPI_SLI_PRT()_ERR and DPI_SLI_PRT()_ERR_INFO have captured and locked contents.
+                                                         When CNXXXX first detects an ErrorResponse, the TYPE, REQQ, and ADDR of the error is saved
+                                                         and an internal lock state is set so the data associated with the initial error is
+                                                         preserved.
+                                                         Subsequent ErrorResponses will optionally raise an interrupt, but will not modify the
+                                                         TYPE, REQQ, or ADDR fields until the internal lock state is cleared.
+                                                         Software can clear the internal lock state by writing a 1 to the appropriate bit in either
+                                                         DPI_REQ_ERR_RSP or DPI_PKT_ERR_RSP depending on the TYPE field. Once the internal lock
+                                                         state is cleared, the next ErrorResponse will set the TYPE, REQQ, and ADDR for the new
+                                                         transaction. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t type                         : 1;  /**< Type of transaction that caused the ErrorResponse.
+                                                         0 = DMA Instruction.
+                                                         1 = PKT Instruction. */
+	uint64_t reserved_3_3                 : 1;
+	uint64_t reqq                         : 3;  /**< Request queue that made the failed load request. */
+#else
+	uint64_t reqq                         : 3;
+	uint64_t reserved_3_3                 : 1;
+	uint64_t type                         : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t lock                         : 1;
+	uint64_t reserved_9_15                : 7;
+	uint64_t vf                           : 7;
+	uint64_t reserved_23_63               : 41;
+#endif
+	} cn78xx;
+	struct cvmx_dpi_sli_prtx_err_info_s   cnf71xx;
 };
 typedef union cvmx_dpi_sli_prtx_err_info cvmx_dpi_sli_prtx_err_info_t;
 
@@ -3057,6 +3241,7 @@ union cvmx_dpi_swa_q_vmid {
 	uint64_t vmid7                        : 8;
 #endif
 	} s;
+	struct cvmx_dpi_swa_q_vmid_s          cn73xx;
 	struct cvmx_dpi_swa_q_vmid_s          cn78xx;
 };
 typedef union cvmx_dpi_swa_q_vmid cvmx_dpi_swa_q_vmid_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
index fa33c6b..9c2ae8d 100644
--- a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -163,9 +163,65 @@ static inline uint64_t CVMX_DTX_ASE_SELX(unsigned long offset)
 #define CVMX_DTX_ASE_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E8000ull) + ((offset) & 1) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_BCH_BCST_RSP CVMX_DTX_BCH_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_BCH_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_DTX_BCH_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE388080ull);
+}
+#else
+#define CVMX_DTX_BCH_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE388080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_BCH_CTL CVMX_DTX_BCH_CTL_FUNC()
+static inline uint64_t CVMX_DTX_BCH_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_DTX_BCH_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE388060ull);
+}
+#else
+#define CVMX_DTX_BCH_CTL (CVMX_ADD_IO_SEG(0x00011800FE388060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BCH_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_BCH_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE388040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_BCH_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE388040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BCH_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_BCH_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE388020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_BCH_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE388020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BCH_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_BCH_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE388000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_BCH_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE388000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_BGXX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DTX_BGXX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE700080ull) + ((offset) & 7) * 32768;
@@ -177,6 +233,7 @@ static inline uint64_t CVMX_DTX_BGXX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_BGXX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DTX_BGXX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE700060ull) + ((offset) & 7) * 32768;
@@ -188,6 +245,7 @@ static inline uint64_t CVMX_DTX_BGXX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_BGXX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -199,6 +257,7 @@ static inline uint64_t CVMX_DTX_BGXX_DATX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_BGXX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -210,6 +269,7 @@ static inline uint64_t CVMX_DTX_BGXX_ENAX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -221,7 +281,7 @@ static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_BROADCAST_CTL CVMX_DTX_BROADCAST_CTL_FUNC()
 static inline uint64_t CVMX_DTX_BROADCAST_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_BROADCAST_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0060ull);
 }
@@ -233,6 +293,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BROADCAST_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0020ull) + ((offset) & 1) * 8;
@@ -245,6 +306,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BROADCAST_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0000ull) + ((offset) & 1) * 8;
@@ -256,7 +318,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_SELX(unsigned long offset)
 #define CVMX_DTX_CIU_BCST_RSP CVMX_DTX_CIU_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_CIU_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE808080ull);
 }
@@ -267,7 +329,7 @@ static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
 #define CVMX_DTX_CIU_CTL CVMX_DTX_CIU_CTL_FUNC()
 static inline uint64_t CVMX_DTX_CIU_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_CIU_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE808060ull);
 }
@@ -278,6 +340,7 @@ static inline uint64_t CVMX_DTX_CIU_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_CIU_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808040ull) + ((offset) & 1) * 8;
@@ -289,6 +352,7 @@ static inline uint64_t CVMX_DTX_CIU_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_CIU_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808020ull) + ((offset) & 1) * 8;
@@ -300,6 +364,7 @@ static inline uint64_t CVMX_DTX_CIU_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_CIU_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808000ull) + ((offset) & 1) * 8;
@@ -311,7 +376,7 @@ static inline uint64_t CVMX_DTX_CIU_SELX(unsigned long offset)
 #define CVMX_DTX_DFA_BCST_RSP CVMX_DTX_DFA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DFA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8080ull);
 }
@@ -322,7 +387,7 @@ static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_DFA_CTL CVMX_DTX_DFA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_DFA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DFA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8060ull);
 }
@@ -334,6 +399,7 @@ static inline uint64_t CVMX_DTX_DFA_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8040ull) + ((offset) & 1) * 8;
@@ -346,6 +412,7 @@ static inline uint64_t CVMX_DTX_DFA_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8020ull) + ((offset) & 1) * 8;
@@ -358,6 +425,7 @@ static inline uint64_t CVMX_DTX_DFA_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8000ull) + ((offset) & 1) * 8;
@@ -369,7 +437,7 @@ static inline uint64_t CVMX_DTX_DFA_SELX(unsigned long offset)
 #define CVMX_DTX_DPI_BCST_RSP CVMX_DTX_DPI_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DPI_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8080ull);
 }
@@ -380,7 +448,7 @@ static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
 #define CVMX_DTX_DPI_CTL CVMX_DTX_DPI_CTL_FUNC()
 static inline uint64_t CVMX_DTX_DPI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DPI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8060ull);
 }
@@ -392,6 +460,7 @@ static inline uint64_t CVMX_DTX_DPI_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8040ull) + ((offset) & 1) * 8;
@@ -404,6 +473,7 @@ static inline uint64_t CVMX_DTX_DPI_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8020ull) + ((offset) & 1) * 8;
@@ -416,6 +486,7 @@ static inline uint64_t CVMX_DTX_DPI_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8000ull) + ((offset) & 1) * 8;
@@ -432,6 +503,7 @@ static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE140080ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 			break;
 	}
@@ -446,6 +518,7 @@ static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140080ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
@@ -460,6 +533,7 @@ static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE140060ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 			break;
 	}
@@ -474,6 +548,7 @@ static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140060ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
@@ -488,6 +563,7 @@ static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE140040ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + ((offset) & 1) * 8;
 			break;
@@ -502,6 +578,7 @@ static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140040ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
@@ -516,6 +593,7 @@ static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE140020ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + ((offset) & 1) * 8;
 			break;
@@ -530,6 +608,7 @@ static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140020ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
@@ -544,6 +623,7 @@ static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE140000ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + ((offset) & 1) * 8;
 			break;
@@ -558,32 +638,33 @@ static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_DTX_GMXX_BCST_RSP(unsigned long block_id)
+static inline uint64_t CVMX_DTX_GMXX_BCST_RSP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_DTX_GMXX_BCST_RSP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE040080ull) + ((block_id) & 1) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_GMXX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE040080ull) + ((offset) & 1) * 0x40000ull;
 }
 #else
-#define CVMX_DTX_GMXX_BCST_RSP(block_id) (CVMX_ADD_IO_SEG(0x00011800FE040080ull) + ((block_id) & 1) * 0x40000ull)
+#define CVMX_DTX_GMXX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE040080ull) + ((offset) & 1) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_DTX_GMXX_CTL(unsigned long block_id)
+static inline uint64_t CVMX_DTX_GMXX_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_DTX_GMXX_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE040060ull) + ((block_id) & 1) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_GMXX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE040060ull) + ((offset) & 1) * 0x40000ull;
 }
 #else
-#define CVMX_DTX_GMXX_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800FE040060ull) + ((block_id) & 1) * 0x40000ull)
+#define CVMX_DTX_GMXX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE040060ull) + ((offset) & 1) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_GMXX_DATX(unsigned long offset, unsigned long block_id)
@@ -622,6 +703,7 @@ static inline uint64_t CVMX_DTX_GMXX_SELX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_GSERX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_DTX_GSERX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE480080ull) + ((offset) & 15) * 32768;
@@ -633,6 +715,7 @@ static inline uint64_t CVMX_DTX_GSERX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_GSERX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_DTX_GSERX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE480060ull) + ((offset) & 15) * 32768;
@@ -644,6 +727,7 @@ static inline uint64_t CVMX_DTX_GSERX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_GSERX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480040ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -655,6 +739,7 @@ static inline uint64_t CVMX_DTX_GSERX_DATX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_GSERX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480020ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -666,6 +751,7 @@ static inline uint64_t CVMX_DTX_GSERX_ENAX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480000ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -677,7 +763,7 @@ static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long b
 #define CVMX_DTX_HNA_BCST_RSP CVMX_DTX_HNA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_HNA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE238080ull);
 }
@@ -688,7 +774,7 @@ static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_HNA_CTL CVMX_DTX_HNA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_HNA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_HNA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE238060ull);
 }
@@ -699,6 +785,7 @@ static inline uint64_t CVMX_DTX_HNA_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_HNA_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238040ull) + ((offset) & 1) * 8;
@@ -710,6 +797,7 @@ static inline uint64_t CVMX_DTX_HNA_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_HNA_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238020ull) + ((offset) & 1) * 8;
@@ -721,6 +809,7 @@ static inline uint64_t CVMX_DTX_HNA_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_HNA_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238000ull) + ((offset) & 1) * 8;
@@ -842,7 +931,7 @@ static inline uint64_t CVMX_DTX_ILK_SELX(unsigned long offset)
 #define CVMX_DTX_IOBN_BCST_RSP CVMX_DTX_IOBN_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBN_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE780080ull);
 }
@@ -853,7 +942,7 @@ static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
 #define CVMX_DTX_IOBN_CTL CVMX_DTX_IOBN_CTL_FUNC()
 static inline uint64_t CVMX_DTX_IOBN_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBN_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE780060ull);
 }
@@ -864,6 +953,7 @@ static inline uint64_t CVMX_DTX_IOBN_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_IOBN_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780040ull) + ((offset) & 1) * 8;
@@ -875,6 +965,7 @@ static inline uint64_t CVMX_DTX_IOBN_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_IOBN_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780020ull) + ((offset) & 1) * 8;
@@ -886,6 +977,7 @@ static inline uint64_t CVMX_DTX_IOBN_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780000ull) + ((offset) & 1) * 8;
@@ -897,7 +989,7 @@ static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
 #define CVMX_DTX_IOBP_BCST_RSP CVMX_DTX_IOBP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0080ull);
 }
@@ -908,7 +1000,7 @@ static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_IOBP_CTL CVMX_DTX_IOBP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_IOBP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0060ull);
 }
@@ -919,6 +1011,7 @@ static inline uint64_t CVMX_DTX_IOBP_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_IOBP_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0040ull) + ((offset) & 1) * 8;
@@ -930,6 +1023,7 @@ static inline uint64_t CVMX_DTX_IOBP_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_IOBP_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0020ull) + ((offset) & 1) * 8;
@@ -941,6 +1035,7 @@ static inline uint64_t CVMX_DTX_IOBP_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_IOBP_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0000ull) + ((offset) & 1) * 8;
@@ -1118,6 +1213,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE420080ull) + ((offset) & 3) * 32768;
@@ -1130,6 +1226,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE420060ull) + ((offset) & 3) * 32768;
@@ -1142,6 +1239,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_DATX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1154,6 +1252,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_ENAX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1166,6 +1265,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_SELX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1178,6 +1278,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0080ull) + ((offset) & 3) * 32768;
@@ -1190,6 +1291,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0060ull) + ((offset) & 3) * 32768;
@@ -1202,6 +1304,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_DATX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1214,6 +1317,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_ENAX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1226,6 +1330,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_SELX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1238,6 +1343,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE240080ull) + ((offset) & 7) * 32768;
@@ -1250,6 +1356,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE240060ull) + ((offset) & 7) * 32768;
@@ -1262,6 +1369,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_DATX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1274,6 +1382,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_ENAX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1286,6 +1395,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_SELX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1352,7 +1462,7 @@ static inline uint64_t CVMX_DTX_LAPX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_LBK_BCST_RSP CVMX_DTX_LBK_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_LBK_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE090080ull);
 }
@@ -1363,7 +1473,7 @@ static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
 #define CVMX_DTX_LBK_CTL CVMX_DTX_LBK_CTL_FUNC()
 static inline uint64_t CVMX_DTX_LBK_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_LBK_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE090060ull);
 }
@@ -1374,6 +1484,7 @@ static inline uint64_t CVMX_DTX_LBK_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_LBK_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090040ull) + ((offset) & 1) * 8;
@@ -1385,6 +1496,7 @@ static inline uint64_t CVMX_DTX_LBK_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_LBK_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090020ull) + ((offset) & 1) * 8;
@@ -1396,6 +1508,7 @@ static inline uint64_t CVMX_DTX_LBK_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_LBK_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090000ull) + ((offset) & 1) * 8;
@@ -1408,6 +1521,7 @@ static inline uint64_t CVMX_DTX_LMCX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_LMCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE440080ull) + ((offset) & 3) * 32768;
@@ -1420,6 +1534,7 @@ static inline uint64_t CVMX_DTX_LMCX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_LMCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE440060ull) + ((offset) & 3) * 32768;
@@ -1432,6 +1547,7 @@ static inline uint64_t CVMX_DTX_LMCX_DATX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1444,6 +1560,7 @@ static inline uint64_t CVMX_DTX_LMCX_ENAX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1456,6 +1573,7 @@ static inline uint64_t CVMX_DTX_LMCX_SELX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1467,7 +1585,7 @@ static inline uint64_t CVMX_DTX_LMCX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_MIO_BCST_RSP CVMX_DTX_MIO_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_MIO_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE000080ull);
 }
@@ -1478,7 +1596,7 @@ static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
 #define CVMX_DTX_MIO_CTL CVMX_DTX_MIO_CTL_FUNC()
 static inline uint64_t CVMX_DTX_MIO_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_MIO_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE000060ull);
 }
@@ -1490,6 +1608,7 @@ static inline uint64_t CVMX_DTX_MIO_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000040ull) + ((offset) & 1) * 8;
@@ -1502,6 +1621,7 @@ static inline uint64_t CVMX_DTX_MIO_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000020ull) + ((offset) & 1) * 8;
@@ -1514,6 +1634,7 @@ static inline uint64_t CVMX_DTX_MIO_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000000ull) + ((offset) & 1) * 8;
@@ -1690,78 +1811,163 @@ static inline uint64_t CVMX_DTX_OCX_TOP_SELX(unsigned long offset)
 #define CVMX_DTX_OSM_BCST_RSP CVMX_DTX_OSM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_DTX_OSM_BCST_RSP not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEEE0080ull);
+			break;
+	}
+	cvmx_warn("CVMX_DTX_OSM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
 }
 #else
-#define CVMX_DTX_OSM_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE6E0080ull))
+#define CVMX_DTX_OSM_BCST_RSP CVMX_DTX_OSM_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEEE0080ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_DTX_OSM_CTL CVMX_DTX_OSM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_DTX_OSM_CTL not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEEE0060ull);
+			break;
+	}
+	cvmx_warn("CVMX_DTX_OSM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
 }
 #else
-#define CVMX_DTX_OSM_CTL (CVMX_ADD_IO_SEG(0x00011800FE6E0060ull))
+#define CVMX_DTX_OSM_CTL CVMX_DTX_OSM_CTL_FUNC()
+static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEEE0060ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_DTX_OSM_DATX(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FEEE0040ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_OSM_DATX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
 }
 #else
-#define CVMX_DTX_OSM_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8)
+static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEEE0040ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + (offset) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_DTX_OSM_ENAX(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FEEE0020ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_OSM_ENAX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
 }
 #else
-#define CVMX_DTX_OSM_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8)
+static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEEE0020ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + (offset) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_DTX_OSM_SELX(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FEEE0000ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_OSM_SELX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
 }
 #else
-#define CVMX_DTX_OSM_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8)
+static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEEE0000ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + (offset) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_DTX_PCSX_BCST_RSP(unsigned long block_id)
+static inline uint64_t CVMX_DTX_PCSX_BCST_RSP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_DTX_PCSX_BCST_RSP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE580080ull) + ((block_id) & 1) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PCSX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE580080ull) + ((offset) & 1) * 0x40000ull;
 }
 #else
-#define CVMX_DTX_PCSX_BCST_RSP(block_id) (CVMX_ADD_IO_SEG(0x00011800FE580080ull) + ((block_id) & 1) * 0x40000ull)
+#define CVMX_DTX_PCSX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE580080ull) + ((offset) & 1) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_DTX_PCSX_CTL(unsigned long block_id)
+static inline uint64_t CVMX_DTX_PCSX_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_DTX_PCSX_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE580060ull) + ((block_id) & 1) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PCSX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE580060ull) + ((offset) & 1) * 0x40000ull;
 }
 #else
-#define CVMX_DTX_PCSX_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800FE580060ull) + ((block_id) & 1) * 0x40000ull)
+#define CVMX_DTX_PCSX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE580060ull) + ((offset) & 1) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_PCSX_DATX(unsigned long offset, unsigned long block_id)
@@ -1801,6 +2007,7 @@ static inline uint64_t CVMX_DTX_PEMX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_PEMX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE600080ull) + ((offset) & 3) * 32768;
@@ -1813,6 +2020,7 @@ static inline uint64_t CVMX_DTX_PEMX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_PEMX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE600060ull) + ((offset) & 3) * 32768;
@@ -1825,6 +2033,7 @@ static inline uint64_t CVMX_DTX_PEMX_DATX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1837,6 +2046,7 @@ static inline uint64_t CVMX_DTX_PEMX_ENAX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1849,6 +2059,7 @@ static inline uint64_t CVMX_DTX_PEMX_SELX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1915,7 +2126,7 @@ static inline uint64_t CVMX_DTX_PIP_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PBE_BCST_RSP CVMX_DTX_PKI_PBE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PBE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE228080ull);
 }
@@ -1926,7 +2137,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PBE_CTL CVMX_DTX_PKI_PBE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PBE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PBE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE228060ull);
 }
@@ -1937,6 +2148,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_PKI_PBE_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228040ull) + ((offset) & 1) * 8;
@@ -1948,6 +2160,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PBE_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228020ull) + ((offset) & 1) * 8;
@@ -1959,6 +2172,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228000ull) + ((offset) & 1) * 8;
@@ -1970,7 +2184,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PFE_BCST_RSP CVMX_DTX_PKI_PFE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PFE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE220080ull);
 }
@@ -1981,7 +2195,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PFE_CTL CVMX_DTX_PKI_PFE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PFE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PFE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE220060ull);
 }
@@ -1992,6 +2206,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_PKI_PFE_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220040ull) + ((offset) & 1) * 8;
@@ -2003,6 +2218,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PFE_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220020ull) + ((offset) & 1) * 8;
@@ -2014,6 +2230,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220000ull) + ((offset) & 1) * 8;
@@ -2025,7 +2242,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PIX_BCST_RSP CVMX_DTX_PKI_PIX_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PIX_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE230080ull);
 }
@@ -2036,7 +2253,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PIX_CTL CVMX_DTX_PKI_PIX_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PIX_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PIX_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE230060ull);
 }
@@ -2047,6 +2264,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_PKI_PIX_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230040ull) + ((offset) & 1) * 8;
@@ -2058,6 +2276,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PIX_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230020ull) + ((offset) & 1) * 8;
@@ -2069,6 +2288,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PIX_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230000ull) + ((offset) & 1) * 8;
@@ -2085,6 +2305,7 @@ static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE280080ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 			break;
 	}
@@ -2099,6 +2320,7 @@ static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280080ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
@@ -2113,6 +2335,7 @@ static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE280060ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 			break;
 	}
@@ -2127,6 +2350,7 @@ static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280060ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
@@ -2141,6 +2365,7 @@ static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE280040ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + ((offset) & 1) * 8;
 			break;
@@ -2155,6 +2380,7 @@ static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280040ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
@@ -2169,6 +2395,7 @@ static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE280020ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + ((offset) & 1) * 8;
 			break;
@@ -2183,6 +2410,7 @@ static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280020ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
@@ -2197,6 +2425,7 @@ static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE280000ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + ((offset) & 1) * 8;
 			break;
@@ -2211,6 +2440,7 @@ static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
@@ -2275,7 +2505,7 @@ static inline uint64_t CVMX_DTX_POW_SELX(unsigned long offset)
 #define CVMX_DTX_RAD_BCST_RSP CVMX_DTX_RAD_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RAD_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE380080ull);
 }
@@ -2286,7 +2516,7 @@ static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RAD_CTL CVMX_DTX_RAD_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RAD_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RAD_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE380060ull);
 }
@@ -2297,6 +2527,7 @@ static inline uint64_t CVMX_DTX_RAD_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_RAD_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380040ull) + ((offset) & 1) * 8;
@@ -2308,6 +2539,7 @@ static inline uint64_t CVMX_DTX_RAD_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_RAD_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380020ull) + ((offset) & 1) * 8;
@@ -2319,6 +2551,7 @@ static inline uint64_t CVMX_DTX_RAD_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_RAD_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380000ull) + ((offset) & 1) * 8;
@@ -2330,7 +2563,7 @@ static inline uint64_t CVMX_DTX_RAD_SELX(unsigned long offset)
 #define CVMX_DTX_RNM_BCST_RSP CVMX_DTX_RNM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RNM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE200080ull);
 }
@@ -2341,7 +2574,7 @@ static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RNM_CTL CVMX_DTX_RNM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RNM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RNM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE200060ull);
 }
@@ -2352,6 +2585,7 @@ static inline uint64_t CVMX_DTX_RNM_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_RNM_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200040ull) + ((offset) & 1) * 8;
@@ -2363,6 +2597,7 @@ static inline uint64_t CVMX_DTX_RNM_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_RNM_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200020ull) + ((offset) & 1) * 8;
@@ -2374,6 +2609,7 @@ static inline uint64_t CVMX_DTX_RNM_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200000ull) + ((offset) & 1) * 8;
@@ -2385,7 +2621,7 @@ static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
 #define CVMX_DTX_RST_BCST_RSP CVMX_DTX_RST_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RST_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE030080ull);
 }
@@ -2396,7 +2632,7 @@ static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RST_CTL CVMX_DTX_RST_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RST_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RST_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE030060ull);
 }
@@ -2408,6 +2644,7 @@ static inline uint64_t CVMX_DTX_RST_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030040ull) + ((offset) & 1) * 8;
@@ -2420,6 +2657,7 @@ static inline uint64_t CVMX_DTX_RST_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030020ull) + ((offset) & 1) * 8;
@@ -2432,6 +2670,7 @@ static inline uint64_t CVMX_DTX_RST_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030000ull) + ((offset) & 1) * 8;
@@ -2443,7 +2682,7 @@ static inline uint64_t CVMX_DTX_RST_SELX(unsigned long offset)
 #define CVMX_DTX_SATA_BCST_RSP CVMX_DTX_SATA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SATA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_DTX_SATA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE360080ull);
 }
@@ -2454,7 +2693,7 @@ static inline uint64_t CVMX_DTX_SATA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SATA_CTL CVMX_DTX_SATA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SATA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_DTX_SATA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE360060ull);
 }
@@ -2465,7 +2704,8 @@ static inline uint64_t CVMX_DTX_SATA_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_SATA_DATX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SATA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE360040ull) + ((offset) & 1) * 8;
 }
@@ -2476,7 +2716,8 @@ static inline uint64_t CVMX_DTX_SATA_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_SATA_ENAX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SATA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE360020ull) + ((offset) & 1) * 8;
 }
@@ -2487,7 +2728,8 @@ static inline uint64_t CVMX_DTX_SATA_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_SATA_SELX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SATA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE360000ull) + ((offset) & 1) * 8;
 }
@@ -2498,7 +2740,7 @@ static inline uint64_t CVMX_DTX_SATA_SELX(unsigned long offset)
 #define CVMX_DTX_SLI_BCST_RSP CVMX_DTX_SLI_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SLI_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8080ull);
 }
@@ -2509,7 +2751,7 @@ static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SLI_CTL CVMX_DTX_SLI_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SLI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SLI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8060ull);
 }
@@ -2521,6 +2763,7 @@ static inline uint64_t CVMX_DTX_SLI_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8040ull) + ((offset) & 1) * 8;
@@ -2533,6 +2776,7 @@ static inline uint64_t CVMX_DTX_SLI_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8020ull) + ((offset) & 1) * 8;
@@ -2545,6 +2789,7 @@ static inline uint64_t CVMX_DTX_SLI_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8000ull) + ((offset) & 1) * 8;
@@ -2556,7 +2801,7 @@ static inline uint64_t CVMX_DTX_SLI_SELX(unsigned long offset)
 #define CVMX_DTX_SSO_BCST_RSP CVMX_DTX_SSO_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SSO_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEB38080ull);
 }
@@ -2567,7 +2812,7 @@ static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SSO_CTL CVMX_DTX_SSO_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SSO_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SSO_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEB38060ull);
 }
@@ -2578,6 +2823,7 @@ static inline uint64_t CVMX_DTX_SSO_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_SSO_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38040ull) + ((offset) & 1) * 8;
@@ -2589,6 +2835,7 @@ static inline uint64_t CVMX_DTX_SSO_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_SSO_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38020ull) + ((offset) & 1) * 8;
@@ -2600,6 +2847,7 @@ static inline uint64_t CVMX_DTX_SSO_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_SSO_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38000ull) + ((offset) & 1) * 8;
@@ -2611,7 +2859,7 @@ static inline uint64_t CVMX_DTX_SSO_SELX(unsigned long offset)
 #define CVMX_DTX_TIM_BCST_RSP CVMX_DTX_TIM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_TIM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0080ull);
 }
@@ -2622,7 +2870,7 @@ static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_TIM_CTL CVMX_DTX_TIM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_TIM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_TIM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0060ull);
 }
@@ -2634,6 +2882,7 @@ static inline uint64_t CVMX_DTX_TIM_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0040ull) + ((offset) & 1) * 8;
@@ -2646,6 +2895,7 @@ static inline uint64_t CVMX_DTX_TIM_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0020ull) + ((offset) & 1) * 8;
@@ -2658,6 +2908,7 @@ static inline uint64_t CVMX_DTX_TIM_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0000ull) + ((offset) & 1) * 8;
@@ -2669,7 +2920,8 @@ static inline uint64_t CVMX_DTX_TIM_SELX(unsigned long offset)
 static inline uint64_t CVMX_DTX_USBDRDX_BCST_RSP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_USBDRDX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768;
 }
@@ -2680,7 +2932,8 @@ static inline uint64_t CVMX_DTX_USBDRDX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_USBDRDX_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_USBDRDX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768;
 }
@@ -2691,7 +2944,8 @@ static inline uint64_t CVMX_DTX_USBDRDX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_USBDRDX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_USBDRDX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
@@ -2702,7 +2956,8 @@ static inline uint64_t CVMX_DTX_USBDRDX_DATX(unsigned long offset, unsigned long
 static inline uint64_t CVMX_DTX_USBDRDX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_USBDRDX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
@@ -2713,7 +2968,8 @@ static inline uint64_t CVMX_DTX_USBDRDX_ENAX(unsigned long offset, unsigned long
 static inline uint64_t CVMX_DTX_USBDRDX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_USBDRDX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
@@ -2721,26 +2977,26 @@ static inline uint64_t CVMX_DTX_USBDRDX_SELX(unsigned long offset, unsigned long
 #define CVMX_DTX_USBDRDX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long block_id)
+static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_DTX_USBHX_BCST_RSP(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_DTX_USBHX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE340080ull);
 }
 #else
-#define CVMX_DTX_USBHX_BCST_RSP(block_id) (CVMX_ADD_IO_SEG(0x00011800FE340080ull))
+#define CVMX_DTX_USBHX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE340080ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long block_id)
+static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_DTX_USBHX_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_DTX_USBHX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE340060ull);
 }
 #else
-#define CVMX_DTX_USBHX_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800FE340060ull))
+#define CVMX_DTX_USBHX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE340060ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBHX_DATX(unsigned long offset, unsigned long block_id)
@@ -2779,7 +3035,7 @@ static inline uint64_t CVMX_DTX_USBHX_SELX(unsigned long offset, unsigned long b
 #define CVMX_DTX_ZIP_BCST_RSP CVMX_DTX_ZIP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ZIP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0080ull);
 }
@@ -2790,7 +3046,7 @@ static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ZIP_CTL CVMX_DTX_ZIP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ZIP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ZIP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0060ull);
 }
@@ -2801,6 +3057,7 @@ static inline uint64_t CVMX_DTX_ZIP_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_ZIP_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0040ull) + ((offset) & 1) * 8;
@@ -2812,6 +3069,7 @@ static inline uint64_t CVMX_DTX_ZIP_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ZIP_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0020ull) + ((offset) & 1) * 8;
@@ -2823,6 +3081,7 @@ static inline uint64_t CVMX_DTX_ZIP_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ZIP_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0000ull) + ((offset) & 1) * 8;
@@ -3037,6 +3296,106 @@ union cvmx_dtx_ase_selx {
 typedef union cvmx_dtx_ase_selx cvmx_dtx_ase_selx_t;
 
 /**
+ * cvmx_dtx_bch_bcst_rsp
+ */
+union cvmx_dtx_bch_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_bch_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_bch_bcst_rsp_s        cn73xx;
+};
+typedef union cvmx_dtx_bch_bcst_rsp cvmx_dtx_bch_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_bch_ctl
+ */
+union cvmx_dtx_bch_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_bch_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_bch_ctl_s             cn73xx;
+};
+typedef union cvmx_dtx_bch_ctl cvmx_dtx_bch_ctl_t;
+
+/**
+ * cvmx_dtx_bch_dat#
+ */
+union cvmx_dtx_bch_datx {
+	uint64_t u64;
+	struct cvmx_dtx_bch_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_bch_datx_s            cn73xx;
+};
+typedef union cvmx_dtx_bch_datx cvmx_dtx_bch_datx_t;
+
+/**
+ * cvmx_dtx_bch_ena#
+ */
+union cvmx_dtx_bch_enax {
+	uint64_t u64;
+	struct cvmx_dtx_bch_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_bch_enax_s            cn73xx;
+};
+typedef union cvmx_dtx_bch_enax cvmx_dtx_bch_enax_t;
+
+/**
+ * cvmx_dtx_bch_sel#
+ */
+union cvmx_dtx_bch_selx {
+	uint64_t u64;
+	struct cvmx_dtx_bch_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_bch_selx_s            cn73xx;
+};
+typedef union cvmx_dtx_bch_selx cvmx_dtx_bch_selx_t;
+
+/**
  * cvmx_dtx_bgx#_bcst_rsp
  */
 union cvmx_dtx_bgxx_bcst_rsp {
@@ -3050,6 +3409,7 @@ union cvmx_dtx_bgxx_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_bgxx_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_bgxx_bcst_rsp cvmx_dtx_bgxx_bcst_rsp_t;
@@ -3076,6 +3436,7 @@ union cvmx_dtx_bgxx_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_ctl_s            cn73xx;
 	struct cvmx_dtx_bgxx_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_bgxx_ctl cvmx_dtx_bgxx_ctl_t;
@@ -3095,6 +3456,7 @@ union cvmx_dtx_bgxx_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_datx_s           cn73xx;
 	struct cvmx_dtx_bgxx_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_bgxx_datx cvmx_dtx_bgxx_datx_t;
@@ -3114,6 +3476,7 @@ union cvmx_dtx_bgxx_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_enax_s           cn73xx;
 	struct cvmx_dtx_bgxx_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_bgxx_enax cvmx_dtx_bgxx_enax_t;
@@ -3132,6 +3495,7 @@ union cvmx_dtx_bgxx_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_selx_s           cn73xx;
 	struct cvmx_dtx_bgxx_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_bgxx_selx cvmx_dtx_bgxx_selx_t;
@@ -3160,6 +3524,7 @@ union cvmx_dtx_broadcast_ctl {
 	} s;
 	struct cvmx_dtx_broadcast_ctl_s       cn70xx;
 	struct cvmx_dtx_broadcast_ctl_s       cn70xxp1;
+	struct cvmx_dtx_broadcast_ctl_s       cn73xx;
 	struct cvmx_dtx_broadcast_ctl_s       cn78xx;
 };
 typedef union cvmx_dtx_broadcast_ctl cvmx_dtx_broadcast_ctl_t;
@@ -3181,6 +3546,7 @@ union cvmx_dtx_broadcast_enax {
 	} s;
 	struct cvmx_dtx_broadcast_enax_s      cn70xx;
 	struct cvmx_dtx_broadcast_enax_s      cn70xxp1;
+	struct cvmx_dtx_broadcast_enax_s      cn73xx;
 	struct cvmx_dtx_broadcast_enax_s      cn78xx;
 };
 typedef union cvmx_dtx_broadcast_enax cvmx_dtx_broadcast_enax_t;
@@ -3201,6 +3567,7 @@ union cvmx_dtx_broadcast_selx {
 	} s;
 	struct cvmx_dtx_broadcast_selx_s      cn70xx;
 	struct cvmx_dtx_broadcast_selx_s      cn70xxp1;
+	struct cvmx_dtx_broadcast_selx_s      cn73xx;
 	struct cvmx_dtx_broadcast_selx_s      cn78xx;
 };
 typedef union cvmx_dtx_broadcast_selx cvmx_dtx_broadcast_selx_t;
@@ -3219,6 +3586,7 @@ union cvmx_dtx_ciu_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_ciu_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_ciu_bcst_rsp cvmx_dtx_ciu_bcst_rsp_t;
@@ -3245,6 +3613,7 @@ union cvmx_dtx_ciu_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_ctl_s             cn73xx;
 	struct cvmx_dtx_ciu_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_ciu_ctl cvmx_dtx_ciu_ctl_t;
@@ -3264,6 +3633,7 @@ union cvmx_dtx_ciu_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_datx_s            cn73xx;
 	struct cvmx_dtx_ciu_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_ciu_datx cvmx_dtx_ciu_datx_t;
@@ -3283,6 +3653,7 @@ union cvmx_dtx_ciu_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_enax_s            cn73xx;
 	struct cvmx_dtx_ciu_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_ciu_enax cvmx_dtx_ciu_enax_t;
@@ -3301,6 +3672,7 @@ union cvmx_dtx_ciu_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_selx_s            cn73xx;
 	struct cvmx_dtx_ciu_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_ciu_selx cvmx_dtx_ciu_selx_t;
@@ -3321,6 +3693,7 @@ union cvmx_dtx_dfa_bcst_rsp {
 	} s;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_dfa_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_dfa_bcst_rsp cvmx_dtx_dfa_bcst_rsp_t;
@@ -3349,6 +3722,7 @@ union cvmx_dtx_dfa_ctl {
 	} s;
 	struct cvmx_dtx_dfa_ctl_s             cn70xx;
 	struct cvmx_dtx_dfa_ctl_s             cn70xxp1;
+	struct cvmx_dtx_dfa_ctl_s             cn73xx;
 	struct cvmx_dtx_dfa_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_dfa_ctl cvmx_dtx_dfa_ctl_t;
@@ -3370,6 +3744,7 @@ union cvmx_dtx_dfa_datx {
 	} s;
 	struct cvmx_dtx_dfa_datx_s            cn70xx;
 	struct cvmx_dtx_dfa_datx_s            cn70xxp1;
+	struct cvmx_dtx_dfa_datx_s            cn73xx;
 	struct cvmx_dtx_dfa_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_dfa_datx cvmx_dtx_dfa_datx_t;
@@ -3391,6 +3766,7 @@ union cvmx_dtx_dfa_enax {
 	} s;
 	struct cvmx_dtx_dfa_enax_s            cn70xx;
 	struct cvmx_dtx_dfa_enax_s            cn70xxp1;
+	struct cvmx_dtx_dfa_enax_s            cn73xx;
 	struct cvmx_dtx_dfa_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_dfa_enax cvmx_dtx_dfa_enax_t;
@@ -3411,6 +3787,7 @@ union cvmx_dtx_dfa_selx {
 	} s;
 	struct cvmx_dtx_dfa_selx_s            cn70xx;
 	struct cvmx_dtx_dfa_selx_s            cn70xxp1;
+	struct cvmx_dtx_dfa_selx_s            cn73xx;
 	struct cvmx_dtx_dfa_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_dfa_selx cvmx_dtx_dfa_selx_t;
@@ -3431,6 +3808,7 @@ union cvmx_dtx_dpi_bcst_rsp {
 	} s;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_dpi_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_dpi_bcst_rsp cvmx_dtx_dpi_bcst_rsp_t;
@@ -3459,6 +3837,7 @@ union cvmx_dtx_dpi_ctl {
 	} s;
 	struct cvmx_dtx_dpi_ctl_s             cn70xx;
 	struct cvmx_dtx_dpi_ctl_s             cn70xxp1;
+	struct cvmx_dtx_dpi_ctl_s             cn73xx;
 	struct cvmx_dtx_dpi_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_dpi_ctl cvmx_dtx_dpi_ctl_t;
@@ -3480,6 +3859,7 @@ union cvmx_dtx_dpi_datx {
 	} s;
 	struct cvmx_dtx_dpi_datx_s            cn70xx;
 	struct cvmx_dtx_dpi_datx_s            cn70xxp1;
+	struct cvmx_dtx_dpi_datx_s            cn73xx;
 	struct cvmx_dtx_dpi_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_dpi_datx cvmx_dtx_dpi_datx_t;
@@ -3501,6 +3881,7 @@ union cvmx_dtx_dpi_enax {
 	} s;
 	struct cvmx_dtx_dpi_enax_s            cn70xx;
 	struct cvmx_dtx_dpi_enax_s            cn70xxp1;
+	struct cvmx_dtx_dpi_enax_s            cn73xx;
 	struct cvmx_dtx_dpi_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_dpi_enax cvmx_dtx_dpi_enax_t;
@@ -3521,6 +3902,7 @@ union cvmx_dtx_dpi_selx {
 	} s;
 	struct cvmx_dtx_dpi_selx_s            cn70xx;
 	struct cvmx_dtx_dpi_selx_s            cn70xxp1;
+	struct cvmx_dtx_dpi_selx_s            cn73xx;
 	struct cvmx_dtx_dpi_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_dpi_selx cvmx_dtx_dpi_selx_t;
@@ -3541,6 +3923,7 @@ union cvmx_dtx_fpa_bcst_rsp {
 	} s;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_fpa_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_fpa_bcst_rsp cvmx_dtx_fpa_bcst_rsp_t;
@@ -3569,6 +3952,7 @@ union cvmx_dtx_fpa_ctl {
 	} s;
 	struct cvmx_dtx_fpa_ctl_s             cn70xx;
 	struct cvmx_dtx_fpa_ctl_s             cn70xxp1;
+	struct cvmx_dtx_fpa_ctl_s             cn73xx;
 	struct cvmx_dtx_fpa_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_fpa_ctl cvmx_dtx_fpa_ctl_t;
@@ -3590,6 +3974,7 @@ union cvmx_dtx_fpa_datx {
 	} s;
 	struct cvmx_dtx_fpa_datx_s            cn70xx;
 	struct cvmx_dtx_fpa_datx_s            cn70xxp1;
+	struct cvmx_dtx_fpa_datx_s            cn73xx;
 	struct cvmx_dtx_fpa_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_fpa_datx cvmx_dtx_fpa_datx_t;
@@ -3611,6 +3996,7 @@ union cvmx_dtx_fpa_enax {
 	} s;
 	struct cvmx_dtx_fpa_enax_s            cn70xx;
 	struct cvmx_dtx_fpa_enax_s            cn70xxp1;
+	struct cvmx_dtx_fpa_enax_s            cn73xx;
 	struct cvmx_dtx_fpa_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_fpa_enax cvmx_dtx_fpa_enax_t;
@@ -3631,6 +4017,7 @@ union cvmx_dtx_fpa_selx {
 	} s;
 	struct cvmx_dtx_fpa_selx_s            cn70xx;
 	struct cvmx_dtx_fpa_selx_s            cn70xxp1;
+	struct cvmx_dtx_fpa_selx_s            cn73xx;
 	struct cvmx_dtx_fpa_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_fpa_selx cvmx_dtx_fpa_selx_t;
@@ -3754,6 +4141,7 @@ union cvmx_dtx_gserx_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_bcst_rsp_s      cn73xx;
 	struct cvmx_dtx_gserx_bcst_rsp_s      cn78xx;
 };
 typedef union cvmx_dtx_gserx_bcst_rsp cvmx_dtx_gserx_bcst_rsp_t;
@@ -3780,6 +4168,7 @@ union cvmx_dtx_gserx_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_ctl_s           cn73xx;
 	struct cvmx_dtx_gserx_ctl_s           cn78xx;
 };
 typedef union cvmx_dtx_gserx_ctl cvmx_dtx_gserx_ctl_t;
@@ -3799,6 +4188,7 @@ union cvmx_dtx_gserx_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_datx_s          cn73xx;
 	struct cvmx_dtx_gserx_datx_s          cn78xx;
 };
 typedef union cvmx_dtx_gserx_datx cvmx_dtx_gserx_datx_t;
@@ -3818,6 +4208,7 @@ union cvmx_dtx_gserx_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_enax_s          cn73xx;
 	struct cvmx_dtx_gserx_enax_s          cn78xx;
 };
 typedef union cvmx_dtx_gserx_enax cvmx_dtx_gserx_enax_t;
@@ -3836,6 +4227,7 @@ union cvmx_dtx_gserx_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_selx_s          cn73xx;
 	struct cvmx_dtx_gserx_selx_s          cn78xx;
 };
 typedef union cvmx_dtx_gserx_selx cvmx_dtx_gserx_selx_t;
@@ -3854,6 +4246,7 @@ union cvmx_dtx_hna_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_hna_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_hna_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_hna_bcst_rsp cvmx_dtx_hna_bcst_rsp_t;
@@ -3880,6 +4273,7 @@ union cvmx_dtx_hna_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_hna_ctl_s             cn73xx;
 	struct cvmx_dtx_hna_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_hna_ctl cvmx_dtx_hna_ctl_t;
@@ -3899,6 +4293,7 @@ union cvmx_dtx_hna_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_hna_datx_s            cn73xx;
 	struct cvmx_dtx_hna_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_hna_datx cvmx_dtx_hna_datx_t;
@@ -3918,6 +4313,7 @@ union cvmx_dtx_hna_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_hna_enax_s            cn73xx;
 	struct cvmx_dtx_hna_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_hna_enax cvmx_dtx_hna_enax_t;
@@ -3936,6 +4332,7 @@ union cvmx_dtx_hna_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_hna_selx_s            cn73xx;
 	struct cvmx_dtx_hna_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_hna_selx cvmx_dtx_hna_selx_t;
@@ -4259,6 +4656,7 @@ union cvmx_dtx_iobn_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_iobn_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_iobn_bcst_rsp cvmx_dtx_iobn_bcst_rsp_t;
@@ -4285,6 +4683,7 @@ union cvmx_dtx_iobn_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_ctl_s            cn73xx;
 	struct cvmx_dtx_iobn_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_iobn_ctl cvmx_dtx_iobn_ctl_t;
@@ -4304,6 +4703,7 @@ union cvmx_dtx_iobn_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_datx_s           cn73xx;
 	struct cvmx_dtx_iobn_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_iobn_datx cvmx_dtx_iobn_datx_t;
@@ -4323,6 +4723,7 @@ union cvmx_dtx_iobn_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_enax_s           cn73xx;
 	struct cvmx_dtx_iobn_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_iobn_enax cvmx_dtx_iobn_enax_t;
@@ -4341,6 +4742,7 @@ union cvmx_dtx_iobn_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_selx_s           cn73xx;
 	struct cvmx_dtx_iobn_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_iobn_selx cvmx_dtx_iobn_selx_t;
@@ -4359,6 +4761,7 @@ union cvmx_dtx_iobp_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_iobp_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_iobp_bcst_rsp cvmx_dtx_iobp_bcst_rsp_t;
@@ -4385,6 +4788,7 @@ union cvmx_dtx_iobp_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_ctl_s            cn73xx;
 	struct cvmx_dtx_iobp_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_iobp_ctl cvmx_dtx_iobp_ctl_t;
@@ -4404,6 +4808,7 @@ union cvmx_dtx_iobp_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_datx_s           cn73xx;
 	struct cvmx_dtx_iobp_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_iobp_datx cvmx_dtx_iobp_datx_t;
@@ -4423,6 +4828,7 @@ union cvmx_dtx_iobp_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_enax_s           cn73xx;
 	struct cvmx_dtx_iobp_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_iobp_enax cvmx_dtx_iobp_enax_t;
@@ -4441,6 +4847,7 @@ union cvmx_dtx_iobp_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_selx_s           cn73xx;
 	struct cvmx_dtx_iobp_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_iobp_selx cvmx_dtx_iobp_selx_t;
@@ -4671,6 +5078,7 @@ union cvmx_dtx_l2c_cbcx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn73xx;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_bcst_rsp cvmx_dtx_l2c_cbcx_bcst_rsp_t;
@@ -4699,6 +5107,7 @@ union cvmx_dtx_l2c_cbcx_ctl {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_ctl_s        cn73xx;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_ctl cvmx_dtx_l2c_cbcx_ctl_t;
@@ -4720,6 +5129,7 @@ union cvmx_dtx_l2c_cbcx_datx {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_datx_s       cn73xx;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_datx cvmx_dtx_l2c_cbcx_datx_t;
@@ -4741,6 +5151,7 @@ union cvmx_dtx_l2c_cbcx_enax {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_enax_s       cn73xx;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_enax cvmx_dtx_l2c_cbcx_enax_t;
@@ -4761,6 +5172,7 @@ union cvmx_dtx_l2c_cbcx_selx {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_selx_s       cn73xx;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_selx cvmx_dtx_l2c_cbcx_selx_t;
@@ -4781,6 +5193,7 @@ union cvmx_dtx_l2c_mcix_bcst_rsp {
 	} s;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn73xx;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_bcst_rsp cvmx_dtx_l2c_mcix_bcst_rsp_t;
@@ -4809,6 +5222,7 @@ union cvmx_dtx_l2c_mcix_ctl {
 	} s;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_ctl_s        cn73xx;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_ctl cvmx_dtx_l2c_mcix_ctl_t;
@@ -4830,6 +5244,7 @@ union cvmx_dtx_l2c_mcix_datx {
 	} s;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_datx_s       cn73xx;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_datx cvmx_dtx_l2c_mcix_datx_t;
@@ -4851,6 +5266,7 @@ union cvmx_dtx_l2c_mcix_enax {
 	} s;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_enax_s       cn73xx;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_enax cvmx_dtx_l2c_mcix_enax_t;
@@ -4871,6 +5287,7 @@ union cvmx_dtx_l2c_mcix_selx {
 	} s;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_selx_s       cn73xx;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_selx cvmx_dtx_l2c_mcix_selx_t;
@@ -4891,6 +5308,7 @@ union cvmx_dtx_l2c_tadx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn73xx;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_bcst_rsp cvmx_dtx_l2c_tadx_bcst_rsp_t;
@@ -4919,6 +5337,7 @@ union cvmx_dtx_l2c_tadx_ctl {
 	} s;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_ctl_s        cn73xx;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_ctl cvmx_dtx_l2c_tadx_ctl_t;
@@ -4940,6 +5359,7 @@ union cvmx_dtx_l2c_tadx_datx {
 	} s;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_datx_s       cn73xx;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_datx cvmx_dtx_l2c_tadx_datx_t;
@@ -4961,6 +5381,7 @@ union cvmx_dtx_l2c_tadx_enax {
 	} s;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_enax_s       cn73xx;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_enax cvmx_dtx_l2c_tadx_enax_t;
@@ -4981,6 +5402,7 @@ union cvmx_dtx_l2c_tadx_selx {
 	} s;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_selx_s       cn73xx;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_selx cvmx_dtx_l2c_tadx_selx_t;
@@ -5099,6 +5521,7 @@ union cvmx_dtx_lbk_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_lbk_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_lbk_bcst_rsp cvmx_dtx_lbk_bcst_rsp_t;
@@ -5125,6 +5548,7 @@ union cvmx_dtx_lbk_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_ctl_s             cn73xx;
 	struct cvmx_dtx_lbk_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_lbk_ctl cvmx_dtx_lbk_ctl_t;
@@ -5144,6 +5568,7 @@ union cvmx_dtx_lbk_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_datx_s            cn73xx;
 	struct cvmx_dtx_lbk_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_lbk_datx cvmx_dtx_lbk_datx_t;
@@ -5163,6 +5588,7 @@ union cvmx_dtx_lbk_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_enax_s            cn73xx;
 	struct cvmx_dtx_lbk_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_lbk_enax cvmx_dtx_lbk_enax_t;
@@ -5181,6 +5607,7 @@ union cvmx_dtx_lbk_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_selx_s            cn73xx;
 	struct cvmx_dtx_lbk_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_lbk_selx cvmx_dtx_lbk_selx_t;
@@ -5201,6 +5628,7 @@ union cvmx_dtx_lmcx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn70xx;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn70xxp1;
+	struct cvmx_dtx_lmcx_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_lmcx_bcst_rsp cvmx_dtx_lmcx_bcst_rsp_t;
@@ -5229,6 +5657,7 @@ union cvmx_dtx_lmcx_ctl {
 	} s;
 	struct cvmx_dtx_lmcx_ctl_s            cn70xx;
 	struct cvmx_dtx_lmcx_ctl_s            cn70xxp1;
+	struct cvmx_dtx_lmcx_ctl_s            cn73xx;
 	struct cvmx_dtx_lmcx_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_lmcx_ctl cvmx_dtx_lmcx_ctl_t;
@@ -5250,6 +5679,7 @@ union cvmx_dtx_lmcx_datx {
 	} s;
 	struct cvmx_dtx_lmcx_datx_s           cn70xx;
 	struct cvmx_dtx_lmcx_datx_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_datx_s           cn73xx;
 	struct cvmx_dtx_lmcx_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_lmcx_datx cvmx_dtx_lmcx_datx_t;
@@ -5271,6 +5701,7 @@ union cvmx_dtx_lmcx_enax {
 	} s;
 	struct cvmx_dtx_lmcx_enax_s           cn70xx;
 	struct cvmx_dtx_lmcx_enax_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_enax_s           cn73xx;
 	struct cvmx_dtx_lmcx_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_lmcx_enax cvmx_dtx_lmcx_enax_t;
@@ -5291,6 +5722,7 @@ union cvmx_dtx_lmcx_selx {
 	} s;
 	struct cvmx_dtx_lmcx_selx_s           cn70xx;
 	struct cvmx_dtx_lmcx_selx_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_selx_s           cn73xx;
 	struct cvmx_dtx_lmcx_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_lmcx_selx cvmx_dtx_lmcx_selx_t;
@@ -5311,6 +5743,7 @@ union cvmx_dtx_mio_bcst_rsp {
 	} s;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_mio_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_mio_bcst_rsp cvmx_dtx_mio_bcst_rsp_t;
@@ -5339,6 +5772,7 @@ union cvmx_dtx_mio_ctl {
 	} s;
 	struct cvmx_dtx_mio_ctl_s             cn70xx;
 	struct cvmx_dtx_mio_ctl_s             cn70xxp1;
+	struct cvmx_dtx_mio_ctl_s             cn73xx;
 	struct cvmx_dtx_mio_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_mio_ctl cvmx_dtx_mio_ctl_t;
@@ -5360,6 +5794,7 @@ union cvmx_dtx_mio_datx {
 	} s;
 	struct cvmx_dtx_mio_datx_s            cn70xx;
 	struct cvmx_dtx_mio_datx_s            cn70xxp1;
+	struct cvmx_dtx_mio_datx_s            cn73xx;
 	struct cvmx_dtx_mio_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_mio_datx cvmx_dtx_mio_datx_t;
@@ -5381,6 +5816,7 @@ union cvmx_dtx_mio_enax {
 	} s;
 	struct cvmx_dtx_mio_enax_s            cn70xx;
 	struct cvmx_dtx_mio_enax_s            cn70xxp1;
+	struct cvmx_dtx_mio_enax_s            cn73xx;
 	struct cvmx_dtx_mio_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_mio_enax cvmx_dtx_mio_enax_t;
@@ -5401,6 +5837,7 @@ union cvmx_dtx_mio_selx {
 	} s;
 	struct cvmx_dtx_mio_selx_s            cn70xx;
 	struct cvmx_dtx_mio_selx_s            cn70xxp1;
+	struct cvmx_dtx_mio_selx_s            cn73xx;
 	struct cvmx_dtx_mio_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_mio_selx cvmx_dtx_mio_selx_t;
@@ -5719,6 +6156,7 @@ union cvmx_dtx_osm_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_osm_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_osm_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_osm_bcst_rsp cvmx_dtx_osm_bcst_rsp_t;
@@ -5745,6 +6183,7 @@ union cvmx_dtx_osm_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_osm_ctl_s             cn73xx;
 	struct cvmx_dtx_osm_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_osm_ctl cvmx_dtx_osm_ctl_t;
@@ -5764,6 +6203,7 @@ union cvmx_dtx_osm_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_osm_datx_s            cn73xx;
 	struct cvmx_dtx_osm_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_osm_datx cvmx_dtx_osm_datx_t;
@@ -5783,6 +6223,7 @@ union cvmx_dtx_osm_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_osm_enax_s            cn73xx;
 	struct cvmx_dtx_osm_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_osm_enax cvmx_dtx_osm_enax_t;
@@ -5801,6 +6242,7 @@ union cvmx_dtx_osm_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_osm_selx_s            cn73xx;
 	struct cvmx_dtx_osm_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_osm_selx cvmx_dtx_osm_selx_t;
@@ -5926,6 +6368,7 @@ union cvmx_dtx_pemx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn70xx;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn70xxp1;
+	struct cvmx_dtx_pemx_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_pemx_bcst_rsp cvmx_dtx_pemx_bcst_rsp_t;
@@ -5954,6 +6397,7 @@ union cvmx_dtx_pemx_ctl {
 	} s;
 	struct cvmx_dtx_pemx_ctl_s            cn70xx;
 	struct cvmx_dtx_pemx_ctl_s            cn70xxp1;
+	struct cvmx_dtx_pemx_ctl_s            cn73xx;
 	struct cvmx_dtx_pemx_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_pemx_ctl cvmx_dtx_pemx_ctl_t;
@@ -5975,6 +6419,7 @@ union cvmx_dtx_pemx_datx {
 	} s;
 	struct cvmx_dtx_pemx_datx_s           cn70xx;
 	struct cvmx_dtx_pemx_datx_s           cn70xxp1;
+	struct cvmx_dtx_pemx_datx_s           cn73xx;
 	struct cvmx_dtx_pemx_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_pemx_datx cvmx_dtx_pemx_datx_t;
@@ -5996,6 +6441,7 @@ union cvmx_dtx_pemx_enax {
 	} s;
 	struct cvmx_dtx_pemx_enax_s           cn70xx;
 	struct cvmx_dtx_pemx_enax_s           cn70xxp1;
+	struct cvmx_dtx_pemx_enax_s           cn73xx;
 	struct cvmx_dtx_pemx_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_pemx_enax cvmx_dtx_pemx_enax_t;
@@ -6016,6 +6462,7 @@ union cvmx_dtx_pemx_selx {
 	} s;
 	struct cvmx_dtx_pemx_selx_s           cn70xx;
 	struct cvmx_dtx_pemx_selx_s           cn70xxp1;
+	struct cvmx_dtx_pemx_selx_s           cn73xx;
 	struct cvmx_dtx_pemx_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_pemx_selx cvmx_dtx_pemx_selx_t;
@@ -6139,6 +6586,7 @@ union cvmx_dtx_pki_pbe_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn73xx;
 	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_bcst_rsp cvmx_dtx_pki_pbe_bcst_rsp_t;
@@ -6165,6 +6613,7 @@ union cvmx_dtx_pki_pbe_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_ctl_s         cn73xx;
 	struct cvmx_dtx_pki_pbe_ctl_s         cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_ctl cvmx_dtx_pki_pbe_ctl_t;
@@ -6184,6 +6633,7 @@ union cvmx_dtx_pki_pbe_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_datx_s        cn73xx;
 	struct cvmx_dtx_pki_pbe_datx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_datx cvmx_dtx_pki_pbe_datx_t;
@@ -6203,6 +6653,7 @@ union cvmx_dtx_pki_pbe_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_enax_s        cn73xx;
 	struct cvmx_dtx_pki_pbe_enax_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_enax cvmx_dtx_pki_pbe_enax_t;
@@ -6221,6 +6672,7 @@ union cvmx_dtx_pki_pbe_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_selx_s        cn73xx;
 	struct cvmx_dtx_pki_pbe_selx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_selx cvmx_dtx_pki_pbe_selx_t;
@@ -6239,6 +6691,7 @@ union cvmx_dtx_pki_pfe_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn73xx;
 	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_bcst_rsp cvmx_dtx_pki_pfe_bcst_rsp_t;
@@ -6265,6 +6718,7 @@ union cvmx_dtx_pki_pfe_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_ctl_s         cn73xx;
 	struct cvmx_dtx_pki_pfe_ctl_s         cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_ctl cvmx_dtx_pki_pfe_ctl_t;
@@ -6284,6 +6738,7 @@ union cvmx_dtx_pki_pfe_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_datx_s        cn73xx;
 	struct cvmx_dtx_pki_pfe_datx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_datx cvmx_dtx_pki_pfe_datx_t;
@@ -6303,6 +6758,7 @@ union cvmx_dtx_pki_pfe_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_enax_s        cn73xx;
 	struct cvmx_dtx_pki_pfe_enax_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_enax cvmx_dtx_pki_pfe_enax_t;
@@ -6321,6 +6777,7 @@ union cvmx_dtx_pki_pfe_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_selx_s        cn73xx;
 	struct cvmx_dtx_pki_pfe_selx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_selx cvmx_dtx_pki_pfe_selx_t;
@@ -6339,6 +6796,7 @@ union cvmx_dtx_pki_pix_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn73xx;
 	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_bcst_rsp cvmx_dtx_pki_pix_bcst_rsp_t;
@@ -6365,6 +6823,7 @@ union cvmx_dtx_pki_pix_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_ctl_s         cn73xx;
 	struct cvmx_dtx_pki_pix_ctl_s         cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_ctl cvmx_dtx_pki_pix_ctl_t;
@@ -6384,6 +6843,7 @@ union cvmx_dtx_pki_pix_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_datx_s        cn73xx;
 	struct cvmx_dtx_pki_pix_datx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_datx cvmx_dtx_pki_pix_datx_t;
@@ -6403,6 +6863,7 @@ union cvmx_dtx_pki_pix_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_enax_s        cn73xx;
 	struct cvmx_dtx_pki_pix_enax_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_enax cvmx_dtx_pki_pix_enax_t;
@@ -6421,6 +6882,7 @@ union cvmx_dtx_pki_pix_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_selx_s        cn73xx;
 	struct cvmx_dtx_pki_pix_selx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_selx cvmx_dtx_pki_pix_selx_t;
@@ -6441,6 +6903,7 @@ union cvmx_dtx_pko_bcst_rsp {
 	} s;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_pko_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_pko_bcst_rsp cvmx_dtx_pko_bcst_rsp_t;
@@ -6469,6 +6932,7 @@ union cvmx_dtx_pko_ctl {
 	} s;
 	struct cvmx_dtx_pko_ctl_s             cn70xx;
 	struct cvmx_dtx_pko_ctl_s             cn70xxp1;
+	struct cvmx_dtx_pko_ctl_s             cn73xx;
 	struct cvmx_dtx_pko_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_pko_ctl cvmx_dtx_pko_ctl_t;
@@ -6490,6 +6954,7 @@ union cvmx_dtx_pko_datx {
 	} s;
 	struct cvmx_dtx_pko_datx_s            cn70xx;
 	struct cvmx_dtx_pko_datx_s            cn70xxp1;
+	struct cvmx_dtx_pko_datx_s            cn73xx;
 	struct cvmx_dtx_pko_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_pko_datx cvmx_dtx_pko_datx_t;
@@ -6511,6 +6976,7 @@ union cvmx_dtx_pko_enax {
 	} s;
 	struct cvmx_dtx_pko_enax_s            cn70xx;
 	struct cvmx_dtx_pko_enax_s            cn70xxp1;
+	struct cvmx_dtx_pko_enax_s            cn73xx;
 	struct cvmx_dtx_pko_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_pko_enax cvmx_dtx_pko_enax_t;
@@ -6531,6 +6997,7 @@ union cvmx_dtx_pko_selx {
 	} s;
 	struct cvmx_dtx_pko_selx_s            cn70xx;
 	struct cvmx_dtx_pko_selx_s            cn70xxp1;
+	struct cvmx_dtx_pko_selx_s            cn73xx;
 	struct cvmx_dtx_pko_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_pko_selx cvmx_dtx_pko_selx_t;
@@ -6654,6 +7121,7 @@ union cvmx_dtx_rad_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_rad_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_rad_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_rad_bcst_rsp cvmx_dtx_rad_bcst_rsp_t;
@@ -6680,6 +7148,7 @@ union cvmx_dtx_rad_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_rad_ctl_s             cn73xx;
 	struct cvmx_dtx_rad_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_rad_ctl cvmx_dtx_rad_ctl_t;
@@ -6699,6 +7168,7 @@ union cvmx_dtx_rad_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_rad_datx_s            cn73xx;
 	struct cvmx_dtx_rad_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_rad_datx cvmx_dtx_rad_datx_t;
@@ -6718,6 +7188,7 @@ union cvmx_dtx_rad_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_rad_enax_s            cn73xx;
 	struct cvmx_dtx_rad_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_rad_enax cvmx_dtx_rad_enax_t;
@@ -6736,6 +7207,7 @@ union cvmx_dtx_rad_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_rad_selx_s            cn73xx;
 	struct cvmx_dtx_rad_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_rad_selx cvmx_dtx_rad_selx_t;
@@ -6754,6 +7226,7 @@ union cvmx_dtx_rnm_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_rnm_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_rnm_bcst_rsp cvmx_dtx_rnm_bcst_rsp_t;
@@ -6780,6 +7253,7 @@ union cvmx_dtx_rnm_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_ctl_s             cn73xx;
 	struct cvmx_dtx_rnm_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_rnm_ctl cvmx_dtx_rnm_ctl_t;
@@ -6799,6 +7273,7 @@ union cvmx_dtx_rnm_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_datx_s            cn73xx;
 	struct cvmx_dtx_rnm_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_rnm_datx cvmx_dtx_rnm_datx_t;
@@ -6818,6 +7293,7 @@ union cvmx_dtx_rnm_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_enax_s            cn73xx;
 	struct cvmx_dtx_rnm_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_rnm_enax cvmx_dtx_rnm_enax_t;
@@ -6836,6 +7312,7 @@ union cvmx_dtx_rnm_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_selx_s            cn73xx;
 	struct cvmx_dtx_rnm_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_rnm_selx cvmx_dtx_rnm_selx_t;
@@ -6856,6 +7333,7 @@ union cvmx_dtx_rst_bcst_rsp {
 	} s;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_rst_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_rst_bcst_rsp cvmx_dtx_rst_bcst_rsp_t;
@@ -6884,6 +7362,7 @@ union cvmx_dtx_rst_ctl {
 	} s;
 	struct cvmx_dtx_rst_ctl_s             cn70xx;
 	struct cvmx_dtx_rst_ctl_s             cn70xxp1;
+	struct cvmx_dtx_rst_ctl_s             cn73xx;
 	struct cvmx_dtx_rst_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_rst_ctl cvmx_dtx_rst_ctl_t;
@@ -6905,6 +7384,7 @@ union cvmx_dtx_rst_datx {
 	} s;
 	struct cvmx_dtx_rst_datx_s            cn70xx;
 	struct cvmx_dtx_rst_datx_s            cn70xxp1;
+	struct cvmx_dtx_rst_datx_s            cn73xx;
 	struct cvmx_dtx_rst_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_rst_datx cvmx_dtx_rst_datx_t;
@@ -6926,6 +7406,7 @@ union cvmx_dtx_rst_enax {
 	} s;
 	struct cvmx_dtx_rst_enax_s            cn70xx;
 	struct cvmx_dtx_rst_enax_s            cn70xxp1;
+	struct cvmx_dtx_rst_enax_s            cn73xx;
 	struct cvmx_dtx_rst_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_rst_enax cvmx_dtx_rst_enax_t;
@@ -6946,6 +7427,7 @@ union cvmx_dtx_rst_selx {
 	} s;
 	struct cvmx_dtx_rst_selx_s            cn70xx;
 	struct cvmx_dtx_rst_selx_s            cn70xxp1;
+	struct cvmx_dtx_rst_selx_s            cn73xx;
 	struct cvmx_dtx_rst_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_rst_selx cvmx_dtx_rst_selx_t;
@@ -6966,6 +7448,7 @@ union cvmx_dtx_sata_bcst_rsp {
 	} s;
 	struct cvmx_dtx_sata_bcst_rsp_s       cn70xx;
 	struct cvmx_dtx_sata_bcst_rsp_s       cn70xxp1;
+	struct cvmx_dtx_sata_bcst_rsp_s       cn73xx;
 };
 typedef union cvmx_dtx_sata_bcst_rsp cvmx_dtx_sata_bcst_rsp_t;
 
@@ -6993,6 +7476,7 @@ union cvmx_dtx_sata_ctl {
 	} s;
 	struct cvmx_dtx_sata_ctl_s            cn70xx;
 	struct cvmx_dtx_sata_ctl_s            cn70xxp1;
+	struct cvmx_dtx_sata_ctl_s            cn73xx;
 };
 typedef union cvmx_dtx_sata_ctl cvmx_dtx_sata_ctl_t;
 
@@ -7013,6 +7497,7 @@ union cvmx_dtx_sata_datx {
 	} s;
 	struct cvmx_dtx_sata_datx_s           cn70xx;
 	struct cvmx_dtx_sata_datx_s           cn70xxp1;
+	struct cvmx_dtx_sata_datx_s           cn73xx;
 };
 typedef union cvmx_dtx_sata_datx cvmx_dtx_sata_datx_t;
 
@@ -7033,6 +7518,7 @@ union cvmx_dtx_sata_enax {
 	} s;
 	struct cvmx_dtx_sata_enax_s           cn70xx;
 	struct cvmx_dtx_sata_enax_s           cn70xxp1;
+	struct cvmx_dtx_sata_enax_s           cn73xx;
 };
 typedef union cvmx_dtx_sata_enax cvmx_dtx_sata_enax_t;
 
@@ -7052,6 +7538,7 @@ union cvmx_dtx_sata_selx {
 	} s;
 	struct cvmx_dtx_sata_selx_s           cn70xx;
 	struct cvmx_dtx_sata_selx_s           cn70xxp1;
+	struct cvmx_dtx_sata_selx_s           cn73xx;
 };
 typedef union cvmx_dtx_sata_selx cvmx_dtx_sata_selx_t;
 
@@ -7071,6 +7558,7 @@ union cvmx_dtx_sli_bcst_rsp {
 	} s;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_sli_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_sli_bcst_rsp cvmx_dtx_sli_bcst_rsp_t;
@@ -7099,6 +7587,7 @@ union cvmx_dtx_sli_ctl {
 	} s;
 	struct cvmx_dtx_sli_ctl_s             cn70xx;
 	struct cvmx_dtx_sli_ctl_s             cn70xxp1;
+	struct cvmx_dtx_sli_ctl_s             cn73xx;
 	struct cvmx_dtx_sli_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_sli_ctl cvmx_dtx_sli_ctl_t;
@@ -7120,6 +7609,7 @@ union cvmx_dtx_sli_datx {
 	} s;
 	struct cvmx_dtx_sli_datx_s            cn70xx;
 	struct cvmx_dtx_sli_datx_s            cn70xxp1;
+	struct cvmx_dtx_sli_datx_s            cn73xx;
 	struct cvmx_dtx_sli_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_sli_datx cvmx_dtx_sli_datx_t;
@@ -7141,6 +7631,7 @@ union cvmx_dtx_sli_enax {
 	} s;
 	struct cvmx_dtx_sli_enax_s            cn70xx;
 	struct cvmx_dtx_sli_enax_s            cn70xxp1;
+	struct cvmx_dtx_sli_enax_s            cn73xx;
 	struct cvmx_dtx_sli_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_sli_enax cvmx_dtx_sli_enax_t;
@@ -7161,6 +7652,7 @@ union cvmx_dtx_sli_selx {
 	} s;
 	struct cvmx_dtx_sli_selx_s            cn70xx;
 	struct cvmx_dtx_sli_selx_s            cn70xxp1;
+	struct cvmx_dtx_sli_selx_s            cn73xx;
 	struct cvmx_dtx_sli_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_sli_selx cvmx_dtx_sli_selx_t;
@@ -7179,6 +7671,7 @@ union cvmx_dtx_sso_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_sso_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_sso_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_sso_bcst_rsp cvmx_dtx_sso_bcst_rsp_t;
@@ -7205,6 +7698,7 @@ union cvmx_dtx_sso_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_sso_ctl_s             cn73xx;
 	struct cvmx_dtx_sso_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_sso_ctl cvmx_dtx_sso_ctl_t;
@@ -7224,6 +7718,7 @@ union cvmx_dtx_sso_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_sso_datx_s            cn73xx;
 	struct cvmx_dtx_sso_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_sso_datx cvmx_dtx_sso_datx_t;
@@ -7243,6 +7738,7 @@ union cvmx_dtx_sso_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_sso_enax_s            cn73xx;
 	struct cvmx_dtx_sso_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_sso_enax cvmx_dtx_sso_enax_t;
@@ -7261,6 +7757,7 @@ union cvmx_dtx_sso_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_sso_selx_s            cn73xx;
 	struct cvmx_dtx_sso_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_sso_selx cvmx_dtx_sso_selx_t;
@@ -7281,6 +7778,7 @@ union cvmx_dtx_tim_bcst_rsp {
 	} s;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_tim_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_tim_bcst_rsp cvmx_dtx_tim_bcst_rsp_t;
@@ -7309,6 +7807,7 @@ union cvmx_dtx_tim_ctl {
 	} s;
 	struct cvmx_dtx_tim_ctl_s             cn70xx;
 	struct cvmx_dtx_tim_ctl_s             cn70xxp1;
+	struct cvmx_dtx_tim_ctl_s             cn73xx;
 	struct cvmx_dtx_tim_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_tim_ctl cvmx_dtx_tim_ctl_t;
@@ -7330,6 +7829,7 @@ union cvmx_dtx_tim_datx {
 	} s;
 	struct cvmx_dtx_tim_datx_s            cn70xx;
 	struct cvmx_dtx_tim_datx_s            cn70xxp1;
+	struct cvmx_dtx_tim_datx_s            cn73xx;
 	struct cvmx_dtx_tim_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_tim_datx cvmx_dtx_tim_datx_t;
@@ -7351,6 +7851,7 @@ union cvmx_dtx_tim_enax {
 	} s;
 	struct cvmx_dtx_tim_enax_s            cn70xx;
 	struct cvmx_dtx_tim_enax_s            cn70xxp1;
+	struct cvmx_dtx_tim_enax_s            cn73xx;
 	struct cvmx_dtx_tim_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_tim_enax cvmx_dtx_tim_enax_t;
@@ -7371,6 +7872,7 @@ union cvmx_dtx_tim_selx {
 	} s;
 	struct cvmx_dtx_tim_selx_s            cn70xx;
 	struct cvmx_dtx_tim_selx_s            cn70xxp1;
+	struct cvmx_dtx_tim_selx_s            cn73xx;
 	struct cvmx_dtx_tim_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_tim_selx cvmx_dtx_tim_selx_t;
@@ -7391,6 +7893,7 @@ union cvmx_dtx_usbdrdx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn70xx;
 	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn70xxp1;
+	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_bcst_rsp cvmx_dtx_usbdrdx_bcst_rsp_t;
 
@@ -7418,6 +7921,7 @@ union cvmx_dtx_usbdrdx_ctl {
 	} s;
 	struct cvmx_dtx_usbdrdx_ctl_s         cn70xx;
 	struct cvmx_dtx_usbdrdx_ctl_s         cn70xxp1;
+	struct cvmx_dtx_usbdrdx_ctl_s         cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_ctl cvmx_dtx_usbdrdx_ctl_t;
 
@@ -7438,6 +7942,7 @@ union cvmx_dtx_usbdrdx_datx {
 	} s;
 	struct cvmx_dtx_usbdrdx_datx_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_datx_s        cn70xxp1;
+	struct cvmx_dtx_usbdrdx_datx_s        cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_datx cvmx_dtx_usbdrdx_datx_t;
 
@@ -7458,6 +7963,7 @@ union cvmx_dtx_usbdrdx_enax {
 	} s;
 	struct cvmx_dtx_usbdrdx_enax_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_enax_s        cn70xxp1;
+	struct cvmx_dtx_usbdrdx_enax_s        cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_enax cvmx_dtx_usbdrdx_enax_t;
 
@@ -7477,6 +7983,7 @@ union cvmx_dtx_usbdrdx_selx {
 	} s;
 	struct cvmx_dtx_usbdrdx_selx_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_selx_s        cn70xxp1;
+	struct cvmx_dtx_usbdrdx_selx_s        cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_selx cvmx_dtx_usbdrdx_selx_t;
 
@@ -7594,6 +8101,7 @@ union cvmx_dtx_zip_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_zip_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_zip_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_zip_bcst_rsp cvmx_dtx_zip_bcst_rsp_t;
@@ -7620,6 +8128,7 @@ union cvmx_dtx_zip_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_zip_ctl_s             cn73xx;
 	struct cvmx_dtx_zip_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_zip_ctl cvmx_dtx_zip_ctl_t;
@@ -7639,6 +8148,7 @@ union cvmx_dtx_zip_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_zip_datx_s            cn73xx;
 	struct cvmx_dtx_zip_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_zip_datx cvmx_dtx_zip_datx_t;
@@ -7658,6 +8168,7 @@ union cvmx_dtx_zip_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_zip_enax_s            cn73xx;
 	struct cvmx_dtx_zip_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_zip_enax cvmx_dtx_zip_enax_t;
@@ -7676,6 +8187,7 @@ union cvmx_dtx_zip_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_zip_selx_s            cn73xx;
 	struct cvmx_dtx_zip_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_zip_selx cvmx_dtx_zip_selx_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index a82c84f..9a203a2 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -65,6 +65,7 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001180028000458ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 			break;
 	}
@@ -83,6 +84,7 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180028000458ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000458ull);
@@ -92,6 +94,7 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 static inline uint64_t CVMX_FPA_AURAX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020100000ull) + ((offset) & 1023) * 8;
@@ -103,6 +106,7 @@ static inline uint64_t CVMX_FPA_AURAX_CFG(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020200000ull) + ((offset) & 1023) * 8;
@@ -114,6 +118,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT_ADD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_ADD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020300000ull) + ((offset) & 1023) * 8;
@@ -125,6 +130,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_ADD(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT_LEVELS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_LEVELS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020800000ull) + ((offset) & 1023) * 8;
@@ -136,6 +142,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_LEVELS(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT_LIMIT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_LIMIT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020400000ull) + ((offset) & 1023) * 8;
@@ -147,6 +154,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_LIMIT(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT_THRESHOLD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_THRESHOLD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020500000ull) + ((offset) & 1023) * 8;
@@ -158,6 +166,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_THRESHOLD(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020600000ull) + ((offset) & 1023) * 8;
@@ -169,6 +178,7 @@ static inline uint64_t CVMX_FPA_AURAX_INT(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_POOL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_POOL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020000000ull) + ((offset) & 1023) * 8;
@@ -180,6 +190,7 @@ static inline uint64_t CVMX_FPA_AURAX_POOL(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_POOL_LEVELS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_POOL_LEVELS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020700000ull) + ((offset) & 1023) * 8;
@@ -208,6 +219,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800280000E8ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 			break;
 	}
@@ -234,6 +246,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800280000E8ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800280000E8ull);
@@ -243,7 +256,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 #define CVMX_FPA_CLK_COUNT CVMX_FPA_CLK_COUNT_FUNC()
 static inline uint64_t CVMX_FPA_CLK_COUNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_CLK_COUNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00012800000000F0ull);
 }
@@ -255,7 +268,7 @@ static inline uint64_t CVMX_FPA_CLK_COUNT_FUNC(void)
 #define CVMX_FPA_ECC_CTL CVMX_FPA_ECC_CTL_FUNC()
 static inline uint64_t CVMX_FPA_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000058ull);
 }
@@ -266,7 +279,7 @@ static inline uint64_t CVMX_FPA_ECC_CTL_FUNC(void)
 #define CVMX_FPA_ECC_INT CVMX_FPA_ECC_INT_FUNC()
 static inline uint64_t CVMX_FPA_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000068ull);
 }
@@ -277,7 +290,7 @@ static inline uint64_t CVMX_FPA_ECC_INT_FUNC(void)
 #define CVMX_FPA_ERR_INT CVMX_FPA_ERR_INT_FUNC()
 static inline uint64_t CVMX_FPA_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000040ull);
 }
@@ -377,7 +390,7 @@ static inline uint64_t CVMX_FPA_FPFX_SIZE(unsigned long offset)
 #define CVMX_FPA_GEN_CFG CVMX_FPA_GEN_CFG_FUNC()
 static inline uint64_t CVMX_FPA_GEN_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_GEN_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000050ull);
 }
@@ -401,6 +414,7 @@ static inline uint64_t CVMX_FPA_PACKET_THRESHOLD_FUNC(void)
 static inline uint64_t CVMX_FPA_POOLX_AVAILABLE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_AVAILABLE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010300000ull) + ((offset) & 63) * 8;
@@ -412,6 +426,7 @@ static inline uint64_t CVMX_FPA_POOLX_AVAILABLE(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010000000ull) + ((offset) & 63) * 8;
@@ -438,6 +453,10 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 			if ((offset <= 63))
 				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 31) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_END_ADDR (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180028000358ull) + ((offset) & 7) * 8;
@@ -455,6 +474,8 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180028000358ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000358ull) + (offset) * 8;
 }
@@ -463,6 +484,7 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_FPF_MARKS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_FPF_MARKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010100000ull) + ((offset) & 63) * 8;
@@ -474,6 +496,7 @@ static inline uint64_t CVMX_FPA_POOLX_FPF_MARKS(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010A00000ull) + ((offset) & 63) * 8;
@@ -485,6 +508,7 @@ static inline uint64_t CVMX_FPA_POOLX_INT(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_OP_PC(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_OP_PC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010F00000ull) + ((offset) & 63) * 8;
@@ -496,6 +520,7 @@ static inline uint64_t CVMX_FPA_POOLX_OP_PC(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_STACK_ADDR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_ADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010900000ull) + ((offset) & 63) * 8;
@@ -507,6 +532,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_ADDR(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_STACK_BASE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_BASE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010700000ull) + ((offset) & 63) * 8;
@@ -518,6 +544,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_BASE(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_STACK_END(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_END(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010800000ull) + ((offset) & 63) * 8;
@@ -544,6 +571,10 @@ static inline uint64_t CVMX_FPA_POOLX_START_ADDR(unsigned long offset)
 			if ((offset <= 63))
 				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 31) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_START_ADDR (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180028000258ull) + ((offset) & 7) * 8;
@@ -561,6 +592,8 @@ static inline uint64_t CVMX_FPA_POOLX_START_ADDR(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180028000258ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000258ull) + (offset) * 8;
 }
@@ -585,6 +618,10 @@ static inline uint64_t CVMX_FPA_POOLX_THRESHOLD(unsigned long offset)
 			if ((offset <= 63))
 				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 31) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_THRESHOLD (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180028000140ull) + ((offset) & 7) * 8;
@@ -603,6 +640,8 @@ static inline uint64_t CVMX_FPA_POOLX_THRESHOLD(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180028000140ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000140ull) + (offset) * 8;
 }
@@ -678,7 +717,7 @@ static inline uint64_t CVMX_FPA_QUEX_PAGE_INDEX(unsigned long offset)
 #define CVMX_FPA_RD_LATENCY_PC CVMX_FPA_RD_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_FPA_RD_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RD_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000610ull);
 }
@@ -689,7 +728,7 @@ static inline uint64_t CVMX_FPA_RD_LATENCY_PC_FUNC(void)
 #define CVMX_FPA_RD_REQ_PC CVMX_FPA_RD_REQ_PC_FUNC()
 static inline uint64_t CVMX_FPA_RD_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RD_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000600ull);
 }
@@ -700,7 +739,7 @@ static inline uint64_t CVMX_FPA_RD_REQ_PC_FUNC(void)
 #define CVMX_FPA_RED_DELAY CVMX_FPA_RED_DELAY_FUNC()
 static inline uint64_t CVMX_FPA_RED_DELAY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RED_DELAY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000100ull);
 }
@@ -711,7 +750,7 @@ static inline uint64_t CVMX_FPA_RED_DELAY_FUNC(void)
 #define CVMX_FPA_SFT_RST CVMX_FPA_SFT_RST_FUNC()
 static inline uint64_t CVMX_FPA_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000000ull);
 }
@@ -783,7 +822,7 @@ union cvmx_fpa_addr_range_error {
 	struct cvmx_fpa_addr_range_error_cn61xx cn68xxp1;
 	struct cvmx_fpa_addr_range_error_cn61xx cn70xx;
 	struct cvmx_fpa_addr_range_error_cn61xx cn70xxp1;
-	struct cvmx_fpa_addr_range_error_cn78xx {
+	struct cvmx_fpa_addr_range_error_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
 	uint64_t pool                         : 6;  /**< Pool that address was sent to. */
@@ -795,7 +834,8 @@ union cvmx_fpa_addr_range_error {
 	uint64_t pool                         : 6;
 	uint64_t reserved_54_63               : 10;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_fpa_addr_range_error_cn73xx cn78xx;
 	struct cvmx_fpa_addr_range_error_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_addr_range_error cvmx_fpa_addr_range_error_t;
@@ -836,6 +876,7 @@ union cvmx_fpa_aurax_cfg {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cfg_s           cn73xx;
 	struct cvmx_fpa_aurax_cfg_s           cn78xx;
 };
 typedef union cvmx_fpa_aurax_cfg cvmx_fpa_aurax_cfg_t;
@@ -854,6 +895,7 @@ union cvmx_fpa_aurax_cnt {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_s           cn73xx;
 	struct cvmx_fpa_aurax_cnt_s           cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt cvmx_fpa_aurax_cnt_t;
@@ -878,6 +920,7 @@ union cvmx_fpa_aurax_cnt_add {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_add_s       cn73xx;
 	struct cvmx_fpa_aurax_cnt_add_s       cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt_add cvmx_fpa_aurax_cnt_add_t;
@@ -907,11 +950,11 @@ union cvmx_fpa_aurax_cnt_levels {
                                                          calculations. */
 	uint64_t bp                           : 8;  /**< Backpressure can assert if the current 8-bit shifted and saturated FPA_AURA()_CNT[CNT] is
                                                          equal to or greater than this value. */
-	uint64_t drop                         : 8;  /**< If [RED_ENA]==1 and RED processing is requested, the packet will be dropped if
+	uint64_t drop                         : 8;  /**< If [RED_ENA]=1 and RED processing is requested, the packet will be dropped if
                                                          [LEVEL] is equal to or greater than this value.
-                                                         If DROP processing is requested, the packet will be dropped if the current 8-bit
-                                                         shifted and saturated FPA_AURA()_CNT[CNT] is equal to or greater than this
-                                                         value. */
+                                                         If [DROP_DIS]=0 and DROP processing is requested, the packet will be dropped if
+                                                         the current 8-bit shifted and saturated FPA_AURA()_CNT[CNT] is equal to or greater
+                                                         than this value. */
 	uint64_t pass                         : 8;  /**< Aura RED processing will not drop an allocation request if [LEVEL] is less than this value. */
 	uint64_t level                        : 8;  /**< Current moving average of the 8-bit shifted and saturated FPA_AURA()_CNT[CNT].
                                                          The lower [LEVEL] is, the more free resources. The highest [LEVEL]'s indicate buffer
@@ -929,6 +972,7 @@ union cvmx_fpa_aurax_cnt_levels {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_levels_s    cn73xx;
 	struct cvmx_fpa_aurax_cnt_levels_s    cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt_levels cvmx_fpa_aurax_cnt_levels_t;
@@ -949,6 +993,7 @@ union cvmx_fpa_aurax_cnt_limit {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_limit_s     cn73xx;
 	struct cvmx_fpa_aurax_cnt_limit_s     cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt_limit cvmx_fpa_aurax_cnt_limit_t;
@@ -969,6 +1014,7 @@ union cvmx_fpa_aurax_cnt_threshold {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_threshold_s cn73xx;
 	struct cvmx_fpa_aurax_cnt_threshold_s cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt_threshold cvmx_fpa_aurax_cnt_threshold_t;
@@ -990,6 +1036,7 @@ union cvmx_fpa_aurax_int {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_int_s           cn73xx;
 	struct cvmx_fpa_aurax_int_s           cn78xx;
 };
 typedef union cvmx_fpa_aurax_int cvmx_fpa_aurax_int_t;
@@ -1011,6 +1058,7 @@ union cvmx_fpa_aurax_pool {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_pool_s          cn73xx;
 	struct cvmx_fpa_aurax_pool_s          cn78xx;
 };
 typedef union cvmx_fpa_aurax_pool cvmx_fpa_aurax_pool_t;
@@ -1044,11 +1092,11 @@ union cvmx_fpa_aurax_pool_levels {
                                                          processing. */
 	uint64_t bp                           : 8;  /**< Backpressure can assert if the current 8-bit shifted and saturated
                                                          FPA_POOL()_AVAILABLE[COUNT] for the aura is equal to or less than this value. */
-	uint64_t drop                         : 8;  /**< If [RED_ENA]==1 and RED processing is requested, the packet will be dropped if
+	uint64_t drop                         : 8;  /**< If [RED_ENA]=1 and RED processing is requested, the packet will be dropped if
                                                          [LEVEL] is equal to or less than this value.
-                                                         If DROP processing is requested, the packet will be dropped if the current 8-bit
-                                                         shifted and saturated FPA_POOL()_AVAILABLE[COUNT] for the aura is equal to or
-                                                         less than this value. */
+                                                         If [DROP_DIS]=0 and DROP processing is requested, the packet will be dropped
+                                                         if the current 8-bit shifted and saturated FPA_POOL()_AVAILABLE[COUNT] for the
+                                                         aura is equal to or less than this value. */
 	uint64_t pass                         : 8;  /**< Aura-unique pool RED processing will not drop an allocation request if [LEVEL] is larger
                                                          than this value. */
 	uint64_t level                        : 8;  /**< Current moving average of the 8-bit shifted and saturated FPA_POOL()_AVAILABLE[COUNT] for
@@ -1068,6 +1116,7 @@ union cvmx_fpa_aurax_pool_levels {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_pool_levels_s   cn73xx;
 	struct cvmx_fpa_aurax_pool_levels_s   cn78xx;
 };
 typedef union cvmx_fpa_aurax_pool_levels cvmx_fpa_aurax_pool_levels_t;
@@ -1122,7 +1171,7 @@ union cvmx_fpa_bist_status {
 	struct cvmx_fpa_bist_status_cn30xx    cn68xxp1;
 	struct cvmx_fpa_bist_status_cn30xx    cn70xx;
 	struct cvmx_fpa_bist_status_cn30xx    cn70xxp1;
-	struct cvmx_fpa_bist_status_cn78xx {
+	struct cvmx_fpa_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_38_63               : 26;
 	uint64_t status                       : 38; /**< Memory BIST status. */
@@ -1130,7 +1179,8 @@ union cvmx_fpa_bist_status {
 	uint64_t status                       : 38;
 	uint64_t reserved_38_63               : 26;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_fpa_bist_status_cn73xx    cn78xx;
 	struct cvmx_fpa_bist_status_cn30xx    cnf71xx;
 };
 typedef union cvmx_fpa_bist_status cvmx_fpa_bist_status_t;
@@ -1151,6 +1201,7 @@ union cvmx_fpa_clk_count {
 	uint64_t clk_cnt                      : 64;
 #endif
 	} s;
+	struct cvmx_fpa_clk_count_s           cn73xx;
 	struct cvmx_fpa_clk_count_s           cn78xx;
 };
 typedef union cvmx_fpa_clk_count cvmx_fpa_clk_count_t;
@@ -1277,6 +1328,7 @@ union cvmx_fpa_ecc_ctl {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_fpa_ecc_ctl_s             cn73xx;
 	struct cvmx_fpa_ecc_ctl_s             cn78xx;
 };
 typedef union cvmx_fpa_ecc_ctl cvmx_fpa_ecc_ctl_t;
@@ -1304,6 +1356,7 @@ union cvmx_fpa_ecc_int {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_fpa_ecc_int_s             cn73xx;
 	struct cvmx_fpa_ecc_int_s             cn78xx;
 };
 typedef union cvmx_fpa_ecc_int cvmx_fpa_ecc_int_t;
@@ -1335,6 +1388,7 @@ union cvmx_fpa_err_int {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_fpa_err_int_s             cn73xx;
 	struct cvmx_fpa_err_int_s             cn78xx;
 };
 typedef union cvmx_fpa_err_int cvmx_fpa_err_int_t;
@@ -1645,6 +1699,7 @@ union cvmx_fpa_gen_cfg {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_fpa_gen_cfg_s             cn73xx;
 	struct cvmx_fpa_gen_cfg_s             cn78xx;
 };
 typedef union cvmx_fpa_gen_cfg cvmx_fpa_gen_cfg_t;
@@ -3187,6 +3242,7 @@ union cvmx_fpa_poolx_available {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_available_s     cn73xx;
 	struct cvmx_fpa_poolx_available_s     cn78xx;
 };
 typedef union cvmx_fpa_poolx_available cvmx_fpa_poolx_available_t;
@@ -3236,6 +3292,7 @@ union cvmx_fpa_poolx_cfg {
 	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_cfg_s           cn73xx;
 	struct cvmx_fpa_poolx_cfg_s           cn78xx;
 };
 typedef union cvmx_fpa_poolx_cfg cvmx_fpa_poolx_cfg_t;
@@ -3269,7 +3326,7 @@ union cvmx_fpa_poolx_end_addr {
 	struct cvmx_fpa_poolx_end_addr_cn61xx cn68xxp1;
 	struct cvmx_fpa_poolx_end_addr_cn61xx cn70xx;
 	struct cvmx_fpa_poolx_end_addr_cn61xx cn70xxp1;
-	struct cvmx_fpa_poolx_end_addr_cn78xx {
+	struct cvmx_fpa_poolx_end_addr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
 	uint64_t addr                         : 35; /**< Address. */
@@ -3279,7 +3336,8 @@ union cvmx_fpa_poolx_end_addr {
 	uint64_t addr                         : 35;
 	uint64_t reserved_42_63               : 22;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_fpa_poolx_end_addr_cn73xx cn78xx;
 	struct cvmx_fpa_poolx_end_addr_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_poolx_end_addr cvmx_fpa_poolx_end_addr_t;
@@ -3314,6 +3372,7 @@ union cvmx_fpa_poolx_fpf_marks {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_fpf_marks_s     cn73xx;
 	struct cvmx_fpa_poolx_fpf_marks_s     cn78xx;
 };
 typedef union cvmx_fpa_poolx_fpf_marks cvmx_fpa_poolx_fpf_marks_t;
@@ -3347,6 +3406,7 @@ union cvmx_fpa_poolx_int {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_int_s           cn73xx;
 	struct cvmx_fpa_poolx_int_s           cn78xx;
 };
 typedef union cvmx_fpa_poolx_int cvmx_fpa_poolx_int_t;
@@ -3363,6 +3423,7 @@ union cvmx_fpa_poolx_op_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_op_pc_s         cn73xx;
 	struct cvmx_fpa_poolx_op_pc_s         cn78xx;
 };
 typedef union cvmx_fpa_poolx_op_pc cvmx_fpa_poolx_op_pc_t;
@@ -3384,6 +3445,7 @@ union cvmx_fpa_poolx_stack_addr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_stack_addr_s    cn73xx;
 	struct cvmx_fpa_poolx_stack_addr_s    cn78xx;
 };
 typedef union cvmx_fpa_poolx_stack_addr cvmx_fpa_poolx_stack_addr_t;
@@ -3404,6 +3466,7 @@ union cvmx_fpa_poolx_stack_base {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_stack_base_s    cn73xx;
 	struct cvmx_fpa_poolx_stack_base_s    cn78xx;
 };
 typedef union cvmx_fpa_poolx_stack_base cvmx_fpa_poolx_stack_base_t;
@@ -3425,6 +3488,7 @@ union cvmx_fpa_poolx_stack_end {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_stack_end_s     cn73xx;
 	struct cvmx_fpa_poolx_stack_end_s     cn78xx;
 };
 typedef union cvmx_fpa_poolx_stack_end cvmx_fpa_poolx_stack_end_t;
@@ -3458,7 +3522,7 @@ union cvmx_fpa_poolx_start_addr {
 	struct cvmx_fpa_poolx_start_addr_cn61xx cn68xxp1;
 	struct cvmx_fpa_poolx_start_addr_cn61xx cn70xx;
 	struct cvmx_fpa_poolx_start_addr_cn61xx cn70xxp1;
-	struct cvmx_fpa_poolx_start_addr_cn78xx {
+	struct cvmx_fpa_poolx_start_addr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
 	uint64_t addr                         : 35; /**< Address. Defaults to 1 so that a NULL pointer free will cause an exception. */
@@ -3468,7 +3532,8 @@ union cvmx_fpa_poolx_start_addr {
 	uint64_t addr                         : 35;
 	uint64_t reserved_42_63               : 22;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_fpa_poolx_start_addr_cn73xx cn78xx;
 	struct cvmx_fpa_poolx_start_addr_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_poolx_start_addr cvmx_fpa_poolx_start_addr_t;
@@ -3515,6 +3580,7 @@ union cvmx_fpa_poolx_threshold {
 	struct cvmx_fpa_poolx_threshold_cn68xx cn68xxp1;
 	struct cvmx_fpa_poolx_threshold_cn61xx cn70xx;
 	struct cvmx_fpa_poolx_threshold_cn61xx cn70xxp1;
+	struct cvmx_fpa_poolx_threshold_s     cn73xx;
 	struct cvmx_fpa_poolx_threshold_s     cn78xx;
 	struct cvmx_fpa_poolx_threshold_cn61xx cnf71xx;
 };
@@ -3727,12 +3793,14 @@ union cvmx_fpa_rd_latency_pc {
 	uint64_t u64;
 	struct cvmx_fpa_rd_latency_pc_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of cycles waiting for L2C pool read returns. This may be divided by FPA_RD_REQ_PC
-                                                         to determine the average read latency. */
+	uint64_t count                        : 64; /**< Number of cycles waiting for L2C pool read returns. Incremented every
+                                                         coprocessor-clock by the number of transactions outstanding in that cycle. This
+                                                         may be divided by FPA_RD_REQ_PC to determine the average read latency. */
 #else
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_fpa_rd_latency_pc_s       cn73xx;
 	struct cvmx_fpa_rd_latency_pc_s       cn78xx;
 };
 typedef union cvmx_fpa_rd_latency_pc cvmx_fpa_rd_latency_pc_t;
@@ -3749,6 +3817,7 @@ union cvmx_fpa_rd_req_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_fpa_rd_req_pc_s           cn73xx;
 	struct cvmx_fpa_rd_req_pc_s           cn78xx;
 };
 typedef union cvmx_fpa_rd_req_pc cvmx_fpa_rd_req_pc_t;
@@ -3777,6 +3846,7 @@ union cvmx_fpa_red_delay {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_fpa_red_delay_s           cn73xx;
 	struct cvmx_fpa_red_delay_s           cn78xx;
 };
 typedef union cvmx_fpa_red_delay cvmx_fpa_red_delay_t;
@@ -3803,6 +3873,7 @@ union cvmx_fpa_sft_rst {
 	uint64_t busy                         : 1;
 #endif
 	} s;
+	struct cvmx_fpa_sft_rst_s             cn73xx;
 	struct cvmx_fpa_sft_rst_s             cn78xx;
 };
 typedef union cvmx_fpa_sft_rst cvmx_fpa_sft_rst_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa3.h b/arch/mips/include/asm/octeon/cvmx-fpa3.h
index 83fe843..e265bf3 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa3.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa3.h
@@ -42,7 +42,7 @@
  *
  * Interface to the CN78XX Free Pool Allocator, a.k.a. FPA3
  *
- * <hr>$Revision: 109476 $<hr>
+ * <hr>$Revision: 110934 $<hr>
  *
  */
 
@@ -255,8 +255,6 @@ static inline int cvmx_fpa3_num_pools(void)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 64;
-	if (OCTEON_IS_MODEL(OCTEON_CN76XX))
-		return 64;
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return 32;
 	cvmx_printf("ERROR: %s: Unknowm model\n",__func__);
@@ -273,8 +271,6 @@ static inline int cvmx_fpa3_num_auras(void)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 1024;
-	if (OCTEON_IS_MODEL(OCTEON_CN76XX))
-		return 1024;
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return 512;
 	cvmx_printf("ERROR: %s: Unknowm model\n",__func__);
diff --git a/arch/mips/include/asm/octeon/cvmx-gmx.h b/arch/mips/include/asm/octeon/cvmx-gmx.h
index bd95280..6d8a600 100644
--- a/arch/mips/include/asm/octeon/cvmx-gmx.h
+++ b/arch/mips/include/asm/octeon/cvmx-gmx.h
@@ -42,7 +42,7 @@
  *
  * Interface to the GMX hardware.
  *
- * <hr>$Revision: 94283 $<hr>
+ * <hr>$Revision: 109572 $<hr>
  */
 
 #ifndef __CVMX_GMX_H__
@@ -60,7 +60,7 @@ int cvmx_gmx_set_backpressure_override(uint32_t interface, uint32_t port_mask);
 
 int cvmx_agl_set_backpressure_override(uint32_t interface, uint32_t port_mask);
 
-int cvmx_bgx_set_backpressure_override(uint32_t interface, uint32_t port_mask);
+int cvmx_bgx_set_backpressure_override(uint32_t xiface, uint32_t port_mask);
 
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
diff --git a/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h b/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
index 0c9b387..cab325e 100644
--- a/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
@@ -53,7 +53,7 @@
 #define __CVMX_GMXX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_BAD_REG(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_BAD_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -62,8 +62,8 @@ static inline uint64_t CVMX_GMXX_BAD_REG(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -71,19 +71,19 @@ static inline uint64_t CVMX_GMXX_BAD_REG(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_BAD_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_BAD_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_BAD_REG(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_BAD_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -92,22 +92,22 @@ static inline uint64_t CVMX_GMXX_BAD_REG(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_BIST(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_BIST(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -116,8 +116,8 @@ static inline uint64_t CVMX_GMXX_BIST(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000400ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000400ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -125,19 +125,19 @@ static inline uint64_t CVMX_GMXX_BIST(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000400ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000400ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000400ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000400ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_BIST (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000400ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_BIST (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000400ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_BIST(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_BIST(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -146,18 +146,18 @@ static inline uint64_t CVMX_GMXX_BIST(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
@@ -172,128 +172,128 @@ static inline uint64_t CVMX_GMXX_BPID_MAPX(unsigned long offset, unsigned long b
 #define CVMX_GMXX_BPID_MAPX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000680ull) + (((offset) & 15) + ((block_id) & 7) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_BPID_MSK(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_BPID_MSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_GMXX_BPID_MSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000700ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_GMXX_BPID_MSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000700ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GMXX_BPID_MSK(block_id) (CVMX_ADD_IO_SEG(0x0001180008000700ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_GMXX_BPID_MSK(offset) (CVMX_ADD_IO_SEG(0x0001180008000700ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_CLK_EN(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_CLK_EN(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_CLK_EN (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_CLK_EN (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_CLK_EN(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_CLK_EN(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_EBP_DIS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_EBP_DIS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_GMXX_EBP_DIS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000608ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_GMXX_EBP_DIS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000608ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GMXX_EBP_DIS(block_id) (CVMX_ADD_IO_SEG(0x0001180008000608ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_GMXX_EBP_DIS(offset) (CVMX_ADD_IO_SEG(0x0001180008000608ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_EBP_MSK(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_EBP_MSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_GMXX_EBP_MSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000600ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_GMXX_EBP_MSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000600ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GMXX_EBP_MSK(block_id) (CVMX_ADD_IO_SEG(0x0001180008000600ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_GMXX_EBP_MSK(offset) (CVMX_ADD_IO_SEG(0x0001180008000600ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_HG2_CONTROL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_HG2_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000550ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000550ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000550ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000550ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000550ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000550ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_HG2_CONTROL (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000550ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_HG2_CONTROL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000550ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_HG2_CONTROL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_HG2_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_INF_MODE(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_INF_MODE(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -302,8 +302,8 @@ static inline uint64_t CVMX_GMXX_INF_MODE(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -311,19 +311,19 @@ static inline uint64_t CVMX_GMXX_INF_MODE(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_INF_MODE (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_INF_MODE (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_INF_MODE(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_INF_MODE(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -332,22 +332,22 @@ static inline uint64_t CVMX_GMXX_INF_MODE(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_NXA_ADR(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_NXA_ADR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -356,8 +356,8 @@ static inline uint64_t CVMX_GMXX_NXA_ADR(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000510ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000510ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -365,19 +365,19 @@ static inline uint64_t CVMX_GMXX_NXA_ADR(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000510ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000510ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000510ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000510ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_NXA_ADR (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000510ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_NXA_ADR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000510ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_NXA_ADR(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_NXA_ADR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -386,30 +386,30 @@ static inline uint64_t CVMX_GMXX_NXA_ADR(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_PIPE_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_PIPE_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_GMXX_PIPE_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_GMXX_PIPE_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GMXX_PIPE_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_GMXX_PIPE_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GMXX_PRTX_CBFC_CTL(unsigned long offset, unsigned long block_id)
@@ -522,42 +522,42 @@ static inline uint64_t CVMX_GMXX_PRTX_CFG(unsigned long offset, unsigned long bl
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_QSGMII_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_QSGMII_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_GMXX_QSGMII_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GMXX_QSGMII_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_GMXX_QSGMII_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_GMXX_QSGMII_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_RXAUI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RXAUI_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000740ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000740ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000740ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000740ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_RXAUI_CTL (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000740ull) + ((block_id) & 1) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_RXAUI_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000740ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_RXAUI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RXAUI_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000740ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000740ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000740ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000740ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000740ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000740ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
@@ -2592,60 +2592,60 @@ static inline uint64_t CVMX_GMXX_RX_BP_ONX(unsigned long offset, unsigned long b
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_RX_HG2_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_HG2_STATUS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000548ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000548ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000548ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000548ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000548ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000548ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_RX_HG2_STATUS (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000548ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_RX_HG2_STATUS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000548ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_RX_HG2_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_HG2_STATUS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_RX_PASS_EN(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_PASS_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_GMXX_RX_PASS_EN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080005F8ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GMXX_RX_PASS_EN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080005F8ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_GMXX_RX_PASS_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800080005F8ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_GMXX_RX_PASS_EN(offset) (CVMX_ADD_IO_SEG(0x00011800080005F8ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GMXX_RX_PASS_MAPX(unsigned long offset, unsigned long block_id)
@@ -2660,7 +2660,7 @@ static inline uint64_t CVMX_GMXX_RX_PASS_MAPX(unsigned long offset, unsigned lon
 #define CVMX_GMXX_RX_PASS_MAPX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000600ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_RX_PRTS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_PRTS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -2669,8 +2669,8 @@ static inline uint64_t CVMX_GMXX_RX_PRTS(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000410ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000410ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -2678,19 +2678,19 @@ static inline uint64_t CVMX_GMXX_RX_PRTS(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000410ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000410ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000410ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000410ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_RX_PRTS (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000410ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_RX_PRTS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000410ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_RX_PRTS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_PRTS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -2699,22 +2699,22 @@ static inline uint64_t CVMX_GMXX_RX_PRTS(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_RX_PRT_INFO(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_PRT_INFO(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2723,8 +2723,8 @@ static inline uint64_t CVMX_GMXX_RX_PRT_INFO(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -2732,19 +2732,19 @@ static inline uint64_t CVMX_GMXX_RX_PRT_INFO(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_RX_PRT_INFO (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_RX_PRT_INFO (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_RX_PRT_INFO(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_PRT_INFO(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2753,119 +2753,119 @@ static inline uint64_t CVMX_GMXX_RX_PRT_INFO(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_RX_TX_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_TX_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GMXX_RX_TX_STATUS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GMXX_RX_TX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800080007E8ull);
 }
 #else
-#define CVMX_GMXX_RX_TX_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800080007E8ull))
+#define CVMX_GMXX_RX_TX_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800080007E8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_RX_XAUI_BAD_COL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_XAUI_BAD_COL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000538ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000538ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000538ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000538ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000538ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000538ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_RX_XAUI_BAD_COL (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000538ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_RX_XAUI_BAD_COL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000538ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_RX_XAUI_BAD_COL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_XAUI_BAD_COL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_RX_XAUI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_XAUI_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000530ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000530ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000530ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000530ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000530ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000530ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_RX_XAUI_CTL (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000530ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_RX_XAUI_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000530ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_RX_XAUI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_RX_XAUI_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
@@ -2935,41 +2935,41 @@ static inline uint64_t CVMX_GMXX_SMACX(unsigned long offset, unsigned long block
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_SOFT_BIST(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_SOFT_BIST(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_SOFT_BIST (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + ((block_id) & 7) * 0x1000000ull;
+	cvmx_warn("CVMX_GMXX_SOFT_BIST (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_SOFT_BIST(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_SOFT_BIST(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_STAT_BP(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_STAT_BP(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -2978,8 +2978,8 @@ static inline uint64_t CVMX_GMXX_STAT_BP(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000520ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000520ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -2987,19 +2987,19 @@ static inline uint64_t CVMX_GMXX_STAT_BP(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000520ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000520ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000520ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000520ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_STAT_BP (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000520ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_STAT_BP (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000520ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_STAT_BP(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_STAT_BP(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -3008,56 +3008,56 @@ static inline uint64_t CVMX_GMXX_STAT_BP(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TB_REG(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TB_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TB_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TB_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TB_REG(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TB_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
@@ -4697,7 +4697,7 @@ static inline uint64_t CVMX_GMXX_TXX_THRESH(unsigned long offset, unsigned long
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_BP(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_BP(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -4706,8 +4706,8 @@ static inline uint64_t CVMX_GMXX_TX_BP(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -4715,19 +4715,19 @@ static inline uint64_t CVMX_GMXX_TX_BP(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_BP (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_BP (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_BP(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_BP(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -4736,18 +4736,18 @@ static inline uint64_t CVMX_GMXX_TX_BP(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
@@ -4763,7 +4763,7 @@ static inline uint64_t CVMX_GMXX_TX_CLK_MSKX(unsigned long offset, unsigned long
 #define CVMX_GMXX_TX_CLK_MSKX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000780ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_COL_ATTEMPT(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_COL_ATTEMPT(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -4772,8 +4772,8 @@ static inline uint64_t CVMX_GMXX_TX_COL_ATTEMPT(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000498ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000498ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -4781,19 +4781,19 @@ static inline uint64_t CVMX_GMXX_TX_COL_ATTEMPT(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000498ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000498ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000498ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000498ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_COL_ATTEMPT (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000498ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_COL_ATTEMPT (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000498ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_COL_ATTEMPT(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_COL_ATTEMPT(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -4802,22 +4802,22 @@ static inline uint64_t CVMX_GMXX_TX_COL_ATTEMPT(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_CORRUPT(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_CORRUPT(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -4826,8 +4826,8 @@ static inline uint64_t CVMX_GMXX_TX_CORRUPT(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -4835,19 +4835,19 @@ static inline uint64_t CVMX_GMXX_TX_CORRUPT(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_CORRUPT (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_CORRUPT (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_CORRUPT(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_CORRUPT(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -4856,110 +4856,110 @@ static inline uint64_t CVMX_GMXX_TX_CORRUPT(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_HG2_REG1(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_HG2_REG1(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000558ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000558ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000558ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000558ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000558ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000558ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_HG2_REG1 (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000558ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_HG2_REG1 (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000558ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_HG2_REG1(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_HG2_REG1(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_HG2_REG2(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_HG2_REG2(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000560ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000560ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000560ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000560ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000560ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000560ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_HG2_REG2 (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000560ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_HG2_REG2 (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000560ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_HG2_REG2(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_HG2_REG2(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_IFG(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_IFG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -4968,8 +4968,8 @@ static inline uint64_t CVMX_GMXX_TX_IFG(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000488ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000488ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -4977,19 +4977,19 @@ static inline uint64_t CVMX_GMXX_TX_IFG(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000488ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000488ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000488ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000488ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_IFG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000488ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_IFG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000488ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_IFG(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_IFG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -4998,22 +4998,22 @@ static inline uint64_t CVMX_GMXX_TX_IFG(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_INT_EN(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_INT_EN(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5022,8 +5022,8 @@ static inline uint64_t CVMX_GMXX_TX_INT_EN(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -5031,19 +5031,19 @@ static inline uint64_t CVMX_GMXX_TX_INT_EN(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_INT_EN (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_INT_EN (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_INT_EN(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_INT_EN(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5052,22 +5052,22 @@ static inline uint64_t CVMX_GMXX_TX_INT_EN(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_INT_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5076,8 +5076,8 @@ static inline uint64_t CVMX_GMXX_TX_INT_REG(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -5085,19 +5085,19 @@ static inline uint64_t CVMX_GMXX_TX_INT_REG(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_INT_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_INT_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_INT_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5106,22 +5106,22 @@ static inline uint64_t CVMX_GMXX_TX_INT_REG(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_JAM(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_JAM(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5130,8 +5130,8 @@ static inline uint64_t CVMX_GMXX_TX_JAM(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000490ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000490ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -5139,19 +5139,19 @@ static inline uint64_t CVMX_GMXX_TX_JAM(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000490ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000490ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000490ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000490ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_JAM (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000490ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_JAM (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000490ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_JAM(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_JAM(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5160,22 +5160,22 @@ static inline uint64_t CVMX_GMXX_TX_JAM(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_LFSR(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_LFSR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5184,8 +5184,8 @@ static inline uint64_t CVMX_GMXX_TX_LFSR(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -5193,19 +5193,19 @@ static inline uint64_t CVMX_GMXX_TX_LFSR(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_LFSR (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_LFSR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_LFSR(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_LFSR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5214,22 +5214,22 @@ static inline uint64_t CVMX_GMXX_TX_LFSR(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_OVR_BP(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_OVR_BP(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5238,8 +5238,8 @@ static inline uint64_t CVMX_GMXX_TX_OVR_BP(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -5247,19 +5247,19 @@ static inline uint64_t CVMX_GMXX_TX_OVR_BP(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_OVR_BP (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_OVR_BP (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_OVR_BP(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_OVR_BP(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5268,22 +5268,22 @@ static inline uint64_t CVMX_GMXX_TX_OVR_BP(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_DMAC(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_DMAC(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5292,8 +5292,8 @@ static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_DMAC(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -5301,19 +5301,19 @@ static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_DMAC(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_PAUSE_PKT_DMAC (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_PAUSE_PKT_DMAC (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_DMAC(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_DMAC(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5322,22 +5322,22 @@ static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_DMAC(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_TYPE(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_TYPE(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5346,8 +5346,8 @@ static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_TYPE(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -5355,19 +5355,19 @@ static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_TYPE(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_PAUSE_PKT_TYPE (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_PAUSE_PKT_TYPE (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_TYPE(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_TYPE(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5376,22 +5376,22 @@ static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_TYPE(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_PRTS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_PRTS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5400,8 +5400,8 @@ static inline uint64_t CVMX_GMXX_TX_PRTS(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000480ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000480ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -5409,19 +5409,19 @@ static inline uint64_t CVMX_GMXX_TX_PRTS(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000480ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000480ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000480ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000480ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_PRTS (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000480ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_PRTS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000480ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_PRTS(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_PRTS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -5430,55 +5430,55 @@ static inline uint64_t CVMX_GMXX_TX_PRTS(unsigned long block_id)
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_SPI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_SPI_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_GMXX_TX_SPI_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004C0ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GMXX_TX_SPI_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004C0ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_GMXX_TX_SPI_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800080004C0ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_GMXX_TX_SPI_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800080004C0ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_SPI_DRAIN(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_SPI_DRAIN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_GMXX_TX_SPI_DRAIN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004E0ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GMXX_TX_SPI_DRAIN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004E0ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_GMXX_TX_SPI_DRAIN(block_id) (CVMX_ADD_IO_SEG(0x00011800080004E0ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_GMXX_TX_SPI_DRAIN(offset) (CVMX_ADD_IO_SEG(0x00011800080004E0ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_SPI_MAX(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_SPI_MAX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_GMXX_TX_SPI_MAX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004B0ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GMXX_TX_SPI_MAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004B0ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_GMXX_TX_SPI_MAX(block_id) (CVMX_ADD_IO_SEG(0x00011800080004B0ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_GMXX_TX_SPI_MAX(offset) (CVMX_ADD_IO_SEG(0x00011800080004B0ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GMXX_TX_SPI_ROUNDX(unsigned long offset, unsigned long block_id)
@@ -5492,114 +5492,114 @@ static inline uint64_t CVMX_GMXX_TX_SPI_ROUNDX(unsigned long offset, unsigned lo
 #define CVMX_GMXX_TX_SPI_ROUNDX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000680ull) + (((offset) & 31) + ((block_id) & 1) * 0x1000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_SPI_THRESH(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_SPI_THRESH(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_GMXX_TX_SPI_THRESH(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800080004B8ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GMXX_TX_SPI_THRESH(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800080004B8ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_GMXX_TX_SPI_THRESH(block_id) (CVMX_ADD_IO_SEG(0x00011800080004B8ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_GMXX_TX_SPI_THRESH(offset) (CVMX_ADD_IO_SEG(0x00011800080004B8ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_TX_XAUI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_XAUI_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000528ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000528ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000528ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000528ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000528ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000528ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_TX_XAUI_CTL (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000528ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_TX_XAUI_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000528ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_TX_XAUI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_TX_XAUI_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_WOL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_WOL_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_GMXX_WOL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000780ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GMXX_WOL_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000780ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_GMXX_WOL_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180008000780ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_GMXX_WOL_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180008000780ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GMXX_XAUI_EXT_LOOPBACK(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_XAUI_EXT_LOOPBACK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180008000540ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180008000540ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180008000540ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180008000540ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x0001180008000540ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x0001180008000540ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_GMXX_XAUI_EXT_LOOPBACK (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180008000540ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_GMXX_XAUI_EXT_LOOPBACK (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180008000540ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_GMXX_XAUI_EXT_LOOPBACK(unsigned long block_id)
+static inline uint64_t CVMX_GMXX_XAUI_EXT_LOOPBACK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (offset) * 0x8000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (offset) * 0x8000000ull;
 }
 #endif
 
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index 6eb8f75..6823819 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -76,6 +76,10 @@ static inline uint64_t CVMX_GPIO_BIT_CFGX(unsigned long offset)
 			if ((offset <= 19))
 				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_GPIO_BIT_CFGX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000800ull) + ((offset) & 15) * 8;
@@ -100,6 +104,8 @@ static inline uint64_t CVMX_GPIO_BIT_CFGX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001070000000800ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000800ull) + (offset) * 8;
 }
@@ -126,6 +132,7 @@ static inline uint64_t CVMX_GPIO_CLK_GENX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_GPIO_CLK_GENX(%lu) is invalid on this chip\n", offset);
@@ -154,6 +161,7 @@ static inline uint64_t CVMX_GPIO_CLK_SYNCEX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_GPIO_CLK_SYNCEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00010700000008E0ull) + ((offset) & 1) * 8;
@@ -165,7 +173,7 @@ static inline uint64_t CVMX_GPIO_CLK_SYNCEX(unsigned long offset)
 #define CVMX_GPIO_COMP CVMX_GPIO_COMP_FUNC()
 static inline uint64_t CVMX_GPIO_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000D00ull);
 }
@@ -187,6 +195,7 @@ static inline uint64_t CVMX_GPIO_DBG_ENA_FUNC(void)
 static inline uint64_t CVMX_GPIO_INTRX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_GPIO_INTRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000A00ull) + ((offset) & 15) * 8;
@@ -199,6 +208,7 @@ static inline uint64_t CVMX_GPIO_INTRX(unsigned long offset)
 static inline uint64_t CVMX_GPIO_MC_INTRX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 4) && (offset <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 4) && (offset <= 7))))))
 		cvmx_warn("CVMX_GPIO_MC_INTRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000C20ull) + ((offset) & 7) * 8 - 8*4;
@@ -207,10 +217,21 @@ static inline uint64_t CVMX_GPIO_MC_INTRX(unsigned long offset)
 #define CVMX_GPIO_MC_INTRX(offset) (CVMX_ADD_IO_SEG(0x0001070000000C20ull) + ((offset) & 7) * 8 - 8*4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GPIO_MC_INTRX_W1S(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 4) && (offset <= 7))))))
+		cvmx_warn("CVMX_GPIO_MC_INTRX_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070000000E20ull) + ((offset) & 7) * 8 - 8*4;
+}
+#else
+#define CVMX_GPIO_MC_INTRX_W1S(offset) (CVMX_ADD_IO_SEG(0x0001070000000E20ull) + ((offset) & 7) * 8 - 8*4)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_GPIO_MULTI_CAST CVMX_GPIO_MULTI_CAST_FUNC()
 static inline uint64_t CVMX_GPIO_MULTI_CAST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_GPIO_MULTI_CAST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008B0ull);
 }
@@ -221,7 +242,7 @@ static inline uint64_t CVMX_GPIO_MULTI_CAST_FUNC(void)
 #define CVMX_GPIO_OCLA_EXTEN_TRIG CVMX_GPIO_OCLA_EXTEN_TRIG_FUNC()
 static inline uint64_t CVMX_GPIO_OCLA_EXTEN_TRIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_OCLA_EXTEN_TRIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008B8ull);
 }
@@ -252,10 +273,32 @@ static inline uint64_t CVMX_GPIO_SATA_CTL_FUNC(void)
 #define CVMX_GPIO_SATA_CTL (CVMX_ADD_IO_SEG(0x00010700000008A8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GPIO_SATA_CTLX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GPIO_SATA_CTLX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070000000D80ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_GPIO_SATA_CTLX(offset) (CVMX_ADD_IO_SEG(0x0001070000000D80ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_GPIO_SATA_LAB_LB CVMX_GPIO_SATA_LAB_LB_FUNC()
+static inline uint64_t CVMX_GPIO_SATA_LAB_LB_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_GPIO_SATA_LAB_LB not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070000000D40ull);
+}
+#else
+#define CVMX_GPIO_SATA_LAB_LB (CVMX_ADD_IO_SEG(0x0001070000000D40ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_GPIO_TIM_CTL CVMX_GPIO_TIM_CTL_FUNC()
 static inline uint64_t CVMX_GPIO_TIM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_TIM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008A0ull);
 }
@@ -265,6 +308,17 @@ static inline uint64_t CVMX_GPIO_TIM_CTL_FUNC(void)
 #define CVMX_GPIO_TX_CLR (CVMX_ADD_IO_SEG(0x0001070000000890ull))
 #define CVMX_GPIO_TX_SET (CVMX_ADD_IO_SEG(0x0001070000000888ull))
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GPIO_USBDRD_CTLX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_GPIO_USBDRD_CTLX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070000000D20ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_GPIO_USBDRD_CTLX(offset) (CVMX_ADD_IO_SEG(0x0001070000000D20ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_GPIO_USBH_CTL CVMX_GPIO_USBH_CTL_FUNC()
 static inline uint64_t CVMX_GPIO_USBH_CTL_FUNC(void)
 {
@@ -431,8 +485,11 @@ union cvmx_gpio_bit_cfgx {
                                                            0x1a-  : Reserved.
                                                          Note: GPIO[19:10] controls are ignored if PCM is enabled.  See PCM(0..3)_TDM_CFG */
 	uint64_t reserved_12_15               : 4;
-	uint64_t fil_sel                      : 4;  /**< Global counter bit-select (controls sample rate) */
-	uint64_t fil_cnt                      : 4;  /**< Number of consecutive samples to change state */
+	uint64_t fil_sel                      : 4;  /**< Filter select. Global counter bit-select (controls sample rate).
+                                                         Filter are XOR inverter are also appliable to GPIO input muxing signals and interrupts. */
+	uint64_t fil_cnt                      : 4;  /**< Filter count. Specifies the number of consecutive samples (FIL_CNT+1) to change state.
+                                                         Zero to disable the filter.
+                                                         Filter are XOR inverter are also appliable to GPIO input muxing signals and interrupts. */
 	uint64_t int_type                     : 1;  /**< Type of interrupt
                                                          0 = level (default)
                                                          1 = rising edge */
@@ -452,6 +509,7 @@ union cvmx_gpio_bit_cfgx {
 #endif
 	} cn70xx;
 	struct cvmx_gpio_bit_cfgx_cn70xx      cn70xxp1;
+	struct cvmx_gpio_bit_cfgx_cn70xx      cn73xx;
 	struct cvmx_gpio_bit_cfgx_cn70xx      cn78xx;
 	struct cvmx_gpio_bit_cfgx_cn61xx      cnf71xx;
 };
@@ -509,6 +567,7 @@ union cvmx_gpio_clk_genx {
 	struct cvmx_gpio_clk_genx_s           cn68xxp1;
 	struct cvmx_gpio_clk_genx_s           cn70xx;
 	struct cvmx_gpio_clk_genx_s           cn70xxp1;
+	struct cvmx_gpio_clk_genx_s           cn73xx;
 	struct cvmx_gpio_clk_genx_s           cn78xx;
 	struct cvmx_gpio_clk_genx_s           cnf71xx;
 };
@@ -669,18 +728,19 @@ union cvmx_gpio_clk_syncex {
 #endif
 	} cn70xx;
 	struct cvmx_gpio_clk_syncex_cn70xx    cn70xxp1;
-	struct cvmx_gpio_clk_syncex_cn78xx {
+	struct cvmx_gpio_clk_syncex_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t qlm_sel                      : 4;  /**< Selects which QLM(0..7) to select from. */
+	uint64_t qlm_sel                      : 4;  /**< Selects which QLM(0..3) or DLM(4..6) to select from, value 7-15 are invalid. */
 	uint64_t reserved_4_7                 : 4;
-	uint64_t div                          : 2;  /**< GPIO internal clock divider setting relative to QLM SERDES CLOCK_SYNCE. The maximum
+	uint64_t div                          : 2;  /**< GPIO internal clock divider setting relative to QLM/DLM SERDES CLOCK_SYNCE. The maximum
                                                          supported GPIO output frequency is 125 MHz.
                                                          0x0 = Divide by 20.
                                                          0x1 = Divide by 40.
                                                          0x2 = Divide by 80.
                                                          0x3 = Divide by 160. */
-	uint64_t lane_sel                     : 2;  /**< Selects which RX lane clock from QLMx to use as the GPIO internal QLMx clock. */
+	uint64_t lane_sel                     : 2;  /**< Selects which RX lane clock from QLMx(DLMx) to use as the GPIO internal QLMx(DLMx) clock.
+                                                         For DLMx, valid LANE_SEL is 0/1. */
 #else
 	uint64_t lane_sel                     : 2;
 	uint64_t div                          : 2;
@@ -688,7 +748,8 @@ union cvmx_gpio_clk_syncex {
 	uint64_t qlm_sel                      : 4;
 	uint64_t reserved_12_63               : 52;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_gpio_clk_syncex_cn73xx    cn78xx;
 };
 typedef union cvmx_gpio_clk_syncex cvmx_gpio_clk_syncex_t;
 
@@ -716,6 +777,7 @@ union cvmx_gpio_comp {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_gpio_comp_s               cn73xx;
 	struct cvmx_gpio_comp_s               cn78xx;
 };
 typedef union cvmx_gpio_comp cvmx_gpio_comp_t;
@@ -790,6 +852,22 @@ union cvmx_gpio_intrx {
 	uint64_t u64;
 	struct cvmx_gpio_intrx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t intr_w1s                     : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to set, otherwise
+                                                         will clear automatically when GPIO pin de-asserts. Read out value is INTR.
+                                                         GPIO_INTR(4..7)[INTR_W1S] can also introduce GPIO_MC_INTR(4..7) when multicast mode is
+                                                         enabled. */
+	uint64_t intr                         : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to clear, otherwise
+                                                         will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(). */
+#else
+	uint64_t intr                         : 1;
+	uint64_t intr_w1s                     : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_gpio_intrx_s              cn73xx;
+	struct cvmx_gpio_intrx_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t intr                         : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to clear, otherwise
                                                          will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(). */
@@ -797,8 +875,7 @@ union cvmx_gpio_intrx {
 	uint64_t intr                         : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
-	} s;
-	struct cvmx_gpio_intrx_s              cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_gpio_intrx cvmx_gpio_intrx_t;
 
@@ -822,11 +899,44 @@ union cvmx_gpio_mc_intrx {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_gpio_mc_intrx_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t intr                         : 16; /**< GPIO interrupt for each core. When corresponding GPIO4-7 is edge-triggered and MILTI_CAST
+                                                         is enabled, a GPIO assertion will set all 48 bits. Each bit is expected to be routed to
+                                                         interrupt a different core using the CIU, and each core will then write one to clear its
+                                                         corresponding bit in this register. Throws GPIO_INTSN_E::GPIO_MC_INTR()_PP(). */
+#else
+	uint64_t intr                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_gpio_mc_intrx_s           cn78xx;
 };
 typedef union cvmx_gpio_mc_intrx cvmx_gpio_mc_intrx_t;
 
 /**
+ * cvmx_gpio_mc_intr#_w1s
+ */
+union cvmx_gpio_mc_intrx_w1s {
+	uint64_t u64;
+	struct cvmx_gpio_mc_intrx_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t intr                         : 16; /**< GPIO interrupt for each core. When corresponding GPIO4-7 is edge-triggered and MILTI_CAST
+                                                         is enabled, a GPIO assertion will set all 48 bits. Each bit is expected to be routed to
+                                                         interrupt a different core using the CIU, and each core will then write one to clear its
+                                                         corresponding bit in this register. Throws GPIO_INTSN_E::GPIO_MC_INTR()_PP(). */
+#else
+	uint64_t intr                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gpio_mc_intrx_w1s_s       cn73xx;
+};
+typedef union cvmx_gpio_mc_intrx_w1s cvmx_gpio_mc_intrx_w1s_t;
+
+/**
  * cvmx_gpio_multi_cast
  *
  * This register enables multicast GPIO interrupts.
@@ -852,6 +962,7 @@ union cvmx_gpio_multi_cast {
 	struct cvmx_gpio_multi_cast_s         cn61xx;
 	struct cvmx_gpio_multi_cast_s         cn70xx;
 	struct cvmx_gpio_multi_cast_s         cn70xxp1;
+	struct cvmx_gpio_multi_cast_s         cn73xx;
 	struct cvmx_gpio_multi_cast_s         cn78xx;
 	struct cvmx_gpio_multi_cast_s         cnf71xx;
 };
@@ -876,6 +987,7 @@ union cvmx_gpio_ocla_exten_trig {
 	} s;
 	struct cvmx_gpio_ocla_exten_trig_s    cn70xx;
 	struct cvmx_gpio_ocla_exten_trig_s    cn70xxp1;
+	struct cvmx_gpio_ocla_exten_trig_s    cn73xx;
 	struct cvmx_gpio_ocla_exten_trig_s    cn78xx;
 };
 typedef union cvmx_gpio_ocla_exten_trig cvmx_gpio_ocla_exten_trig_t;
@@ -919,15 +1031,23 @@ union cvmx_gpio_rx_dat {
 	uint64_t u64;
 	struct cvmx_gpio_rx_dat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t dat                          : 32; /**< GPIO Read Data */
+#else
+	uint64_t dat                          : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gpio_rx_dat_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_24_63               : 40;
 	uint64_t dat                          : 24; /**< GPIO Read Data */
 #else
 	uint64_t dat                          : 24;
 	uint64_t reserved_24_63               : 40;
 #endif
-	} s;
-	struct cvmx_gpio_rx_dat_s             cn30xx;
-	struct cvmx_gpio_rx_dat_s             cn31xx;
+	} cn30xx;
+	struct cvmx_gpio_rx_dat_cn30xx        cn31xx;
 	struct cvmx_gpio_rx_dat_cn38xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
@@ -938,7 +1058,7 @@ union cvmx_gpio_rx_dat {
 #endif
 	} cn38xx;
 	struct cvmx_gpio_rx_dat_cn38xx        cn38xxp2;
-	struct cvmx_gpio_rx_dat_s             cn50xx;
+	struct cvmx_gpio_rx_dat_cn30xx        cn50xx;
 	struct cvmx_gpio_rx_dat_cn38xx        cn52xx;
 	struct cvmx_gpio_rx_dat_cn38xx        cn52xxp1;
 	struct cvmx_gpio_rx_dat_cn38xx        cn56xx;
@@ -961,6 +1081,7 @@ union cvmx_gpio_rx_dat {
 	struct cvmx_gpio_rx_dat_cn38xx        cn68xxp1;
 	struct cvmx_gpio_rx_dat_cn61xx        cn70xx;
 	struct cvmx_gpio_rx_dat_cn61xx        cn70xxp1;
+	struct cvmx_gpio_rx_dat_s             cn73xx;
 	struct cvmx_gpio_rx_dat_cn61xx        cn78xx;
 	struct cvmx_gpio_rx_dat_cn61xx        cnf71xx;
 };
@@ -1007,6 +1128,51 @@ union cvmx_gpio_sata_ctl {
 typedef union cvmx_gpio_sata_ctl cvmx_gpio_sata_ctl_t;
 
 /**
+ * cvmx_gpio_sata_ctl#
+ */
+union cvmx_gpio_sata_ctlx {
+	uint64_t u64;
+	struct cvmx_gpio_sata_ctlx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_13_63               : 51;
+	uint64_t mp_switch                    : 5;  /**< Selects the GPIO(0..31) input pin for SATA mechanical presence switch input;
+                                                         indicated the state of external device presence switch, (0) switch open,
+                                                         (1) switch closed. See SATA()_UAHC_p0_CMD[MPSS]. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t cp_det                       : 5;  /**< Selects the GPIO(0..31) input pin for SATA cold presence detect input;
+                                                         detects addition (1) or removal (0) of the powered-down device;
+                                                         see SATA()_UAHC_p0_CMD[CPS]. */
+#else
+	uint64_t cp_det                       : 5;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t mp_switch                    : 5;
+	uint64_t reserved_13_63               : 51;
+#endif
+	} s;
+	struct cvmx_gpio_sata_ctlx_s          cn73xx;
+};
+typedef union cvmx_gpio_sata_ctlx cvmx_gpio_sata_ctlx_t;
+
+/**
+ * cvmx_gpio_sata_lab_lb
+ */
+union cvmx_gpio_sata_lab_lb {
+	uint64_t u64;
+	struct cvmx_gpio_sata_lab_lb_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t sel                          : 5;  /**< Selects the GPIO(0..31) input pin for SATA BIST lab-loopback pin.
+                                                         see TBD. */
+#else
+	uint64_t sel                          : 5;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_gpio_sata_lab_lb_s        cn73xx;
+};
+typedef union cvmx_gpio_sata_lab_lb cvmx_gpio_sata_lab_lb_t;
+
+/**
  * cvmx_gpio_tim_ctl
  */
 union cvmx_gpio_tim_ctl {
@@ -1030,6 +1196,7 @@ union cvmx_gpio_tim_ctl {
 #endif
 	} cn68xx;
 	struct cvmx_gpio_tim_ctl_cn68xx       cn68xxp1;
+	struct cvmx_gpio_tim_ctl_s            cn73xx;
 	struct cvmx_gpio_tim_ctl_s            cn78xx;
 };
 typedef union cvmx_gpio_tim_ctl cvmx_gpio_tim_ctl_t;
@@ -1041,17 +1208,25 @@ union cvmx_gpio_tx_clr {
 	uint64_t u64;
 	struct cvmx_gpio_tx_clr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_24_63               : 40;
-	uint64_t clr                          : 24; /**< Bit mask to indicate which GPIO_TX_DAT bits to set
+	uint64_t reserved_32_63               : 32;
+	uint64_t clr                          : 32; /**< Bit mask to indicate which GPIO_TX_DAT bits to set
                                                          to '0'. When read, CLR returns the GPIO_TX_DAT
                                                          storage. */
 #else
+	uint64_t clr                          : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gpio_tx_clr_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t clr                          : 24; /**< Bit mask to indicate which bits to drive to '0'. */
+#else
 	uint64_t clr                          : 24;
 	uint64_t reserved_24_63               : 40;
 #endif
-	} s;
-	struct cvmx_gpio_tx_clr_s             cn30xx;
-	struct cvmx_gpio_tx_clr_s             cn31xx;
+	} cn30xx;
+	struct cvmx_gpio_tx_clr_cn30xx        cn31xx;
 	struct cvmx_gpio_tx_clr_cn38xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
@@ -1062,7 +1237,7 @@ union cvmx_gpio_tx_clr {
 #endif
 	} cn38xx;
 	struct cvmx_gpio_tx_clr_cn38xx        cn38xxp2;
-	struct cvmx_gpio_tx_clr_s             cn50xx;
+	struct cvmx_gpio_tx_clr_cn30xx        cn50xx;
 	struct cvmx_gpio_tx_clr_cn38xx        cn52xx;
 	struct cvmx_gpio_tx_clr_cn38xx        cn52xxp1;
 	struct cvmx_gpio_tx_clr_cn38xx        cn56xx;
@@ -1087,6 +1262,7 @@ union cvmx_gpio_tx_clr {
 	struct cvmx_gpio_tx_clr_cn38xx        cn68xxp1;
 	struct cvmx_gpio_tx_clr_cn61xx        cn70xx;
 	struct cvmx_gpio_tx_clr_cn61xx        cn70xxp1;
+	struct cvmx_gpio_tx_clr_s             cn73xx;
 	struct cvmx_gpio_tx_clr_cn61xx        cn78xx;
 	struct cvmx_gpio_tx_clr_cn61xx        cnf71xx;
 };
@@ -1099,17 +1275,25 @@ union cvmx_gpio_tx_set {
 	uint64_t u64;
 	struct cvmx_gpio_tx_set_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_24_63               : 40;
-	uint64_t set                          : 24; /**< Bit mask to indicate which GPIO_TX_DAT bits to set
+	uint64_t reserved_32_63               : 32;
+	uint64_t set                          : 32; /**< Bit mask to indicate which GPIO_TX_DAT bits to set
                                                          to '1'. When read, SET returns the GPIO_TX_DAT
                                                          storage. */
 #else
+	uint64_t set                          : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gpio_tx_set_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t set                          : 24; /**< Bit mask to indicate which bits to drive to '1'. */
+#else
 	uint64_t set                          : 24;
 	uint64_t reserved_24_63               : 40;
 #endif
-	} s;
-	struct cvmx_gpio_tx_set_s             cn30xx;
-	struct cvmx_gpio_tx_set_s             cn31xx;
+	} cn30xx;
+	struct cvmx_gpio_tx_set_cn30xx        cn31xx;
 	struct cvmx_gpio_tx_set_cn38xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
@@ -1120,7 +1304,7 @@ union cvmx_gpio_tx_set {
 #endif
 	} cn38xx;
 	struct cvmx_gpio_tx_set_cn38xx        cn38xxp2;
-	struct cvmx_gpio_tx_set_s             cn50xx;
+	struct cvmx_gpio_tx_set_cn30xx        cn50xx;
 	struct cvmx_gpio_tx_set_cn38xx        cn52xx;
 	struct cvmx_gpio_tx_set_cn38xx        cn52xxp1;
 	struct cvmx_gpio_tx_set_cn38xx        cn56xx;
@@ -1145,12 +1329,31 @@ union cvmx_gpio_tx_set {
 	struct cvmx_gpio_tx_set_cn38xx        cn68xxp1;
 	struct cvmx_gpio_tx_set_cn61xx        cn70xx;
 	struct cvmx_gpio_tx_set_cn61xx        cn70xxp1;
+	struct cvmx_gpio_tx_set_s             cn73xx;
 	struct cvmx_gpio_tx_set_cn61xx        cn78xx;
 	struct cvmx_gpio_tx_set_cn61xx        cnf71xx;
 };
 typedef union cvmx_gpio_tx_set cvmx_gpio_tx_set_t;
 
 /**
+ * cvmx_gpio_usbdrd_ctl#
+ */
+union cvmx_gpio_usbdrd_ctlx {
+	uint64_t u64;
+	struct cvmx_gpio_usbdrd_ctlx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t sel                          : 5;  /**< Selects the GPIO(0..31) input pin for USBDRD over-current control. */
+#else
+	uint64_t sel                          : 5;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_gpio_usbdrd_ctlx_s        cn73xx;
+};
+typedef union cvmx_gpio_usbdrd_ctlx cvmx_gpio_usbdrd_ctlx_t;
+
+/**
  * cvmx_gpio_usbh_ctl
  *
  * Select GPIO0-19 received data (GPIO_RX_DAT[DAT]) routing to USB.
@@ -1302,8 +1505,11 @@ union cvmx_gpio_xbit_cfgx {
                                                            0x1a-  : Reserved.
                                                          Note: GPIO[19:10] controls are ignored if PCM is enabled.  See PCM(0..3)_TDM_CFG */
 	uint64_t reserved_12_15               : 4;
-	uint64_t fil_sel                      : 4;  /**< Global counter bit-select (controls sample rate) */
-	uint64_t fil_cnt                      : 4;  /**< Number of consecutive samples to change state */
+	uint64_t fil_sel                      : 4;  /**< Filter select. Global counter bit-select (controls sample rate).
+                                                         Filter are XOR inverter are also appliable to GPIO input muxing signals and interrupts. */
+	uint64_t fil_cnt                      : 4;  /**< Filter count. Specifies the number of consecutive samples (FIL_CNT+1) to change state.
+                                                         Zero to disable the filter.
+                                                         Filter are XOR inverter are also appliable to GPIO input muxing signals and interrupts. */
 	uint64_t int_type                     : 1;  /**< Type of interrupt
                                                          0 = level (default)
                                                          1 = rising edge */
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index a95e311..62f87b3 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -53,31 +53,34 @@
 #define __CVMX_GSERX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_ANA_ATEST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_ANA_ATEST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_ANA_ATEST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000800ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_ANA_ATEST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000800ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_ANA_ATEST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000800ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_ANA_ATEST(offset) (CVMX_ADD_IO_SEG(0x0001180090000800ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_ANA_SEL(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_ANA_SEL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_ANA_SEL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000808ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_ANA_SEL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000808ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_ANA_SEL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000808ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_ANA_SEL(offset) (CVMX_ADD_IO_SEG(0x0001180090000808ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_BR_RXX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_RXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000400ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -89,6 +92,7 @@ static inline uint64_t CVMX_GSERX_BR_RXX_CTL(unsigned long offset, unsigned long
 static inline uint64_t CVMX_GSERX_BR_RXX_EER(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_RXX_EER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000418ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -100,6 +104,7 @@ static inline uint64_t CVMX_GSERX_BR_RXX_EER(unsigned long offset, unsigned long
 static inline uint64_t CVMX_GSERX_BR_TXX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000420ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -111,6 +116,7 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CTL(unsigned long offset, unsigned long
 static inline uint64_t CVMX_GSERX_BR_TXX_CUR(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_CUR(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000438ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -119,26 +125,39 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CUR(unsigned long offset, unsigned long
 #define CVMX_GSERX_BR_TXX_CUR(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090000438ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_CFG(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_BR_TXX_TAP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000080ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_BR_TXX_TAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000440ull) + (((offset) & 3) + ((block_id) & 7) * 0x20000ull) * 128;
 }
 #else
-#define CVMX_GSERX_CFG(block_id) (CVMX_ADD_IO_SEG(0x0001180090000080ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_BR_TXX_TAP(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090000440ull) + (((offset) & 3) + ((block_id) & 7) * 0x20000ull) * 128)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_DBG(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_DBG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000098ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_CFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000080ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_DBG(block_id) (CVMX_ADD_IO_SEG(0x0001180090000098ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_CFG(offset) (CVMX_ADD_IO_SEG(0x0001180090000080ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_DBG(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_DBG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000098ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_DBG(offset) (CVMX_ADD_IO_SEG(0x0001180090000098ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_DLMX_LOOPBK_EN(unsigned long offset, unsigned long block_id)
@@ -493,64 +512,70 @@ static inline uint64_t CVMX_GSERX_DLMX_TX_TERM_OFFSET(unsigned long offset, unsi
 #define CVMX_GSERX_DLMX_TX_TERM_OFFSET(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090003040ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 524288)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_EQ_WAIT_TIME(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_EQ_WAIT_TIME(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_EQ_WAIT_TIME(block_id) (CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_EQ_WAIT_TIME(offset) (CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_GLBL_PLL_MONITOR(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_GLBL_PLL_MONITOR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_GLBL_PLL_MONITOR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460100ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_GLBL_PLL_MONITOR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460100ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_GLBL_PLL_MONITOR(block_id) (CVMX_ADD_IO_SEG(0x0001180090460100ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_GLBL_PLL_MONITOR(offset) (CVMX_ADD_IO_SEG(0x0001180090460100ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_GLBL_TAD(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_GLBL_TAD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_GLBL_TAD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460400ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_GLBL_TAD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460400ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_GLBL_TAD(block_id) (CVMX_ADD_IO_SEG(0x0001180090460400ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_GLBL_TAD(offset) (CVMX_ADD_IO_SEG(0x0001180090460400ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_GLBL_TM_ADMON(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_GLBL_TM_ADMON(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_GLBL_TM_ADMON(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460408ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_GLBL_TM_ADMON(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460408ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_GLBL_TM_ADMON(block_id) (CVMX_ADD_IO_SEG(0x0001180090460408ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_GLBL_TM_ADMON(offset) (CVMX_ADD_IO_SEG(0x0001180090460408ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_IDDQ_MODE(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_IDDQ_MODE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_IDDQ_MODE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000018ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_IDDQ_MODE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000018ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_IDDQ_MODE(block_id) (CVMX_ADD_IO_SEG(0x0001180090000018ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_IDDQ_MODE(offset) (CVMX_ADD_IO_SEG(0x0001180090000018ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_LBERT_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0020ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -562,6 +587,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_CFG(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_LBERT_ECNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_ECNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0028ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -573,6 +599,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_ECNT(unsigned long offset, unsigne
 static inline uint64_t CVMX_GSERX_LANEX_LBERT_PAT_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_PAT_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -584,6 +611,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_PAT_CFG(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -595,6 +623,7 @@ static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_0(unsigned long offset, unsigne
 static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -606,6 +635,7 @@ static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_1(unsigned long offset, unsigne
 static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -617,6 +647,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_0(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0068ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -628,6 +659,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_1(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0070ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -639,6 +671,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_2(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -650,6 +683,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(unsigned long offset,
 static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PWR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -658,20 +692,10 @@ static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL(unsigned long offset, unsigned
 #define CVMX_GSERX_LANEX_PWR_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904400D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL_P2(unsigned long offset, unsigned long block_id)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
-		cvmx_warn("CVMX_GSERX_LANEX_PWR_CTRL_P2(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904600B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
-}
-#else
-#define CVMX_GSERX_LANEX_PWR_CTRL_P2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904600B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440280ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -683,6 +707,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440288ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -694,6 +719,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_1(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440290ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -705,6 +731,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_2(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440038ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -716,6 +743,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_1(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440040ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -727,6 +755,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_2(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440208ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -738,6 +767,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(unsigned long offset,
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -749,6 +779,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_1(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -760,6 +791,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_2(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -771,6 +803,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_0(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -782,6 +815,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_1(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440010ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -793,6 +827,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_2(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_3(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -804,6 +839,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_3(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_4(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440020ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -815,6 +851,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_4(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_5(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440028ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -826,6 +863,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_5(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CTLE_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440058ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -837,6 +875,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_LOOP_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_LOOP_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440048ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -848,6 +887,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_LOOP_CTRL(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_MISC_OVRRD(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440258ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -859,6 +899,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -870,6 +911,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_VAL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_VAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440078ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -881,6 +923,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_VAL(unsigned long offset, uns
 static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440240ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -892,6 +935,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(unsigned long offset, u
 static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440248ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -903,6 +947,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(unsigned long offset, u
 static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440250ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -914,6 +959,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(unsigned long offset, u
 static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440200ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -925,6 +971,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_CTRL(unsigned long offset, unsign
 static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -936,6 +983,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_0(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -944,9 +992,43 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_1(unsigned long offset, un
 #define CVMX_GSERX_LANEX_RX_VMA_STATUS_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_0(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400A8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -958,6 +1040,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_0(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400B0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -969,6 +1052,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_1(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -980,6 +1064,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_2(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_3(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -991,6 +1076,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_3(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -999,42 +1085,46 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(unsigned long offset, un
 #define CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904400C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_LPBKEN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_LPBKEN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_LPBKEN(block_id) (CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_LPBKEN(offset) (CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_MODE(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_MODE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_MODE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_MODE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_MODE(block_id) (CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_MODE(offset) (CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_POFF(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_POFF(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_POFF(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_POFF(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_POFF(block_id) (CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_POFF(offset) (CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANE_PX_MODE_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0040ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1046,6 +1136,7 @@ static inline uint64_t CVMX_GSERX_LANE_PX_MODE_0(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANE_PX_MODE_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0048ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1054,92 +1145,99 @@ static inline uint64_t CVMX_GSERX_LANE_PX_MODE_1(unsigned long offset, unsigned
 #define CVMX_GSERX_LANE_PX_MODE_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E0048ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_SRST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_SRST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_SRST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_SRST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_SRST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_SRST(offset) (CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(offset) (CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(offset) (CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(offset) (CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_0(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_VMA_FINE_CTRL_0(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_FINE_CTRL_0(offset) (CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_1(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_VMA_FINE_CTRL_1(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_FINE_CTRL_1(offset) (CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_2(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_LANE_VMA_FINE_CTRL_2(block_id) (CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_LANE_VMA_FINE_CTRL_2(offset) (CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_PCS_CLK_REQ(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_PCS_CLK_REQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_PCS_CLK_REQ(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_PCS_CLK_REQ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080478ull);
 }
 #else
-#define CVMX_GSERX_PCIE_PCS_CLK_REQ(block_id) (CVMX_ADD_IO_SEG(0x0001180090080478ull))
+#define CVMX_GSERX_PCIE_PCS_CLK_REQ(offset) (CVMX_ADD_IO_SEG(0x0001180090080478ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_PCIE_PIPEX_TXDEEMPH(unsigned long offset, unsigned long block_id)
@@ -1153,147 +1251,147 @@ static inline uint64_t CVMX_GSERX_PCIE_PIPEX_TXDEEMPH(unsigned long offset, unsi
 #define CVMX_GSERX_PCIE_PIPEX_TXDEEMPH(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090080480ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_PIPE_COM_CLK(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_PIPE_COM_CLK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_PIPE_COM_CLK(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_PIPE_COM_CLK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080470ull);
 }
 #else
-#define CVMX_GSERX_PCIE_PIPE_COM_CLK(block_id) (CVMX_ADD_IO_SEG(0x0001180090080470ull))
+#define CVMX_GSERX_PCIE_PIPE_COM_CLK(offset) (CVMX_ADD_IO_SEG(0x0001180090080470ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_PIPE_CRST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_PIPE_CRST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_PIPE_CRST(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_PIPE_CRST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080458ull);
 }
 #else
-#define CVMX_GSERX_PCIE_PIPE_CRST(block_id) (CVMX_ADD_IO_SEG(0x0001180090080458ull))
+#define CVMX_GSERX_PCIE_PIPE_CRST(offset) (CVMX_ADD_IO_SEG(0x0001180090080458ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_PIPE_PORT_LOOPBK(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_PIPE_PORT_LOOPBK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_PIPE_PORT_LOOPBK(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_PIPE_PORT_LOOPBK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080468ull);
 }
 #else
-#define CVMX_GSERX_PCIE_PIPE_PORT_LOOPBK(block_id) (CVMX_ADD_IO_SEG(0x0001180090080468ull))
+#define CVMX_GSERX_PCIE_PIPE_PORT_LOOPBK(offset) (CVMX_ADD_IO_SEG(0x0001180090080468ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_PIPE_PORT_SEL(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_PIPE_PORT_SEL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_PIPE_PORT_SEL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_PIPE_PORT_SEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080460ull);
 }
 #else
-#define CVMX_GSERX_PCIE_PIPE_PORT_SEL(block_id) (CVMX_ADD_IO_SEG(0x0001180090080460ull))
+#define CVMX_GSERX_PCIE_PIPE_PORT_SEL(offset) (CVMX_ADD_IO_SEG(0x0001180090080460ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_PIPE_RST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_PIPE_RST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_PIPE_RST(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_PIPE_RST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080448ull);
 }
 #else
-#define CVMX_GSERX_PCIE_PIPE_RST(block_id) (CVMX_ADD_IO_SEG(0x0001180090080448ull))
+#define CVMX_GSERX_PCIE_PIPE_RST(offset) (CVMX_ADD_IO_SEG(0x0001180090080448ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_PIPE_RST_STS(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_PIPE_RST_STS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_PIPE_RST_STS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_PIPE_RST_STS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080450ull);
 }
 #else
-#define CVMX_GSERX_PCIE_PIPE_RST_STS(block_id) (CVMX_ADD_IO_SEG(0x0001180090080450ull))
+#define CVMX_GSERX_PCIE_PIPE_RST_STS(offset) (CVMX_ADD_IO_SEG(0x0001180090080450ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_PIPE_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_PIPE_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_PIPE_STATUS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_PIPE_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080400ull);
 }
 #else
-#define CVMX_GSERX_PCIE_PIPE_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180090080400ull))
+#define CVMX_GSERX_PCIE_PIPE_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180090080400ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_TX_DEEMPH_GEN1(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_TX_DEEMPH_GEN1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_TX_DEEMPH_GEN1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_TX_DEEMPH_GEN1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080408ull);
 }
 #else
-#define CVMX_GSERX_PCIE_TX_DEEMPH_GEN1(block_id) (CVMX_ADD_IO_SEG(0x0001180090080408ull))
+#define CVMX_GSERX_PCIE_TX_DEEMPH_GEN1(offset) (CVMX_ADD_IO_SEG(0x0001180090080408ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_3P5DB(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_3P5DB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_3P5DB(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_3P5DB(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080410ull);
 }
 #else
-#define CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_3P5DB(block_id) (CVMX_ADD_IO_SEG(0x0001180090080410ull))
+#define CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_3P5DB(offset) (CVMX_ADD_IO_SEG(0x0001180090080410ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_6DB(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_6DB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_6DB(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_6DB(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080418ull);
 }
 #else
-#define CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_6DB(block_id) (CVMX_ADD_IO_SEG(0x0001180090080418ull))
+#define CVMX_GSERX_PCIE_TX_DEEMPH_GEN2_6DB(offset) (CVMX_ADD_IO_SEG(0x0001180090080418ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_TX_SWING_FULL(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_TX_SWING_FULL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_TX_SWING_FULL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_TX_SWING_FULL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080420ull);
 }
 #else
-#define CVMX_GSERX_PCIE_TX_SWING_FULL(block_id) (CVMX_ADD_IO_SEG(0x0001180090080420ull))
+#define CVMX_GSERX_PCIE_TX_SWING_FULL(offset) (CVMX_ADD_IO_SEG(0x0001180090080420ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_TX_SWING_LOW(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_TX_SWING_LOW(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_TX_SWING_LOW(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_TX_SWING_LOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080428ull);
 }
 #else
-#define CVMX_GSERX_PCIE_TX_SWING_LOW(block_id) (CVMX_ADD_IO_SEG(0x0001180090080428ull))
+#define CVMX_GSERX_PCIE_TX_SWING_LOW(offset) (CVMX_ADD_IO_SEG(0x0001180090080428ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PCIE_TX_VBOOST_LVL(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PCIE_TX_VBOOST_LVL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_PCIE_TX_VBOOST_LVL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_PCIE_TX_VBOOST_LVL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090080440ull);
 }
 #else
-#define CVMX_GSERX_PCIE_TX_VBOOST_LVL(block_id) (CVMX_ADD_IO_SEG(0x0001180090080440ull))
+#define CVMX_GSERX_PCIE_TX_VBOOST_LVL(offset) (CVMX_ADD_IO_SEG(0x0001180090080440ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_PHYX_IDCODE_HI(unsigned long offset, unsigned long block_id)
@@ -1505,31 +1603,34 @@ static inline uint64_t CVMX_GSERX_PHYX_OVRD_IN_LO(unsigned long offset, unsigned
 #define CVMX_GSERX_PHYX_OVRD_IN_LO(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090400088ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 524288)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PHY_CTL(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PHY_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_PHY_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000000ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_PHY_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000000ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_PHY_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000000ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_PHY_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000000ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PIPE_LPBK(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PIPE_LPBK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_PIPE_LPBK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_PIPE_LPBK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_PIPE_LPBK(block_id) (CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_PIPE_LPBK(offset) (CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_PLL_PX_MODE_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_PLL_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0030ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1541,6 +1642,7 @@ static inline uint64_t CVMX_GSERX_PLL_PX_MODE_0(unsigned long offset, unsigned l
 static inline uint64_t CVMX_GSERX_PLL_PX_MODE_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_PLL_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0038ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1549,136 +1651,219 @@ static inline uint64_t CVMX_GSERX_PLL_PX_MODE_1(unsigned long offset, unsigned l
 #define CVMX_GSERX_PLL_PX_MODE_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E0038ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_PLL_STAT(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_PLL_STAT(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_PLL_STAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000010ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_PLL_STAT(offset) (CVMX_ADD_IO_SEG(0x0001180090000010ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_QLM_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_PLL_STAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000010ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_QLM_STAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800900000A0ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_PLL_STAT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000010ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_QLM_STAT(offset) (CVMX_ADD_IO_SEG(0x00011800900000A0ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_QLM_STAT(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_RDET_TIME(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_QLM_STAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800900000A0ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RDET_TIME(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904E0008ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_QLM_STAT(block_id) (CVMX_ADD_IO_SEG(0x00011800900000A0ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_RDET_TIME(offset) (CVMX_ADD_IO_SEG(0x00011800904E0008ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_RDET_TIME(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_REFCLK_EVT_CNTR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_RDET_TIME(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904E0008ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6)))))
+		cvmx_warn("CVMX_GSERX_REFCLK_EVT_CNTR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000178ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_RDET_TIME(block_id) (CVMX_ADD_IO_SEG(0x00011800904E0008ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_REFCLK_EVT_CNTR(offset) (CVMX_ADD_IO_SEG(0x0001180090000178ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_REFCLK_SEL(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_REFCLK_EVT_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_REFCLK_SEL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000008ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6)))))
+		cvmx_warn("CVMX_GSERX_REFCLK_EVT_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000170ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_REFCLK_SEL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000008ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_REFCLK_EVT_CTRL(offset) (CVMX_ADD_IO_SEG(0x0001180090000170ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_RX_COAST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_REFCLK_SEL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_RX_COAST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000138ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_REFCLK_SEL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000008ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_RX_COAST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000138ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_REFCLK_SEL(offset) (CVMX_ADD_IO_SEG(0x0001180090000008ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_RX_EIE_DETEN(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_RX_COAST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_RX_EIE_DETEN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000148ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_COAST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000138ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_RX_EIE_DETEN(block_id) (CVMX_ADD_IO_SEG(0x0001180090000148ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_RX_COAST(offset) (CVMX_ADD_IO_SEG(0x0001180090000138ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_RX_EIE_DETSTS(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_RX_EIE_DETEN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_RX_EIE_DETSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000150ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_EIE_DETEN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000148ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_RX_EIE_DETSTS(block_id) (CVMX_ADD_IO_SEG(0x0001180090000150ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_RX_EIE_DETEN(offset) (CVMX_ADD_IO_SEG(0x0001180090000148ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_RX_EIE_FILTER(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_RX_EIE_DETSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_RX_EIE_FILTER(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000158ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_EIE_DETSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000150ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_RX_EIE_FILTER(block_id) (CVMX_ADD_IO_SEG(0x0001180090000158ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_RX_EIE_DETSTS(offset) (CVMX_ADD_IO_SEG(0x0001180090000150ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_RX_POLARITY(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_RX_EIE_FILTER(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_RX_POLARITY(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000160ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_EIE_FILTER(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000158ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_RX_POLARITY(block_id) (CVMX_ADD_IO_SEG(0x0001180090000160ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_RX_EIE_FILTER(offset) (CVMX_ADD_IO_SEG(0x0001180090000158ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P1(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_RX_POLARITY(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800904600B0ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_POLARITY(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000160ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_RX_PWR_CTRL_P1(block_id) (CVMX_ADD_IO_SEG(0x00011800904600B0ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_RX_POLARITY(offset) (CVMX_ADD_IO_SEG(0x0001180090000160ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_CFG(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_CFG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904600B0ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_RX_PWR_CTRL_P1(offset) (CVMX_ADD_IO_SEG(0x00011800904600B0ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P2(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904600B8ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_RX_PWR_CTRL_P2(offset) (CVMX_ADD_IO_SEG(0x00011800904600B8ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SATA_CFG(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_SATA_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090100208ull);
 }
 #else
-#define CVMX_GSERX_SATA_CFG(block_id) (CVMX_ADD_IO_SEG(0x0001180090100208ull))
+#define CVMX_GSERX_SATA_CFG(offset) (CVMX_ADD_IO_SEG(0x0001180090100208ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SATA_LANEX_TX_AMPX(unsigned long a, unsigned long b, unsigned long c)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2))))))
+		cvmx_warn("CVMX_GSERX_SATA_LANEX_TX_AMPX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
+	return CVMX_ADD_IO_SEG(0x0001180090000B00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3);
+}
+#else
+#define CVMX_GSERX_SATA_LANEX_TX_AMPX(a, b, c) (CVMX_ADD_IO_SEG(0x0001180090000B00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_LANE_RST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_LANEX_TX_PREEMPHX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_LANE_RST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090100210ull);
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2))))))
+		cvmx_warn("CVMX_GSERX_SATA_LANEX_TX_PREEMPHX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
+	return CVMX_ADD_IO_SEG(0x0001180090000A00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3);
+}
+#else
+#define CVMX_GSERX_SATA_LANEX_TX_PREEMPHX(a, b, c) (CVMX_ADD_IO_SEG(0x0001180090000A00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SATA_LANE_RST(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180090100210ull) + ((offset) & 0) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 6))
+				return CVMX_ADD_IO_SEG(0x0001180090000908ull) + ((offset) & 7) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_GSERX_SATA_LANE_RST (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000908ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SATA_LANE_RST(block_id) (CVMX_ADD_IO_SEG(0x0001180090100210ull))
+static inline uint64_t CVMX_GSERX_SATA_LANE_RST(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090100210ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090000908ull) + (offset) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180090000908ull) + (offset) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SATA_P0_TX_AMP_GENX(unsigned long offset, unsigned long block_id)
@@ -1725,97 +1910,133 @@ static inline uint64_t CVMX_GSERX_SATA_P1_TX_PREEMPH_GENX(unsigned long offset,
 #define CVMX_GSERX_SATA_P1_TX_PREEMPH_GENX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090100420ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_REF_SSP_EN(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_REF_SSP_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_REF_SSP_EN(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_SATA_REF_SSP_EN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090100600ull);
 }
 #else
-#define CVMX_GSERX_SATA_REF_SSP_EN(block_id) (CVMX_ADD_IO_SEG(0x0001180090100600ull))
+#define CVMX_GSERX_SATA_REF_SSP_EN(offset) (CVMX_ADD_IO_SEG(0x0001180090100600ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_RX_INVERT(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_RX_INVERT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_RX_INVERT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_SATA_RX_INVERT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090100218ull);
 }
 #else
-#define CVMX_GSERX_SATA_RX_INVERT(block_id) (CVMX_ADD_IO_SEG(0x0001180090100218ull))
+#define CVMX_GSERX_SATA_RX_INVERT(offset) (CVMX_ADD_IO_SEG(0x0001180090100218ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_SSC_CLK_SEL(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_SSC_CLK_SEL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_SSC_CLK_SEL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_SATA_SSC_CLK_SEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090100238ull);
 }
 #else
-#define CVMX_GSERX_SATA_SSC_CLK_SEL(block_id) (CVMX_ADD_IO_SEG(0x0001180090100238ull))
+#define CVMX_GSERX_SATA_SSC_CLK_SEL(offset) (CVMX_ADD_IO_SEG(0x0001180090100238ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_SSC_EN(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_SSC_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_SSC_EN(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_SATA_SSC_EN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090100228ull);
 }
 #else
-#define CVMX_GSERX_SATA_SSC_EN(block_id) (CVMX_ADD_IO_SEG(0x0001180090100228ull))
+#define CVMX_GSERX_SATA_SSC_EN(offset) (CVMX_ADD_IO_SEG(0x0001180090100228ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_SSC_RANGE(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_SSC_RANGE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_SSC_RANGE(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_GSERX_SATA_SSC_RANGE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090100230ull);
 }
 #else
-#define CVMX_GSERX_SATA_SSC_RANGE(block_id) (CVMX_ADD_IO_SEG(0x0001180090100230ull))
+#define CVMX_GSERX_SATA_SSC_RANGE(offset) (CVMX_ADD_IO_SEG(0x0001180090100230ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_STATUS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090100200ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180090100200ull) + ((offset) & 0) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 6))
+				return CVMX_ADD_IO_SEG(0x0001180090100900ull) + ((offset) & 7) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_GSERX_SATA_STATUS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090100900ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SATA_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180090100200ull))
+static inline uint64_t CVMX_GSERX_SATA_STATUS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090100200ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090100900ull) + (offset) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180090100900ull) + (offset) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_TX_INVERT(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_TX_INVERT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_TX_INVERT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090100220ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180090100220ull) + ((offset) & 0) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 6))
+				return CVMX_ADD_IO_SEG(0x0001180090000910ull) + ((offset) & 7) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_GSERX_SATA_TX_INVERT (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000910ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SATA_TX_INVERT(block_id) (CVMX_ADD_IO_SEG(0x0001180090100220ull))
+static inline uint64_t CVMX_GSERX_SATA_TX_INVERT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090100220ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090000910ull) + (offset) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180090000910ull) + (offset) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_SCRATCH(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_SCRATCH(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SCRATCH(block_id) (CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_SCRATCH(offset) (CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_RX_SDLL_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090460220ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
@@ -1824,48 +2045,74 @@ static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsi
 #define CVMX_GSERX_SLICEX_RX_SDLL_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460220ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_SLICE_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460060ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_SLICE_CFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460060ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SLICE_CFG(block_id) (CVMX_ADD_IO_SEG(0x0001180090460060ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_SLICE_CFG(offset) (CVMX_ADD_IO_SEG(0x0001180090460060ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SPD(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SPD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_SPD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000088ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_SPD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000088ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SPD(block_id) (CVMX_ADD_IO_SEG(0x0001180090000088ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_SPD(offset) (CVMX_ADD_IO_SEG(0x0001180090000088ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SRST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SRST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_SRST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000090ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_SRST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000090ull) + ((offset) & 15) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SRST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000090ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_SRST(offset) (CVMX_ADD_IO_SEG(0x0001180090000090ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_TX_VBOOST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_TXCLK_EVT_CNTR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
-		cvmx_warn("CVMX_GSERX_TX_VBOOST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000130ull) + ((block_id) & 15) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6)))))
+		cvmx_warn("CVMX_GSERX_TXCLK_EVT_CNTR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000188ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_TX_VBOOST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000130ull) + ((block_id) & 15) * 0x1000000ull)
+#define CVMX_GSERX_TXCLK_EVT_CNTR(offset) (CVMX_ADD_IO_SEG(0x0001180090000188ull) + ((offset) & 7) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_TXCLK_EVT_CTRL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6)))))
+		cvmx_warn("CVMX_GSERX_TXCLK_EVT_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000180ull) + ((offset) & 7) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_TXCLK_EVT_CTRL(offset) (CVMX_ADD_IO_SEG(0x0001180090000180ull) + ((offset) & 7) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_TX_VBOOST(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_TX_VBOOST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000130ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_TX_VBOOST(offset) (CVMX_ADD_IO_SEG(0x0001180090000130ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 
 /**
@@ -1890,6 +2137,7 @@ union cvmx_gserx_ana_atest {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_gserx_ana_atest_s         cn73xx;
 	struct cvmx_gserx_ana_atest_s         cn78xx;
 };
 typedef union cvmx_gserx_ana_atest cvmx_gserx_ana_atest_t;
@@ -1911,6 +2159,7 @@ union cvmx_gserx_ana_sel {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_gserx_ana_sel_s           cn73xx;
 	struct cvmx_gserx_ana_sel_s           cn78xx;
 };
 typedef union cvmx_gserx_ana_sel cvmx_gserx_ana_sel_t;
@@ -1946,6 +2195,7 @@ union cvmx_gserx_br_rxx_ctl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_gserx_br_rxx_ctl_s        cn73xx;
 	struct cvmx_gserx_br_rxx_ctl_s        cn78xx;
 };
 typedef union cvmx_gserx_br_rxx_ctl cvmx_gserx_br_rxx_ctl_t;
@@ -1990,6 +2240,7 @@ union cvmx_gserx_br_rxx_eer {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_br_rxx_eer_s        cn73xx;
 	struct cvmx_gserx_br_rxx_eer_s        cn78xx;
 };
 typedef union cvmx_gserx_br_rxx_eer cvmx_gserx_br_rxx_eer_t;
@@ -2009,6 +2260,7 @@ union cvmx_gserx_br_txx_ctl {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_br_txx_ctl_s        cn73xx;
 	struct cvmx_gserx_br_txx_ctl_s        cn78xx;
 };
 typedef union cvmx_gserx_br_txx_ctl cvmx_gserx_br_txx_ctl_t;
@@ -2033,17 +2285,78 @@ union cvmx_gserx_br_txx_cur {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_br_txx_cur_s        cn73xx;
 	struct cvmx_gserx_br_txx_cur_s        cn78xx;
 };
 typedef union cvmx_gserx_br_txx_cur cvmx_gserx_br_txx_cur_t;
 
 /**
+ * cvmx_gser#_br_tx#_tap
+ */
+union cvmx_gserx_br_txx_tap {
+	uint64_t u64;
+	struct cvmx_gserx_br_txx_tap_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t txt_pre                      : 4;  /**< After TX Base-R Link Training, this is the resultant POST Tap value that was
+                                                         written to the PHY.  This field has no meaning if TX Base-R Link Traning was
+                                                         not performed.
+                                                         For diagnostic use only. */
+	uint64_t txt_swing                    : 5;  /**< After TX Base-R Link Training, this is the resultant SWING Tap value that was
+                                                         written to the PHY.  This field has no meaning if TX Base-R Link Traning was
+                                                         not performed.
+                                                         For diagnostic use only. */
+	uint64_t txt_post                     : 5;  /**< After TX Base-R Link Training, this is the resultant POST Tap value that was
+                                                         written to the PHY.  This field has no meaning if TX Base-R Link Traning was
+                                                         not performed.
+                                                         For diagnostic use only. */
+#else
+	uint64_t txt_post                     : 5;
+	uint64_t txt_swing                    : 5;
+	uint64_t txt_pre                      : 4;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_br_txx_tap_s        cn73xx;
+};
+typedef union cvmx_gserx_br_txx_tap cvmx_gserx_br_txx_tap_t;
+
+/**
  * cvmx_gser#_cfg
  */
 union cvmx_gserx_cfg {
 	uint64_t u64;
 	struct cvmx_gserx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_6_63                : 58;
+	uint64_t sata                         : 1;  /**< Indicates the GSER is configured for SATA mode. Only one of the BGX, SATA, or PCIE
+                                                         modes can be set at any one time. */
+	uint64_t bgx_quad                     : 1;  /**< For non-CCPI links, indicates the BGX is in quad aggregation mode when GSER()_CFG[BGX]
+                                                         is also set. A single controller is used for all four lanes. For CCPI links, this bit has
+                                                         no meaning. */
+	uint64_t bgx_dual                     : 1;  /**< For non-CCPI links, indicates the BGX is in dual aggregation mode when GSER()_CFG[BGX]
+                                                         is also set. A single controller is used for lanes 0 and 1 and another controller is used
+                                                         for lanes 2 and 3. For CCPI links, this bit has no meaning. */
+	uint64_t bgx                          : 1;  /**< For non-CCPI links, indicates the GSER is configured for BGX mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For CCPI links, this bit has no meaning. */
+	uint64_t ila                          : 1;  /**< For non-CCPI links, indicates the GSER is configured for ILK/ILA mode. For CCPI links this
+                                                         bit will be set. Only one of the BGX, ILA, or PCIE modes can be set at any one time. For
+                                                         CCPI links, this bit has no meaning. */
+	uint64_t pcie                         : 1;  /**< For non-CCPI links, indicates the GSER is configured for PCIE mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For CCPI links, this bit has no meaning. */
+#else
+	uint64_t pcie                         : 1;
+	uint64_t ila                          : 1;
+	uint64_t bgx                          : 1;
+	uint64_t bgx_dual                     : 1;
+	uint64_t bgx_quad                     : 1;
+	uint64_t sata                         : 1;
+	uint64_t reserved_6_63                : 58;
+#endif
+	} s;
+	struct cvmx_gserx_cfg_s               cn73xx;
+	struct cvmx_gserx_cfg_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t bgx_quad                     : 1;  /**< For non-CCPI links, indicates the BGX is in quad aggregation mode when GSER()_CFG[BGX]
                                                          is also set. A single controller is used for all four lanes. For CCPI links, this bit has
@@ -2066,8 +2379,7 @@ union cvmx_gserx_cfg {
 	uint64_t bgx_quad                     : 1;
 	uint64_t reserved_5_63                : 59;
 #endif
-	} s;
-	struct cvmx_gserx_cfg_s               cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_gserx_cfg cvmx_gserx_cfg_t;
 
@@ -2086,6 +2398,7 @@ union cvmx_gserx_dbg {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_dbg_s               cn73xx;
 	struct cvmx_gserx_dbg_s               cn78xx;
 };
 typedef union cvmx_gserx_dbg cvmx_gserx_dbg_t;
@@ -2969,6 +3282,7 @@ union cvmx_gserx_eq_wait_time {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_gserx_eq_wait_time_s      cn73xx;
 	struct cvmx_gserx_eq_wait_time_s      cn78xx;
 };
 typedef union cvmx_gserx_eq_wait_time cvmx_gserx_eq_wait_time_t;
@@ -3002,6 +3316,7 @@ union cvmx_gserx_glbl_pll_monitor {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_glbl_pll_monitor_s  cn73xx;
 	struct cvmx_gserx_glbl_pll_monitor_s  cn78xx;
 };
 typedef union cvmx_gserx_glbl_pll_monitor cvmx_gserx_glbl_pll_monitor_t;
@@ -3070,6 +3385,7 @@ union cvmx_gserx_glbl_tad {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_gserx_glbl_tad_s          cn73xx;
 	struct cvmx_gserx_glbl_tad_s          cn78xx;
 };
 typedef union cvmx_gserx_glbl_tad cvmx_gserx_glbl_tad_t;
@@ -3103,6 +3419,7 @@ union cvmx_gserx_glbl_tm_admon {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_gserx_glbl_tm_admon_s     cn73xx;
 	struct cvmx_gserx_glbl_tm_admon_s     cn78xx;
 };
 typedef union cvmx_gserx_glbl_tm_admon cvmx_gserx_glbl_tm_admon_t;
@@ -3124,6 +3441,7 @@ union cvmx_gserx_iddq_mode {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_iddq_mode_s         cn73xx;
 	struct cvmx_gserx_iddq_mode_s         cn78xx;
 };
 typedef union cvmx_gserx_iddq_mode cvmx_gserx_iddq_mode_t;
@@ -3198,6 +3516,7 @@ union cvmx_gserx_lanex_lbert_cfg {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_lbert_cfg_s   cn73xx;
 	struct cvmx_gserx_lanex_lbert_cfg_s   cn78xx;
 };
 typedef union cvmx_gserx_lanex_lbert_cfg cvmx_gserx_lanex_lbert_cfg_t;
@@ -3228,6 +3547,7 @@ union cvmx_gserx_lanex_lbert_ecnt {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_lbert_ecnt_s  cn73xx;
 	struct cvmx_gserx_lanex_lbert_ecnt_s  cn78xx;
 };
 typedef union cvmx_gserx_lanex_lbert_ecnt cvmx_gserx_lanex_lbert_ecnt_t;
@@ -3251,6 +3571,7 @@ union cvmx_gserx_lanex_lbert_pat_cfg {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_lbert_pat_cfg_s cn73xx;
 	struct cvmx_gserx_lanex_lbert_pat_cfg_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_lbert_pat_cfg cvmx_gserx_lanex_lbert_pat_cfg_t;
@@ -3297,6 +3618,7 @@ union cvmx_gserx_lanex_misc_cfg_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_misc_cfg_0_s  cn73xx;
 	struct cvmx_gserx_lanex_misc_cfg_0_s  cn78xx;
 };
 typedef union cvmx_gserx_lanex_misc_cfg_0 cvmx_gserx_lanex_misc_cfg_0_t;
@@ -3335,7 +3657,32 @@ union cvmx_gserx_lanex_misc_cfg_1 {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
-	struct cvmx_gserx_lanex_misc_cfg_1_s  cn78xx;
+	struct cvmx_gserx_lanex_misc_cfg_1_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_13_63               : 51;
+	uint64_t par_tx_init                  : 1;  /**< Performs parallel initialization of SerDes interface TX
+                                                         fifo pointers. */
+	uint64_t tx_polarity                  : 1;  /**< Invert polarity of trasmitted bit stream.  Inversion is
+                                                         performed in the SerDes interface transmit datapth. */
+	uint64_t rx_polarity_ovrrd_en         : 1;  /**< Override mac_pcs_rxX_polarity control pin values
+                                                         When set, RX polarity inversion is specified from
+                                                         RX_POLARITY_OVRRD_VAL, and mac_pcs_rxX_polarity is ignored. */
+	uint64_t rx_polarity_ovrrd_val        : 1;  /**< Controls RX polarity inversion when RX_POLARITY_OVRRD_EN
+                                                         is set. Inversion is performed in the SerDes interface receive
+                                                         datapath. */
+	uint64_t reserved_8_2                 : 7;
+	uint64_t mac_tx_fifo_rd_ptr_ival      : 2;  /**< Initial value for MAC to PCS TX FIFO read pointer. */
+#else
+	uint64_t mac_tx_fifo_rd_ptr_ival      : 2;
+	uint64_t reserved_8_2                 : 7;
+	uint64_t rx_polarity_ovrrd_val        : 1;
+	uint64_t rx_polarity_ovrrd_en         : 1;
+	uint64_t tx_polarity                  : 1;
+	uint64_t par_tx_init                  : 1;
+	uint64_t reserved_13_63               : 51;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_misc_cfg_1_cn73xx cn78xx;
 };
 typedef union cvmx_gserx_lanex_misc_cfg_1 cvmx_gserx_lanex_misc_cfg_1_t;
 
@@ -3367,7 +3714,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_0 {
                                                          is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_MODE_OVRRD_EN].
                                                          0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
-                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (for PCIe Gen3 8Gb only).
                                                          0x3 = 20-bit raw data. */
 	uint64_t cfg_tx_pstate_req_ovrrd_val  : 2;  /**< Override TX pstate request when its override bit
                                                          is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_EN]. */
@@ -3386,6 +3733,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_0 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn73xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_0 cvmx_gserx_lanex_pcs_ctlifc_0_t;
@@ -3418,6 +3766,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_1 {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn73xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_1 cvmx_gserx_lanex_pcs_ctlifc_1_t;
@@ -3479,6 +3828,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn73xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_2 cvmx_gserx_lanex_pcs_ctlifc_2_t;
@@ -3503,6 +3853,7 @@ union cvmx_gserx_lanex_pma_loopback_ctrl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pma_loopback_ctrl cvmx_gserx_lanex_pma_loopback_ctrl_t;
@@ -3580,58 +3931,12 @@ union cvmx_gserx_lanex_pwr_ctrl {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pwr_ctrl_s    cn73xx;
 	struct cvmx_gserx_lanex_pwr_ctrl_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_pwr_ctrl cvmx_gserx_lanex_pwr_ctrl_t;
 
 /**
- * cvmx_gser#_lane#_pwr_ctrl_p2
- *
- * These registers are for diagnostic use only.
- * These registers are reset by hardware only during chip cold reset.
- * The values of the CSR fields in these registers do not change during chip warm or soft resets.
- */
-union cvmx_gserx_lanex_pwr_ctrl_p2 {
-	uint64_t u64;
-	struct cvmx_gserx_lanex_pwr_ctrl_p2_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_14_63               : 50;
-	uint64_t p2_rx_resetn                 : 1;  /**< Place the reciever in reset (active low). */
-	uint64_t p2_rx_allow_pll_pd           : 1;  /**< When asserted, it permits PLL powerdown (PLL is
-                                                         powered down if all other factors permit). */
-	uint64_t p2_rx_pcs_reset              : 1;  /**< When asserted, the RX Power state machine puts the Raw PCS
-                                                         RX logic in reset state to save power. */
-	uint64_t p2_rx_agc_en                 : 1;  /**< AGC enable. */
-	uint64_t p2_rx_dfe_en                 : 1;  /**< DFE enable. */
-	uint64_t p2_rx_cdr_en                 : 1;  /**< CDR enable. */
-	uint64_t p2_rx_cdr_coast              : 1;  /**< CDR coast; freezes the frequency of the CDR. */
-	uint64_t p2_rx_cdr_clr                : 1;  /**< CDR clear; clears the frequency register in the CDR. */
-	uint64_t p2_rx_subblk_pd              : 5;  /**< RX sub-block powerdown to RX:
-                                                         <4> = CTLE.
-                                                         <3> = Reserved.
-                                                         <2> = Lane DLL.
-                                                         <1> = DFE/Samplers.
-                                                         <0> = Termination. */
-	uint64_t p2_rx_chpd                   : 1;  /**< RX lane power down. */
-#else
-	uint64_t p2_rx_chpd                   : 1;
-	uint64_t p2_rx_subblk_pd              : 5;
-	uint64_t p2_rx_cdr_clr                : 1;
-	uint64_t p2_rx_cdr_coast              : 1;
-	uint64_t p2_rx_cdr_en                 : 1;
-	uint64_t p2_rx_dfe_en                 : 1;
-	uint64_t p2_rx_agc_en                 : 1;
-	uint64_t p2_rx_pcs_reset              : 1;
-	uint64_t p2_rx_allow_pll_pd           : 1;
-	uint64_t p2_rx_resetn                 : 1;
-	uint64_t reserved_14_63               : 50;
-#endif
-	} s;
-	struct cvmx_gserx_lanex_pwr_ctrl_p2_s cn78xx;
-};
-typedef union cvmx_gserx_lanex_pwr_ctrl_p2 cvmx_gserx_lanex_pwr_ctrl_p2_t;
-
-/**
  * cvmx_gser#_lane#_rx_aeq_out_0
  *
  * These registers are for diagnostic use only.
@@ -3650,6 +3955,7 @@ union cvmx_gserx_lanex_rx_aeq_out_0 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn73xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_0 cvmx_gserx_lanex_rx_aeq_out_0_t;
@@ -3674,6 +3980,7 @@ union cvmx_gserx_lanex_rx_aeq_out_1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_1 cvmx_gserx_lanex_rx_aeq_out_1_t;
@@ -3698,6 +4005,7 @@ union cvmx_gserx_lanex_rx_aeq_out_2 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn73xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_2 cvmx_gserx_lanex_rx_aeq_out_2_t;
@@ -3726,6 +4034,7 @@ union cvmx_gserx_lanex_rx_cdr_ctrl_1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_ctrl_1 cvmx_gserx_lanex_rx_cdr_ctrl_1_t;
@@ -3753,6 +4062,7 @@ union cvmx_gserx_lanex_rx_cdr_ctrl_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_ctrl_2 cvmx_gserx_lanex_rx_cdr_ctrl_2_t;
@@ -3780,6 +4090,7 @@ union cvmx_gserx_lanex_rx_cdr_misc_ctrl_0 {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_misc_ctrl_0 cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_t;
@@ -3805,6 +4116,7 @@ union cvmx_gserx_lanex_rx_cdr_status_1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_status_1 cvmx_gserx_lanex_rx_cdr_status_1_t;
@@ -3829,6 +4141,7 @@ union cvmx_gserx_lanex_rx_cdr_status_2 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_status_2 cvmx_gserx_lanex_rx_cdr_status_2_t;
@@ -3846,6 +4159,76 @@ union cvmx_gserx_lanex_rx_cfg_0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t rx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power State Machine data rate signal. */
+	uint64_t reserved_14_14               : 1;
+	uint64_t rx_resetn_ovvrd_val          : 1;  /**< This value overrides the RX Power State machine rx_resetn control
+                                                         signal when GSER()_LANE()_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
+	uint64_t pcs_sds_rx_eyemon_en         : 1;  /**< RX eyemon test enable. */
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;  /**< <11>: Reserved
+                                                         <10-8>:
+                                                           0x0 = 540mV.
+                                                           0x1 = 540mV + 20mV.
+                                                           0x2-0x3 = Reserved.
+                                                           0x4 = 100-620mV (default).
+                                                           0x5-0x7 = Reserved. */
+	uint64_t rx_datarate_ovrrd_val        : 2;  /**< Specifies the data rate when RX_DATARATE_OVRRD_EN is asserted:
+                                                         0x0 = Full rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate. */
+	uint64_t cfg_rx_pol_invert            : 1;  /**< Invert the receive data.  Allies with GSER()_LANE()_MISC_CFG_0[USE_PMA_POLARITY]
+                                                         is deasserted. */
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;  /**< Not supported. */
+#else
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;
+	uint64_t cfg_rx_pol_invert            : 1;
+	uint64_t rx_datarate_ovrrd_val        : 2;
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;
+	uint64_t pcs_sds_rx_eyemon_en         : 1;
+	uint64_t rx_resetn_ovvrd_val          : 1;
+	uint64_t reserved_14_14               : 1;
+	uint64_t rx_datarate_ovrrd_en         : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cfg_0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t rx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power State Machine data rate signal. */
+	uint64_t pcs_rx_tristate_enable       : 1;  /**< RX termination high-Z enable. */
+	uint64_t rx_resetn_ovvrd_val          : 1;  /**< This value overrides the RX Power State machine rx_resetn control
+                                                         signal when GSER()_LANE()_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
+	uint64_t pcs_sds_rx_eyemon_en         : 1;  /**< RX eyemon test enable. */
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;  /**< <11>: Reserved
+                                                         <10-8>:
+                                                           0x0 = 540mV.
+                                                           0x1 = 540mV + 20mV.
+                                                           0x2-0x3 = Reserved.
+                                                           0x4 = 100-620mV (default).
+                                                           0x5-0x7 = Reserved. */
+	uint64_t rx_datarate_ovrrd_val        : 2;  /**< Specifies the data rate when RX_DATARATE_OVRRD_EN is asserted:
+                                                         0x0 = Full rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate. */
+	uint64_t cfg_rx_pol_invert            : 1;  /**< Invert the receive data.  Allies with GSER()_LANE()_MISC_CFG_0[USE_PMA_POLARITY]
+                                                         is deasserted. */
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;  /**< Not supported. */
+#else
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;
+	uint64_t cfg_rx_pol_invert            : 1;
+	uint64_t rx_datarate_ovrrd_val        : 2;
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;
+	uint64_t pcs_sds_rx_eyemon_en         : 1;
+	uint64_t rx_resetn_ovvrd_val          : 1;
+	uint64_t pcs_rx_tristate_enable       : 1;
+	uint64_t rx_datarate_ovrrd_en         : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_rx_cfg_0_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t rx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power State Machine data rate signal. */
 	uint64_t pcs_sds_rx_tristate_enable   : 1;  /**< RX termination high-Z enable. */
 	uint64_t rx_resetn_ovvrd_val          : 1;  /**< This value overrides the RX Power State machine rx_resetn control
                                                          signal when GSER()_LANE()_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
@@ -3876,8 +4259,7 @@ union cvmx_gserx_lanex_rx_cfg_0 {
 	uint64_t rx_datarate_ovrrd_en         : 1;
 	uint64_t reserved_16_63               : 48;
 #endif
-	} s;
-	struct cvmx_gserx_lanex_rx_cfg_0_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_0 cvmx_gserx_lanex_rx_cfg_0_t;
 
@@ -3923,6 +4305,7 @@ union cvmx_gserx_lanex_rx_cfg_1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_1_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_1_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_1 cvmx_gserx_lanex_rx_cfg_1_t;
@@ -3949,11 +4332,11 @@ union cvmx_gserx_lanex_rx_cfg_2 {
 	uint64_t reserved_10_10               : 1;
 	uint64_t rx_sds_rx_agc_mval           : 10; /**< AGC manual value only used when GSERX_LANE()_RX_CFG_5[RX_AGC_MEN_OVVRD_VAL] is set.
                                                          <9:8>: Reserved.
-                                                         <7:4>: Pre-CTL gain
+                                                         <7:4>: Pre-CTLE (continuous time linear equalizer) gain:
                                                          - 0 = -6dB
                                                          - 1 = -5dB
                                                          - 3 = +5dB.
-                                                         <3:0>: Post-CTL gain (steps of 0.0875)
+                                                         <3:0>: Post-CTLE gain (steps of 0.0875):
                                                          - 0x0 = lowest
                                                          - 0xf = lowest * 2.3125. */
 #else
@@ -3965,6 +4348,7 @@ union cvmx_gserx_lanex_rx_cfg_2 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_2_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_2_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_2 cvmx_gserx_lanex_rx_cfg_2_t;
@@ -4000,6 +4384,7 @@ union cvmx_gserx_lanex_rx_cfg_3 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_3_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_3_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_3 cvmx_gserx_lanex_rx_cfg_3_t;
@@ -4035,6 +4420,7 @@ union cvmx_gserx_lanex_rx_cfg_4 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_4_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_4_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_4 cvmx_gserx_lanex_rx_cfg_4_t;
@@ -4067,6 +4453,7 @@ union cvmx_gserx_lanex_rx_cfg_5 {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_5_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_5_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_5 cvmx_gserx_lanex_rx_cfg_5_t;
@@ -4113,6 +4500,7 @@ union cvmx_gserx_lanex_rx_ctle_ctrl {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_ctle_ctrl cvmx_gserx_lanex_rx_ctle_ctrl_t;
@@ -4149,6 +4537,7 @@ union cvmx_gserx_lanex_rx_loop_ctrl {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_loop_ctrl cvmx_gserx_lanex_rx_loop_ctrl_t;
@@ -4184,6 +4573,48 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;  /**< When asserted, pcs_sds_rx_err_det_ctrl is set
                                                          to cfg_rx_errdet_ctrl in registers
                                                          GSER()_LANE()_RX_CFG_3 and GSER()_LANE()_RX_CFG_4. */
+	uint64_t reserved_1_3                 : 3;
+	uint64_t cfg_rxeq_eval_restore_en     : 1;  /**< When asserted, AGC and CTLE use the RX EQ settings determined from RX EQ
+                                                         evaluation process when VMA is not in manual mode. Otherwise, default settings are used. */
+#else
+	uint64_t cfg_rxeq_eval_restore_en     : 1;
+	uint64_t reserved_1_3                 : 3;
+	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;
+	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;
+	uint64_t reserved_6_6                 : 1;
+	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;
+	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;
+	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;
+	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_en   : 1;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn73xx;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;  /**< Not supported. */
+	uint64_t cfg_rx_oob_clk_en_ovrrd_en   : 1;  /**< Not supported. */
+	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;  /**< Override value for RX Electrical-Idle-Exit
+                                                         Detect Enable. */
+	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;  /**< Override enable for RX Electrical-Idle-Exit
+                                                         Detect Enable. */
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;  /**< Not supported. */
+	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;  /**< Training mode control in override mode. */
+	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;  /**< Override enable for RX-EQ Eval
+                                                         When asserted, training mode is controlled by
+                                                         CFG_RX_EQ_EVAL_OVRRD_VAL. */
+	uint64_t reserved_6_6                 : 1;
+	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;  /**< When asserted, override DLL lock enable
+                                                         signal from the RX Power State machine with
+                                                         CFG_RX_DLL_LOCKEN in register
+                                                         GSER()_LANE()_RX_CFG_1. */
+	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;  /**< When asserted, pcs_sds_rx_err_det_ctrl is set
+                                                         to cfg_rx_errdet_ctrl in registers
+                                                         GSER()_LANE()_RX_CFG_3 and GSER()_LANE()_RX_CFG_4. */
 	uint64_t reserved_0_3                 : 4;
 #else
 	uint64_t reserved_0_3                 : 4;
@@ -4199,8 +4630,7 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;
 	uint64_t reserved_14_63               : 50;
 #endif
-	} s;
-	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_misc_ovrrd cvmx_gserx_lanex_rx_misc_ovrrd_t;
 
@@ -4233,6 +4663,7 @@ union cvmx_gserx_lanex_rx_precorr_ctrl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_precorr_ctrl cvmx_gserx_lanex_rx_precorr_ctrl_t;
@@ -4258,6 +4689,7 @@ union cvmx_gserx_lanex_rx_precorr_val {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_precorr_val_s cn73xx;
 	struct cvmx_gserx_lanex_rx_precorr_val_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_precorr_val cvmx_gserx_lanex_rx_precorr_val_t;
@@ -4293,6 +4725,7 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_0 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s cn73xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_0 cvmx_gserx_lanex_rx_valbbd_ctrl_0_t;
@@ -4335,6 +4768,7 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_1 cvmx_gserx_lanex_rx_valbbd_ctrl_1_t;
@@ -4386,6 +4820,7 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_2 {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s cn73xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_2 cvmx_gserx_lanex_rx_valbbd_ctrl_2_t;
@@ -4426,6 +4861,7 @@ union cvmx_gserx_lanex_rx_vma_ctrl {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_vma_ctrl cvmx_gserx_lanex_rx_vma_ctrl_t;
@@ -4451,6 +4887,7 @@ union cvmx_gserx_lanex_rx_vma_status_0 {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_vma_status_0_s cn73xx;
 	struct cvmx_gserx_lanex_rx_vma_status_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_vma_status_0 cvmx_gserx_lanex_rx_vma_status_0_t;
@@ -4468,10 +4905,10 @@ union cvmx_gserx_lanex_rx_vma_status_1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t sds_pcs_rx_vma_status        : 16; /**< <15:8>: Output is controlled by GSER()_LANE()_RX_CFG_3[CFG_RX_ERRDET_CTRL[6:5]
-                                                         0x0 = Pre-CTL gain, CTLE Peak.
-                                                         0x1 = CTL pole, SDLL_IQ.
-                                                         0x2 = Window counter[11:3].
-                                                         0x3 = Window counter[19:12] (VMA RAW FOM).
+                                                         0x0 = Window counter[19:12] (VMA RAW FOM).
+                                                         0x1 = Window counter[11:4].
+                                                         0x2 = CTLE (continous time linear equalizer) pole, SDLL_IQ.
+                                                         0x3 = Pre-CTLE gain, CTLE Peak.
                                                          <7>: Training done
                                                          <6>: Internal state machine training done
                                                          <5:3>: Internal state machine Delta
@@ -4481,11 +4918,133 @@ union cvmx_gserx_lanex_rx_vma_status_1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_vma_status_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_vma_status_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_vma_status_1 cvmx_gserx_lanex_rx_vma_status_1_t;
 
 /**
+ * cvmx_gser#_lane#_sds_pin_mon_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_sds_pin_mon_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_sds_pin_mon_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t pcs_sds_tx_widthsel          : 2;  /**< TX parallel interface width settings (RAW PCS to
+                                                         SerDes TX).
+                                                         0x0 = 8-bit raw data (not supported).
+                                                         0x1 = 10-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x3 = 20-bit raw data. */
+	uint64_t pcs_sds_rx_pcie_mode         : 1;  /**< Selects between RX terminations:
+                                                         0x0 = pcs_sds_rx_terminate_to_vdda.
+                                                         0x1 = VSS. */
+	uint64_t reserved_5_6                 : 2;
+	uint64_t pcs_sds_rx_misc_ctrl_5       : 1;  /**< Not Used. */
+	uint64_t tx_detrx_state               : 2;  /**< RX detection state:
+                                                         0x0 = IDLE.
+                                                         0x1 = Charge Up.
+                                                         0x2 = Detection.
+                                                         0x3 = Restore common mode. */
+	uint64_t pcs_sds_tx_rx_detect_dis     : 1;  /**< TX detect RX, mode disable. */
+	uint64_t pcs_sds_tx_detect_pulsen     : 1;  /**< TX detect RX, pulse enable. */
+#else
+	uint64_t pcs_sds_tx_detect_pulsen     : 1;
+	uint64_t pcs_sds_tx_rx_detect_dis     : 1;
+	uint64_t tx_detrx_state               : 2;
+	uint64_t pcs_sds_rx_misc_ctrl_5       : 1;
+	uint64_t reserved_5_6                 : 2;
+	uint64_t pcs_sds_rx_pcie_mode         : 1;
+	uint64_t pcs_sds_tx_widthsel          : 2;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_sds_pin_mon_0_s cn73xx;
+};
+typedef union cvmx_gserx_lanex_sds_pin_mon_0 cvmx_gserx_lanex_sds_pin_mon_0_t;
+
+/**
+ * cvmx_gser#_lane#_sds_pin_mon_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_sds_pin_mon_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_sds_pin_mon_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_rx_chpd              : 1;  /**< RX channel powerdown signal. */
+	uint64_t pcs_sds_rx_eie_en            : 1;  /**< Enable for electrical idle detection circuit
+                                                         in SerDes RX. */
+	uint64_t reserved_13_13               : 1;
+	uint64_t pcs_sds_ln_loopback_mode     : 1;  /**< TX to RX on chip loopback control signal. */
+	uint64_t pcs_sds_tx_chpd              : 1;  /**< TX channel powerdown signal. */
+	uint64_t pcs_sds_rx_widthsel          : 2;  /**< Width select.
+                                                         0x0 = 8-bit raw data.
+                                                         0x1 = 10-bit raw data.
+                                                         0x2 = 16-bit raw data.
+                                                         0x3 = 20-bit raw data. */
+	uint64_t reserved_8_8                 : 1;
+	uint64_t pcs_sds_tx_resetn            : 1;  /**< TX reset, active low (RAW PCS output to lane TX). */
+	uint64_t pcs_sds_tx_tristate_en       : 1;  /**< TX driver tristate enable (RAW PCS output to lane TX). */
+	uint64_t pcs_sds_tx_swing             : 5;  /**< TX swing (RAW PCS output to lane TX). */
+	uint64_t pcs_sds_tx_elec_idle         : 1;  /**< TX electrical idle control (RAW PCS output to lane TX). */
+#else
+	uint64_t pcs_sds_tx_elec_idle         : 1;
+	uint64_t pcs_sds_tx_swing             : 5;
+	uint64_t pcs_sds_tx_tristate_en       : 1;
+	uint64_t pcs_sds_tx_resetn            : 1;
+	uint64_t reserved_8_8                 : 1;
+	uint64_t pcs_sds_rx_widthsel          : 2;
+	uint64_t pcs_sds_tx_chpd              : 1;
+	uint64_t pcs_sds_ln_loopback_mode     : 1;
+	uint64_t reserved_13_13               : 1;
+	uint64_t pcs_sds_rx_eie_en            : 1;
+	uint64_t pcs_sds_rx_chpd              : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_sds_pin_mon_1_s cn73xx;
+};
+typedef union cvmx_gserx_lanex_sds_pin_mon_1 cvmx_gserx_lanex_sds_pin_mon_1_t;
+
+/**
+ * cvmx_gser#_lane#_sds_pin_mon_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_sds_pin_mon_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_sds_pin_mon_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_11_63               : 53;
+	uint64_t pcs_sds_tx_vboost_en         : 1;  /**< TX boost enable. */
+	uint64_t pcs_sds_tx_turbos_en         : 1;  /**< TX turbo mode enable signal, increases swing of TX
+                                                         through current mode. */
+	uint64_t pcs_sds_premptap             : 9;  /**< Pre-emphasis control.
+                                                         <8:4> = Post-cursor.
+                                                         <3:0> = Pre-cursor. */
+#else
+	uint64_t pcs_sds_premptap             : 9;
+	uint64_t pcs_sds_tx_turbos_en         : 1;
+	uint64_t pcs_sds_tx_vboost_en         : 1;
+	uint64_t reserved_11_63               : 53;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_sds_pin_mon_2_s cn73xx;
+};
+typedef union cvmx_gserx_lanex_sds_pin_mon_2 cvmx_gserx_lanex_sds_pin_mon_2_t;
+
+/**
  * cvmx_gser#_lane#_tx_cfg_0
  *
  * These registers are for diagnostic use only. These registers are reset by hardware only during
@@ -4521,6 +5080,7 @@ union cvmx_gserx_lanex_tx_cfg_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_cfg_0_s    cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_0_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_0 cvmx_gserx_lanex_tx_cfg_0_t;
@@ -4541,8 +5101,8 @@ union cvmx_gserx_lanex_tx_cfg_1 {
 	uint64_t tx_widthsel_ovrd_val         : 2;  /**< Override value for pcs_sds_widthsel, TX parallel interface width setting.
                                                          0x0 = 8-bit (not supported).
                                                          0x1 = 10-bit (not supported).
-                                                         0x2 = 16-bit (not supported).
-                                                         0x3 = 20-bit (not supported). */
+                                                         0x2 = 16-bit (for PCIe Gen3 8Gb only).
+                                                         0x3 = 20-bit. */
 	uint64_t tx_vboost_en_ovrrd_en        : 1;  /**< Override enable for pcs_sds_txX_vboost_en, TX  vboost mode enable. */
 	uint64_t tx_turbo_en_ovrrd_en         : 1;  /**< Override enable for pcs_sds_txX_turbo_en, Turbo mode enable. */
 	uint64_t tx_swing_ovrd_en             : 1;  /**< Override enable for pcs_sds_txX_swing, TX swing. */
@@ -4582,6 +5142,7 @@ union cvmx_gserx_lanex_tx_cfg_1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_cfg_1_s    cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_1_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_1 cvmx_gserx_lanex_tx_cfg_1_t;
@@ -4613,6 +5174,7 @@ union cvmx_gserx_lanex_tx_cfg_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_cfg_2_s    cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_2_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_2 cvmx_gserx_lanex_tx_cfg_2_t;
@@ -4644,6 +5206,7 @@ union cvmx_gserx_lanex_tx_cfg_3 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_cfg_3_s    cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_3_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_3 cvmx_gserx_lanex_tx_cfg_3_t;
@@ -4669,6 +5232,7 @@ union cvmx_gserx_lanex_tx_pre_emphasis {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn73xx;
 	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_pre_emphasis cvmx_gserx_lanex_tx_pre_emphasis_t;
@@ -4695,6 +5259,7 @@ union cvmx_gserx_lane_lpbken {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_lane_lpbken_s       cn73xx;
 	struct cvmx_gserx_lane_lpbken_s       cn78xx;
 };
 typedef union cvmx_gserx_lane_lpbken cvmx_gserx_lane_lpbken_t;
@@ -4718,14 +5283,10 @@ union cvmx_gserx_lane_mode {
                                                          0x2: R_8G_REFCLK100.
                                                          0x3: R_125G_REFCLK15625_KX (not supported).
                                                          0x4: R_3125G_REFCLK15625_XAUI.
-                                                         For XAUI applications:
                                                          0x5: R_103125G_REFCLK15625_KR.
-                                                         For XFI, XLAUI, KR applications:
                                                          0x6: R_125G_REFCLK15625_SGMII.
-                                                         For SGMII applications:
                                                          0x7: R_5G_REFCLK15625_QSGMII (not supported).
                                                          0x8: R_625G_REFCLK15625_RXAUI.
-                                                         For RXAUI, DXAUI applications:
                                                          0x9: R_25G_REFCLK125.
                                                          0xA: R_5G_REFCLK125.
                                                          0xB: R_8G_REFCLK125.
@@ -4751,6 +5312,7 @@ union cvmx_gserx_lane_mode {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_lane_mode_s         cn73xx;
 	struct cvmx_gserx_lane_mode_s         cn78xx;
 };
 typedef union cvmx_gserx_lane_mode cvmx_gserx_lane_mode_t;
@@ -4852,12 +5414,12 @@ union cvmx_gserx_lane_px_mode_0 {
 	uint64_t tx_mode                      : 2;  /**< TX data width:
                                                          0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
-                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (for PCIe Gen3 8Gb only).
                                                          0x3 = 20-bit raw data. */
 	uint64_t rx_mode                      : 2;  /**< RX data width:
                                                          0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
-                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (for PCIe Gen3 8Gb only).
                                                          0x3 = 20-bit raw data. */
 #else
 	uint64_t rx_mode                      : 2;
@@ -4871,6 +5433,7 @@ union cvmx_gserx_lane_px_mode_0 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lane_px_mode_0_s    cn73xx;
 	struct cvmx_gserx_lane_px_mode_0_s    cn78xx;
 };
 typedef union cvmx_gserx_lane_px_mode_0 cvmx_gserx_lane_px_mode_0_t;
@@ -4932,6 +5495,7 @@ union cvmx_gserx_lane_px_mode_1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lane_px_mode_1_s    cn73xx;
 	struct cvmx_gserx_lane_px_mode_1_s    cn78xx;
 };
 typedef union cvmx_gserx_lane_px_mode_1 cvmx_gserx_lane_px_mode_1_t;
@@ -4958,6 +5522,7 @@ union cvmx_gserx_lane_poff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_lane_poff_s         cn73xx;
 	struct cvmx_gserx_lane_poff_s         cn78xx;
 };
 typedef union cvmx_gserx_lane_poff cvmx_gserx_lane_poff_t;
@@ -4983,6 +5548,7 @@ union cvmx_gserx_lane_srst {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_lane_srst_s         cn73xx;
 	struct cvmx_gserx_lane_srst_s         cn78xx;
 };
 typedef union cvmx_gserx_lane_srst cvmx_gserx_lane_srst_t;
@@ -5014,6 +5580,7 @@ union cvmx_gserx_lane_vma_coarse_ctrl_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn73xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_0 cvmx_gserx_lane_vma_coarse_ctrl_0_t;
@@ -5040,6 +5607,7 @@ union cvmx_gserx_lane_vma_coarse_ctrl_1 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn73xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_1 cvmx_gserx_lane_vma_coarse_ctrl_1_t;
@@ -5066,6 +5634,7 @@ union cvmx_gserx_lane_vma_coarse_ctrl_2 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn73xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_2 cvmx_gserx_lane_vma_coarse_ctrl_2_t;
@@ -5106,6 +5675,7 @@ union cvmx_gserx_lane_vma_fine_ctrl_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn73xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_0 cvmx_gserx_lane_vma_fine_ctrl_0_t;
@@ -5135,6 +5705,7 @@ union cvmx_gserx_lane_vma_fine_ctrl_1 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn73xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_1 cvmx_gserx_lane_vma_fine_ctrl_1_t;
@@ -5164,6 +5735,7 @@ union cvmx_gserx_lane_vma_fine_ctrl_2 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn73xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_2 cvmx_gserx_lane_vma_fine_ctrl_2_t;
@@ -6308,6 +6880,7 @@ union cvmx_gserx_phy_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_gserx_phy_ctl_s           cn73xx;
 	struct cvmx_gserx_phy_ctl_s           cn78xx;
 };
 typedef union cvmx_gserx_phy_ctl cvmx_gserx_phy_ctl_t;
@@ -6328,6 +6901,7 @@ union cvmx_gserx_pipe_lpbk {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_pipe_lpbk_s         cn73xx;
 	struct cvmx_gserx_pipe_lpbk_s         cn78xx;
 };
 typedef union cvmx_gserx_pipe_lpbk cvmx_gserx_pipe_lpbk_t;
@@ -6390,6 +6964,7 @@ union cvmx_gserx_pll_px_mode_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_pll_px_mode_0_s     cn73xx;
 	struct cvmx_gserx_pll_px_mode_0_s     cn78xx;
 };
 typedef union cvmx_gserx_pll_px_mode_0 cvmx_gserx_pll_px_mode_0_t;
@@ -6463,6 +7038,7 @@ union cvmx_gserx_pll_px_mode_1 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_pll_px_mode_1_s     cn73xx;
 	struct cvmx_gserx_pll_px_mode_1_s     cn78xx;
 };
 typedef union cvmx_gserx_pll_px_mode_1 cvmx_gserx_pll_px_mode_1_t;
@@ -6481,6 +7057,7 @@ union cvmx_gserx_pll_stat {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_pll_stat_s          cn73xx;
 	struct cvmx_gserx_pll_stat_s          cn78xx;
 };
 typedef union cvmx_gserx_pll_stat cvmx_gserx_pll_stat_t;
@@ -6502,6 +7079,7 @@ union cvmx_gserx_qlm_stat {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_gserx_qlm_stat_s          cn73xx;
 	struct cvmx_gserx_qlm_stat_s          cn78xx;
 };
 typedef union cvmx_gserx_qlm_stat cvmx_gserx_qlm_stat_t;
@@ -6530,11 +7108,57 @@ union cvmx_gserx_rdet_time {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_rdet_time_s         cn73xx;
 	struct cvmx_gserx_rdet_time_s         cn78xx;
 };
 typedef union cvmx_gserx_rdet_time cvmx_gserx_rdet_time_t;
 
 /**
+ * cvmx_gser#_refclk_evt_cntr
+ */
+union cvmx_gserx_refclk_evt_cntr {
+	uint64_t u64;
+	struct cvmx_gserx_refclk_evt_cntr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t count                        : 32; /**< This register can only be reliably read when GSER()_REFCLK_EVT_CTRL[ENB]
+                                                         is clear.
+                                                         When GSER()_REFCLK_EVT_CTRL[CLR] is set, [COUNT] goes to zero.
+                                                         When GSER()_REFCLK_EVT_CTRL[ENB] is set, [COUNT] is incremented
+                                                         in positve edges of the QLM reference clock.
+                                                         When GSER()_REFCLK_EVT_CTRL[ENB] is not set, [COUNT] is held; this must
+                                                         be used when [COUNT] is being read for reliable results. */
+#else
+	uint64_t count                        : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gserx_refclk_evt_cntr_s   cn73xx;
+};
+typedef union cvmx_gserx_refclk_evt_cntr cvmx_gserx_refclk_evt_cntr_t;
+
+/**
+ * cvmx_gser#_refclk_evt_ctrl
+ */
+union cvmx_gserx_refclk_evt_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_refclk_evt_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t clr                          : 1;  /**< When set, clears GSER()_REFCLK_EVT_CNTR[COUNT]. */
+	uint64_t enb                          : 1;  /**< When set, enables the GSER()_REFCLK_EVT_CNTR[COUNT] to increment
+                                                         on positive edges of the QLM reference clock. */
+#else
+	uint64_t enb                          : 1;
+	uint64_t clr                          : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_gserx_refclk_evt_ctrl_s   cn73xx;
+};
+typedef union cvmx_gserx_refclk_evt_ctrl cvmx_gserx_refclk_evt_ctrl_t;
+
+/**
  * cvmx_gser#_refclk_sel
  *
  * This register selects the reference clock.
@@ -6562,6 +7186,7 @@ union cvmx_gserx_refclk_sel {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_gserx_refclk_sel_s        cn73xx;
 	struct cvmx_gserx_refclk_sel_s        cn78xx;
 };
 typedef union cvmx_gserx_refclk_sel cvmx_gserx_refclk_sel_t;
@@ -6592,6 +7217,7 @@ union cvmx_gserx_rx_coast {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_rx_coast_s          cn73xx;
 	struct cvmx_gserx_rx_coast_s          cn78xx;
 };
 typedef union cvmx_gserx_rx_coast cvmx_gserx_rx_coast_t;
@@ -6621,6 +7247,7 @@ union cvmx_gserx_rx_eie_deten {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_rx_eie_deten_s      cn73xx;
 	struct cvmx_gserx_rx_eie_deten_s      cn78xx;
 };
 typedef union cvmx_gserx_rx_eie_deten cvmx_gserx_rx_eie_deten_t;
@@ -6668,6 +7295,7 @@ union cvmx_gserx_rx_eie_detsts {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_gserx_rx_eie_detsts_s     cn73xx;
 	struct cvmx_gserx_rx_eie_detsts_s     cn78xx;
 };
 typedef union cvmx_gserx_rx_eie_detsts cvmx_gserx_rx_eie_detsts_t;
@@ -6702,6 +7330,7 @@ union cvmx_gserx_rx_eie_filter {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_rx_eie_filter_s     cn73xx;
 	struct cvmx_gserx_rx_eie_filter_s     cn78xx;
 };
 typedef union cvmx_gserx_rx_eie_filter cvmx_gserx_rx_eie_filter_t;
@@ -6729,6 +7358,7 @@ union cvmx_gserx_rx_polarity {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_rx_polarity_s       cn73xx;
 	struct cvmx_gserx_rx_polarity_s       cn78xx;
 };
 typedef union cvmx_gserx_rx_polarity cvmx_gserx_rx_polarity_t;
@@ -6776,11 +7406,60 @@ union cvmx_gserx_rx_pwr_ctrl_p1 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn73xx;
 	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn78xx;
 };
 typedef union cvmx_gserx_rx_pwr_ctrl_p1 cvmx_gserx_rx_pwr_ctrl_p1_t;
 
 /**
+ * cvmx_gser#_rx_pwr_ctrl_p2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_rx_pwr_ctrl_p2 {
+	uint64_t u64;
+	struct cvmx_gserx_rx_pwr_ctrl_p2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t p2_rx_resetn                 : 1;  /**< Place the reciever in reset (active low). */
+	uint64_t p2_rx_allow_pll_pd           : 1;  /**< When asserted, it permits PLL powerdown (PLL is
+                                                         powered down if all other factors permit). */
+	uint64_t p2_rx_pcs_reset              : 1;  /**< When asserted, the RX Power state machine puts the Raw PCS
+                                                         RX logic in reset state to save power. */
+	uint64_t p2_rx_agc_en                 : 1;  /**< AGC enable. */
+	uint64_t p2_rx_dfe_en                 : 1;  /**< DFE enable. */
+	uint64_t p2_rx_cdr_en                 : 1;  /**< CDR enable. */
+	uint64_t p2_rx_cdr_coast              : 1;  /**< CDR coast; freezes the frequency of the CDR. */
+	uint64_t p2_rx_cdr_clr                : 1;  /**< CDR clear; clears the frequency register in the CDR. */
+	uint64_t p2_rx_subblk_pd              : 5;  /**< RX sub-block powerdown to RX:
+                                                         <4> = CTLE.
+                                                         <3> = Reserved.
+                                                         <2> = Lane DLL.
+                                                         <1> = DFE/Samplers.
+                                                         <0> = Termination. */
+	uint64_t p2_rx_chpd                   : 1;  /**< RX lane power down. */
+#else
+	uint64_t p2_rx_chpd                   : 1;
+	uint64_t p2_rx_subblk_pd              : 5;
+	uint64_t p2_rx_cdr_clr                : 1;
+	uint64_t p2_rx_cdr_coast              : 1;
+	uint64_t p2_rx_cdr_en                 : 1;
+	uint64_t p2_rx_dfe_en                 : 1;
+	uint64_t p2_rx_agc_en                 : 1;
+	uint64_t p2_rx_pcs_reset              : 1;
+	uint64_t p2_rx_allow_pll_pd           : 1;
+	uint64_t p2_rx_resetn                 : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_rx_pwr_ctrl_p2_s    cn73xx;
+	struct cvmx_gserx_rx_pwr_ctrl_p2_s    cn78xx;
+};
+typedef union cvmx_gserx_rx_pwr_ctrl_p2 cvmx_gserx_rx_pwr_ctrl_p2_t;
+
+/**
  * cvmx_gser#_sata_cfg
  *
  * SATA Config Enable.
@@ -6803,6 +7482,59 @@ union cvmx_gserx_sata_cfg {
 typedef union cvmx_gserx_sata_cfg cvmx_gserx_sata_cfg_t;
 
 /**
+ * cvmx_gser#_sata_lane#_tx_amp#
+ *
+ * SATA lane TX launch amplitude at Gen 1, 2 and 3 speeds.
+ * * AMP(0) is for Gen1.
+ * * AMP(1) is for Gen2.
+ * * AMP(2) is for Gen3.
+ */
+union cvmx_gserx_sata_lanex_tx_ampx {
+	uint64_t u64;
+	struct cvmx_gserx_sata_lanex_tx_ampx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t tx_amp_gen                   : 7;  /**< This status value sets the Tx driver launch amplitude in the
+                                                         case where the PHY is running at the Gen1, Gen2, and Gen3
+                                                         rates. Used for tuning at the board level for Rx eye compliance.
+                                                         This register is unused for GSER(0..4). */
+#else
+	uint64_t tx_amp_gen                   : 7;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} s;
+	struct cvmx_gserx_sata_lanex_tx_ampx_s cn73xx;
+};
+typedef union cvmx_gserx_sata_lanex_tx_ampx cvmx_gserx_sata_lanex_tx_ampx_t;
+
+/**
+ * cvmx_gser#_sata_lane#_tx_preemph#
+ *
+ * SATA TX pre-emphasis at Gen 1, 2 and 3 speeds. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
+ * * PREEMPH(0) is for Gen1.
+ * * PREEMPH(1) is for Gen2.
+ * * PREEMPH(2) is for Gen3.
+ */
+union cvmx_gserx_sata_lanex_tx_preemphx {
+	uint64_t u64;
+	struct cvmx_gserx_sata_lanex_tx_preemphx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t tx_preemph                   : 7;  /**< This static value sets the Tx driver de-emphasis value in the
+                                                         case where the PHY is running at the Gen1, Gen2, and Gen3
+                                                         rates. Used for tuning at the board level for Rx eye compliance.
+                                                         This register is unused for GSER(0..4). */
+#else
+	uint64_t tx_preemph                   : 7;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} s;
+	struct cvmx_gserx_sata_lanex_tx_preemphx_s cn73xx;
+};
+typedef union cvmx_gserx_sata_lanex_tx_preemphx cvmx_gserx_sata_lanex_tx_preemphx_t;
+
+/**
  * cvmx_gser#_sata_lane_rst
  *
  * Lane Reset Control.
@@ -6813,8 +7545,10 @@ union cvmx_gserx_sata_lane_rst {
 	struct cvmx_gserx_sata_lane_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t l1_rst                       : 1;  /**< Independent reset for Lane 1. */
-	uint64_t l0_rst                       : 1;  /**< Independent reset for Lane 0. */
+	uint64_t l1_rst                       : 1;  /**< Independent reset for lane 1.
+                                                         This register is unused for GSER(0..4). */
+	uint64_t l0_rst                       : 1;  /**< Independent reset for lane 0.
+                                                         This register is unused for GSER(0..4). */
 #else
 	uint64_t l0_rst                       : 1;
 	uint64_t l1_rst                       : 1;
@@ -6823,6 +7557,7 @@ union cvmx_gserx_sata_lane_rst {
 	} s;
 	struct cvmx_gserx_sata_lane_rst_s     cn70xx;
 	struct cvmx_gserx_sata_lane_rst_s     cn70xxp1;
+	struct cvmx_gserx_sata_lane_rst_s     cn73xx;
 };
 typedef union cvmx_gserx_sata_lane_rst cvmx_gserx_sata_lane_rst_t;
 
@@ -7067,7 +7802,8 @@ union cvmx_gserx_sata_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t p1_rdy                       : 1;  /**< PHY Lane 1 is ready to send and receive data. */
-	uint64_t p0_rdy                       : 1;  /**< PHY Lane 0 is ready to send and receive data. */
+	uint64_t p0_rdy                       : 1;  /**< PHY Lane 0 is ready to send and receive data.
+                                                         This register is unused for GSER(0..4). */
 #else
 	uint64_t p0_rdy                       : 1;
 	uint64_t p1_rdy                       : 1;
@@ -7076,19 +7812,27 @@ union cvmx_gserx_sata_status {
 	} s;
 	struct cvmx_gserx_sata_status_s       cn70xx;
 	struct cvmx_gserx_sata_status_s       cn70xxp1;
+	struct cvmx_gserx_sata_status_s       cn73xx;
 };
 typedef union cvmx_gserx_sata_status cvmx_gserx_sata_status_t;
 
 /**
  * cvmx_gser#_sata_tx_invert
  *
- * SATA Transmit Polarity Inversion.
+ * TX Lane Data Invert Control.
  *
  */
 union cvmx_gserx_sata_tx_invert {
 	uint64_t u64;
 	struct cvmx_gserx_sata_tx_invert_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} s;
+	struct cvmx_gserx_sata_tx_invert_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t tx1_invert                   : 1;  /**< Instructs the PHY to perform a polarity inversion on the Lane 1
                                                           transmitted data.
@@ -7103,9 +7847,23 @@ union cvmx_gserx_sata_tx_invert {
 	uint64_t tx1_invert                   : 1;
 	uint64_t reserved_2_63                : 62;
 #endif
-	} s;
-	struct cvmx_gserx_sata_tx_invert_s    cn70xx;
-	struct cvmx_gserx_sata_tx_invert_s    cn70xxp1;
+	} cn70xx;
+	struct cvmx_gserx_sata_tx_invert_cn70xx cn70xxp1;
+	struct cvmx_gserx_sata_tx_invert_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t l1_inv                       : 1;  /**< Instructs the SATA PCS to perform a polarity inversion on the
+                                                         lane 1 transmitted data.
+                                                         This register is unused for GSER(0..4). */
+	uint64_t l0_inv                       : 1;  /**< Instructs the SATA PCS to perform a polarity inversion on the
+                                                         lane 0 transmitted data.
+                                                         This register is unused for GSER(0..4). */
+#else
+	uint64_t l0_inv                       : 1;
+	uint64_t l1_inv                       : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_gserx_sata_tx_invert cvmx_gserx_sata_tx_invert_t;
 
@@ -7126,6 +7884,7 @@ union cvmx_gserx_scratch {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_scratch_s           cn73xx;
 	struct cvmx_gserx_scratch_s           cn78xx;
 };
 typedef union cvmx_gserx_scratch cvmx_gserx_scratch_t;
@@ -7162,6 +7921,7 @@ union cvmx_gserx_slicex_rx_sdll_ctrl {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn73xx;
 	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_slicex_rx_sdll_ctrl cvmx_gserx_slicex_rx_sdll_ctrl_t;
@@ -7194,6 +7954,7 @@ union cvmx_gserx_slice_cfg {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_gserx_slice_cfg_s         cn73xx;
 	struct cvmx_gserx_slice_cfg_s         cn78xx;
 };
 typedef union cvmx_gserx_slice_cfg cvmx_gserx_slice_cfg_t;
@@ -7251,6 +8012,13 @@ union cvmx_gserx_spd {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_spd_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} cn73xx;
 	struct cvmx_gserx_spd_s               cn78xx;
 };
 typedef union cvmx_gserx_spd cvmx_gserx_spd_t;
@@ -7273,6 +8041,7 @@ union cvmx_gserx_srst {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_srst_s              cn73xx;
 	struct cvmx_gserx_srst_s              cn78xx;
 };
 typedef union cvmx_gserx_srst cvmx_gserx_srst_t;
@@ -7299,8 +8068,54 @@ union cvmx_gserx_tx_vboost {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_tx_vboost_s         cn73xx;
 	struct cvmx_gserx_tx_vboost_s         cn78xx;
 };
 typedef union cvmx_gserx_tx_vboost cvmx_gserx_tx_vboost_t;
 
+/**
+ * cvmx_gser#_txclk_evt_cntr
+ */
+union cvmx_gserx_txclk_evt_cntr {
+	uint64_t u64;
+	struct cvmx_gserx_txclk_evt_cntr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t count                        : 32; /**< This register can only be reliably read when GSER()_TXCLK_EVT_CTRL[ENB]
+                                                         is clear.
+                                                         When GSER()_TXCLK_EVT_CTRL[CLR] is set, [COUNT] goes to zero.
+                                                         When GSER()_TXCLK_EVT_CTRL[ENB] is set, [COUNT] is incremented
+                                                         in positve edges of the QLM reference clock.
+                                                         When GSER()_TXCLK_EVT_CTRL[ENB] is not set, [COUNT] value is held;
+                                                         this must be used when [COUNT] is being read for reliable results. */
+#else
+	uint64_t count                        : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gserx_txclk_evt_cntr_s    cn73xx;
+};
+typedef union cvmx_gserx_txclk_evt_cntr cvmx_gserx_txclk_evt_cntr_t;
+
+/**
+ * cvmx_gser#_txclk_evt_ctrl
+ */
+union cvmx_gserx_txclk_evt_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_txclk_evt_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t clr                          : 1;  /**< When set, clears GSER()_TXCLK_EVT_CNTR[COUNT]. */
+	uint64_t enb                          : 1;  /**< When set, enables the GSER()_TXCLK_EVT_CNTR[COUNT] to increment
+                                                         on positive edges of the QLM reference clock. */
+#else
+	uint64_t enb                          : 1;
+	uint64_t clr                          : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_gserx_txclk_evt_ctrl_s    cn73xx;
+};
+typedef union cvmx_gserx_txclk_evt_ctrl cvmx_gserx_txclk_evt_ctrl_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-board.h b/arch/mips/include/asm/octeon/cvmx-helper-board.h
index b57ff08..bfac979 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-board.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-board.h
@@ -43,7 +43,7 @@
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
  *
- * <hr>$Revision: 103898 $<hr>
+ * <hr>$Revision: 109826 $<hr>
  */
 #ifndef __CVMX_HELPER_BOARD_H__
 #define __CVMX_HELPER_BOARD_H__
@@ -65,6 +65,7 @@ typedef enum cvmx_phy_type {
 	BROADCOM_GENERIC_PHY,
 	MARVELL_GENERIC_PHY,
 	CORTINA_PHY,
+	AQUANTIA_PHY,
 	GENERIC_8023_C22_PHY,
 	GENERIC_8023_C45_PHY,
  	INBAND_PHY,
diff --git a/arch/mips/include/asm/octeon/cvmx-helper.h b/arch/mips/include/asm/octeon/cvmx-helper.h
index b23777a..f1561b0 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper.h
@@ -42,7 +42,7 @@
  *
  * Helper functions for common, but complicated tasks.
  *
- * <hr>$Revision: 106932 $<hr>
+ * <hr>$Revision: 109369 $<hr>
  */
 
 #ifndef __CVMX_HELPER_H__
@@ -281,6 +281,11 @@ extern int cvmx_helper_initialize_packet_io_local(void);
 extern int cvmx_helper_shutdown_packet_io_global(void);
 
 /**
+ * Helper function for 78xx global packet IO shutdown
+ */
+extern int cvmx_helper_shutdown_packet_io_global_cn78xx(int node);
+
+/**
  * Does core local shutdown of packet io
  *
  * @return Zero on success, non-zero on failure
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index c6bdd88..5f156d8 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_HNA_BIST0 CVMX_HNA_BIST0_FUNC()
 static inline uint64_t CVMX_HNA_BIST0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_BIST0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470007F0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_HNA_BIST0_FUNC(void)
 #define CVMX_HNA_BIST1 CVMX_HNA_BIST1_FUNC()
 static inline uint64_t CVMX_HNA_BIST1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_BIST1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470007F8ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_HNA_BIST1_FUNC(void)
 #define CVMX_HNA_CONFIG CVMX_HNA_CONFIG_FUNC()
 static inline uint64_t CVMX_HNA_CONFIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_CONFIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000000ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_HNA_CONFIG_FUNC(void)
 #define CVMX_HNA_CONTROL CVMX_HNA_CONTROL_FUNC()
 static inline uint64_t CVMX_HNA_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000020ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_HNA_CONTROL_FUNC(void)
 #define CVMX_HNA_DBELL CVMX_HNA_DBELL_FUNC()
 static inline uint64_t CVMX_HNA_DBELL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_DBELL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470000000000ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_HNA_DBELL_FUNC(void)
 #define CVMX_HNA_DIFCTL CVMX_HNA_DIFCTL_FUNC()
 static inline uint64_t CVMX_HNA_DIFCTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_DIFCTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470600000000ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_HNA_DIFCTL_FUNC(void)
 #define CVMX_HNA_DIFRDPTR CVMX_HNA_DIFRDPTR_FUNC()
 static inline uint64_t CVMX_HNA_DIFRDPTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_DIFRDPTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470200000000ull);
 }
@@ -133,7 +133,7 @@ static inline uint64_t CVMX_HNA_DIFRDPTR_FUNC(void)
 #define CVMX_HNA_ERROR CVMX_HNA_ERROR_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_ERROR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000028ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 #define CVMX_HNA_ERROR_CAPTURE_DATA CVMX_HNA_ERROR_CAPTURE_DATA_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_CAPTURE_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_ERROR_CAPTURE_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000038ull);
 }
@@ -155,7 +155,7 @@ static inline uint64_t CVMX_HNA_ERROR_CAPTURE_DATA_FUNC(void)
 #define CVMX_HNA_ERROR_CAPTURE_INFO CVMX_HNA_ERROR_CAPTURE_INFO_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_CAPTURE_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_ERROR_CAPTURE_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000030ull);
 }
@@ -166,6 +166,7 @@ static inline uint64_t CVMX_HNA_ERROR_CAPTURE_INFO_FUNC(void)
 static inline uint64_t CVMX_HNA_HNC0_RAM1X(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC0_RAM1X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400000000ull) + ((offset) & 63) * 8;
@@ -177,6 +178,7 @@ static inline uint64_t CVMX_HNA_HNC0_RAM1X(unsigned long offset)
 static inline uint64_t CVMX_HNA_HNC0_RAM2X(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC0_RAM2X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400040000ull) + ((offset) & 63) * 8;
@@ -188,6 +190,7 @@ static inline uint64_t CVMX_HNA_HNC0_RAM2X(unsigned long offset)
 static inline uint64_t CVMX_HNA_HNC1_RAM1X(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC1_RAM1X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400400000ull) + ((offset) & 63) * 8;
@@ -199,6 +202,7 @@ static inline uint64_t CVMX_HNA_HNC1_RAM1X(unsigned long offset)
 static inline uint64_t CVMX_HNA_HNC1_RAM2X(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC1_RAM2X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400440000ull) + ((offset) & 63) * 8;
@@ -210,7 +214,7 @@ static inline uint64_t CVMX_HNA_HNC1_RAM2X(unsigned long offset)
 #define CVMX_HNA_HPU_CSR CVMX_HNA_HPU_CSR_FUNC()
 static inline uint64_t CVMX_HNA_HPU_CSR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_HPU_CSR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000010ull);
 }
@@ -221,7 +225,7 @@ static inline uint64_t CVMX_HNA_HPU_CSR_FUNC(void)
 #define CVMX_HNA_HPU_DBG CVMX_HNA_HPU_DBG_FUNC()
 static inline uint64_t CVMX_HNA_HPU_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_HPU_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000008ull);
 }
@@ -232,7 +236,7 @@ static inline uint64_t CVMX_HNA_HPU_DBG_FUNC(void)
 #define CVMX_HNA_HPU_EIR CVMX_HNA_HPU_EIR_FUNC()
 static inline uint64_t CVMX_HNA_HPU_EIR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_HPU_EIR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000018ull);
 }
@@ -243,7 +247,7 @@ static inline uint64_t CVMX_HNA_HPU_EIR_FUNC(void)
 #define CVMX_HNA_PFC0_CNT CVMX_HNA_PFC0_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC0_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC0_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000090ull);
 }
@@ -254,7 +258,7 @@ static inline uint64_t CVMX_HNA_PFC0_CNT_FUNC(void)
 #define CVMX_HNA_PFC0_CTL CVMX_HNA_PFC0_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC0_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC0_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000088ull);
 }
@@ -265,7 +269,7 @@ static inline uint64_t CVMX_HNA_PFC0_CTL_FUNC(void)
 #define CVMX_HNA_PFC1_CNT CVMX_HNA_PFC1_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC1_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC1_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000A0ull);
 }
@@ -276,7 +280,7 @@ static inline uint64_t CVMX_HNA_PFC1_CNT_FUNC(void)
 #define CVMX_HNA_PFC1_CTL CVMX_HNA_PFC1_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC1_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC1_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000098ull);
 }
@@ -287,7 +291,7 @@ static inline uint64_t CVMX_HNA_PFC1_CTL_FUNC(void)
 #define CVMX_HNA_PFC2_CNT CVMX_HNA_PFC2_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC2_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC2_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000B0ull);
 }
@@ -298,7 +302,7 @@ static inline uint64_t CVMX_HNA_PFC2_CNT_FUNC(void)
 #define CVMX_HNA_PFC2_CTL CVMX_HNA_PFC2_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC2_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC2_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000A8ull);
 }
@@ -309,7 +313,7 @@ static inline uint64_t CVMX_HNA_PFC2_CTL_FUNC(void)
 #define CVMX_HNA_PFC3_CNT CVMX_HNA_PFC3_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC3_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC3_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000C0ull);
 }
@@ -320,7 +324,7 @@ static inline uint64_t CVMX_HNA_PFC3_CNT_FUNC(void)
 #define CVMX_HNA_PFC3_CTL CVMX_HNA_PFC3_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC3_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC3_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000B8ull);
 }
@@ -331,7 +335,7 @@ static inline uint64_t CVMX_HNA_PFC3_CTL_FUNC(void)
 #define CVMX_HNA_PFC_GCTL CVMX_HNA_PFC_GCTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC_GCTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC_GCTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000080ull);
 }
@@ -342,7 +346,7 @@ static inline uint64_t CVMX_HNA_PFC_GCTL_FUNC(void)
 #define CVMX_HNA_SBD_DBG0 CVMX_HNA_SBD_DBG0_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_SBD_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000040ull);
 }
@@ -353,7 +357,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG0_FUNC(void)
 #define CVMX_HNA_SBD_DBG1 CVMX_HNA_SBD_DBG1_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_SBD_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000048ull);
 }
@@ -364,7 +368,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG1_FUNC(void)
 #define CVMX_HNA_SBD_DBG2 CVMX_HNA_SBD_DBG2_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_SBD_DBG2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000050ull);
 }
@@ -375,7 +379,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG2_FUNC(void)
 #define CVMX_HNA_SBD_DBG3 CVMX_HNA_SBD_DBG3_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_SBD_DBG3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000058ull);
 }
@@ -412,6 +416,7 @@ union cvmx_hna_bist0 {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_hna_bist0_s               cn73xx;
 	struct cvmx_hna_bist0_s               cn78xx;
 };
 typedef union cvmx_hna_bist0 cvmx_hna_bist0_t;
@@ -443,6 +448,7 @@ union cvmx_hna_bist1 {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_hna_bist1_s               cn73xx;
 	struct cvmx_hna_bist1_s               cn78xx;
 };
 typedef union cvmx_hna_bist1 cvmx_hna_bist1_t;
@@ -547,6 +553,100 @@ union cvmx_hna_config {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_hna_config_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t stk_ll_dis                   : 1;  /**< Stack linked-list disable. When set, the linked-list mechanism for run stack and save
+                                                         stack structures is disabled. In this mode, the linked-list chunk boundary checking is not
+                                                         done, and therefore the previous/next pointers are non-existent. The stacks are
+                                                         effectively in an infinite linear buffer, bounded only by the maximum sizes provided in
+                                                         the instruction (IWORD3[RUNSTACKSZ] and IWORD6[SVSTACKSZ]). There is no space reserved for
+                                                         the previous and next pointers, and [STK_CHKSZ] is ignored.
+                                                         When the STK_LL_DIS is cleared, the stack linked-list mechanism operates as per spec. */
+	uint64_t reserved_23_23               : 1;
+	uint64_t stk_chksz                    : 3;  /**< Stack chunk size. This encoded value specifies the chunk size for both the RNSTK/SVSTK
+                                                         data structures. The RNSTK/SVSTK use a doubly linked list where each chunk's first two
+                                                         64-bit entries contain the previous and next chunk pointers.
+                                                         0x0 = 32 entries or 256 bytes.
+                                                         0x1 = 64 entries or 512 bytes.
+                                                         0x2 = 128 entries or 1K bytes.
+                                                         0x3 = 256 entries or 2K bytes.
+                                                         0x4 = 512 entries or 4K bytes.
+                                                         0x5 = 1024 entries or 8K bytes.
+                                                         0x6 = 2048 entries or 16K bytes.
+                                                         0x7 = 4096 entries or 32K bytes.
+                                                         NOTE: This field can only be changed at initialization/power on time before the HNA is fed
+                                                         instructions. */
+	uint64_t rnstk_lwm                    : 4;  /**< RNSTK low watermark. This field specifies the low watermark for the run stack. Valid
+                                                         range: 0-15.
+                                                         Once the run stack goes below the low watermark, HNA fills entries from the global run
+                                                         stack head to the local run stack tail. The granularity of this field is represented as
+                                                         number of 128B cachelines.
+                                                         NOTE: This field can only be changed at initialization/power on time before the HNA is fed
+                                                         instructions. */
+	uint64_t rnstk_hwm                    : 4;  /**< RNSTK high watermark. This field specifies the high watermark for the run stack. Valid
+                                                         range: 0-15.
+                                                         Once the local run stack level goes above the high watermark, the HNA spills entries from
+                                                         the local run stack tail to the global run stack head (in DDR memory). The granularity of
+                                                         this field is represented as number of 128B cachelines.
+                                                         NOTE: This field can only be changed at initialization/power on time before the HNA is fed
+                                                         instructions. */
+	uint64_t reserved_9_11                : 3;
+	uint64_t ecccordis                    : 1;  /**< ECC correction disable. When set, all HNA ECC protected data structures disable their ECC
+                                                         correction logic. When clear (default) ECC correction is always enabled. */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t clmskcrip                    : 2;  /**< Cluster cripple mask. A one in each bit of the mask represents which HPC cluster to
+                                                         cripple. CN73XX HNA has 2 clusters, where all CLMSKCRIP mask bits are used.
+                                                         Software NOTE: The MIO_FUS___HNA_CLMASK_CRIPPLE[1:0] fuse bits are forced into this
+                                                         register at reset. Any fuse bits that contain 1 are disallowed during a write and are
+                                                         always read as 1. */
+	uint64_t hpu_clcrip                   : 3;  /**< HPU cluster cripple. Encoding which represents number of HPUs to cripple for each
+                                                         cluster. Typically HPU_CLCRIP=0x0, which enables all HPUs within each cluster. However,
+                                                         when the HNA performance counters are used, software may want to limit the number of HPUs
+                                                         per cluster available, as there are only 4 parallel performance counters.
+                                                         0x0 = HPU[9:0]:ON, All engines enabled
+                                                         0x1 = HPU[9]:OFF /HPU[8:0]:ON, (n-1) engines enabled.
+                                                         0x2 = HPU[9:8]:OFF /HPU[7:0]:ON, (n-2) engines enabled.
+                                                         0x2 = HPU[9:7]:OFF /HPU[6:0]:ON, (n-3) engines enabled.
+                                                         0x3 = HPU[9:6]:OFF /HPU[5:0]:ON, (n-4) engines enabled.
+                                                         0x4 = HPU[9:5]:OFF /HPU[4:0]:ON, (n-5) engines enabled.
+                                                         0x5 = HPU[9:4]:OFF /HPU[3:0]:ON, (n-6) engines enabled.
+                                                         0x6 = HPU[9:2]:OFF /HPU[1:0]:ON, (n-8) engines enabled.
+                                                         0x7 = HPU[9:1]:OFF /HPU[0]:ON, (n-9) 1 engine enabled.
+                                                         NOTE: Higher numbered HPUs are crippled first. For instance, on CN78XX (with 10
+                                                         HPUs/cluster), if HPU_CLCRIP=0x1, then HPU numbers [9] within the cluster are
+                                                         crippled and only HPU numbers 0-8 are available.
+                                                         Software NOTE: The MIO_FUS___HNA_NUMHPU_CRIPPLE[2:0] fuse bits are forced into this
+                                                         register at reset. Any fuse bits that contain 1 are disallowed during a write and are
+                                                         always read as 1.
+                                                         INTERNAL: The encodings are done in such a way as to later be used with fuses (for future
+                                                         revisions which will disable some number of HPUs). Blowing a fuse has the effect that
+                                                         there will always be fewer HPUs available. [i.e: we never want a customer to blow
+                                                         additional fuses to get more HPUs]. */
+	uint64_t hpuclkdis                    : 1;  /**< HNA clock disable source. When set, the HNA clocks for HPU (thread engine) operation are
+                                                         disabled (to conserve overall chip clocking power when the HNA function is not used).
+                                                         NOTE: When set, software must never issue NCB-direct CSR operations to the HNA (will
+                                                         result in NCB bus timeout errors).
+                                                         NOTE: This should only be written to a different value during power-on software
+                                                         initialization.
+                                                         Software NOTE: The MIO_FUS___HNA_HPU_DISABLE fuse bit is forced into this register at
+                                                         reset. If the fuse bit contains 1, writes to HPUCLKDIS are disallowed and are always read
+                                                         as 1. */
+#else
+	uint64_t hpuclkdis                    : 1;
+	uint64_t hpu_clcrip                   : 3;
+	uint64_t clmskcrip                    : 2;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t ecccordis                    : 1;
+	uint64_t reserved_9_11                : 3;
+	uint64_t rnstk_hwm                    : 4;
+	uint64_t rnstk_lwm                    : 4;
+	uint64_t stk_chksz                    : 3;
+	uint64_t reserved_23_23               : 1;
+	uint64_t stk_ll_dis                   : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn73xx;
 	struct cvmx_hna_config_s              cn78xx;
 };
 typedef union cvmx_hna_config cvmx_hna_config_t;
@@ -595,6 +695,7 @@ union cvmx_hna_control {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_hna_control_s             cn73xx;
 	struct cvmx_hna_control_s             cn78xx;
 };
 typedef union cvmx_hna_control cvmx_hna_control_t;
@@ -627,6 +728,7 @@ union cvmx_hna_dbell {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_hna_dbell_s               cn73xx;
 	struct cvmx_hna_dbell_s               cn78xx;
 };
 typedef union cvmx_hna_dbell cvmx_hna_dbell_t;
@@ -675,6 +777,7 @@ union cvmx_hna_difctl {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_hna_difctl_s              cn73xx;
 	struct cvmx_hna_difctl_s              cn78xx;
 };
 typedef union cvmx_hna_difctl cvmx_hna_difctl_t;
@@ -709,6 +812,7 @@ union cvmx_hna_difrdptr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_hna_difrdptr_s            cn73xx;
 	struct cvmx_hna_difrdptr_s            cn78xx;
 };
 typedef union cvmx_hna_difrdptr cvmx_hna_difrdptr_t;
@@ -795,6 +899,7 @@ union cvmx_hna_error {
 	uint64_t reserved_21_63               : 43;
 #endif
 	} s;
+	struct cvmx_hna_error_s               cn73xx;
 	struct cvmx_hna_error_s               cn78xx;
 };
 typedef union cvmx_hna_error cvmx_hna_error_t;
@@ -849,6 +954,7 @@ union cvmx_hna_error_capture_data {
 	uint64_t hpu_stat                     : 64;
 #endif
 	} s;
+	struct cvmx_hna_error_capture_data_s  cn73xx;
 	struct cvmx_hna_error_capture_data_s  cn78xx;
 };
 typedef union cvmx_hna_error_capture_data cvmx_hna_error_capture_data_t;
@@ -882,6 +988,7 @@ union cvmx_hna_error_capture_info {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_hna_error_capture_info_s  cn73xx;
 	struct cvmx_hna_error_capture_info_s  cn78xx;
 };
 typedef union cvmx_hna_error_capture_info cvmx_hna_error_capture_info_t;
@@ -902,6 +1009,7 @@ union cvmx_hna_hnc0_ram1x {
 	uint64_t ram1_data                    : 64;
 #endif
 	} s;
+	struct cvmx_hna_hnc0_ram1x_s          cn73xx;
 	struct cvmx_hna_hnc0_ram1x_s          cn78xx;
 };
 typedef union cvmx_hna_hnc0_ram1x cvmx_hna_hnc0_ram1x_t;
@@ -922,6 +1030,7 @@ union cvmx_hna_hnc0_ram2x {
 	uint64_t ram2_data                    : 64;
 #endif
 	} s;
+	struct cvmx_hna_hnc0_ram2x_s          cn73xx;
 	struct cvmx_hna_hnc0_ram2x_s          cn78xx;
 };
 typedef union cvmx_hna_hnc0_ram2x cvmx_hna_hnc0_ram2x_t;
@@ -942,6 +1051,7 @@ union cvmx_hna_hnc1_ram1x {
 	uint64_t ram1_data                    : 64;
 #endif
 	} s;
+	struct cvmx_hna_hnc1_ram1x_s          cn73xx;
 	struct cvmx_hna_hnc1_ram1x_s          cn78xx;
 };
 typedef union cvmx_hna_hnc1_ram1x cvmx_hna_hnc1_ram1x_t;
@@ -962,6 +1072,7 @@ union cvmx_hna_hnc1_ram2x {
 	uint64_t ram2_data                    : 64;
 #endif
 	} s;
+	struct cvmx_hna_hnc1_ram2x_s          cn73xx;
 	struct cvmx_hna_hnc1_ram2x_s          cn78xx;
 };
 typedef union cvmx_hna_hnc1_ram2x cvmx_hna_hnc1_ram2x_t;
@@ -983,6 +1094,7 @@ union cvmx_hna_hpu_csr {
 	uint64_t csrdat                       : 64;
 #endif
 	} s;
+	struct cvmx_hna_hpu_csr_s             cn73xx;
 	struct cvmx_hna_hpu_csr_s             cn78xx;
 };
 typedef union cvmx_hna_hpu_csr cvmx_hna_hpu_csr_t;
@@ -1011,6 +1123,7 @@ union cvmx_hna_hpu_dbg {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_hna_hpu_dbg_s             cn73xx;
 	struct cvmx_hna_hpu_dbg_s             cn78xx;
 };
 typedef union cvmx_hna_hpu_dbg cvmx_hna_hpu_dbg_t;
@@ -1047,6 +1160,7 @@ union cvmx_hna_hpu_eir {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_hna_hpu_eir_s             cn73xx;
 	struct cvmx_hna_hpu_eir_s             cn78xx;
 };
 typedef union cvmx_hna_hpu_eir cvmx_hna_hpu_eir_t;
@@ -1065,6 +1179,7 @@ union cvmx_hna_pfc0_cnt {
 	uint64_t pfcnt                        : 64;
 #endif
 	} s;
+	struct cvmx_hna_pfc0_cnt_s            cn73xx;
 	struct cvmx_hna_pfc0_cnt_s            cn78xx;
 };
 typedef union cvmx_hna_pfc0_cnt cvmx_hna_pfc0_cnt_t;
@@ -1094,6 +1209,7 @@ union cvmx_hna_pfc0_ctl {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_hna_pfc0_ctl_s            cn73xx;
 	struct cvmx_hna_pfc0_ctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc0_ctl cvmx_hna_pfc0_ctl_t;
@@ -1112,6 +1228,7 @@ union cvmx_hna_pfc1_cnt {
 	uint64_t pfcnt                        : 64;
 #endif
 	} s;
+	struct cvmx_hna_pfc1_cnt_s            cn73xx;
 	struct cvmx_hna_pfc1_cnt_s            cn78xx;
 };
 typedef union cvmx_hna_pfc1_cnt cvmx_hna_pfc1_cnt_t;
@@ -1140,6 +1257,7 @@ union cvmx_hna_pfc1_ctl {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_hna_pfc1_ctl_s            cn73xx;
 	struct cvmx_hna_pfc1_ctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc1_ctl cvmx_hna_pfc1_ctl_t;
@@ -1158,6 +1276,7 @@ union cvmx_hna_pfc2_cnt {
 	uint64_t pfcnt                        : 64;
 #endif
 	} s;
+	struct cvmx_hna_pfc2_cnt_s            cn73xx;
 	struct cvmx_hna_pfc2_cnt_s            cn78xx;
 };
 typedef union cvmx_hna_pfc2_cnt cvmx_hna_pfc2_cnt_t;
@@ -1186,6 +1305,7 @@ union cvmx_hna_pfc2_ctl {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_hna_pfc2_ctl_s            cn73xx;
 	struct cvmx_hna_pfc2_ctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc2_ctl cvmx_hna_pfc2_ctl_t;
@@ -1204,6 +1324,7 @@ union cvmx_hna_pfc3_cnt {
 	uint64_t pfcnt                        : 64;
 #endif
 	} s;
+	struct cvmx_hna_pfc3_cnt_s            cn73xx;
 	struct cvmx_hna_pfc3_cnt_s            cn78xx;
 };
 typedef union cvmx_hna_pfc3_cnt cvmx_hna_pfc3_cnt_t;
@@ -1232,6 +1353,7 @@ union cvmx_hna_pfc3_ctl {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_hna_pfc3_ctl_s            cn73xx;
 	struct cvmx_hna_pfc3_ctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc3_ctl cvmx_hna_pfc3_ctl_t;
@@ -1291,6 +1413,7 @@ union cvmx_hna_pfc_gctl {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_hna_pfc_gctl_s            cn73xx;
 	struct cvmx_hna_pfc_gctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc_gctl cvmx_hna_pfc_gctl_t;
@@ -1339,6 +1462,7 @@ union cvmx_hna_sbd_dbg0 {
 	uint64_t sbd                          : 64;
 #endif
 	} s;
+	struct cvmx_hna_sbd_dbg0_s            cn73xx;
 	struct cvmx_hna_sbd_dbg0_s            cn78xx;
 };
 typedef union cvmx_hna_sbd_dbg0 cvmx_hna_sbd_dbg0_t;
@@ -1363,6 +1487,7 @@ union cvmx_hna_sbd_dbg1 {
 	uint64_t sbd                          : 64;
 #endif
 	} s;
+	struct cvmx_hna_sbd_dbg1_s            cn73xx;
 	struct cvmx_hna_sbd_dbg1_s            cn78xx;
 };
 typedef union cvmx_hna_sbd_dbg1 cvmx_hna_sbd_dbg1_t;
@@ -1387,6 +1512,7 @@ union cvmx_hna_sbd_dbg2 {
 	uint64_t sbd                          : 64;
 #endif
 	} s;
+	struct cvmx_hna_sbd_dbg2_s            cn73xx;
 	struct cvmx_hna_sbd_dbg2_s            cn78xx;
 };
 typedef union cvmx_hna_sbd_dbg2 cvmx_hna_sbd_dbg2_t;
@@ -1421,6 +1547,7 @@ union cvmx_hna_sbd_dbg3 {
 	uint64_t sbd                          : 64;
 #endif
 	} s;
+	struct cvmx_hna_sbd_dbg3_s            cn73xx;
 	struct cvmx_hna_sbd_dbg3_s            cn78xx;
 };
 typedef union cvmx_hna_sbd_dbg3 cvmx_hna_sbd_dbg3_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ila-defs.h b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
index 98f7f89..9a2698a 100644
--- a/arch/mips/include/asm/octeon/cvmx-ila-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
@@ -141,48 +141,48 @@ static inline uint64_t CVMX_ILA_RXX_BYTE_CNTX(unsigned long offset, unsigned lon
 #define CVMX_ILA_RXX_BYTE_CNTX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800170200A0ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_CFG0(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_CFG0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_CFG0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_CFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020000ull);
 }
 #else
-#define CVMX_ILA_RXX_CFG0(block_id) (CVMX_ADD_IO_SEG(0x0001180017020000ull))
+#define CVMX_ILA_RXX_CFG0(offset) (CVMX_ADD_IO_SEG(0x0001180017020000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_CFG1(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_CFG1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_CFG1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_CFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020008ull);
 }
 #else
-#define CVMX_ILA_RXX_CFG1(block_id) (CVMX_ADD_IO_SEG(0x0001180017020008ull))
+#define CVMX_ILA_RXX_CFG1(offset) (CVMX_ADD_IO_SEG(0x0001180017020008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_CHA_XON(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_CHA_XON(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_CHA_XON(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_CHA_XON(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020090ull);
 }
 #else
-#define CVMX_ILA_RXX_CHA_XON(block_id) (CVMX_ADD_IO_SEG(0x0001180017020090ull))
+#define CVMX_ILA_RXX_CHA_XON(offset) (CVMX_ADD_IO_SEG(0x0001180017020090ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_INT(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_INT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020010ull);
 }
 #else
-#define CVMX_ILA_RXX_INT(block_id) (CVMX_ADD_IO_SEG(0x0001180017020010ull))
+#define CVMX_ILA_RXX_INT(offset) (CVMX_ADD_IO_SEG(0x0001180017020010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ILA_RXX_PKT_CNTX(unsigned long offset, unsigned long block_id)
@@ -196,114 +196,114 @@ static inline uint64_t CVMX_ILA_RXX_PKT_CNTX(unsigned long offset, unsigned long
 #define CVMX_ILA_RXX_PKT_CNTX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180017020080ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT0(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020020ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT0(block_id) (CVMX_ADD_IO_SEG(0x0001180017020020ull))
+#define CVMX_ILA_RXX_STAT0(offset) (CVMX_ADD_IO_SEG(0x0001180017020020ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT1(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020028ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT1(block_id) (CVMX_ADD_IO_SEG(0x0001180017020028ull))
+#define CVMX_ILA_RXX_STAT1(offset) (CVMX_ADD_IO_SEG(0x0001180017020028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT2(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT2(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020030ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT2(block_id) (CVMX_ADD_IO_SEG(0x0001180017020030ull))
+#define CVMX_ILA_RXX_STAT2(offset) (CVMX_ADD_IO_SEG(0x0001180017020030ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT3(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT3(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020038ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT3(block_id) (CVMX_ADD_IO_SEG(0x0001180017020038ull))
+#define CVMX_ILA_RXX_STAT3(offset) (CVMX_ADD_IO_SEG(0x0001180017020038ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT4(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT4(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020040ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT4(block_id) (CVMX_ADD_IO_SEG(0x0001180017020040ull))
+#define CVMX_ILA_RXX_STAT4(offset) (CVMX_ADD_IO_SEG(0x0001180017020040ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT5(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT5(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT5(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020048ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT5(block_id) (CVMX_ADD_IO_SEG(0x0001180017020048ull))
+#define CVMX_ILA_RXX_STAT5(offset) (CVMX_ADD_IO_SEG(0x0001180017020048ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT6(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT6(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT6(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020050ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT6(block_id) (CVMX_ADD_IO_SEG(0x0001180017020050ull))
+#define CVMX_ILA_RXX_STAT6(offset) (CVMX_ADD_IO_SEG(0x0001180017020050ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT7(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT7(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT7(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020058ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT7(block_id) (CVMX_ADD_IO_SEG(0x0001180017020058ull))
+#define CVMX_ILA_RXX_STAT7(offset) (CVMX_ADD_IO_SEG(0x0001180017020058ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT8(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT8(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT8(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020060ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT8(block_id) (CVMX_ADD_IO_SEG(0x0001180017020060ull))
+#define CVMX_ILA_RXX_STAT8(offset) (CVMX_ADD_IO_SEG(0x0001180017020060ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_RXX_STAT9(unsigned long block_id)
+static inline uint64_t CVMX_ILA_RXX_STAT9(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_RXX_STAT9(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_RXX_STAT9(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020068ull);
 }
 #else
-#define CVMX_ILA_RXX_STAT9(block_id) (CVMX_ADD_IO_SEG(0x0001180017020068ull))
+#define CVMX_ILA_RXX_STAT9(offset) (CVMX_ADD_IO_SEG(0x0001180017020068ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ILA_RX_LNEX_CFG(unsigned long offset)
@@ -471,70 +471,70 @@ static inline uint64_t CVMX_ILA_TXX_BYTE_CNTX(unsigned long offset, unsigned lon
 #define CVMX_ILA_TXX_BYTE_CNTX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180017010040ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_TXX_CFG0(unsigned long block_id)
+static inline uint64_t CVMX_ILA_TXX_CFG0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_TXX_CFG0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_TXX_CFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010000ull);
 }
 #else
-#define CVMX_ILA_TXX_CFG0(block_id) (CVMX_ADD_IO_SEG(0x0001180017010000ull))
+#define CVMX_ILA_TXX_CFG0(offset) (CVMX_ADD_IO_SEG(0x0001180017010000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_TXX_CFG1(unsigned long block_id)
+static inline uint64_t CVMX_ILA_TXX_CFG1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_TXX_CFG1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_TXX_CFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010008ull);
 }
 #else
-#define CVMX_ILA_TXX_CFG1(block_id) (CVMX_ADD_IO_SEG(0x0001180017010008ull))
+#define CVMX_ILA_TXX_CFG1(offset) (CVMX_ADD_IO_SEG(0x0001180017010008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_TXX_CHA_XON(unsigned long block_id)
+static inline uint64_t CVMX_ILA_TXX_CHA_XON(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_TXX_CHA_XON(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_TXX_CHA_XON(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010088ull);
 }
 #else
-#define CVMX_ILA_TXX_CHA_XON(block_id) (CVMX_ADD_IO_SEG(0x0001180017010088ull))
+#define CVMX_ILA_TXX_CHA_XON(offset) (CVMX_ADD_IO_SEG(0x0001180017010088ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_TXX_DBG(unsigned long block_id)
+static inline uint64_t CVMX_ILA_TXX_DBG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_TXX_DBG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_TXX_DBG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010090ull);
 }
 #else
-#define CVMX_ILA_TXX_DBG(block_id) (CVMX_ADD_IO_SEG(0x0001180017010090ull))
+#define CVMX_ILA_TXX_DBG(offset) (CVMX_ADD_IO_SEG(0x0001180017010090ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_TXX_ERR_CFG(unsigned long block_id)
+static inline uint64_t CVMX_ILA_TXX_ERR_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_TXX_ERR_CFG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_TXX_ERR_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800170100A0ull);
 }
 #else
-#define CVMX_ILA_TXX_ERR_CFG(block_id) (CVMX_ADD_IO_SEG(0x00011800170100A0ull))
+#define CVMX_ILA_TXX_ERR_CFG(offset) (CVMX_ADD_IO_SEG(0x00011800170100A0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_TXX_INT(unsigned long block_id)
+static inline uint64_t CVMX_ILA_TXX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_TXX_INT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_TXX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010098ull);
 }
 #else
-#define CVMX_ILA_TXX_INT(block_id) (CVMX_ADD_IO_SEG(0x0001180017010098ull))
+#define CVMX_ILA_TXX_INT(offset) (CVMX_ADD_IO_SEG(0x0001180017010098ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ILA_TXX_PKT_CNTX(unsigned long offset, unsigned long block_id)
@@ -548,15 +548,15 @@ static inline uint64_t CVMX_ILA_TXX_PKT_CNTX(unsigned long offset, unsigned long
 #define CVMX_ILA_TXX_PKT_CNTX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180017010020ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_ILA_TXX_RMATCH(unsigned long block_id)
+static inline uint64_t CVMX_ILA_TXX_RMATCH(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_ILA_TXX_RMATCH(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_ILA_TXX_RMATCH(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010080ull);
 }
 #else
-#define CVMX_ILA_TXX_RMATCH(block_id) (CVMX_ADD_IO_SEG(0x0001180017010080ull))
+#define CVMX_ILA_TXX_RMATCH(offset) (CVMX_ADD_IO_SEG(0x0001180017010080ull))
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
index 022efe4..14a17a6 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_IOBN_BIST_STATUS CVMX_IOBN_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_IOBN_BIST_STATUS_FUNC(void)
 #define CVMX_IOBN_CHIP_CUR_PWR CVMX_IOBN_CHIP_CUR_PWR_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_CUR_PWR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_CUR_PWR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000068ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_IOBN_CHIP_CUR_PWR_FUNC(void)
 #define CVMX_IOBN_CHIP_GLB_PWR_THROTTLE CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_GLB_PWR_THROTTLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000038ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC(void)
 #define CVMX_IOBN_CHIP_PWR_OUT CVMX_IOBN_CHIP_PWR_OUT_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_PWR_OUT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_PWR_OUT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000048ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_IOBN_CHIP_PWR_OUT_FUNC(void)
 #define CVMX_IOBN_CONTROL CVMX_IOBN_CONTROL_FUNC()
 static inline uint64_t CVMX_IOBN_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000008ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_IOBN_CONTROL_FUNC(void)
 #define CVMX_IOBN_CREDITS CVMX_IOBN_CREDITS_FUNC()
 static inline uint64_t CVMX_IOBN_CREDITS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CREDITS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000028ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_IOBN_CREDITS_FUNC(void)
 #define CVMX_IOBN_ECC CVMX_IOBN_ECC_FUNC()
 static inline uint64_t CVMX_IOBN_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000010ull);
 }
@@ -133,7 +133,7 @@ static inline uint64_t CVMX_IOBN_ECC_FUNC(void)
 #define CVMX_IOBN_GBL_DLL CVMX_IOBN_GBL_DLL_FUNC()
 static inline uint64_t CVMX_IOBN_GBL_DLL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_GBL_DLL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0001000ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_IOBN_GBL_DLL_FUNC(void)
 #define CVMX_IOBN_HIGH_PRIORITY CVMX_IOBN_HIGH_PRIORITY_FUNC()
 static inline uint64_t CVMX_IOBN_HIGH_PRIORITY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_HIGH_PRIORITY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000000ull);
 }
@@ -155,7 +155,7 @@ static inline uint64_t CVMX_IOBN_HIGH_PRIORITY_FUNC(void)
 #define CVMX_IOBN_INT_SUM CVMX_IOBN_INT_SUM_FUNC()
 static inline uint64_t CVMX_IOBN_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000020ull);
 }
@@ -166,6 +166,7 @@ static inline uint64_t CVMX_IOBN_INT_SUM_FUNC(void)
 static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_IOBN_NCBX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800F0004000ull) + ((offset) & 3) * 8;
@@ -177,7 +178,7 @@ static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
 #define CVMX_IOBN_PP_BIST_STATUS CVMX_IOBN_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_PP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_PP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000700ull);
 }
@@ -254,6 +255,7 @@ union cvmx_iobn_bist_status {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_iobn_bist_status_s        cn73xx;
 	struct cvmx_iobn_bist_status_s        cn78xx;
 };
 typedef union cvmx_iobn_bist_status cvmx_iobn_bist_status_t;
@@ -286,6 +288,7 @@ union cvmx_iobn_chip_cur_pwr {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_iobn_chip_cur_pwr_s       cn73xx;
 	struct cvmx_iobn_chip_cur_pwr_s       cn78xx;
 };
 typedef union cvmx_iobn_chip_cur_pwr cvmx_iobn_chip_cur_pwr_t;
@@ -328,6 +331,7 @@ union cvmx_iobn_chip_glb_pwr_throttle {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_iobn_chip_glb_pwr_throttle_s cn73xx;
 	struct cvmx_iobn_chip_glb_pwr_throttle_s cn78xx;
 };
 typedef union cvmx_iobn_chip_glb_pwr_throttle cvmx_iobn_chip_glb_pwr_throttle_t;
@@ -360,6 +364,7 @@ union cvmx_iobn_chip_pwr_out {
 	uint64_t cpu_pwr                      : 16;
 #endif
 	} s;
+	struct cvmx_iobn_chip_pwr_out_s       cn73xx;
 	struct cvmx_iobn_chip_pwr_out_s       cn78xx;
 };
 typedef union cvmx_iobn_chip_pwr_out cvmx_iobn_chip_pwr_out_t;
@@ -381,6 +386,7 @@ union cvmx_iobn_control {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_iobn_control_s            cn73xx;
 	struct cvmx_iobn_control_s            cn78xx;
 };
 typedef union cvmx_iobn_control cvmx_iobn_control_t;
@@ -438,6 +444,7 @@ union cvmx_iobn_credits {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_iobn_credits_s            cn73xx;
 	struct cvmx_iobn_credits_s            cn78xx;
 };
 typedef union cvmx_iobn_credits cvmx_iobn_credits_t;
@@ -537,6 +544,7 @@ union cvmx_iobn_ecc {
 	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
+	struct cvmx_iobn_ecc_s                cn73xx;
 	struct cvmx_iobn_ecc_s                cn78xx;
 };
 typedef union cvmx_iobn_ecc cvmx_iobn_ecc_t;
@@ -576,6 +584,7 @@ union cvmx_iobn_gbl_dll {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_iobn_gbl_dll_s            cn73xx;
 	struct cvmx_iobn_gbl_dll_s            cn78xx;
 };
 typedef union cvmx_iobn_gbl_dll cvmx_iobn_gbl_dll_t;
@@ -602,6 +611,7 @@ union cvmx_iobn_high_priority {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_iobn_high_priority_s      cn73xx;
 	struct cvmx_iobn_high_priority_s      cn78xx;
 };
 typedef union cvmx_iobn_high_priority cvmx_iobn_high_priority_t;
@@ -777,6 +787,7 @@ union cvmx_iobn_int_sum {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_iobn_int_sum_s            cn73xx;
 	struct cvmx_iobn_int_sum_s            cn78xx;
 };
 typedef union cvmx_iobn_int_sum cvmx_iobn_int_sum_t;
@@ -785,7 +796,7 @@ typedef union cvmx_iobn_int_sum cvmx_iobn_int_sum_t;
  * cvmx_iobn_ncb#_ctl
  *
  * This register controls the type of store operation used for full cache blocks stores.
- * Added in pass 2.
+ *
  */
 union cvmx_iobn_ncbx_ctl {
 	uint64_t u64;
@@ -810,6 +821,7 @@ union cvmx_iobn_ncbx_ctl {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_iobn_ncbx_ctl_s           cn73xx;
 	struct cvmx_iobn_ncbx_ctl_s           cn78xx;
 };
 typedef union cvmx_iobn_ncbx_ctl cvmx_iobn_ncbx_ctl_t;
@@ -833,6 +845,7 @@ union cvmx_iobn_pp_bist_status {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_iobn_pp_bist_status_s     cn73xx;
 	struct cvmx_iobn_pp_bist_status_s     cn78xx;
 };
 typedef union cvmx_iobn_pp_bist_status cvmx_iobn_pp_bist_status_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
index ad0918f..b716d79 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_IOBP_BIST_STATUS CVMX_IOBP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_IOBP_BIST_STATUS_FUNC(void)
 #define CVMX_IOBP_CREDITS CVMX_IOBP_CREDITS_FUNC()
 static inline uint64_t CVMX_IOBP_CREDITS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_CREDITS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010028ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_IOBP_CREDITS_FUNC(void)
 #define CVMX_IOBP_ECC CVMX_IOBP_ECC_FUNC()
 static inline uint64_t CVMX_IOBP_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010010ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_IOBP_ECC_FUNC(void)
 #define CVMX_IOBP_INT_SUM CVMX_IOBP_INT_SUM_FUNC()
 static inline uint64_t CVMX_IOBP_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010020ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_IOBP_INT_SUM_FUNC(void)
 #define CVMX_IOBP_PP_BIST_STATUS CVMX_IOBP_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBP_PP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_PP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010700ull);
 }
@@ -145,6 +145,7 @@ union cvmx_iobp_bist_status {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_iobp_bist_status_s        cn73xx;
 	struct cvmx_iobp_bist_status_s        cn78xx;
 };
 typedef union cvmx_iobp_bist_status cvmx_iobp_bist_status_t;
@@ -178,6 +179,7 @@ union cvmx_iobp_credits {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_iobp_credits_s            cn73xx;
 	struct cvmx_iobp_credits_s            cn78xx;
 };
 typedef union cvmx_iobp_credits cvmx_iobp_credits_t;
@@ -227,6 +229,7 @@ union cvmx_iobp_ecc {
 	uint64_t reserved_22_63               : 42;
 #endif
 	} s;
+	struct cvmx_iobp_ecc_s                cn73xx;
 	struct cvmx_iobp_ecc_s                cn78xx;
 };
 typedef union cvmx_iobp_ecc cvmx_iobp_ecc_t;
@@ -312,6 +315,7 @@ union cvmx_iobp_int_sum {
 	uint64_t reserved_46_63               : 18;
 #endif
 	} s;
+	struct cvmx_iobp_int_sum_s            cn73xx;
 	struct cvmx_iobp_int_sum_s            cn78xx;
 };
 typedef union cvmx_iobp_int_sum cvmx_iobp_int_sum_t;
@@ -335,6 +339,7 @@ union cvmx_iobp_pp_bist_status {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_iobp_pp_bist_status_s     cn73xx;
 	struct cvmx_iobp_pp_bist_status_s     cn78xx;
 };
 typedef union cvmx_iobp_pp_bist_status cvmx_iobp_pp_bist_status_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ipd-defs.h b/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
index e2642a1..ec7a210 100644
--- a/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
@@ -172,15 +172,15 @@ static inline uint64_t CVMX_IPD_NEXT_WQE_PTR_FUNC(void)
 #endif
 #define CVMX_IPD_NOT_1ST_MBUFF_SKIP (CVMX_ADD_IO_SEG(0x00014F0000000008ull))
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_IPD_ON_BP_DROP_PKTX(unsigned long block_id)
+static inline uint64_t CVMX_IPD_ON_BP_DROP_PKTX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_IPD_ON_BP_DROP_PKTX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_IPD_ON_BP_DROP_PKTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00014F0000004100ull);
 }
 #else
-#define CVMX_IPD_ON_BP_DROP_PKTX(block_id) (CVMX_ADD_IO_SEG(0x00014F0000004100ull))
+#define CVMX_IPD_ON_BP_DROP_PKTX(offset) (CVMX_ADD_IO_SEG(0x00014F0000004100ull))
 #endif
 #define CVMX_IPD_PACKET_MBUFF_SIZE (CVMX_ADD_IO_SEG(0x00014F0000000010ull))
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
@@ -393,15 +393,15 @@ static inline uint64_t CVMX_IPD_PORT_QOS_X_CNT(unsigned long offset)
 #define CVMX_IPD_PORT_QOS_X_CNT(offset) (CVMX_ADD_IO_SEG(0x00014F0000000888ull) + ((offset) & 511) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_IPD_PORT_SOPX(unsigned long block_id)
+static inline uint64_t CVMX_IPD_PORT_SOPX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_IPD_PORT_SOPX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_IPD_PORT_SOPX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00014F0000004400ull);
 }
 #else
-#define CVMX_IPD_PORT_SOPX(block_id) (CVMX_ADD_IO_SEG(0x00014F0000004400ull))
+#define CVMX_IPD_PORT_SOPX(offset) (CVMX_ADD_IO_SEG(0x00014F0000004400ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL_FUNC()
@@ -470,15 +470,15 @@ static inline uint64_t CVMX_IPD_QOSX_RED_MARKS(unsigned long offset)
 #endif
 #define CVMX_IPD_QUE0_FREE_PAGE_CNT (CVMX_ADD_IO_SEG(0x00014F0000000330ull))
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_IPD_RED_BPID_ENABLEX(unsigned long block_id)
+static inline uint64_t CVMX_IPD_RED_BPID_ENABLEX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_IPD_RED_BPID_ENABLEX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_IPD_RED_BPID_ENABLEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00014F0000004200ull);
 }
 #else
-#define CVMX_IPD_RED_BPID_ENABLEX(block_id) (CVMX_ADD_IO_SEG(0x00014F0000004200ull))
+#define CVMX_IPD_RED_BPID_ENABLEX(offset) (CVMX_ADD_IO_SEG(0x00014F0000004200ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_IPD_RED_DELAY CVMX_IPD_RED_DELAY_FUNC()
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 1ef42c6..2b0b5a6 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_L2C_BIG_CTL CVMX_L2C_BIG_CTL_FUNC()
 static inline uint64_t CVMX_L2C_BIG_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_BIG_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800030ull);
 }
@@ -108,141 +108,165 @@ static inline uint64_t CVMX_L2C_BST2_FUNC(void)
 #define CVMX_L2C_BST2 (CVMX_ADD_IO_SEG(0x00011800800007E8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_BST_MEMX(unsigned long block_id)
+static inline uint64_t CVMX_L2C_BST_MEMX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_BST_MEMX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_BST_MEMX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_BST_MEMX(block_id) (CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_BST_MEMX(offset) (CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_BST_TDTX(unsigned long block_id)
+static inline uint64_t CVMX_L2C_BST_TDTX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_BST_TDTX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_BST_TDTX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_BST_TDTX(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_BST_TDTX(offset) (CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_BST_TTGX(unsigned long block_id)
+static inline uint64_t CVMX_L2C_BST_TTGX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_BST_TTGX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_BST_TTGX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_BST_TTGX(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_BST_TTGX(offset) (CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_CBCX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_L2C_CBCX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_CBCX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080E007F8ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_CBCX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080E007F8ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_CBCX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180080E007F8ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_CBCX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180080E007F8ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_CBCX_DLL(unsigned long block_id)
+static inline uint64_t CVMX_L2C_CBCX_DLL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_CBCX_DLL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080E00018ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_CBCX_DLL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080E00018ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_CBCX_DLL(block_id) (CVMX_ADD_IO_SEG(0x0001180080E00018ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_CBCX_DLL(offset) (CVMX_ADD_IO_SEG(0x0001180080E00018ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_CBCX_HOLEERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_CBCX_HOLEERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_CBCX_HOLEERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080E007D0ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_CBCX_HOLEERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080E007D0ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_CBCX_HOLEERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080E007D0ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_CBCX_HOLEERR(offset) (CVMX_ADD_IO_SEG(0x0001180080E007D0ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_CBCX_INT(unsigned long block_id)
+static inline uint64_t CVMX_L2C_CBCX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_CBCX_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080E00028ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_CBCX_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080E00028ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_CBCX_INT(block_id) (CVMX_ADD_IO_SEG(0x0001180080E00028ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_CBCX_INT(offset) (CVMX_ADD_IO_SEG(0x0001180080E00028ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_CBCX_IOCERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_CBCX_IOCERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_CBCX_IOCERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080E007E8ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_CBCX_IOCERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080E007E8ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_CBCX_IOCERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080E007E8ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_CBCX_IOCERR(offset) (CVMX_ADD_IO_SEG(0x0001180080E007E8ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_CBCX_IODISOCIERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_CBCX_IODISOCIERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_CBCX_IODISOCIERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080E007D8ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_CBCX_IODISOCIERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080E007D8ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_CBCX_IODISOCIERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080E007D8ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_CBCX_IODISOCIERR(offset) (CVMX_ADD_IO_SEG(0x0001180080E007D8ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_L2C_CBCX_MIBERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((block_id) & 3) * 0x40000ull - 262144*2;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (((offset >= 2) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 3) * 0x40000ull - 262144*2;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset == 1))
+				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 1) * 0x40000ull - 262144*1;
+			break;
+	}
+	cvmx_warn("CVMX_L2C_CBCX_MIBERR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 3) * 0x40000ull - 262144*2;
 }
 #else
-#define CVMX_L2C_CBCX_MIBERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((block_id) & 3) * 0x40000ull - 262144*2)
+static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*2;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*1;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*2;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_CBCX_RSDERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_CBCX_RSDERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_CBCX_RSDERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080E007F0ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_CBCX_RSDERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080E007F0ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_CBCX_RSDERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080E007F0ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_CBCX_RSDERR(offset) (CVMX_ADD_IO_SEG(0x0001180080E007F0ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_L2C_CFG CVMX_L2C_CFG_FUNC()
@@ -259,7 +283,7 @@ static inline uint64_t CVMX_L2C_CFG_FUNC(void)
 #define CVMX_L2C_COP0_ADR CVMX_L2C_COP0_ADR_FUNC()
 static inline uint64_t CVMX_L2C_COP0_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_COP0_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800038ull);
 }
@@ -270,7 +294,7 @@ static inline uint64_t CVMX_L2C_COP0_ADR_FUNC(void)
 #define CVMX_L2C_COP0_DAT CVMX_L2C_COP0_DAT_FUNC()
 static inline uint64_t CVMX_L2C_COP0_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_COP0_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800040ull);
 }
@@ -296,7 +320,7 @@ static inline uint64_t CVMX_L2C_COP0_MAPX(unsigned long offset)
 #define CVMX_L2C_CTL CVMX_L2C_CTL_FUNC()
 static inline uint64_t CVMX_L2C_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800000ull);
 }
@@ -344,7 +368,7 @@ static inline uint64_t CVMX_L2C_DUT_MAPX(unsigned long offset)
 #define CVMX_L2C_ECC_CTL CVMX_L2C_ECC_CTL_FUNC()
 static inline uint64_t CVMX_L2C_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800010ull);
 }
@@ -352,49 +376,49 @@ static inline uint64_t CVMX_L2C_ECC_CTL_FUNC(void)
 #define CVMX_L2C_ECC_CTL (CVMX_ADD_IO_SEG(0x0001180080800010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_ERR_TDTX(unsigned long block_id)
+static inline uint64_t CVMX_L2C_ERR_TDTX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_ERR_TDTX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_ERR_TDTX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_ERR_TDTX(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_ERR_TDTX(offset) (CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_ERR_TTGX(unsigned long block_id)
+static inline uint64_t CVMX_L2C_ERR_TTGX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_ERR_TTGX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_ERR_TTGX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_ERR_TTGX(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_ERR_TTGX(offset) (CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_ERR_VBFX(unsigned long block_id)
+static inline uint64_t CVMX_L2C_ERR_VBFX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_ERR_VBFX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_ERR_VBFX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_ERR_VBFX(block_id) (CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_ERR_VBFX(offset) (CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_L2C_ERR_XMC CVMX_L2C_ERR_XMC_FUNC()
@@ -478,6 +502,7 @@ static inline uint64_t CVMX_L2C_INVX_PFC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_INVX_PFC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800820ull) + ((offset) & 7) * 64;
@@ -486,7 +511,7 @@ static inline uint64_t CVMX_L2C_INVX_PFC(unsigned long offset)
 #define CVMX_L2C_INVX_PFC(offset) (CVMX_ADD_IO_SEG(0x0001180080800820ull) + ((offset) & 7) * 64)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long block_id)
+static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -494,20 +519,21 @@ static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800420ull);
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 			break;
 	}
-	cvmx_warn("CVMX_L2C_IOCX_PFC (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_L2C_IOCX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800420ull);
 }
 #else
-static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long block_id __attribute__ ((unused)))
+static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long offset __attribute__ ((unused)))
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -518,13 +544,14 @@ static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long block_id __attribute__ ((
 			return CVMX_ADD_IO_SEG(0x0001180080800420ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800420ull);
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long block_id)
+static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -532,20 +559,21 @@ static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800428ull);
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 			break;
 	}
-	cvmx_warn("CVMX_L2C_IORX_PFC (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_L2C_IORX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800428ull);
 }
 #else
-static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long block_id __attribute__ ((unused)))
+static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long offset __attribute__ ((unused)))
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -556,6 +584,7 @@ static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long block_id __attribute__ ((
 			return CVMX_ADD_IO_SEG(0x0001180080800428ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800428ull);
@@ -628,46 +657,49 @@ static inline uint64_t CVMX_L2C_LFB3_FUNC(void)
 #define CVMX_L2C_LFB3 (CVMX_ADD_IO_SEG(0x00011800800000B8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_MCIX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_L2C_MCIX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_MCIX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_MCIX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_MCIX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_MCIX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_MCIX_ERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_MCIX_ERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_MCIX_ERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_MCIX_ERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_MCIX_ERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_MCIX_ERR(offset) (CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long block_id)
+static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_L2C_MCIX_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080C00028ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_MCIX_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080C00028ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_MCIX_INT(block_id) (CVMX_ADD_IO_SEG(0x0001180080C00028ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_MCIX_INT(offset) (CVMX_ADD_IO_SEG(0x0001180080C00028ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_L2C_OCI_CTL CVMX_L2C_OCI_CTL_FUNC()
 static inline uint64_t CVMX_L2C_OCI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_OCI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800020ull);
 }
@@ -770,6 +802,7 @@ static inline uint64_t CVMX_L2C_QOS_IOBX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_QOS_IOBX(%lu) is invalid on this chip\n", offset);
@@ -787,6 +820,7 @@ static inline uint64_t CVMX_L2C_QOS_PPX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_QOS_PPX(%lu) is invalid on this chip\n", offset);
@@ -799,7 +833,7 @@ static inline uint64_t CVMX_L2C_QOS_PPX(unsigned long offset)
 #define CVMX_L2C_QOS_WGT CVMX_L2C_QOS_WGT_FUNC()
 static inline uint64_t CVMX_L2C_QOS_WGT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_QOS_WGT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800008ull);
 }
@@ -829,6 +863,10 @@ static inline uint64_t CVMX_L2C_RSCX_PFC(unsigned long offset)
 			if ((offset <= 9))
 				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 15) * 64;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 3) * 64;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_RSCX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800410ull) + ((offset) & 0) * 64;
@@ -848,6 +886,8 @@ static inline uint64_t CVMX_L2C_RSCX_PFC(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800410ull) + (offset) * 64;
 }
@@ -875,6 +915,10 @@ static inline uint64_t CVMX_L2C_RSDX_PFC(unsigned long offset)
 			if ((offset <= 9))
 				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 15) * 64;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 3) * 64;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_RSDX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800418ull) + ((offset) & 0) * 64;
@@ -894,6 +938,8 @@ static inline uint64_t CVMX_L2C_RSDX_PFC(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800418ull) + (offset) * 64;
 }
@@ -954,156 +1000,160 @@ static inline uint64_t CVMX_L2C_SPAR4_FUNC(void)
 #define CVMX_L2C_SPAR4 (CVMX_ADD_IO_SEG(0x0001180080000088ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_DLL(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_DLL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TADX_DLL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TADX_DLL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_DLL(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TADX_DLL(offset) (CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_ECC0(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_ECC0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_ECC0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_ECC0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_ECC0(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_TADX_ECC0(offset) (CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_ECC1(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_ECC1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_ECC1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_ECC1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_ECC1(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_TADX_ECC1(offset) (CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_ERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_ERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TADX_ERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007D0ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TADX_ERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007D0ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_ERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007D0ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TADX_ERR(offset) (CVMX_ADD_IO_SEG(0x0001180080A007D0ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_IEN(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_IEN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_IEN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_IEN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_IEN(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_TADX_IEN(offset) (CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_INT(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_INT(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TADX_INT(offset) (CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_PFC0(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_PFC0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_PFC0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00400ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_PFC0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00400ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_PFC0(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00400ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_TADX_PFC0(offset) (CVMX_ADD_IO_SEG(0x0001180080A00400ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_PFC1(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_PFC1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_PFC1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00408ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_PFC1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00408ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_PFC1(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00408ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_TADX_PFC1(offset) (CVMX_ADD_IO_SEG(0x0001180080A00408ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_PFC2(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_PFC2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_PFC2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00410ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_PFC2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00410ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_PFC2(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00410ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_TADX_PFC2(offset) (CVMX_ADD_IO_SEG(0x0001180080A00410ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_PFC3(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_PFC3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_PFC3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00418ull) + ((block_id) & 3) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_PFC3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00418ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_PFC3(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00418ull) + ((block_id) & 3) * 0x40000ull)
+#define CVMX_L2C_TADX_PFC3(offset) (CVMX_ADD_IO_SEG(0x0001180080A00418ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_L2C_TADX_PFCX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_L2C_TADX_PFCX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A00400ull) + (((offset) & 3) + ((block_id) & 7) * 0x8000ull) * 8;
@@ -1112,66 +1162,81 @@ static inline uint64_t CVMX_L2C_TADX_PFCX(unsigned long offset, unsigned long bl
 #define CVMX_L2C_TADX_PFCX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180080A00400ull) + (((offset) & 3) + ((block_id) & 7) * 0x8000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_PRF(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_PRF(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_PRF(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00008ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_PRF(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00008ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_PRF(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00008ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TADX_PRF(offset) (CVMX_ADD_IO_SEG(0x0001180080A00008ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_TAG(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_L2C_TADX_TAG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00010ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_L2C_TADX_STAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((offset) & 3) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_TAG(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00010ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TADX_STAT(offset) (CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((offset) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_TIMEOUT(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_TAG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TADX_TIMEOUT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007C8ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_L2C_TADX_TAG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A00010ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_TIMEOUT(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007C8ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TADX_TAG(offset) (CVMX_ADD_IO_SEG(0x0001180080A00010ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TADX_TIMETWO(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TADX_TIMEOUT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TADX_TIMETWO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007C0ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TADX_TIMEOUT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007C8ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_TIMETWO(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007C0ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TADX_TIMEOUT(offset) (CVMX_ADD_IO_SEG(0x0001180080A007C8ull) + ((offset) & 7) * 0x40000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_L2C_TADX_TIMETWO(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TADX_TIMETWO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007C0ull) + ((offset) & 7) * 0x40000ull;
+}
+#else
+#define CVMX_L2C_TADX_TIMETWO(offset) (CVMX_ADD_IO_SEG(0x0001180080A007C0ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_L2C_TAD_CTL CVMX_L2C_TAD_CTL_FUNC()
 static inline uint64_t CVMX_L2C_TAD_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_TAD_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800018ull);
 }
@@ -1179,64 +1244,69 @@ static inline uint64_t CVMX_L2C_TAD_CTL_FUNC(void)
 #define CVMX_L2C_TAD_CTL (CVMX_ADD_IO_SEG(0x0001180080800018ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TBFX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TBFX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TBFX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TBFX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TBFX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TBFX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TDTX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TDTX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TDTX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TDTX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TDTX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TDTX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TQDX_ERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TQDX_ERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TQDX_ERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007D8ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TQDX_ERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007D8ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TQDX_ERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007D8ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TQDX_ERR(offset) (CVMX_ADD_IO_SEG(0x0001180080A007D8ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TTGX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TTGX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TTGX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TTGX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TTGX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TTGX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_L2C_TTGX_ERR(unsigned long block_id)
+static inline uint64_t CVMX_L2C_TTGX_ERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
-		cvmx_warn("CVMX_L2C_TTGX_ERR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((block_id) & 7) * 0x40000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_L2C_TTGX_ERR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((offset) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TTGX_ERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((block_id) & 7) * 0x40000ull)
+#define CVMX_L2C_TTGX_ERR(offset) (CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((offset) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_L2C_VER_ID CVMX_L2C_VER_ID_FUNC()
@@ -1347,6 +1417,7 @@ static inline uint64_t CVMX_L2C_WPAR_IOBX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_WPAR_IOBX(%lu) is invalid on this chip\n", offset);
@@ -1364,6 +1435,7 @@ static inline uint64_t CVMX_L2C_WPAR_PPX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_WPAR_PPX(%lu) is invalid on this chip\n", offset);
@@ -1395,6 +1467,10 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 			if ((offset <= 9))
 				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 15) * 64;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 3) * 64;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_XMCX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800400ull) + ((offset) & 0) * 64;
@@ -1414,6 +1490,8 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800400ull) + (offset) * 64;
 }
@@ -1422,7 +1500,7 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 #define CVMX_L2C_XMC_CMD CVMX_L2C_XMC_CMD_FUNC()
 static inline uint64_t CVMX_L2C_XMC_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_XMC_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800028ull);
 }
@@ -1452,6 +1530,10 @@ static inline uint64_t CVMX_L2C_XMDX_PFC(unsigned long offset)
 			if ((offset <= 9))
 				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 15) * 64;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 3) * 64;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_XMDX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800408ull) + ((offset) & 0) * 64;
@@ -1471,6 +1553,8 @@ static inline uint64_t CVMX_L2C_XMDX_PFC(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800408ull) + (offset) * 64;
 }
@@ -1581,6 +1665,7 @@ union cvmx_l2c_big_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_big_ctl_cn70xx        cn70xxp1;
+	struct cvmx_l2c_big_ctl_cn70xx        cn73xx;
 	struct cvmx_l2c_big_ctl_cn70xx        cn78xx;
 	struct cvmx_l2c_big_ctl_cn61xx        cnf71xx;
 };
@@ -2321,17 +2406,18 @@ union cvmx_l2c_cbcx_bist_status {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_cbcx_bist_status_cn70xx cn70xxp1;
-	struct cvmx_l2c_cbcx_bist_status_cn78xx {
+	struct cvmx_l2c_cbcx_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_37_63               : 27;
-	uint64_t mibfl                        : 5;  /**< BIST failure status for various MIB memories. ([XMD, IPM, IRM, MXD, MXN]) */
+	uint64_t mibfl                        : 5;  /**< Reserved. */
 	uint64_t rsdfl                        : 32; /**< BIST failure status for RSDQW0-31. */
 #else
 	uint64_t rsdfl                        : 32;
 	uint64_t mibfl                        : 5;
 	uint64_t reserved_37_63               : 27;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_cbcx_bist_status_cn73xx cn78xx;
 };
 typedef union cvmx_l2c_cbcx_bist_status cvmx_l2c_cbcx_bist_status_t;
 
@@ -2366,6 +2452,7 @@ union cvmx_l2c_cbcx_dll {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_l2c_cbcx_dll_s            cn73xx;
 	struct cvmx_l2c_cbcx_dll_s            cn78xx;
 };
 typedef union cvmx_l2c_cbcx_dll cvmx_l2c_cbcx_dll_t;
@@ -2403,6 +2490,7 @@ union cvmx_l2c_cbcx_holeerr {
 	uint64_t holerd                       : 1;
 #endif
 	} s;
+	struct cvmx_l2c_cbcx_holeerr_s        cn73xx;
 	struct cvmx_l2c_cbcx_holeerr_s        cn78xx;
 };
 typedef union cvmx_l2c_cbcx_holeerr cvmx_l2c_cbcx_holeerr_t;
@@ -2462,19 +2550,15 @@ union cvmx_l2c_cbcx_int {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_cbcx_int_cn70xx       cn70xxp1;
-	struct cvmx_l2c_cbcx_int_cn78xx {
+	struct cvmx_l2c_cbcx_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t holerd                       : 1;  /**< Read reference to 256MB hole occurred. */
 	uint64_t holewr                       : 1;  /**< Write reference to 256MB hole occurred. */
-	uint64_t iowrdisoci                   : 1;  /**< Illegal I/O write operation to a remote node with L2C_OCI_CTL[ENAOCI][node] clear. See
-                                                         L2C_CBC()_IODISOCIERR for logged information. This interrupt applies to IOBST8,
-                                                         IOBST16, IOBST32, IOBST64, IOBADDR, LMTST, and LMTDMA XMC commands. */
-	uint64_t iorddisoci                   : 1;  /**< Illegal I/O read operation to a remote node with L2C_OCI_CTL[ENAOCI][node] clear. See
-                                                         L2C_CBC()_IODISOCIERR for logged information. This interrupt applies to IOBLD8,
-                                                         IOBLD16, IOBLD32, IOBLD64, IOBDMA, and LMTDMA XMC commands. */
-	uint64_t mibdbe                       : 1;  /**< MIB double-bit error occurred. See L2C_CBC()_MIBERR for logged information. */
-	uint64_t mibsbe                       : 1;  /**< MIB double-bit error occurred. See L2C_CBC()_MIBERR for logged information. */
+	uint64_t iowrdisoci                   : 1;  /**< Reserved. */
+	uint64_t iorddisoci                   : 1;  /**< Reserved. */
+	uint64_t mibdbe                       : 1;  /**< Reserved. */
+	uint64_t mibsbe                       : 1;  /**< Reserved. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t rsddbe                       : 1;  /**< RSD double-bit error occurred. See L2C_CBC()_RSDERR for logged information. */
 	uint64_t rsdsbe                       : 1;  /**< RSD single-bit error occurred. See L2C_CBC()_RSDERR for logged information. */
@@ -2490,7 +2574,8 @@ union cvmx_l2c_cbcx_int {
 	uint64_t holerd                       : 1;
 	uint64_t reserved_10_63               : 54;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_cbcx_int_cn73xx       cn78xx;
 };
 typedef union cvmx_l2c_cbcx_int cvmx_l2c_cbcx_int_t;
 
@@ -2521,24 +2606,22 @@ union cvmx_l2c_cbcx_iocerr {
 	} s;
 	struct cvmx_l2c_cbcx_iocerr_s         cn70xx;
 	struct cvmx_l2c_cbcx_iocerr_s         cn70xxp1;
-	struct cvmx_l2c_cbcx_iocerr_cn78xx {
+	struct cvmx_l2c_cbcx_iocerr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_0_63                : 64;
 #else
 	uint64_t reserved_0_63                : 64;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_cbcx_iocerr_cn73xx    cn78xx;
 };
 typedef union cvmx_l2c_cbcx_iocerr cvmx_l2c_cbcx_iocerr_t;
 
 /**
  * cvmx_l2c_cbc#_iodisocierr
  *
- * This register records error information associated with IORDDISOCI/IOWRDISOCI interrupts.
- * IOWRDISOCI events take priority over previously captured IORDDISOCI events. Of the available
- * I/O transactions, some commands will either set IORDDISOCI, set IOWRDISOCI, or set both
- * IORDDISOCI and IOWRDISOCI. See L2C_CBC()_INT for information about which I/O transactions
- * may result in IORDDISOCI/IOWRDISOCI interrupts.
+ * Reserved.
+ *
  */
 union cvmx_l2c_cbcx_iodisocierr {
 	uint64_t u64;
@@ -2563,6 +2646,7 @@ union cvmx_l2c_cbcx_iodisocierr {
 	uint64_t iorddisoci                   : 1;
 #endif
 	} s;
+	struct cvmx_l2c_cbcx_iodisocierr_s    cn73xx;
 	struct cvmx_l2c_cbcx_iodisocierr_s    cn78xx;
 };
 typedef union cvmx_l2c_cbcx_iodisocierr cvmx_l2c_cbcx_iodisocierr_t;
@@ -2570,11 +2654,8 @@ typedef union cvmx_l2c_cbcx_iodisocierr cvmx_l2c_cbcx_iodisocierr_t;
 /**
  * cvmx_l2c_cbc#_miberr
  *
- * This register records error information for all CBC MIB errors. An error locks the INDEX, and
- * SYN fields and set the bit corresponding to the error received. MIBDBE errors take priority
- * and overwrite an earlier logged MIBSBE error. Only one of MIBSBE/MIBDBE is set at any given
- * time and serves to document which error the INDEX/SYN is associated with. The syndrome is
- * recorded for DBE errors, though the utility of the value is not clear.
+ * Reserved.
+ *
  */
 union cvmx_l2c_cbcx_miberr {
 	uint64_t u64;
@@ -2601,6 +2682,7 @@ union cvmx_l2c_cbcx_miberr {
 	uint64_t mibdbe                       : 1;
 #endif
 	} s;
+	struct cvmx_l2c_cbcx_miberr_s         cn73xx;
 	struct cvmx_l2c_cbcx_miberr_s         cn78xx;
 };
 typedef union cvmx_l2c_cbcx_miberr cvmx_l2c_cbcx_miberr_t;
@@ -2640,6 +2722,7 @@ union cvmx_l2c_cbcx_rsderr {
 	} s;
 	struct cvmx_l2c_cbcx_rsderr_s         cn70xx;
 	struct cvmx_l2c_cbcx_rsderr_s         cn70xxp1;
+	struct cvmx_l2c_cbcx_rsderr_s         cn73xx;
 	struct cvmx_l2c_cbcx_rsderr_s         cn78xx;
 };
 typedef union cvmx_l2c_cbcx_rsderr cvmx_l2c_cbcx_rsderr_t;
@@ -3351,6 +3434,7 @@ union cvmx_l2c_cop0_adr {
 	} s;
 	struct cvmx_l2c_cop0_adr_s            cn70xx;
 	struct cvmx_l2c_cop0_adr_s            cn70xxp1;
+	struct cvmx_l2c_cop0_adr_s            cn73xx;
 	struct cvmx_l2c_cop0_adr_s            cn78xx;
 };
 typedef union cvmx_l2c_cop0_adr cvmx_l2c_cop0_adr_t;
@@ -3372,6 +3456,7 @@ union cvmx_l2c_cop0_dat {
 	} s;
 	struct cvmx_l2c_cop0_dat_s            cn70xx;
 	struct cvmx_l2c_cop0_dat_s            cn70xxp1;
+	struct cvmx_l2c_cop0_dat_s            cn73xx;
 	struct cvmx_l2c_cop0_dat_s            cn78xx;
 };
 typedef union cvmx_l2c_cop0_dat cvmx_l2c_cop0_dat_t;
@@ -3867,7 +3952,7 @@ union cvmx_l2c_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_ctl_cn70xx            cn70xxp1;
-	struct cvmx_l2c_ctl_cn78xx {
+	struct cvmx_l2c_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t ocla_qos                     : 3;  /**< QOS level for the transactions from OCLA to L2C. */
@@ -3888,10 +3973,8 @@ union cvmx_l2c_ctl {
                                                          To disable set to 0. All other values are reserved. */
 	uint64_t reserved_4_5                 : 2;
 	uint64_t disldwb                      : 1;  /**< Suppresses the DWB functionality of any received LDWB, effectively turning them into LDTs. */
-	uint64_t dissblkdty                   : 1;  /**< Disable bandwidth optimization between L2 and LMC and MOB which only transfers modified
-                                                         sub-blocks when possible. In an CCPI system all nodes must use the same setting of
-                                                         DISSBLKDTY or operation is undefined.
-                                                         INTERNAL: PASS2: DISSBLKDTY should reset to 0, once verif supports it. */
+	uint64_t dissblkdty                   : 1;  /**< Disable bandwidth optimization between L2 and LMC which only transfers modified
+                                                         sub-blocks when possible. */
 	uint64_t disecc                       : 1;  /**< Tag and data ECC disable. */
 	uint64_t disidxalias                  : 1;  /**< Index alias disable. */
 #else
@@ -3911,7 +3994,8 @@ union cvmx_l2c_ctl {
 	uint64_t ocla_qos                     : 3;
 	uint64_t reserved_32_63               : 32;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_ctl_cn73xx            cn78xx;
 	struct cvmx_l2c_ctl_cn61xx            cnf71xx;
 };
 typedef union cvmx_l2c_ctl cvmx_l2c_ctl_t;
@@ -4604,10 +4688,10 @@ union cvmx_l2c_ecc_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_ecc_ctl_cn70xx        cn70xxp1;
-	struct cvmx_l2c_ecc_ctl_cn78xx {
+	struct cvmx_l2c_ecc_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t mibflip                      : 2;  /**< Generate an ECC error in the MIB. See note above. */
+	uint64_t mibflip                      : 2;  /**< Reserved. */
 	uint64_t l2dflip                      : 2;  /**< Generate an ECC error in the L2D. See note above. */
 	uint64_t l2tflip                      : 2;  /**< Generate an ECC error in the L2T. */
 	uint64_t rdfflip                      : 2;  /**< Generate an ECC error in RDF memory. */
@@ -4622,7 +4706,8 @@ union cvmx_l2c_ecc_ctl {
 	uint64_t mibflip                      : 2;
 	uint64_t reserved_12_63               : 52;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_ecc_ctl_cn73xx        cn78xx;
 };
 typedef union cvmx_l2c_ecc_ctl cvmx_l2c_ecc_ctl_t;
 
@@ -5467,6 +5552,7 @@ union cvmx_l2c_invx_pfc {
 	} s;
 	struct cvmx_l2c_invx_pfc_s            cn70xx;
 	struct cvmx_l2c_invx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_invx_pfc_s            cn73xx;
 	struct cvmx_l2c_invx_pfc_s            cn78xx;
 };
 typedef union cvmx_l2c_invx_pfc cvmx_l2c_invx_pfc_t;
@@ -5494,6 +5580,7 @@ union cvmx_l2c_iocx_pfc {
 	struct cvmx_l2c_iocx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_iocx_pfc_s            cn70xx;
 	struct cvmx_l2c_iocx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_iocx_pfc_s            cn73xx;
 	struct cvmx_l2c_iocx_pfc_s            cn78xx;
 	struct cvmx_l2c_iocx_pfc_s            cnf71xx;
 };
@@ -5522,6 +5609,7 @@ union cvmx_l2c_iorx_pfc {
 	struct cvmx_l2c_iorx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_iorx_pfc_s            cn70xx;
 	struct cvmx_l2c_iorx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_iorx_pfc_s            cn73xx;
 	struct cvmx_l2c_iorx_pfc_s            cn78xx;
 	struct cvmx_l2c_iorx_pfc_s            cnf71xx;
 };
@@ -6077,6 +6165,7 @@ union cvmx_l2c_mcix_bist_status {
 	} s;
 	struct cvmx_l2c_mcix_bist_status_s    cn70xx;
 	struct cvmx_l2c_mcix_bist_status_s    cn70xxp1;
+	struct cvmx_l2c_mcix_bist_status_s    cn73xx;
 	struct cvmx_l2c_mcix_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_mcix_bist_status cvmx_l2c_mcix_bist_status_t;
@@ -6122,6 +6211,7 @@ union cvmx_l2c_mcix_err {
 	} s;
 	struct cvmx_l2c_mcix_err_s            cn70xx;
 	struct cvmx_l2c_mcix_err_s            cn70xxp1;
+	struct cvmx_l2c_mcix_err_s            cn73xx;
 	struct cvmx_l2c_mcix_err_s            cn78xx;
 };
 typedef union cvmx_l2c_mcix_err cvmx_l2c_mcix_err_t;
@@ -6147,6 +6237,7 @@ union cvmx_l2c_mcix_int {
 	} s;
 	struct cvmx_l2c_mcix_int_s            cn70xx;
 	struct cvmx_l2c_mcix_int_s            cn70xxp1;
+	struct cvmx_l2c_mcix_int_s            cn73xx;
 	struct cvmx_l2c_mcix_int_s            cn78xx;
 };
 typedef union cvmx_l2c_mcix_int cvmx_l2c_mcix_int_t;
@@ -6241,6 +6332,7 @@ union cvmx_l2c_oci_ctl {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_l2c_oci_ctl_s             cn73xx;
 	struct cvmx_l2c_oci_ctl_s             cn78xx;
 };
 typedef union cvmx_l2c_oci_ctl cvmx_l2c_oci_ctl_t;
@@ -6745,6 +6837,7 @@ union cvmx_l2c_qos_iobx {
 	struct cvmx_l2c_qos_iobx_s            cn68xxp1;
 	struct cvmx_l2c_qos_iobx_s            cn70xx;
 	struct cvmx_l2c_qos_iobx_s            cn70xxp1;
+	struct cvmx_l2c_qos_iobx_s            cn73xx;
 	struct cvmx_l2c_qos_iobx_s            cn78xx;
 	struct cvmx_l2c_qos_iobx_cn61xx       cnf71xx;
 };
@@ -6784,6 +6877,7 @@ union cvmx_l2c_qos_ppx {
 	struct cvmx_l2c_qos_ppx_s             cn68xxp1;
 	struct cvmx_l2c_qos_ppx_s             cn70xx;
 	struct cvmx_l2c_qos_ppx_s             cn70xxp1;
+	struct cvmx_l2c_qos_ppx_s             cn73xx;
 	struct cvmx_l2c_qos_ppx_s             cn78xx;
 	struct cvmx_l2c_qos_ppx_cn61xx        cnf71xx;
 };
@@ -6840,6 +6934,7 @@ union cvmx_l2c_qos_wgt {
 	struct cvmx_l2c_qos_wgt_s             cn68xxp1;
 	struct cvmx_l2c_qos_wgt_s             cn70xx;
 	struct cvmx_l2c_qos_wgt_s             cn70xxp1;
+	struct cvmx_l2c_qos_wgt_s             cn73xx;
 	struct cvmx_l2c_qos_wgt_s             cn78xx;
 	struct cvmx_l2c_qos_wgt_cn61xx        cnf71xx;
 };
@@ -6868,6 +6963,7 @@ union cvmx_l2c_rscx_pfc {
 	struct cvmx_l2c_rscx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_rscx_pfc_s            cn70xx;
 	struct cvmx_l2c_rscx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_rscx_pfc_s            cn73xx;
 	struct cvmx_l2c_rscx_pfc_s            cn78xx;
 	struct cvmx_l2c_rscx_pfc_s            cnf71xx;
 };
@@ -6896,6 +6992,7 @@ union cvmx_l2c_rsdx_pfc {
 	struct cvmx_l2c_rsdx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_rsdx_pfc_s            cn70xx;
 	struct cvmx_l2c_rsdx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_rsdx_pfc_s            cn73xx;
 	struct cvmx_l2c_rsdx_pfc_s            cn78xx;
 	struct cvmx_l2c_rsdx_pfc_s            cnf71xx;
 };
@@ -7186,6 +7283,7 @@ union cvmx_l2c_tadx_dll {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tadx_dll_cn70xx       cn70xxp1;
+	struct cvmx_l2c_tadx_dll_s            cn73xx;
 	struct cvmx_l2c_tadx_dll_s            cn78xx;
 };
 typedef union cvmx_l2c_tadx_dll cvmx_l2c_tadx_dll_t;
@@ -7273,11 +7371,9 @@ typedef union cvmx_l2c_tadx_ecc1 cvmx_l2c_tadx_ecc1_t;
 /**
  * cvmx_l2c_tad#_err
  *
- * This register records error information for *DISOCI and BIG* interrupts. The BIG logic only
- * applies to local addresses. A command for a remote address does not cause a BIGRD/BIGWR on the
- * requesting node. Similary RDDISOCI/WRDISOCI is always for a remote address. The first
- * WRDISOCI/BIGWR error will lock the register until the logged error type is cleared;
- * RDDISOCI/BIGRD never locks the register.
+ * This register records error information for BIG* interrupts. The BIG logic only
+ * applies to local addresses. The first BIGWR error will lock the register until the
+ * logged error type is cleared; BIGRD never locks the register.
  */
 union cvmx_l2c_tadx_err {
 	uint64_t u64;
@@ -7337,24 +7433,19 @@ union cvmx_l2c_tadx_err {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tadx_err_cn70xx       cn70xxp1;
-	struct cvmx_l2c_tadx_err_cn78xx {
+	struct cvmx_l2c_tadx_err_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t bigrd                        : 1;  /**< Logged information is for a BIGRD error. */
 	uint64_t bigwr                        : 1;  /**< Logged information is for a BIGWR error. */
-	uint64_t rddisoci                     : 1;  /**< Logged information is for a RDDISOCI error. */
-	uint64_t wrdisoci                     : 1;  /**< Logged information is for a WRDISOCI error. */
+	uint64_t rddisoci                     : 1;  /**< Reserved. */
+	uint64_t wrdisoci                     : 1;  /**< Reserved. */
 	uint64_t reserved_59_59               : 1;
-	uint64_t cmd                          : 8;  /**< Encoding of XMC or CCPI command causing error. INTERNAL: If CMD[7]==1, use XMC_CMD_E to
-                                                         decode CMD[6:0]. If CMD[7:5]==0, use OCI_MREQ_CMD_E to decode CMD[4:0]. If CMD[7:5]==1,
-                                                         use OCI_MFWD_CMD_E to decode CMD[4:0]. If CMD[7:5]==2, use OCI_MRSP_CMD_E to decode
-                                                         CMD[4:0]. */
+	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error.
+                                                         INTERNAL: CMD[7] should always be 1, use XMC_CMD_E to decode CMD[6:0]. */
 	uint64_t source                       : 7;  /**< XMC source of request causing error. If SOURCE<6>==0, then SOURCE<5:0> is PPID, else
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. If CMD[7]==0, this field is
                                                          unpredictable. */
-	uint64_t node                         : 4;  /**< CCPI node of XMC request causing error. For BIG* errors NODE is always the node that
-                                                         generated request causing the error (BIG* errors are logged at the home node). For *DISOCI
-                                                         errors, is the NODE the request is directed to (DISOCI request is always the current
-                                                         Node). */
+	uint64_t node                         : 4;  /**< Reserved.  Will always be 0. */
 	uint64_t addr                         : 40; /**< XMC address causing the error. This field is the physical address after hole removal and
                                                          index aliasing (if enabled). (The hole is between DR0 and DR1. Remove the hole by
                                                          subtracting 256MB from all L2/DRAM physical addresses >= 512 MB.) */
@@ -7369,7 +7460,8 @@ union cvmx_l2c_tadx_err {
 	uint64_t bigwr                        : 1;
 	uint64_t bigrd                        : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_tadx_err_cn73xx       cn78xx;
 };
 typedef union cvmx_l2c_tadx_err cvmx_l2c_tadx_err_t;
 
@@ -7623,15 +7715,11 @@ union cvmx_l2c_tadx_int {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tadx_int_cn70xx       cn70xxp1;
-	struct cvmx_l2c_tadx_int_cn78xx {
+	struct cvmx_l2c_tadx_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t wrdisoci                     : 1;  /**< Illegal write operation to a remote node with L2C_OCI_CTL[ENAOCI][node] clear. See
-                                                         L2C_TAD()_ERR for for logged information. */
-	uint64_t rddisoci                     : 1;  /**< Illegal read operation to a remote node with L2C_OCI_CTL[ENAOCI][node] clear. Note
-                                                         RDDISOCI interrupts can occur during normal operation as the cores are allowed to prefetch
-                                                         to nonexistent memory locations. Therefore, RDDISOCI is for informational purposes only.
-                                                         See L2C_TAD()_ERR for logged information. */
+	uint64_t wrdisoci                     : 1;  /**< Reserved. */
+	uint64_t rddisoci                     : 1;  /**< Reserved. */
 	uint64_t rtgdbe                       : 1;  /**< RTG double-bit error. */
 	uint64_t rtgsbe                       : 1;  /**< RTG single-bit error. */
 	uint64_t reserved_18_31               : 14;
@@ -7688,7 +7776,8 @@ union cvmx_l2c_tadx_int {
 	uint64_t wrdisoci                     : 1;
 	uint64_t reserved_36_63               : 28;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_tadx_int_cn73xx       cn78xx;
 	struct cvmx_l2c_tadx_int_cn61xx       cnf71xx;
 };
 typedef union cvmx_l2c_tadx_int cvmx_l2c_tadx_int_t;
@@ -7707,6 +7796,7 @@ union cvmx_l2c_tadx_pfcx {
 	} s;
 	struct cvmx_l2c_tadx_pfcx_s           cn70xx;
 	struct cvmx_l2c_tadx_pfcx_s           cn70xxp1;
+	struct cvmx_l2c_tadx_pfcx_s           cn73xx;
 	struct cvmx_l2c_tadx_pfcx_s           cn78xx;
 };
 typedef union cvmx_l2c_tadx_pfcx cvmx_l2c_tadx_pfcx_t;
@@ -7842,12 +7932,38 @@ union cvmx_l2c_tadx_prf {
 	struct cvmx_l2c_tadx_prf_s            cn68xxp1;
 	struct cvmx_l2c_tadx_prf_s            cn70xx;
 	struct cvmx_l2c_tadx_prf_s            cn70xxp1;
+	struct cvmx_l2c_tadx_prf_s            cn73xx;
 	struct cvmx_l2c_tadx_prf_s            cn78xx;
 	struct cvmx_l2c_tadx_prf_s            cnf71xx;
 };
 typedef union cvmx_l2c_tadx_prf cvmx_l2c_tadx_prf_t;
 
 /**
+ * cvmx_l2c_tad#_stat
+ *
+ * This register holds information about the instantaneous state of the TAD.
+ *
+ */
+union cvmx_l2c_tadx_stat {
+	uint64_t u64;
+	struct cvmx_l2c_tadx_stat_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t lfb_valid_cnt                : 6;  /**< The number of LFBs in use. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t vbf_inuse_cnt                : 5;  /**< The number of MCI VBFs in use. */
+#else
+	uint64_t vbf_inuse_cnt                : 5;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t lfb_valid_cnt                : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_l2c_tadx_stat_s           cn73xx;
+};
+typedef union cvmx_l2c_tadx_stat cvmx_l2c_tadx_stat_t;
+
+/**
  * cvmx_l2c_tad#_tag
  *
  * This register holds the tag information for LTGL2I and STGL2I commands.
@@ -7935,6 +8051,47 @@ union cvmx_l2c_tadx_tag {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tadx_tag_cn70xx       cn70xxp1;
+	struct cvmx_l2c_tadx_tag_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. Ignored/loaded with 0 for RTG accesses. If TS is Invalid (0) SBLKDTY
+                                                         must be 0 or operation is undefined. */
+	uint64_t reserved_58_59               : 2;
+	uint64_t businfo                      : 9;  /**< The bus information bits. Legal values: when [57]==1, we are in idmode and
+                                                         [56:53] must be 0, [52:49] are the PPVID of the PP which could be holding the
+                                                         block; when [57]==0, we are in bus mask mode and [56:52] must be 0 and if any of
+                                                         [51:48] is 1 then any of the PP's on that bus (3..0) could contain the
+                                                         block. Operation is undefined if an STGL2I causes an illegal value to be written
+                                                         to the L2 TAGs. LTGL2Is will only load legal values into this register. */
+	uint64_t ecc                          : 7;  /**< The tag ECC. This field is undefined if L2C_CTL[DISECC] is not 1 when the LTGL2I reads the tags. */
+	uint64_t reserved_40_41               : 2;
+	uint64_t tag                          : 22; /**< The tag. TAG<39:18> is the corresponding bits from the L2C+LMC internal L2/DRAM byte
+                                                         address. */
+	uint64_t reserved_6_17                : 12;
+	uint64_t node                         : 2;  /**< Reserved. */
+	uint64_t ts                           : 2;  /**< The tag state.
+                                                         0x0 = Invalid.
+                                                         0x1 = Shared.
+                                                         0x2 = Exclusive.
+                                                         Note that a local address will never have the value of exclusive as that state is incloded
+                                                         as shared in the TAG and invalid in the RTG. */
+	uint64_t used                         : 1;  /**< The LRU use bit. If setting the LOCK bit, the USE bit should also be set or the operation
+                                                         is undefined.  Ignored/loaded with 0 for RTG accesses. */
+	uint64_t lock                         : 1;  /**< The lock bit. If setting the LOCK bit, the USE bit should also be set or the operation is
+                                                         undefined.  Ignored/loaded with 0 for RTG accesses. */
+#else
+	uint64_t lock                         : 1;
+	uint64_t used                         : 1;
+	uint64_t ts                           : 2;
+	uint64_t node                         : 2;
+	uint64_t reserved_6_17                : 12;
+	uint64_t tag                          : 22;
+	uint64_t reserved_40_41               : 2;
+	uint64_t ecc                          : 7;
+	uint64_t businfo                      : 9;
+	uint64_t reserved_58_59               : 2;
+	uint64_t sblkdty                      : 4;
+#endif
+	} cn73xx;
 	struct cvmx_l2c_tadx_tag_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. Ignored/loaded with 0 for RTG accesses. If TS is Invalid (0) SBLKDTY
@@ -8017,6 +8174,7 @@ union cvmx_l2c_tadx_timeout {
 	uint64_t infolfb                      : 1;
 #endif
 	} s;
+	struct cvmx_l2c_tadx_timeout_s        cn73xx;
 	struct cvmx_l2c_tadx_timeout_s        cn78xx;
 };
 typedef union cvmx_l2c_tadx_timeout cvmx_l2c_tadx_timeout_t;
@@ -8051,6 +8209,7 @@ union cvmx_l2c_tadx_timetwo {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_l2c_tadx_timetwo_s        cn73xx;
 	struct cvmx_l2c_tadx_timetwo_s        cn78xx;
 };
 typedef union cvmx_l2c_tadx_timetwo cvmx_l2c_tadx_timetwo_t;
@@ -8058,12 +8217,8 @@ typedef union cvmx_l2c_tadx_timetwo cvmx_l2c_tadx_timetwo_t;
 /**
  * cvmx_l2c_tad_ctl
  *
- * In CNXXXX, MAXLFB, EXLRQ, EXRRQ, EXFWD, EXVIC refer to half-TAD LFBs/VABs. Therefore, even
- * though there are 24 LFBs/VABs in a full TAD, the number applies to both halves.
- * * If MAXLFB is written to 0 or 13-15 operation is undefined. (CN78XX pass 1.0).
- * * If MAXLFB is != 0, VBF_THRESH should be less than MAXLFB.
- * * If MAXVBF is != 0, VBF_THRESH should be less than MAXVBF.
- * * If MAXLFB != 0, EXLRQ + EXRRQ + EXFWD + EXVIC must be less than or equal to MAXLFB - 3.
+ * "* If MAXLFB is != 0, VBF_THRESH should be less than MAXLFB.
+ * * If MAXVBF is != 0, VBF_THRESH should be less than MAXVBF."
  */
 union cvmx_l2c_tad_ctl {
 	uint64_t u64;
@@ -8122,6 +8277,7 @@ union cvmx_l2c_tad_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tad_ctl_cn70xx        cn70xxp1;
+	struct cvmx_l2c_tad_ctl_s             cn73xx;
 	struct cvmx_l2c_tad_ctl_s             cn78xx;
 };
 typedef union cvmx_l2c_tad_ctl cvmx_l2c_tad_ctl_t;
@@ -8146,6 +8302,7 @@ union cvmx_l2c_tbfx_bist_status {
 	} s;
 	struct cvmx_l2c_tbfx_bist_status_s    cn70xx;
 	struct cvmx_l2c_tbfx_bist_status_s    cn70xxp1;
+	struct cvmx_l2c_tbfx_bist_status_s    cn73xx;
 	struct cvmx_l2c_tbfx_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_tbfx_bist_status cvmx_l2c_tbfx_bist_status_t;
@@ -8166,6 +8323,7 @@ union cvmx_l2c_tdtx_bist_status {
 	} s;
 	struct cvmx_l2c_tdtx_bist_status_s    cn70xx;
 	struct cvmx_l2c_tdtx_bist_status_s    cn70xxp1;
+	struct cvmx_l2c_tdtx_bist_status_s    cn73xx;
 	struct cvmx_l2c_tdtx_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_tdtx_bist_status cvmx_l2c_tdtx_bist_status_t;
@@ -8213,6 +8371,7 @@ union cvmx_l2c_tqdx_err {
 	} s;
 	struct cvmx_l2c_tqdx_err_s            cn70xx;
 	struct cvmx_l2c_tqdx_err_s            cn70xxp1;
+	struct cvmx_l2c_tqdx_err_s            cn73xx;
 	struct cvmx_l2c_tqdx_err_s            cn78xx;
 };
 typedef union cvmx_l2c_tqdx_err cvmx_l2c_tqdx_err_t;
@@ -8259,6 +8418,7 @@ union cvmx_l2c_ttgx_bist_status {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_ttgx_bist_status_cn70xx cn70xxp1;
+	struct cvmx_l2c_ttgx_bist_status_s    cn73xx;
 	struct cvmx_l2c_ttgx_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_ttgx_bist_status cvmx_l2c_ttgx_bist_status_t;
@@ -8271,7 +8431,7 @@ typedef union cvmx_l2c_ttgx_bist_status cvmx_l2c_ttgx_bist_status_t;
  * and L2IDX fields for equal or lower priority errors until cleared by software.
  * The syndrome is recorded for DBE errors, though the utility of the value is not clear.
  * A NOWAY error does not change the value of the SYN field, and leaves WAY unpredictable.
- * L2IDX[19:7] is the L2 block index associated with the command which had no way to allocate.
+ * L2IDX[17:7] is the L2 block index associated with the command which had no way to allocate.
  */
 union cvmx_l2c_ttgx_err {
 	uint64_t u64;
@@ -8316,6 +8476,29 @@ union cvmx_l2c_ttgx_err {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_ttgx_err_cn70xx       cn70xxp1;
+	struct cvmx_l2c_ttgx_err_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t tagdbe                       : 1;  /**< Information refers to a double-bit TAG ECC error. */
+	uint64_t tagsbe                       : 1;  /**< Information refers to a single-bit TAG ECC error. */
+	uint64_t noway                        : 1;  /**< Information refers to a NOWAY error. */
+	uint64_t reserved_39_60               : 22;
+	uint64_t syn                          : 7;  /**< Syndrome for the single-bit error. */
+	uint64_t reserved_22_31               : 10;
+	uint64_t way                          : 4;  /**< Way of the L2 block containing the error. */
+	uint64_t l2idx                        : 11; /**< Index of the L2 block containing the error. */
+	uint64_t reserved_0_6                 : 7;
+#else
+	uint64_t reserved_0_6                 : 7;
+	uint64_t l2idx                        : 11;
+	uint64_t way                          : 4;
+	uint64_t reserved_22_31               : 10;
+	uint64_t syn                          : 7;
+	uint64_t reserved_39_60               : 22;
+	uint64_t noway                        : 1;
+	uint64_t tagsbe                       : 1;
+	uint64_t tagdbe                       : 1;
+#endif
+	} cn73xx;
 	struct cvmx_l2c_ttgx_err_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t tagdbe                       : 1;  /**< Information refers to a double-bit TAG ECC error. */
@@ -8324,8 +8507,8 @@ union cvmx_l2c_ttgx_err {
 	uint64_t reserved_39_60               : 22;
 	uint64_t syn                          : 7;  /**< Syndrome for the single-bit error. */
 	uint64_t reserved_24_31               : 8;
-	uint64_t way                          : 4;  /**< Way of the L2 block containing the error */
-	uint64_t l2idx                        : 13; /**< Index of the L2 block containing the error */
+	uint64_t way                          : 4;  /**< Way of the L2 block containing the error. */
+	uint64_t l2idx                        : 13; /**< Index of the L2 block containing the error. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -8717,6 +8900,7 @@ union cvmx_l2c_wpar_iobx {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_wpar_iobx_cn70xx      cn70xxp1;
+	struct cvmx_l2c_wpar_iobx_s           cn73xx;
 	struct cvmx_l2c_wpar_iobx_s           cn78xx;
 	struct cvmx_l2c_wpar_iobx_s           cnf71xx;
 };
@@ -8760,6 +8944,7 @@ union cvmx_l2c_wpar_ppx {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_wpar_ppx_cn70xx       cn70xxp1;
+	struct cvmx_l2c_wpar_ppx_s            cn73xx;
 	struct cvmx_l2c_wpar_ppx_s            cn78xx;
 	struct cvmx_l2c_wpar_ppx_s            cnf71xx;
 };
@@ -8788,6 +8973,7 @@ union cvmx_l2c_xmcx_pfc {
 	struct cvmx_l2c_xmcx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_xmcx_pfc_s            cn70xx;
 	struct cvmx_l2c_xmcx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_xmcx_pfc_s            cn73xx;
 	struct cvmx_l2c_xmcx_pfc_s            cn78xx;
 	struct cvmx_l2c_xmcx_pfc_s            cnf71xx;
 };
@@ -8890,6 +9076,7 @@ union cvmx_l2c_xmc_cmd {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_xmc_cmd_cn70xx        cn70xxp1;
+	struct cvmx_l2c_xmc_cmd_cn70xx        cn73xx;
 	struct cvmx_l2c_xmc_cmd_cn70xx        cn78xx;
 	struct cvmx_l2c_xmc_cmd_cn61xx        cnf71xx;
 };
@@ -8918,6 +9105,7 @@ union cvmx_l2c_xmdx_pfc {
 	struct cvmx_l2c_xmdx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_xmdx_pfc_s            cn70xx;
 	struct cvmx_l2c_xmdx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_xmdx_pfc_s            cn73xx;
 	struct cvmx_l2c_xmdx_pfc_s            cn78xx;
 	struct cvmx_l2c_xmdx_pfc_s            cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c.h b/arch/mips/include/asm/octeon/cvmx-l2c.h
index bee0b31..b251b8f 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c.h
@@ -43,7 +43,7 @@
  * Interface to the Level 2 Cache (L2C) control, measurement, and debugging
  * facilities.
  *
- * <hr>$Revision: 107037 $<hr>
+ * <hr>$Revision: 110377 $<hr>
  *
  */
 
@@ -64,17 +64,19 @@
 #define CVMX_L2C_MAX_PCNT     4
 
 /* Number of L2C Tag-and-data sections (TADs) that are connected to LMC. */
-#define CVMX_L2C_TADS  ((OCTEON_IS_MODEL(OCTEON_CN68XX)) ? 4 : \
-			(OCTEON_IS_MODEL(OCTEON_CN78XX)) ? 8 : 1)
+#define CVMX_L2C_TADS  ((OCTEON_IS_MODEL(OCTEON_CN68XX) \
+		         || OCTEON_IS_MODEL(OCTEON_CN73XX)) ? 4 : \
+				(OCTEON_IS_MODEL(OCTEON_CN78XX)) ? 8 : 1)
 /* Number of L2C IOBs connected to LMC. */
 #define CVMX_L2C_IOBS  ((OCTEON_IS_MODEL(OCTEON_CN68XX) \
-			 || OCTEON_IS_MODEL(OCTEON_CN78XX)) ? 2 : 1)
+			 || OCTEON_IS_MODEL(OCTEON_CN78XX) \
+			 || OCTEON_IS_MODEL(OCTEON_CN73XX)) ? 2 : 1)
 
 /* Defines for Virtualizations, valid only from Octeon II onwards. */
 #define CVMX_L2C_VRT_MAX_VIRTID_ALLOWED ((OCTEON_IS_OCTEON2()) ? 64 : 0)
 #define CVMX_L2C_MAX_MEMSZ_ALLOWED (((OCTEON_IS_OCTEON2() \
 				      || OCTEON_IS_OCTEON3()) \
-				    ? 32 : 0) * (CVMX_L2C_TADS)) /* FIXME for O3 */
+				    ? 32 : 0) * (CVMX_L2C_TADS))
 
   /*------------*/
   /*  TYPEDEFS  */
diff --git a/arch/mips/include/asm/octeon/cvmx-lap.h b/arch/mips/include/asm/octeon/cvmx-lap.h
index 0a63063..3599cdc 100644
--- a/arch/mips/include/asm/octeon/cvmx-lap.h
+++ b/arch/mips/include/asm/octeon/cvmx-lap.h
@@ -58,16 +58,16 @@ typedef enum {
 } cvmx_lap_cmd_e_t;
 
 typedef enum {
-    CVMX_LAP_NONE,
-    CVMX_LAP_TERMINATE,
-    CVMX_LAP_EOP_SKIP,
-    CVMX_LAP_PARITY,
-    CVMX_LAP_LAB_OUT,
-    CVMX_LAP_LAB_INVALID,
-    CVMX_LAP_RESP_TIME,
-    CVMX_LAP_MISMATCH,
-    CVMX_LAP_XID_BAD,
-    CVMX_LAP_TOO_BIG
+    CVMX_LAP_NONE = 0x0,
+    CVMX_LAP_TERMINATE = 0x9,
+    CVMX_LAP_EOP_SKIP = 0xC,
+    CVMX_LAP_PARITY = 0xD,
+    CVMX_LAP_LAB_OUT = 0x21,
+    CVMX_LAP_LAB_INVALID = 0x22,
+    CVMX_LAP_RESP_TIME = 0x23,
+    CVMX_LAP_MISMATCH = 0x24,
+    CVMX_LAP_XID_BAD = 0x25,
+    CVMX_LAP_TOO_BIG = 0x26
 } cvmx_lap_err_e_t;
 
 #define CVMX_LAP_MAX_EXCEPTION_REGS (16)
diff --git a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
index 67f640c..131a6d0 100644
--- a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
@@ -53,59 +53,59 @@
 #define __CVMX_LAPX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_BIST_RESULT(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_BIST_RESULT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_BIST_RESULT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010000ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_BIST_RESULT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010000ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_BIST_RESULT(block_id) (CVMX_ADD_IO_SEG(0x000118000C010000ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_BIST_RESULT(offset) (CVMX_ADD_IO_SEG(0x000118000C010000ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_CFG(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010040ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_CFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010040ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_CFG(block_id) (CVMX_ADD_IO_SEG(0x000118000C010040ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_CFG(offset) (CVMX_ADD_IO_SEG(0x000118000C010040ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_EDAT_ERR_ST(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_EDAT_ERR_ST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_EDAT_ERR_ST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010220ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_EDAT_ERR_ST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010220ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_EDAT_ERR_ST(block_id) (CVMX_ADD_IO_SEG(0x000118000C010220ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_EDAT_ERR_ST(offset) (CVMX_ADD_IO_SEG(0x000118000C010220ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_EMSK_ERR_ST(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_EMSK_ERR_ST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_EMSK_ERR_ST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010218ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_EMSK_ERR_ST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010218ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_EMSK_ERR_ST(block_id) (CVMX_ADD_IO_SEG(0x000118000C010218ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_EMSK_ERR_ST(offset) (CVMX_ADD_IO_SEG(0x000118000C010218ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_ERR_CFG(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_ERR_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_ERR_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010050ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_ERR_CFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010050ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_ERR_CFG(block_id) (CVMX_ADD_IO_SEG(0x000118000C010050ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_ERR_CFG(offset) (CVMX_ADD_IO_SEG(0x000118000C010050ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LAPX_EXPX_DATA(unsigned long offset, unsigned long block_id)
@@ -130,26 +130,26 @@ static inline uint64_t CVMX_LAPX_EXPX_VALID(unsigned long offset, unsigned long
 #define CVMX_LAPX_EXPX_VALID(offset, block_id) (CVMX_ADD_IO_SEG(0x000118000C030000ull) + (((offset) & 15) + ((block_id) & 1) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_FREE_STATE(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_FREE_STATE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_FREE_STATE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010100ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_FREE_STATE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010100ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_FREE_STATE(block_id) (CVMX_ADD_IO_SEG(0x000118000C010100ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_FREE_STATE(offset) (CVMX_ADD_IO_SEG(0x000118000C010100ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_GEN_INT(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_GEN_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_GEN_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010010ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_GEN_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010010ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_GEN_INT(block_id) (CVMX_ADD_IO_SEG(0x000118000C010010ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_GEN_INT(offset) (CVMX_ADD_IO_SEG(0x000118000C010010ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LAPX_LABX_STATE(unsigned long offset, unsigned long block_id)
@@ -174,26 +174,26 @@ static inline uint64_t CVMX_LAPX_LAB_DATAX(unsigned long offset, unsigned long b
 #define CVMX_LAPX_LAB_DATAX(offset, block_id) (CVMX_ADD_IO_SEG(0x000118000C080000ull) + (((offset) & 2047) + ((block_id) & 1) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_LAB_ERR_ST(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_LAB_ERR_ST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_LAB_ERR_ST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010200ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_LAB_ERR_ST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010200ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_LAB_ERR_ST(block_id) (CVMX_ADD_IO_SEG(0x000118000C010200ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_LAB_ERR_ST(offset) (CVMX_ADD_IO_SEG(0x000118000C010200ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_NXT_ERR_ST(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_NXT_ERR_ST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_NXT_ERR_ST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010210ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_NXT_ERR_ST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010210ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_NXT_ERR_ST(block_id) (CVMX_ADD_IO_SEG(0x000118000C010210ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_NXT_ERR_ST(offset) (CVMX_ADD_IO_SEG(0x000118000C010210ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LAPX_QUEX_CFG(unsigned long offset, unsigned long block_id)
@@ -218,59 +218,59 @@ static inline uint64_t CVMX_LAPX_QUEX_STATE(unsigned long offset, unsigned long
 #define CVMX_LAPX_QUEX_STATE(offset, block_id) (CVMX_ADD_IO_SEG(0x000118000C050000ull) + (((offset) & 3) + ((block_id) & 1) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_RESP_STATE(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_RESP_STATE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_RESP_STATE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010108ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_RESP_STATE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010108ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_RESP_STATE(block_id) (CVMX_ADD_IO_SEG(0x000118000C010108ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_RESP_STATE(offset) (CVMX_ADD_IO_SEG(0x000118000C010108ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_SFT_RST(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_SFT_RST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_SFT_RST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C000008ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_SFT_RST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C000008ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_SFT_RST(block_id) (CVMX_ADD_IO_SEG(0x000118000C000008ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_SFT_RST(offset) (CVMX_ADD_IO_SEG(0x000118000C000008ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_STA_ERR_ST(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_STA_ERR_ST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_STA_ERR_ST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010208ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_STA_ERR_ST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010208ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_STA_ERR_ST(block_id) (CVMX_ADD_IO_SEG(0x000118000C010208ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_STA_ERR_ST(offset) (CVMX_ADD_IO_SEG(0x000118000C010208ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_TIMEOUT(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_TIMEOUT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_TIMEOUT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010060ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_TIMEOUT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010060ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_TIMEOUT(block_id) (CVMX_ADD_IO_SEG(0x000118000C010060ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_TIMEOUT(offset) (CVMX_ADD_IO_SEG(0x000118000C010060ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LAPX_XID_POS(unsigned long block_id)
+static inline uint64_t CVMX_LAPX_XID_POS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LAPX_XID_POS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118000C010070ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LAPX_XID_POS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118000C010070ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LAPX_XID_POS(block_id) (CVMX_ADD_IO_SEG(0x000118000C010070ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_LAPX_XID_POS(offset) (CVMX_ADD_IO_SEG(0x000118000C010070ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
index 0114201..f1ec6ad 100644
--- a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_LBK_BIST_RESULT CVMX_LBK_BIST_RESULT_FUNC()
 static inline uint64_t CVMX_LBK_BIST_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_BIST_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000020ull);
 }
@@ -67,6 +67,7 @@ static inline uint64_t CVMX_LBK_BIST_RESULT_FUNC(void)
 static inline uint64_t CVMX_LBK_CHX_PKIND(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_LBK_CHX_PKIND(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180012000200ull) + ((offset) & 63) * 8;
@@ -75,10 +76,21 @@ static inline uint64_t CVMX_LBK_CHX_PKIND(unsigned long offset)
 #define CVMX_LBK_CHX_PKIND(offset) (CVMX_ADD_IO_SEG(0x0001180012000200ull) + ((offset) & 63) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_LBK_CLK_GATE_CTL CVMX_LBK_CLK_GATE_CTL_FUNC()
+static inline uint64_t CVMX_LBK_CLK_GATE_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_LBK_CLK_GATE_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180012000008ull);
+}
+#else
+#define CVMX_LBK_CLK_GATE_CTL (CVMX_ADD_IO_SEG(0x0001180012000008ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_LBK_DAT_ERR_INFO CVMX_LBK_DAT_ERR_INFO_FUNC()
 static inline uint64_t CVMX_LBK_DAT_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_DAT_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000050ull);
 }
@@ -89,7 +101,7 @@ static inline uint64_t CVMX_LBK_DAT_ERR_INFO_FUNC(void)
 #define CVMX_LBK_ECC_CFG CVMX_LBK_ECC_CFG_FUNC()
 static inline uint64_t CVMX_LBK_ECC_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_ECC_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000060ull);
 }
@@ -100,7 +112,7 @@ static inline uint64_t CVMX_LBK_ECC_CFG_FUNC(void)
 #define CVMX_LBK_INT CVMX_LBK_INT_FUNC()
 static inline uint64_t CVMX_LBK_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000040ull);
 }
@@ -111,7 +123,7 @@ static inline uint64_t CVMX_LBK_INT_FUNC(void)
 #define CVMX_LBK_SFT_RST CVMX_LBK_SFT_RST_FUNC()
 static inline uint64_t CVMX_LBK_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000000ull);
 }
@@ -136,6 +148,7 @@ union cvmx_lbk_bist_result {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_lbk_bist_result_s         cn73xx;
 	struct cvmx_lbk_bist_result_s         cn78xx;
 };
 typedef union cvmx_lbk_bist_result cvmx_lbk_bist_result_t;
@@ -154,11 +167,33 @@ union cvmx_lbk_chx_pkind {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_lbk_chx_pkind_s           cn73xx;
 	struct cvmx_lbk_chx_pkind_s           cn78xx;
 };
 typedef union cvmx_lbk_chx_pkind cvmx_lbk_chx_pkind_t;
 
 /**
+ * cvmx_lbk_clk_gate_ctl
+ *
+ * This register is for diagnostic use only.
+ *
+ */
+union cvmx_lbk_clk_gate_ctl {
+	uint64_t u64;
+	struct cvmx_lbk_clk_gate_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t dis                          : 1;  /**< Clock gate disable. When set, forces gated clock to always on. */
+#else
+	uint64_t dis                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_lbk_clk_gate_ctl_s        cn73xx;
+};
+typedef union cvmx_lbk_clk_gate_ctl cvmx_lbk_clk_gate_ctl_t;
+
+/**
  * cvmx_lbk_dat_err_info
  */
 union cvmx_lbk_dat_err_info {
@@ -190,6 +225,7 @@ union cvmx_lbk_dat_err_info {
 	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
+	struct cvmx_lbk_dat_err_info_s        cn73xx;
 	struct cvmx_lbk_dat_err_info_s        cn78xx;
 };
 typedef union cvmx_lbk_dat_err_info cvmx_lbk_dat_err_info_t;
@@ -211,6 +247,7 @@ union cvmx_lbk_ecc_cfg {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_lbk_ecc_cfg_s             cn73xx;
 	struct cvmx_lbk_ecc_cfg_s             cn78xx;
 };
 typedef union cvmx_lbk_ecc_cfg cvmx_lbk_ecc_cfg_t;
@@ -243,6 +280,7 @@ union cvmx_lbk_int {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_lbk_int_s                 cn73xx;
 	struct cvmx_lbk_int_s                 cn78xx;
 };
 typedef union cvmx_lbk_int cvmx_lbk_int_t;
@@ -261,6 +299,7 @@ union cvmx_lbk_sft_rst {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_lbk_sft_rst_s             cn73xx;
 	struct cvmx_lbk_sft_rst_s             cn78xx;
 };
 typedef union cvmx_lbk_sft_rst cvmx_lbk_sft_rst_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index a86010c..86bd5a1 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -53,403 +53,434 @@
 #define __CVMX_LMCX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((block_id) & 0) * 0x60000000ull;
-			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((block_id) & 3) * 0x1000000ull;
-			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800880000F0ull) + ((block_id) & 1) * 0x60000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800880000F0ull) + ((offset) & 1) * 0x60000000ull;
 			break;
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x00011800880000F0ull);
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 0) * 0x60000000ull;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 3) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 	}
-	cvmx_warn("CVMX_LMCX_BIST_CTL (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((block_id) & 3) * 0x1000000ull;
+	cvmx_warn("CVMX_LMCX_BIST_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (block_id) * 0x60000000ull;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800880000F0ull) + (block_id) * 0x60000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800880000F0ull) + (offset) * 0x60000000ull;
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000F0ull);
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x60000000ull;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_BIST_RESULT(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_BIST_RESULT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880000F8ull) + ((offset) & 1) * 0x60000000ull;
 }
+#else
+#define CVMX_LMCX_BIST_RESULT(offset) (CVMX_ADD_IO_SEG(0x00011800880000F8ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_BIST_RESULT(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CHAR_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LMCX_BIST_RESULT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880000F8ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CHAR_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000220ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_BIST_RESULT(block_id) (CVMX_ADD_IO_SEG(0x00011800880000F8ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_CHAR_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000220ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CHAR_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CHAR_DQ_ERR_COUNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CHAR_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000220ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_CHAR_DQ_ERR_COUNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000040ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_CHAR_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000220ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CHAR_DQ_ERR_COUNT(offset) (CVMX_ADD_IO_SEG(0x0001180088000040ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CHAR_DQ_ERR_COUNT(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CHAR_MASK0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_CHAR_DQ_ERR_COUNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000040ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CHAR_MASK0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000228ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_CHAR_DQ_ERR_COUNT(block_id) (CVMX_ADD_IO_SEG(0x0001180088000040ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CHAR_MASK0(offset) (CVMX_ADD_IO_SEG(0x0001180088000228ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CHAR_MASK0(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CHAR_MASK1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CHAR_MASK0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000228ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CHAR_MASK1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000230ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_CHAR_MASK0(block_id) (CVMX_ADD_IO_SEG(0x0001180088000228ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CHAR_MASK1(offset) (CVMX_ADD_IO_SEG(0x0001180088000230ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CHAR_MASK1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CHAR_MASK2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CHAR_MASK1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000230ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CHAR_MASK2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000238ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_CHAR_MASK1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000230ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CHAR_MASK2(offset) (CVMX_ADD_IO_SEG(0x0001180088000238ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CHAR_MASK2(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CHAR_MASK3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CHAR_MASK2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000238ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CHAR_MASK3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000240ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_CHAR_MASK2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000238ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CHAR_MASK3(offset) (CVMX_ADD_IO_SEG(0x0001180088000240ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CHAR_MASK3(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CHAR_MASK4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CHAR_MASK3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000240ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CHAR_MASK4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000318ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_CHAR_MASK3(block_id) (CVMX_ADD_IO_SEG(0x0001180088000240ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CHAR_MASK4(offset) (CVMX_ADD_IO_SEG(0x0001180088000318ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CHAR_MASK4(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_COMP_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CHAR_MASK4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000318ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_COMP_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_CHAR_MASK4(block_id) (CVMX_ADD_IO_SEG(0x0001180088000318ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_COMP_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_COMP_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_COMP_CTL2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_COMP_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_COMP_CTL2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001B8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_COMP_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_COMP_CTL2(offset) (CVMX_ADD_IO_SEG(0x00011800880001B8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_COMP_CTL2(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CONFIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_COMP_CTL2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001B8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CONFIG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000188ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_COMP_CTL2(block_id) (CVMX_ADD_IO_SEG(0x00011800880001B8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CONFIG(offset) (CVMX_ADD_IO_SEG(0x0001180088000188ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CONFIG(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CONTROL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CONFIG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000188ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CONTROL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000190ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_CONFIG(block_id) (CVMX_ADD_IO_SEG(0x0001180088000188ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CONTROL(offset) (CVMX_ADD_IO_SEG(0x0001180088000190ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CONTROL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CONTROL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000190ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000010ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_CONTROL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000190ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000010ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_CTL1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000010ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_CTL1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000010ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_CTL1(offset) (CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_CTL1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DBTRAIN_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_CTL1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_DBTRAIN_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880003F8ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_CTL1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_DBTRAIN_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880003F8ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DCLK_CNT(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DCLK_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DCLK_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001E0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DCLK_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001E0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_DCLK_CNT(block_id) (CVMX_ADD_IO_SEG(0x00011800880001E0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_DCLK_CNT(offset) (CVMX_ADD_IO_SEG(0x00011800880001E0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DCLK_CNT_HI(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DCLK_CNT_HI(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DCLK_CNT_HI(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DCLK_CNT_HI(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_DCLK_CNT_HI(block_id) (CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_DCLK_CNT_HI(offset) (CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DCLK_CNT_LO(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DCLK_CNT_LO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DCLK_CNT_LO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DCLK_CNT_LO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_DCLK_CNT_LO(block_id) (CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_DCLK_CNT_LO(offset) (CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DCLK_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DCLK_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LMCX_DCLK_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880000B8ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_DCLK_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880000B8ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_DCLK_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800880000B8ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_DCLK_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880000B8ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DDR2_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DDR2_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DDR2_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000018ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DDR2_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000018ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_DDR2_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000018ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_DDR2_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000018ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DDR4_DIMM_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DDR4_DIMM_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_DDR4_DIMM_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880003F0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_DDR4_DIMM_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880003F0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_DDR4_DIMM_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800880003F0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_DDR4_DIMM_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880003F0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DDR_PLL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DDR_PLL_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DDR_PLL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000258ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DDR_PLL_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000258ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_DDR_PLL_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000258ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_DDR_PLL_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000258ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DELAY_CFG(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DELAY_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DELAY_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000088ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DELAY_CFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000088ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_DELAY_CFG(block_id) (CVMX_ADD_IO_SEG(0x0001180088000088ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_DELAY_CFG(offset) (CVMX_ADD_IO_SEG(0x0001180088000088ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_DIMMX_DDR4_PARAMS0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_DDR4_PARAMS0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800880000D0ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -462,6 +493,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_DDR4_PARAMS1(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_DDR4_PARAMS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000140ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -478,6 +510,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_PARAMS(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_PARAMS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -487,75 +520,78 @@ static inline uint64_t CVMX_LMCX_DIMMX_PARAMS(unsigned long offset, unsigned lon
 #define CVMX_LMCX_DIMMX_PARAMS(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180088000270ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DIMM_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DIMM_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DIMM_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000310ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DIMM_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000310ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_DIMM_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000310ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_DIMM_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000310ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DLL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DLL_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LMCX_DLL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880000C0ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_DLL_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880000C0ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_DLL_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800880000C0ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_DLL_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880000C0ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DLL_CTL2(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DLL_CTL2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DLL_CTL2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001C8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DLL_CTL2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001C8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_DLL_CTL2(block_id) (CVMX_ADD_IO_SEG(0x00011800880001C8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_DLL_CTL2(offset) (CVMX_ADD_IO_SEG(0x00011800880001C8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DLL_CTL3(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DLL_CTL3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_DLL_CTL3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000218ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_DLL_CTL3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000218ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_DLL_CTL3(block_id) (CVMX_ADD_IO_SEG(0x0001180088000218ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_DLL_CTL3(offset) (CVMX_ADD_IO_SEG(0x0001180088000218ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((block_id) & 1) * 0x60000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 1) * 0x60000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -565,24 +601,28 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((block_id) & 0) * 0x60000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 0) * 0x60000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 3) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_LMCX_DUAL_MEMCFG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((block_id) & 0) * 0x60000000ull;
+	cvmx_warn("CVMX_LMCX_DUAL_MEMCFG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 0) * 0x60000000ull;
 }
 #else
-static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (block_id) * 0x60000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x60000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
@@ -591,27 +631,30 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (block_id) * 0x60000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x60000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (block_id) * 0x60000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x60000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_ECC_PARITY_TEST(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_ECC_PARITY_TEST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_ECC_PARITY_TEST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000108ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_ECC_PARITY_TEST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000108ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_ECC_PARITY_TEST(block_id) (CVMX_ADD_IO_SEG(0x0001180088000108ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_ECC_PARITY_TEST(offset) (CVMX_ADD_IO_SEG(0x0001180088000108ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
@@ -625,24 +668,28 @@ static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long block_id)
 		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 0) * 0x60000000ull;
-			break;
-		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 1) * 0x60000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 0) * 0x60000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 3) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 1) * 0x60000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_LMCX_ECC_SYND (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 0) * 0x60000000ull;
+	cvmx_warn("CVMX_LMCX_ECC_SYND (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 0) * 0x60000000ull;
 }
 #else
-static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
@@ -656,30 +703,44 @@ static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long block_id)
 		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x60000000ull;
-		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x60000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x60000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x60000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x60000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x60000000ull;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_EXT_CONFIG(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_EXT_CONFIG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((offset) & 3) * 0x1000000ull;
 }
+#else
+#define CVMX_LMCX_EXT_CONFIG(offset) (CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_EXT_CONFIG(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_EXT_CONFIG2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_EXT_CONFIG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_EXT_CONFIG2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_EXT_CONFIG(block_id) (CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_EXT_CONFIG2(offset) (CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_FADR(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_FADR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
@@ -693,24 +754,28 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long block_id)
 		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 0) * 0x60000000ull;
-			break;
-		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 1) * 0x60000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 0) * 0x60000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 3) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 1) * 0x60000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_LMCX_FADR (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 0) * 0x60000000ull;
+	cvmx_warn("CVMX_LMCX_FADR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 0) * 0x60000000ull;
 }
 #else
-static inline uint64_t CVMX_LMCX_FADR(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_FADR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
@@ -724,105 +789,144 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long block_id)
 		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x60000000ull;
-		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x60000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x60000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x60000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x60000000ull;
+	return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x60000000ull;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE0(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000340ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_GENERAL_PURPOSE0(offset) (CVMX_ADD_IO_SEG(0x0001180088000340ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE1(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000348ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_GENERAL_PURPOSE1(offset) (CVMX_ADD_IO_SEG(0x0001180088000348ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE2(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000350ull) + ((offset) & 1) * 0x1000000ull;
 }
+#else
+#define CVMX_LMCX_GENERAL_PURPOSE2(offset) (CVMX_ADD_IO_SEG(0x0001180088000350ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_IFB_CNT(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_IFB_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_IFB_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001D0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_IFB_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001D0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_IFB_CNT(block_id) (CVMX_ADD_IO_SEG(0x00011800880001D0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_IFB_CNT(offset) (CVMX_ADD_IO_SEG(0x00011800880001D0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_IFB_CNT_HI(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_IFB_CNT_HI(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_IFB_CNT_HI(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_IFB_CNT_HI(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_IFB_CNT_HI(block_id) (CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_IFB_CNT_HI(offset) (CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_IFB_CNT_LO(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_IFB_CNT_LO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_IFB_CNT_LO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_IFB_CNT_LO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_IFB_CNT_LO(block_id) (CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_IFB_CNT_LO(offset) (CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_INT(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_INT(block_id) (CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_INT(offset) (CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_INT_EN(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_INT_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_INT_EN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_INT_EN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_INT_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_INT_EN(offset) (CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_LANEX_CRC_SWIZ(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 8)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 8)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_LANEX_CRC_SWIZ(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000380ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -831,152 +935,171 @@ static inline uint64_t CVMX_LMCX_LANEX_CRC_SWIZ(unsigned long offset, unsigned l
 #define CVMX_LMCX_LANEX_CRC_SWIZ(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180088000380ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MEM_CFG0(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MEM_CFG0(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_MEM_CFG0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((offset) & 1) * 0x60000000ull;
+}
+#else
+#define CVMX_LMCX_MEM_CFG0(offset) (CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((offset) & 1) * 0x60000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_MEM_CFG1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_MEM_CFG0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_MEM_CFG1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000008ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_MEM_CFG0(block_id) (CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_MEM_CFG1(offset) (CVMX_ADD_IO_SEG(0x0001180088000008ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MEM_CFG1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MODEREG_PARAMS0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_MEM_CFG1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000008ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001A8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MEM_CFG1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000008ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_MODEREG_PARAMS0(offset) (CVMX_ADD_IO_SEG(0x00011800880001A8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MODEREG_PARAMS0(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MODEREG_PARAMS1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001A8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000260ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MODEREG_PARAMS0(block_id) (CVMX_ADD_IO_SEG(0x00011800880001A8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_MODEREG_PARAMS1(offset) (CVMX_ADD_IO_SEG(0x0001180088000260ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MODEREG_PARAMS1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MODEREG_PARAMS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000260ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MODEREG_PARAMS1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000260ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_MODEREG_PARAMS2(offset) (CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MODEREG_PARAMS2(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MODEREG_PARAMS3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MODEREG_PARAMS2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_MODEREG_PARAMS3(offset) (CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MODEREG_PARAMS3(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MPR_DATA0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_MPR_DATA0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MODEREG_PARAMS3(block_id) (CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_MPR_DATA0(offset) (CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MPR_DATA0(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MPR_DATA1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_MPR_DATA0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_MPR_DATA1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MPR_DATA0(block_id) (CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_MPR_DATA1(offset) (CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MPR_DATA1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MPR_DATA2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_MPR_DATA1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_MPR_DATA2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MPR_DATA1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_MPR_DATA2(offset) (CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MPR_DATA2(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_MR_MPR_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_MPR_DATA2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_MR_MPR_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MPR_DATA2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_MR_MPR_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_MR_MPR_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_NS_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_MR_MPR_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_NS_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000178ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_MR_MPR_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_NS_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000178ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_NXM(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_NXM(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((block_id) & 1) * 0x60000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 1) * 0x60000000ull;
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -985,24 +1108,28 @@ static inline uint64_t CVMX_LMCX_NXM(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((block_id) & 0) * 0x60000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 0) * 0x60000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 3) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_LMCX_NXM (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((block_id) & 0) * 0x60000000ull;
+	cvmx_warn("CVMX_LMCX_NXM (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 0) * 0x60000000ull;
 }
 #else
-static inline uint64_t CVMX_LMCX_NXM(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_NXM(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (block_id) * 0x60000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x60000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1010,158 +1137,174 @@ static inline uint64_t CVMX_LMCX_NXM(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (block_id) * 0x60000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x60000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (block_id) * 0x60000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x60000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_NXM_FADR(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_NXM_FADR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_NXM_FADR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_NXM_FADR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_NXM_FADR(block_id) (CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_NXM_FADR(offset) (CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_OPS_CNT(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_OPS_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_OPS_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001D8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_OPS_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001D8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_OPS_CNT(block_id) (CVMX_ADD_IO_SEG(0x00011800880001D8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_OPS_CNT(offset) (CVMX_ADD_IO_SEG(0x00011800880001D8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_OPS_CNT_HI(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_OPS_CNT_HI(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_OPS_CNT_HI(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_OPS_CNT_HI(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_OPS_CNT_HI(block_id) (CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_OPS_CNT_HI(offset) (CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_OPS_CNT_LO(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_OPS_CNT_LO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_OPS_CNT_LO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_OPS_CNT_LO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_OPS_CNT_LO(block_id) (CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_OPS_CNT_LO(offset) (CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_PHY_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_PHY_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_PHY_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000210ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_PHY_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000210ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_PHY_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000210ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_PHY_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000210ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_PLL_BWCTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_PLL_BWCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_PLL_BWCTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_PLL_BWCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000040ull);
 }
 #else
-#define CVMX_LMCX_PLL_BWCTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000040ull))
+#define CVMX_LMCX_PLL_BWCTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000040ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_PLL_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_PLL_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880000A8ull) + ((offset) & 1) * 0x60000000ull;
+}
+#else
+#define CVMX_LMCX_PLL_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880000A8ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_PLL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_PLL_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_PLL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880000A8ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_PLL_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880000B0ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_PLL_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800880000A8ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_PLL_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800880000B0ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_PLL_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_PPR_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_PLL_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880000B0ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_PPR_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880003E0ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_PLL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800880000B0ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_PPR_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880003E0ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_READ_LEVEL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_READ_LEVEL_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LMCX_READ_LEVEL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000140ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_READ_LEVEL_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000140ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_READ_LEVEL_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000140ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_READ_LEVEL_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000140ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_READ_LEVEL_DBG(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_READ_LEVEL_DBG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LMCX_READ_LEVEL_DBG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000148ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_READ_LEVEL_DBG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000148ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_READ_LEVEL_DBG(block_id) (CVMX_ADD_IO_SEG(0x0001180088000148ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_READ_LEVEL_DBG(offset) (CVMX_ADD_IO_SEG(0x0001180088000148ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_READ_LEVEL_RANKX(unsigned long offset, unsigned long block_id)
@@ -1176,55 +1319,91 @@ static inline uint64_t CVMX_LMCX_READ_LEVEL_RANKX(unsigned long offset, unsigned
 #define CVMX_LMCX_READ_LEVEL_RANKX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180088000100ull) + (((offset) & 3) + ((block_id) & 1) * 0xC000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_REF_STATUS(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_REF_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_REF_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_RESET_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000180ull) + ((offset) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_RESET_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000180ull) + ((offset) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_RETRY_CONFIG(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_RETRY_CONFIG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000110ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_RETRY_CONFIG(offset) (CVMX_ADD_IO_SEG(0x0001180088000110ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_RETRY_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_RESET_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000180ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_RETRY_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000118ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_RESET_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000180ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_RETRY_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180088000118ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_RLEVEL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_RLEVEL_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_RLEVEL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880002A0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_RLEVEL_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880002A0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_RLEVEL_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800880002A0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_RLEVEL_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880002A0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_RLEVEL_DBG(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_RLEVEL_DBG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_RLEVEL_DBG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880002A8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_RLEVEL_DBG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880002A8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_RLEVEL_DBG(block_id) (CVMX_ADD_IO_SEG(0x00011800880002A8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_RLEVEL_DBG(offset) (CVMX_ADD_IO_SEG(0x00011800880002A8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_RLEVEL_RANKX(unsigned long offset, unsigned long block_id)
@@ -1235,6 +1414,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_RANKX(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_LMCX_RLEVEL_RANKX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1244,270 +1424,305 @@ static inline uint64_t CVMX_LMCX_RLEVEL_RANKX(unsigned long offset, unsigned lon
 #define CVMX_LMCX_RLEVEL_RANKX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180088000280ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_RODT_COMP_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_RODT_COMP_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_RODT_COMP_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((offset) & 1) * 0x60000000ull;
+}
+#else
+#define CVMX_LMCX_RODT_COMP_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((offset) & 1) * 0x60000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_RODT_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_RODT_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((offset) & 1) * 0x60000000ull;
+}
+#else
+#define CVMX_LMCX_RODT_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((offset) & 1) * 0x60000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_RODT_MASK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_RODT_COMP_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_RODT_MASK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000268ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_RODT_COMP_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_RODT_MASK(offset) (CVMX_ADD_IO_SEG(0x0001180088000268ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_RODT_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SCRAMBLED_FADR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_RODT_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_SCRAMBLED_FADR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000330ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_RODT_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_SCRAMBLED_FADR(offset) (CVMX_ADD_IO_SEG(0x0001180088000330ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_RODT_MASK(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_RODT_MASK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000268ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000320ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_RODT_MASK(block_id) (CVMX_ADD_IO_SEG(0x0001180088000268ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_SCRAMBLE_CFG0(offset) (CVMX_ADD_IO_SEG(0x0001180088000320ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_SCRAMBLED_FADR(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_SCRAMBLED_FADR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000330ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000328ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SCRAMBLED_FADR(block_id) (CVMX_ADD_IO_SEG(0x0001180088000330ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_SCRAMBLE_CFG1(offset) (CVMX_ADD_IO_SEG(0x0001180088000328ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG0(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000320ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000338ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SCRAMBLE_CFG0(block_id) (CVMX_ADD_IO_SEG(0x0001180088000320ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_SCRAMBLE_CFG2(offset) (CVMX_ADD_IO_SEG(0x0001180088000338ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SEQ_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000328ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_SEQ_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SCRAMBLE_CFG1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000328ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_SEQ_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_SEQ_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SLOT_CTL0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_SEQ_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_SLOT_CTL0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001F8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SEQ_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_SLOT_CTL0(offset) (CVMX_ADD_IO_SEG(0x00011800880001F8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_SLOT_CTL0(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SLOT_CTL1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_SLOT_CTL0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001F8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_SLOT_CTL1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000200ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SLOT_CTL0(block_id) (CVMX_ADD_IO_SEG(0x00011800880001F8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_SLOT_CTL1(offset) (CVMX_ADD_IO_SEG(0x0001180088000200ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_SLOT_CTL1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SLOT_CTL2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_SLOT_CTL1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000200ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_SLOT_CTL2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000208ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SLOT_CTL1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000200ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_SLOT_CTL2(offset) (CVMX_ADD_IO_SEG(0x0001180088000208ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_SLOT_CTL2(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_SLOT_CTL3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_SLOT_CTL2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000208ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_SLOT_CTL3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_SLOT_CTL2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000208ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_SLOT_CTL3(offset) (CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_TIMING_PARAMS0(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_TIMING_PARAMS0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_TIMING_PARAMS0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000198ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_TIMING_PARAMS0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000198ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_TIMING_PARAMS0(block_id) (CVMX_ADD_IO_SEG(0x0001180088000198ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_TIMING_PARAMS0(offset) (CVMX_ADD_IO_SEG(0x0001180088000198ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_TIMING_PARAMS1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_TIMING_PARAMS1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_TIMING_PARAMS1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001A0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_TIMING_PARAMS1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001A0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_TIMING_PARAMS1(block_id) (CVMX_ADD_IO_SEG(0x00011800880001A0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_TIMING_PARAMS1(offset) (CVMX_ADD_IO_SEG(0x00011800880001A0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_TIMING_PARAMS2(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_TIMING_PARAMS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_LMCX_TIMING_PARAMS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_LMCX_TIMING_PARAMS2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_TIMING_PARAMS2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_TIMING_PARAMS2(offset) (CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_TRO_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_TRO_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_TRO_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_TRO_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_TRO_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_TRO_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_TRO_STAT(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_TRO_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_TRO_STAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000250ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_TRO_STAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000250ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_TRO_STAT(block_id) (CVMX_ADD_IO_SEG(0x0001180088000250ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_TRO_STAT(offset) (CVMX_ADD_IO_SEG(0x0001180088000250ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_WLEVEL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_WLEVEL_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_WLEVEL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000300ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_WLEVEL_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000300ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_WLEVEL_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000300ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_WLEVEL_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000300ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_WLEVEL_DBG(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_WLEVEL_DBG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_WLEVEL_DBG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000308ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_WLEVEL_DBG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000308ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_WLEVEL_DBG(block_id) (CVMX_ADD_IO_SEG(0x0001180088000308ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_WLEVEL_DBG(offset) (CVMX_ADD_IO_SEG(0x0001180088000308ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned long block_id)
@@ -1535,6 +1750,10 @@ static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned lon
 			if (((offset <= 3)) && ((block_id <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 3)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 1) * 0x200000ull) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_LMCX_WLEVEL_RANKX (%lu, %lu) not supported on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800880002B0ull) + (((offset) & 3) + ((block_id) & 0) * 0x200000ull) * 8;
@@ -1555,57 +1774,60 @@ static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned lon
 			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800880002B0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_WODT_CTL0(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_WODT_CTL0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_WODT_CTL0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_WODT_CTL0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_WODT_CTL0(block_id) (CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_WODT_CTL0(offset) (CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_WODT_CTL1(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_WODT_CTL1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_LMCX_WODT_CTL1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((block_id) & 1) * 0x60000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_WODT_CTL1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((offset) & 1) * 0x60000000ull;
 }
 #else
-#define CVMX_LMCX_WODT_CTL1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((block_id) & 1) * 0x60000000ull)
+#define CVMX_LMCX_WODT_CTL1(offset) (CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((offset) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_LMCX_WODT_MASK(unsigned long block_id)
+static inline uint64_t CVMX_LMCX_WODT_MASK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_LMCX_WODT_MASK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800880001B0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_LMCX_WODT_MASK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800880001B0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_LMCX_WODT_MASK(block_id) (CVMX_ADD_IO_SEG(0x00011800880001B0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_LMCX_WODT_MASK(offset) (CVMX_ADD_IO_SEG(0x00011800880001B0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 
 /**
@@ -1618,17 +1840,20 @@ union cvmx_lmcx_bist_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_bist_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_5_63                : 59;
+	uint64_t macram_bist_status           : 1;  /**< Reserved. */
 	uint64_t dlcram_bist_status           : 1;  /**< DLC RAM BIST status; 1 means fail. */
-	uint64_t dlcram_bist_done             : 1;  /**< DLC RAM BIST complete indication; 1 means complete. */
-	uint64_t start_bist                   : 1;  /**< Start BIST on DLC memory. */
+	uint64_t dlcram_bist_done             : 1;  /**< DLC and MAC RAM BIST complete indication;
+                                                         1 means both RAMs have completed. */
+	uint64_t start_bist                   : 1;  /**< Start BIST on DLC and MAC memory. */
 	uint64_t reserved_0_0                 : 1;
 #else
 	uint64_t reserved_0_0                 : 1;
 	uint64_t start_bist                   : 1;
 	uint64_t dlcram_bist_done             : 1;
 	uint64_t dlcram_bist_status           : 1;
-	uint64_t reserved_4_63                : 60;
+	uint64_t macram_bist_status           : 1;
+	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
 	struct cvmx_lmcx_bist_ctl_cn50xx {
@@ -1660,7 +1885,26 @@ union cvmx_lmcx_bist_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_bist_ctl_cn70xx      cn70xxp1;
-	struct cvmx_lmcx_bist_ctl_cn70xx      cn78xx;
+	struct cvmx_lmcx_bist_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t macram_bist_status           : 1;  /**< Maximum Activate Counts RAM BIST status.
+                                                         1 means fail. */
+	uint64_t dlcram_bist_status           : 1;  /**< DLC RAM BIST status; 1 means fail. */
+	uint64_t dlcram_bist_done             : 1;  /**< DLC and MAC RAM BIST complete indication;
+                                                         1 means both RAMs have completed. */
+	uint64_t start_bist                   : 1;  /**< Start BIST on DLC and MAC memory. */
+	uint64_t clear_bist                   : 1;  /**< Start clear BIST on DLC and MAC memory. */
+#else
+	uint64_t clear_bist                   : 1;
+	uint64_t start_bist                   : 1;
+	uint64_t dlcram_bist_done             : 1;
+	uint64_t dlcram_bist_status           : 1;
+	uint64_t macram_bist_status           : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} cn73xx;
+	struct cvmx_lmcx_bist_ctl_cn73xx      cn78xx;
 };
 typedef union cvmx_lmcx_bist_ctl cvmx_lmcx_bist_ctl_t;
 
@@ -1802,6 +2046,7 @@ union cvmx_lmcx_char_ctl {
 	struct cvmx_lmcx_char_ctl_cn63xx      cn68xxp1;
 	struct cvmx_lmcx_char_ctl_s           cn70xx;
 	struct cvmx_lmcx_char_ctl_s           cn70xxp1;
+	struct cvmx_lmcx_char_ctl_s           cn73xx;
 	struct cvmx_lmcx_char_ctl_s           cn78xx;
 	struct cvmx_lmcx_char_ctl_cn61xx      cnf71xx;
 };
@@ -1826,6 +2071,7 @@ union cvmx_lmcx_char_dq_err_count {
 	} s;
 	struct cvmx_lmcx_char_dq_err_count_s  cn70xx;
 	struct cvmx_lmcx_char_dq_err_count_s  cn70xxp1;
+	struct cvmx_lmcx_char_dq_err_count_s  cn73xx;
 	struct cvmx_lmcx_char_dq_err_count_s  cn78xx;
 };
 typedef union cvmx_lmcx_char_dq_err_count cvmx_lmcx_char_dq_err_count_t;
@@ -1853,6 +2099,7 @@ union cvmx_lmcx_char_mask0 {
 	struct cvmx_lmcx_char_mask0_s         cn68xxp1;
 	struct cvmx_lmcx_char_mask0_s         cn70xx;
 	struct cvmx_lmcx_char_mask0_s         cn70xxp1;
+	struct cvmx_lmcx_char_mask0_s         cn73xx;
 	struct cvmx_lmcx_char_mask0_s         cn78xx;
 	struct cvmx_lmcx_char_mask0_s         cnf71xx;
 };
@@ -1883,6 +2130,7 @@ union cvmx_lmcx_char_mask1 {
 	struct cvmx_lmcx_char_mask1_s         cn68xxp1;
 	struct cvmx_lmcx_char_mask1_s         cn70xx;
 	struct cvmx_lmcx_char_mask1_s         cn70xxp1;
+	struct cvmx_lmcx_char_mask1_s         cn73xx;
 	struct cvmx_lmcx_char_mask1_s         cn78xx;
 	struct cvmx_lmcx_char_mask1_s         cnf71xx;
 };
@@ -1911,6 +2159,7 @@ union cvmx_lmcx_char_mask2 {
 	struct cvmx_lmcx_char_mask2_s         cn68xxp1;
 	struct cvmx_lmcx_char_mask2_s         cn70xx;
 	struct cvmx_lmcx_char_mask2_s         cn70xxp1;
+	struct cvmx_lmcx_char_mask2_s         cn73xx;
 	struct cvmx_lmcx_char_mask2_s         cn78xx;
 	struct cvmx_lmcx_char_mask2_s         cnf71xx;
 };
@@ -1941,6 +2190,7 @@ union cvmx_lmcx_char_mask3 {
 	struct cvmx_lmcx_char_mask3_s         cn68xxp1;
 	struct cvmx_lmcx_char_mask3_s         cn70xx;
 	struct cvmx_lmcx_char_mask3_s         cn70xxp1;
+	struct cvmx_lmcx_char_mask3_s         cn73xx;
 	struct cvmx_lmcx_char_mask3_s         cn78xx;
 	struct cvmx_lmcx_char_mask3_s         cnf71xx;
 };
@@ -2075,6 +2325,7 @@ union cvmx_lmcx_char_mask4 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_char_mask4_cn70xx    cn70xxp1;
+	struct cvmx_lmcx_char_mask4_s         cn73xx;
 	struct cvmx_lmcx_char_mask4_s         cn78xx;
 	struct cvmx_lmcx_char_mask4_cn61xx    cnf71xx;
 };
@@ -2427,6 +2678,7 @@ union cvmx_lmcx_comp_ctl2 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_comp_ctl2_cn70xx     cn70xxp1;
+	struct cvmx_lmcx_comp_ctl2_cn70xx     cn73xx;
 	struct cvmx_lmcx_comp_ctl2_cn70xx     cn78xx;
 	struct cvmx_lmcx_comp_ctl2_cn61xx     cnf71xx;
 };
@@ -2450,7 +2702,7 @@ union cvmx_lmcx_config {
 	uint64_t u64;
 	struct cvmx_lmcx_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_63_63               : 1;
+	uint64_t lrdimm_ena                   : 1;  /**< Reserved. */
 	uint64_t bg2_enable                   : 1;  /**< BG2 pin is active for DDR4 mode. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
                                                          Typically only cleared for DDR4 *16 devices, where there is no BG2 pin on the device. */
 	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
@@ -2648,7 +2900,7 @@ union cvmx_lmcx_config {
 	uint64_t mode32b                      : 1;
 	uint64_t mode_x4dev                   : 1;
 	uint64_t bg2_enable                   : 1;
-	uint64_t reserved_63_63               : 1;
+	uint64_t lrdimm_ena                   : 1;
 #endif
 	} s;
 	struct cvmx_lmcx_config_cn61xx {
@@ -3788,7 +4040,201 @@ union cvmx_lmcx_config {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_config_cn70xx        cn70xxp1;
-	struct cvmx_lmcx_config_cn70xx        cn78xx;
+	struct cvmx_lmcx_config_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t lrdimm_ena                   : 1;  /**< Load Reduced DIMM Enable. When set allows the use of JEDEC DDR4 LRDIMMs. */
+	uint64_t bg2_enable                   : 1;  /**< BG2 pin is active for DDR4 mode. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
+                                                         Typically only cleared for DDR4 *16 devices, where there is no BG2 pin on the device. */
+	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
+	uint64_t mode32b                      : 1;  /**< 32-bit datapath mode. When set, only 32 DQ pins are used. */
+	uint64_t scrz                         : 1;  /**< Hide LMC()_SCRAMBLE_CFG0 and LMC()_SCRAMBLE_CFG1 when set. */
+	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 3 reads.
+                                                         The recommended EARLY_UNLOAD_D1_R1 value can be calculated after the final
+                                                         LMC()_RLEVEL_RANK3[BYTE*] values are selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting for rank 3 (i.e. calculate
+                                                         maxset=MAX(LMC()_RLEVEL_RANK3[BYTEi]) across all i), then set EARLY_UNLOAD_D1_R1 when the
+                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_R1 = (maxset<1:0>
+                                                         !=3)). */
+	uint64_t early_unload_d1_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 2 reads.
+                                                         The recommended EARLY_UNLOAD_D1_RO value can be calculated after the final
+                                                         LMC()_RLEVEL_RANK2[BYTE*] values are selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting for rank 2 (i.e. calculate
+                                                         maxset=MAX(LMC()_RLEVEL_RANK2[BYTEi]) across all i), then set EARLY_UNLOAD_D1_RO when the
+                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_RO = (maxset<1:0>
+                                                         !=3)). */
+	uint64_t early_unload_d0_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 1 reads.
+                                                         The recommended EARLY_UNLOAD_D0_R1 value can be calculated after the final
+                                                         LMC()_RLEVEL_RANK1[BYTE*] values are selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting for rank 1 (i.e. calculate
+                                                         maxset=MAX(LMC()_RLEVEL_RANK1[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R1 when the
+                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R1 = (maxset<1:0>
+                                                         !=3)). */
+	uint64_t early_unload_d0_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 0 reads.
+                                                         The recommended EARLY_UNLOAD_D0_R0 value can be calculated after the final
+                                                         LMC()_RLEVEL_RANK0[BYTE*] values are selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting for rank 0 (i.e. calculate
+                                                         maxset=MAX(LMC()_RLEVEL_RANK0[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R0 when the
+                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R0 = (maxset<1:0>
+                                                         !=3)). */
+	uint64_t init_status                  : 4;  /**< Indicates status of initialization. INIT_STATUS[n] = 1 implies rank n has been
+                                                         initialized.
+                                                         Software must set necessary RANKMASK bits before executing the initialization sequence
+                                                         using LMC()_SEQ_CTL. If the rank has been selected for init with the RANKMASK bits,
+                                                         the INIT_STATUS bits will be set after successful initialization and after self-refresh
+                                                         exit. INIT_STATUS determines the chip-selects that assert during refresh, ZQCS, precharge
+                                                         power-down entry/exit, and self-refresh entry SEQ_SELs. */
+	uint64_t mirrmask                     : 4;  /**< "Mask determining which ranks are address-mirrored.
+                                                         MIRRMASK<n> = 1 means Rank n addresses are mirrored for
+                                                         0 <= n <= 3.
+                                                         In DDR3, a mirrored read/write operation has the following differences:
+                                                         * DDR#_BA<1> is swapped with DDR#_BA<0>.
+                                                         * DDR#_A<8> is swapped with DDR#_A<7>.
+                                                         * DDR#_A<6> is swapped with DDR#_A<5>.
+                                                         * DDR#_A<4> is swapped with DDR#_A<3>.
+                                                         When RANK_ENA = 0, MIRRMASK<1> MBZ.
+                                                         In DDR4, a mirrored read/write operation has the following differences:
+                                                         * DDR#_BG<1> is swapped with DDR#_BG<0>.
+                                                         * DDR#_BA<1> is swapped with DDR#_BA<0>.
+                                                         * DDR#_A<13> is swapped with DDR#_A<11>.
+                                                         * DDR#_A<8> is swapped with DDR#_A<7>.
+                                                         * DDR#_A<6> is swapped with DDR#_A<5>.
+                                                         * DDR#_A<4> is swapped with DDR#_A<3>.
+                                                         For CN70XX, MIRRMASK<3:2> MBZ.
+                                                         * When RANK_ENA = 0, MIRRMASK<1> MBZ." */
+	uint64_t rankmask                     : 4;  /**< Mask to select rank to be leveled/initialized. To write-level/read-level/initialize rank
+                                                         i, set RANKMASK<i>:
+                                                         <pre>
+                                                                       RANK_ENA = 1   RANK_ENA = 0
+                                                         RANKMASK<0> = DIMM0_CS0      DIMM0_CS0
+                                                         RANKMASK<1> = DIMM0_CS1      MBZ
+                                                         RANKMASK<2> = DIMM1_CS0      DIMM1_CS0
+                                                         RANKMASK<3> = DIMM1_CS1      MBZ
+                                                         </pre>
+                                                         For read/write leveling, each rank has to be leveled separately, so RANKMASK should only
+                                                         have one bit set. RANKMASK is not used during self-refresh entry/exit and precharge power-
+                                                         down entry/exit instruction sequences. When RANK_ENA = 0, RANKMASK<1> and RANKMASK<3> MBZ. */
+	uint64_t rank_ena                     : 1;  /**< "RANK enable (for use with dual-rank DIMMs).
+                                                         * For dual-rank DIMMs, the RANK_ENA bit will enable the drive of the DDR#_DIMM*_CS*_L and
+                                                         ODT_<1:0> pins differently based on the (PBANK_LSB - 1) address bit.
+                                                         * Write 0 for SINGLE ranked DIMMs." */
+	uint64_t sref_with_dll                : 1;  /**< Self-refresh entry/exit write mode registers. When set, self-refresh entry sequence writes
+                                                         MR2 and MR1 (in this order, in all ranks), and self-refresh exit sequence writes MR1, MR0,
+                                                         MR2, and MR3 (in this order, for all ranks). The write operations occur before self-
+                                                         refresh entry, and after self-refresh exit. When clear, self-refresh entry and exit
+                                                         instruction sequences do not write any mode registers in the DDR3/4 parts. */
+	uint64_t early_dqx                    : 1;  /**< Set this bit to send DQx signals one CK cycle earlier for the case when the shortest DQx
+                                                         lines have a larger delay than the CK line. */
+	uint64_t ref_zqcs_int                 : 22; /**< Refresh interval is represented in number of 512 CK cycle increments. ZQCS interval is
+                                                         represented in a number of refresh intervals. A refresh sequence is triggered when bits
+                                                         <24:18> are equal to 0x0, and a ZQCS sequence is triggered when <39:18> are equal to 0x0.
+                                                         The ZQCS timer only decrements when the refresh timer is 0.
+                                                         Program <24:18> to RND-DN(TREFI/clkPeriod/512).
+                                                         A value of 0 in bits <24:18> will effectively turn off refresh.
+                                                         Program <36:25> to (RND-DN(ZQCS_Period / Refresh_Period) - 1), where Refresh_Period is the
+                                                         effective period programmed in bits <24:18>. Note that this value should always be greater
+                                                         than 32, to account for resistor calibration delays.
+                                                         000_00000000_0000000: Reserved
+                                                         Max Refresh interval = 127 * 512= 65024 CK cycles.
+                                                         Max ZQCS interval = 32768 * 127 * 512 = 2130706432 CK cycles.
+                                                         If refresh interval is programmed to ~8us, max ZQCS interval is ~262ms, or ~4 ZQCS
+                                                         operations per second.
+                                                         LMC()_CONFIG[INIT_STATUS] determines which ranks receive the REF / ZQCS. LMC does not
+                                                         send any refreshes / ZQCS's when LMC()_CONFIG[INIT_STATUS]=0. */
+	uint64_t reset                        : 1;  /**< Reset one-shot pulse for LMC()_OPS_CNT, LMC()_IFB_CNT, and LMC()_DCLK_CNT
+                                                         CSRs.
+                                                         To cause the reset, software writes this to a 1, then rewrites it to a 0. */
+	uint64_t ecc_adr                      : 1;  /**< Include memory reference address in the ECC calculation.
+                                                         0 = disabled, 1 = enabled. */
+	uint64_t forcewrite                   : 4;  /**< Force the oldest outstanding write to complete after having waited for 2^FORCEWRITE CK
+                                                         cycles. 0 = disabled. */
+	uint64_t idlepower                    : 3;  /**< Enter precharge power-down mode after the memory controller has been idle for
+                                                         2^(2+IDLEPOWER) CK cycles. 0 = disabled.
+                                                         This field should only be programmed after initialization.
+                                                         LMC()_MODEREG_PARAMS0[PPD] determines whether the DRAM DLL is disabled during the
+                                                         precharge power-down. */
+	uint64_t pbank_lsb                    : 4;  /**< DIMM address bit select. Reverting to the explanation for ROW_LSB, PBANK_LSB would be:
+                                                         ROW_LSB bit + num_rowbits + num_rankbits
+                                                         Decoding for PBANK_LSB:
+                                                         0x0: DIMM = mem_adr<28>; if RANK_ENA=1, rank = mem_adr<27>.
+                                                         0x1: DIMM = mem_adr<29>; if RANK_ENA=1, rank = mem_adr<28>.
+                                                         0x2: DIMM = mem_adr<30>; if RANK_ENA=1, rank = mem_adr<29>.
+                                                         0x3: DIMM = mem_adr<31>; if RANK_ENA=1, rank = mem_adr<30>.
+                                                         0x4: DIMM = mem_adr<32>; if RANK_ENA=1, rank = mem_adr<31>.
+                                                         0x5: DIMM = mem_adr<33>; if RANK_ENA=1, rank = mem_adr<32>.
+                                                         0x6: DIMM = mem_adr<34>; if RANK_ENA=1, rank = mem_adr<33>.
+                                                         0x7: DIMM = mem_adr<35>; if RANK_ENA=1, rank = mem_adr<34>.
+                                                         0x8: DIMM = mem_adr<36>; if RANK_ENA=1, rank = mem_adr<35>.
+                                                         0x9: DIMM = mem_adr<37>; if RANK_ENA=1, rank = mem_adr<36>.
+                                                         0xA: DIMM = 0;           if RANK_ENA=1, rank = mem_adr<37>.
+                                                         0xB-0xF: Reserved.
+                                                         For example, for a DIMM made of Samsung's K4B1G0846C-F7 1Gb (16M * 8 bit * 8 bank)
+                                                         parts, the column address width = 10, so with 10b of col, 3b of bus, 3b of bank, ROW_LSB =
+                                                         16. So, row = mem_adr<29:16>.
+                                                         With RANK_ENA = 0, PBANK_LSB = 2.
+                                                         With RANK_ENA = 1, PBANK_LSB = 3.
+                                                         TBD for interfacing with 8H 3DS, regardless of RANK_ENA value, set this 0xA. */
+	uint64_t row_lsb                      : 3;  /**< "Row address bit select.
+                                                         0x0 = Address bit 14 is LSB.
+                                                         0x1 = Address bit 15 is LSB.
+                                                         0x2 = Address bit 16 is LSB.
+                                                         0x3 = Address bit 17 is LSB.
+                                                         0x4 = Address bit 18 is LSB.
+                                                         0x5 = Address bit 19 is LSB.
+                                                         0x6 = Address bit 20 is LSB.
+                                                         0x6 = Reserved.
+                                                         Encoding used to determine which memory address bit position represents the low order DDR
+                                                         ROW address. The processor's memory address<34:7> needs to be translated to DRAM addresses
+                                                         (bnk,row,col,rank and DIMM) and that is a function of the following:
+                                                         * Datapath width (64).
+                                                         * Number of banks (8).
+                                                         * Number of column bits of the memory part--specified indirectly by this register.
+                                                         * Number of row bits of the memory part--specified indirectly by PBANK_LSB.
+                                                         * Number of ranks in a DIMM--specified by RANK_ENA.
+                                                         * Number of DIMMs in the system by the register below (PBANK_LSB).
+                                                         Col address starts from mem_addr[3] for 64b (8Bytes) DQ width. ROW_LSB is mem_adr[15] for
+                                                         64b mode. Therefore, the ROW_LSB parameter should be set to 001 (64b).
+                                                         For example, for a DIMM made of Samsung's K4B1G0846C-F7 1GB (16M * 8 bit * 8 bank)
+                                                         parts, the column address width = 10, so with 10b of col, 3b of bus, 3b of bank, ROW_LSB =
+                                                         16. So, row = mem_adr<29:16>.
+                                                         Refer to Cache-block Read Transaction Example, Cache-block Read Transaction Example." */
+	uint64_t ecc_ena                      : 1;  /**< ECC enable. When set, enables the 8b ECC check/correct logic. Should be 1 when used with
+                                                         DIMMs with ECC; 0, otherwise.
+                                                         * When this mode is turned on, DQ<71:64> on write operations contains the ECC code
+                                                         generated for the 64 bits of data which will be written in the memory. Later on read
+                                                         operations, will be used to check for single-bit error (which will be auto-corrected) and
+                                                         double-bit error (which will be reported).
+                                                         * When not turned on, DQ<71:64> are driven to 0. Please refer to SEC_ERR, DED_ERR,
+                                                         LMC()_FADR, and LMC()_ECC_SYND registers for diagnostics information when there is
+                                                         an error. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t ecc_ena                      : 1;
+	uint64_t row_lsb                      : 3;
+	uint64_t pbank_lsb                    : 4;
+	uint64_t idlepower                    : 3;
+	uint64_t forcewrite                   : 4;
+	uint64_t ecc_adr                      : 1;
+	uint64_t reset                        : 1;
+	uint64_t ref_zqcs_int                 : 22;
+	uint64_t early_dqx                    : 1;
+	uint64_t sref_with_dll                : 1;
+	uint64_t rank_ena                     : 1;
+	uint64_t rankmask                     : 4;
+	uint64_t mirrmask                     : 4;
+	uint64_t init_status                  : 4;
+	uint64_t early_unload_d0_r0           : 1;
+	uint64_t early_unload_d0_r1           : 1;
+	uint64_t early_unload_d1_r0           : 1;
+	uint64_t early_unload_d1_r1           : 1;
+	uint64_t scrz                         : 1;
+	uint64_t mode32b                      : 1;
+	uint64_t mode_x4dev                   : 1;
+	uint64_t bg2_enable                   : 1;
+	uint64_t lrdimm_ena                   : 1;
+#endif
+	} cn73xx;
+	struct cvmx_lmcx_config_cn73xx        cn78xx;
 	struct cvmx_lmcx_config_cn61xx        cnf71xx;
 };
 typedef union cvmx_lmcx_config cvmx_lmcx_config_t;
@@ -4200,6 +4646,7 @@ union cvmx_lmcx_control {
 	struct cvmx_lmcx_control_cn68xx       cn68xxp1;
 	struct cvmx_lmcx_control_s            cn70xx;
 	struct cvmx_lmcx_control_s            cn70xxp1;
+	struct cvmx_lmcx_control_s            cn73xx;
 	struct cvmx_lmcx_control_s            cn78xx;
 	struct cvmx_lmcx_control_cn66xx       cnf71xx;
 };
@@ -5053,6 +5500,86 @@ union cvmx_lmcx_ctl1 {
 typedef union cvmx_lmcx_ctl1 cvmx_lmcx_ctl1_t;
 
 /**
+ * cvmx_lmc#_dbtrain_ctl
+ *
+ * This register contains control bits that are used during the Data Buffer
+ * training sequence in DDR4 LRDIMM mode. When one of the data buffer training
+ * sequence is initiated, it uses the contents of this register to control
+ * its operation.
+ */
+union cvmx_lmcx_dbtrain_ctl {
+	uint64_t u64;
+	struct cvmx_lmcx_dbtrain_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t db_output_impedance          : 3;  /**< Host Interface DQ/DQS Output Driver Impedance control.
+                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
+                                                         environment, i.e., CONFIG[LRDIMM_ENA] = 1, SEQ_CTL[SEQ_SEL] = 0x6.
+                                                         0x0 = RZQ/6 (40 ohm).
+                                                         0x1 = RZQ/7 (34 ohm).
+                                                         0x2 = RZQ/5 (48 ohm).
+                                                         0x3-0x7 = Reserved. */
+	uint64_t db_sel                       : 1;  /**< Used when running Host Interface Write Leveling.
+                                                         0 = selects DIMM0's Data Buffer.
+                                                         1 = selects DIMM1's Data Buffer. */
+	uint64_t tccd_sel                     : 1;  /**< When set, the sequence uses MODEREG_PARAMS3[TCCD_L] to space out
+                                                         back-to-back read commands. Otherwise it will space out back-to-back
+                                                         reads with a default value of 4 cycles.
+                                                         While in DRAM MPR mode, reads from Page 0 may use tCCD_S or tCCD_L.
+                                                         Reads from Pages 1, 2 or 3 however must use tCCD_L, thereby requring
+                                                         this bit to be set. */
+	uint64_t rw_train                     : 1;  /**< When set, the DBTRAIN sequence will perform a Write to the DRAM
+                                                         memory array using burst patern that are set in the CSRs
+                                                         LMC()_GENERAL_PURPOSE0[DATA]<61:0>, LMC()_GENERAL_PURPOSE1[DATA]<61:0> and
+                                                         LMC()_GENERAL_PURPOSE2[DATA]<15:0>.
+                                                         This burst pattern gets shifted by one byte at every cycle.
+                                                         The sequence will then do the reads to the same location and compare
+                                                         the data coming back with this pattern.
+                                                         The bit-wise comparison result gets stored in
+                                                         LMC()_MPR_DATA0[MPR_DATA]<63:0> and LMC()_MPR_DATA1[MPR_DATA]<7:0>. */
+	uint64_t read_dq_count                : 7;  /**< The amount of cycles until a pulse is issued to sample the DQ into the
+                                                         MPR register. This bits control the timing of when to sample the data
+                                                         buffer training result. */
+	uint64_t read_cmd_count               : 5;  /**< The amount of Read Commands to be sent during the data buffer training.
+                                                         This can be set to zero in which case the sequence does not send any
+                                                         Read commands to accommodate for the DWL training mode. */
+	uint64_t write_ena                    : 1;  /**< Enables the write operation. This is mainly used to accomplish the MWD
+                                                         training sequence of the data buffer.
+                                                         DBTRAIN_CTL[ACTIVATE] must be set to 1 for this to take effect. */
+	uint64_t activate                     : 1;  /**< Enables the activate command during the data buffer training sequence. */
+	uint64_t prank                        : 2;  /**< Physical Rank bits for Read/Write/Activate operation during the data buffer
+                                                         training. */
+	uint64_t lrank                        : 3;  /**< Logical Rank bits for Read/Write/Activate operation during the data buffer
+                                                         training. */
+	uint64_t row_a                        : 18; /**< The row address for the Activate command during dbtrain. */
+	uint64_t bg                           : 2;  /**< The Bank Group that the commands are directed to while in data buffer
+                                                         training sequence. */
+	uint64_t ba                           : 2;  /**< The bank address for the commands while in data buffer training sequence. */
+	uint64_t column_a                     : 13; /**< Column address for the Read/Write operation during the data buffer
+                                                         training. */
+#else
+	uint64_t column_a                     : 13;
+	uint64_t ba                           : 2;
+	uint64_t bg                           : 2;
+	uint64_t row_a                        : 18;
+	uint64_t lrank                        : 3;
+	uint64_t prank                        : 2;
+	uint64_t activate                     : 1;
+	uint64_t write_ena                    : 1;
+	uint64_t read_cmd_count               : 5;
+	uint64_t read_dq_count                : 7;
+	uint64_t rw_train                     : 1;
+	uint64_t tccd_sel                     : 1;
+	uint64_t db_sel                       : 1;
+	uint64_t db_output_impedance          : 3;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} s;
+	struct cvmx_lmcx_dbtrain_ctl_s        cn73xx;
+};
+typedef union cvmx_lmcx_dbtrain_ctl cvmx_lmcx_dbtrain_ctl_t;
+
+/**
  * cvmx_lmc#_dclk_cnt
  *
  * LMC_DCLK_CNT  = Performance Counters
@@ -5076,6 +5603,7 @@ union cvmx_lmcx_dclk_cnt {
 	struct cvmx_lmcx_dclk_cnt_s           cn68xxp1;
 	struct cvmx_lmcx_dclk_cnt_s           cn70xx;
 	struct cvmx_lmcx_dclk_cnt_s           cn70xxp1;
+	struct cvmx_lmcx_dclk_cnt_s           cn73xx;
 	struct cvmx_lmcx_dclk_cnt_s           cn78xx;
 	struct cvmx_lmcx_dclk_cnt_s           cnf71xx;
 };
@@ -5431,14 +5959,45 @@ typedef union cvmx_lmcx_ddr2_ctl cvmx_lmcx_ddr2_ctl_t;
 /**
  * cvmx_lmc#_ddr4_dimm_ctl
  *
- * This register is used only when LMC(0..3)_CONTROL[RDIMM_ENA] = 1. During an RCW initialization
- * sequence, this register controls LMC's write operations to the extended DDR4 control words in
- * the JEDEC standard registering clock driver on an RDIMM.
+ * Bits 0-21 of this register is used only when LMC()_CONTROL[RDIMM_ENA] = 1.
+ *
+ * Bits 22-27 is used only when LMC()_CONFIG[LRDIMM_ENA] = 1 AND
+ * LMC()_MR_MPR_CTL[MR_WR_PBA_ENABLE] = 1.
+ *
+ * During an RCW initialization sequence, bits 0-21 controls LMC's write
+ * operations to the extended DDR4 control words in the JEDEC standard
+ * registering clock driver on an RDIMM.
+ *
+ * During PBA mode of an MRW sequence, bits 22-27 controls the Buffer Configuration
+ * Control Word F0BC1x settings during the BCW write.
  */
 union cvmx_lmcx_ddr4_dimm_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_ddr4_dimm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_28_63               : 36;
+	uint64_t rank_timing_enable           : 1;  /**< Reserved. */
+	uint64_t bodt_trans_mode              : 1;  /**< Reserved. */
+	uint64_t trans_mode_ena               : 1;  /**< Reserved. */
+	uint64_t read_preamble_mode           : 1;  /**< Reserved. */
+	uint64_t buff_config_da3              : 1;  /**< Reserved. */
+	uint64_t mpr_over_ena                 : 1;  /**< Reserved. */
+	uint64_t ddr4_dimm1_wmask             : 11; /**< DIMM1 write mask. If (DIMM1_WMASK[n] = 1), write DIMM1.RCn. */
+	uint64_t ddr4_dimm0_wmask             : 11; /**< DIMM0 write mask. If (DIMM0_WMASK[n] = 1), write DIMM0.RCn. */
+#else
+	uint64_t ddr4_dimm0_wmask             : 11;
+	uint64_t ddr4_dimm1_wmask             : 11;
+	uint64_t mpr_over_ena                 : 1;
+	uint64_t buff_config_da3              : 1;
+	uint64_t read_preamble_mode           : 1;
+	uint64_t trans_mode_ena               : 1;
+	uint64_t bodt_trans_mode              : 1;
+	uint64_t rank_timing_enable           : 1;
+	uint64_t reserved_28_63               : 36;
+#endif
+	} s;
+	struct cvmx_lmcx_ddr4_dimm_ctl_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_22_63               : 42;
 	uint64_t ddr4_dimm1_wmask             : 11; /**< DIMM1 write mask. If (DIMM1_WMASK[n] = 1), write DIMM1.RCn. */
 	uint64_t ddr4_dimm0_wmask             : 11; /**< DIMM0 write mask. If (DIMM0_WMASK[n] = 1), write DIMM0.RCn. */
@@ -5447,9 +6006,9 @@ union cvmx_lmcx_ddr4_dimm_ctl {
 	uint64_t ddr4_dimm1_wmask             : 11;
 	uint64_t reserved_22_63               : 42;
 #endif
-	} s;
-	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn70xx;
-	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn70xxp1;
+	} cn70xx;
+	struct cvmx_lmcx_ddr4_dimm_ctl_cn70xx cn70xxp1;
+	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn73xx;
 	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn78xx;
 };
 typedef union cvmx_lmcx_ddr4_dimm_ctl cvmx_lmcx_ddr4_dimm_ctl_t;
@@ -5482,7 +6041,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_ddr_pll_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_44_63               : 20;
+	uint64_t reserved_45_63               : 19;
+	uint64_t dclk_alt_refclk_sel          : 1;  /**< Reserved. */
 	uint64_t bwadj                        : 12; /**< Bandwidth control for DCLK PLLs. */
 	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
 	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC()_DDR_PLL_CTL[DDR4_MODE]. */
@@ -5511,7 +6071,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t phy_dcok                     : 1;
 	uint64_t dclk_invert                  : 1;
 	uint64_t bwadj                        : 12;
-	uint64_t reserved_44_63               : 20;
+	uint64_t dclk_alt_refclk_sel          : 1;
+	uint64_t reserved_45_63               : 19;
 #endif
 	} s;
 	struct cvmx_lmcx_ddr_pll_ctl_cn61xx {
@@ -5630,9 +6191,10 @@ union cvmx_lmcx_ddr_pll_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_ddr_pll_ctl_cn70xx   cn70xxp1;
-	struct cvmx_lmcx_ddr_pll_ctl_cn78xx {
+	struct cvmx_lmcx_ddr_pll_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_44_63               : 20;
+	uint64_t reserved_45_63               : 19;
+	uint64_t dclk_alt_refclk_sel          : 1;  /**< Select alternate reference clock for DCLK PLL. */
 	uint64_t bwadj                        : 12; /**< Bandwidth control for DCLK PLLs. */
 	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
 	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC()_DDR_PLL_CTL[DDR4_MODE]. */
@@ -5650,18 +6212,23 @@ union cvmx_lmcx_ddr_pll_ctl {
                                                          jtg_test_mode) by about 160 microseconds to ensure that lock is achieved. */
 	uint64_t ddr_div_reset                : 1;  /**< DDR postscalar divider reset. */
 	uint64_t ddr_ps_en                    : 4;  /**< DDR postscalar divide ratio. Determines the LMC CK speed.
-                                                         0x0 = Divide LMC PLL by 1.
-                                                         0x1 = Divide LMC PLL by 2.
-                                                         0x2 = Divide LMC PLL by 3.
-                                                         0x3 = Divide LMC PLL by 4.
-                                                         0x4 = Divide LMC PLL by 5.
-                                                         0x5 = Divide LMC PLL by 6.
-                                                         0x6 = Divide LMC PLL by 7.
-                                                         0x7 = Divide LMC PLL by 8.
-                                                         0x8 = Divide LMC PLL by 10.
-                                                         0x9 = Divide LMC PLL by 12.
-                                                         0xA-0xF = Reserved.
-                                                         DDR_PS_EN is not used when DDR_DIV_RESET = 1 */
+                                                         0x0 = divide LMC PLL by 1.
+                                                         0x1 = divide LMC PLL by 2.
+                                                         0x2 = divide LMC PLL by 3.
+                                                         0x3 = divide LMC PLL by 4.
+                                                         0x4 = divide LMC PLL by 5.
+                                                         0x5 = divide LMC PLL by 6.
+                                                         0x6 = divide LMC PLL by 7.
+                                                         0x7 = divide LMC PLL by 8.
+                                                         0x8 = divide LMC PLL by 10.
+                                                         0x9 = divide LMC PLL by 12.
+                                                         0xA = Reserved.
+                                                         0xB = Reserved.
+                                                         0xC = Reserved.
+                                                         0xD = Reserved.
+                                                         0xE = Reserved.
+                                                         0xF = Reserved.
+                                                         DDR_PS_EN is not used when DDR_DIV_RESET = 1. */
 	uint64_t reserved_9_17                : 9;
 	uint64_t clkf_ext                     : 1;  /**< A 1-bit extension to the CLKF register to support for DDR4-2666. */
 	uint64_t reset_n                      : 1;  /**< PLL reset */
@@ -5683,9 +6250,11 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t phy_dcok                     : 1;
 	uint64_t dclk_invert                  : 1;
 	uint64_t bwadj                        : 12;
-	uint64_t reserved_44_63               : 20;
+	uint64_t dclk_alt_refclk_sel          : 1;
+	uint64_t reserved_45_63               : 19;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_lmcx_ddr_pll_ctl_cn73xx   cn78xx;
 	struct cvmx_lmcx_ddr_pll_ctl_cn61xx   cnf71xx;
 };
 typedef union cvmx_lmcx_ddr_pll_ctl cvmx_lmcx_ddr_pll_ctl_t;
@@ -5791,6 +6360,7 @@ union cvmx_lmcx_dimmx_ddr4_params0 {
 	} s;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn70xx;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn70xxp1;
+	struct cvmx_lmcx_dimmx_ddr4_params0_s cn73xx;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn78xx;
 };
 typedef union cvmx_lmcx_dimmx_ddr4_params0 cvmx_lmcx_dimmx_ddr4_params0_t;
@@ -5818,6 +6388,7 @@ union cvmx_lmcx_dimmx_ddr4_params1 {
 	} s;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn70xx;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn70xxp1;
+	struct cvmx_lmcx_dimmx_ddr4_params1_s cn73xx;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn78xx;
 };
 typedef union cvmx_lmcx_dimmx_ddr4_params1 cvmx_lmcx_dimmx_ddr4_params1_t;
@@ -5879,6 +6450,7 @@ union cvmx_lmcx_dimmx_params {
 	struct cvmx_lmcx_dimmx_params_s       cn68xxp1;
 	struct cvmx_lmcx_dimmx_params_s       cn70xx;
 	struct cvmx_lmcx_dimmx_params_s       cn70xxp1;
+	struct cvmx_lmcx_dimmx_params_s       cn73xx;
 	struct cvmx_lmcx_dimmx_params_s       cn78xx;
 	struct cvmx_lmcx_dimmx_params_s       cnf71xx;
 };
@@ -5936,6 +6508,7 @@ union cvmx_lmcx_dimm_ctl {
 	struct cvmx_lmcx_dimm_ctl_s           cn68xxp1;
 	struct cvmx_lmcx_dimm_ctl_s           cn70xx;
 	struct cvmx_lmcx_dimm_ctl_s           cn70xxp1;
+	struct cvmx_lmcx_dimm_ctl_s           cn73xx;
 	struct cvmx_lmcx_dimm_ctl_s           cn78xx;
 	struct cvmx_lmcx_dimm_ctl_s           cnf71xx;
 };
@@ -6095,6 +6668,7 @@ union cvmx_lmcx_dll_ctl2 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_dll_ctl2_cn70xx      cn70xxp1;
+	struct cvmx_lmcx_dll_ctl2_cn70xx      cn73xx;
 	struct cvmx_lmcx_dll_ctl2_cn70xx      cn78xx;
 	struct cvmx_lmcx_dll_ctl2_cn61xx      cnf71xx;
 };
@@ -6110,9 +6684,17 @@ union cvmx_lmcx_dll_ctl3 {
 	uint64_t u64;
 	struct cvmx_lmcx_dll_ctl3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_0_63                : 64;
+	uint64_t reserved_50_63               : 14;
+	uint64_t wr_deskew_ena                : 1;  /**< Reserved. */
+	uint64_t wr_deskew_ld                 : 1;  /**< Reserved. */
+	uint64_t bit_select                   : 4;  /**< Reserved. */
+	uint64_t reserved_0_43                : 44;
 #else
-	uint64_t reserved_0_63                : 64;
+	uint64_t reserved_0_43                : 44;
+	uint64_t bit_select                   : 4;
+	uint64_t wr_deskew_ld                 : 1;
+	uint64_t wr_deskew_ena                : 1;
+	uint64_t reserved_50_63               : 14;
 #endif
 	} s;
 	struct cvmx_lmcx_dll_ctl3_cn61xx {
@@ -6296,7 +6878,74 @@ union cvmx_lmcx_dll_ctl3 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_dll_ctl3_cn70xx      cn70xxp1;
-	struct cvmx_lmcx_dll_ctl3_cn70xx      cn78xx;
+	struct cvmx_lmcx_dll_ctl3_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_50_63               : 14;
+	uint64_t wr_deskew_ena                : 1;  /**< When set, it enables the write bit deskew feature. */
+	uint64_t wr_deskew_ld                 : 1;  /**< When set, the bit deskew settings in DLL_CTL3[OFFSET] gets loaded to
+                                                         the designated byte DLL_CTL3[BYTE_SEL] and bit DLL_CTL3[BIT_SELECT]
+                                                         for write bit deskew. This is a oneshot and clears itself each time
+                                                         it is set. */
+	uint64_t bit_select                   : 4;  /**< 0x0-0x7 = Selects bit 0 - bit 8 for write deskew setting assignment.
+                                                         0x8 = Selects dbi for write deskew setting assignment.
+                                                         0x9 = No-Op
+                                                         0xA = Reuse deskew setting on.
+                                                         0xB = Reuse deskew setting off.
+                                                         0xC = Vref bypass setting load.
+                                                         0xD = Vref bypass on.
+                                                         0xE = Vref bypass off.
+                                                         0xF = Bit select reset. Clear write deskew settings to default value 0x40 in each DQ bit.
+                                                         Also sets Vref bypass to off and deskew reuse setting to off. */
+	uint64_t dclk90_fwd                   : 1;  /**< Reserved; must be zero. INTERNAL: Generate a one cycle pulse to forward setting. This is a
+                                                         oneshot and clears itself each time it is set. */
+	uint64_t ddr_90_dly_byp               : 1;  /**< Reserved; must be zero. INTERNAL: Bypass DDR90_DLY in clock tree. */
+	uint64_t dclk90_recal_dis             : 1;  /**< Disable periodic recalibration of DDR90 delay line in. */
+	uint64_t dclk90_byp_sel               : 1;  /**< Bypass setting select for DDR90 delay line. */
+	uint64_t dclk90_byp_setting           : 9;  /**< Bypass setting for DDR90 delay line. */
+	uint64_t dll_fast                     : 1;  /**< Reserved; must be zero. INTERNAL: DLL lock, 0=DLL locked. */
+	uint64_t dll90_setting                : 9;  /**< Reserved; must be zero. INTERNAL: Encoded DLL settings. Works in conjunction with
+                                                         DLL90_BYTE_SEL. */
+	uint64_t fine_tune_mode               : 1;  /**< DLL fine tune mode. 0 = disabled; 1 = enable. When enabled, calibrate internal PHY DLL
+                                                         every LMC()_CONFIG[REF_ZQCS_INT] CK cycles. */
+	uint64_t dll_mode                     : 1;  /**< Reserved; must be zero. INTERNAL: DLL mode. */
+	uint64_t dll90_byte_sel               : 4;  /**< Observe DLL settings for selected byte.
+                                                         0x0 = byte 0.
+                                                         0x1 = byte 1.
+                                                         - ...
+                                                         0x8: byte 8.
+                                                         0x9-0xF: reserved. */
+	uint64_t offset_ena                   : 1;  /**< Reserved; must be zero. INTERNAL: Offset enable. 1=enable. */
+	uint64_t load_offset                  : 1;  /**< Reserved; must be zero. INTERNAL: Load offset. 0=disable, 1=generate a one cycle pulse to
+                                                         the PHY. This field is a oneshot and clears itself each time it is set. */
+	uint64_t mode_sel                     : 2;  /**< Reserved; must be zero. INTERNAL: Mode select. 0x0 = reset, 0x1 = write, 0x2 = read, 0x3 =
+                                                         write and read. */
+	uint64_t byte_sel                     : 4;  /**< Reserved; must be zero. INTERNAL: Byte select. 0x0 = no byte, 0x1 = byte 0, ..., 0x9 =
+                                                         byte 8, 0xA = all bytes, 0xB-0xF = Reserved. */
+	uint64_t offset                       : 7;  /**< Reserved; must be zero. INTERNAL: Write/read offset setting. <5:0>: offset (not
+                                                         two's-complement), <5>: 0 = increment, 1 = decrement. */
+#else
+	uint64_t offset                       : 7;
+	uint64_t byte_sel                     : 4;
+	uint64_t mode_sel                     : 2;
+	uint64_t load_offset                  : 1;
+	uint64_t offset_ena                   : 1;
+	uint64_t dll90_byte_sel               : 4;
+	uint64_t dll_mode                     : 1;
+	uint64_t fine_tune_mode               : 1;
+	uint64_t dll90_setting                : 9;
+	uint64_t dll_fast                     : 1;
+	uint64_t dclk90_byp_setting           : 9;
+	uint64_t dclk90_byp_sel               : 1;
+	uint64_t dclk90_recal_dis             : 1;
+	uint64_t ddr_90_dly_byp               : 1;
+	uint64_t dclk90_fwd                   : 1;
+	uint64_t bit_select                   : 4;
+	uint64_t wr_deskew_ld                 : 1;
+	uint64_t wr_deskew_ena                : 1;
+	uint64_t reserved_50_63               : 14;
+#endif
+	} cn73xx;
+	struct cvmx_lmcx_dll_ctl3_cn73xx      cn78xx;
 	struct cvmx_lmcx_dll_ctl3_cn61xx      cnf71xx;
 };
 typedef union cvmx_lmcx_dll_ctl3 cvmx_lmcx_dll_ctl3_t;
@@ -6393,6 +7042,7 @@ union cvmx_lmcx_dual_memcfg {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_dual_memcfg_cn70xx   cn70xxp1;
+	struct cvmx_lmcx_dual_memcfg_cn70xx   cn73xx;
 	struct cvmx_lmcx_dual_memcfg_cn70xx   cn78xx;
 	struct cvmx_lmcx_dual_memcfg_cn61xx   cnf71xx;
 };
@@ -6430,6 +7080,7 @@ union cvmx_lmcx_ecc_parity_test {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_lmcx_ecc_parity_test_s    cn73xx;
 	struct cvmx_lmcx_ecc_parity_test_s    cn78xx;
 };
 typedef union cvmx_lmcx_ecc_parity_test cvmx_lmcx_ecc_parity_test_t;
@@ -6492,6 +7143,7 @@ union cvmx_lmcx_ecc_synd {
 	struct cvmx_lmcx_ecc_synd_s           cn68xxp1;
 	struct cvmx_lmcx_ecc_synd_s           cn70xx;
 	struct cvmx_lmcx_ecc_synd_s           cn70xxp1;
+	struct cvmx_lmcx_ecc_synd_s           cn73xx;
 	struct cvmx_lmcx_ecc_synd_s           cn78xx;
 	struct cvmx_lmcx_ecc_synd_s           cnf71xx;
 };
@@ -6507,7 +7159,16 @@ union cvmx_lmcx_ext_config {
 	uint64_t u64;
 	struct cvmx_lmcx_ext_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_49_63               : 15;
+	uint64_t reserved_60_63               : 4;
+	uint64_t ref_block                    : 1;  /**< Reserved. */
+	uint64_t mrs_side                     : 1;  /**< Reserved. */
+	uint64_t mrs_one_side                 : 1;  /**< Reserved. */
+	uint64_t mrs_bside_invert_disable     : 1;  /**< Reserved. */
+	uint64_t dimm_sel_invert_off          : 1;  /**< Reserved. */
+	uint64_t dimm_sel_force_invert        : 1;  /**< Reserved. */
+	uint64_t coalesce_address_mode        : 1;  /**< Reserved. */
+	uint64_t dimm1_cid                    : 2;  /**< Reserved. */
+	uint64_t dimm0_cid                    : 2;  /**< Reserved. */
 	uint64_t rcd_parity_check             : 1;  /**< Enables the one cycle delay of the CA parity output. This MUST be set to 1 when using DDR4
                                                          RDIMM AND parity checking in RCD is enabled (RC0E DA0 = 1). Set this to 0 otherwise.
                                                          To enable the parity checking in RCD, set this bit first BEFORE issuing the RCW write RC0E
@@ -6598,7 +7259,16 @@ union cvmx_lmcx_ext_config {
 	uint64_t error_alert_n_sample         : 1;
 	uint64_t reserved_46_47               : 2;
 	uint64_t rcd_parity_check             : 1;
-	uint64_t reserved_49_63               : 15;
+	uint64_t dimm0_cid                    : 2;
+	uint64_t dimm1_cid                    : 2;
+	uint64_t coalesce_address_mode        : 1;
+	uint64_t dimm_sel_force_invert        : 1;
+	uint64_t dimm_sel_invert_off          : 1;
+	uint64_t mrs_bside_invert_disable     : 1;
+	uint64_t mrs_one_side                 : 1;
+	uint64_t mrs_side                     : 1;
+	uint64_t ref_block                    : 1;
+	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
 	struct cvmx_lmcx_ext_config_cn70xx {
@@ -6640,11 +7310,63 @@ union cvmx_lmcx_ext_config {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_ext_config_cn70xx    cn70xxp1;
+	struct cvmx_lmcx_ext_config_s         cn73xx;
 	struct cvmx_lmcx_ext_config_s         cn78xx;
 };
 typedef union cvmx_lmcx_ext_config cvmx_lmcx_ext_config_t;
 
 /**
+ * cvmx_lmc#_ext_config2
+ *
+ * This register has additional configuration and control bits for the LMC.
+ *
+ */
+union cvmx_lmcx_ext_config2 {
+	uint64_t u64;
+	struct cvmx_lmcx_ext_config2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t row_col_switch               : 1;  /**< When set, the memory address bit position that represents bit 4 of the COLUMN
+                                                         address (bit 5 in 32-bit mode) becomes the low order DDR ROW address bit.
+                                                         The upper DDR COLUMN address portion is selected using LMC()_CONFIG[ROW_LSB]
+                                                         (and LMC()_DUAL_MEMCFG[ROW_LSB] for dual-memory configuration).
+                                                         It is recommended to set this bit to 1 when TRR_ON is set. */
+	uint64_t trr_on                       : 1;  /**< When set, this enables row activates counts of the
+                                                         DRAM used in Target Row Refresh mode. This bit can
+                                                         be safely set after the LMC()_EXT_CONFIG2[MACRAM_SCRUB_DONE]
+                                                         has a value of 1. */
+	uint64_t mac                          : 3;  /**< Sets the maximum number of activates allowed within a tMAW interval.
+                                                         0x0 = 100K.
+                                                         0x1 = 400K/2.
+                                                         0x2 = 500K/2.
+                                                         0x3 = 600K/2.
+                                                         0x4 = 700K/2.
+                                                         0x5 = 800K/2.
+                                                         0x6 = 900K/2.
+                                                         0x7 = 1000K/2. */
+	uint64_t macram_scrub_done            : 1;  /**< Maximum Activate Count memory scrub complete indication;
+                                                         1 means the memory has been scrubbed to all zero. */
+	uint64_t macram_scrub                 : 1;  /**< When set, the Maximum Activate Count memory will be scrubbed to all zero values. This
+                                                         should be done before enabling TRR mode by setting LMC()_EXT_CONFIG2[TRR_ON].
+                                                         This is a one-shot operation; it automatically returns to 0 after a write to 1. */
+	uint64_t macram_flip_synd             : 2;  /**< Reserved. INTERNAL: MAC RAM flip syndrome control bits. */
+	uint64_t macram_cor_dis               : 1;  /**< Reserved. INTERNAL: MAC RAM correction disable control. */
+#else
+	uint64_t macram_cor_dis               : 1;
+	uint64_t macram_flip_synd             : 2;
+	uint64_t macram_scrub                 : 1;
+	uint64_t macram_scrub_done            : 1;
+	uint64_t mac                          : 3;
+	uint64_t trr_on                       : 1;
+	uint64_t row_col_switch               : 1;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_lmcx_ext_config2_s        cn73xx;
+};
+typedef union cvmx_lmcx_ext_config2 cvmx_lmcx_ext_config2_t;
+
+/**
  * cvmx_lmc#_fadr
  *
  * This register only captures the first transaction with ECC errors. A DED error can over-write
@@ -6664,13 +7386,15 @@ union cvmx_lmcx_fadr {
 	uint64_t u64;
 	struct cvmx_lmcx_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_40_63               : 24;
+	uint64_t reserved_43_63               : 21;
+	uint64_t fcid                         : 3;  /**< Reserved. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t reserved_0_37                : 38;
 #else
 	uint64_t reserved_0_37                : 38;
 	uint64_t fill_order                   : 2;
-	uint64_t reserved_40_63               : 24;
+	uint64_t fcid                         : 3;
+	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
 	struct cvmx_lmcx_fadr_cn30xx {
@@ -6752,12 +7476,85 @@ union cvmx_lmcx_fadr {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_fadr_cn70xx          cn70xxp1;
-	struct cvmx_lmcx_fadr_cn70xx          cn78xx;
+	struct cvmx_lmcx_fadr_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_43_63               : 21;
+	uint64_t fcid                         : 3;  /**< Failing CID number. */
+	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
+	uint64_t fdimm                        : 1;  /**< Failing DIMM number. */
+	uint64_t fbunk                        : 1;  /**< Failing rank number. */
+	uint64_t fbank                        : 4;  /**< Failing bank number. Bits <3:0>. */
+	uint64_t frow                         : 18; /**< Failing row address. Bits <17:0>. */
+	uint64_t fcol                         : 14; /**< Failing column address <13:0>. Technically, represents the address of the 64b data that
+                                                         had an ECC error, i.e., FCOL[0] is always 0. Can be used in conjunction with
+                                                         LMC()_INT[DED_ERR] to isolate the 64b chunk of data in error. */
+#else
+	uint64_t fcol                         : 14;
+	uint64_t frow                         : 18;
+	uint64_t fbank                        : 4;
+	uint64_t fbunk                        : 1;
+	uint64_t fdimm                        : 1;
+	uint64_t fill_order                   : 2;
+	uint64_t fcid                         : 3;
+	uint64_t reserved_43_63               : 21;
+#endif
+	} cn73xx;
+	struct cvmx_lmcx_fadr_cn73xx          cn78xx;
 	struct cvmx_lmcx_fadr_cn61xx          cnf71xx;
 };
 typedef union cvmx_lmcx_fadr cvmx_lmcx_fadr_t;
 
 /**
+ * cvmx_lmc#_general_purpose0
+ */
+union cvmx_lmcx_general_purpose0 {
+	uint64_t u64;
+	struct cvmx_lmcx_general_purpose0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t data                         : 64; /**< General purpose data register.  See LMC()_PPR_CTL and LMC()_DBTRAIN_CTL[RW_TRAIN]. */
+#else
+	uint64_t data                         : 64;
+#endif
+	} s;
+	struct cvmx_lmcx_general_purpose0_s   cn73xx;
+};
+typedef union cvmx_lmcx_general_purpose0 cvmx_lmcx_general_purpose0_t;
+
+/**
+ * cvmx_lmc#_general_purpose1
+ */
+union cvmx_lmcx_general_purpose1 {
+	uint64_t u64;
+	struct cvmx_lmcx_general_purpose1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t data                         : 64; /**< General purpose data register.  See LMC()_PPR_CTL and LMC()_DBTRAIN_CTL[RW_TRAIN]. */
+#else
+	uint64_t data                         : 64;
+#endif
+	} s;
+	struct cvmx_lmcx_general_purpose1_s   cn73xx;
+};
+typedef union cvmx_lmcx_general_purpose1 cvmx_lmcx_general_purpose1_t;
+
+/**
+ * cvmx_lmc#_general_purpose2
+ */
+union cvmx_lmcx_general_purpose2 {
+	uint64_t u64;
+	struct cvmx_lmcx_general_purpose2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t data                         : 16; /**< General purpose data register.  See LMC()_PPR_CTL and LMC()_DBTRAIN_CTL[RW_TRAIN]. */
+#else
+	uint64_t data                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_lmcx_general_purpose2_s   cn73xx;
+};
+typedef union cvmx_lmcx_general_purpose2 cvmx_lmcx_general_purpose2_t;
+
+/**
  * cvmx_lmc#_ifb_cnt
  *
  * LMC_IFB_CNT  = Performance Counters
@@ -6782,6 +7579,7 @@ union cvmx_lmcx_ifb_cnt {
 	struct cvmx_lmcx_ifb_cnt_s            cn68xxp1;
 	struct cvmx_lmcx_ifb_cnt_s            cn70xx;
 	struct cvmx_lmcx_ifb_cnt_s            cn70xxp1;
+	struct cvmx_lmcx_ifb_cnt_s            cn73xx;
 	struct cvmx_lmcx_ifb_cnt_s            cn78xx;
 	struct cvmx_lmcx_ifb_cnt_s            cnf71xx;
 };
@@ -6863,7 +7661,9 @@ union cvmx_lmcx_int {
 	uint64_t u64;
 	struct cvmx_lmcx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_12_63               : 52;
+	uint64_t reserved_14_63               : 50;
+	uint64_t macram_ded_err               : 1;  /**< Reserved. */
+	uint64_t macram_sec_err               : 1;  /**< Reserved. */
 	uint64_t ddr_err                      : 1;  /**< DDR RAM error alert interrupt. */
 	uint64_t dlcram_ded_err               : 1;  /**< DLC RAM ECC double error detect (DED). */
 	uint64_t dlcram_sec_err               : 1;  /**< DLC RAM ECC single error correct (SEC). */
@@ -6900,7 +7700,9 @@ union cvmx_lmcx_int {
 	uint64_t dlcram_sec_err               : 1;
 	uint64_t dlcram_ded_err               : 1;
 	uint64_t ddr_err                      : 1;
-	uint64_t reserved_12_63               : 52;
+	uint64_t macram_sec_err               : 1;
+	uint64_t macram_ded_err               : 1;
+	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
 	struct cvmx_lmcx_int_cn61xx {
@@ -6944,8 +7746,37 @@ union cvmx_lmcx_int {
 	struct cvmx_lmcx_int_cn61xx           cn66xx;
 	struct cvmx_lmcx_int_cn61xx           cn68xx;
 	struct cvmx_lmcx_int_cn61xx           cn68xxp1;
-	struct cvmx_lmcx_int_s                cn70xx;
-	struct cvmx_lmcx_int_s                cn70xxp1;
+	struct cvmx_lmcx_int_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t ddr_err                      : 1;  /**< Reserved. */
+	uint64_t dlcram_ded_err               : 1;  /**< Reserved. */
+	uint64_t dlcram_sec_err               : 1;  /**< Reserved. */
+	uint64_t ded_err                      : 4;  /**< Double error detected (DED) of Rd Data.
+                                                         In 32b mode, each bit corresponds to 2 phases:
+                                                         <5> corresponds to DQ[31:0]_c0_p1/0
+                                                         <6> corresponds to DQ[31:0]_c1_p1/0
+                                                         <7> corresponds to DQ[31:0]_c2_p1/0
+                                                         <8> corresponds to DQ[31:0]_c3_p1/0 */
+	uint64_t sec_err                      : 4;  /**< Single error (corrected) of Rd Data.
+                                                         In 32b mode, each bit corresponds to 2 phases:
+                                                         <1> corresponds to DQ[31:0]_c0_p1/0
+                                                         <2> corresponds to DQ[31:0]_c1_p1/0
+                                                         <3> corresponds to DQ[31:0]_c2_p1/0
+                                                         <4> corresponds to DQ[31:0]_c3_p1/0 */
+	uint64_t nxm_wr_err                   : 1;  /**< Write to nonexistent memory. */
+#else
+	uint64_t nxm_wr_err                   : 1;
+	uint64_t sec_err                      : 4;
+	uint64_t ded_err                      : 4;
+	uint64_t dlcram_sec_err               : 1;
+	uint64_t dlcram_ded_err               : 1;
+	uint64_t ddr_err                      : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_int_cn70xx           cn70xxp1;
+	struct cvmx_lmcx_int_s                cn73xx;
 	struct cvmx_lmcx_int_s                cn78xx;
 	struct cvmx_lmcx_int_cn61xx           cnf71xx;
 };
@@ -7014,6 +7845,7 @@ union cvmx_lmcx_int_en {
 	struct cvmx_lmcx_int_en_cn61xx        cn68xxp1;
 	struct cvmx_lmcx_int_en_s             cn70xx;
 	struct cvmx_lmcx_int_en_s             cn70xxp1;
+	struct cvmx_lmcx_int_en_s             cn73xx;
 	struct cvmx_lmcx_int_en_s             cn78xx;
 	struct cvmx_lmcx_int_en_cn61xx        cnf71xx;
 };
@@ -7068,6 +7900,7 @@ union cvmx_lmcx_lanex_crc_swiz {
 	uint64_t reserved_56_63               : 8;
 #endif
 	} s;
+	struct cvmx_lmcx_lanex_crc_swiz_s     cn73xx;
 	struct cvmx_lmcx_lanex_crc_swiz_s     cn78xx;
 };
 typedef union cvmx_lmcx_lanex_crc_swiz cvmx_lmcx_lanex_crc_swiz_t;
@@ -7467,14 +8300,17 @@ typedef union cvmx_lmcx_mem_cfg1 cvmx_lmcx_mem_cfg1_t;
 /**
  * cvmx_lmc#_modereg_params0
  *
- * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.
+ * These parameters are written into the DDR3/DDR4 MR0, MR1, MR2 and MR3 registers.
  *
  */
 union cvmx_lmcx_modereg_params0 {
 	uint64_t u64;
 	struct cvmx_lmcx_modereg_params0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_25_63               : 39;
+	uint64_t reserved_28_63               : 36;
+	uint64_t wrp_ext                      : 1;  /**< Reserved. */
+	uint64_t cl_ext                       : 1;  /**< Reserved. */
+	uint64_t al_ext                       : 1;  /**< Reserved. */
 	uint64_t ppd                          : 1;  /**< DLL Control for precharge powerdown
                                                          0 = Slow exit (DLL off)
                                                          1 = Fast exit (DLL on)
@@ -7653,55 +8489,243 @@ union cvmx_lmcx_modereg_params0 {
 	uint64_t dllr                         : 1;
 	uint64_t wrp                          : 3;
 	uint64_t ppd                          : 1;
-	uint64_t reserved_25_63               : 39;
+	uint64_t al_ext                       : 1;
+	uint64_t cl_ext                       : 1;
+	uint64_t wrp_ext                      : 1;
+	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
-	struct cvmx_lmcx_modereg_params0_s    cn61xx;
-	struct cvmx_lmcx_modereg_params0_s    cn63xx;
-	struct cvmx_lmcx_modereg_params0_s    cn63xxp1;
-	struct cvmx_lmcx_modereg_params0_s    cn66xx;
-	struct cvmx_lmcx_modereg_params0_s    cn68xx;
-	struct cvmx_lmcx_modereg_params0_s    cn68xxp1;
-	struct cvmx_lmcx_modereg_params0_s    cn70xx;
-	struct cvmx_lmcx_modereg_params0_s    cn70xxp1;
-	struct cvmx_lmcx_modereg_params0_s    cn78xx;
-	struct cvmx_lmcx_modereg_params0_s    cnf71xx;
-};
-typedef union cvmx_lmcx_modereg_params0 cvmx_lmcx_modereg_params0_t;
-
-/**
- * cvmx_lmc#_modereg_params1
- *
- * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.
- *
- */
-union cvmx_lmcx_modereg_params1 {
-	uint64_t u64;
-	struct cvmx_lmcx_modereg_params1_s {
+	struct cvmx_lmcx_modereg_params0_cn61xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_48_63               : 16;
-	uint64_t rtt_nom_11                   : 3;  /**< RTT_NOM Rank 3
-                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
-                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+	uint64_t reserved_25_63               : 39;
+	uint64_t ppd                          : 1;  /**< DLL Control for precharge powerdown
+                                                         0 = Slow exit (DLL off)
+                                                         1 = Fast exit (DLL on)
+                                                         LMC writes this value to MR0[PPD] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[PPD] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t wrp                          : 3;  /**< Write recovery for auto precharge
+                                                         Should be programmed to be equal to or greater than
+                                                         RNDUP[tWR(ns)/tCYC(ns)]
+                                                         000 = 5
+                                                         001 = 5
+                                                         010 = 6
+                                                         011 = 7
+                                                         100 = 8
+                                                         101 = 10
+                                                         110 = 12
+                                                         111 = 14
+                                                         LMC writes this value to MR0[WR] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[WR] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t dllr                         : 1;  /**< DLL Reset
+                                                         LMC writes this value to MR0[DLL] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[DLL] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t tm                           : 1;  /**< Test Mode
+                                                         LMC writes this value to MR0[TM] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[TM] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t rbt                          : 1;  /**< Read Burst Type
+                                                         1 = interleaved (fixed)
+                                                         LMC writes this value to MR0[RBT] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[RBT] value must be 1 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t cl                           : 4;  /**< CAS Latency
+                                                         0010 = 5
+                                                         0100 = 6
+                                                         0110 = 7
+                                                         1000 = 8
+                                                         1010 = 9
+                                                         1100 = 10
+                                                         1110 = 11
+                                                         0001 = 12
+                                                         0011 = 13
+                                                         0101 = 14
+                                                         0111 = 15
+                                                         1001 = 16
+                                                         0000, 1011, 1101, 1111 = Reserved
+                                                         LMC writes this value to MR0[CAS Latency / CL] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[CAS Latency / CL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t bl                           : 2;  /**< Burst Length
+                                                         0 = 8 (fixed)
+                                                         LMC writes this value to MR0[BL] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[BL] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t qoff                         : 1;  /**< Qoff Enable
+                                                         0 = enable
+                                                         1 = disable
+                                                         LMC writes this value to MR1[Qoff] in the DDR3 parts in the selected ranks
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
                                                          self-refresh entry and exit instruction sequences.
-                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and
                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
-                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
-                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
-                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
-	uint64_t dic_11                       : 2;  /**< Output Driver Impedance Control Rank 3
-                                                         LMC writes this value to MR1[D.I.C.] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
-                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         The MR1[Qoff] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t tdqs                         : 1;  /**< TDQS Enable
+                                                         0 = disable
+                                                         LMC writes this value to MR1[TDQS] in the DDR3 parts in the selected ranks
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
                                                          self-refresh entry and exit instruction sequences.
-                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and
                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
-	uint64_t rtt_wr_11                    : 2;  /**< RTT_WR Rank 3
-                                                         LMC writes this value to MR2[Rtt_WR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
-                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+	uint64_t wlev                         : 1;  /**< Write Leveling Enable
+                                                         0 = disable
+                                                         LMC writes MR1[Level]=0 in the DDR3 parts in the selected ranks
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
                                                          self-refresh entry and exit instruction sequences.
-                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         (Write-leveling can only be initiated via the
+                                                         write-leveling instruction sequence.)
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and
                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
-	uint64_t srt_11                       : 1;  /**< Self-refresh temperature range Rank 3
+	uint64_t al                           : 2;  /**< Additive Latency
+                                                         00 = 0
+                                                         01 = CL-1
+                                                         10 = CL-2
+                                                         11 = Reserved
+                                                         LMC writes this value to MR1[AL] in the selected DDR3 parts
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR1[AL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation.
+                                                         See also LMC*_CONTROL[POCAS]. */
+	uint64_t dll                          : 1;  /**< DLL Enable
+                                                         0 = enable
+                                                         1 = disable.
+                                                         LMC writes this value to MR1[DLL] in the selected DDR3 parts
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR1[DLL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation.
+                                                         In dll-off mode, CL/CWL must be programmed
+                                                         equal to 6/6, respectively, as per the DDR3 specifications. */
+	uint64_t mpr                          : 1;  /**< MPR
+                                                         LMC writes this value to MR3[MPR] in the selected DDR3 parts
+                                                         during power-up/init, read-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         (LMC also writes MR3[MPR]=1 at the beginning of the
+                                                         read-leveling instruction sequence. Read-leveling should only be initiated via the
+                                                         read-leveling instruction sequence.)
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR3[MPR] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t mprloc                       : 2;  /**< MPR Location
+                                                         LMC writes this value to MR3[MPRLoc] in the selected DDR3 parts
+                                                         during power-up/init, read-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         (LMC also writes MR3[MPRLoc]=0 at the beginning of the
+                                                         read-leveling instruction sequence.)
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR3[MPRLoc] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t cwl                          : 3;  /**< CAS Write Latency
+                                                         - 000: 5
+                                                         - 001: 6
+                                                         - 010: 7
+                                                         - 011: 8
+                                                         - 100: 9
+                                                         - 101: 10
+                                                         - 110: 11
+                                                         - 111: 12
+                                                         LMC writes this value to MR2[CWL] in the selected DDR3 parts
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR2[CWL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+#else
+	uint64_t cwl                          : 3;
+	uint64_t mprloc                       : 2;
+	uint64_t mpr                          : 1;
+	uint64_t dll                          : 1;
+	uint64_t al                           : 2;
+	uint64_t wlev                         : 1;
+	uint64_t tdqs                         : 1;
+	uint64_t qoff                         : 1;
+	uint64_t bl                           : 2;
+	uint64_t cl                           : 4;
+	uint64_t rbt                          : 1;
+	uint64_t tm                           : 1;
+	uint64_t dllr                         : 1;
+	uint64_t wrp                          : 3;
+	uint64_t ppd                          : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn61xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn63xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn63xxp1;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn66xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn68xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn68xxp1;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn70xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn70xxp1;
+	struct cvmx_lmcx_modereg_params0_s    cn73xx;
+	struct cvmx_lmcx_modereg_params0_s    cn78xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cnf71xx;
+};
+typedef union cvmx_lmcx_modereg_params0 cvmx_lmcx_modereg_params0_t;
+
+/**
+ * cvmx_lmc#_modereg_params1
+ *
+ * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.
+ *
+ */
+union cvmx_lmcx_modereg_params1 {
+	uint64_t u64;
+	struct cvmx_lmcx_modereg_params1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_51_63               : 13;
+	uint64_t db_output_impedance          : 3;  /**< Reserved. */
+	uint64_t rtt_nom_11                   : 3;  /**< RTT_NOM Rank 3
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_11                       : 2;  /**< Output Driver Impedance Control Rank 3
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_11                    : 2;  /**< RTT_WR Rank 3
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_11                       : 1;  /**< Self-refresh temperature range Rank 3
                                                          LMC writes this value to MR2[SRT] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
                                                          self-refresh entry and exit instruction sequences.
@@ -7861,19 +8885,207 @@ union cvmx_lmcx_modereg_params1 {
 	uint64_t rtt_wr_11                    : 2;
 	uint64_t dic_11                       : 2;
 	uint64_t rtt_nom_11                   : 3;
-	uint64_t reserved_48_63               : 16;
+	uint64_t db_output_impedance          : 3;
+	uint64_t reserved_51_63               : 13;
 #endif
 	} s;
-	struct cvmx_lmcx_modereg_params1_s    cn61xx;
-	struct cvmx_lmcx_modereg_params1_s    cn63xx;
-	struct cvmx_lmcx_modereg_params1_s    cn63xxp1;
-	struct cvmx_lmcx_modereg_params1_s    cn66xx;
-	struct cvmx_lmcx_modereg_params1_s    cn68xx;
-	struct cvmx_lmcx_modereg_params1_s    cn68xxp1;
-	struct cvmx_lmcx_modereg_params1_s    cn70xx;
-	struct cvmx_lmcx_modereg_params1_s    cn70xxp1;
+	struct cvmx_lmcx_modereg_params1_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t rtt_nom_11                   : 3;  /**< RTT_NOM Rank 3
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_11                       : 2;  /**< Output Driver Impedance Control Rank 3
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_11                    : 2;  /**< RTT_WR Rank 3
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_11                       : 1;  /**< Self-refresh temperature range Rank 3
+                                                         LMC writes this value to MR2[SRT] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_11                       : 1;  /**< Auto self-refresh Rank 3
+                                                         LMC writes this value to MR2[ASR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_11                      : 3;  /**< Partial array self-refresh Rank 3
+                                                         LMC writes this value to MR2[PASR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_nom_10                   : 3;  /**< RTT_NOM Rank 2
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_10                       : 2;  /**< Output Driver Impedance Control Rank 2
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_10                    : 2;  /**< RTT_WR Rank 2
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_10                       : 1;  /**< Self-refresh temperature range Rank 2
+                                                         LMC writes this value to MR2[SRT] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_10                       : 1;  /**< Auto self-refresh Rank 2
+                                                         LMC writes this value to MR2[ASR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_10                      : 3;  /**< Partial array self-refresh Rank 2
+                                                         LMC writes this value to MR2[PASR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_nom_01                   : 3;  /**< RTT_NOM Rank 1
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_01                       : 2;  /**< Output Driver Impedance Control Rank 1
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_01                    : 2;  /**< RTT_WR Rank 1
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_01                       : 1;  /**< Self-refresh temperature range Rank 1
+                                                         LMC writes this value to MR2[SRT] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_01                       : 1;  /**< Auto self-refresh Rank 1
+                                                         LMC writes this value to MR2[ASR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_01                      : 3;  /**< Partial array self-refresh Rank 1
+                                                         LMC writes this value to MR2[PASR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_nom_00                   : 3;  /**< RTT_NOM Rank 0
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_00                       : 2;  /**< Output Driver Impedance Control Rank 0
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_00                    : 2;  /**< RTT_WR Rank 0
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_00                       : 1;  /**< Self-refresh temperature range Rank 0
+                                                         LMC writes this value to MR2[SRT] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_00                       : 1;  /**< Auto self-refresh Rank 0
+                                                         LMC writes this value to MR2[ASR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_00                      : 3;  /**< Partial array self-refresh Rank 0
+                                                         LMC writes this value to MR2[PASR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+#else
+	uint64_t pasr_00                      : 3;
+	uint64_t asr_00                       : 1;
+	uint64_t srt_00                       : 1;
+	uint64_t rtt_wr_00                    : 2;
+	uint64_t dic_00                       : 2;
+	uint64_t rtt_nom_00                   : 3;
+	uint64_t pasr_01                      : 3;
+	uint64_t asr_01                       : 1;
+	uint64_t srt_01                       : 1;
+	uint64_t rtt_wr_01                    : 2;
+	uint64_t dic_01                       : 2;
+	uint64_t rtt_nom_01                   : 3;
+	uint64_t pasr_10                      : 3;
+	uint64_t asr_10                       : 1;
+	uint64_t srt_10                       : 1;
+	uint64_t rtt_wr_10                    : 2;
+	uint64_t dic_10                       : 2;
+	uint64_t rtt_nom_10                   : 3;
+	uint64_t pasr_11                      : 3;
+	uint64_t asr_11                       : 1;
+	uint64_t srt_11                       : 1;
+	uint64_t rtt_wr_11                    : 2;
+	uint64_t dic_11                       : 2;
+	uint64_t rtt_nom_11                   : 3;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn61xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn63xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn63xxp1;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn66xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn68xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn68xxp1;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn70xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn70xxp1;
+	struct cvmx_lmcx_modereg_params1_s    cn73xx;
 	struct cvmx_lmcx_modereg_params1_s    cn78xx;
-	struct cvmx_lmcx_modereg_params1_s    cnf71xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_modereg_params1 cvmx_lmcx_modereg_params1_t;
 
@@ -7950,6 +9162,7 @@ union cvmx_lmcx_modereg_params2 {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} cn70xxp1;
+	struct cvmx_lmcx_modereg_params2_s    cn73xx;
 	struct cvmx_lmcx_modereg_params2_s    cn78xx;
 };
 typedef union cvmx_lmcx_modereg_params2 cvmx_lmcx_modereg_params2_t;
@@ -7964,7 +9177,9 @@ union cvmx_lmcx_modereg_params3 {
 	uint64_t u64;
 	struct cvmx_lmcx_modereg_params3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_33_63               : 31;
+	uint64_t reserved_39_63               : 25;
+	uint64_t xrank_add_tccd_l             : 3;  /**< Reserved. */
+	uint64_t xrank_add_tccd_s             : 3;  /**< Reserved. */
 	uint64_t mpr_fmt                      : 2;  /**< MPR format. */
 	uint64_t wr_cmd_lat                   : 2;  /**< Write command latency when CRC and DM are both enabled. */
 	uint64_t fgrm                         : 3;  /**< Fine granularity refresh mode. */
@@ -8016,11 +9231,67 @@ union cvmx_lmcx_modereg_params3 {
 	uint64_t fgrm                         : 3;
 	uint64_t wr_cmd_lat                   : 2;
 	uint64_t mpr_fmt                      : 2;
-	uint64_t reserved_33_63               : 31;
+	uint64_t xrank_add_tccd_s             : 3;
+	uint64_t xrank_add_tccd_l             : 3;
+	uint64_t reserved_39_63               : 25;
 #endif
 	} s;
-	struct cvmx_lmcx_modereg_params3_s    cn70xx;
-	struct cvmx_lmcx_modereg_params3_s    cn70xxp1;
+	struct cvmx_lmcx_modereg_params3_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_33_63               : 31;
+	uint64_t mpr_fmt                      : 2;  /**< MPR format. */
+	uint64_t wr_cmd_lat                   : 2;  /**< Write command latency when CRC and DM are both enabled. */
+	uint64_t fgrm                         : 3;  /**< Fine granularity refresh mode. */
+	uint64_t temp_sense                   : 1;  /**< Temperature sensor readout enable. */
+	uint64_t pda                          : 1;  /**< Per DRAM addressability. */
+	uint64_t gd                           : 1;  /**< Gear-down mode. */
+	uint64_t crc                          : 1;  /**< CRC mode. */
+	uint64_t lpasr                        : 2;  /**< LP auto self refresh. */
+	uint64_t tccd_l                       : 3;  /**< TCCD_L timing parameter:
+                                                         0x0 = 4. 0x3 = 7.
+                                                         0x1 = 5. 0x4 = 8.
+                                                         0x2 = 6. 0x5-0x7 = reserved. */
+	uint64_t rd_dbi                       : 1;  /**< Read DBI, must be 0. */
+	uint64_t wr_dbi                       : 1;  /**< Write DBI, must be 0. */
+	uint64_t dm                           : 1;  /**< Data mask enable. */
+	uint64_t ca_par_pers                  : 1;  /**< Command/address persistent parity error mode. */
+	uint64_t odt_pd                       : 1;  /**< ODT in PD mode. */
+	uint64_t par_lat_mode                 : 3;  /**< Parity latency mode. */
+	uint64_t wr_preamble                  : 1;  /**< Write preamble, 0 = one nCK, 1 = two nCK. */
+	uint64_t rd_preamble                  : 1;  /**< Write preamble, 0 = one nCK, 1 = two nCK. */
+	uint64_t sre_abort                    : 1;  /**< Self refresh abort. */
+	uint64_t cal                          : 3;  /**< CS-to-CMD/ADDR latency mode (cycles). */
+	uint64_t vref_mon                     : 1;  /**< Internal VREF monitor: 0 = disable, 1 = enable. */
+	uint64_t tc_ref                       : 1;  /**< Temperature controlled refresh range: 0 = normal, 1 = extended. */
+	uint64_t max_pd                       : 1;  /**< Maximum power-down mode: 0 = disable, 1 = enable. */
+#else
+	uint64_t max_pd                       : 1;
+	uint64_t tc_ref                       : 1;
+	uint64_t vref_mon                     : 1;
+	uint64_t cal                          : 3;
+	uint64_t sre_abort                    : 1;
+	uint64_t rd_preamble                  : 1;
+	uint64_t wr_preamble                  : 1;
+	uint64_t par_lat_mode                 : 3;
+	uint64_t odt_pd                       : 1;
+	uint64_t ca_par_pers                  : 1;
+	uint64_t dm                           : 1;
+	uint64_t wr_dbi                       : 1;
+	uint64_t rd_dbi                       : 1;
+	uint64_t tccd_l                       : 3;
+	uint64_t lpasr                        : 2;
+	uint64_t crc                          : 1;
+	uint64_t gd                           : 1;
+	uint64_t pda                          : 1;
+	uint64_t temp_sense                   : 1;
+	uint64_t fgrm                         : 3;
+	uint64_t wr_cmd_lat                   : 2;
+	uint64_t mpr_fmt                      : 2;
+	uint64_t reserved_33_63               : 31;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_modereg_params3_cn70xx cn70xxp1;
+	struct cvmx_lmcx_modereg_params3_s    cn73xx;
 	struct cvmx_lmcx_modereg_params3_s    cn78xx;
 };
 typedef union cvmx_lmcx_modereg_params3 cvmx_lmcx_modereg_params3_t;
@@ -8043,6 +9314,7 @@ union cvmx_lmcx_mpr_data0 {
 	} s;
 	struct cvmx_lmcx_mpr_data0_s          cn70xx;
 	struct cvmx_lmcx_mpr_data0_s          cn70xxp1;
+	struct cvmx_lmcx_mpr_data0_s          cn73xx;
 	struct cvmx_lmcx_mpr_data0_s          cn78xx;
 };
 typedef union cvmx_lmcx_mpr_data0 cvmx_lmcx_mpr_data0_t;
@@ -8065,6 +9337,7 @@ union cvmx_lmcx_mpr_data1 {
 	} s;
 	struct cvmx_lmcx_mpr_data1_s          cn70xx;
 	struct cvmx_lmcx_mpr_data1_s          cn70xxp1;
+	struct cvmx_lmcx_mpr_data1_s          cn73xx;
 	struct cvmx_lmcx_mpr_data1_s          cn78xx;
 };
 typedef union cvmx_lmcx_mpr_data1 cvmx_lmcx_mpr_data1_t;
@@ -8089,6 +9362,7 @@ union cvmx_lmcx_mpr_data2 {
 	} s;
 	struct cvmx_lmcx_mpr_data2_s          cn70xx;
 	struct cvmx_lmcx_mpr_data2_s          cn70xxp1;
+	struct cvmx_lmcx_mpr_data2_s          cn73xx;
 	struct cvmx_lmcx_mpr_data2_s          cn78xx;
 };
 typedef union cvmx_lmcx_mpr_data2 cvmx_lmcx_mpr_data2_t;
@@ -8103,9 +9377,13 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_mr_mpr_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_57_63               : 7;
+	uint64_t reserved_61_63               : 3;
+	uint64_t mr_wr_secure_key_ena         : 1;  /**< Reserved. */
+	uint64_t pba_func_space               : 3;  /**< Reserved. */
 	uint64_t mr_wr_bg1                    : 1;  /**< BG1 part of the address select for MRS in DDR4 mode. */
-	uint64_t reserved_53_55               : 3;
+	uint64_t mpr_sample_dq_enable         : 1;  /**< Reserved. */
+	uint64_t pda_early_dqx                : 1;  /**< Reserved. */
+	uint64_t mr_wr_pba_enable             : 1;  /**< Reserved. */
 	uint64_t mr_wr_use_default_value      : 1;  /**< When set, write the value to the MR that is computed from the value set in various CSR
                                                          fields that would be used during initialization, rather that using the value in the
                                                          LMC()_MR_MPR_CTL[MR_WR_ADDR]. Useful to rewrite the same value or to change single
@@ -8144,9 +9422,13 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t mpr_byte_select              : 4;
 	uint64_t mpr_whole_byte_enable        : 1;
 	uint64_t mr_wr_use_default_value      : 1;
-	uint64_t reserved_53_55               : 3;
+	uint64_t mr_wr_pba_enable             : 1;
+	uint64_t pda_early_dqx                : 1;
+	uint64_t mpr_sample_dq_enable         : 1;
 	uint64_t mr_wr_bg1                    : 1;
-	uint64_t reserved_57_63               : 7;
+	uint64_t pba_func_space               : 3;
+	uint64_t mr_wr_secure_key_ena         : 1;
+	uint64_t reserved_61_63               : 3;
 #endif
 	} s;
 	struct cvmx_lmcx_mr_mpr_ctl_cn70xx {
@@ -8191,11 +9473,41 @@ union cvmx_lmcx_mr_mpr_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_mr_mpr_ctl_cn70xx    cn70xxp1;
+	struct cvmx_lmcx_mr_mpr_ctl_s         cn73xx;
 	struct cvmx_lmcx_mr_mpr_ctl_s         cn78xx;
 };
 typedef union cvmx_lmcx_mr_mpr_ctl cvmx_lmcx_mr_mpr_ctl_t;
 
 /**
+ * cvmx_lmc#_ns_ctl
+ *
+ * This register contains control parameters for handling non-secure accesses.
+ *
+ */
+union cvmx_lmcx_ns_ctl {
+	uint64_t u64;
+	struct cvmx_lmcx_ns_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_26_63               : 38;
+	uint64_t ns_scramble_dis              : 1;  /**< When set, this field disables data scrambling on non-secure accesses only.
+                                                         When data scrambling is enabled by setting CONTROL[SCRAMBLE_ENA] to 1, this
+                                                         field needs to be cleared to 0 in order to enable data scrambling on
+                                                         non-secure mode. */
+	uint64_t reserved_18_24               : 7;
+	uint64_t adr_offset                   : 18; /**< Sets the offset to the upper 18 bits of L2C-LMC address when a non-secure mode
+                                                         transaction occurs. */
+#else
+	uint64_t adr_offset                   : 18;
+	uint64_t reserved_18_24               : 7;
+	uint64_t ns_scramble_dis              : 1;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} s;
+	struct cvmx_lmcx_ns_ctl_s             cn73xx;
+};
+typedef union cvmx_lmcx_ns_ctl cvmx_lmcx_ns_ctl_t;
+
+/**
  * cvmx_lmc#_nxm
  *
  * Following is the decoding for mem_msb/rank:
@@ -8310,6 +9622,7 @@ union cvmx_lmcx_nxm {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_nxm_cn70xx           cn70xxp1;
+	struct cvmx_lmcx_nxm_cn70xx           cn73xx;
 	struct cvmx_lmcx_nxm_cn70xx           cn78xx;
 	struct cvmx_lmcx_nxm_s                cnf71xx;
 };
@@ -8328,6 +9641,25 @@ union cvmx_lmcx_nxm_fadr {
 	uint64_t u64;
 	struct cvmx_lmcx_nxm_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t nxm_faddr_ext                : 1;  /**< Reserved. */
+	uint64_t nxm_src                      : 1;  /**< Indicates the source of the operation that caused a NXM error:
+                                                         0 = L2C, 1 = HFA */
+	uint64_t nxm_type                     : 1;  /**< Indicates the type of operation that caused NXM error:
+                                                         0 = Read, 1 = Write */
+	uint64_t nxm_faddr                    : 37; /**< Failing L2C-LMC address. Bits<3:0> are always 0s for an HFA access, and bits<4:0> are
+                                                         always 0s for an L2C access. Bits<5:4> represent the fill order for an L2C read operation,
+                                                         and the start point within a cache line for a write operation. */
+#else
+	uint64_t nxm_faddr                    : 37;
+	uint64_t nxm_type                     : 1;
+	uint64_t nxm_src                      : 1;
+	uint64_t nxm_faddr_ext                : 1;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} s;
+	struct cvmx_lmcx_nxm_fadr_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_39_63               : 25;
 	uint64_t nxm_src                      : 1;  /**< Indicates the source of the operation that caused a NXM error:
                                                          0 = L2C, 1 = HFA */
@@ -8342,9 +9674,9 @@ union cvmx_lmcx_nxm_fadr {
 	uint64_t nxm_src                      : 1;
 	uint64_t reserved_39_63               : 25;
 #endif
-	} s;
-	struct cvmx_lmcx_nxm_fadr_s           cn70xx;
-	struct cvmx_lmcx_nxm_fadr_s           cn70xxp1;
+	} cn70xx;
+	struct cvmx_lmcx_nxm_fadr_cn70xx      cn70xxp1;
+	struct cvmx_lmcx_nxm_fadr_s           cn73xx;
 	struct cvmx_lmcx_nxm_fadr_s           cn78xx;
 };
 typedef union cvmx_lmcx_nxm_fadr cvmx_lmcx_nxm_fadr_t;
@@ -8375,6 +9707,7 @@ union cvmx_lmcx_ops_cnt {
 	struct cvmx_lmcx_ops_cnt_s            cn68xxp1;
 	struct cvmx_lmcx_ops_cnt_s            cn70xx;
 	struct cvmx_lmcx_ops_cnt_s            cn70xxp1;
+	struct cvmx_lmcx_ops_cnt_s            cn73xx;
 	struct cvmx_lmcx_ops_cnt_s            cn78xx;
 	struct cvmx_lmcx_ops_cnt_s            cnf71xx;
 };
@@ -8456,7 +9789,12 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_phy_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_51_63               : 13;
+	uint64_t reserved_58_63               : 6;
+	uint64_t data_rate_loopback           : 1;  /**< Reserved. */
+	uint64_t dq_shallow_loopback          : 1;  /**< Reserved. */
+	uint64_t dm_disable                   : 1;  /**< Reserved. */
+	uint64_t c1_sel                       : 2;  /**< Reserved. */
+	uint64_t c0_sel                       : 2;  /**< Reserved. */
 	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
                                                          clear to value of 0. */
 	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
@@ -8477,7 +9815,16 @@ union cvmx_lmcx_phy_ctl {
                                                          1 = 9 bits per byte lane, including DBI. */
 	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
                                                          byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
-	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation. */
+	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation.
+                                                         0x0 = DQ0.
+                                                         0x1 = DQ1.
+                                                         0x2 = DQ2.
+                                                         0x3 = DQ3.
+                                                         0x4 = DBI.
+                                                         0x5 = DQ4.
+                                                         0x6 = DQ5.
+                                                         0x7 = DQ6.
+                                                         0x8 = DQ7. */
 	uint64_t dbi_mode_ena                 : 1;  /**< Enable DBI mode for PHY. */
 	uint64_t ddr_error_n_ena              : 1;  /**< Enable error_alert_n signal for PHY. */
 	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
@@ -8536,7 +9883,12 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t dsk_dbg_rd_data              : 10;
 	uint64_t dsk_dbg_rd_complete          : 1;
 	uint64_t phy_reset                    : 1;
-	uint64_t reserved_51_63               : 13;
+	uint64_t c0_sel                       : 2;
+	uint64_t c1_sel                       : 2;
+	uint64_t dm_disable                   : 1;
+	uint64_t dq_shallow_loopback          : 1;
+	uint64_t data_rate_loopback           : 1;
+	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
 	struct cvmx_lmcx_phy_ctl_cn61xx {
@@ -8607,8 +9959,90 @@ union cvmx_lmcx_phy_ctl {
 	struct cvmx_lmcx_phy_ctl_cn61xx       cn66xx;
 	struct cvmx_lmcx_phy_ctl_cn61xx       cn68xx;
 	struct cvmx_lmcx_phy_ctl_cn61xx       cn68xxp1;
-	struct cvmx_lmcx_phy_ctl_s            cn70xx;
-	struct cvmx_lmcx_phy_ctl_s            cn70xxp1;
+	struct cvmx_lmcx_phy_ctl_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_51_63               : 13;
+	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
+                                                         clear to value of 0. */
+	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
+                                                         operation is started, then set to 1 when operation is complete. */
+	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. INTERNAL: Data from a deskew read operation. Only valid when the
+                                                         LMCX_PHY_CTL[DSK_DBG_RD_COMPLETE] bit is set. */
+	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. INTERNAL: Write 1 to start deskew data read operation, will automatically clear
+                                                         to 0. Write to 1 will also clear the complete bit. */
+	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. INTERNAL: Adjust clock toggle rate for reading deskew debug information:
+                                                         0 = Deskew read clock toggles every 1 DCLK
+                                                         1 = Deskew read clock toggles every 2 DCLKs
+                                                         2 = Deskew read clock toggles every 3 DCLKs
+                                                         3 = Deskew read clock toggles every 4 DCLKs */
+	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
+                                                         DDR PHY. */
+	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
+                                                         0 = 8 bits per byte lane, no DBI
+                                                         1 = 9 bits per byte lane, including DBI */
+	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
+                                                         byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
+	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation. */
+	uint64_t dbi_mode_ena                 : 1;  /**< Enable DBI mode for PHY, must be 0.  DBI mode not supported
+                                                         in CN70XX. */
+	uint64_t ddr_error_n_ena              : 1;  /**< Reserved. */
+	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
+	uint64_t dac_on                       : 1;  /**< Reserved. INTERNAL: PHY DAC on. */
+	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMCX_PHY_CTL[PHY_DSK_BYP]
+                                                         when loopback is enabled. */
+	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. INTERNAL: PHY loopback enable. */
+	uint64_t phy_dsk_reset                : 1;  /**< PHY deskew reset. When set, the deskew reset signal goes active if the Vrefint/deskew
+                                                         training sequence is in the idle state. */
+	uint64_t phy_dsk_byp                  : 1;  /**< PHY deskew bypass. */
+	uint64_t phy_pwr_save_disable         : 1;  /**< DDR PHY power save disable. */
+	uint64_t ten                          : 1;  /**< DDR PHY test enable pin. */
+	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. INTERNAL: Set to force read_enable to PHY active all the time. */
+	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. INTERNAL: Low Voltage Mode (1.35V.) */
+	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
+	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
+	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
+	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
+	uint64_t loopback                     : 1;  /**< Reserved; must be zero. INTERNAL: Loopback enable. */
+	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. INTERNAL: Loopback pos mode. */
+	uint64_t ts_stagger                   : 1;  /**< TS stagger mode. This mode configures output drivers with two-stage drive strength to
+                                                         avoid undershoot issues on the bus when strong drivers are suddenly turned on. When this
+                                                         mode is asserted, CN78XX will configure output drivers to be weak drivers (60ohm output
+                                                         impedance) at the first CK cycle, and change drivers to the designated drive strengths
+                                                         specified in LMC(0..0)_COMP_CTL2[CMD_CTL/CK_CTL/DQX_CTL] starting at the following cycle. */
+#else
+	uint64_t ts_stagger                   : 1;
+	uint64_t loopback_pos                 : 1;
+	uint64_t loopback                     : 1;
+	uint64_t ck_dlyout0                   : 4;
+	uint64_t ck_tune0                     : 1;
+	uint64_t ck_dlyout1                   : 4;
+	uint64_t ck_tune1                     : 1;
+	uint64_t lv_mode                      : 1;
+	uint64_t rx_always_on                 : 1;
+	uint64_t ten                          : 1;
+	uint64_t phy_pwr_save_disable         : 1;
+	uint64_t phy_dsk_byp                  : 1;
+	uint64_t phy_dsk_reset                : 1;
+	uint64_t int_phy_loopback_ena         : 1;
+	uint64_t int_pad_loopback_ena         : 1;
+	uint64_t dac_on                       : 1;
+	uint64_t ref_pin_on                   : 1;
+	uint64_t ddr_error_n_ena              : 1;
+	uint64_t dbi_mode_ena                 : 1;
+	uint64_t dsk_dbg_bit_sel              : 4;
+	uint64_t dsk_dbg_byte_sel             : 4;
+	uint64_t dsk_dbg_num_bits_sel         : 1;
+	uint64_t dsk_dbg_offset               : 2;
+	uint64_t dsk_dbg_clk_scaler           : 2;
+	uint64_t dsk_dbg_rd_start             : 1;
+	uint64_t dsk_dbg_rd_data              : 10;
+	uint64_t dsk_dbg_rd_complete          : 1;
+	uint64_t phy_reset                    : 1;
+	uint64_t reserved_51_63               : 13;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_phy_ctl_cn70xx       cn70xxp1;
+	struct cvmx_lmcx_phy_ctl_s            cn73xx;
 	struct cvmx_lmcx_phy_ctl_s            cn78xx;
 	struct cvmx_lmcx_phy_ctl_cn61xx       cnf71xx;
 };
@@ -8826,6 +10260,64 @@ union cvmx_lmcx_pll_status {
 typedef union cvmx_lmcx_pll_status cvmx_lmcx_pll_status_t;
 
 /**
+ * cvmx_lmc#_ppr_ctl
+ *
+ * This register contains programmable timing and control parameters used
+ * when running the post package repair sequence. The timing fields
+ * PPR_CTL[TPGMPST], PPR_CTL[TPGM_EXIT] and PPR_CTL[TPGM] need to be set as
+ * to satisfy the minimum values mentioned in the JEDEC DDR4 spec before
+ * running the PPR sequence. See LMC()_SEQ_CTL[SEQ_SEL,INIT_START] to run
+ * the PPR sequence.
+ *
+ * Running Hard PPR may require LMC to issue Security Key as four consecutive
+ * MR0 commands, each with a unique address field A[17:0]. Set the Security
+ * Key in the general purpose CSRs as follows:
+ *
+ * _ Security Key 0 = LMC()_GENERAL_PURPOSE0[DATA]<17:0>.
+ * _ Security Key 1 = LMC()_GENERAL_PURPOSE0[DATA]<35:18>.
+ * _ Security Key 2 = LMC()_GENERAL_PURPOSE1[DATA]<17:0>.
+ * _ Security Key 3 = LMC()_GENERAL_PURPOSE1[DATA]<35:18>.
+ */
+union cvmx_lmcx_ppr_ctl {
+	uint64_t u64;
+	struct cvmx_lmcx_ppr_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t skip_issue_security          : 1;  /**< Personality bit for the PPR sequence. When set, this field forces the sequence to skip
+                                                         issuing four consecutive MR0 commands that suppliy the Security Key. */
+	uint64_t sppr                         : 1;  /**< Personality bit for the PPR sequence. When set, this field forces the sequence to run
+                                                         the Soft PPR mode. */
+	uint64_t tpgm                         : 10; /**< Indicates the programming time (tPGM) constraint used when running PPR sequence.
+                                                         For hard PPR (PPR_CTL[SPPR] = 0), set this field as follows:
+                                                         RNDUP[TPGM(ns) / (1048576 * TCYC(ns))].
+                                                         For soft PPR (PPR_CTL[SPPR] = 1), set this field as follows:
+                                                         RNDUP[TPGM(ns) / TCYC(ns))].
+                                                         TPGM is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not data
+                                                         rate). */
+	uint64_t tpgm_exit                    : 5;  /**< Indicates PPR Exit time (tPGM_Exit) contrainst used when running PPR sequence.
+                                                         Set this field as follows:
+                                                         _ RNDUP[TPGM_EXIT(ns) / TCYC(ns)]
+                                                         where TPGM_EXIT is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not
+                                                         data rate). */
+	uint64_t tpgmpst                      : 7;  /**< Indicates New Address Setting time (tPGMPST) constraint used when running PPR sequence.
+                                                         Set this field as follows:
+                                                         _ RNDUP[TPGMPST(ns) / (1024 * TCYC(ns))]
+                                                         where TPGMPST is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not
+                                                         data rate). */
+#else
+	uint64_t tpgmpst                      : 7;
+	uint64_t tpgm_exit                    : 5;
+	uint64_t tpgm                         : 10;
+	uint64_t sppr                         : 1;
+	uint64_t skip_issue_security          : 1;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_lmcx_ppr_ctl_s            cn73xx;
+};
+typedef union cvmx_lmcx_ppr_ctl cvmx_lmcx_ppr_ctl_t;
+
+/**
  * cvmx_lmc#_read_level_ctl
  *
  * Notes:
@@ -8955,6 +10447,30 @@ union cvmx_lmcx_read_level_rankx {
 typedef union cvmx_lmcx_read_level_rankx cvmx_lmcx_read_level_rankx_t;
 
 /**
+ * cvmx_lmc#_ref_status
+ *
+ * This register contains the status of the refresh pending counter.
+ *
+ */
+union cvmx_lmcx_ref_status {
+	uint64_t u64;
+	struct cvmx_lmcx_ref_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t ref_pend_max_clr             : 1;  /**< Indicates that the number of pending refreshes has reached 7. Requiring
+                                                         software to clear the flag by setting this field to 1. */
+	uint64_t ref_count                    : 3;  /**< Reads back the number of pending refreshes that LMC has yet to execute. */
+#else
+	uint64_t ref_count                    : 3;
+	uint64_t ref_pend_max_clr             : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_lmcx_ref_status_s         cn73xx;
+};
+typedef union cvmx_lmcx_ref_status cvmx_lmcx_ref_status_t;
+
+/**
  * cvmx_lmc#_reset_ctl
  *
  * Specify the RSL base addresses for the block.
@@ -8975,25 +10491,122 @@ union cvmx_lmcx_reset_ctl {
                                                          0 = Reset asserted
                                                          1 = Reset de-asserted */
 #else
-	uint64_t ddr3rst                      : 1;
-	uint64_t ddr3pwarm                    : 1;
-	uint64_t ddr3psoft                    : 1;
-	uint64_t ddr3psv                      : 1;
-	uint64_t reserved_4_63                : 60;
+	uint64_t ddr3rst                      : 1;
+	uint64_t ddr3pwarm                    : 1;
+	uint64_t ddr3psoft                    : 1;
+	uint64_t ddr3psv                      : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_lmcx_reset_ctl_s          cn61xx;
+	struct cvmx_lmcx_reset_ctl_s          cn63xx;
+	struct cvmx_lmcx_reset_ctl_s          cn63xxp1;
+	struct cvmx_lmcx_reset_ctl_s          cn66xx;
+	struct cvmx_lmcx_reset_ctl_s          cn68xx;
+	struct cvmx_lmcx_reset_ctl_s          cn68xxp1;
+	struct cvmx_lmcx_reset_ctl_s          cn70xx;
+	struct cvmx_lmcx_reset_ctl_s          cn70xxp1;
+	struct cvmx_lmcx_reset_ctl_s          cn73xx;
+	struct cvmx_lmcx_reset_ctl_s          cn78xx;
+	struct cvmx_lmcx_reset_ctl_s          cnf71xx;
+};
+typedef union cvmx_lmcx_reset_ctl cvmx_lmcx_reset_ctl_t;
+
+/**
+ * cvmx_lmc#_retry_config
+ *
+ * This register configures automatic retry operation.
+ *
+ */
+union cvmx_lmcx_retry_config {
+	uint64_t u64;
+	struct cvmx_lmcx_retry_config_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_56_63               : 8;
+	uint64_t max_errors                   : 24; /**< Maximum number of errors before errors are ignored. */
+	uint64_t reserved_13_31               : 19;
+	uint64_t error_continue               : 1;  /**< If LMC()_RETRY_CONFIG[AUTO_ERROR_CONTINUE] is cleared, LMC will wait
+                                                         for a 1 to be written to LMC()_RETRY_CONFIG[ERROR_CONTINUE] before
+                                                         continuing operations after an error. */
+	uint64_t reserved_9_11                : 3;
+	uint64_t auto_error_continue          : 1;  /**< When set, LMC will automatically proceed with error handling and normal
+                                                         operation after an error occurs.  If clear, LMC will cease all operations
+                                                         except for refresh as soon as possible, and will not continue with error
+                                                         handling or normal operation until LMC()_RETRY_CONFIG[ERROR_CONTINUE]
+                                                         is written with a 1. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t pulse_count_auto_clr         : 1;  /**< When set, LMC()_RETRY_STATUS[ERROR_PULSE_COUNT_VALID] will clear
+                                                         whenever the error interrupt is cleared. */
+	uint64_t reserved_1_3                 : 3;
+	uint64_t retry_enable                 : 1;  /**< Enable retry on errors. */
+#else
+	uint64_t retry_enable                 : 1;
+	uint64_t reserved_1_3                 : 3;
+	uint64_t pulse_count_auto_clr         : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t auto_error_continue          : 1;
+	uint64_t reserved_9_11                : 3;
+	uint64_t error_continue               : 1;
+	uint64_t reserved_13_31               : 19;
+	uint64_t max_errors                   : 24;
+	uint64_t reserved_56_63               : 8;
+#endif
+	} s;
+	struct cvmx_lmcx_retry_config_s       cn73xx;
+};
+typedef union cvmx_lmcx_retry_config cvmx_lmcx_retry_config_t;
+
+/**
+ * cvmx_lmc#_retry_status
+ *
+ * This register provides status on automatic retry operation.
+ *
+ */
+union cvmx_lmcx_retry_status {
+	uint64_t u64;
+	struct cvmx_lmcx_retry_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t clear_error_count            : 1;  /**< Clear the error count, one shot operation. */
+	uint64_t clear_error_pulse_count      : 1;  /**< Clear the error count, one shot operation. */
+	uint64_t reserved_57_61               : 5;
+	uint64_t error_pulse_count_valid      : 1;  /**< When set and the count is valid, indicates that the counter has saturated,
+                                                         which effectively indicates that a command error has occured and not a CRC
+                                                         error. */
+	uint64_t error_pulse_count_sat        : 1;  /**< When set and the count is valid, indicates that the counter has saturated,
+                                                         which effectively indicates that a command error has occured and not a CRC
+                                                         error. */
+	uint64_t reserved_52_54               : 3;
+	uint64_t error_pulse_count            : 4;  /**< Count of cycles in last error pulse since clear.  This count will be cleared
+                                                         either by clearing the interrupt or writing a 1 to the pulse count clear bit. */
+	uint64_t reserved_45_47               : 3;
+	uint64_t error_sequence               : 5;  /**< Sequence number for sequence that was running when error occurred. */
+	uint64_t reserved_33_39               : 7;
+	uint64_t error_type                   : 1;  /**< Error type:
+                                                         0 = Error during a sequence run.
+                                                         1 = Error during normal operation, which means a read or write operation. Effectively this
+                                                         means a command error for a read or write operation, or a CRC error for a write data
+                                                         operation. */
+	uint64_t reserved_24_31               : 8;
+	uint64_t error_count                  : 24; /**< Number of errors encountered since last cleared. */
+#else
+	uint64_t error_count                  : 24;
+	uint64_t reserved_24_31               : 8;
+	uint64_t error_type                   : 1;
+	uint64_t reserved_33_39               : 7;
+	uint64_t error_sequence               : 5;
+	uint64_t reserved_45_47               : 3;
+	uint64_t error_pulse_count            : 4;
+	uint64_t reserved_52_54               : 3;
+	uint64_t error_pulse_count_sat        : 1;
+	uint64_t error_pulse_count_valid      : 1;
+	uint64_t reserved_57_61               : 5;
+	uint64_t clear_error_pulse_count      : 1;
+	uint64_t clear_error_count            : 1;
 #endif
 	} s;
-	struct cvmx_lmcx_reset_ctl_s          cn61xx;
-	struct cvmx_lmcx_reset_ctl_s          cn63xx;
-	struct cvmx_lmcx_reset_ctl_s          cn63xxp1;
-	struct cvmx_lmcx_reset_ctl_s          cn66xx;
-	struct cvmx_lmcx_reset_ctl_s          cn68xx;
-	struct cvmx_lmcx_reset_ctl_s          cn68xxp1;
-	struct cvmx_lmcx_reset_ctl_s          cn70xx;
-	struct cvmx_lmcx_reset_ctl_s          cn70xxp1;
-	struct cvmx_lmcx_reset_ctl_s          cn78xx;
-	struct cvmx_lmcx_reset_ctl_s          cnf71xx;
+	struct cvmx_lmcx_retry_status_s       cn73xx;
 };
-typedef union cvmx_lmcx_reset_ctl cvmx_lmcx_reset_ctl_t;
+typedef union cvmx_lmcx_retry_status cvmx_lmcx_retry_status_t;
 
 /**
  * cvmx_lmc#_rlevel_ctl
@@ -9122,6 +10735,7 @@ union cvmx_lmcx_rlevel_ctl {
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cn68xxp1;
 	struct cvmx_lmcx_rlevel_ctl_s         cn70xx;
 	struct cvmx_lmcx_rlevel_ctl_s         cn70xxp1;
+	struct cvmx_lmcx_rlevel_ctl_s         cn73xx;
 	struct cvmx_lmcx_rlevel_ctl_s         cn78xx;
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cnf71xx;
 };
@@ -9158,6 +10772,7 @@ union cvmx_lmcx_rlevel_dbg {
 	struct cvmx_lmcx_rlevel_dbg_s         cn68xxp1;
 	struct cvmx_lmcx_rlevel_dbg_s         cn70xx;
 	struct cvmx_lmcx_rlevel_dbg_s         cn70xxp1;
+	struct cvmx_lmcx_rlevel_dbg_s         cn73xx;
 	struct cvmx_lmcx_rlevel_dbg_s         cn78xx;
 	struct cvmx_lmcx_rlevel_dbg_s         cnf71xx;
 };
@@ -9234,6 +10849,7 @@ union cvmx_lmcx_rlevel_rankx {
 	struct cvmx_lmcx_rlevel_rankx_s       cn68xxp1;
 	struct cvmx_lmcx_rlevel_rankx_s       cn70xx;
 	struct cvmx_lmcx_rlevel_rankx_s       cn70xxp1;
+	struct cvmx_lmcx_rlevel_rankx_s       cn73xx;
 	struct cvmx_lmcx_rlevel_rankx_s       cn78xx;
 	struct cvmx_lmcx_rlevel_rankx_s       cnf71xx;
 };
@@ -9432,6 +11048,7 @@ union cvmx_lmcx_rodt_mask {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_rodt_mask_cn70xx     cn70xxp1;
+	struct cvmx_lmcx_rodt_mask_cn70xx     cn73xx;
 	struct cvmx_lmcx_rodt_mask_cn70xx     cn78xx;
 	struct cvmx_lmcx_rodt_mask_s          cnf71xx;
 };
@@ -9456,6 +11073,7 @@ union cvmx_lmcx_scramble_cfg0 {
 	struct cvmx_lmcx_scramble_cfg0_s      cn66xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cn70xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cn70xxp1;
+	struct cvmx_lmcx_scramble_cfg0_s      cn73xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cn78xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cnf71xx;
 };
@@ -9480,12 +11098,29 @@ union cvmx_lmcx_scramble_cfg1 {
 	struct cvmx_lmcx_scramble_cfg1_s      cn66xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cn70xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cn70xxp1;
+	struct cvmx_lmcx_scramble_cfg1_s      cn73xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cn78xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cnf71xx;
 };
 typedef union cvmx_lmcx_scramble_cfg1 cvmx_lmcx_scramble_cfg1_t;
 
 /**
+ * cvmx_lmc#_scramble_cfg2
+ */
+union cvmx_lmcx_scramble_cfg2 {
+	uint64_t u64;
+	struct cvmx_lmcx_scramble_cfg2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t key                          : 64; /**< Scramble key for data. */
+#else
+	uint64_t key                          : 64;
+#endif
+	} s;
+	struct cvmx_lmcx_scramble_cfg2_s      cn73xx;
+};
+typedef union cvmx_lmcx_scramble_cfg2 cvmx_lmcx_scramble_cfg2_t;
+
+/**
  * cvmx_lmc#_scrambled_fadr
  *
  * LMC()_FADR captures the failing pre-scrambled address location (split into DIMM, bunk,
@@ -9508,7 +11143,8 @@ union cvmx_lmcx_scrambled_fadr {
 	uint64_t u64;
 	struct cvmx_lmcx_scrambled_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_40_63               : 24;
+	uint64_t reserved_43_63               : 21;
+	uint64_t fcid                         : 3;  /**< Reserved. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t reserved_14_37               : 24;
 	uint64_t fcol                         : 14; /**< Failing Column Address[13:0]
@@ -9520,7 +11156,8 @@ union cvmx_lmcx_scrambled_fadr {
 	uint64_t fcol                         : 14;
 	uint64_t reserved_14_37               : 24;
 	uint64_t fill_order                   : 2;
-	uint64_t reserved_40_63               : 24;
+	uint64_t fcid                         : 3;
+	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
 	struct cvmx_lmcx_scrambled_fadr_cn61xx {
@@ -9567,7 +11204,30 @@ union cvmx_lmcx_scrambled_fadr {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_scrambled_fadr_cn70xx cn70xxp1;
-	struct cvmx_lmcx_scrambled_fadr_cn70xx cn78xx;
+	struct cvmx_lmcx_scrambled_fadr_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_43_63               : 21;
+	uint64_t fcid                         : 3;  /**< Failing CID number. */
+	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
+	uint64_t fdimm                        : 1;  /**< Failing DIMM number. */
+	uint64_t fbunk                        : 1;  /**< Failing rank number. */
+	uint64_t fbank                        : 4;  /**< Failing bank number. Bits <3:0>. */
+	uint64_t frow                         : 18; /**< Failing row address. Bits <17:0>. */
+	uint64_t fcol                         : 14; /**< Failing column address <13:0>. Technically, represents the address of the 128b data that
+                                                         had an ECC error, i.e., FCOL<0> is always 0. Can be used in conjunction with
+                                                         LMC()_CONFIG[DED_ERR] to isolate the 64b chunk of data in error. */
+#else
+	uint64_t fcol                         : 14;
+	uint64_t frow                         : 18;
+	uint64_t fbank                        : 4;
+	uint64_t fbunk                        : 1;
+	uint64_t fdimm                        : 1;
+	uint64_t fill_order                   : 2;
+	uint64_t fcid                         : 3;
+	uint64_t reserved_43_63               : 21;
+#endif
+	} cn73xx;
+	struct cvmx_lmcx_scrambled_fadr_cn73xx cn78xx;
 	struct cvmx_lmcx_scrambled_fadr_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_scrambled_fadr cvmx_lmcx_scrambled_fadr_t;
@@ -9587,58 +11247,35 @@ union cvmx_lmcx_seq_ctl {
                                                          when the sequence is completed. */
 	uint64_t seq_sel                      : 4;  /**< Selects the sequence that LMC runs after a 0->1 transition on INIT_START.
                                                          0x0 = Power-up/initialization:
-                                                         LMC(0..3)_CONFIG[RANKMASK] selects participating ranks (should be all ranks with attached
-                                                         DRAM). DDR_CKE* signals are activated (if not already active).
+                                                         LMC()_CONFIG[RANKMASK] selects participating ranks (should be all ranks with attached
+                                                         DRAM). DDR*_DIMM*_CKE* signals are activated (if not already active). RDIMM register
+                                                         control words 0-15 are written to LMC()_CONFIG[RANKMASK]-selected RDIMMs when
+                                                         LMC()_CONTROL[RDIMM_ENA] = 1 and corresponding LMC()_DIMM_CTL[DIMM*_WMASK] bits
+                                                         are set. (Refer to LMC()_DIMM(0..1)_PARAMS and LMC()_DIMM_CTL descriptions for
+                                                         more details.)
                                                          The DRAM registers MR0, MR1, MR2, and MR3 are written in the selected ranks.
                                                          0x1 = Read-leveling:
-                                                         LMC(0..3)_CONFIG[RANKMASK] selects the rank to be read-leveled. MR3 written in the
+                                                         LMC()_CONFIG[RANKMASK] selects the rank to be read-leveled. MR3 written in the
                                                          selected rank.
                                                          0x2 = Self-refresh entry:
-                                                         LMC(0..3)_CONFIG[INIT_STATUS] selects the participating ranks (should be all ranks with
+                                                         LMC()_CONFIG[INIT_STATUS] selects the participating ranks (should be all ranks with
                                                          attached DRAM). MR1 and MR2 are written in the selected ranks if
-                                                         LMC(0..3)_CONFIG[SREF_WITH_DLL] = 1. DDR_CKE* signals de-activated.
+                                                         LMC()_CONFIG[SREF_WITH_DLL] = 1. DDR*_DIMM*_CKE* signals de-activated.
                                                          0x3 = Self-refresh exit:
-                                                         LMC(0..3)_CONFIG[RANKMASK] must be set to indicate participating ranks (should be all
-                                                         ranks with attached DRAM). DDR_CKE* signals activated. MR0, MR1, MR2, and MR3 are
-                                                         written in the participating ranks if LMC(0..3)_CONFIG[SREF_WITH_DLL] = 1.
-                                                         LMC(0..3)_CONFIG[INIT_STATUS] is updated for ranks that are selected.
+                                                         LMC()_CONFIG[RANKMASK] must be set to indicate participating ranks (should be all
+                                                         ranks with attached DRAM). DDR*_DIMM*_CKE* signals activated. MR0, MR1, MR2, and MR3 are
+                                                         written in the participating ranks if LMC()_CONFIG[SREF_WITH_DLL] = 1.
+                                                         LMC()_CONFIG[INIT_STATUS] is updated for ranks that are selected.
                                                          0x6 = Write-leveling:
-                                                         RANKMASK selects the rank to be write-leveled.
-                                                         INIT_STATUS must indicate all ranks with attached DRAM.
-                                                         MR1 and MR2 written to INIT_STATUS-selected ranks.
-                                                         0x7 = Init RCW
-                                                         RANKMASK selects participating ranks (should be all ranks with attached DRAM).
-                                                         In DDR3 mode, RDIMM register control words 0-15 will be written to RANKMASK-selected
-                                                         RDIMMs when LMC(0..3)_CONTROL[RDIMM_ENA]=1 and corresponding
-                                                         LMC(0..3)_DIMM_CTL[DIMM*_WMASK]
-                                                         bits are set. (Refer to LMC(0..3)_DIMM(0..1)_PARAMS and LMC(0..3)_DIMM_CTL descriptions
-                                                         below for more details.)  In DDR4 mode, additionally register control words RC1x-RCBx
-                                                         will be written if selected by LMC(0..3)_DDR4_DIMM_CTL[DIMM*_WMASK].  See
-                                                         LMC(0..3)_DIMM(0..1)_DDR4_PARAMS0 and LMC(0..3)_DIMM(0..1)_DDR4_PARAMS1 for the values
-                                                         that are written to the DDR4 RCWs.
-                                                         0x8 = MRW
-                                                         Mode Register Write sequence.
-                                                         0x9 = MPR
-                                                         MPR register read or write sequence.
-                                                         0xa = VREFINT
-                                                         Vref internal training sequence, also used as deskew training sequence when
-                                                         LMC(0..3)_EXT_CONFIG[VREFINT_SEQ_DESKEW] is set.
-                                                         0xb = Offset Training
-                                                         Offset training sequence.
-                                                         Self-refresh entry SEQ_SEL's may also be automatically
-                                                         generated by hardware upon a chip warm or soft reset
-                                                         sequence when LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT] are set.
-                                                         LMC writes the LMC*_MODEREG_PARAMS0 and LMC*_MODEREG_PARAMS1 CSR field values
-                                                         to the Mode registers in the DRAM parts (i.e. MR0, MR1, MR2, and MR3) as part of some of
-                                                         these sequences.
-                                                         Refer to the LMC*_MODEREG_PARAMS0 and LMC*_MODEREG_PARAMS1 descriptions for more details.
-                                                         If there are two consecutive power-up/init's without
-                                                         a DRESET assertion between them, LMC asserts DDR_CKE* as part of
-                                                         the first power-up/init, and continues to assert DDR_CKE*
-                                                         through the remainder of the first and the second power-up/init.
-                                                         If DDR_CKE* deactivation and reactivation is needed for
-                                                         a second power-up/init, a DRESET assertion is required
-                                                         between the first and the second. */
+                                                         LMC()_CONFIG[RANKMASK] selects the rank to be write-leveled.
+                                                         LMC()_CONFIG[INIT_STATUS] must indicate all ranks with attached DRAM. MR1 and MR2
+                                                         written in the LMC()_CONFIG[INIT_STATUS]-selected ranks.
+                                                         0x7 = Initialize RCW:
+                                                         LMC()_CONFIG[RANKMASK] selects participating ranks (should be all ranks with attached
+                                                         DRAM). In DDR3 mode, RDIMM register control words 0-15 are written to
+                                                         LMC()_CONFIG[RANKMASK]-selected RDIMMs when LMC()_CONTROL[RDIMM_ENA] = 1 and
+                                                         corresponding LMC()_DIMM_CTL[DIMM*_WMASK] bits are set. (Refer to
+                                                         LMC()_DIMM(0..1)_PARAMS and LMC()_DIMM_CTL descriptions for more details.) */
 	uint64_t init_start                   : 1;  /**< A 0->1 transition starts the DDR memory sequence that is selected by
                                                          LMC()_SEQ_CTL[SEQ_SEL].
                                                          This register is a one-shot and clears itself each time it is set. */
@@ -9651,6 +11288,7 @@ union cvmx_lmcx_seq_ctl {
 	} s;
 	struct cvmx_lmcx_seq_ctl_s            cn70xx;
 	struct cvmx_lmcx_seq_ctl_s            cn70xxp1;
+	struct cvmx_lmcx_seq_ctl_s            cn73xx;
 	struct cvmx_lmcx_seq_ctl_s            cn78xx;
 };
 typedef union cvmx_lmcx_seq_ctl cvmx_lmcx_seq_ctl_t;
@@ -9660,41 +11298,30 @@ typedef union cvmx_lmcx_seq_ctl cvmx_lmcx_seq_ctl_t;
  *
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
- * fields in th
- * LMC(0..3)_WLEVEL_RANK(0..1), LMC(0..3)_CONTROL, and LMC(0..3)_MODEREG_PARAMS0 registers
+ * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL, and LMC()_MODEREG_PARAMS0 registers
  * change. Ideally, only read this register after LMC has been initialized and
- * LMC(0..3)_RLEVEL_RANK(0..1), LMC(0..3)_WLEVEL_RANK(0..1) have valid data.
- * The field value is the minimum CK cycles between when the DRAM
- * part registers CAS commands of the first and second types from different cache blocks.
+ * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
+ *
+ * The interpretation of the fields in this register depends on LMC(0)_CONFIG[DDR2T]:
+ *
+ * * If LMC()_CONFIG[DDR2T]=1, (FieldValue + 4) is the minimum CK cycles between when
+ * the DRAM part registers CAS commands of the first and second types from different cache
+ * blocks.
  *
- * "*_S_INIT" fields are DDR3 timing or DDR4 short timing parameters
- * "*_L_INIT" fields are DDR4 long timing parameters
- *
- * The hardware-calculated minimums are:
- * min R2R_S_INIT = 4
- * min R2W_S_INIT = 8 + (RL + MaxRdSkew) (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]
- * min W2R_S_INIT = 5 + LMC*_TIMING_PARAMS1[TWTR] + WL
- * min W2W_S_INIT = 4
- * min R2R_L_INIT = LMC*_MODEREG_PARAMS3[TCCD_L] (decoded)
- * min R2W_L_INIT = 8 + (RL + MaxRdSkew) (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]
- * min W2R_L_INIT = 5 + LMC*_TIMING_PARAMS2[TWTR_L] + WL
- * min W2W_L_INIT = LMC*_MODEREG_PARAMS3[TCCD_L] (decoded)
- * where
- * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects
- * AL)
- * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)
- * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1
- * (max is across all ranks i (0..3) and bytes j (0..8))
- * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX]
- * (min is across all ranks i (0..3) and bytes j (0..8))
- *
- * R2W_INIT has 1 CK cycle built in for OCTEON-internal ODT settling/channel turnaround time.
+ * If LMC()_CONFIG[DDR2T]=0, (FieldValue + 3) is the minimum CK cycles between when the DRAM
+ * part registers CAS commands of the first and second types from different cache blocks.
+ * FieldValue = 0 is always illegal in this case.
+ * The hardware-calculated minimums for these fields are shown in LMC(0)_SLOT_CTL0 Hardware-
+ * Calculated Minimums.
  */
 union cvmx_lmcx_slot_ctl0 {
 	uint64_t u64;
 	struct cvmx_lmcx_slot_ctl0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_48_63               : 16;
+	uint64_t reserved_50_63               : 14;
+	uint64_t w2r_l_init_ext               : 1;  /**< Reserved. */
+	uint64_t w2r_init_ext                 : 1;  /**< Reserved. */
 	uint64_t w2w_l_init                   : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
                                                          accesses to the same rank and DIMM, and same BG for DDR4. */
 	uint64_t w2r_l_init                   : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
@@ -9724,7 +11351,9 @@ union cvmx_lmcx_slot_ctl0 {
 	uint64_t r2w_l_init                   : 6;
 	uint64_t w2r_l_init                   : 6;
 	uint64_t w2w_l_init                   : 6;
-	uint64_t reserved_48_63               : 16;
+	uint64_t w2r_init_ext                 : 1;
+	uint64_t w2r_l_init_ext               : 1;
+	uint64_t reserved_50_63               : 14;
 #endif
 	} s;
 	struct cvmx_lmcx_slot_ctl0_cn61xx {
@@ -9755,8 +11384,39 @@ union cvmx_lmcx_slot_ctl0 {
 	struct cvmx_lmcx_slot_ctl0_cn61xx     cn66xx;
 	struct cvmx_lmcx_slot_ctl0_cn61xx     cn68xx;
 	struct cvmx_lmcx_slot_ctl0_cn61xx     cn68xxp1;
-	struct cvmx_lmcx_slot_ctl0_s          cn70xx;
-	struct cvmx_lmcx_slot_ctl0_s          cn70xxp1;
+	struct cvmx_lmcx_slot_ctl0_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t w2w_l_init                   : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
+                                                         accesses to the same rank and DIMM, and same BG for DDR4. */
+	uint64_t w2r_l_init                   : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
+                                                         to the same rank and DIMM, and same BG for DDR4. */
+	uint64_t r2w_l_init                   : 6;  /**< Read-to-write spacing control for back-to-back read followed by write cache block accesses
+                                                         to the same rank and DIMM, and same BG for DDR4. */
+	uint64_t r2r_l_init                   : 6;  /**< Read-to-read spacing control for back-to-back read followed by read cache block accesses
+                                                         to the same rank and DIMM, and same BG for DDR4. */
+	uint64_t w2w_init                     : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
+                                                         accesses to the same rank and DIMM. */
+	uint64_t w2r_init                     : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
+                                                         to the same rank and DIMM. */
+	uint64_t r2w_init                     : 6;  /**< Read-to-write spacing control for back-to-back read followed by write cache block accesses
+                                                         to the same rank and DIMM. */
+	uint64_t r2r_init                     : 6;  /**< Read-to-read spacing control for back-to-back read followed by read cache block accesses
+                                                         to the same rank and DIMM. */
+#else
+	uint64_t r2r_init                     : 6;
+	uint64_t r2w_init                     : 6;
+	uint64_t w2r_init                     : 6;
+	uint64_t w2w_init                     : 6;
+	uint64_t r2r_l_init                   : 6;
+	uint64_t r2w_l_init                   : 6;
+	uint64_t w2r_l_init                   : 6;
+	uint64_t w2w_l_init                   : 6;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_slot_ctl0_cn70xx     cn70xxp1;
+	struct cvmx_lmcx_slot_ctl0_s          cn73xx;
 	struct cvmx_lmcx_slot_ctl0_s          cn78xx;
 	struct cvmx_lmcx_slot_ctl0_cn61xx     cnf71xx;
 };
@@ -9767,33 +11427,22 @@ typedef union cvmx_lmcx_slot_ctl0 cvmx_lmcx_slot_ctl0_t;
  *
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
- * fields in this register to the minimum allowed value when any of LMC(0..3)_RLEVEL_RANK(0..1),
- * LMC(0..3)_WLEVEL_RANK(0..1), LMC(0..3)_CONTROL and LMC(0..3)_MODEREG_PARAMS0 CSRs change.
+ * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
  * Ideally, only read this register after LMC has been initialized and
- * LMC(0..3)_RLEVEL_RANK(0..1), LMC(0..3)_WLEVEL_RANK(0..1) have valid data.
- * The field value is the minimum CK cycles between when the DRAM
+ * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
+ *
+ * The interpretation of the fields in this CSR depends on LMC(0)_CONFIG[DDR2T]:
+ *
+ * * If LMC()_CONFIG[DDR2T]=1, (FieldValue + 4) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ *
+ * * If LMC()_CONFIG[DDR2T]=0, (FieldValue + 3) is the minimum CK cycles between when the DRAM
  * part registers CAS commands of the first and second types from different cache blocks.
+ * FieldValue = 0 is always illegal in this case.
  *
- * The hardware-calculated minimums are:
- * min R2R_XRANK_INIT = 5 + MaxRdSkew MinRdSkew + LMC*_CONTROL[RODT_BPRCH]
- * min R2W_XRANK_INIT = 8 + (RL + MaxRdSkew) - (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]
- * min W2R_XRANK_INIT = 6 + MaxWrSkew + LMC*_CONTROL[FPRCH2]
- * min W2W_XRANK_INIT = 7 + MaxWrSkew - MinWrSkew
- * where
- * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects
- * AL)
- * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)
- * MinRdSkew = min(LMC*_RLEVEL_RANKi[BYTEj]/4)                              (min is across all
- * ranks i (0..3) and bytes j (0..8))
- * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1                          (max is across all
- * ranks i (0..3) and bytes j (0..8))
- * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX]     (min is across all
- * ranks i (0..3) and bytes j (0..8))
- * MaxWrSkew = max(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX] + 1 (max is across all
- * ranks i (0..3) and bytes j (0..8))
- * R2W_XRANK_INIT has 1 extra CK cycle built in for OCTEON-internal ODT settling/channel
- * turnaround time.
- * W2R_XRANK_INIT has 1 extra CK cycle built in for channel turnaround time.
+ * The hardware-calculated minimums for these fields are shown in LMC(0)_SLOT_CTL1 Hardware-
+ * Calculated Minimums.
  */
 union cvmx_lmcx_slot_ctl1 {
 	uint64_t u64;
@@ -9828,6 +11477,7 @@ union cvmx_lmcx_slot_ctl1 {
 	struct cvmx_lmcx_slot_ctl1_s          cn68xxp1;
 	struct cvmx_lmcx_slot_ctl1_s          cn70xx;
 	struct cvmx_lmcx_slot_ctl1_s          cn70xxp1;
+	struct cvmx_lmcx_slot_ctl1_s          cn73xx;
 	struct cvmx_lmcx_slot_ctl1_s          cn78xx;
 	struct cvmx_lmcx_slot_ctl1_s          cnf71xx;
 };
@@ -9838,35 +11488,21 @@ typedef union cvmx_lmcx_slot_ctl1 cvmx_lmcx_slot_ctl1_t;
  *
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
- * fields in this register to the minimum allowed value when any of LMC(0..3)_RLEVEL_RANK(0..1),
- * LMC(0..3)_WLEVEL_RANK(0..1)LMC*_WLEVEL_RANKn, LMC*_CONTROL and LMC*_MODEREG_PARAMS0 CSRs
- * change. Ideally, only read this register after LMC has been initialized and LMC*_RLEVEL_RANKn,
- * LMC*_WLEVEL_RANKn have valid data.
+ * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
+ * Ideally, only read this register after LMC has been initialized and
+ * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
  *
- * The field value is the minimum CK cycles between when the DRAM
- * part registers CAS commands of the first and second types from different cache blocks.
+ * The interpretation of the fields in this CSR depends on LMC(0)_CONFIG[DDR2T]:
+ *
+ * * If LMC()_CONFIG[DDR2T] = 1, (FieldValue + 4) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ *
+ * * If LMC()_CONFIG[DDR2T] = 0, (FieldValue + 3) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ * FieldValue = 0 is always illegal in this case.
  *
- * The hardware-calculated minimums are:
- * min R2R_XDIMM_INIT = 6 + MaxRdSkew MinRdSkew + LMC*_CONTROL[RODT_BPRCH]
- * min R2W_XDIMM_INIT = 9 + (RL + MaxRdSkew) - (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]
- * min W2R_XDIMM_INIT = 6 + MaxWrSkew + LMC*_CONTROL[FPRCH2]
- * min W2W_XDIMM_INIT = 8 + MaxWrSkew - MinWrSkew
- * where
- * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects
- * AL)
- * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)
- * MinRdSkew = min(LMC*_RLEVEL_RANKi[BYTEj]/4)                              (min is across all
- * ranks i (0..3) and bytes j (0..8))
- * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1                          (max is across all
- * ranks i (0..3) and bytes j (0..8))
- * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX]     (min is across all
- * ranks i (0..3) and bytes j (0..8))
- * MaxWrSkew = max(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX] + 1 (max is across all
- * ranks i (0..3) and bytes j (0..8))
- * R2W_XDIMM_INIT has 2 extra CK cycles built in for OCTEON-internal ODT settling/channel
- * turnaround time.
- * R2R_XDIMM_INIT, W2R_XRANK_INIT, W2W_XDIMM_INIT have 1 extra CK cycle built in for channel
- * turnaround time.
+ * The hardware-calculated minimums for these fields are shown in LMC Registers.
  */
 union cvmx_lmcx_slot_ctl2 {
 	uint64_t u64;
@@ -9901,19 +11537,84 @@ union cvmx_lmcx_slot_ctl2 {
 	struct cvmx_lmcx_slot_ctl2_s          cn68xxp1;
 	struct cvmx_lmcx_slot_ctl2_s          cn70xx;
 	struct cvmx_lmcx_slot_ctl2_s          cn70xxp1;
+	struct cvmx_lmcx_slot_ctl2_s          cn73xx;
 	struct cvmx_lmcx_slot_ctl2_s          cn78xx;
 	struct cvmx_lmcx_slot_ctl2_s          cnf71xx;
 };
 typedef union cvmx_lmcx_slot_ctl2 cvmx_lmcx_slot_ctl2_t;
 
 /**
+ * cvmx_lmc#_slot_ctl3
+ *
+ * This register is an assortment of control fields needed by the memory controller. If software
+ * has not previously written to this register (since the last DRESET), hardware updates the
+ * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
+ * Ideally, only read this register after LMC has been initialized and
+ * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
+ *
+ * The interpretation of the fields in this CSR depends on LMC(0)_CONFIG[DDR2T]:
+ *
+ * * If LMC()_CONFIG[DDR2T] = 1, (FieldValue + 4) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ *
+ * * If LMC()_CONFIG[DDR2T] = 0, (FieldValue + 3) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ * FieldValue = 0 is always illegal in this case.
+ *
+ * The hardware-calculated minimums for these fields are shown in LMC Registers.
+ */
+union cvmx_lmcx_slot_ctl3 {
+	uint64_t u64;
+	struct cvmx_lmcx_slot_ctl3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_50_63               : 14;
+	uint64_t w2r_l_xrank_init_ext         : 1;  /**< A 1-bit extension to the W2R_L_XRANK_INIT register. */
+	uint64_t w2r_xrank_init_ext           : 1;  /**< A 1-bit extension to the W2R_XRANK_INIT register. */
+	uint64_t w2w_l_xrank_init             : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
+                                                         accesses to a different logical rank, and same BG for DDR4. */
+	uint64_t w2r_l_xrank_init             : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
+                                                         to a different logical rank, and same BG for DDR4. */
+	uint64_t r2w_l_xrank_init             : 6;  /**< Read-to-write spacing control for back-to-back read followed by write cache block accesses
+                                                         to a different logical rank, and same BG for DDR4. */
+	uint64_t r2r_l_xrank_init             : 6;  /**< Read-to-read spacing control for back-to-back read followed by read cache block accesses
+                                                         to a different logical rank, and same BG for DDR4. */
+	uint64_t w2w_xrank_init               : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
+                                                         accesses to a different logical rank. */
+	uint64_t w2r_xrank_init               : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
+                                                         to a different logical rank. */
+	uint64_t r2w_xrank_init               : 6;  /**< Read-to-write spacing control for back-to-back read followed by write cache block accesses
+                                                         to a different logical rank. */
+	uint64_t r2r_xrank_init               : 6;  /**< Read-to-read spacing control for back-to-back read followed by read cache block accesses
+                                                         to a different logical rank. */
+#else
+	uint64_t r2r_xrank_init               : 6;
+	uint64_t r2w_xrank_init               : 6;
+	uint64_t w2r_xrank_init               : 6;
+	uint64_t w2w_xrank_init               : 6;
+	uint64_t r2r_l_xrank_init             : 6;
+	uint64_t r2w_l_xrank_init             : 6;
+	uint64_t w2r_l_xrank_init             : 6;
+	uint64_t w2w_l_xrank_init             : 6;
+	uint64_t w2r_xrank_init_ext           : 1;
+	uint64_t w2r_l_xrank_init_ext         : 1;
+	uint64_t reserved_50_63               : 14;
+#endif
+	} s;
+	struct cvmx_lmcx_slot_ctl3_s          cn73xx;
+};
+typedef union cvmx_lmcx_slot_ctl3 cvmx_lmcx_slot_ctl3_t;
+
+/**
  * cvmx_lmc#_timing_params0
  */
 union cvmx_lmcx_timing_params0 {
 	uint64_t u64;
 	struct cvmx_lmcx_timing_params0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_54_63               : 10;
+	uint64_t tbcw                         : 6;  /**< Reserved. */
+	uint64_t reserved_26_47               : 22;
 	uint64_t tmrd                         : 4;  /**< Indicates tMRD constraints.
                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,
                                                          where tMRD is from the DDR3 spec, and tCYC(ns)
@@ -9925,7 +11626,9 @@ union cvmx_lmcx_timing_params0 {
 	uint64_t tckeon                       : 8;
 	uint64_t reserved_8_21                : 14;
 	uint64_t tmrd                         : 4;
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_26_47               : 22;
+	uint64_t tbcw                         : 6;
+	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
 	struct cvmx_lmcx_timing_params0_cn61xx {
@@ -10140,7 +11843,82 @@ union cvmx_lmcx_timing_params0 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_timing_params0_cn70xx cn70xxp1;
-	struct cvmx_lmcx_timing_params0_cn70xx cn78xx;
+	struct cvmx_lmcx_timing_params0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_54_63               : 10;
+	uint64_t tbcw                         : 6;  /**< Indicates tBCW constraints. Set this field as follows:
+                                                         _ RNDUP[TBCW(ns) / TCYC(ns)] - 1
+                                                         where TBCW is from the JEDEC DDR4DB spec, and TCYC(ns) is the DDR clock frequency (not
+                                                         data rate).
+                                                         TYP = 16. */
+	uint64_t tcksre                       : 4;  /**< Indicates TCKSRE constraints. Set this field as follows:
+                                                         _ RNDUP[TCKSRE(ns) / TCYC(ns)] - 1
+                                                         where TCKSRE is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(5nCK, 10 ns). */
+	uint64_t trp                          : 5;  /**< Indicates TRP constraints. Set TRP as follows:
+                                                         _ RNDUP[TRP(ns) / TCYC(ns)] - 1
+                                                         where TRP and TRTP are from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency
+                                                         (not data rate).
+                                                         TYP TRP = 10-15ns.
+                                                         TYP TRTP = max(4nCK, 7.5 ns). */
+	uint64_t tzqinit                      : 4;  /**< Indicates TZQINIT constraints. Set this field as follows:
+                                                         _ RNDUP[TZQINIT(ns) / (256 * TCYC(ns))]
+                                                         where TZQINIT is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 2 (equivalent to 512). */
+	uint64_t tdllk                        : 4;  /**< Indicates TDLLK constraints. Set this field as follows:
+                                                         _ RNDUP[TDLLK(ns) / (256 * TCYC(ns))]
+                                                         where TDLLK is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 3 (equivalent to 768).
+                                                         This parameter is used in self-refresh exit and assumed to be greater than TRFC. */
+	uint64_t tmod                         : 5;  /**< Indicates tMOD constraints. Set this field as follows:
+                                                         _ RNDUP[TMOD(ns) / TCYC(ns)] - 1
+                                                         where TMOD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(24nCK, 15 ns). */
+	uint64_t tmrd                         : 4;  /**< Indicates TMRD constraints. Set this field as follows:
+                                                         _ RNDUP[TMRD(ns) / TCYC(ns)] - 1
+                                                         where TMRD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 8nCK. */
+	uint64_t txpr                         : 6;  /**< Indicates TXPR constraints. Set this field as follows:
+                                                         _ RNDUP[TXPR(ns) / (16 * TCYC(ns))]
+                                                         where TXPR is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(5nCK, TRFC+10 ns). */
+	uint64_t tcke                         : 4;  /**< Indicates TCKE constraints. Set this field as follows:
+                                                         _ RNDUP[TCKE(ns) / TCYC(ns)] - 1
+                                                         where TCKE is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(3nCK, 7.5/5.625/5.625/5 ns).
+                                                         Because a DDR4 register can shorten the pulse width of CKE (it delays the falling edge
+                                                         but does not delay the rising edge), care must be taken to set this parameter larger
+                                                         to account for this effective reduction in the pulse width. */
+	uint64_t tzqcs                        : 4;  /**< Indicates TZQCS constraints. This field is set as follows:
+                                                         _ RNDUP[(2 * TZQCS(ns)) / (16 * TCYC(ns))]
+                                                         where TZQCS is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP >= 8 (greater-than-or-equal-to 128), to allow for dclk90 calibration. */
+	uint64_t reserved_0_7                 : 8;
+#else
+	uint64_t reserved_0_7                 : 8;
+	uint64_t tzqcs                        : 4;
+	uint64_t tcke                         : 4;
+	uint64_t txpr                         : 6;
+	uint64_t tmrd                         : 4;
+	uint64_t tmod                         : 5;
+	uint64_t tdllk                        : 4;
+	uint64_t tzqinit                      : 4;
+	uint64_t trp                          : 5;
+	uint64_t tcksre                       : 4;
+	uint64_t tbcw                         : 6;
+	uint64_t reserved_54_63               : 10;
+#endif
+	} cn73xx;
+	struct cvmx_lmcx_timing_params0_cn73xx cn78xx;
 	struct cvmx_lmcx_timing_params0_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_timing_params0 cvmx_lmcx_timing_params0_t;
@@ -10152,7 +11930,12 @@ union cvmx_lmcx_timing_params1 {
 	uint64_t u64;
 	struct cvmx_lmcx_timing_params1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_59_63               : 5;
+	uint64_t txp_ext                      : 1;  /**< Reserved. */
+	uint64_t trcd_ext                     : 1;  /**< Reserved. */
+	uint64_t tpdm_full_cycle_ena          : 1;  /**< Reserved. */
+	uint64_t trfc_dlr                     : 7;  /**< Reserved. */
+	uint64_t reserved_4_48                : 45;
 	uint64_t tmprr                        : 4;  /**< Indicates tMPRR constraints.
                                                          Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,
                                                          where tMPRR is from the DDR3 spec, and tCYC(ns)
@@ -10160,7 +11943,12 @@ union cvmx_lmcx_timing_params1 {
                                                          TYP=1nCK */
 #else
 	uint64_t tmprr                        : 4;
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_4_48                : 45;
+	uint64_t trfc_dlr                     : 7;
+	uint64_t tpdm_full_cycle_ena          : 1;
+	uint64_t trcd_ext                     : 1;
+	uint64_t txp_ext                      : 1;
+	uint64_t reserved_59_63               : 5;
 #endif
 	} s;
 	struct cvmx_lmcx_timing_params1_cn61xx {
@@ -10491,7 +12279,140 @@ union cvmx_lmcx_timing_params1 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_timing_params1_cn70xx cn70xxp1;
-	struct cvmx_lmcx_timing_params1_cn70xx cn78xx;
+	struct cvmx_lmcx_timing_params1_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_59_63               : 5;
+	uint64_t txp_ext                      : 1;  /**< A 1-bit extension to the TXP register. */
+	uint64_t trcd_ext                     : 1;  /**< A 1-bit extension to the TRCD register. */
+	uint64_t tpdm_full_cycle_ena          : 1;  /**< When set, this field enables the addition of one-cycle delay to the
+                                                         Write/Read latency calculation. This is to compensate the case when
+                                                         tPDM delay in the RCD of an RDIMM/LRDIMM is greater than one-cycle.
+                                                         Only valid in RDIMM  (LMC()_CTL[RDIMM_ENA]=1) or LRDIMM
+                                                         (LMC()_CONFIG[LRDIMM_ENA=1) mode. */
+	uint64_t trfc_dlr                     : 7;  /**< Indicates TRFC_DLR constraints. Set this field as follows:
+                                                         _ RNDUP[TRFC_DLR(ns) / (8 * TCYC(ns))]
+                                                         where TRFC_DLR is from the JEDEC 3D Stacked SDRAM spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 90-120 ns.
+                                                         0x0 = reserved.
+                                                         0x1 = 8 TCYC.
+                                                         0x2 = 16 TCYC.
+                                                         0x3 = 24 TCYC.
+                                                         0x4 = 32 TCYC.
+                                                         - ...
+                                                         0x7E = 1008 TCYC.
+                                                         0x7F = 1016 TCYC. */
+	uint64_t txpdll                       : 5;  /**< Indicates TXPDLL constraints. Set this field as follows:
+                                                         _ RNDUP[TXPDLL(ns) / TCYC(ns)] - 1
+                                                         where TXPDLL is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP=max(10nCK, 24 ns) */
+	uint64_t tfaw                         : 5;  /**< Indicates TFAW constraints. Set this field as follows:
+                                                         _ RNDUP[TFAW(ns) / (4 * TCYC(ns))]
+                                                         where TFAW is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 30-40 ns
+                                                         When interfacing with DIMMs that contain 3DS DRAMs, set this field as follows:
+                                                         _ RNDUP[TFAW_SLR(ns) / (4 * TCYC(ns))]
+                                                         where TFAW_SLR is the Four activate window to the same logical rank from the
+                                                         JEDEC DDR4 3D Stacked spec. */
+	uint64_t twldqsen                     : 4;  /**< Indicates TWLDQSEN constraints. Set this field as follows:
+                                                         _ RNDUP[TWLDQSEN(ns) / (4 * TCYC(ns))]
+                                                         where TWLDQSEN is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(25nCK) */
+	uint64_t twlmrd                       : 4;  /**< Indicates TWLMRD constraints. Set this field as follows:
+                                                         _ RNDUP[TWLMRD(ns) / (4 * TCYC(ns))]
+                                                         where TWLMRD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(40nCK) */
+	uint64_t txp                          : 3;  /**< Indicates TXP constraints. Set this field as follows:
+                                                         _ RNDUP[TXP(ns) / TCYC(ns)] - 1
+                                                         where TXP is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP=max(3nCK, 7.5 ns) */
+	uint64_t trrd                         : 3;  /**< Indicates TRRD constraints. Set this field as follows:
+                                                         _ RNDUP[TRRD(ns) / TCYC(ns)] - 1,
+                                                         where TRRD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(4nCK, 10 ns)
+                                                         0x0 = Reserved.
+                                                         0x1 = 2 TCYC.
+                                                         - ...
+                                                         0x6 = 7 TCYC.
+                                                         0x7 = 8 TCYC.
+                                                         For DDR4, this is the TRRD_S parameter. */
+	uint64_t trfc                         : 7;  /**< Indicates TRFC constraints. Set this field as follows:
+                                                         _ RNDUP[TRFC(ns) / (8 * TCYC(ns))]
+                                                         where TRFC is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 90-350 ns
+                                                         0x0 = reserved.
+                                                         0x1 = 8 TCYC.
+                                                         0x2 = 16 TCYC.
+                                                         0x3 = 24 TCYC.
+                                                         0x4 = 32 TCYC.
+                                                         - ...
+                                                         0x7E = 1008 TCYC.
+                                                         0x7F = 1016 TCYC. */
+	uint64_t twtr                         : 4;  /**< Indicates TWTR constraints. Set this field as follows:
+                                                         _ RNDUP[TWTR(ns) / TCYC(ns)] - 1
+                                                         where TWTR is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(4nCK, 7.5 ns)
+                                                         For DDR4, this CSR field represents TWTR_S.
+                                                         0x0 = reserved.
+                                                         0x1 = 2.
+                                                         - ...
+                                                         0x7 = 8.
+                                                         0x8-0xF = reserved. */
+	uint64_t trcd                         : 4;  /**< Indicates TRCD constraints. Set this field as follows:
+                                                         _ RNDUP[TRCD(ns) / TCYC(ns)]
+                                                         where TRCD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 10-15 ns
+                                                         0x0 = reserved.
+                                                         0x1 = 2 (2 is the smallest value allowed).
+                                                         0x2 = 2.
+                                                         - ...
+                                                         0xE = 14.
+                                                         0xA-0xF = reserved.
+                                                         In 2T mode, make this register TRCD - 1, not going below 2. */
+	uint64_t tras                         : 6;  /**< Indicates TRAS constraints. Set TRAS (CSR field) as follows:
+                                                         _ RNDUP[TRAS(ns)/TCYC(ns)] - 1,
+                                                         where TRAS is from the DDR3/DDR4 spec, and TCYC(ns) is the DDR clock frequency (not data
+                                                         rate).
+                                                         TYP = 35ns - 9 * TREFI
+                                                         0x0 = reserved.
+                                                         0x1 = 2 TCYC.
+                                                         - 0010:  3 TCYC.
+                                                         - ...
+                                                         0x3F: 64 TCYC. */
+	uint64_t tmprr                        : 4;  /**< Indicates TMPRR constraints. Set this field as follows:
+                                                         _ RNDUP[TMPRR(ns) / TCYC(ns)] - 1
+                                                         where TMPRR is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 1 nCK */
+#else
+	uint64_t tmprr                        : 4;
+	uint64_t tras                         : 6;
+	uint64_t trcd                         : 4;
+	uint64_t twtr                         : 4;
+	uint64_t trfc                         : 7;
+	uint64_t trrd                         : 3;
+	uint64_t txp                          : 3;
+	uint64_t twlmrd                       : 4;
+	uint64_t twldqsen                     : 4;
+	uint64_t tfaw                         : 5;
+	uint64_t txpdll                       : 5;
+	uint64_t trfc_dlr                     : 7;
+	uint64_t tpdm_full_cycle_ena          : 1;
+	uint64_t trcd_ext                     : 1;
+	uint64_t txp_ext                      : 1;
+	uint64_t reserved_59_63               : 5;
+#endif
+	} cn73xx;
+	struct cvmx_lmcx_timing_params1_cn73xx cn78xx;
 	struct cvmx_lmcx_timing_params1_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_timing_params1 cvmx_lmcx_timing_params1_t;
@@ -10506,7 +12427,8 @@ union cvmx_lmcx_timing_params2 {
 	uint64_t u64;
 	struct cvmx_lmcx_timing_params2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_15_63               : 49;
+	uint64_t reserved_16_63               : 48;
+	uint64_t trrd_l_ext                   : 1;  /**< Reserved. */
 	uint64_t trtp                         : 4;  /**< Specifies the TRTP parameter, in cycles. Set this field as follows:
                                                          _ RNDUP[TRTP(ns) / TCYC(ns)] - 1,
                                                          For DDR3, typical = max(4 nCK, 7.5ns).
@@ -10539,11 +12461,46 @@ union cvmx_lmcx_timing_params2 {
 	uint64_t twtr_l                       : 4;
 	uint64_t t_rw_op_max                  : 4;
 	uint64_t trtp                         : 4;
-	uint64_t reserved_15_63               : 49;
+	uint64_t trrd_l_ext                   : 1;
+	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_lmcx_timing_params2_s     cn70xx;
-	struct cvmx_lmcx_timing_params2_s     cn70xxp1;
+	struct cvmx_lmcx_timing_params2_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t trtp                         : 4;  /**< Specifies the TRTP parameter, in cycles. Set this field as follows:
+                                                         RNDUP[TRTP(ns) / TCYC(ns)] - 1,
+                                                         For DDR3, typical = max(4 nCK, 7.5ns).
+                                                         For DDR4 the TRTP parameter is dictated by the TWR MR bits. */
+	uint64_t t_rw_op_max                  : 4;  /**< Specifies the maximum delay for a read or write operation to complete, used to set the
+                                                         timing of MRW and MPR operations. Set this field as follows:
+                                                         RNDUP[Maximum operation delay (cycles) / 8]
+                                                         Typical = 0x7. */
+	uint64_t twtr_l                       : 4;  /**< Specifies TWTR_L constraints. Set this field as follows:
+                                                         RNDUP[TWTR_L(ns) / TCYC(ns)] - 1
+                                                         where TWTR_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
+                                                         data rate).
+                                                         Typical = MAX(4 nCK, 7.5 ns)
+                                                         INTERNAL: Seems the '- 1' is because we add 1 back into slot timing equation */
+	uint64_t trrd_l                       : 3;  /**< Specifies TRRD_L constraints. Set this field as follows:
+                                                         RNDUP[TRRD_L(ns) / TCYC(ns)] - 1,
+                                                         where TRRD_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
+                                                         data rate).
+                                                         Typical = MAX(4 nCK, 7.5 ns)
+                                                         0x0 = reserved. 0x4 = five TCYC.
+                                                         0x1 = two TCYC. 0x5 = six TCYC.
+                                                         0x2 = three TCYC. 0x6 = seven TCYC.
+                                                         0x3 = four TCYC. 0x7 = eight TCYC. */
+#else
+	uint64_t trrd_l                       : 3;
+	uint64_t twtr_l                       : 4;
+	uint64_t t_rw_op_max                  : 4;
+	uint64_t trtp                         : 4;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_timing_params2_cn70xx cn70xxp1;
+	struct cvmx_lmcx_timing_params2_s     cn73xx;
 	struct cvmx_lmcx_timing_params2_s     cn78xx;
 };
 typedef union cvmx_lmcx_timing_params2 cvmx_lmcx_timing_params2_t;
@@ -10668,6 +12625,7 @@ union cvmx_lmcx_wlevel_ctl {
 	struct cvmx_lmcx_wlevel_ctl_s         cn68xxp1;
 	struct cvmx_lmcx_wlevel_ctl_s         cn70xx;
 	struct cvmx_lmcx_wlevel_ctl_s         cn70xxp1;
+	struct cvmx_lmcx_wlevel_ctl_s         cn73xx;
 	struct cvmx_lmcx_wlevel_ctl_s         cn78xx;
 	struct cvmx_lmcx_wlevel_ctl_s         cnf71xx;
 };
@@ -10714,6 +12672,7 @@ union cvmx_lmcx_wlevel_dbg {
 	struct cvmx_lmcx_wlevel_dbg_s         cn68xxp1;
 	struct cvmx_lmcx_wlevel_dbg_s         cn70xx;
 	struct cvmx_lmcx_wlevel_dbg_s         cn70xxp1;
+	struct cvmx_lmcx_wlevel_dbg_s         cn73xx;
 	struct cvmx_lmcx_wlevel_dbg_s         cn78xx;
 	struct cvmx_lmcx_wlevel_dbg_s         cnf71xx;
 };
@@ -10808,6 +12767,7 @@ union cvmx_lmcx_wlevel_rankx {
 	struct cvmx_lmcx_wlevel_rankx_s       cn68xxp1;
 	struct cvmx_lmcx_wlevel_rankx_s       cn70xx;
 	struct cvmx_lmcx_wlevel_rankx_s       cn70xxp1;
+	struct cvmx_lmcx_wlevel_rankx_s       cn73xx;
 	struct cvmx_lmcx_wlevel_rankx_s       cn78xx;
 	struct cvmx_lmcx_wlevel_rankx_s       cnf71xx;
 };
@@ -11022,6 +12982,7 @@ union cvmx_lmcx_wodt_mask {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_wodt_mask_cn70xx     cn70xxp1;
+	struct cvmx_lmcx_wodt_mask_cn70xx     cn73xx;
 	struct cvmx_lmcx_wodt_mask_cn70xx     cn78xx;
 	struct cvmx_lmcx_wodt_mask_s          cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 74f8e9e..94ab0fa 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -57,7 +57,7 @@
 #define CVMX_MIO_BOOT_COMP CVMX_MIO_BOOT_COMP_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_BOOT_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000000B8ull);
 }
@@ -79,6 +79,7 @@ static inline uint64_t CVMX_MIO_BOOT_CTL_FUNC(void)
 static inline uint64_t CVMX_MIO_BOOT_DMA_ADRX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_ADRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000000110ull) + ((offset) & 1) * 8;
@@ -96,6 +97,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_CFGX(%lu) is invalid on this chip\n", offset);
@@ -114,6 +116,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_INTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_INTX(%lu) is invalid on this chip\n", offset);
@@ -140,6 +143,17 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_INT_ENX(unsigned long offset)
 #define CVMX_MIO_BOOT_DMA_INT_ENX(offset) (CVMX_ADD_IO_SEG(0x0001180000000150ull) + ((offset) & 3) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_MIO_BOOT_DMA_INT_W1SX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_MIO_BOOT_DMA_INT_W1SX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000000150ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_MIO_BOOT_DMA_INT_W1SX(offset) (CVMX_ADD_IO_SEG(0x0001180000000150ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 {
 	if (!(
@@ -149,6 +163,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_TIMX(%lu) is invalid on this chip\n", offset);
@@ -157,6 +172,17 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 #else
 #define CVMX_MIO_BOOT_DMA_TIMX(offset) (CVMX_ADD_IO_SEG(0x0001180000000120ull) + ((offset) & 3) * 8)
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_MIO_BOOT_ECO CVMX_MIO_BOOT_ECO_FUNC()
+static inline uint64_t CVMX_MIO_BOOT_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_MIO_BOOT_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800000001F8ull);
+}
+#else
+#define CVMX_MIO_BOOT_ECO (CVMX_ADD_IO_SEG(0x00011800000001F8ull))
+#endif
 #define CVMX_MIO_BOOT_ERR (CVMX_ADD_IO_SEG(0x00011800000000A0ull))
 #define CVMX_MIO_BOOT_INT (CVMX_ADD_IO_SEG(0x00011800000000A8ull))
 #define CVMX_MIO_BOOT_LOC_ADR (CVMX_ADD_IO_SEG(0x0001180000000090ull))
@@ -176,6 +202,7 @@ static inline uint64_t CVMX_MIO_BOOT_LOC_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_LOC_CFGX(%lu) is invalid on this chip\n", offset);
@@ -189,7 +216,7 @@ static inline uint64_t CVMX_MIO_BOOT_LOC_CFGX(unsigned long offset)
 #define CVMX_MIO_BOOT_PIN_DEFS CVMX_MIO_BOOT_PIN_DEFS_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_PIN_DEFS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_BOOT_PIN_DEFS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000000C0ull);
 }
@@ -212,6 +239,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_MIO_BOOT_REG_CFGX(%lu) is invalid on this chip\n", offset);
@@ -236,6 +264,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_TIMX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_MIO_BOOT_REG_TIMX(%lu) is invalid on this chip\n", offset);
@@ -249,7 +278,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_TIMX(unsigned long offset)
 #define CVMX_MIO_EMM_ACCESS_WDOG CVMX_MIO_EMM_ACCESS_WDOG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_ACCESS_WDOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_ACCESS_WDOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020F0ull);
 }
@@ -260,7 +289,7 @@ static inline uint64_t CVMX_MIO_EMM_ACCESS_WDOG_FUNC(void)
 #define CVMX_MIO_EMM_BUF_DAT CVMX_MIO_EMM_BUF_DAT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_BUF_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_BUF_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020E8ull);
 }
@@ -271,7 +300,7 @@ static inline uint64_t CVMX_MIO_EMM_BUF_DAT_FUNC(void)
 #define CVMX_MIO_EMM_BUF_IDX CVMX_MIO_EMM_BUF_IDX_FUNC()
 static inline uint64_t CVMX_MIO_EMM_BUF_IDX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_BUF_IDX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020E0ull);
 }
@@ -282,7 +311,7 @@ static inline uint64_t CVMX_MIO_EMM_BUF_IDX_FUNC(void)
 #define CVMX_MIO_EMM_CFG CVMX_MIO_EMM_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002000ull);
 }
@@ -293,7 +322,7 @@ static inline uint64_t CVMX_MIO_EMM_CFG_FUNC(void)
 #define CVMX_MIO_EMM_CMD CVMX_MIO_EMM_CMD_FUNC()
 static inline uint64_t CVMX_MIO_EMM_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002058ull);
 }
@@ -304,7 +333,7 @@ static inline uint64_t CVMX_MIO_EMM_CMD_FUNC(void)
 #define CVMX_MIO_EMM_DMA CVMX_MIO_EMM_DMA_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002050ull);
 }
@@ -315,7 +344,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FUNC(void)
 #define CVMX_MIO_EMM_DMA_ADR CVMX_MIO_EMM_DMA_ADR_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000188ull);
 }
@@ -326,7 +355,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_ADR_FUNC(void)
 #define CVMX_MIO_EMM_DMA_CFG CVMX_MIO_EMM_DMA_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000180ull);
 }
@@ -337,7 +366,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_CFG_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_ADR CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000170ull);
 }
@@ -348,7 +377,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_CFG CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000160ull);
 }
@@ -359,7 +388,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_CMD CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000178ull);
 }
@@ -370,7 +399,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT CVMX_MIO_EMM_DMA_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000190ull);
 }
@@ -381,7 +410,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT_W1S CVMX_MIO_EMM_DMA_INT_W1S_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_INT_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000198ull);
 }
@@ -392,7 +421,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
 #define CVMX_MIO_EMM_INT CVMX_MIO_EMM_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002078ull);
 }
@@ -411,11 +440,23 @@ static inline uint64_t CVMX_MIO_EMM_INT_EN_FUNC(void)
 #define CVMX_MIO_EMM_INT_EN (CVMX_ADD_IO_SEG(0x0001180000002080ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_MIO_EMM_INT_W1S CVMX_MIO_EMM_INT_W1S_FUNC()
+static inline uint64_t CVMX_MIO_EMM_INT_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_MIO_EMM_INT_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180000002080ull);
+}
+#else
+#define CVMX_MIO_EMM_INT_W1S (CVMX_ADD_IO_SEG(0x0001180000002080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_EMM_MODEX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_MIO_EMM_MODEX(%lu) is invalid on this chip\n", offset);
@@ -428,7 +469,7 @@ static inline uint64_t CVMX_MIO_EMM_MODEX(unsigned long offset)
 #define CVMX_MIO_EMM_RCA CVMX_MIO_EMM_RCA_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RCA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RCA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020A0ull);
 }
@@ -439,7 +480,7 @@ static inline uint64_t CVMX_MIO_EMM_RCA_FUNC(void)
 #define CVMX_MIO_EMM_RSP_HI CVMX_MIO_EMM_RSP_HI_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002070ull);
 }
@@ -450,7 +491,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_HI_FUNC(void)
 #define CVMX_MIO_EMM_RSP_LO CVMX_MIO_EMM_RSP_LO_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002068ull);
 }
@@ -461,7 +502,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_LO_FUNC(void)
 #define CVMX_MIO_EMM_RSP_STS CVMX_MIO_EMM_RSP_STS_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002060ull);
 }
@@ -472,7 +513,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_STS_FUNC(void)
 #define CVMX_MIO_EMM_SAMPLE CVMX_MIO_EMM_SAMPLE_FUNC()
 static inline uint64_t CVMX_MIO_EMM_SAMPLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_SAMPLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002090ull);
 }
@@ -483,7 +524,7 @@ static inline uint64_t CVMX_MIO_EMM_SAMPLE_FUNC(void)
 #define CVMX_MIO_EMM_STS_MASK CVMX_MIO_EMM_STS_MASK_FUNC()
 static inline uint64_t CVMX_MIO_EMM_STS_MASK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_STS_MASK not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002098ull);
 }
@@ -494,7 +535,7 @@ static inline uint64_t CVMX_MIO_EMM_STS_MASK_FUNC(void)
 #define CVMX_MIO_EMM_SWITCH CVMX_MIO_EMM_SWITCH_FUNC()
 static inline uint64_t CVMX_MIO_EMM_SWITCH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_SWITCH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002048ull);
 }
@@ -505,7 +546,7 @@ static inline uint64_t CVMX_MIO_EMM_SWITCH_FUNC(void)
 #define CVMX_MIO_EMM_WDOG CVMX_MIO_EMM_WDOG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_WDOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_WDOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002088ull);
 }
@@ -525,6 +566,7 @@ static inline uint64_t CVMX_MIO_FUS_BNK_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_FUS_BNK_DATX(%lu) is invalid on this chip\n", offset);
@@ -541,7 +583,7 @@ static inline uint64_t CVMX_MIO_FUS_BNK_DATX(unsigned long offset)
 #define CVMX_MIO_FUS_DAT4 CVMX_MIO_FUS_DAT4_FUNC()
 static inline uint64_t CVMX_MIO_FUS_DAT4_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_DAT4 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001420ull);
 }
@@ -563,7 +605,7 @@ static inline uint64_t CVMX_MIO_FUS_EMA_FUNC(void)
 #define CVMX_MIO_FUS_INT CVMX_MIO_FUS_INT_FUNC()
 static inline uint64_t CVMX_MIO_FUS_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001548ull);
 }
@@ -588,6 +630,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 			break;
 	}
@@ -611,6 +654,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001180000001420ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001420ull);
@@ -620,7 +664,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 #define CVMX_MIO_FUS_PLL CVMX_MIO_FUS_PLL_FUNC()
 static inline uint64_t CVMX_MIO_FUS_PLL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_PLL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001580ull);
 }
@@ -632,7 +676,7 @@ static inline uint64_t CVMX_MIO_FUS_PLL_FUNC(void)
 #define CVMX_MIO_FUS_PROG_TIMES CVMX_MIO_FUS_PROG_TIMES_FUNC()
 static inline uint64_t CVMX_MIO_FUS_PROG_TIMES_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_PROG_TIMES not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001518ull);
 }
@@ -644,7 +688,7 @@ static inline uint64_t CVMX_MIO_FUS_PROG_TIMES_FUNC(void)
 #define CVMX_MIO_FUS_READ_TIMES CVMX_MIO_FUS_READ_TIMES_FUNC()
 static inline uint64_t CVMX_MIO_FUS_READ_TIMES_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_READ_TIMES not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001570ull);
 }
@@ -689,6 +733,7 @@ static inline uint64_t CVMX_MIO_FUS_RPR_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_FUS_RPR_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001530ull) + ((offset) & 1) * 8;
@@ -700,7 +745,7 @@ static inline uint64_t CVMX_MIO_FUS_RPR_DATX(unsigned long offset)
 #define CVMX_MIO_FUS_SOFT_REPAIR CVMX_MIO_FUS_SOFT_REPAIR_FUNC()
 static inline uint64_t CVMX_MIO_FUS_SOFT_REPAIR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_SOFT_REPAIR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001540ull);
 }
@@ -714,15 +759,16 @@ static inline uint64_t CVMX_MIO_FUS_SOFT_REPAIR_FUNC(void)
 static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
-			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
+			break;
 	}
 	cvmx_warn("CVMX_MIO_FUS_TGG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001428ull);
@@ -732,13 +778,14 @@ static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 }
@@ -825,7 +872,7 @@ static inline uint64_t CVMX_MIO_PLL_SETTING_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_HI_INCR CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_HI_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F40ull);
 }
@@ -836,7 +883,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_LO_INCR CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_LO_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F48ull);
 }
@@ -847,7 +894,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_THRESH_HI CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_THRESH_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F38ull);
 }
@@ -858,7 +905,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_THRESH_LO CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_THRESH_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F30ull);
 }
@@ -869,7 +916,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_CFG CVMX_MIO_PTP_CLOCK_CFG_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F00ull);
 }
@@ -880,7 +927,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_CFG_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_COMP CVMX_MIO_PTP_CLOCK_COMP_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F18ull);
 }
@@ -891,7 +938,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_COMP_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_HI CVMX_MIO_PTP_CLOCK_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F10ull);
 }
@@ -902,7 +949,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_HI_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_LO CVMX_MIO_PTP_CLOCK_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F08ull);
 }
@@ -913,7 +960,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_LO_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_ERR_INT CVMX_MIO_PTP_DPLL_ERR_INT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F90ull);
 }
@@ -924,7 +971,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_INT_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_ERR_THRESH CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_ERR_THRESH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F88ull);
 }
@@ -935,7 +982,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_INCR CVMX_MIO_PTP_DPLL_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F80ull);
 }
@@ -946,7 +993,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_INCR_FUNC(void)
 #define CVMX_MIO_PTP_EVT_CNT CVMX_MIO_PTP_EVT_CNT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_EVT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_EVT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F28ull);
 }
@@ -957,7 +1004,7 @@ static inline uint64_t CVMX_MIO_PTP_EVT_CNT_FUNC(void)
 #define CVMX_MIO_PTP_EVT_INT CVMX_MIO_PTP_EVT_INT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_EVT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_EVT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F70ull);
 }
@@ -979,7 +1026,7 @@ static inline uint64_t CVMX_MIO_PTP_PHY_1PPS_IN_FUNC(void)
 #define CVMX_MIO_PTP_PPS_HI_INCR CVMX_MIO_PTP_PPS_HI_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_HI_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_HI_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F60ull);
 }
@@ -990,7 +1037,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_HI_INCR_FUNC(void)
 #define CVMX_MIO_PTP_PPS_LO_INCR CVMX_MIO_PTP_PPS_LO_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_LO_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_LO_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F68ull);
 }
@@ -1001,7 +1048,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_LO_INCR_FUNC(void)
 #define CVMX_MIO_PTP_PPS_THRESH_HI CVMX_MIO_PTP_PPS_THRESH_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_THRESH_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F58ull);
 }
@@ -1012,7 +1059,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_HI_FUNC(void)
 #define CVMX_MIO_PTP_PPS_THRESH_LO CVMX_MIO_PTP_PPS_THRESH_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_THRESH_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F50ull);
 }
@@ -1023,7 +1070,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_LO_FUNC(void)
 #define CVMX_MIO_PTP_TIMESTAMP CVMX_MIO_PTP_TIMESTAMP_FUNC()
 static inline uint64_t CVMX_MIO_PTP_TIMESTAMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_TIMESTAMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F20ull);
 }
@@ -1155,6 +1202,7 @@ static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_INT(%lu) is invalid on this chip\n", offset);
@@ -1164,6 +1212,17 @@ static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 #define CVMX_MIO_TWSX_INT(offset) (CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 1) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_MIO_TWSX_INT_W1S(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_MIO_TWSX_INT_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512;
+}
+#else
+#define CVMX_MIO_TWSX_INT_W1S(offset) (CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
 {
 	if (!(
@@ -1179,6 +1238,7 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_SW_TWSI(%lu) is invalid on this chip\n", offset);
@@ -1203,6 +1263,7 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI_EXT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_SW_TWSI_EXT(%lu) is invalid on this chip\n", offset);
@@ -1227,6 +1288,7 @@ static inline uint64_t CVMX_MIO_TWSX_TWSI_SW(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_TWSI_SW(%lu) is invalid on this chip\n", offset);
@@ -1526,6 +1588,7 @@ static inline uint64_t CVMX_MIO_UARTX_DLH(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_DLH(%lu) is invalid on this chip\n", offset);
@@ -1550,6 +1613,7 @@ static inline uint64_t CVMX_MIO_UARTX_DLL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_DLL(%lu) is invalid on this chip\n", offset);
@@ -1574,6 +1638,7 @@ static inline uint64_t CVMX_MIO_UARTX_FAR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_FAR(%lu) is invalid on this chip\n", offset);
@@ -1598,6 +1663,7 @@ static inline uint64_t CVMX_MIO_UARTX_FCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_FCR(%lu) is invalid on this chip\n", offset);
@@ -1622,6 +1688,7 @@ static inline uint64_t CVMX_MIO_UARTX_HTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_HTX(%lu) is invalid on this chip\n", offset);
@@ -1646,6 +1713,7 @@ static inline uint64_t CVMX_MIO_UARTX_IER(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_IER(%lu) is invalid on this chip\n", offset);
@@ -1670,6 +1738,7 @@ static inline uint64_t CVMX_MIO_UARTX_IIR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_IIR(%lu) is invalid on this chip\n", offset);
@@ -1694,6 +1763,7 @@ static inline uint64_t CVMX_MIO_UARTX_LCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_LCR(%lu) is invalid on this chip\n", offset);
@@ -1718,6 +1788,7 @@ static inline uint64_t CVMX_MIO_UARTX_LSR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_LSR(%lu) is invalid on this chip\n", offset);
@@ -1742,6 +1813,7 @@ static inline uint64_t CVMX_MIO_UARTX_MCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_MCR(%lu) is invalid on this chip\n", offset);
@@ -1766,6 +1838,7 @@ static inline uint64_t CVMX_MIO_UARTX_MSR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_MSR(%lu) is invalid on this chip\n", offset);
@@ -1790,6 +1863,7 @@ static inline uint64_t CVMX_MIO_UARTX_RBR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RBR(%lu) is invalid on this chip\n", offset);
@@ -1814,6 +1888,7 @@ static inline uint64_t CVMX_MIO_UARTX_RFL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RFL(%lu) is invalid on this chip\n", offset);
@@ -1838,6 +1913,7 @@ static inline uint64_t CVMX_MIO_UARTX_RFW(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RFW(%lu) is invalid on this chip\n", offset);
@@ -1862,6 +1938,7 @@ static inline uint64_t CVMX_MIO_UARTX_SBCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SBCR(%lu) is invalid on this chip\n", offset);
@@ -1886,6 +1963,7 @@ static inline uint64_t CVMX_MIO_UARTX_SCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SCR(%lu) is invalid on this chip\n", offset);
@@ -1910,6 +1988,7 @@ static inline uint64_t CVMX_MIO_UARTX_SFE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SFE(%lu) is invalid on this chip\n", offset);
@@ -1934,6 +2013,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRR(%lu) is invalid on this chip\n", offset);
@@ -1958,6 +2038,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRT(%lu) is invalid on this chip\n", offset);
@@ -1982,6 +2063,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRTS(%lu) is invalid on this chip\n", offset);
@@ -2006,6 +2088,7 @@ static inline uint64_t CVMX_MIO_UARTX_STT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_STT(%lu) is invalid on this chip\n", offset);
@@ -2030,6 +2113,7 @@ static inline uint64_t CVMX_MIO_UARTX_TFL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_TFL(%lu) is invalid on this chip\n", offset);
@@ -2054,6 +2138,7 @@ static inline uint64_t CVMX_MIO_UARTX_TFR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_TFR(%lu) is invalid on this chip\n", offset);
@@ -2078,6 +2163,7 @@ static inline uint64_t CVMX_MIO_UARTX_THR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_THR(%lu) is invalid on this chip\n", offset);
@@ -2102,6 +2188,7 @@ static inline uint64_t CVMX_MIO_UARTX_USR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_USR(%lu) is invalid on this chip\n", offset);
@@ -2251,6 +2338,41 @@ union cvmx_mio_boot_bist_stat {
 #endif
 	} cn70xx;
 	struct cvmx_mio_boot_bist_stat_cn70xx cn70xxp1;
+	struct cvmx_mio_boot_bist_stat_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t stat                         : 15; /**< BIST status.
+                                                         INTERNAL:
+                                                           <0>  = mio.mio_boot.boot_fifo.mem.
+                                                           <1>  = mio.mio_boot.mio_boot_emm.mem.
+                                                           <2>  = mio.mio_boot.mio_boot_mem2.mem.
+                                                           <3>  = mio.mio_boot.boot_loc.mem.
+                                                           <4>  = mio.mio_boot.dma_fifo.mem.
+                                                           <5>  = mio.mio_nbt.mio_nbt_fifo.mem.
+                                                           <6>  = mio.mio_emm.bufs.mem.mem.
+                                                           <7>  = mio_boot_rom/mio_boot_rom1 (bootroms).
+                                                           <8>  = mio.csr.csr_fifo.mem.
+                                                           <9>  = mio.mii.mix0.mix_agi.ipwreq.ipf_mem.
+                                                                = mix_agi.irf.irf0_dat.
+                                                                = mix_agi.ipwreq.mio_mix_agi_merge.mrg_mem.
+                                                                = mix_ago.oprsp.opf_mem.
+                                                                = mix_ago.orf.ago_orf.
+                                                                = mix_nbr.mrq_mem.
+                                                           <10> = mio.mii.mix1.mix_agi.ipwreq.ipf_mem.
+                                                                = mix_agi.irf.irf0_dat.
+                                                                = mix_agi.ipwreq.mio_mix_agi_merge.mrg_mem.
+                                                                = mix_ago.oprsp.opf_mem.
+                                                                = mix_ago.orf.ago_orf.
+                                                                = mix_nbr.mrq_mem.
+                                                           <11> = mio.mio_nbr.ncbo_crd_fif_mem0.
+                                                           <12> = mio.mio_ndf.mio_ndf_bufs.ndf_buf.
+                                                           <13> = mio.mio_ndf.ndf_ncb_rcv_fif.
+                                                           <14> = mio.mpi.mpi_fifo.mem. */
+#else
+	uint64_t stat                         : 15;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} cn73xx;
 	struct cvmx_mio_boot_bist_stat_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
@@ -2333,6 +2455,7 @@ union cvmx_mio_boot_comp {
 #endif
 	} cn70xx;
 	struct cvmx_mio_boot_comp_cn70xx      cn70xxp1;
+	struct cvmx_mio_boot_comp_cn70xx      cn73xx;
 	struct cvmx_mio_boot_comp_cn70xx      cn78xx;
 	struct cvmx_mio_boot_comp_cn61xx      cnf71xx;
 };
@@ -2394,6 +2517,7 @@ union cvmx_mio_boot_dma_adrx {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_mio_boot_dma_adrx_s       cn73xx;
 	struct cvmx_mio_boot_dma_adrx_s       cn78xx;
 };
 typedef union cvmx_mio_boot_dma_adrx cvmx_mio_boot_dma_adrx_t;
@@ -2449,7 +2573,7 @@ union cvmx_mio_boot_dma_cfgx {
 	struct cvmx_mio_boot_dma_cfgx_s       cn66xx;
 	struct cvmx_mio_boot_dma_cfgx_s       cn68xx;
 	struct cvmx_mio_boot_dma_cfgx_s       cn68xxp1;
-	struct cvmx_mio_boot_dma_cfgx_cn78xx {
+	struct cvmx_mio_boot_dma_cfgx_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t en                           : 1;  /**< DMA engine 0-1 enable. */
 	uint64_t rw                           : 1;  /**< DMA engine 0-1 R/W bit (0 = read, 1 = write). */
@@ -2479,7 +2603,8 @@ union cvmx_mio_boot_dma_cfgx {
 	uint64_t rw                           : 1;
 	uint64_t en                           : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mio_boot_dma_cfgx_cn73xx  cn78xx;
 	struct cvmx_mio_boot_dma_cfgx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_dma_cfgx cvmx_mio_boot_dma_cfgx_t;
@@ -2513,6 +2638,7 @@ union cvmx_mio_boot_dma_intx {
 	struct cvmx_mio_boot_dma_intx_s       cn66xx;
 	struct cvmx_mio_boot_dma_intx_s       cn68xx;
 	struct cvmx_mio_boot_dma_intx_s       cn68xxp1;
+	struct cvmx_mio_boot_dma_intx_s       cn73xx;
 	struct cvmx_mio_boot_dma_intx_s       cn78xx;
 	struct cvmx_mio_boot_dma_intx_s       cnf71xx;
 };
@@ -2552,6 +2678,29 @@ union cvmx_mio_boot_dma_int_enx {
 typedef union cvmx_mio_boot_dma_int_enx cvmx_mio_boot_dma_int_enx_t;
 
 /**
+ * cvmx_mio_boot_dma_int_w1s#
+ *
+ * This register sets MIO_BOOT_DMA_INT() interrupts.
+ *
+ */
+union cvmx_mio_boot_dma_int_w1sx {
+	uint64_t u64;
+	struct cvmx_mio_boot_dma_int_w1sx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t dmarq                        : 1;  /**< Reads MIO_BOOT_DMA_INT()[DMARQ]. */
+	uint64_t done                         : 1;  /**< Reads or sets MIO_BOOT_DMA_INT()[DONE]. */
+#else
+	uint64_t done                         : 1;
+	uint64_t dmarq                        : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_mio_boot_dma_int_w1sx_s   cn73xx;
+};
+typedef union cvmx_mio_boot_dma_int_w1sx cvmx_mio_boot_dma_int_w1sx_t;
+
+/**
  * cvmx_mio_boot_dma_tim#
  *
  * This is the DMA engine n timing register (one register for each of two engines).
@@ -2604,12 +2753,31 @@ union cvmx_mio_boot_dma_timx {
 	struct cvmx_mio_boot_dma_timx_s       cn66xx;
 	struct cvmx_mio_boot_dma_timx_s       cn68xx;
 	struct cvmx_mio_boot_dma_timx_s       cn68xxp1;
+	struct cvmx_mio_boot_dma_timx_s       cn73xx;
 	struct cvmx_mio_boot_dma_timx_s       cn78xx;
 	struct cvmx_mio_boot_dma_timx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_dma_timx cvmx_mio_boot_dma_timx_t;
 
 /**
+ * cvmx_mio_boot_eco
+ */
+union cvmx_mio_boot_eco {
+	uint64_t u64;
+	struct cvmx_mio_boot_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< ECO flops. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_mio_boot_eco_s            cn73xx;
+};
+typedef union cvmx_mio_boot_eco cvmx_mio_boot_eco_t;
+
+/**
  * cvmx_mio_boot_err
  *
  * The boot-error register contains the address decode error and wait mode error bits.
@@ -2647,6 +2815,7 @@ union cvmx_mio_boot_err {
 	struct cvmx_mio_boot_err_s            cn68xxp1;
 	struct cvmx_mio_boot_err_s            cn70xx;
 	struct cvmx_mio_boot_err_s            cn70xxp1;
+	struct cvmx_mio_boot_err_s            cn73xx;
 	struct cvmx_mio_boot_err_s            cn78xx;
 	struct cvmx_mio_boot_err_s            cnf71xx;
 };
@@ -2737,6 +2906,7 @@ union cvmx_mio_boot_loc_adr {
 	struct cvmx_mio_boot_loc_adr_s        cn68xxp1;
 	struct cvmx_mio_boot_loc_adr_s        cn70xx;
 	struct cvmx_mio_boot_loc_adr_s        cn70xxp1;
+	struct cvmx_mio_boot_loc_adr_s        cn73xx;
 	struct cvmx_mio_boot_loc_adr_s        cn78xx;
 	struct cvmx_mio_boot_loc_adr_s        cnf71xx;
 };
@@ -2785,6 +2955,7 @@ union cvmx_mio_boot_loc_cfgx {
 	struct cvmx_mio_boot_loc_cfgx_s       cn68xxp1;
 	struct cvmx_mio_boot_loc_cfgx_s       cn70xx;
 	struct cvmx_mio_boot_loc_cfgx_s       cn70xxp1;
+	struct cvmx_mio_boot_loc_cfgx_s       cn73xx;
 	struct cvmx_mio_boot_loc_cfgx_s       cn78xx;
 	struct cvmx_mio_boot_loc_cfgx_s       cnf71xx;
 };
@@ -2824,6 +2995,7 @@ union cvmx_mio_boot_loc_dat {
 	struct cvmx_mio_boot_loc_dat_s        cn68xxp1;
 	struct cvmx_mio_boot_loc_dat_s        cn70xx;
 	struct cvmx_mio_boot_loc_dat_s        cn70xxp1;
+	struct cvmx_mio_boot_loc_dat_s        cn73xx;
 	struct cvmx_mio_boot_loc_dat_s        cn78xx;
 	struct cvmx_mio_boot_loc_dat_s        cnf71xx;
 };
@@ -2963,6 +3135,66 @@ union cvmx_mio_boot_pin_defs {
 #endif
 	} cn70xx;
 	struct cvmx_mio_boot_pin_defs_cn70xx  cn70xxp1;
+	struct cvmx_mio_boot_pin_defs_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_56_63               : 8;
+	uint64_t rgm_supply                   : 2;  /**< RGMii power supply setting based on VDD_RGM_SUPPLY_SELECT pin:
+                                                         0x1 = 1.8V.
+                                                         0x2 = 2.5V.
+                                                         else Reserved. */
+	uint64_t smi_supply                   : 3;  /**< SMI power supply setting based on VDD_SMI_SUPPLY_SELECT pin:
+                                                         0x1 = 1.8V.
+                                                         0x2 = 2.5V.
+                                                         0x8 = 3.3V.
+                                                         else Reserved. */
+	uint64_t io_supply                    : 3;  /**< I/O power supply setting based on VDD_IO_SUPPLY_SELECT pin:
+                                                         0x1 = 1.8V.
+                                                         0x2 = 2.5V.
+                                                         0x8 = 3.3V.
+                                                         else Reserved. */
+	uint64_t reserved_33_47               : 15;
+	uint64_t vrm_disable                  : 1;  /**< VRM disabled. */
+	uint64_t user1                        : 13; /**< BOOT_AD<31:19> latched during power up. */
+	uint64_t device                       : 3;  /**< BOOT_AD<18:16> latched during power up. Indicates boot device:
+                                                         0x0 = Parallel NOR.
+                                                         0x1 = Reserved.
+                                                         0x2 = eMMC/SD.
+                                                         0x3 = Reserved.
+                                                         0x4 = SPI Boot (16-bit address).
+                                                         0x5 = SPI Boot (24-bit address).
+                                                         0x6 = SPI Boot (32-bit address).
+                                                         0x7 = Reserved. */
+	uint64_t ale                          : 1;  /**< Region 0 default ALE mode. */
+	uint64_t width                        : 1;  /**< Region 0 default bus width. */
+	uint64_t pcie2_dlm5                   : 1;  /**< PCIe2 QLM/DLM Selection at powerup:
+                                                         0 = PCIe2 is mapped to QLM2 (default).
+                                                         1 = PCIe2 is mapped to DLM5. */
+	uint64_t dmack_p1                     : 1;  /**< BOOT_DMACK<1> default polarity. */
+	uint64_t dmack_p0                     : 1;  /**< BOOT_DMACK<0> default polarity. */
+	uint64_t term                         : 2;  /**< Selects default boot-bus driver termination.
+                                                         0x0 = full strength.
+                                                         0x1 = 25ohm.
+                                                         0x2 = 50ohm.
+                                                         0x3 = 65ohm. */
+	uint64_t user0                        : 9;  /**< BOOT_AD<8:0> latched during power up. */
+#else
+	uint64_t user0                        : 9;
+	uint64_t term                         : 2;
+	uint64_t dmack_p0                     : 1;
+	uint64_t dmack_p1                     : 1;
+	uint64_t pcie2_dlm5                   : 1;
+	uint64_t width                        : 1;
+	uint64_t ale                          : 1;
+	uint64_t device                       : 3;
+	uint64_t user1                        : 13;
+	uint64_t vrm_disable                  : 1;
+	uint64_t reserved_33_47               : 15;
+	uint64_t io_supply                    : 3;
+	uint64_t smi_supply                   : 3;
+	uint64_t rgm_supply                   : 2;
+	uint64_t reserved_56_63               : 8;
+#endif
+	} cn73xx;
 	struct cvmx_mio_boot_pin_defs_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
@@ -3146,6 +3378,7 @@ union cvmx_mio_boot_reg_cfgx {
 	struct cvmx_mio_boot_reg_cfgx_s       cn68xxp1;
 	struct cvmx_mio_boot_reg_cfgx_s       cn70xx;
 	struct cvmx_mio_boot_reg_cfgx_s       cn70xxp1;
+	struct cvmx_mio_boot_reg_cfgx_s       cn73xx;
 	struct cvmx_mio_boot_reg_cfgx_s       cn78xx;
 	struct cvmx_mio_boot_reg_cfgx_s       cnf71xx;
 };
@@ -3239,6 +3472,7 @@ union cvmx_mio_boot_reg_timx {
 	struct cvmx_mio_boot_reg_timx_s       cn68xxp1;
 	struct cvmx_mio_boot_reg_timx_s       cn70xx;
 	struct cvmx_mio_boot_reg_timx_s       cn70xxp1;
+	struct cvmx_mio_boot_reg_timx_s       cn73xx;
 	struct cvmx_mio_boot_reg_timx_s       cn78xx;
 	struct cvmx_mio_boot_reg_timx_s       cnf71xx;
 };
@@ -3300,6 +3534,7 @@ union cvmx_mio_boot_thr {
 	struct cvmx_mio_boot_thr_s            cn68xxp1;
 	struct cvmx_mio_boot_thr_s            cn70xx;
 	struct cvmx_mio_boot_thr_s            cn70xxp1;
+	struct cvmx_mio_boot_thr_s            cn73xx;
 	struct cvmx_mio_boot_thr_s            cn78xx;
 	struct cvmx_mio_boot_thr_s            cnf71xx;
 };
@@ -3322,6 +3557,7 @@ union cvmx_mio_emm_access_wdog {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_mio_emm_access_wdog_s     cn73xx;
 	struct cvmx_mio_emm_access_wdog_s     cn78xx;
 };
 typedef union cvmx_mio_emm_access_wdog cvmx_mio_emm_access_wdog_t;
@@ -3345,6 +3581,7 @@ union cvmx_mio_emm_buf_dat {
 	struct cvmx_mio_emm_buf_dat_s         cn61xx;
 	struct cvmx_mio_emm_buf_dat_s         cn70xx;
 	struct cvmx_mio_emm_buf_dat_s         cn70xxp1;
+	struct cvmx_mio_emm_buf_dat_s         cn73xx;
 	struct cvmx_mio_emm_buf_dat_s         cn78xx;
 	struct cvmx_mio_emm_buf_dat_s         cnf71xx;
 };
@@ -3378,6 +3615,7 @@ union cvmx_mio_emm_buf_idx {
 	struct cvmx_mio_emm_buf_idx_s         cn61xx;
 	struct cvmx_mio_emm_buf_idx_s         cn70xx;
 	struct cvmx_mio_emm_buf_idx_s         cn70xxp1;
+	struct cvmx_mio_emm_buf_idx_s         cn73xx;
 	struct cvmx_mio_emm_buf_idx_s         cn78xx;
 	struct cvmx_mio_emm_buf_idx_s         cnf71xx;
 };
@@ -3429,6 +3667,7 @@ union cvmx_mio_emm_cfg {
 	struct cvmx_mio_emm_cfg_s             cn61xx;
 	struct cvmx_mio_emm_cfg_s             cn70xx;
 	struct cvmx_mio_emm_cfg_s             cn70xxp1;
+	struct cvmx_mio_emm_cfg_s             cn73xx;
 	struct cvmx_mio_emm_cfg_s             cn78xx;
 	struct cvmx_mio_emm_cfg_s             cnf71xx;
 };
@@ -3537,6 +3776,7 @@ union cvmx_mio_emm_cmd {
 	} cn61xx;
 	struct cvmx_mio_emm_cmd_cn61xx        cn70xx;
 	struct cvmx_mio_emm_cmd_cn61xx        cn70xxp1;
+	struct cvmx_mio_emm_cmd_s             cn73xx;
 	struct cvmx_mio_emm_cmd_s             cn78xx;
 	struct cvmx_mio_emm_cmd_cn61xx        cnf71xx;
 };
@@ -3637,6 +3877,7 @@ union cvmx_mio_emm_dma {
 	} cn61xx;
 	struct cvmx_mio_emm_dma_cn61xx        cn70xx;
 	struct cvmx_mio_emm_dma_cn61xx        cn70xxp1;
+	struct cvmx_mio_emm_dma_s             cn73xx;
 	struct cvmx_mio_emm_dma_s             cn78xx;
 	struct cvmx_mio_emm_dma_cn61xx        cnf71xx;
 };
@@ -3646,7 +3887,8 @@ typedef union cvmx_mio_emm_dma cvmx_mio_emm_dma_t;
  * cvmx_mio_emm_dma_adr
  *
  * This register sets the address for eMMC/SD flash transfers to/from memory. Sixty-four-bit
- * operations must be used to access this register.
+ * operations must be used to access this register.  This register is updated by the dma
+ * hardware and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
  */
 union cvmx_mio_emm_dma_adr {
 	uint64_t u64;
@@ -3659,6 +3901,7 @@ union cvmx_mio_emm_dma_adr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_adr_s         cn73xx;
 	struct cvmx_mio_emm_dma_adr_s         cn78xx;
 };
 typedef union cvmx_mio_emm_dma_adr cvmx_mio_emm_dma_adr_t;
@@ -3667,7 +3910,8 @@ typedef union cvmx_mio_emm_dma_adr cvmx_mio_emm_dma_adr_t;
  * cvmx_mio_emm_dma_cfg
  *
  * This register controls the internal DMA engine used with the eMMC/SD flash controller. Sixty-
- * four-bit operations must be used to access this register.
+ * four-bit operations must be used to access this register.  This register is updated by the
+ * hardware dma engine and can also be reloaded by writes to the MIO_EMM_DMA_FIFO_CMD register.
  */
 union cvmx_mio_emm_dma_cfg {
 	uint64_t u64;
@@ -3697,6 +3941,7 @@ union cvmx_mio_emm_dma_cfg {
 	uint64_t en                           : 1;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_cfg_s         cn73xx;
 	struct cvmx_mio_emm_dma_cfg_s         cn78xx;
 };
 typedef union cvmx_mio_emm_dma_cfg cvmx_mio_emm_dma_cfg_t;
@@ -3721,6 +3966,7 @@ union cvmx_mio_emm_dma_fifo_adr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_fifo_adr_s    cn73xx;
 	struct cvmx_mio_emm_dma_fifo_adr_s    cn78xx;
 };
 typedef union cvmx_mio_emm_dma_fifo_adr cvmx_mio_emm_dma_fifo_adr_t;
@@ -3755,6 +4001,7 @@ union cvmx_mio_emm_dma_fifo_cfg {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_fifo_cfg_s    cn73xx;
 	struct cvmx_mio_emm_dma_fifo_cfg_s    cn78xx;
 };
 typedef union cvmx_mio_emm_dma_fifo_cfg cvmx_mio_emm_dma_fifo_cfg_t;
@@ -3777,6 +4024,40 @@ union cvmx_mio_emm_dma_fifo_cmd {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_63_63               : 1;
 	uint64_t rw                           : 1;  /**< DMA engine R/W bit: 0 = read, 1 = write. */
+	uint64_t reserved_61_61               : 1;
+	uint64_t intdis                       : 1;  /**< DMA command interrupt disable.  When set, the dma command being summitted will
+                                                         not enerate a MIO_EMM_DMA_INT[DONE] interrupt when it completes.  When cleared
+                                                         the command will generate the interrupt.
+                                                         For example, this field can be set for all the DMA commands submitted to the
+                                                         DMA FIFO in the case of a write to the eMMC device because the MIO_EMM_INT[DONE]
+                                                         interrupt would signify the end of the operation.  It could be cleared on the last
+                                                         dma command being submitted to the DMA FIFO and the MIO_EMM_DMA_INT[DONE] would
+                                                         occur when the read from the eMMC device was available in lcal emory. */
+	uint64_t swap32                       : 1;  /**< DMA engine 32-bit swap. */
+	uint64_t swap16                       : 1;  /**< DMA engine enable 16-bit swap. */
+	uint64_t swap8                        : 1;  /**< DMA engine enable 8-bit swap. */
+	uint64_t endian                       : 1;  /**< DMA engine endian mode: 0 = big-endian, 1 = little-endian. */
+	uint64_t size                         : 20; /**< DMA engine size. Specified in the number of 64-bit transfers (encoded in -1 notation). For
+                                                         example, to transfer 512 bytes, SIZE = 64 - 1 = 63. */
+	uint64_t reserved_0_35                : 36;
+#else
+	uint64_t reserved_0_35                : 36;
+	uint64_t size                         : 20;
+	uint64_t endian                       : 1;
+	uint64_t swap8                        : 1;
+	uint64_t swap16                       : 1;
+	uint64_t swap32                       : 1;
+	uint64_t intdis                       : 1;
+	uint64_t reserved_61_61               : 1;
+	uint64_t rw                           : 1;
+	uint64_t reserved_63_63               : 1;
+#endif
+	} s;
+	struct cvmx_mio_emm_dma_fifo_cmd_s    cn73xx;
+	struct cvmx_mio_emm_dma_fifo_cmd_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_63_63               : 1;
+	uint64_t rw                           : 1;  /**< DMA engine R/W bit: 0 = read, 1 = write. */
 	uint64_t reserved_60_61               : 2;
 	uint64_t swap32                       : 1;  /**< DMA engine 32-bit swap. */
 	uint64_t swap16                       : 1;  /**< DMA engine enable 16-bit swap. */
@@ -3796,8 +4077,7 @@ union cvmx_mio_emm_dma_fifo_cmd {
 	uint64_t rw                           : 1;
 	uint64_t reserved_63_63               : 1;
 #endif
-	} s;
-	struct cvmx_mio_emm_dma_fifo_cmd_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_mio_emm_dma_fifo_cmd cvmx_mio_emm_dma_fifo_cmd_t;
 
@@ -3812,8 +4092,7 @@ union cvmx_mio_emm_dma_int {
 	struct cvmx_mio_emm_dma_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t fifo                         : 1;  /**< INIERNAL Set as reserved in HRM
-                                                         Internal DMA FIFO has dropped to level specified by MIO_EMM_DMA_FIFO_CFG[INT_LVL]. Throws
+	uint64_t fifo                         : 1;  /**< Internal DMA FIFO has dropped to level specified by MIO_EMM_DMA_FIFO_CFG[INT_LVL]. Throws
                                                          MIO_EMM_INTSN_E::MIO_EMM_DMA_FIFO. */
 	uint64_t done                         : 1;  /**< Internal DMA engine request completion interrupt. Throws
                                                          MIO_EMM_INTSN_E::MIO_EMM_DMA_DONE. */
@@ -3823,6 +4102,7 @@ union cvmx_mio_emm_dma_int {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_int_s         cn73xx;
 	struct cvmx_mio_emm_dma_int_s         cn78xx;
 };
 typedef union cvmx_mio_emm_dma_int cvmx_mio_emm_dma_int_t;
@@ -3835,8 +4115,7 @@ union cvmx_mio_emm_dma_int_w1s {
 	struct cvmx_mio_emm_dma_int_w1s_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t fifo                         : 1;  /**< INIERNAL Set as reserved in HRM
-                                                         Internal DMA FIFO has dropped to level specified by MIO_EMM_DMA_FIFO_CFG[INT_LVL]. Throws
+	uint64_t fifo                         : 1;  /**< Internal DMA FIFO has dropped to level specified by MIO_EMM_DMA_FIFO_CFG[INT_LVL]. Throws
                                                          MIO_EMM_INTSN_E::MIO_EMM_DMA_FIFO. */
 	uint64_t done                         : 1;  /**< Internal DMA engine request completion interrupt. Throws
                                                          MIO_EMM_INTSN_E::MIO_EMM_DMA_DONE. */
@@ -3846,6 +4125,7 @@ union cvmx_mio_emm_dma_int_w1s {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_int_w1s_s     cn73xx;
 	struct cvmx_mio_emm_dma_int_w1s_s     cn78xx;
 };
 typedef union cvmx_mio_emm_dma_int_w1s cvmx_mio_emm_dma_int_w1s_t;
@@ -3887,6 +4167,7 @@ union cvmx_mio_emm_int {
 	struct cvmx_mio_emm_int_s             cn61xx;
 	struct cvmx_mio_emm_int_s             cn70xx;
 	struct cvmx_mio_emm_int_s             cn70xxp1;
+	struct cvmx_mio_emm_int_s             cn73xx;
 	struct cvmx_mio_emm_int_s             cn78xx;
 	struct cvmx_mio_emm_int_s             cnf71xx;
 };
@@ -3931,6 +4212,41 @@ union cvmx_mio_emm_int_en {
 typedef union cvmx_mio_emm_int_en cvmx_mio_emm_int_en_t;
 
 /**
+ * cvmx_mio_emm_int_w1s
+ */
+union cvmx_mio_emm_int_w1s {
+	uint64_t u64;
+	struct cvmx_mio_emm_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t switch_err                   : 1;  /**< Switch operation encountered an error. Throws MIO_EMM_INTSN_E::MIO_EMM_INT_SWITCH_ERR. */
+	uint64_t switch_done                  : 1;  /**< Switch operation completed successfully. Throws MIO_EMM_INTSN_E::MIO_EMM_INT_SWITCH_DONE. */
+	uint64_t dma_err                      : 1;  /**< External DMA transfer encountered an error. See MIO_EMM_RSP_STS. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_DMA_ERR. */
+	uint64_t cmd_err                      : 1;  /**< Operation specified by MIO_EMM_CMD encountered an error. See MIO_EMM_RSP_STS. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_CMD_ERR. */
+	uint64_t dma_done                     : 1;  /**< External DMA transfer specified by MIO_EMM_DMA completed successfully. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_DMA_DONE. */
+	uint64_t cmd_done                     : 1;  /**< Operation specified by MIO_EMM_CMD completed successfully. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_CMD_DONE. */
+	uint64_t buf_done                     : 1;  /**< The next 512B block transfer of a multiblock transfer has completed. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_BUF_DONE. */
+#else
+	uint64_t buf_done                     : 1;
+	uint64_t cmd_done                     : 1;
+	uint64_t dma_done                     : 1;
+	uint64_t cmd_err                      : 1;
+	uint64_t dma_err                      : 1;
+	uint64_t switch_done                  : 1;
+	uint64_t switch_err                   : 1;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} s;
+	struct cvmx_mio_emm_int_w1s_s         cn73xx;
+};
+typedef union cvmx_mio_emm_int_w1s cvmx_mio_emm_int_w1s_t;
+
+/**
  * cvmx_mio_emm_mode#
  *
  * MIO_EMM_MODE = MIO EMMC Operating mode Register
@@ -3975,6 +4291,7 @@ union cvmx_mio_emm_modex {
 	struct cvmx_mio_emm_modex_s           cn61xx;
 	struct cvmx_mio_emm_modex_s           cn70xx;
 	struct cvmx_mio_emm_modex_s           cn70xxp1;
+	struct cvmx_mio_emm_modex_s           cn73xx;
 	struct cvmx_mio_emm_modex_s           cn78xx;
 	struct cvmx_mio_emm_modex_s           cnf71xx;
 };
@@ -3999,6 +4316,7 @@ union cvmx_mio_emm_rca {
 	struct cvmx_mio_emm_rca_s             cn61xx;
 	struct cvmx_mio_emm_rca_s             cn70xx;
 	struct cvmx_mio_emm_rca_s             cn70xxp1;
+	struct cvmx_mio_emm_rca_s             cn73xx;
 	struct cvmx_mio_emm_rca_s             cn78xx;
 	struct cvmx_mio_emm_rca_s             cnf71xx;
 };
@@ -4028,6 +4346,7 @@ union cvmx_mio_emm_rsp_hi {
 	struct cvmx_mio_emm_rsp_hi_s          cn61xx;
 	struct cvmx_mio_emm_rsp_hi_s          cn70xx;
 	struct cvmx_mio_emm_rsp_hi_s          cn70xxp1;
+	struct cvmx_mio_emm_rsp_hi_s          cn73xx;
 	struct cvmx_mio_emm_rsp_hi_s          cn78xx;
 	struct cvmx_mio_emm_rsp_hi_s          cnf71xx;
 };
@@ -4089,6 +4408,7 @@ union cvmx_mio_emm_rsp_lo {
 	struct cvmx_mio_emm_rsp_lo_s          cn61xx;
 	struct cvmx_mio_emm_rsp_lo_s          cn70xx;
 	struct cvmx_mio_emm_rsp_lo_s          cn70xxp1;
+	struct cvmx_mio_emm_rsp_lo_s          cn73xx;
 	struct cvmx_mio_emm_rsp_lo_s          cn78xx;
 	struct cvmx_mio_emm_rsp_lo_s          cnf71xx;
 };
@@ -4258,6 +4578,7 @@ union cvmx_mio_emm_rsp_sts {
 	} cn61xx;
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cn70xx;
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cn70xxp1;
+	struct cvmx_mio_emm_rsp_sts_s         cn73xx;
 	struct cvmx_mio_emm_rsp_sts_s         cn78xx;
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cnf71xx;
 };
@@ -4286,6 +4607,7 @@ union cvmx_mio_emm_sample {
 	struct cvmx_mio_emm_sample_s          cn61xx;
 	struct cvmx_mio_emm_sample_s          cn70xx;
 	struct cvmx_mio_emm_sample_s          cn70xxp1;
+	struct cvmx_mio_emm_sample_s          cn73xx;
 	struct cvmx_mio_emm_sample_s          cn78xx;
 	struct cvmx_mio_emm_sample_s          cnf71xx;
 };
@@ -4309,6 +4631,7 @@ union cvmx_mio_emm_sts_mask {
 	struct cvmx_mio_emm_sts_mask_s        cn61xx;
 	struct cvmx_mio_emm_sts_mask_s        cn70xx;
 	struct cvmx_mio_emm_sts_mask_s        cn70xxp1;
+	struct cvmx_mio_emm_sts_mask_s        cn73xx;
 	struct cvmx_mio_emm_sts_mask_s        cn78xx;
 	struct cvmx_mio_emm_sts_mask_s        cnf71xx;
 };
@@ -4379,6 +4702,7 @@ union cvmx_mio_emm_switch {
 	struct cvmx_mio_emm_switch_s          cn61xx;
 	struct cvmx_mio_emm_switch_s          cn70xx;
 	struct cvmx_mio_emm_switch_s          cn70xxp1;
+	struct cvmx_mio_emm_switch_s          cn73xx;
 	struct cvmx_mio_emm_switch_s          cn78xx;
 	struct cvmx_mio_emm_switch_s          cnf71xx;
 };
@@ -4428,6 +4752,7 @@ union cvmx_mio_emm_wdog {
 	struct cvmx_mio_emm_wdog_s            cn61xx;
 	struct cvmx_mio_emm_wdog_s            cn70xx;
 	struct cvmx_mio_emm_wdog_s            cn70xxp1;
+	struct cvmx_mio_emm_wdog_s            cn73xx;
 	struct cvmx_mio_emm_wdog_s            cn78xx;
 	struct cvmx_mio_emm_wdog_s            cnf71xx;
 };
@@ -4465,6 +4790,7 @@ union cvmx_mio_fus_bnk_datx {
 	struct cvmx_mio_fus_bnk_datx_s        cn68xxp1;
 	struct cvmx_mio_fus_bnk_datx_s        cn70xx;
 	struct cvmx_mio_fus_bnk_datx_s        cn70xxp1;
+	struct cvmx_mio_fus_bnk_datx_s        cn73xx;
 	struct cvmx_mio_fus_bnk_datx_s        cn78xx;
 	struct cvmx_mio_fus_bnk_datx_s        cnf71xx;
 };
@@ -4503,6 +4829,7 @@ union cvmx_mio_fus_dat0 {
 	struct cvmx_mio_fus_dat0_s            cn68xxp1;
 	struct cvmx_mio_fus_dat0_s            cn70xx;
 	struct cvmx_mio_fus_dat0_s            cn70xxp1;
+	struct cvmx_mio_fus_dat0_s            cn73xx;
 	struct cvmx_mio_fus_dat0_s            cn78xx;
 	struct cvmx_mio_fus_dat0_s            cnf71xx;
 };
@@ -4541,6 +4868,7 @@ union cvmx_mio_fus_dat1 {
 	struct cvmx_mio_fus_dat1_s            cn68xxp1;
 	struct cvmx_mio_fus_dat1_s            cn70xx;
 	struct cvmx_mio_fus_dat1_s            cn70xxp1;
+	struct cvmx_mio_fus_dat1_s            cn73xx;
 	struct cvmx_mio_fus_dat1_s            cn78xx;
 	struct cvmx_mio_fus_dat1_s            cnf71xx;
 };
@@ -4565,7 +4893,17 @@ union cvmx_mio_fus_dat2 {
 	uint64_t u64;
 	struct cvmx_mio_fus_dat2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_48_63               : 16;
+	uint64_t reserved_59_63               : 5;
+	uint64_t run_platform                 : 3;  /**< Fuses to indicate the run platform. Not to be blown in actual hardware.
+                                                         Provides software a means of determining the platform at run time.
+                                                         0x0 = Hardware.
+                                                         0x1 = Emulator.
+                                                         0x2 = RTL simulator.
+                                                         0x3 = ASIM.
+                                                         0x4-0x7 = Reserved. */
+	uint64_t gbl_pwr_throttle             : 8;  /**< Controls global power throttling. MSB is a spare, and lower 7 bits indicate
+                                                         N/128 power reduction. Small values have less throttling and higher
+                                                         performance. 0x0 disables throttling. */
 	uint64_t fus118                       : 1;  /**< Ignore Authentik disable */
 	uint64_t rom_info                     : 10; /**< Fuse information - ROM info */
 	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit */
@@ -4604,7 +4942,9 @@ union cvmx_mio_fus_dat2 {
 	uint64_t power_limit                  : 2;
 	uint64_t rom_info                     : 10;
 	uint64_t fus118                       : 1;
-	uint64_t reserved_48_63               : 16;
+	uint64_t gbl_pwr_throttle             : 8;
+	uint64_t run_platform                 : 3;
+	uint64_t reserved_59_63               : 5;
 #endif
 	} s;
 	struct cvmx_mio_fus_dat2_cn30xx {
@@ -4962,7 +5302,7 @@ union cvmx_mio_fus_dat2 {
 	uint64_t dorm_crypto                  : 1;  /**< Fuse information - Dormant encryption enable. */
 	uint64_t fus318                       : 1;  /**< Reserved. */
 	uint64_t raid_en                      : 1;  /**< Fuse information - RAID enabled. */
-	uint64_t reserved_29_31               : 3;
+	uint64_t reserved_31_29               : 3;
 	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2). */
 	uint64_t nomul                        : 1;  /**< Fuse information - VMUL disable. */
 	uint64_t nocrypto                     : 1;  /**< Fuse information - DORM_CRYPTO and NOCRYPTO together select one of four mutually-exclusive
@@ -4971,17 +5311,17 @@ union cvmx_mio_fus_dat2 {
                                                          _ DORM_CRYPTO = 0, NOCRYPTO = 1 AES/DES/HASH disabled.
                                                          _ DORM_CRYPTO = 1, NOCRYPTO = 0 Dormant encryption enable.
                                                          _ DORM_CRYPTO = 1, NOCRYPTO = 1 Authentik mode. */
-	uint64_t reserved_24_25               : 2;
+	uint64_t reserved_25_24               : 2;
 	uint64_t chip_id                      : 8;  /**< Fuse information - chip ID. */
-	uint64_t reserved_0_15                : 16;
+	uint64_t reserved_15_0                : 16;
 #else
-	uint64_t reserved_0_15                : 16;
+	uint64_t reserved_15_0                : 16;
 	uint64_t chip_id                      : 8;
-	uint64_t reserved_24_25               : 2;
+	uint64_t reserved_25_24               : 2;
 	uint64_t nocrypto                     : 1;
 	uint64_t nomul                        : 1;
 	uint64_t nodfa_cp2                    : 1;
-	uint64_t reserved_29_31               : 3;
+	uint64_t reserved_31_29               : 3;
 	uint64_t raid_en                      : 1;
 	uint64_t fus318                       : 1;
 	uint64_t dorm_crypto                  : 1;
@@ -4992,7 +5332,109 @@ union cvmx_mio_fus_dat2 {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_dat2_cn70xx       cn70xxp1;
-	struct cvmx_mio_fus_dat2_cn70xx       cn78xx;
+	struct cvmx_mio_fus_dat2_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_59_63               : 5;
+	uint64_t run_platform                 : 3;  /**< Fuses to indicate the run platform. Not to be blown in actual hardware.
+                                                         Provides software a means of determining the platform at run time.
+                                                         0x0 = Hardware.
+                                                         0x1 = Emulator.
+                                                         0x2 = RTL simulator.
+                                                         0x3 = ASIM.
+                                                         0x4-0x7 = Reserved. */
+	uint64_t gbl_pwr_throttle             : 8;  /**< Controls global power throttling. MSB is a spare, and lower 7 bits indicate
+                                                         N/128 power reduction. Small values have less throttling and higher
+                                                         performance. 0x0 disables throttling. */
+	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable.
+                                                         INTERNAL: fuse[99]. */
+	uint64_t rom_info                     : 10; /**< Fuse information - ROM info. */
+	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit. */
+	uint64_t dorm_crypto                  : 1;  /**< Fuse information - Dormant encryption enable. See NOCRYPTO. */
+	uint64_t fus318                       : 1;  /**< Reserved.
+                                                         INTERNAL: Tied to 0. */
+	uint64_t raid_en                      : 1;  /**< Fuse information - RAID enabled. */
+	uint64_t reserved_31_29               : 3;
+	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2). */
+	uint64_t nomul                        : 1;  /**< Fuse information - VMUL disable. */
+	uint64_t nocrypto                     : 1;  /**< Fuse information - DORM_CRYPTO and NOCRYPTO together select one of four mutually-exclusive
+                                                         modes:
+                                                         _ DORM_CRYPTO = 0, NOCRYPTO = 0 AES/DES/HASH enabled.
+                                                         _ DORM_CRYPTO = 0, NOCRYPTO = 1 AES/DES/HASH disabled.
+                                                         _ DORM_CRYPTO = 1, NOCRYPTO = 0 Dormant encryption enable.
+                                                         _ DORM_CRYPTO = 1, NOCRYPTO = 1 Authentik mode. */
+	uint64_t reserved_25_24               : 2;
+	uint64_t chip_id                      : 8;  /**< Fuse information - chip ID. */
+	uint64_t reserved_15_0                : 16;
+#else
+	uint64_t reserved_15_0                : 16;
+	uint64_t chip_id                      : 8;
+	uint64_t reserved_25_24               : 2;
+	uint64_t nocrypto                     : 1;
+	uint64_t nomul                        : 1;
+	uint64_t nodfa_cp2                    : 1;
+	uint64_t reserved_31_29               : 3;
+	uint64_t raid_en                      : 1;
+	uint64_t fus318                       : 1;
+	uint64_t dorm_crypto                  : 1;
+	uint64_t power_limit                  : 2;
+	uint64_t rom_info                     : 10;
+	uint64_t fus118                       : 1;
+	uint64_t gbl_pwr_throttle             : 8;
+	uint64_t run_platform                 : 3;
+	uint64_t reserved_59_63               : 5;
+#endif
+	} cn73xx;
+	struct cvmx_mio_fus_dat2_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_59_63               : 5;
+	uint64_t run_platform                 : 3;  /**< Fuses to indicate the run platform. Not to be blown in actual hardware.
+                                                         Provides software a means of determining the platform at run time.
+                                                         0x0 = Hardware.
+                                                         0x1 = Emulator.
+                                                         0x2 = RTL simulator.
+                                                         0x3 = ASIM.
+                                                         0x4-0x7 = Reserved. */
+	uint64_t reserved_48_55               : 8;
+	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable.
+                                                         INTERNAL: fuse[99]. */
+	uint64_t rom_info                     : 10; /**< Fuse information - ROM info. */
+	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit. */
+	uint64_t dorm_crypto                  : 1;  /**< Fuse information - Dormant encryption enable. See NOCRYPTO. */
+	uint64_t fus318                       : 1;  /**< Reserved.
+                                                         INTERNAL: Tied to 0. */
+	uint64_t raid_en                      : 1;  /**< Fuse information - RAID enabled. */
+	uint64_t reserved_31_29               : 3;
+	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2).
+                                                         INTERNAL: Tied to 1. */
+	uint64_t nomul                        : 1;  /**< Fuse information - VMUL disable. */
+	uint64_t nocrypto                     : 1;  /**< Fuse information - DORM_CRYPTO and NOCRYPTO together select one of four mutually-exclusive
+                                                         modes:
+                                                         _ DORM_CRYPTO = 0, NOCRYPTO = 0 AES/DES/HASH enabled.
+                                                         _ DORM_CRYPTO = 0, NOCRYPTO = 1 AES/DES/HASH disabled.
+                                                         _ DORM_CRYPTO = 1, NOCRYPTO = 0 Dormant encryption enable.
+                                                         _ DORM_CRYPTO = 1, NOCRYPTO = 1 Authentik mode. */
+	uint64_t reserved_25_24               : 2;
+	uint64_t chip_id                      : 8;  /**< Fuse information - chip ID. */
+	uint64_t reserved_0_15                : 16;
+#else
+	uint64_t reserved_0_15                : 16;
+	uint64_t chip_id                      : 8;
+	uint64_t reserved_25_24               : 2;
+	uint64_t nocrypto                     : 1;
+	uint64_t nomul                        : 1;
+	uint64_t nodfa_cp2                    : 1;
+	uint64_t reserved_31_29               : 3;
+	uint64_t raid_en                      : 1;
+	uint64_t fus318                       : 1;
+	uint64_t dorm_crypto                  : 1;
+	uint64_t power_limit                  : 2;
+	uint64_t rom_info                     : 10;
+	uint64_t fus118                       : 1;
+	uint64_t reserved_48_55               : 8;
+	uint64_t run_platform                 : 3;
+	uint64_t reserved_59_63               : 5;
+#endif
+	} cn78xx;
 	struct cvmx_mio_fus_dat2_cn61xx       cnf71xx;
 };
 typedef union cvmx_mio_fus_dat2 cvmx_mio_fus_dat2_t;
@@ -5009,7 +5451,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - DFA information (DTE) */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - DFA information (Cluster mask) */
-	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. Added in pass 2. */
+	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. */
 	uint64_t reserved_38_39               : 2;
 	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown */
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown */
@@ -5308,6 +5750,70 @@ union cvmx_mio_fus_dat3 {
 	uint64_t ema0                         : 6;
 #endif
 	} cn70xxp1;
+	struct cvmx_mio_fus_dat3_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
+                                                         will XOR with this value. */
+	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
+	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
+	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
+	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. */
+	uint64_t pll_bwadj_denom              : 2;  /**< Select CLKF denominator for BWADJ value.
+                                                         0x0 = Selects CLKF/4.
+                                                         0x1 = Selects CLKF/2.
+                                                         0x2 = Selects CLKF/8. */
+	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t pll_half_dis                 : 1;  /**< Fuse information - Coprocessor-clock PLL control. */
+	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C cripple:
+                                                         0x0 = Full cache (16-way, 16 MB).
+                                                         0x1 = 3/4 ways (12-way, 12 MB).
+                                                         0x2 = 1/2 ways (8-way, 8 MB).
+                                                         0x3 = 1/4 ways (4-way, 4MB).
+                                                         0x4-0x7 = Reserved. */
+	uint64_t use_int_refclk               : 1;  /**< If set use the PLL output as the low-jitter reference clock to the rclk DLLs. Default is
+                                                         to use the external input reference clock. */
+	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information. */
+	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIe specification. */
+	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
+	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
+	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: Default value is 0x11. Soft or hard blow of these fuses
+                                                         will XOR with this value. */
+	uint64_t nohna_dte                    : 1;  /**< Fuse information - HNA disable (DTE). */
+	uint64_t hna_info_dte                 : 3;  /**< Fuse information - HNA information (DTE). */
+	uint64_t hna_info_clm                 : 4;  /**< Fuse information - HNA information (cluster mask). */
+	uint64_t reserved_9_9                 : 1;
+	uint64_t core_pll_mul                 : 5;  /**< Core-clock PLL multiplier. */
+	uint64_t pnr_pll_mul                  : 4;  /**< Coprocessor-clock PLL multiplier. */
+#else
+	uint64_t pnr_pll_mul                  : 4;
+	uint64_t core_pll_mul                 : 5;
+	uint64_t reserved_9_9                 : 1;
+	uint64_t hna_info_clm                 : 4;
+	uint64_t hna_info_dte                 : 3;
+	uint64_t nohna_dte                    : 1;
+	uint64_t ema1                         : 6;
+	uint64_t nodfa_dte                    : 1;
+	uint64_t nozip                        : 1;
+	uint64_t efus_ign                     : 1;
+	uint64_t efus_lck                     : 1;
+	uint64_t bar2_sz_conf                 : 1;
+	uint64_t zip_info                     : 2;
+	uint64_t use_int_refclk               : 1;
+	uint64_t l2c_crip                     : 3;
+	uint64_t pll_half_dis                 : 1;
+	uint64_t efus_lck_man                 : 1;
+	uint64_t efus_lck_rsv                 : 1;
+	uint64_t pll_bwadj_denom              : 2;
+	uint64_t pll_alt_matrix               : 1;
+	uint64_t dfa_info_clm                 : 4;
+	uint64_t dfa_info_dte                 : 3;
+	uint64_t pll_ctl                      : 10;
+	uint64_t ema0                         : 6;
+#endif
+	} cn73xx;
 	struct cvmx_mio_fus_dat3_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
@@ -5398,6 +5904,7 @@ union cvmx_mio_fus_dat4 {
 	} s;
 	struct cvmx_mio_fus_dat4_s            cn70xx;
 	struct cvmx_mio_fus_dat4_s            cn70xxp1;
+	struct cvmx_mio_fus_dat4_s            cn73xx;
 	struct cvmx_mio_fus_dat4_s            cn78xx;
 };
 typedef union cvmx_mio_fus_dat4 cvmx_mio_fus_dat4_t;
@@ -5466,6 +5973,7 @@ union cvmx_mio_fus_int {
 	} s;
 	struct cvmx_mio_fus_int_s             cn70xx;
 	struct cvmx_mio_fus_int_s             cn70xxp1;
+	struct cvmx_mio_fus_int_s             cn73xx;
 	struct cvmx_mio_fus_int_s             cn78xx;
 };
 typedef union cvmx_mio_fus_int cvmx_mio_fus_int_t;
@@ -5496,6 +6004,7 @@ union cvmx_mio_fus_pdf {
 	struct cvmx_mio_fus_pdf_s             cn68xxp1;
 	struct cvmx_mio_fus_pdf_s             cn70xx;
 	struct cvmx_mio_fus_pdf_s             cn70xxp1;
+	struct cvmx_mio_fus_pdf_s             cn73xx;
 	struct cvmx_mio_fus_pdf_s             cn78xx;
 	struct cvmx_mio_fus_pdf_s             cnf71xx;
 };
@@ -5657,6 +6166,7 @@ union cvmx_mio_fus_pll {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_pll_cn70xx        cn70xxp1;
+	struct cvmx_mio_fus_pll_cn70xx        cn73xx;
 	struct cvmx_mio_fus_pll_cn70xx        cn78xx;
 	struct cvmx_mio_fus_pll_cn61xx        cnf71xx;
 };
@@ -5745,6 +6255,7 @@ union cvmx_mio_fus_prog {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_prog_cn70xx       cn70xxp1;
+	struct cvmx_mio_fus_prog_cn70xx       cn73xx;
 	struct cvmx_mio_fus_prog_cn70xx       cn78xx;
 	struct cvmx_mio_fus_prog_cn61xx       cnf71xx;
 };
@@ -5876,6 +6387,7 @@ union cvmx_mio_fus_prog_times {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_prog_times_cn70xx cn70xxp1;
+	struct cvmx_mio_fus_prog_times_cn70xx cn73xx;
 	struct cvmx_mio_fus_prog_times_cn70xx cn78xx;
 	struct cvmx_mio_fus_prog_times_cn61xx cnf71xx;
 };
@@ -5979,6 +6491,7 @@ union cvmx_mio_fus_rcmd {
 	struct cvmx_mio_fus_rcmd_cn52xx       cn68xxp1;
 	struct cvmx_mio_fus_rcmd_s            cn70xx;
 	struct cvmx_mio_fus_rcmd_s            cn70xxp1;
+	struct cvmx_mio_fus_rcmd_s            cn73xx;
 	struct cvmx_mio_fus_rcmd_s            cn78xx;
 	struct cvmx_mio_fus_rcmd_cn52xx       cnf71xx;
 };
@@ -6091,6 +6604,7 @@ union cvmx_mio_fus_read_times {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_read_times_cn70xx cn70xxp1;
+	struct cvmx_mio_fus_read_times_cn70xx cn73xx;
 	struct cvmx_mio_fus_read_times_cn70xx cn78xx;
 	struct cvmx_mio_fus_read_times_cn61xx cnf71xx;
 };
@@ -6193,6 +6707,7 @@ union cvmx_mio_fus_rpr_datx {
 	} s;
 	struct cvmx_mio_fus_rpr_datx_s        cn70xx;
 	struct cvmx_mio_fus_rpr_datx_s        cn70xxp1;
+	struct cvmx_mio_fus_rpr_datx_s        cn73xx;
 	struct cvmx_mio_fus_rpr_datx_s        cn78xx;
 };
 typedef union cvmx_mio_fus_rpr_datx cvmx_mio_fus_rpr_datx_t;
@@ -6226,6 +6741,7 @@ union cvmx_mio_fus_soft_repair {
 	} s;
 	struct cvmx_mio_fus_soft_repair_s     cn70xx;
 	struct cvmx_mio_fus_soft_repair_s     cn70xxp1;
+	struct cvmx_mio_fus_soft_repair_s     cn73xx;
 	struct cvmx_mio_fus_soft_repair_s     cn78xx;
 };
 typedef union cvmx_mio_fus_soft_repair cvmx_mio_fus_soft_repair_t;
@@ -6361,6 +6877,7 @@ union cvmx_mio_fus_tgg {
 	struct cvmx_mio_fus_tgg_s             cn66xx;
 	struct cvmx_mio_fus_tgg_s             cn70xx;
 	struct cvmx_mio_fus_tgg_s             cn70xxp1;
+	struct cvmx_mio_fus_tgg_s             cn73xx;
 	struct cvmx_mio_fus_tgg_s             cn78xx;
 	struct cvmx_mio_fus_tgg_s             cnf71xx;
 };
@@ -6451,6 +6968,7 @@ union cvmx_mio_fus_wadr {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_wadr_cn70xx       cn70xxp1;
+	struct cvmx_mio_fus_wadr_cn70xx       cn73xx;
 	struct cvmx_mio_fus_wadr_cn70xx       cn78xx;
 	struct cvmx_mio_fus_wadr_cn61xx       cnf71xx;
 };
@@ -6655,8 +7173,8 @@ typedef union cvmx_mio_pll_setting cvmx_mio_pll_setting_t;
 /**
  * cvmx_mio_ptp_ckout_hi_incr
  *
- * This register contains the high bytes of the PTP clock out increment.
- *
+ * This register contains the PTP CKOUT threshold increment on pre-inverted PTP_CKOUT rising
+ * edge. See MIO_PTP_CKOUT_THRESH_HI for details.
  */
 union cvmx_mio_ptp_ckout_hi_incr {
 	uint64_t u64;
@@ -6674,6 +7192,7 @@ union cvmx_mio_ptp_ckout_hi_incr {
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn68xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn70xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn70xxp1;
+	struct cvmx_mio_ptp_ckout_hi_incr_s   cn73xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn78xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cnf71xx;
 };
@@ -6682,8 +7201,8 @@ typedef union cvmx_mio_ptp_ckout_hi_incr cvmx_mio_ptp_ckout_hi_incr_t;
 /**
  * cvmx_mio_ptp_ckout_lo_incr
  *
- * This register contains the low bytes of the PTP clock out increment.
- *
+ * This register contains the PTP CKOUTthreshold increment on pre-inverted PTP_CKOUT falling
+ * edge. See MIO_PTP_CKOUT_THRESH_HI for details.
  */
 union cvmx_mio_ptp_ckout_lo_incr {
 	uint64_t u64;
@@ -6701,6 +7220,7 @@ union cvmx_mio_ptp_ckout_lo_incr {
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn68xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn70xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn70xxp1;
+	struct cvmx_mio_ptp_ckout_lo_incr_s   cn73xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn78xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cnf71xx;
 };
@@ -6709,9 +7229,17 @@ typedef union cvmx_mio_ptp_ckout_lo_incr cvmx_mio_ptp_ckout_lo_incr_t;
 /**
  * cvmx_mio_ptp_ckout_thresh_hi
  *
- * This register contains the high bytes of the PTP clock out. Writes to MIO_PTP_CKOUT_THRESH_HI
- * also clear MIO_PTP_CKOUT_THRESH_LO; to update all 96 bits, write MIO_PTP_CKOUT_THRESH_HI
- * followed by MIO_PTP_CKOUT_THRESH_LO.
+ * This register contains the high bytes of the PTP CKOUT threshold.
+ * Writes to MIO_PTP_CKOUT_THRESH_HI also clear MIO_PTP_CKOUT_THRESH_LO; in order to update all
+ * 96 bits, writes MIO_PTP_CKOUT_THRESH_HI followed by MIO_PTP_CKOUT_THRESH_LO.
+ * This threshold [MIO_PTP_CKOUT_THRESH_HI,  MIO_PTP_CKOUT_THRESH_LO] is a rolling threshold that
+ * will be updated by hardware:
+ *   When current PTP_CKOUT before inversion (defined by MIO_PTP_CLOCK_CFG[CKOUT_INV]) is zero,
+ *   and [MIO_PTP_CLOCK_HI/LO] >= [MIO_PTP_CKOUT_THRESH_HI/LO], the pre-inverted PTP_CKOUT will
+ *   update to one, and [MIO_PTP_CKOUT_THRESH_HI/LO] will increment by MIO_PTP_CKOUT_HI_INCR.
+ *   When current PTP_CKOUT before inversion (defined by MIO_PTP_CLOCK_CFG[CKOUT_INV]) is one,
+ *   and [MIO_PTP_CLOCK_HI/LO] >= [MIO_PTP_CKOUT_THRESH_HI/LO], the pre-inverted PTP_CKOUT will
+ *   update to zero, and [MIO_PTP_CKOUT_THRESH_HI/LO] will increment by MIO_PTP_CKOUT_LO_INCR.
  */
 union cvmx_mio_ptp_ckout_thresh_hi {
 	uint64_t u64;
@@ -6727,6 +7255,7 @@ union cvmx_mio_ptp_ckout_thresh_hi {
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn68xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn70xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn70xxp1;
+	struct cvmx_mio_ptp_ckout_thresh_hi_s cn73xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn78xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cnf71xx;
 };
@@ -6735,8 +7264,8 @@ typedef union cvmx_mio_ptp_ckout_thresh_hi cvmx_mio_ptp_ckout_thresh_hi_t;
 /**
  * cvmx_mio_ptp_ckout_thresh_lo
  *
- * This register contains the low bytes of the PTP clock out.
- *
+ * This register contains the low bytes of the PTP CKOUT threshold,
+ * See MIO_PTP_CKOUT_THRESH_HI for details.
  */
 union cvmx_mio_ptp_ckout_thresh_lo {
 	uint64_t u64;
@@ -6754,6 +7283,7 @@ union cvmx_mio_ptp_ckout_thresh_lo {
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn68xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn70xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn70xxp1;
+	struct cvmx_mio_ptp_ckout_thresh_lo_s cn73xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn78xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cnf71xx;
 };
@@ -6769,11 +7299,7 @@ union cvmx_mio_ptp_clock_cfg {
 	uint64_t u64;
 	struct cvmx_mio_ptp_clock_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t pps                          : 1;  /**< PTP PPS Output
-                                                         reflects ptp__pps after PPS_INV inverter */
-	uint64_t ckout                        : 1;  /**< PTP Clock Output
-                                                         reflects ptp__ckout after CKOUT_INV inverter */
+	uint64_t reserved_40_63               : 24;
 	uint64_t ext_clk_edge                 : 2;  /**< External Clock input edge
                                                          00 = rising edge
                                                          01 = falling edge
@@ -6863,60 +7389,16 @@ union cvmx_mio_ptp_clock_cfg {
 	uint64_t pps_out                      : 5;
 	uint64_t ckout_out4                   : 1;
 	uint64_t ext_clk_edge                 : 2;
-	uint64_t ckout                        : 1;
-	uint64_t pps                          : 1;
-	uint64_t reserved_42_63               : 22;
+	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
-	struct cvmx_mio_ptp_clock_cfg_s       cn61xx;
-	struct cvmx_mio_ptp_clock_cfg_cn63xx {
+	struct cvmx_mio_ptp_clock_cfg_cn61xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_24_63               : 40;
-	uint64_t evcnt_in                     : 6;  /**< Source for event counter input
-                                                         0x00-0x0f : GPIO[EVCNT_IN[3:0]]
-                                                         0x10      : QLM0_REF_CLK
-                                                         0x11      : QLM1_REF_CLK
-                                                         0x12      : QLM2_REF_CLK
-                                                         0x13-0x3f : Reserved */
-	uint64_t evcnt_edge                   : 1;  /**< Event counter input edge
-                                                         0 = falling edge
-                                                         1 = rising edge */
-	uint64_t evcnt_en                     : 1;  /**< Enable event counter */
-	uint64_t tstmp_in                     : 6;  /**< Source for timestamp input
-                                                         0x00-0x0f : GPIO[TSTMP_IN[3:0]]
-                                                         0x10      : QLM0_REF_CLK
-                                                         0x11      : QLM1_REF_CLK
-                                                         0x12      : QLM2_REF_CLK
-                                                         0x13-0x3f : Reserved */
-	uint64_t tstmp_edge                   : 1;  /**< External timestamp input edge
-                                                         0 = falling edge
-                                                         1 = rising edge */
-	uint64_t tstmp_en                     : 1;  /**< Enable external timestamp */
-	uint64_t ext_clk_in                   : 6;  /**< Source for external clock
-                                                         0x00-0x0f : GPIO[EXT_CLK_IN[3:0]]
-                                                         0x10      : QLM0_REF_CLK
-                                                         0x11      : QLM1_REF_CLK
-                                                         0x12      : QLM2_REF_CLK
-                                                         0x13-0x3f : Reserved */
-	uint64_t ext_clk_en                   : 1;  /**< Use positive edge of external clock */
-	uint64_t ptp_en                       : 1;  /**< Enable PTP Module */
-#else
-	uint64_t ptp_en                       : 1;
-	uint64_t ext_clk_en                   : 1;
-	uint64_t ext_clk_in                   : 6;
-	uint64_t tstmp_en                     : 1;
-	uint64_t tstmp_edge                   : 1;
-	uint64_t tstmp_in                     : 6;
-	uint64_t evcnt_en                     : 1;
-	uint64_t evcnt_edge                   : 1;
-	uint64_t evcnt_in                     : 6;
-	uint64_t reserved_24_63               : 40;
-#endif
-	} cn63xx;
-	struct cvmx_mio_ptp_clock_cfg_cn63xx  cn63xxp1;
-	struct cvmx_mio_ptp_clock_cfg_cn66xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_40_63               : 24;
+	uint64_t reserved_42_63               : 22;
+	uint64_t pps                          : 1;  /**< PTP PPS Output
+                                                         reflects ptp__pps after PPS_INV inverter */
+	uint64_t ckout                        : 1;  /**< PTP Clock Output
+                                                         reflects ptp__ckout after CKOUT_INV inverter */
 	uint64_t ext_clk_edge                 : 2;  /**< External Clock input edge
                                                          00 = rising edge
                                                          01 = falling edge
@@ -6975,7 +7457,7 @@ union cvmx_mio_ptp_clock_cfg {
                                                          0x21      : GPIO[17]
                                                          0x22      : GPIO[18]
                                                          0x23      : GPIO[19]
-                                                         0x10      : QLM0_REF_CLK
+                                                         0x10      : QLM0_EF_CLK
                                                          0x11      : QLM1_REF_CLK
                                                          0x12      : QLM2_REF_CLK
                                                          0x13-0x1f : Reserved
@@ -7000,18 +7482,66 @@ union cvmx_mio_ptp_clock_cfg {
 	uint64_t pps_out                      : 5;
 	uint64_t ckout_out4                   : 1;
 	uint64_t ext_clk_edge                 : 2;
-	uint64_t reserved_40_63               : 24;
+	uint64_t ckout                        : 1;
+	uint64_t pps                          : 1;
+	uint64_t reserved_42_63               : 22;
 #endif
-	} cn66xx;
-	struct cvmx_mio_ptp_clock_cfg_s       cn68xx;
+	} cn61xx;
+	struct cvmx_mio_ptp_clock_cfg_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t evcnt_in                     : 6;  /**< Source for event counter input
+                                                         0x00-0x0f : GPIO[EVCNT_IN[3:0]]
+                                                         0x10      : QLM0_REF_CLK
+                                                         0x11      : QLM1_REF_CLK
+                                                         0x12      : QLM2_REF_CLK
+                                                         0x13-0x3f : Reserved */
+	uint64_t evcnt_edge                   : 1;  /**< Event counter input edge
+                                                         0 = falling edge
+                                                         1 = rising edge */
+	uint64_t evcnt_en                     : 1;  /**< Enable event counter */
+	uint64_t tstmp_in                     : 6;  /**< Source for timestamp input
+                                                         0x00-0x0f : GPIO[TSTMP_IN[3:0]]
+                                                         0x10      : QLM0_REF_CLK
+                                                         0x11      : QLM1_REF_CLK
+                                                         0x12      : QLM2_REF_CLK
+                                                         0x13-0x3f : Reserved */
+	uint64_t tstmp_edge                   : 1;  /**< External timestamp input edge
+                                                         0 = falling edge
+                                                         1 = rising edge */
+	uint64_t tstmp_en                     : 1;  /**< Enable external timestamp */
+	uint64_t ext_clk_in                   : 6;  /**< Source for external clock
+                                                         0x00-0x0f : GPIO[EXT_CLK_IN[3:0]]
+                                                         0x10      : QLM0_REF_CLK
+                                                         0x11      : QLM1_REF_CLK
+                                                         0x12      : QLM2_REF_CLK
+                                                         0x13-0x3f : Reserved */
+	uint64_t ext_clk_en                   : 1;  /**< Use positive edge of external clock */
+	uint64_t ptp_en                       : 1;  /**< Enable PTP Module */
+#else
+	uint64_t ptp_en                       : 1;
+	uint64_t ext_clk_en                   : 1;
+	uint64_t ext_clk_in                   : 6;
+	uint64_t tstmp_en                     : 1;
+	uint64_t tstmp_edge                   : 1;
+	uint64_t tstmp_in                     : 6;
+	uint64_t evcnt_en                     : 1;
+	uint64_t evcnt_edge                   : 1;
+	uint64_t evcnt_in                     : 6;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn63xx;
+	struct cvmx_mio_ptp_clock_cfg_cn63xx  cn63xxp1;
+	struct cvmx_mio_ptp_clock_cfg_s       cn66xx;
+	struct cvmx_mio_ptp_clock_cfg_cn61xx  cn68xx;
 	struct cvmx_mio_ptp_clock_cfg_cn63xx  cn68xxp1;
 	struct cvmx_mio_ptp_clock_cfg_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
+	uint64_t ckout                        : 1;  /**< PTP CKOUT output
+                                                         reflects ptp__ckout after CKOUT_INV inverter */
 	uint64_t pps                          : 1;  /**< PTP PPS Output
                                                          reflects ptp__pps after PPS_INV inverter */
-	uint64_t ckout                        : 1;  /**< PTP Clock Output
-                                                         reflects ptp__ckout after CKOUT_INV inverter */
 	uint64_t ext_clk_edge                 : 2;  /**< External Clock input edge
                                                          00 = rising edge
                                                          01 = falling edge
@@ -7023,10 +7553,10 @@ union cvmx_mio_ptp_clock_cfg {
                                                          1 = invert */
 	uint64_t pps_en                       : 1;  /**< Enable PTP PPS */
 	uint64_t reserved_26_29               : 4;
-	uint64_t ckout_inv                    : 1;  /**< Invert PTP Clock Out
+	uint64_t ckout_inv                    : 1;  /**< Invert PTP CKOUT
                                                          0 = don't invert
                                                          1 = invert */
-	uint64_t ckout_en                     : 1;  /**< Enable PTP Clock Out */
+	uint64_t ckout_en                     : 1;  /**< Enable PTP CKOUT */
 	uint64_t evcnt_in                     : 6;  /**< Source for event counter input
                                                          0x00-0x0f : GPIO[EVCNT_IN[3:0]]
                                                          0x20      : GPIO[16]
@@ -7087,22 +7617,25 @@ union cvmx_mio_ptp_clock_cfg {
 	uint64_t pps_inv                      : 1;
 	uint64_t reserved_32_37               : 6;
 	uint64_t ext_clk_edge                 : 2;
-	uint64_t ckout                        : 1;
 	uint64_t pps                          : 1;
+	uint64_t ckout                        : 1;
 	uint64_t reserved_42_63               : 22;
 #endif
 	} cn70xx;
 	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn70xxp1;
+	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn73xx;
 	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn78xx;
-	struct cvmx_mio_ptp_clock_cfg_s       cnf71xx;
+	struct cvmx_mio_ptp_clock_cfg_cn61xx  cnf71xx;
 };
 typedef union cvmx_mio_ptp_clock_cfg cvmx_mio_ptp_clock_cfg_t;
 
 /**
  * cvmx_mio_ptp_clock_comp
  *
- * This register provides the compensation value the PTP clock. MIO_PTP_CLOCK_CFG[PTP_EN] needs
- * to be enabled before writing this register.
+ * This register provides the amount to increment the PTP clock [MIO_PTP_CLOCK_HI,
+ * MIO_PTP_CLOCK_LO]
+ * on PTP events defined by MIO_PTP_CLOCK_CFG[EXT_CLK_EN/EXT_CLK_IN/EXT_CLK_EDGE].
+ * MIO_PTP_CLOCK_CFG[PTP_EN] needs to be enabled before writing this register.
  */
 union cvmx_mio_ptp_clock_comp {
 	uint64_t u64;
@@ -7123,6 +7656,7 @@ union cvmx_mio_ptp_clock_comp {
 	struct cvmx_mio_ptp_clock_comp_s      cn68xxp1;
 	struct cvmx_mio_ptp_clock_comp_s      cn70xx;
 	struct cvmx_mio_ptp_clock_comp_s      cn70xxp1;
+	struct cvmx_mio_ptp_clock_comp_s      cn73xx;
 	struct cvmx_mio_ptp_clock_comp_s      cn78xx;
 	struct cvmx_mio_ptp_clock_comp_s      cnf71xx;
 };
@@ -7152,6 +7686,7 @@ union cvmx_mio_ptp_clock_hi {
 	struct cvmx_mio_ptp_clock_hi_s        cn68xxp1;
 	struct cvmx_mio_ptp_clock_hi_s        cn70xx;
 	struct cvmx_mio_ptp_clock_hi_s        cn70xxp1;
+	struct cvmx_mio_ptp_clock_hi_s        cn73xx;
 	struct cvmx_mio_ptp_clock_hi_s        cn78xx;
 	struct cvmx_mio_ptp_clock_hi_s        cnf71xx;
 };
@@ -7182,6 +7717,7 @@ union cvmx_mio_ptp_clock_lo {
 	struct cvmx_mio_ptp_clock_lo_s        cn68xxp1;
 	struct cvmx_mio_ptp_clock_lo_s        cn70xx;
 	struct cvmx_mio_ptp_clock_lo_s        cn70xxp1;
+	struct cvmx_mio_ptp_clock_lo_s        cn73xx;
 	struct cvmx_mio_ptp_clock_lo_s        cn78xx;
 	struct cvmx_mio_ptp_clock_lo_s        cnf71xx;
 };
@@ -7197,7 +7733,23 @@ union cvmx_mio_ptp_dpll_err_int {
 	uint64_t u64;
 	struct cvmx_mio_ptp_dpll_err_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t n_sclk                       : 32; /**< Latest number of Digital PLL coprocessor clocks in one compensation period. */
+	uint64_t n_sclk                       : 32; /**< Latest number of coprocessor clocks in one external reference signal compensation period
+                                                         (MIO_PTP_CLOCK_COMP). */
+	uint64_t reserved_2_31                : 30;
+	uint64_t dpll_int_w1s                 : 1;  /**< Reads or sets [DPLL_INT]. */
+	uint64_t dpll_int                     : 1;  /**< Digital PLL error. Throws MIO_PTP_INTSN_E::MIO_PTP_DPLL_INT. */
+#else
+	uint64_t dpll_int                     : 1;
+	uint64_t dpll_int_w1s                 : 1;
+	uint64_t reserved_2_31                : 30;
+	uint64_t n_sclk                       : 32;
+#endif
+	} s;
+	struct cvmx_mio_ptp_dpll_err_int_s    cn73xx;
+	struct cvmx_mio_ptp_dpll_err_int_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t n_sclk                       : 32; /**< Latest number of coprocessor clocks in one external reference signal compensation period
+                                                         (MIO_PTP_CLOCK_COMP). */
 	uint64_t reserved_1_31                : 31;
 	uint64_t dpll_int                     : 1;  /**< Digital PLL error. Throws MIO_PTP_INTSN_E::MIO_PTP_DPLL_INT. */
 #else
@@ -7205,8 +7757,7 @@ union cvmx_mio_ptp_dpll_err_int {
 	uint64_t reserved_1_31                : 31;
 	uint64_t n_sclk                       : 32;
 #endif
-	} s;
-	struct cvmx_mio_ptp_dpll_err_int_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_mio_ptp_dpll_err_int cvmx_mio_ptp_dpll_err_int_t;
 
@@ -7227,6 +7778,7 @@ union cvmx_mio_ptp_dpll_err_thresh {
 	uint64_t max                          : 32;
 #endif
 	} s;
+	struct cvmx_mio_ptp_dpll_err_thresh_s cn73xx;
 	struct cvmx_mio_ptp_dpll_err_thresh_s cn78xx;
 };
 typedef union cvmx_mio_ptp_dpll_err_thresh cvmx_mio_ptp_dpll_err_thresh_t;
@@ -7234,8 +7786,8 @@ typedef union cvmx_mio_ptp_dpll_err_thresh cvmx_mio_ptp_dpll_err_thresh_t;
 /**
  * cvmx_mio_ptp_dpll_incr
  *
- * This register contains the Digital PLL increment. Zero disables the digital PLL.
- *
+ * This register contains the Digital PLL increment on each coprocessor clock rising edge.
+ * Zero disables the digital PLL.
  */
 union cvmx_mio_ptp_dpll_incr {
 	uint64_t u64;
@@ -7248,6 +7800,7 @@ union cvmx_mio_ptp_dpll_incr {
 	uint64_t nanosec                      : 32;
 #endif
 	} s;
+	struct cvmx_mio_ptp_dpll_incr_s       cn73xx;
 	struct cvmx_mio_ptp_dpll_incr_s       cn78xx;
 };
 typedef union cvmx_mio_ptp_dpll_incr cvmx_mio_ptp_dpll_incr_t;
@@ -7275,6 +7828,7 @@ union cvmx_mio_ptp_evt_cnt {
 	struct cvmx_mio_ptp_evt_cnt_s         cn68xxp1;
 	struct cvmx_mio_ptp_evt_cnt_s         cn70xx;
 	struct cvmx_mio_ptp_evt_cnt_s         cn70xxp1;
+	struct cvmx_mio_ptp_evt_cnt_s         cn73xx;
 	struct cvmx_mio_ptp_evt_cnt_s         cn78xx;
 	struct cvmx_mio_ptp_evt_cnt_s         cnf71xx;
 };
@@ -7283,21 +7837,32 @@ typedef union cvmx_mio_ptp_evt_cnt cvmx_mio_ptp_evt_cnt_t;
 /**
  * cvmx_mio_ptp_evt_int
  *
- * This register contains the PTP event interrupt.
+ * This register contains the PTP event interrupt. See MIO_PTP_EVT_CNT for details.
  *
  */
 union cvmx_mio_ptp_evt_int {
 	uint64_t u64;
 	struct cvmx_mio_ptp_evt_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t evt_int_w1s                  : 1;  /**< Reads or sets [EVT_INT]. */
+	uint64_t evt_int                      : 1;  /**< PTP event observed. Throws MIO_PTP_INTSN_E::MIO_PTP_EVT_INT. */
+#else
+	uint64_t evt_int                      : 1;
+	uint64_t evt_int_w1s                  : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_mio_ptp_evt_int_s         cn73xx;
+	struct cvmx_mio_ptp_evt_int_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t evt_int                      : 1;  /**< PTP event observed. Throws MIO_PTP_INTSN_E::MIO_PTP_EVT_INT. */
 #else
 	uint64_t evt_int                      : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
-	} s;
-	struct cvmx_mio_ptp_evt_int_s         cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_mio_ptp_evt_int cvmx_mio_ptp_evt_int_t;
 
@@ -7331,8 +7896,8 @@ typedef union cvmx_mio_ptp_phy_1pps_in cvmx_mio_ptp_phy_1pps_in_t;
 /**
  * cvmx_mio_ptp_pps_hi_incr
  *
- * This register contains the high bytes of the PTP PPS increment.
- *
+ * This register contains the PTP PPS threshold increment on pre-inverted PTP_PPS rising edge.
+ * See MIO_PTP_PPS_THRESH_HI for details.
  */
 union cvmx_mio_ptp_pps_hi_incr {
 	uint64_t u64;
@@ -7350,6 +7915,7 @@ union cvmx_mio_ptp_pps_hi_incr {
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn68xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn70xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn70xxp1;
+	struct cvmx_mio_ptp_pps_hi_incr_s     cn73xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn78xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cnf71xx;
 };
@@ -7358,8 +7924,8 @@ typedef union cvmx_mio_ptp_pps_hi_incr cvmx_mio_ptp_pps_hi_incr_t;
 /**
  * cvmx_mio_ptp_pps_lo_incr
  *
- * This register contains the low bytes of the PTP PPS increment.
- *
+ * This register contains the PTP PPS threshold increment on pre-inverted PTP_PPS falling edge.
+ * See MIO_PTP_PPS_THRESH_HI for details.
  */
 union cvmx_mio_ptp_pps_lo_incr {
 	uint64_t u64;
@@ -7377,6 +7943,7 @@ union cvmx_mio_ptp_pps_lo_incr {
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn68xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn70xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn70xxp1;
+	struct cvmx_mio_ptp_pps_lo_incr_s     cn73xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn78xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cnf71xx;
 };
@@ -7385,9 +7952,17 @@ typedef union cvmx_mio_ptp_pps_lo_incr cvmx_mio_ptp_pps_lo_incr_t;
 /**
  * cvmx_mio_ptp_pps_thresh_hi
  *
- * This register contains the high bytes of the PTP PPS. Writes to MIO_PTP_PPS_THRESH_HI also
- * clear MIO_PTP_PPS_THRESH_LO; to update all 96 bits write MIO_PTP_PPS_THRESH_HI followed by
- * MIO_PTP_PPS_THRESH_LO.
+ * This register contains the high bytes of the PTP PPS threshold.
+ * Writes to MIO_PTP_PPS_THRESH_HI also clear MIO_PTP_PPS_THRESH_LO; in order to update all 96
+ * bits, writes MIO_PTP_PPS_THRESH_HI followed by MIO_PTP_PPS_THRESH_LO.
+ * This threshold [MIO_PTP_PPS_THRESH_HI,  MIO_PTP_PPS_THRESH_LO]  is a rolling threshold that
+ * will be updated by hardware:
+ *   When current PTP_PPS before inversion (defined by MIO_PTP_CLOCK_CFG[PPS_INV]) is zero,
+ *   and [MIO_PTP_CLOCK_HI/LO] >=  [MIO_PTP_PPS_THRESH_HI/LO], the pre-inverted PTP_PPS will
+ *   update to one, and [MIO_PTP_PPS_THRESH_HI/LO] will increment by MIO_PTP_PPS_HI_INCR.
+ *   When current PTP_PPS before inversion (defined by MIO_PTP_CLOCK_CFG[PPS_INV]) is one,
+ *   and [MIO_PTP_CLOCK_HI/LO] >=  [MIO_PTP_PPS_THRESH_HI/LO], the pre-inverted PTP_PPS will
+ *   update to zero, and [MIO_PTP_PPS_THRESH_HI/LO] will increment by MIO_PTP_PPS_LO_INCR.
  */
 union cvmx_mio_ptp_pps_thresh_hi {
 	uint64_t u64;
@@ -7403,6 +7978,7 @@ union cvmx_mio_ptp_pps_thresh_hi {
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn68xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn70xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn70xxp1;
+	struct cvmx_mio_ptp_pps_thresh_hi_s   cn73xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn78xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cnf71xx;
 };
@@ -7411,8 +7987,8 @@ typedef union cvmx_mio_ptp_pps_thresh_hi cvmx_mio_ptp_pps_thresh_hi_t;
 /**
  * cvmx_mio_ptp_pps_thresh_lo
  *
- * This register contains the low bytes of the PTP PPS.
- *
+ * This register contains the low bytes of the PTP PPS threshold.
+ * See MIO_PTP_PPS_THRESH_HI for details.
  */
 union cvmx_mio_ptp_pps_thresh_lo {
 	uint64_t u64;
@@ -7430,6 +8006,7 @@ union cvmx_mio_ptp_pps_thresh_lo {
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn68xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn70xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn70xxp1;
+	struct cvmx_mio_ptp_pps_thresh_lo_s   cn73xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn78xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cnf71xx;
 };
@@ -7458,6 +8035,7 @@ union cvmx_mio_ptp_timestamp {
 	struct cvmx_mio_ptp_timestamp_s       cn68xxp1;
 	struct cvmx_mio_ptp_timestamp_s       cn70xx;
 	struct cvmx_mio_ptp_timestamp_s       cn70xxp1;
+	struct cvmx_mio_ptp_timestamp_s       cn73xx;
 	struct cvmx_mio_ptp_timestamp_s       cn78xx;
 	struct cvmx_mio_ptp_timestamp_s       cnf71xx;
 };
@@ -9018,7 +9596,7 @@ union cvmx_mio_twsx_int {
 	struct cvmx_mio_twsx_int_s            cn68xxp1;
 	struct cvmx_mio_twsx_int_s            cn70xx;
 	struct cvmx_mio_twsx_int_s            cn70xxp1;
-	struct cvmx_mio_twsx_int_cn78xx {
+	struct cvmx_mio_twsx_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t scl                          : 1;  /**< SCL signal. */
@@ -9030,8 +9608,12 @@ union cvmx_mio_twsx_int {
                                                          0 = Normal operation, SDA bus controlled by TWSI core.
                                                          1 = Pull SDA low. */
 	uint64_t reserved_3_7                 : 5;
-	uint64_t core_int                     : 1;  /**< TWSI core interrupt. Ignored when the HLC is enabled. Throws
-                                                         TWS_INTSN_E::MIO_TWS()_INT_CORE. */
+	uint64_t core_int                     : 1;  /**< TWSI core interrupt. Ignored when the HLC is enabled.
+                                                         Throws TWS_INTSN_E::MIO_TWS()_INT_CORE.
+                                                         Writes 0 to TWSI control registers IFLG (TWSI_CTL bit 3) to clear
+                                                         TWS_INTSN_E::MIO_TWS()_INT_CORE interrupt.
+                                                         TWSI control registers (TWSI_CTL) can be accessible by MIO_TWS()_SW_TWSI, with
+                                                         OP=0x6 and EOP_IA = 0x2, see MIO_TWS()_SW_TWSI for details. */
 	uint64_t ts_int                       : 1;  /**< MIO_TWS()_TWSI_SW register-update interrupt. Ignored when the HLC is disabled. Throws
                                                          TWS_INTSN_E::MIO_TWS()_INT_TS. */
 	uint64_t st_int                       : 1;  /**< MIO_TWS()_SW_TWSI register-update interrupt. Ignored when the HLC is disabled. Throws
@@ -9047,12 +9629,35 @@ union cvmx_mio_twsx_int {
 	uint64_t scl                          : 1;
 	uint64_t reserved_12_63               : 52;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mio_twsx_int_cn73xx       cn78xx;
 	struct cvmx_mio_twsx_int_s            cnf71xx;
 };
 typedef union cvmx_mio_twsx_int cvmx_mio_twsx_int_t;
 
 /**
+ * cvmx_mio_tws#_int_w1s
+ */
+union cvmx_mio_twsx_int_w1s {
+	uint64_t u64;
+	struct cvmx_mio_twsx_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_3_63                : 61;
+	uint64_t core_int                     : 1;  /**< Reads MIO_TWS()_INT[CORE_INT]. */
+	uint64_t ts_int                       : 1;  /**< Reads or sets MIO_TWS()_INT[TS_INT]. */
+	uint64_t st_int                       : 1;  /**< Reads or sets MIO_TWS()_INT[ST_INT]. */
+#else
+	uint64_t st_int                       : 1;
+	uint64_t ts_int                       : 1;
+	uint64_t core_int                     : 1;
+	uint64_t reserved_3_63                : 61;
+#endif
+	} s;
+	struct cvmx_mio_twsx_int_w1s_s        cn73xx;
+};
+typedef union cvmx_mio_twsx_int_w1s cvmx_mio_twsx_int_w1s_t;
+
+/**
  * cvmx_mio_tws#_sw_twsi
  *
  * This register allows software to:
@@ -9186,6 +9791,7 @@ union cvmx_mio_twsx_sw_twsi {
 	struct cvmx_mio_twsx_sw_twsi_s        cn68xxp1;
 	struct cvmx_mio_twsx_sw_twsi_s        cn70xx;
 	struct cvmx_mio_twsx_sw_twsi_s        cn70xxp1;
+	struct cvmx_mio_twsx_sw_twsi_s        cn73xx;
 	struct cvmx_mio_twsx_sw_twsi_s        cn78xx;
 	struct cvmx_mio_twsx_sw_twsi_s        cnf71xx;
 };
@@ -9234,6 +9840,7 @@ union cvmx_mio_twsx_sw_twsi_ext {
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn68xxp1;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn70xx;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn70xxp1;
+	struct cvmx_mio_twsx_sw_twsi_ext_s    cn73xx;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn78xx;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cnf71xx;
 };
@@ -9295,7 +9902,7 @@ union cvmx_mio_twsx_twsi_sw {
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cn68xxp1;
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cn70xx;
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cn70xxp1;
-	struct cvmx_mio_twsx_twsi_sw_cn78xx {
+	struct cvmx_mio_twsx_twsi_sw_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t v                            : 2;  /**< Valid bits. These bits are not directly writable. They are set to 11 on any write
                                                          operation by the TWSI device. They are cleared to 00 on any read operation by software. */
@@ -9306,7 +9913,8 @@ union cvmx_mio_twsx_twsi_sw {
 	uint64_t reserved_32_61               : 30;
 	uint64_t v                            : 2;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mio_twsx_twsi_sw_cn73xx   cn78xx;
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cnf71xx;
 };
 typedef union cvmx_mio_twsx_twsi_sw cvmx_mio_twsx_twsi_sw_t;
@@ -9354,6 +9962,7 @@ union cvmx_mio_uartx_dlh {
 	struct cvmx_mio_uartx_dlh_s           cn68xxp1;
 	struct cvmx_mio_uartx_dlh_s           cn70xx;
 	struct cvmx_mio_uartx_dlh_s           cn70xxp1;
+	struct cvmx_mio_uartx_dlh_s           cn73xx;
 	struct cvmx_mio_uartx_dlh_s           cn78xx;
 	struct cvmx_mio_uartx_dlh_s           cnf71xx;
 };
@@ -9403,6 +10012,7 @@ union cvmx_mio_uartx_dll {
 	struct cvmx_mio_uartx_dll_s           cn68xxp1;
 	struct cvmx_mio_uartx_dll_s           cn70xx;
 	struct cvmx_mio_uartx_dll_s           cn70xxp1;
+	struct cvmx_mio_uartx_dll_s           cn73xx;
 	struct cvmx_mio_uartx_dll_s           cn78xx;
 	struct cvmx_mio_uartx_dll_s           cnf71xx;
 };
@@ -9449,6 +10059,7 @@ union cvmx_mio_uartx_far {
 	struct cvmx_mio_uartx_far_s           cn68xxp1;
 	struct cvmx_mio_uartx_far_s           cn70xx;
 	struct cvmx_mio_uartx_far_s           cn70xxp1;
+	struct cvmx_mio_uartx_far_s           cn73xx;
 	struct cvmx_mio_uartx_far_s           cn78xx;
 	struct cvmx_mio_uartx_far_s           cnf71xx;
 };
@@ -9502,6 +10113,7 @@ union cvmx_mio_uartx_fcr {
 	struct cvmx_mio_uartx_fcr_s           cn68xxp1;
 	struct cvmx_mio_uartx_fcr_s           cn70xx;
 	struct cvmx_mio_uartx_fcr_s           cn70xxp1;
+	struct cvmx_mio_uartx_fcr_s           cn73xx;
 	struct cvmx_mio_uartx_fcr_s           cn78xx;
 	struct cvmx_mio_uartx_fcr_s           cnf71xx;
 };
@@ -9545,6 +10157,7 @@ union cvmx_mio_uartx_htx {
 	struct cvmx_mio_uartx_htx_s           cn68xxp1;
 	struct cvmx_mio_uartx_htx_s           cn70xx;
 	struct cvmx_mio_uartx_htx_s           cn70xxp1;
+	struct cvmx_mio_uartx_htx_s           cn73xx;
 	struct cvmx_mio_uartx_htx_s           cn78xx;
 	struct cvmx_mio_uartx_htx_s           cnf71xx;
 };
@@ -9603,7 +10216,26 @@ union cvmx_mio_uartx_ier {
 	struct cvmx_mio_uartx_ier_s           cn68xxp1;
 	struct cvmx_mio_uartx_ier_s           cn70xx;
 	struct cvmx_mio_uartx_ier_s           cn70xxp1;
-	struct cvmx_mio_uartx_ier_s           cn78xx;
+	struct cvmx_mio_uartx_ier_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t ptime                        : 1;  /**< Programmable THRE interrupt-mode enable. */
+	uint64_t reserved_6_4                 : 3;
+	uint64_t edssi                        : 1;  /**< Enable modem status interrupt. */
+	uint64_t elsi                         : 1;  /**< Enable receiver line status interrupt. */
+	uint64_t etbei                        : 1;  /**< Enable transmitter holding register empty interrupt. */
+	uint64_t erbfi                        : 1;  /**< Enable received data available interrupt. */
+#else
+	uint64_t erbfi                        : 1;
+	uint64_t etbei                        : 1;
+	uint64_t elsi                         : 1;
+	uint64_t edssi                        : 1;
+	uint64_t reserved_6_4                 : 3;
+	uint64_t ptime                        : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} cn73xx;
+	struct cvmx_mio_uartx_ier_cn73xx      cn78xx;
 	struct cvmx_mio_uartx_ier_s           cnf71xx;
 };
 typedef union cvmx_mio_uartx_ier cvmx_mio_uartx_ier_t;
@@ -9649,6 +10281,7 @@ union cvmx_mio_uartx_iir {
 	struct cvmx_mio_uartx_iir_s           cn68xxp1;
 	struct cvmx_mio_uartx_iir_s           cn70xx;
 	struct cvmx_mio_uartx_iir_s           cn70xxp1;
+	struct cvmx_mio_uartx_iir_s           cn73xx;
 	struct cvmx_mio_uartx_iir_s           cn78xx;
 	struct cvmx_mio_uartx_iir_s           cnf71xx;
 };
@@ -9703,6 +10336,7 @@ union cvmx_mio_uartx_lcr {
 	struct cvmx_mio_uartx_lcr_s           cn68xxp1;
 	struct cvmx_mio_uartx_lcr_s           cn70xx;
 	struct cvmx_mio_uartx_lcr_s           cn70xxp1;
+	struct cvmx_mio_uartx_lcr_s           cn73xx;
 	struct cvmx_mio_uartx_lcr_s           cn78xx;
 	struct cvmx_mio_uartx_lcr_s           cnf71xx;
 };
@@ -9759,6 +10393,7 @@ union cvmx_mio_uartx_lsr {
 	struct cvmx_mio_uartx_lsr_s           cn68xxp1;
 	struct cvmx_mio_uartx_lsr_s           cn70xx;
 	struct cvmx_mio_uartx_lsr_s           cn70xxp1;
+	struct cvmx_mio_uartx_lsr_s           cn73xx;
 	struct cvmx_mio_uartx_lsr_s           cn78xx;
 	struct cvmx_mio_uartx_lsr_s           cnf71xx;
 };
@@ -9812,6 +10447,7 @@ union cvmx_mio_uartx_mcr {
 	struct cvmx_mio_uartx_mcr_s           cn68xxp1;
 	struct cvmx_mio_uartx_mcr_s           cn70xx;
 	struct cvmx_mio_uartx_mcr_s           cn70xxp1;
+	struct cvmx_mio_uartx_mcr_s           cn73xx;
 	struct cvmx_mio_uartx_mcr_s           cn78xx;
 	struct cvmx_mio_uartx_mcr_s           cnf71xx;
 };
@@ -9868,6 +10504,7 @@ union cvmx_mio_uartx_msr {
 	struct cvmx_mio_uartx_msr_s           cn68xxp1;
 	struct cvmx_mio_uartx_msr_s           cn70xx;
 	struct cvmx_mio_uartx_msr_s           cn70xxp1;
+	struct cvmx_mio_uartx_msr_s           cn73xx;
 	struct cvmx_mio_uartx_msr_s           cn78xx;
 	struct cvmx_mio_uartx_msr_s           cnf71xx;
 };
@@ -9911,6 +10548,7 @@ union cvmx_mio_uartx_rbr {
 	struct cvmx_mio_uartx_rbr_s           cn68xxp1;
 	struct cvmx_mio_uartx_rbr_s           cn70xx;
 	struct cvmx_mio_uartx_rbr_s           cn70xxp1;
+	struct cvmx_mio_uartx_rbr_s           cn73xx;
 	struct cvmx_mio_uartx_rbr_s           cn78xx;
 	struct cvmx_mio_uartx_rbr_s           cnf71xx;
 };
@@ -9953,6 +10591,7 @@ union cvmx_mio_uartx_rfl {
 	struct cvmx_mio_uartx_rfl_s           cn68xxp1;
 	struct cvmx_mio_uartx_rfl_s           cn70xx;
 	struct cvmx_mio_uartx_rfl_s           cn70xxp1;
+	struct cvmx_mio_uartx_rfl_s           cn73xx;
 	struct cvmx_mio_uartx_rfl_s           cn78xx;
 	struct cvmx_mio_uartx_rfl_s           cnf71xx;
 };
@@ -9999,6 +10638,7 @@ union cvmx_mio_uartx_rfw {
 	struct cvmx_mio_uartx_rfw_s           cn68xxp1;
 	struct cvmx_mio_uartx_rfw_s           cn70xx;
 	struct cvmx_mio_uartx_rfw_s           cn70xxp1;
+	struct cvmx_mio_uartx_rfw_s           cn73xx;
 	struct cvmx_mio_uartx_rfw_s           cn78xx;
 	struct cvmx_mio_uartx_rfw_s           cnf71xx;
 };
@@ -10042,6 +10682,7 @@ union cvmx_mio_uartx_sbcr {
 	struct cvmx_mio_uartx_sbcr_s          cn68xxp1;
 	struct cvmx_mio_uartx_sbcr_s          cn70xx;
 	struct cvmx_mio_uartx_sbcr_s          cn70xxp1;
+	struct cvmx_mio_uartx_sbcr_s          cn73xx;
 	struct cvmx_mio_uartx_sbcr_s          cn78xx;
 	struct cvmx_mio_uartx_sbcr_s          cnf71xx;
 };
@@ -10084,6 +10725,7 @@ union cvmx_mio_uartx_scr {
 	struct cvmx_mio_uartx_scr_s           cn68xxp1;
 	struct cvmx_mio_uartx_scr_s           cn70xx;
 	struct cvmx_mio_uartx_scr_s           cn70xxp1;
+	struct cvmx_mio_uartx_scr_s           cn73xx;
 	struct cvmx_mio_uartx_scr_s           cn78xx;
 	struct cvmx_mio_uartx_scr_s           cnf71xx;
 };
@@ -10128,6 +10770,7 @@ union cvmx_mio_uartx_sfe {
 	struct cvmx_mio_uartx_sfe_s           cn68xxp1;
 	struct cvmx_mio_uartx_sfe_s           cn70xx;
 	struct cvmx_mio_uartx_sfe_s           cn70xxp1;
+	struct cvmx_mio_uartx_sfe_s           cn73xx;
 	struct cvmx_mio_uartx_sfe_s           cn78xx;
 	struct cvmx_mio_uartx_sfe_s           cnf71xx;
 };
@@ -10174,6 +10817,7 @@ union cvmx_mio_uartx_srr {
 	struct cvmx_mio_uartx_srr_s           cn68xxp1;
 	struct cvmx_mio_uartx_srr_s           cn70xx;
 	struct cvmx_mio_uartx_srr_s           cn70xxp1;
+	struct cvmx_mio_uartx_srr_s           cn73xx;
 	struct cvmx_mio_uartx_srr_s           cn78xx;
 	struct cvmx_mio_uartx_srr_s           cnf71xx;
 };
@@ -10218,6 +10862,7 @@ union cvmx_mio_uartx_srt {
 	struct cvmx_mio_uartx_srt_s           cn68xxp1;
 	struct cvmx_mio_uartx_srt_s           cn70xx;
 	struct cvmx_mio_uartx_srt_s           cn70xxp1;
+	struct cvmx_mio_uartx_srt_s           cn73xx;
 	struct cvmx_mio_uartx_srt_s           cn78xx;
 	struct cvmx_mio_uartx_srt_s           cnf71xx;
 };
@@ -10261,6 +10906,7 @@ union cvmx_mio_uartx_srts {
 	struct cvmx_mio_uartx_srts_s          cn68xxp1;
 	struct cvmx_mio_uartx_srts_s          cn70xx;
 	struct cvmx_mio_uartx_srts_s          cn70xxp1;
+	struct cvmx_mio_uartx_srts_s          cn73xx;
 	struct cvmx_mio_uartx_srts_s          cn78xx;
 	struct cvmx_mio_uartx_srts_s          cnf71xx;
 };
@@ -10305,6 +10951,7 @@ union cvmx_mio_uartx_stt {
 	struct cvmx_mio_uartx_stt_s           cn68xxp1;
 	struct cvmx_mio_uartx_stt_s           cn70xx;
 	struct cvmx_mio_uartx_stt_s           cn70xxp1;
+	struct cvmx_mio_uartx_stt_s           cn73xx;
 	struct cvmx_mio_uartx_stt_s           cn78xx;
 	struct cvmx_mio_uartx_stt_s           cnf71xx;
 };
@@ -10347,6 +10994,7 @@ union cvmx_mio_uartx_tfl {
 	struct cvmx_mio_uartx_tfl_s           cn68xxp1;
 	struct cvmx_mio_uartx_tfl_s           cn70xx;
 	struct cvmx_mio_uartx_tfl_s           cn70xxp1;
+	struct cvmx_mio_uartx_tfl_s           cn73xx;
 	struct cvmx_mio_uartx_tfl_s           cn78xx;
 	struct cvmx_mio_uartx_tfl_s           cnf71xx;
 };
@@ -10389,6 +11037,7 @@ union cvmx_mio_uartx_tfr {
 	struct cvmx_mio_uartx_tfr_s           cn68xxp1;
 	struct cvmx_mio_uartx_tfr_s           cn70xx;
 	struct cvmx_mio_uartx_tfr_s           cn70xxp1;
+	struct cvmx_mio_uartx_tfr_s           cn73xx;
 	struct cvmx_mio_uartx_tfr_s           cn78xx;
 	struct cvmx_mio_uartx_tfr_s           cnf71xx;
 };
@@ -10432,6 +11081,7 @@ union cvmx_mio_uartx_thr {
 	struct cvmx_mio_uartx_thr_s           cn68xxp1;
 	struct cvmx_mio_uartx_thr_s           cn70xx;
 	struct cvmx_mio_uartx_thr_s           cn70xxp1;
+	struct cvmx_mio_uartx_thr_s           cn73xx;
 	struct cvmx_mio_uartx_thr_s           cn78xx;
 	struct cvmx_mio_uartx_thr_s           cnf71xx;
 };
@@ -10482,6 +11132,7 @@ union cvmx_mio_uartx_usr {
 	struct cvmx_mio_uartx_usr_s           cn68xxp1;
 	struct cvmx_mio_uartx_usr_s           cn70xx;
 	struct cvmx_mio_uartx_usr_s           cn70xxp1;
+	struct cvmx_mio_uartx_usr_s           cn73xx;
 	struct cvmx_mio_uartx_usr_s           cn78xx;
 	struct cvmx_mio_uartx_usr_s           cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
index a43098c..5f8dd33 100644
--- a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
@@ -62,6 +62,7 @@ static inline uint64_t CVMX_MIXX_BIST(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_BIST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100078ull) + ((offset) & 1) * 2048;
@@ -79,6 +80,7 @@ static inline uint64_t CVMX_MIXX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100020ull) + ((offset) & 1) * 2048;
@@ -112,6 +114,7 @@ static inline uint64_t CVMX_MIXX_IRCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100030ull) + ((offset) & 1) * 2048;
@@ -129,6 +132,7 @@ static inline uint64_t CVMX_MIXX_IRHWM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRHWM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100028ull) + ((offset) & 1) * 2048;
@@ -146,6 +150,7 @@ static inline uint64_t CVMX_MIXX_IRING1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRING1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100010ull) + ((offset) & 1) * 2048;
@@ -163,6 +168,7 @@ static inline uint64_t CVMX_MIXX_IRING2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRING2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100018ull) + ((offset) & 1) * 2048;
@@ -180,6 +186,7 @@ static inline uint64_t CVMX_MIXX_ISR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ISR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100048ull) + ((offset) & 1) * 2048;
@@ -188,6 +195,17 @@ static inline uint64_t CVMX_MIXX_ISR(unsigned long offset)
 #define CVMX_MIXX_ISR(offset) (CVMX_ADD_IO_SEG(0x0001070000100048ull) + ((offset) & 1) * 2048)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_MIXX_ISR_W1S(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_MIXX_ISR_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070000100050ull) + ((offset) & 1) * 2048;
+}
+#else
+#define CVMX_MIXX_ISR_W1S(offset) (CVMX_ADD_IO_SEG(0x0001070000100050ull) + ((offset) & 1) * 2048)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIXX_ORCNT(unsigned long offset)
 {
 	if (!(
@@ -197,6 +215,7 @@ static inline uint64_t CVMX_MIXX_ORCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100040ull) + ((offset) & 1) * 2048;
@@ -214,6 +233,7 @@ static inline uint64_t CVMX_MIXX_ORHWM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORHWM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100038ull) + ((offset) & 1) * 2048;
@@ -231,6 +251,7 @@ static inline uint64_t CVMX_MIXX_ORING1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORING1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100000ull) + ((offset) & 1) * 2048;
@@ -248,6 +269,7 @@ static inline uint64_t CVMX_MIXX_ORING2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORING2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100008ull) + ((offset) & 1) * 2048;
@@ -265,6 +287,7 @@ static inline uint64_t CVMX_MIXX_REMCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_REMCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100058ull) + ((offset) & 1) * 2048;
@@ -280,6 +303,7 @@ static inline uint64_t CVMX_MIXX_TSCTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_TSCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100068ull) + ((offset) & 1) * 2048;
@@ -295,6 +319,7 @@ static inline uint64_t CVMX_MIXX_TSTAMP(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_TSTAMP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100060ull) + ((offset) & 1) * 2048;
@@ -362,6 +387,7 @@ union cvmx_mixx_bist {
 	struct cvmx_mixx_bist_s               cn66xx;
 	struct cvmx_mixx_bist_s               cn68xx;
 	struct cvmx_mixx_bist_s               cn68xxp1;
+	struct cvmx_mixx_bist_s               cn73xx;
 	struct cvmx_mixx_bist_s               cn78xx;
 };
 typedef union cvmx_mixx_bist cvmx_mixx_bist_t;
@@ -538,6 +564,7 @@ union cvmx_mixx_ctl {
 	struct cvmx_mixx_ctl_s                cn66xx;
 	struct cvmx_mixx_ctl_s                cn68xx;
 	struct cvmx_mixx_ctl_s                cn68xxp1;
+	struct cvmx_mixx_ctl_s                cn73xx;
 	struct cvmx_mixx_ctl_s                cn78xx;
 };
 typedef union cvmx_mixx_ctl cvmx_mixx_ctl_t;
@@ -710,6 +737,7 @@ union cvmx_mixx_ircnt {
 	struct cvmx_mixx_ircnt_s              cn66xx;
 	struct cvmx_mixx_ircnt_s              cn68xx;
 	struct cvmx_mixx_ircnt_s              cn68xxp1;
+	struct cvmx_mixx_ircnt_s              cn73xx;
 	struct cvmx_mixx_ircnt_s              cn78xx;
 };
 typedef union cvmx_mixx_ircnt cvmx_mixx_ircnt_t;
@@ -753,6 +781,7 @@ union cvmx_mixx_irhwm {
 	struct cvmx_mixx_irhwm_s              cn66xx;
 	struct cvmx_mixx_irhwm_s              cn68xx;
 	struct cvmx_mixx_irhwm_s              cn68xxp1;
+	struct cvmx_mixx_irhwm_s              cn73xx;
 	struct cvmx_mixx_irhwm_s              cn78xx;
 };
 typedef union cvmx_mixx_irhwm cvmx_mixx_irhwm_t;
@@ -823,7 +852,7 @@ union cvmx_mixx_iring1 {
 	struct cvmx_mixx_iring1_cn61xx        cn66xx;
 	struct cvmx_mixx_iring1_cn61xx        cn68xx;
 	struct cvmx_mixx_iring1_cn61xx        cn68xxp1;
-	struct cvmx_mixx_iring1_cn78xx {
+	struct cvmx_mixx_iring1_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t isize                        : 20; /**< Represents the inbound ring (I-Ring) buffer's size (in 8-byte words). The ring can be as
                                                          large as 1MB entries.
@@ -839,7 +868,8 @@ union cvmx_mixx_iring1 {
 	uint64_t reserved_42_43               : 2;
 	uint64_t isize                        : 20;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mixx_iring1_cn73xx        cn78xx;
 };
 typedef union cvmx_mixx_iring1 cvmx_mixx_iring1_t;
 
@@ -887,6 +917,7 @@ union cvmx_mixx_iring2 {
 	struct cvmx_mixx_iring2_s             cn66xx;
 	struct cvmx_mixx_iring2_s             cn68xx;
 	struct cvmx_mixx_iring2_s             cn68xxp1;
+	struct cvmx_mixx_iring2_s             cn73xx;
 	struct cvmx_mixx_iring2_s             cn78xx;
 };
 typedef union cvmx_mixx_iring2 cvmx_mixx_iring2_t;
@@ -1083,11 +1114,94 @@ union cvmx_mixx_isr {
 	struct cvmx_mixx_isr_s                cn66xx;
 	struct cvmx_mixx_isr_s                cn68xx;
 	struct cvmx_mixx_isr_s                cn68xxp1;
+	struct cvmx_mixx_isr_s                cn73xx;
 	struct cvmx_mixx_isr_s                cn78xx;
 };
 typedef union cvmx_mixx_isr cvmx_mixx_isr_t;
 
 /**
+ * cvmx_mix#_isr_w1s
+ */
+union cvmx_mixx_isr_w1s {
+	uint64_t u64;
+	struct cvmx_mixx_isr_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t ts                           : 1;  /**< Timestamp interrupt. Throws MIX_INTSN_E:MIX(0..1)_INT_TS. This bit is set and the
+                                                         interrupt generated when the number of pending timestamp interrupts
+                                                         (MIX(0..1)_TSCTL[TSCNT]) is greater than the timestamp interrupt threshold
+                                                         (MIX(0..1)_CTL[TS_THRESH]) value. */
+	uint64_t orun                         : 1;  /**< O-ring packet count underflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_ORUN. If
+                                                         software writes a larger value than what is currently in the MIX(0..1)_ORCNT[ORCNT], then
+                                                         hardware reports the underflow condition.
+                                                         The MIX(0..1)_ORCNT[IOCNT] will clamp to zero.
+                                                         If an ORUN underflow condition is detected, the integrity of the MIX hardware state has
+                                                         been compromised. To recover, software must issue a software reset sequence. (See
+                                                         MIX(0..1)_CTL[RESET.] */
+	uint64_t irun                         : 1;  /**< I-ring packet count underflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_IRUN. If
+                                                         software writes a larger value than what is currently in the MIX(0..1)_IRCNT[IRCNT], then
+                                                         hardware reports the underflow condition.
+                                                         The MIX(0..1)_IRCNT[IRCNT] will clamp to zero.
+                                                         If an IRUN underflow condition is detected, the integrity of the MIX hardware state has
+                                                         been compromised. To recover, software must issue a software reset sequence. (See
+                                                         MIX(0..1)_CTL[RESET]). */
+	uint64_t data_drp                     : 1;  /**< Data was dropped due to RX FIFO full. Throws MIX_INTSN_E::MIX(0..1)_INT_DATA_DRP. If this
+                                                         event does occur, DATA_DRP is set and the interrupt is generated. */
+	uint64_t irthresh                     : 1;  /**< Inbound ring packet threshold exceeded. Throws MIX_INTSN_E::MIX(0..1)_INT_IRTHRESH. When
+                                                         the pending number of inbound packets in system memory (IRCNT) has exceeded a programmable
+                                                         threshold (IRHWM), this bit is set and the interrupt is generated. To service this
+                                                         interrupt, the IRCNT must first be lowered below the IRHWM before the W1C to this field. */
+	uint64_t orthresh                     : 1;  /**< Outbound ring packet threshold exceeded. Throws MIX_INTSN_E::MIX(0..1)_INT_ORTHRESH. When
+                                                         the pending number of outbound packets in system memory (ORCNT) has exceeded a
+                                                         programmable threshold (ORHWM), this bit is set and the interrupt is generated. To service
+                                                         this interrupt, the ORCNT must first be lowered below the ORHWM before the W1C to this
+                                                         field. */
+	uint64_t idblovf                      : 1;  /**< Inbound doorbell (IDBELL) overflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_IDBLOVF.
+                                                         If software attempts to write to the MIX(0..1)_IRING2[IDBELL] with a value greater than
+                                                         the remaining number of I-Ring buffer entries (MIX(0..1)_REMCNT[IREMCNT]), then the
+                                                         following occurs:
+                                                         * The MIX(0..1)_IRING2[IDBELL] write is IGNORED.
+                                                         * IDBLOVF is set and the interrupt is generated.
+                                                         Software should keep track of the number of I-Ring entries in use (i.e. the cumulative
+                                                         number
+                                                         of IDBELL write operations), and ensure that future IDBELL write operations don't exceed
+                                                         the size of the I-Ring Buffer (MIX(0..1)_IRING2[ISIZE]). Software must reclaim I-Ring
+                                                         entries by keeping track of the number of I-Ring entries, and writing to the
+                                                         MIX(0..1)_IRCNT[IRCNT].
+                                                         The MIX(0..1)_IRCNT[IRCNT] register represents the total number of packets (not I-Ring
+                                                         entries) and software must further keep track of the number of I-Ring entries associated
+                                                         with each packet as they are processed.
+                                                         If an IDBLOVF occurs, it is an indication that software has overwritten the I-Ring buffer,
+                                                         and the only recourse for recovery is a hardware reset. */
+	uint64_t odblovf                      : 1;  /**< Outbound doorbell (ODBELL) overflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_ODBLOVF.
+                                                         If software attempts to write to MIX(0..1)_ORING2[ODBELL] with a value greater than the
+                                                         remaining number of O-Ring buffer entries (MIX(0..1)_REMCNT[OREMCNT]), then the following
+                                                         occurs:
+                                                         * The MIX(0..1)_IRING2[ODBELL] write operation is IGNORED.
+                                                         * ODBLOVF is set and the interrupt is generated.
+                                                         Software should keep track of the number of I-Ring entries in use (i.e. the cumulative
+                                                         number of ODBELL write operations), and ensure that future ODBELL write operations don't
+                                                         exceed the size of the O-Ring buffer (MIX(0..1)_ORING2[OSIZE]). Software must reclaim
+                                                         O-Ring entries by writing to MIX(0..1)_ORCNT[ORCNT].
+                                                         If an ODBLOVF occurs, it is an indication that software has overwritten the O-Ring buffer,
+                                                         and the only recourse for recovery is a hardware reset. */
+#else
+	uint64_t odblovf                      : 1;
+	uint64_t idblovf                      : 1;
+	uint64_t orthresh                     : 1;
+	uint64_t irthresh                     : 1;
+	uint64_t data_drp                     : 1;
+	uint64_t irun                         : 1;
+	uint64_t orun                         : 1;
+	uint64_t ts                           : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_mixx_isr_w1s_s            cn73xx;
+};
+typedef union cvmx_mixx_isr_w1s cvmx_mixx_isr_w1s_t;
+
+/**
  * cvmx_mix#_orcnt
  *
  * MIX_ORCNT = MIX O-Ring Packets Sent Counter
@@ -1126,6 +1240,7 @@ union cvmx_mixx_orcnt {
 	struct cvmx_mixx_orcnt_s              cn66xx;
 	struct cvmx_mixx_orcnt_s              cn68xx;
 	struct cvmx_mixx_orcnt_s              cn68xxp1;
+	struct cvmx_mixx_orcnt_s              cn73xx;
 	struct cvmx_mixx_orcnt_s              cn78xx;
 };
 typedef union cvmx_mixx_orcnt cvmx_mixx_orcnt_t;
@@ -1162,6 +1277,7 @@ union cvmx_mixx_orhwm {
 	struct cvmx_mixx_orhwm_s              cn66xx;
 	struct cvmx_mixx_orhwm_s              cn68xx;
 	struct cvmx_mixx_orhwm_s              cn68xxp1;
+	struct cvmx_mixx_orhwm_s              cn73xx;
 	struct cvmx_mixx_orhwm_s              cn78xx;
 };
 typedef union cvmx_mixx_orhwm cvmx_mixx_orhwm_t;
@@ -1232,7 +1348,7 @@ union cvmx_mixx_oring1 {
 	struct cvmx_mixx_oring1_cn61xx        cn66xx;
 	struct cvmx_mixx_oring1_cn61xx        cn68xx;
 	struct cvmx_mixx_oring1_cn61xx        cn68xxp1;
-	struct cvmx_mixx_oring1_cn78xx {
+	struct cvmx_mixx_oring1_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t osize                        : 20; /**< Represents the outbound ring (O-Ring) buffer's size (in 8-byte words). The ring can be as
                                                          large as 1MB entries.
@@ -1248,7 +1364,8 @@ union cvmx_mixx_oring1 {
 	uint64_t reserved_42_43               : 2;
 	uint64_t osize                        : 20;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mixx_oring1_cn73xx        cn78xx;
 };
 typedef union cvmx_mixx_oring1 cvmx_mixx_oring1_t;
 
@@ -1296,6 +1413,7 @@ union cvmx_mixx_oring2 {
 	struct cvmx_mixx_oring2_s             cn66xx;
 	struct cvmx_mixx_oring2_s             cn68xx;
 	struct cvmx_mixx_oring2_s             cn68xxp1;
+	struct cvmx_mixx_oring2_s             cn73xx;
 	struct cvmx_mixx_oring2_s             cn78xx;
 };
 typedef union cvmx_mixx_oring2 cvmx_mixx_oring2_t;
@@ -1345,6 +1463,7 @@ union cvmx_mixx_remcnt {
 	struct cvmx_mixx_remcnt_s             cn66xx;
 	struct cvmx_mixx_remcnt_s             cn68xx;
 	struct cvmx_mixx_remcnt_s             cn68xxp1;
+	struct cvmx_mixx_remcnt_s             cn73xx;
 	struct cvmx_mixx_remcnt_s             cn78xx;
 };
 typedef union cvmx_mixx_remcnt cvmx_mixx_remcnt_t;
@@ -1399,6 +1518,7 @@ union cvmx_mixx_tsctl {
 	struct cvmx_mixx_tsctl_s              cn66xx;
 	struct cvmx_mixx_tsctl_s              cn68xx;
 	struct cvmx_mixx_tsctl_s              cn68xxp1;
+	struct cvmx_mixx_tsctl_s              cn73xx;
 	struct cvmx_mixx_tsctl_s              cn78xx;
 };
 typedef union cvmx_mixx_tsctl cvmx_mixx_tsctl_t;
@@ -1447,6 +1567,7 @@ union cvmx_mixx_tstamp {
 	struct cvmx_mixx_tstamp_s             cn66xx;
 	struct cvmx_mixx_tstamp_s             cn68xx;
 	struct cvmx_mixx_tstamp_s             cn68xxp1;
+	struct cvmx_mixx_tstamp_s             cn73xx;
 	struct cvmx_mixx_tstamp_s             cn78xx;
 };
 typedef union cvmx_mixx_tstamp cvmx_mixx_tstamp_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
index e921c30..79fc801 100644
--- a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_MPI_CFG CVMX_MPI_CFG_FUNC()
 static inline uint64_t CVMX_MPI_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001000ull);
 }
@@ -73,6 +73,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 8))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_MPI_DATX(%lu) is invalid on this chip\n", offset);
@@ -85,7 +86,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 #define CVMX_MPI_STS CVMX_MPI_STS_FUNC()
 static inline uint64_t CVMX_MPI_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001008ull);
 }
@@ -93,10 +94,21 @@ static inline uint64_t CVMX_MPI_STS_FUNC(void)
 #define CVMX_MPI_STS (CVMX_ADD_IO_SEG(0x0001070000001008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_MPI_STS_W1S CVMX_MPI_STS_W1S_FUNC()
+static inline uint64_t CVMX_MPI_STS_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_MPI_STS_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070000001018ull);
+}
+#else
+#define CVMX_MPI_STS_W1S (CVMX_ADD_IO_SEG(0x0001070000001018ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_MPI_TX CVMX_MPI_TX_FUNC()
 static inline uint64_t CVMX_MPI_TX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_TX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001010ull);
 }
@@ -107,7 +119,7 @@ static inline uint64_t CVMX_MPI_TX_FUNC(void)
 #define CVMX_MPI_WIDE_DAT CVMX_MPI_WIDE_DAT_FUNC()
 static inline uint64_t CVMX_MPI_WIDE_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MPI_WIDE_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001040ull);
 }
@@ -511,7 +523,7 @@ union cvmx_mpi_cfg {
 #endif
 	} cn70xx;
 	struct cvmx_mpi_cfg_cn70xx            cn70xxp1;
-	struct cvmx_mpi_cfg_cn78xx {
+	struct cvmx_mpi_cfg_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
 	uint64_t clkdiv                       : 13; /**< Clock divisor.
@@ -579,7 +591,8 @@ union cvmx_mpi_cfg {
 	uint64_t clkdiv                       : 13;
 	uint64_t reserved_29_63               : 35;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mpi_cfg_cn73xx            cn78xx;
 	struct cvmx_mpi_cfg_cn61xx            cnf71xx;
 };
 typedef union cvmx_mpi_cfg cvmx_mpi_cfg_t;
@@ -605,6 +618,7 @@ union cvmx_mpi_datx {
 	struct cvmx_mpi_datx_s                cn66xx;
 	struct cvmx_mpi_datx_s                cn70xx;
 	struct cvmx_mpi_datx_s                cn70xxp1;
+	struct cvmx_mpi_datx_s                cn73xx;
 	struct cvmx_mpi_datx_s                cn78xx;
 	struct cvmx_mpi_datx_s                cnf71xx;
 };
@@ -651,12 +665,36 @@ union cvmx_mpi_sts {
 	struct cvmx_mpi_sts_cn30xx            cn66xx;
 	struct cvmx_mpi_sts_cn30xx            cn70xx;
 	struct cvmx_mpi_sts_cn30xx            cn70xxp1;
+	struct cvmx_mpi_sts_s                 cn73xx;
 	struct cvmx_mpi_sts_s                 cn78xx;
 	struct cvmx_mpi_sts_cn30xx            cnf71xx;
 };
 typedef union cvmx_mpi_sts cvmx_mpi_sts_t;
 
 /**
+ * cvmx_mpi_sts_w1s
+ *
+ * This register sets MPI_STS() interrupts.
+ *
+ */
+union cvmx_mpi_sts_w1s {
+	uint64_t u64;
+	struct cvmx_mpi_sts_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t mpi_intr_w1s                 : 1;  /**< Reads or sets MPI_STS[MPI_INTR]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t mpi_intr_w1s                 : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_mpi_sts_w1s_s             cn73xx;
+};
+typedef union cvmx_mpi_sts_w1s cvmx_mpi_sts_w1s_t;
+
+/**
  * cvmx_mpi_tx
  */
 union cvmx_mpi_tx {
@@ -726,8 +764,30 @@ union cvmx_mpi_tx {
 #endif
 	} cn61xx;
 	struct cvmx_mpi_tx_s                  cn66xx;
-	struct cvmx_mpi_tx_s                  cn70xx;
-	struct cvmx_mpi_tx_s                  cn70xxp1;
+	struct cvmx_mpi_tx_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_63_22               : 42;
+	uint64_t csid                         : 2;  /**< Which CS to assert for this transaction */
+	uint64_t reserved_19_17               : 3;
+	uint64_t leavecs                      : 1;  /**< If 0, deassert CS after transaction is done
+                                                         1, leave CS asserted after transactrion is done */
+	uint64_t reserved_15_13               : 3;
+	uint64_t txnum                        : 5;  /**< Number of bytes to transmit */
+	uint64_t reserved_7_5                 : 3;
+	uint64_t totnum                       : 5;  /**< Number of bytes to shift (transmit + receive) */
+#else
+	uint64_t totnum                       : 5;
+	uint64_t reserved_7_5                 : 3;
+	uint64_t txnum                        : 5;
+	uint64_t reserved_15_13               : 3;
+	uint64_t leavecs                      : 1;
+	uint64_t reserved_19_17               : 3;
+	uint64_t csid                         : 2;
+	uint64_t reserved_63_22               : 42;
+#endif
+	} cn70xx;
+	struct cvmx_mpi_tx_cn70xx             cn70xxp1;
+	struct cvmx_mpi_tx_s                  cn73xx;
 	struct cvmx_mpi_tx_s                  cn78xx;
 	struct cvmx_mpi_tx_cn61xx             cnf71xx;
 };
@@ -750,6 +810,7 @@ union cvmx_mpi_wide_dat {
 	} s;
 	struct cvmx_mpi_wide_dat_s            cn70xx;
 	struct cvmx_mpi_wide_dat_s            cn70xxp1;
+	struct cvmx_mpi_wide_dat_s            cn73xx;
 	struct cvmx_mpi_wide_dat_s            cn78xx;
 };
 typedef union cvmx_mpi_wide_dat cvmx_mpi_wide_dat_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
index e1f3859..08dc547 100644
--- a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_NDF_BT_PG_INFO CVMX_NDF_BT_PG_INFO_FUNC()
 static inline uint64_t CVMX_NDF_BT_PG_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_BT_PG_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_NDF_BT_PG_INFO_FUNC(void)
 #define CVMX_NDF_CMD CVMX_NDF_CMD_FUNC()
 static inline uint64_t CVMX_NDF_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000000ull);
 }
@@ -75,10 +75,32 @@ static inline uint64_t CVMX_NDF_CMD_FUNC(void)
 #define CVMX_NDF_CMD (CVMX_ADD_IO_SEG(0x0001070001000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_NDF_DMA_ADR CVMX_NDF_DMA_ADR_FUNC()
+static inline uint64_t CVMX_NDF_DMA_ADR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_NDF_DMA_ADR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070001000058ull);
+}
+#else
+#define CVMX_NDF_DMA_ADR (CVMX_ADD_IO_SEG(0x0001070001000058ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_NDF_DMA_CFG CVMX_NDF_DMA_CFG_FUNC()
+static inline uint64_t CVMX_NDF_DMA_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_NDF_DMA_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070001000050ull);
+}
+#else
+#define CVMX_NDF_DMA_CFG (CVMX_ADD_IO_SEG(0x0001070001000050ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_NDF_DRBELL CVMX_NDF_DRBELL_FUNC()
 static inline uint64_t CVMX_NDF_DRBELL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_DRBELL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000030ull);
 }
@@ -89,7 +111,7 @@ static inline uint64_t CVMX_NDF_DRBELL_FUNC(void)
 #define CVMX_NDF_ECC_CNT CVMX_NDF_ECC_CNT_FUNC()
 static inline uint64_t CVMX_NDF_ECC_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_ECC_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000010ull);
 }
@@ -100,12 +122,37 @@ static inline uint64_t CVMX_NDF_ECC_CNT_FUNC(void)
 #define CVMX_NDF_INT CVMX_NDF_INT_FUNC()
 static inline uint64_t CVMX_NDF_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
-		cvmx_warn("CVMX_NDF_INT not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001070001000020ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070001000040ull);
+			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070001000020ull);
+			break;
+	}
+	cvmx_warn("CVMX_NDF_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070001000040ull);
 }
 #else
-#define CVMX_NDF_INT (CVMX_ADD_IO_SEG(0x0001070001000020ull))
+#define CVMX_NDF_INT CVMX_NDF_INT_FUNC()
+static inline uint64_t CVMX_NDF_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070001000040ull);
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070001000020ull);
+	}
+	return CVMX_ADD_IO_SEG(0x0001070001000040ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_NDF_INT_EN CVMX_NDF_INT_EN_FUNC()
@@ -119,10 +166,21 @@ static inline uint64_t CVMX_NDF_INT_EN_FUNC(void)
 #define CVMX_NDF_INT_EN (CVMX_ADD_IO_SEG(0x0001070001000028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_NDF_INT_W1S CVMX_NDF_INT_W1S_FUNC()
+static inline uint64_t CVMX_NDF_INT_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_NDF_INT_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070001000048ull);
+}
+#else
+#define CVMX_NDF_INT_W1S (CVMX_ADD_IO_SEG(0x0001070001000048ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_NDF_MISC CVMX_NDF_MISC_FUNC()
 static inline uint64_t CVMX_NDF_MISC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_MISC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000008ull);
 }
@@ -133,7 +191,7 @@ static inline uint64_t CVMX_NDF_MISC_FUNC(void)
 #define CVMX_NDF_ST_REG CVMX_NDF_ST_REG_FUNC()
 static inline uint64_t CVMX_NDF_ST_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_ST_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000038ull);
 }
@@ -144,28 +202,33 @@ static inline uint64_t CVMX_NDF_ST_REG_FUNC(void)
 /**
  * cvmx_ndf_bt_pg_info
  *
- * NDF_BT_PG_INFO provides page size and number of column plus row address cycles information. SW
- * writes to this CSR
- *   during boot from Nand Flash. Additionally SW also writes the multiplier value for timing
- * parameters. This value is
- *   used during boot, in the SET_TM_PARAM command. This information is used only by the boot
- * load state machine and is
- *   otherwise a don't care, once boot is disabled. Also, boot dma's do not use this value.
- * Bytes per Nand Flash page = 2 ** (SIZE + 1) times 256 bytes.
- *   512, 1k, 2k, 4k, 8k, 16k, 32k and 64k are legal bytes per page values
- * Legal values for ADR_CYC field are 3 through 8. SW CSR writes with a value less than 3 will
- * write a 3 to this
- *   field, and a SW CSR write with a value greater than 8, will write an 8 to this field.
+ * This register provides the page size and the number of column-plus-row address-cycle
+ * information. Software writes to this register during a boot operation from a NAND flash
+ * device.
+ *
+ * Additionally, software also writes the multiplier value for timing parameters that is used
+ * during the boot process, in the SET_TM_PARAM command. The multiplier value is used only by the
+ * boot-load state machine during boot operations. Boot DMA operations do not use this value.
+ *
+ * Sixty-four-bit operations must be used to access this register.
  */
 union cvmx_ndf_bt_pg_info {
 	uint64_t u64;
 	struct cvmx_ndf_bt_pg_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_11_63               : 53;
-	uint64_t t_mult                       : 4;  /**< Boot time TIM_MULT[3:0] field of SET__TM_PAR[63:0]
-                                                         command */
-	uint64_t adr_cyc                      : 4;  /**< # of column address cycles */
-	uint64_t size                         : 3;  /**< bytes per page in the nand device */
+	uint64_t t_mult                       : 4;  /**< The boot-time TIM_MULT field of the SET_TM_PAR command. */
+	uint64_t adr_cyc                      : 4;  /**< Number of column-address cycles. Legal values are 0x3 - 0x8. Values written to this field
+                                                         smaller than 0x3 are converted to 0x3; values larger than 0x8 are converted to 0x8. */
+	uint64_t size                         : 3;  /**< Number of bytes per page in the NAND flash device = 2^SIZE+1 * 256.
+                                                         0x0 = 512 bytes/page.
+                                                         0x1 = 1 KB/page.
+                                                         0x2 = 2 KB/page.
+                                                         0x3 = 4 KB/page.
+                                                         0x4 = 8 KB/page.
+                                                         0x5 = 16 KB/page.
+                                                         0x6 = 32 KB/page.
+                                                         0x7 = 64 KB/page. */
 #else
 	uint64_t size                         : 3;
 	uint64_t adr_cyc                      : 4;
@@ -181,25 +244,27 @@ union cvmx_ndf_bt_pg_info {
 	struct cvmx_ndf_bt_pg_info_s          cn68xxp1;
 	struct cvmx_ndf_bt_pg_info_s          cn70xx;
 	struct cvmx_ndf_bt_pg_info_s          cn70xxp1;
+	struct cvmx_ndf_bt_pg_info_s          cn73xx;
 };
 typedef union cvmx_ndf_bt_pg_info cvmx_ndf_bt_pg_info_t;
 
 /**
  * cvmx_ndf_cmd
  *
- * When SW reads this csr, RD_VAL bit in NDF_MISC csr is cleared to 0. SW must always write all 8
- * bytes whenever it writes
- * this csr. If there are fewer than 8 bytes left in the command sequence that SW wants the NAND
- * flash controller to execute, it
- * must insert Idle (WAIT) commands to make up 8 bytes. SW also must ensure there is enough
- * vacancy in the command fifo to accept these
- * 8 bytes, by first reading the FR_BYT field in the NDF_MISC csr.
+ * When software reads this register, NDF_MISC[RD_VAL] is cleared to 0. Software must always
+ * write all eight bytes whenever it writes this register. If there are fewer than eight bytes
+ * left in the command sequence that software wants the NAND flash controller to execute, it must
+ * insert Idle (WAIT) commands to make up eight bytes. Software must also ensure that there is
+ * enough space in the NDF_CMD queue to accept these eight bytes by first reading
+ * NDF_MISC[FR_BYT].
+ *
+ * Sixty-four-bit operations must be used to access this register.
  */
 union cvmx_ndf_cmd {
 	uint64_t u64;
 	struct cvmx_ndf_cmd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t nf_cmd                       : 64; /**< 8 Command Bytes */
+	uint64_t nf_cmd                       : 64; /**< Eight NAND flash memory command bytes. */
 #else
 	uint64_t nf_cmd                       : 64;
 #endif
@@ -212,46 +277,107 @@ union cvmx_ndf_cmd {
 	struct cvmx_ndf_cmd_s                 cn68xxp1;
 	struct cvmx_ndf_cmd_s                 cn70xx;
 	struct cvmx_ndf_cmd_s                 cn70xxp1;
+	struct cvmx_ndf_cmd_s                 cn73xx;
 };
 typedef union cvmx_ndf_cmd cvmx_ndf_cmd_t;
 
 /**
+ * cvmx_ndf_dma_adr
+ *
+ * Sixty-four-bit operations must be used to access this register.
+ *
+ */
+union cvmx_ndf_dma_adr {
+	uint64_t u64;
+	struct cvmx_ndf_dma_adr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t adr                          : 39; /**< DMA engine address. 64-bit aligned. */
+	uint64_t reserved_0_2                 : 3;
+#else
+	uint64_t reserved_0_2                 : 3;
+	uint64_t adr                          : 39;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} s;
+	struct cvmx_ndf_dma_adr_s             cn73xx;
+};
+typedef union cvmx_ndf_dma_adr cvmx_ndf_dma_adr_t;
+
+/**
+ * cvmx_ndf_dma_cfg
+ *
+ * Sixty-four-bit operations must be used to access this register.
+ *
+ */
+union cvmx_ndf_dma_cfg {
+	uint64_t u64;
+	struct cvmx_ndf_dma_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t en                           : 1;  /**< DMA engine enable.  This bit is cleared at the termination of the DMA. */
+	uint64_t rw                           : 1;  /**< DMA engine R/W bit: 0 = read, 1 = write. */
+	uint64_t clr                          : 1;  /**< DMA engine clear EN. When set to 1, DMA is terminated and EN is cleared and the DMA_DONE
+                                                         interrupt
+                                                         occurs when either the SIZE is exhausted (normal termination) or the NDF BUS_REL is
+                                                         issued. */
+	uint64_t reserved_60_60               : 1;
+	uint64_t swap32                       : 1;  /**< DMA engine 32-bit swap. */
+	uint64_t swap16                       : 1;  /**< DMA engine enable 16-bit swap. */
+	uint64_t swap8                        : 1;  /**< DMA engine enable 8-bit swap. */
+	uint64_t endian                       : 1;  /**< DMA engine endian mode: 0 = big-endian, 1 = little-endian. */
+	uint64_t size                         : 20; /**< DMA engine size. Specified in the number of 64-bit transfers (encoded in -1 notation). */
+	uint64_t reserved_0_35                : 36;
+#else
+	uint64_t reserved_0_35                : 36;
+	uint64_t size                         : 20;
+	uint64_t endian                       : 1;
+	uint64_t swap8                        : 1;
+	uint64_t swap16                       : 1;
+	uint64_t swap32                       : 1;
+	uint64_t reserved_60_60               : 1;
+	uint64_t clr                          : 1;
+	uint64_t rw                           : 1;
+	uint64_t en                           : 1;
+#endif
+	} s;
+	struct cvmx_ndf_dma_cfg_s             cn73xx;
+};
+typedef union cvmx_ndf_dma_cfg cvmx_ndf_dma_cfg_t;
+
+/**
  * cvmx_ndf_drbell
  *
- * SW csr writes will increment CNT by the signed 8 bit value being written. SW csr reads return
- * the current CNT value.
- * HW will also modify the value of the CNT field. Everytime HW executes a BUS_ACQ[15:0] command,
- * to arbitrate and win the
- * flash bus, it decrements the CNT field by 1. If the CNT field is already 0 or negative, HW
- * command execution unit will
- * stall when it fetches the new BUS_ACQ[15:0] command, from the command fifo. Only when the SW
- * writes to this CSR with a
- * non-zero data value, can the execution unit come out of the stalled condition, and resume
- * execution.
- * The intended use of this doorbell CSR is to control execution of the Nand Flash commands. The
- * NDF execution unit
- * has to arbitrate for the flash bus, before it can enable a Nand Flash device connected to the
- * Octeon chip, by
- * asserting the device's chip enable. Therefore SW should first load the command fifo, with a
- * full sequence of
- * commands to perform a Nand Flash device task. This command sequence will start with a bus
- * acquire command and
- * the last command in the sequence will be a bus release command. The execution unit will start
- * execution of
- * the sequence only if the [CNT] field is non-zero when it fetches the bus acquire command,
- * which is the first
- * command in this sequence. SW can also, load multiple such sequences, each starting with a chip
- * enable command
- * and ending with a chip disable command, and then write a non-zero data value to this csr to
- * increment the
- * CNT field by the number of the command sequences, loaded to the command fifo.
+ * This register is designed to control the execution of the NAND flash commands. The NDF
+ * command-execution unit must arbitrate for the boot bus before it can enable a NAND flash
+ * device connected to the CNXXXX, which it then does by asserting the device's chip-enable
+ * signal. Therefore software must first load the NDF_CMD queue, with a full sequence of commands
+ * to perform a NAND flash device task.
+ *
+ * This command sequence starts with a BUS_ACQ command, and the last command in the sequence must
+ * be a BUS_REL command. The execution unit starts execution of the sequence only if the
+ * NDF_DRBELL[CNT] is non-zero when it fetches the BUS_ACQ command.
+ *
+ * Software can load multiple such sequences, each starting with a CHIP_EN command and ending
+ * with a CHIP_DIS command, and then write a data value to this register to increment the CNT
+ * field by the number of the command sequences loaded to the NDF_CMD queue.
+ *
+ * Software register-write operations increment CNT by the signed 8-bit value being written.
+ * Software register-read operations return the current CNT value.
+ *
+ * Hardware can also modifies the value of CNT. Every time hardware executes a BUS_ACQ command to
+ * arbitrate and win the boot bus, it decrements CNT by 1. If CNT is already 0 or negative, the
+ * hardware command-execution unit stalls when it fetches the new BUS_ACQ command from the
+ * NDF_CMD queue. Only when the software writes to this register with a non-zero data value can
+ * the execution unit come out of the stalled condition, and resume execution.
+ *
+ * Sixty-four-bit operations must be used to access this register.
  */
 union cvmx_ndf_drbell {
 	uint64_t u64;
 	struct cvmx_ndf_drbell_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t cnt                          : 8;  /**< Doorbell count register, 2's complement 8 bit value */
+	uint64_t cnt                          : 8;  /**< Doorbell count, in 2s-complement format. */
 #else
 	uint64_t cnt                          : 8;
 	uint64_t reserved_8_63                : 56;
@@ -265,28 +391,30 @@ union cvmx_ndf_drbell {
 	struct cvmx_ndf_drbell_s              cn68xxp1;
 	struct cvmx_ndf_drbell_s              cn70xx;
 	struct cvmx_ndf_drbell_s              cn70xxp1;
+	struct cvmx_ndf_drbell_s              cn73xx;
 };
 typedef union cvmx_ndf_drbell cvmx_ndf_drbell_t;
 
 /**
  * cvmx_ndf_ecc_cnt
  *
- * Notes:
- * XOR_ECC[31:8] = [ecc_gen_byt258, ecc_gen_byt257, ecc_gen_byt256] xor [ecc_258, ecc_257, ecc_256]
- *         ecc_258, ecc_257 and ecc_256 are bytes stored in Nand Flash and read out during boot
- *         ecc_gen_byt258, ecc_gen_byt257, ecc_gen_byt256 are generated from data read out from Nand Flash
+ * Sixty-four-bit operations must be used to access this register.
  *
- * Like all NDF_... registers, 64-bit operations must be used to access this register
  */
 union cvmx_ndf_ecc_cnt {
 	uint64_t u64;
 	struct cvmx_ndf_ecc_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t xor_ecc                      : 24; /**< result of XOR of ecc read bytes and ecc genarated
-                                                         bytes. The value pertains to the last 1 bit ecc err */
-	uint64_t ecc_err                      : 8;  /**< "Count = \# of 1 bit errors fixed during boot
-                                                         This count saturates instead of wrapping around." */
+	uint64_t xor_ecc                      : 24; /**< Result of XOR operation of ECC read bytes and ECC generated bytes. The value pertains to
+                                                         the last single-bit ECC error.
+                                                         _ XOR_ECC =[ECC_gen_byt258, ECC_gen_byt257, ECC_gen_byt256] ^
+                                                           [ECC_258, ECC_257, ECC_256]
+                                                         ECC_258, ECC_257 and ECC_256 are bytes stored in the NAND flash device and read out during
+                                                         boot.
+                                                         ECC_gen_byt258, ECC_gen_byt257, ECC_gen_byt256 are generated from data read out from the
+                                                         NAND flash device. */
+	uint64_t ecc_err                      : 8;  /**< ECC error count. The number of single-bit errors fixed during boot. */
 #else
 	uint64_t ecc_err                      : 8;
 	uint64_t xor_ecc                      : 24;
@@ -301,22 +429,45 @@ union cvmx_ndf_ecc_cnt {
 	struct cvmx_ndf_ecc_cnt_s             cn68xxp1;
 	struct cvmx_ndf_ecc_cnt_s             cn70xx;
 	struct cvmx_ndf_ecc_cnt_s             cn70xxp1;
+	struct cvmx_ndf_ecc_cnt_s             cn73xx;
 };
 typedef union cvmx_ndf_ecc_cnt cvmx_ndf_ecc_cnt_t;
 
 /**
  * cvmx_ndf_int
  *
- * FULL status is updated when the command fifo becomes full as a result of SW writing a new
- * command to it.
- * EMPTY status is updated when the command fifo becomes empty as a result of command execution
- * unit fetching the
- *   last instruction out of the command fifo.
+ * This register contains the bits that can trigger an error interrupt. Sixty-four-bit operations
+ * must be used to access this register.
  */
 union cvmx_ndf_int {
 	uint64_t u64;
 	struct cvmx_ndf_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t dma_done                     : 1;  /**< DMA engine request completion interrupt. */
+	uint64_t ovrf                         : 1;  /**< NDF_CMD write when FIFO is full. Generally a fatal error. */
+	uint64_t ecc_mult                     : 1;  /**< Multibit ECC error detected during boot. */
+	uint64_t ecc_1bit                     : 1;  /**< Single-bit ECC error detected and fixed during boot. */
+	uint64_t sm_bad                       : 1;  /**< One of the state machines is in a bad state, */
+	uint64_t wdog                         : 1;  /**< Watchdog timer expired during command execution. */
+	uint64_t full                         : 1;  /**< NDF_CMD queue is full. FULL status is updated when the NDF_CMD queue becomes full as a
+                                                         result of software writing a new command to it. */
+	uint64_t empty                        : 1;  /**< NDF_CMD queue is empty. EMPTY status is updated when the NDF_CMD queue becomes empty as a
+                                                         result of command execution unit fetching the last instruction out of the NDF_CMD queue. */
+#else
+	uint64_t empty                        : 1;
+	uint64_t full                         : 1;
+	uint64_t wdog                         : 1;
+	uint64_t sm_bad                       : 1;
+	uint64_t ecc_1bit                     : 1;
+	uint64_t ecc_mult                     : 1;
+	uint64_t ovrf                         : 1;
+	uint64_t dma_done                     : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_ndf_int_cn52xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
 	uint64_t ovrf                         : 1;  /**< NDF_CMD write when fifo is full. Generally a
                                                          fatal error. */
@@ -336,15 +487,15 @@ union cvmx_ndf_int {
 	uint64_t ovrf                         : 1;
 	uint64_t reserved_7_63                : 57;
 #endif
-	} s;
-	struct cvmx_ndf_int_s                 cn52xx;
-	struct cvmx_ndf_int_s                 cn63xx;
-	struct cvmx_ndf_int_s                 cn63xxp1;
-	struct cvmx_ndf_int_s                 cn66xx;
-	struct cvmx_ndf_int_s                 cn68xx;
-	struct cvmx_ndf_int_s                 cn68xxp1;
-	struct cvmx_ndf_int_s                 cn70xx;
-	struct cvmx_ndf_int_s                 cn70xxp1;
+	} cn52xx;
+	struct cvmx_ndf_int_cn52xx            cn63xx;
+	struct cvmx_ndf_int_cn52xx            cn63xxp1;
+	struct cvmx_ndf_int_cn52xx            cn66xx;
+	struct cvmx_ndf_int_cn52xx            cn68xx;
+	struct cvmx_ndf_int_cn52xx            cn68xxp1;
+	struct cvmx_ndf_int_cn52xx            cn70xx;
+	struct cvmx_ndf_int_cn52xx            cn70xxp1;
+	struct cvmx_ndf_int_s                 cn73xx;
 };
 typedef union cvmx_ndf_int cvmx_ndf_int_t;
 
@@ -390,76 +541,93 @@ union cvmx_ndf_int_en {
 typedef union cvmx_ndf_int_en cvmx_ndf_int_en_t;
 
 /**
+ * cvmx_ndf_int_w1s
+ */
+union cvmx_ndf_int_w1s {
+	uint64_t u64;
+	struct cvmx_ndf_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t dma_done                     : 1;  /**< DMA engine request completion interrupt. */
+	uint64_t ovrf                         : 1;  /**< NDF_CMD write when FIFO is full. Generally a fatal error. */
+	uint64_t ecc_mult                     : 1;  /**< Multibit ECC error detected during boot. */
+	uint64_t ecc_1bit                     : 1;  /**< Single-bit ECC error detected and fixed during boot. */
+	uint64_t sm_bad                       : 1;  /**< One of the state machines is in a bad state, */
+	uint64_t wdog                         : 1;  /**< Watchdog timer expired during command execution. */
+	uint64_t full                         : 1;  /**< NDF_CMD queue is full. FULL status is updated when the NDF_CMD queue becomes full as a
+                                                         result of software writing a new command to it. */
+	uint64_t empty                        : 1;  /**< NDF_CMD queue is empty. EMPTY status is updated when the NDF_CMD queue becomes empty as a
+                                                         result of command execution unit fetching the last instruction out of the NDF_CMD queue. */
+#else
+	uint64_t empty                        : 1;
+	uint64_t full                         : 1;
+	uint64_t wdog                         : 1;
+	uint64_t sm_bad                       : 1;
+	uint64_t ecc_1bit                     : 1;
+	uint64_t ecc_mult                     : 1;
+	uint64_t ovrf                         : 1;
+	uint64_t dma_done                     : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_ndf_int_w1s_s             cn73xx;
+};
+typedef union cvmx_ndf_int_w1s cvmx_ndf_int_w1s_t;
+
+/**
  * cvmx_ndf_misc
  *
- * "NBR_HWM this field specifies the high water mark for the NCB outbound load/store commands
- * receive fifo.
- *   the fifo size is 16 entries.
- * WAIT_CNT this field allows glitch filtering of the WAIT_n input to octeon, from Flash Memory.
- * The count
- *   represents number of eclk cycles.
- * FR_BYT  this field specifies \# of unfilled bytes in the command fifo. Bytes become unfilled as
- * commands
- *   complete execution and exit. (fifo is 256 bytes when BT_DIS=0,  and 1536 bytes when
- * BT_DIS=1)
- * RD_DONE this W1C bit is set to 1 by HW when it reads the last 8 bytes out of the command fifo,
- *   in response to RD_CMD bit being set to 1 by SW.
- * RD_VAL  this read only bit is set to 1 by HW when it reads next 8 bytes from command fifo in
- * response
- *   to RD_CMD bit being set to 1. A SW read of NDF_CMD csr clears this bit to 0.
- * RD_CMD  this R/W bit starts read out from the command fifo, 8 bytes at a time. SW should first
- * read the
- * RD_VAL bit in  this csr to see if next 8 bytes from the command fifo are available in the
- * NDF_CMD csr. All command fifo reads start and end on an 8 byte boundary. A RD_CMD in the
- *   middle of command execution will cause the execution to freeze until RD_DONE is set to 1.
- * RD_CMD
- *   bit will be cleared on any NDF_CMD csr write by SW.
- * BT_DMA  this indicates to the NAND flash boot control state machine that boot dma read can
- * begin.
- *   SW should set this bit to 1 after SW has loaded the command fifo. HW sets the bit to 0
- *   when boot dma command execution is complete. If chip enable 0 is not nand flash, this bit is
- *   permanently 1'b0 with SW writes ignored. Whenever BT_DIS=1, this bit will be 0.
- * BT_DIS  this R/W bit indicates to NAND flash boot control state machine that boot operation
- * has ended.
- *   whenever this bit changes from 0 to a 1, the command fifo is emptied as a side effect. This
- * bit must
- *   never be set when booting from nand flash and region zero is enabled.
- * EX_DIS  When 1, command execution stops after completing execution of all commands currently
- * in the command
- *   fifo. Once command execution has stopped, and then new commands are loaded into the command
- * fifo, execution
- *   will not resume as long as this bit is 1. When this bit is 0, command execution will resume
- * if command fifo
- *   is not empty. EX_DIS should be set to 1, during boot i.e. when BT_DIS = 0.
- * RST_FF  reset command fifo to make it empty, any command inflight is not aborted before
- * reseting
- *   the fifo. The fifo comes up empty at the end of power on reset."
+ * Sixty-four-bit operations must be used to access this register.
+ *
  */
 union cvmx_ndf_misc {
 	uint64_t u64;
 	struct cvmx_ndf_misc_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t mb_dis                       : 1;  /**< Disable multibit error hangs and allow boot loads
-                                                         or boot dma's proceed as if no multi bit errors
-                                                         occured. HW will fix single bit errors as usual */
-	uint64_t nbr_hwm                      : 3;  /**< Hi Water mark for NBR fifo or load/stores */
-	uint64_t wait_cnt                     : 6;  /**< WAIT input filter count */
-	uint64_t fr_byt                       : 11; /**< Number of unfilled Command fifo bytes */
-	uint64_t rd_done                      : 1;  /**< This W1C bit is set to 1 by HW when it completes
-                                                         command fifo read out, in response to RD_CMD */
-	uint64_t rd_val                       : 1;  /**< This RO bit is set to 1 by HW when it reads next 8
-                                                         bytes from Command fifo into the NDF_CMD csr
-                                                         SW reads NDF_CMD csr, HW clears this bit to 0 */
-	uint64_t rd_cmd                       : 1;  /**< When 1, HW reads out contents of the Command fifo 8
-                                                         bytes at a time into the NDF_CMD csr */
-	uint64_t bt_dma                       : 1;  /**< When set to 1, boot time dma is enabled */
-	uint64_t bt_dis                       : 1;  /**< When boot operation is over SW must set to 1
-                                                         causes boot state mchines to sleep */
-	uint64_t ex_dis                       : 1;  /**< When set to 1, suspends execution of commands at
-                                                         next command in the fifo. */
-	uint64_t rst_ff                       : 1;  /**< 1=reset command fifo to make it empty,
-                                                         0=normal operation */
+	uint64_t mb_dis                       : 1;  /**< Set to disable multi-bit error hangs. Allows boot loads and boot DMAs to proceed as if no
+                                                         multi-bit errors occurred. Hardware fixes single bit errors as usual. */
+	uint64_t nbr_hwm                      : 3;  /**< High watermark for NBR FIFO or load/store operations. This field specifies the high
+                                                         watermark for the IOI outbound load/store commands receive FIFO. NBR_HWM+1 is used
+                                                         as the high watermark.  So a value of 0 allows 1 entry in the FIFO at a time.  The
+                                                         FIFO size is 8 entries. */
+	uint64_t wait_cnt                     : 6;  /**< Wait input filter count. Represents the number of coprocessor-clock cycles for glitch
+                                                         filtering of BOOT_WAIT_L from the NAND flash device. */
+	uint64_t fr_byt                       : 11; /**< Unfilled NDF_CMD queue bytes. This field specifies the number of unfilled bytes in the
+                                                         NDF_CMD queue. Bytes become unfilled as commands complete execution and exit. (FIFO is 256
+                                                         bytes when BT_DIS = 0 and 1536 bytes when BT_DIS = 1.) */
+	uint64_t rd_done                      : 1;  /**< Read done. This bit is set to 1 by hardware when it reads the last eight bytes out of the
+                                                         NDF_CMD queue in response to RD_CMD being set to 1 by software. */
+	uint64_t rd_val                       : 1;  /**< This read-only bit is set to 1 by hardware when it reads the next eight bytes from NDF_CMD
+                                                         queue in response to RD_CMD being set to 1. A software read of NDF_CMD clears this bit to
+                                                         0. */
+	uint64_t rd_cmd                       : 1;  /**< Read command. When set to 1, the hardware reads the contents of the NDF_CMD queue eight
+                                                         bytes at a time and places the data into NDF_CMD. Software should first read RD_VAL to see
+                                                         if the next eight bytes from the NDF_CMD queue are available in NDF_CMD.
+                                                         All NDF_CMD queue read operations start and end on an eight-byte boundary. A RD_CMD
+                                                         command in the middle of command execution causes the execution to freeze until RD_DONE is
+                                                         set to 1.
+                                                         This bit is cleared on any NDF_CMD software write command. */
+	uint64_t bt_dma                       : 1;  /**< Boot-time DMA enable. When set to 1, boot-time DMA is enabled. This indicates to the NAND
+                                                         flash boot-control state machine that boot DMA read operations can begin. Software should
+                                                         set this bit to 1 after loading the NDF_CMD queue. Hardware sets the bit to 0 when boot
+                                                         DMA command execution is complete. If chip-enable 0 is not a NAND flash device, this bit
+                                                         is permanently 0 with software write operations ignored.
+                                                         When [BT_DIS] = 1, this bit is 0. */
+	uint64_t bt_dis                       : 1;  /**< Boot disable. When the boot operation is over, software must set this field to 1, which
+                                                         causes the boot-control state machines to sleep.
+                                                         This bit indicates to the NAND flash boot-control state machine that boot operation has
+                                                         ended. When this bit changes from 0 -> 1, the NDF_CMD queue is emptied as a side effect.
+                                                         This bit must never be set when booting from NAND flash and region zero is enabled. */
+	uint64_t ex_dis                       : 1;  /**< Execution disable. When set to 1, this bit stops command execution after completing the
+                                                         execution of all commands currently in the NDF_CMD queue. Once command execution has
+                                                         stopped and then new commands are loaded into the NDF_CMD queue, command execution does
+                                                         not resume while this bit is 1.
+                                                         When this bit is set to 0, execution resumes if the NDF_CMD queue is not empty. */
+	uint64_t rst_ff                       : 1;  /**< Reset FIFO.
+                                                         0 = Normal operation.
+                                                         1 = Reset NDF_CMD queue to empty it; any command in flight is not aborted before
+                                                         resetting. The FIFO comes up empty at the end of power on reset. */
 #else
 	uint64_t rst_ff                       : 1;
 	uint64_t ex_dis                       : 1;
@@ -516,30 +684,30 @@ union cvmx_ndf_misc {
 	struct cvmx_ndf_misc_s                cn68xxp1;
 	struct cvmx_ndf_misc_s                cn70xx;
 	struct cvmx_ndf_misc_s                cn70xxp1;
+	struct cvmx_ndf_misc_s                cn73xx;
 };
 typedef union cvmx_ndf_misc cvmx_ndf_misc_t;
 
 /**
  * cvmx_ndf_st_reg
  *
- * Notes:
- * This CSR aggregates all state machines used in nand flash controller for debug.
- * Like all NDF_... registers, 64-bit operations must be used to access this register
+ * This register aggregates all state machines used in NAND flash controller for debug purposes.
+ *
  */
 union cvmx_ndf_st_reg {
 	uint64_t u64;
 	struct cvmx_ndf_st_reg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t exe_idle                     : 1;  /**< Command Execution status 1=IDLE, 0=Busy
-                                                         1 means execution of command sequence is complete
-                                                         and command fifo is empty */
-	uint64_t exe_sm                       : 4;  /**< Command Execution State machine states */
-	uint64_t bt_sm                        : 4;  /**< Boot load and Boot dma State machine states */
-	uint64_t rd_ff_bad                    : 1;  /**< CMD fifo read back State machine in bad state */
-	uint64_t rd_ff                        : 2;  /**< CMD fifo read back State machine states */
-	uint64_t main_bad                     : 1;  /**< Main State machine in bad state */
-	uint64_t main_sm                      : 3;  /**< Main State machine states */
+	uint64_t exe_idle                     : 1;  /**< Command execution status
+                                                         0 = Busy.
+                                                         1 = Idle (execution of command sequence is complete and NDF_CMD queue is empty). */
+	uint64_t exe_sm                       : 4;  /**< Command-execution state-machine states. */
+	uint64_t bt_sm                        : 4;  /**< Boot-load and boot-DMA state-machine states. */
+	uint64_t rd_ff_bad                    : 1;  /**< The NDF_CMD-queue read-back state machine is in a 'bad' state. */
+	uint64_t rd_ff                        : 2;  /**< NDF_CMD-queue read-back state machine states. */
+	uint64_t main_bad                     : 1;  /**< The main state machine is in a 'bad' state. */
+	uint64_t main_sm                      : 3;  /**< Main state-machine states. */
 #else
 	uint64_t main_sm                      : 3;
 	uint64_t main_bad                     : 1;
@@ -559,6 +727,7 @@ union cvmx_ndf_st_reg {
 	struct cvmx_ndf_st_reg_s              cn68xxp1;
 	struct cvmx_ndf_st_reg_s              cn70xx;
 	struct cvmx_ndf_st_reg_s              cn70xxp1;
+	struct cvmx_ndf_st_reg_s              cn73xx;
 };
 typedef union cvmx_ndf_st_reg cvmx_ndf_st_reg_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index 2555c91..10dbbac 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -53,22 +53,24 @@
 #define __CVMX_OCLAX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_BIST_RESULT(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_BIST_RESULT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_BIST_RESULT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000040ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_BIST_RESULT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000040ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_BIST_RESULT(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000040ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_BIST_RESULT(offset) (CVMX_ADD_IO_SEG(0x00011800A8000040ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCLAX_CDHX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_CDHX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000600ull) + (((offset) & 1) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -77,22 +79,24 @@ static inline uint64_t CVMX_OCLAX_CDHX_CTL(unsigned long offset, unsigned long b
 #define CVMX_OCLAX_CDHX_CTL(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800A8000600ull) + (((offset) & 1) + ((block_id) & 7) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_CONST(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_CONST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_CONST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000000ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_CONST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000000ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_CONST(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000000ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_CONST(offset) (CVMX_ADD_IO_SEG(0x00011800A8000000ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCLAX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 8191)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 8191)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 8191)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8400000ull) + (((offset) & 8191) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -101,82 +105,101 @@ static inline uint64_t CVMX_OCLAX_DATX(unsigned long offset, unsigned long block
 #define CVMX_OCLAX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800A8400000ull) + (((offset) & 8191) + ((block_id) & 7) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_DAT_POP(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_DAT_POP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_DAT_POP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000800ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_DAT_POP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000800ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_DAT_POP(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000800ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_DAT_POP(offset) (CVMX_ADD_IO_SEG(0x00011800A8000800ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_FIFO_DEPTH(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_ECO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_FIFO_DEPTH(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000200ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2)))))
+		cvmx_warn("CVMX_OCLAX_ECO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A80000D0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_FIFO_DEPTH(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000200ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_ECO(offset) (CVMX_ADD_IO_SEG(0x00011800A80000D0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_FIFO_LIMIT(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_FIFO_DEPTH(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_FIFO_LIMIT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000240ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_FIFO_DEPTH(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000200ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_FIFO_LIMIT(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000240ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_FIFO_DEPTH(offset) (CVMX_ADD_IO_SEG(0x00011800A8000200ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_FIFO_TAIL(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_FIFO_LIMIT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_FIFO_TAIL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000260ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_FIFO_LIMIT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000240ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_FIFO_TAIL(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000260ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_FIFO_LIMIT(offset) (CVMX_ADD_IO_SEG(0x00011800A8000240ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_FIFO_TRIG(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_FIFO_TAIL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_FIFO_TRIG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A80002A0ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_FIFO_TAIL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000260ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_FIFO_TRIG(block_id) (CVMX_ADD_IO_SEG(0x00011800A80002A0ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_FIFO_TAIL(offset) (CVMX_ADD_IO_SEG(0x00011800A8000260ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_FIFO_WRAP(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_FIFO_TRIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_FIFO_WRAP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000280ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_FIFO_TRIG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A80002A0ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_FIFO_WRAP(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000280ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_FIFO_TRIG(offset) (CVMX_ADD_IO_SEG(0x00011800A80002A0ull) + ((offset) & 7) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCLAX_FIFO_WRAP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_FIFO_WRAP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000280ull) + ((offset) & 7) * 0x1000000ull;
+}
+#else
+#define CVMX_OCLAX_FIFO_WRAP(offset) (CVMX_ADD_IO_SEG(0x00011800A8000280ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCLAX_FSMX_ANDX_IX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_ANDX_IX(%lu,%lu,%lu,%lu) is invalid on this chip\n", a, b, c, d);
 	return CVMX_ADD_IO_SEG(0x00011800A8300000ull) + ((a) << 24) + ((b) << 12) + ((c) << 4) + ((d) << 3);
@@ -189,6 +212,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_ORX(unsigned long a, unsigned long b, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_ORX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8310000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -201,6 +225,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_STATEX(unsigned long a, unsigned long b,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_STATEX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8320000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -209,22 +234,24 @@ static inline uint64_t CVMX_OCLAX_FSMX_STATEX(unsigned long a, unsigned long b,
 #define CVMX_OCLAX_FSMX_STATEX(a, b, c) (CVMX_ADD_IO_SEG(0x00011800A8320000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_GEN_CTL(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_GEN_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_GEN_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000060ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_GEN_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000060ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_GEN_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000060ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_GEN_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800A8000060ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCLAX_MATX_COUNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_COUNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8230000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -237,6 +264,7 @@ static inline uint64_t CVMX_OCLAX_MATX_CTL(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8200000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -249,6 +277,7 @@ static inline uint64_t CVMX_OCLAX_MATX_MASKX(unsigned long a, unsigned long b, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 3)) && ((c <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 3)) && ((c <= 1))))))
 		cvmx_warn("CVMX_OCLAX_MATX_MASKX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8220000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -261,6 +290,7 @@ static inline uint64_t CVMX_OCLAX_MATX_THRESH(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8240000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -273,6 +303,7 @@ static inline uint64_t CVMX_OCLAX_MATX_VALUEX(unsigned long a, unsigned long b,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 3)) && ((c <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 3)) && ((c <= 1))))))
 		cvmx_warn("CVMX_OCLAX_MATX_VALUEX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8210000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -285,6 +316,7 @@ static inline uint64_t CVMX_OCLAX_RAWX(unsigned long offset, unsigned long block
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_RAWX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000100ull) + (((offset) & 1) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -293,82 +325,89 @@ static inline uint64_t CVMX_OCLAX_RAWX(unsigned long offset, unsigned long block
 #define CVMX_OCLAX_RAWX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800A8000100ull) + (((offset) & 1) + ((block_id) & 7) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_SFT_RST(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_SFT_RST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_SFT_RST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000020ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_SFT_RST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000020ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_SFT_RST(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000020ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_SFT_RST(offset) (CVMX_ADD_IO_SEG(0x00011800A8000020ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_STACK_BASE(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_STACK_BASE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_STACK_BASE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000400ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_STACK_BASE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000400ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_STACK_BASE(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000400ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_STACK_BASE(offset) (CVMX_ADD_IO_SEG(0x00011800A8000400ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_STACK_CUR(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_STACK_CUR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_STACK_CUR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000480ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_STACK_CUR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000480ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_STACK_CUR(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000480ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_STACK_CUR(offset) (CVMX_ADD_IO_SEG(0x00011800A8000480ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_STACK_STORE_CNT(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_STACK_STORE_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_STACK_STORE_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000460ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_STACK_STORE_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000460ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_STACK_STORE_CNT(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000460ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_STACK_STORE_CNT(offset) (CVMX_ADD_IO_SEG(0x00011800A8000460ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_STACK_TOP(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_STACK_TOP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_STACK_TOP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000420ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_STACK_TOP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000420ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_STACK_TOP(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000420ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_STACK_TOP(offset) (CVMX_ADD_IO_SEG(0x00011800A8000420ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_STACK_WRAP(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_STACK_WRAP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_STACK_WRAP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000440ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_STACK_WRAP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000440ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_STACK_WRAP(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000440ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_STACK_WRAP(offset) (CVMX_ADD_IO_SEG(0x00011800A8000440ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCLAX_STAGEX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 71)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 71)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 71)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_STAGEX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8100000ull) + (((offset) & 127) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -377,40 +416,43 @@ static inline uint64_t CVMX_OCLAX_STAGEX(unsigned long offset, unsigned long blo
 #define CVMX_OCLAX_STAGEX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800A8100000ull) + (((offset) & 127) + ((block_id) & 7) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_STATE_INT(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_STATE_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_STATE_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A8000080ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_STATE_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A8000080ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_STATE_INT(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000080ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_STATE_INT(offset) (CVMX_ADD_IO_SEG(0x00011800A8000080ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_STATE_SET(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_STATE_SET(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_STATE_SET(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A80000A0ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_STATE_SET(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A80000A0ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_STATE_SET(block_id) (CVMX_ADD_IO_SEG(0x00011800A80000A0ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_STATE_SET(offset) (CVMX_ADD_IO_SEG(0x00011800A80000A0ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_OCLAX_TIME(unsigned long block_id)
+static inline uint64_t CVMX_OCLAX_TIME(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
-		cvmx_warn("CVMX_OCLAX_TIME(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800A80000C0ull) + ((block_id) & 7) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
+		cvmx_warn("CVMX_OCLAX_TIME(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800A80000C0ull) + ((offset) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_OCLAX_TIME(block_id) (CVMX_ADD_IO_SEG(0x00011800A80000C0ull) + ((block_id) & 7) * 0x1000000ull)
+#define CVMX_OCLAX_TIME(offset) (CVMX_ADD_IO_SEG(0x00011800A80000C0ull) + ((offset) & 7) * 0x1000000ull)
 #endif
 
 /**
@@ -432,6 +474,7 @@ union cvmx_oclax_bist_result {
 	} s;
 	struct cvmx_oclax_bist_result_s       cn70xx;
 	struct cvmx_oclax_bist_result_s       cn70xxp1;
+	struct cvmx_oclax_bist_result_s       cn73xx;
 	struct cvmx_oclax_bist_result_s       cn78xx;
 };
 typedef union cvmx_oclax_bist_result cvmx_oclax_bist_result_t;
@@ -470,6 +513,7 @@ union cvmx_oclax_cdhx_ctl {
 	} s;
 	struct cvmx_oclax_cdhx_ctl_s          cn70xx;
 	struct cvmx_oclax_cdhx_ctl_s          cn70xxp1;
+	struct cvmx_oclax_cdhx_ctl_s          cn73xx;
 	struct cvmx_oclax_cdhx_ctl_s          cn78xx;
 };
 typedef union cvmx_oclax_cdhx_ctl cvmx_oclax_cdhx_ctl_t;
@@ -492,6 +536,7 @@ union cvmx_oclax_const {
 	} s;
 	struct cvmx_oclax_const_s             cn70xx;
 	struct cvmx_oclax_const_s             cn70xxp1;
+	struct cvmx_oclax_const_s             cn73xx;
 	struct cvmx_oclax_const_s             cn78xx;
 };
 typedef union cvmx_oclax_const cvmx_oclax_const_t;
@@ -512,6 +557,7 @@ union cvmx_oclax_datx {
 	} s;
 	struct cvmx_oclax_datx_s              cn70xx;
 	struct cvmx_oclax_datx_s              cn70xxp1;
+	struct cvmx_oclax_datx_s              cn73xx;
 	struct cvmx_oclax_datx_s              cn78xx;
 };
 typedef union cvmx_oclax_datx cvmx_oclax_datx_t;
@@ -542,11 +588,34 @@ union cvmx_oclax_dat_pop {
 	} s;
 	struct cvmx_oclax_dat_pop_s           cn70xx;
 	struct cvmx_oclax_dat_pop_s           cn70xxp1;
+	struct cvmx_oclax_dat_pop_s           cn73xx;
 	struct cvmx_oclax_dat_pop_s           cn78xx;
 };
 typedef union cvmx_oclax_dat_pop cvmx_oclax_dat_pop_t;
 
 /**
+ * cvmx_ocla#_eco
+ *
+ * Added in pass 2.
+ *
+ */
+union cvmx_oclax_eco {
+	uint64_t u64;
+	struct cvmx_oclax_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_oclax_eco_s               cn70xx;
+	struct cvmx_oclax_eco_s               cn73xx;
+};
+typedef union cvmx_oclax_eco cvmx_oclax_eco_t;
+
+/**
  * cvmx_ocla#_fifo_depth
  */
 union cvmx_oclax_fifo_depth {
@@ -562,6 +631,7 @@ union cvmx_oclax_fifo_depth {
 	} s;
 	struct cvmx_oclax_fifo_depth_s        cn70xx;
 	struct cvmx_oclax_fifo_depth_s        cn70xxp1;
+	struct cvmx_oclax_fifo_depth_s        cn73xx;
 	struct cvmx_oclax_fifo_depth_s        cn78xx;
 };
 typedef union cvmx_oclax_fifo_depth cvmx_oclax_fifo_depth_t;
@@ -593,6 +663,7 @@ union cvmx_oclax_fifo_limit {
 	} s;
 	struct cvmx_oclax_fifo_limit_s        cn70xx;
 	struct cvmx_oclax_fifo_limit_s        cn70xxp1;
+	struct cvmx_oclax_fifo_limit_s        cn73xx;
 	struct cvmx_oclax_fifo_limit_s        cn78xx;
 };
 typedef union cvmx_oclax_fifo_limit cvmx_oclax_fifo_limit_t;
@@ -613,6 +684,7 @@ union cvmx_oclax_fifo_tail {
 	} s;
 	struct cvmx_oclax_fifo_tail_s         cn70xx;
 	struct cvmx_oclax_fifo_tail_s         cn70xxp1;
+	struct cvmx_oclax_fifo_tail_s         cn73xx;
 	struct cvmx_oclax_fifo_tail_s         cn78xx;
 };
 typedef union cvmx_oclax_fifo_tail cvmx_oclax_fifo_tail_t;
@@ -637,6 +709,7 @@ union cvmx_oclax_fifo_trig {
 	} s;
 	struct cvmx_oclax_fifo_trig_s         cn70xx;
 	struct cvmx_oclax_fifo_trig_s         cn70xxp1;
+	struct cvmx_oclax_fifo_trig_s         cn73xx;
 	struct cvmx_oclax_fifo_trig_s         cn78xx;
 };
 typedef union cvmx_oclax_fifo_trig cvmx_oclax_fifo_trig_t;
@@ -659,6 +732,7 @@ union cvmx_oclax_fifo_wrap {
 	} s;
 	struct cvmx_oclax_fifo_wrap_s         cn70xx;
 	struct cvmx_oclax_fifo_wrap_s         cn70xxp1;
+	struct cvmx_oclax_fifo_wrap_s         cn73xx;
 	struct cvmx_oclax_fifo_wrap_s         cn78xx;
 };
 typedef union cvmx_oclax_fifo_wrap cvmx_oclax_fifo_wrap_t;
@@ -691,6 +765,7 @@ union cvmx_oclax_fsmx_andx_ix {
 	} s;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn70xx;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn70xxp1;
+	struct cvmx_oclax_fsmx_andx_ix_s      cn73xx;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn78xx;
 };
 typedef union cvmx_oclax_fsmx_andx_ix cvmx_oclax_fsmx_andx_ix_t;
@@ -719,6 +794,7 @@ union cvmx_oclax_fsmx_orx {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} cn70xxp1;
+	struct cvmx_oclax_fsmx_orx_s          cn73xx;
 	struct cvmx_oclax_fsmx_orx_cn70xxp1   cn78xx;
 };
 typedef union cvmx_oclax_fsmx_orx cvmx_oclax_fsmx_orx_t;
@@ -763,6 +839,7 @@ union cvmx_oclax_fsmx_statex {
 	} s;
 	struct cvmx_oclax_fsmx_statex_s       cn70xx;
 	struct cvmx_oclax_fsmx_statex_s       cn70xxp1;
+	struct cvmx_oclax_fsmx_statex_s       cn73xx;
 	struct cvmx_oclax_fsmx_statex_s       cn78xx;
 };
 typedef union cvmx_oclax_fsmx_statex cvmx_oclax_fsmx_statex_t;
@@ -797,6 +874,7 @@ union cvmx_oclax_gen_ctl {
 	} s;
 	struct cvmx_oclax_gen_ctl_s           cn70xx;
 	struct cvmx_oclax_gen_ctl_s           cn70xxp1;
+	struct cvmx_oclax_gen_ctl_s           cn73xx;
 	struct cvmx_oclax_gen_ctl_s           cn78xx;
 };
 typedef union cvmx_oclax_gen_ctl cvmx_oclax_gen_ctl_t;
@@ -818,6 +896,7 @@ union cvmx_oclax_matx_count {
 	} s;
 	struct cvmx_oclax_matx_count_s        cn70xx;
 	struct cvmx_oclax_matx_count_s        cn70xxp1;
+	struct cvmx_oclax_matx_count_s        cn73xx;
 	struct cvmx_oclax_matx_count_s        cn78xx;
 };
 typedef union cvmx_oclax_matx_count cvmx_oclax_matx_count_t;
@@ -845,6 +924,7 @@ union cvmx_oclax_matx_ctl {
 	} s;
 	struct cvmx_oclax_matx_ctl_s          cn70xx;
 	struct cvmx_oclax_matx_ctl_s          cn70xxp1;
+	struct cvmx_oclax_matx_ctl_s          cn73xx;
 	struct cvmx_oclax_matx_ctl_s          cn78xx;
 };
 typedef union cvmx_oclax_matx_ctl cvmx_oclax_matx_ctl_t;
@@ -871,6 +951,7 @@ union cvmx_oclax_matx_maskx {
 	} s;
 	struct cvmx_oclax_matx_maskx_s        cn70xx;
 	struct cvmx_oclax_matx_maskx_s        cn70xxp1;
+	struct cvmx_oclax_matx_maskx_s        cn73xx;
 	struct cvmx_oclax_matx_maskx_s        cn78xx;
 };
 typedef union cvmx_oclax_matx_maskx cvmx_oclax_matx_maskx_t;
@@ -892,6 +973,7 @@ union cvmx_oclax_matx_thresh {
 	} s;
 	struct cvmx_oclax_matx_thresh_s       cn70xx;
 	struct cvmx_oclax_matx_thresh_s       cn70xxp1;
+	struct cvmx_oclax_matx_thresh_s       cn73xx;
 	struct cvmx_oclax_matx_thresh_s       cn78xx;
 };
 typedef union cvmx_oclax_matx_thresh cvmx_oclax_matx_thresh_t;
@@ -913,6 +995,7 @@ union cvmx_oclax_matx_valuex {
 	} s;
 	struct cvmx_oclax_matx_valuex_s       cn70xx;
 	struct cvmx_oclax_matx_valuex_s       cn70xxp1;
+	struct cvmx_oclax_matx_valuex_s       cn73xx;
 	struct cvmx_oclax_matx_valuex_s       cn78xx;
 };
 typedef union cvmx_oclax_matx_valuex cvmx_oclax_matx_valuex_t;
@@ -933,6 +1016,7 @@ union cvmx_oclax_rawx {
 	} s;
 	struct cvmx_oclax_rawx_s              cn70xx;
 	struct cvmx_oclax_rawx_s              cn70xxp1;
+	struct cvmx_oclax_rawx_s              cn73xx;
 	struct cvmx_oclax_rawx_s              cn78xx;
 };
 typedef union cvmx_oclax_rawx cvmx_oclax_rawx_t;
@@ -953,6 +1037,7 @@ union cvmx_oclax_sft_rst {
 	} s;
 	struct cvmx_oclax_sft_rst_s           cn70xx;
 	struct cvmx_oclax_sft_rst_s           cn70xxp1;
+	struct cvmx_oclax_sft_rst_s           cn73xx;
 	struct cvmx_oclax_sft_rst_s           cn78xx;
 };
 typedef union cvmx_oclax_sft_rst cvmx_oclax_sft_rst_t;
@@ -975,6 +1060,7 @@ union cvmx_oclax_stack_base {
 	} s;
 	struct cvmx_oclax_stack_base_s        cn70xx;
 	struct cvmx_oclax_stack_base_s        cn70xxp1;
+	struct cvmx_oclax_stack_base_s        cn73xx;
 	struct cvmx_oclax_stack_base_s        cn78xx;
 };
 typedef union cvmx_oclax_stack_base cvmx_oclax_stack_base_t;
@@ -999,6 +1085,7 @@ union cvmx_oclax_stack_cur {
 	} s;
 	struct cvmx_oclax_stack_cur_s         cn70xx;
 	struct cvmx_oclax_stack_cur_s         cn70xxp1;
+	struct cvmx_oclax_stack_cur_s         cn73xx;
 	struct cvmx_oclax_stack_cur_s         cn78xx;
 };
 typedef union cvmx_oclax_stack_cur cvmx_oclax_stack_cur_t;
@@ -1019,6 +1106,7 @@ union cvmx_oclax_stack_store_cnt {
 	} s;
 	struct cvmx_oclax_stack_store_cnt_s   cn70xx;
 	struct cvmx_oclax_stack_store_cnt_s   cn70xxp1;
+	struct cvmx_oclax_stack_store_cnt_s   cn73xx;
 	struct cvmx_oclax_stack_store_cnt_s   cn78xx;
 };
 typedef union cvmx_oclax_stack_store_cnt cvmx_oclax_stack_store_cnt_t;
@@ -1042,6 +1130,7 @@ union cvmx_oclax_stack_top {
 	} s;
 	struct cvmx_oclax_stack_top_s         cn70xx;
 	struct cvmx_oclax_stack_top_s         cn70xxp1;
+	struct cvmx_oclax_stack_top_s         cn73xx;
 	struct cvmx_oclax_stack_top_s         cn78xx;
 };
 typedef union cvmx_oclax_stack_top cvmx_oclax_stack_top_t;
@@ -1063,6 +1152,7 @@ union cvmx_oclax_stack_wrap {
 	} s;
 	struct cvmx_oclax_stack_wrap_s        cn70xx;
 	struct cvmx_oclax_stack_wrap_s        cn70xxp1;
+	struct cvmx_oclax_stack_wrap_s        cn73xx;
 	struct cvmx_oclax_stack_wrap_s        cn78xx;
 };
 typedef union cvmx_oclax_stack_wrap cvmx_oclax_stack_wrap_t;
@@ -1083,6 +1173,7 @@ union cvmx_oclax_stagex {
 	} s;
 	struct cvmx_oclax_stagex_s            cn70xx;
 	struct cvmx_oclax_stagex_s            cn70xxp1;
+	struct cvmx_oclax_stagex_s            cn73xx;
 	struct cvmx_oclax_stagex_s            cn78xx;
 };
 typedef union cvmx_oclax_stagex cvmx_oclax_stagex_t;
@@ -1146,6 +1237,7 @@ union cvmx_oclax_state_int {
 	} s;
 	struct cvmx_oclax_state_int_s         cn70xx;
 	struct cvmx_oclax_state_int_s         cn70xxp1;
+	struct cvmx_oclax_state_int_s         cn73xx;
 	struct cvmx_oclax_state_int_s         cn78xx;
 };
 typedef union cvmx_oclax_state_int cvmx_oclax_state_int_t;
@@ -1203,6 +1295,7 @@ union cvmx_oclax_state_set {
 	} s;
 	struct cvmx_oclax_state_set_s         cn70xx;
 	struct cvmx_oclax_state_set_s         cn70xxp1;
+	struct cvmx_oclax_state_set_s         cn73xx;
 	struct cvmx_oclax_state_set_s         cn78xx;
 };
 typedef union cvmx_oclax_state_set cvmx_oclax_state_set_t;
@@ -1230,6 +1323,7 @@ union cvmx_oclax_time {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} cn70xxp1;
+	struct cvmx_oclax_time_s              cn73xx;
 	struct cvmx_oclax_time_cn70xxp1       cn78xx;
 };
 typedef union cvmx_oclax_time cvmx_oclax_time_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 68948f3..b9153e3 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -985,8 +985,10 @@ union cvmx_ocx_com_linkx_ctl {
                                                          Setting the bit also causes the link to transmit a REINIT request to the link partner.
                                                          This bit must be cleared for link to operate normally. */
 	uint64_t gate                         : 1;  /**< Reserved. */
-	uint64_t auto_clr                     : 1;  /**< Automatically clear DROP bit if link partner has cleared other side. Typically disabled if
-                                                         software wishes to manage deassertion of DROP. */
+	uint64_t auto_clr                     : 1;  /**< When set, automatically clears the local DROP bit if link partner forces
+                                                         a reinitialization.  Typically disabled once software is running.
+                                                         If clear, software must manage clearing the DROP bit after it has verified
+                                                         that any pending transactions have timed out. */
 	uint64_t drop                         : 1;  /**< Drop all requests on given link. Typically set by hardware when link has failed or been
                                                          reinitialized. Cleared by software once pending link traffic is removed. (See
                                                          OCX_TLK(0..2)_FIFO(0..13)_CNT.) */
diff --git a/arch/mips/include/asm/octeon/cvmx-osm-defs.h b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
index 720d3c2..f1e45a1 100644
--- a/arch/mips/include/asm/octeon/cvmx-osm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
@@ -66,68 +66,203 @@ static inline uint64_t CVMX_OSM_ASE_RATE_LIMIT_CTRL_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OSM_BANKX_CTRL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
-		cvmx_warn("CVMX_OSM_BANKX_CTRL(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001DC0000001000ull) + ((offset) & 31) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_OSM_BANKX_CTRL (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8;
 }
 #else
-#define CVMX_OSM_BANKX_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8)
+static inline uint64_t CVMX_OSM_BANKX_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000001000ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_OSM_CLK_CFG CVMX_OSM_CLK_CFG_FUNC()
+static inline uint64_t CVMX_OSM_CLK_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_OSM_CLK_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001DC0000000028ull);
+}
+#else
+#define CVMX_OSM_CLK_CFG (CVMX_ADD_IO_SEG(0x0001DC0000000028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OSM_ECC_CTRL CVMX_OSM_ECC_CTRL_FUNC()
 static inline uint64_t CVMX_OSM_ECC_CTRL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_OSM_ECC_CTRL not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000020ull);
+			break;
+	}
+	cvmx_warn("CVMX_OSM_ECC_CTRL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
 }
 #else
-#define CVMX_OSM_ECC_CTRL (CVMX_ADD_IO_SEG(0x00011800DC000020ull))
+#define CVMX_OSM_ECC_CTRL CVMX_OSM_ECC_CTRL_FUNC()
+static inline uint64_t CVMX_OSM_ECC_CTRL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000020ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_OSM_ECO CVMX_OSM_ECO_FUNC()
+static inline uint64_t CVMX_OSM_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_OSM_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001DC0000003000ull);
+}
+#else
+#define CVMX_OSM_ECO (CVMX_ADD_IO_SEG(0x0001DC0000003000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OSM_INT_INFO_ADDR CVMX_OSM_INT_INFO_ADDR_FUNC()
 static inline uint64_t CVMX_OSM_INT_INFO_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_OSM_INT_INFO_ADDR not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000018ull);
+			break;
+	}
+	cvmx_warn("CVMX_OSM_INT_INFO_ADDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
 }
 #else
-#define CVMX_OSM_INT_INFO_ADDR (CVMX_ADD_IO_SEG(0x00011800DC000018ull))
+#define CVMX_OSM_INT_INFO_ADDR CVMX_OSM_INT_INFO_ADDR_FUNC()
+static inline uint64_t CVMX_OSM_INT_INFO_ADDR_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000018ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OSM_INT_INFO_ECC CVMX_OSM_INT_INFO_ECC_FUNC()
 static inline uint64_t CVMX_OSM_INT_INFO_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_OSM_INT_INFO_ECC not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000010ull);
+			break;
+	}
+	cvmx_warn("CVMX_OSM_INT_INFO_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
 }
 #else
-#define CVMX_OSM_INT_INFO_ECC (CVMX_ADD_IO_SEG(0x00011800DC000010ull))
+#define CVMX_OSM_INT_INFO_ECC CVMX_OSM_INT_INFO_ECC_FUNC()
+static inline uint64_t CVMX_OSM_INT_INFO_ECC_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000010ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OSM_INT_STAT CVMX_OSM_INT_STAT_FUNC()
 static inline uint64_t CVMX_OSM_INT_STAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_OSM_INT_STAT not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000008ull);
+			break;
+	}
+	cvmx_warn("CVMX_OSM_INT_STAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
 }
 #else
-#define CVMX_OSM_INT_STAT (CVMX_ADD_IO_SEG(0x00011800DC000008ull))
+#define CVMX_OSM_INT_STAT CVMX_OSM_INT_STAT_FUNC()
+static inline uint64_t CVMX_OSM_INT_STAT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000008ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OSM_MEMX_BIST_STATUS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
-		cvmx_warn("CVMX_OSM_MEMX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 7))
+				return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001DC0000002000ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_OSM_MEMX_BIST_STATUS (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8;
 }
 #else
-#define CVMX_OSM_MEMX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8)
+static inline uint64_t CVMX_OSM_MEMX_BIST_STATUS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000002000ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OSM_MEMX_DX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 16383))))))
+		cvmx_warn("CVMX_OSM_MEMX_DX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001DC0800000000ull) + (((offset) & 3) + ((block_id) & 16383) * 0x4ull) * 8;
+}
+#else
+#define CVMX_OSM_MEMX_DX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001DC0800000000ull) + (((offset) & 3) + ((block_id) & 16383) * 0x4ull) * 8)
 #endif
 
 /**
@@ -191,11 +326,33 @@ union cvmx_osm_bankx_ctrl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_osm_bankx_ctrl_s          cn73xx;
 	struct cvmx_osm_bankx_ctrl_s          cn78xx;
 };
 typedef union cvmx_osm_bankx_ctrl cvmx_osm_bankx_ctrl_t;
 
 /**
+ * cvmx_osm_clk_cfg
+ *
+ * This is the general configuration register for the OSM block.
+ *
+ */
+union cvmx_osm_clk_cfg {
+	uint64_t u64;
+	struct cvmx_osm_clk_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t clken                        : 1;  /**< Enable OSM clocks. Clear to disable clocking to disallow OSM accesses and save power. */
+#else
+	uint64_t clken                        : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_osm_clk_cfg_s             cn73xx;
+};
+typedef union cvmx_osm_clk_cfg cvmx_osm_clk_cfg_t;
+
+/**
  * cvmx_osm_ecc_ctrl
  *
  * ECC control register.
@@ -218,11 +375,32 @@ union cvmx_osm_ecc_ctrl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_osm_ecc_ctrl_s            cn73xx;
 	struct cvmx_osm_ecc_ctrl_s            cn78xx;
 };
 typedef union cvmx_osm_ecc_ctrl cvmx_osm_ecc_ctrl_t;
 
 /**
+ * cvmx_osm_eco
+ */
+union cvmx_osm_eco {
+	uint64_t u64;
+	struct cvmx_osm_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t eco_ro                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 8;
+	uint64_t eco_ro                       : 8;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_osm_eco_s                 cn73xx;
+};
+typedef union cvmx_osm_eco cvmx_osm_eco_t;
+
+/**
  * cvmx_osm_int_info_addr
  *
  * This register can be used to debug address errors (illegal bank). Fields are captured when
@@ -245,6 +423,7 @@ union cvmx_osm_int_info_addr {
 	uint64_t reserved_35_63               : 29;
 #endif
 	} s;
+	struct cvmx_osm_int_info_addr_s       cn73xx;
 	struct cvmx_osm_int_info_addr_s       cn78xx;
 };
 typedef union cvmx_osm_int_info_addr cvmx_osm_int_info_addr_t;
@@ -256,7 +435,7 @@ typedef union cvmx_osm_int_info_addr cvmx_osm_int_info_addr_t;
  * outstanding ECC errors indicated in OSM_INT_STAT and a new ECC error arrives. Prioritization
  * for multiple events occurring at the same time is indicated by the OSM_ECC_ERR_SOURCE_E
  * enumeration; highest encoded value has highest priority. For current bank assignment, see
- * OSM_BANK(0..63)_CTRL.
+ * OSM_BANK()_CTRL.
  */
 union cvmx_osm_int_info_ecc {
 	uint64_t u64;
@@ -273,6 +452,7 @@ union cvmx_osm_int_info_ecc {
 	uint64_t reserved_37_63               : 27;
 #endif
 	} s;
+	struct cvmx_osm_int_info_ecc_s        cn73xx;
 	struct cvmx_osm_int_info_ecc_s        cn78xx;
 };
 typedef union cvmx_osm_int_info_ecc cvmx_osm_int_info_ecc_t;
@@ -283,7 +463,7 @@ typedef union cvmx_osm_int_info_ecc cvmx_osm_int_info_ecc_t;
  * For debugging output for ECC DBE/SBEs, see OSM_INT_INFO_ECC. Address errors happen when a
  * requester attempts to access a bank that was not assigned to it. For example, Bank 0 is
  * assigned to HFA, and HNA attempts to access it. For debugging output for address errors, see
- * OSM_INT_INFO_ADDR. For current bank assignment, see OSM_BANK(0..63)_CTRL.
+ * OSM_INT_INFO_ADDR. For current bank assignment, see OSM_BANK()_CTRL.
  */
 union cvmx_osm_int_stat {
 	uint64_t u64;
@@ -340,6 +520,27 @@ union cvmx_osm_int_stat {
 	uint64_t reserved_23_63               : 41;
 #endif
 	} s;
+	struct cvmx_osm_int_stat_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_18_63               : 46;
+	uint64_t hna_addr_err                 : 1;  /**< HNA port illegal bank address error. */
+	uint64_t dfa_addr_err                 : 1;  /**< HFA port illegal bank address error. */
+	uint64_t reserved_4_15                : 12;
+	uint64_t hna_sbe                      : 1;  /**< HNA port single-bit error. */
+	uint64_t hna_dbe                      : 1;  /**< HNA port double-bit error. */
+	uint64_t dfa_sbe                      : 1;  /**< HFA port single-bit error. */
+	uint64_t dfa_dbe                      : 1;  /**< HFA port double-bit error. */
+#else
+	uint64_t dfa_dbe                      : 1;
+	uint64_t dfa_sbe                      : 1;
+	uint64_t hna_dbe                      : 1;
+	uint64_t hna_sbe                      : 1;
+	uint64_t reserved_4_15                : 12;
+	uint64_t dfa_addr_err                 : 1;
+	uint64_t hna_addr_err                 : 1;
+	uint64_t reserved_18_63               : 46;
+#endif
+	} cn73xx;
 	struct cvmx_osm_int_stat_s            cn78xx;
 };
 typedef union cvmx_osm_int_stat cvmx_osm_int_stat_t;
@@ -347,16 +548,16 @@ typedef union cvmx_osm_int_stat cvmx_osm_int_stat_t;
 /**
  * cvmx_osm_mem#_bist_status
  *
- * Results from BIST runs of OSM's memories. OSM_MEM is instantiated 8 times, each instance of
- * OSM_MEM has its own BIST_STATUS. Each OSM_MEM contains 32 BIST memory instances, so there are
- * 32 status bits per register.
+ * Results from BIST runs of OSM's memories. OSM_MEM is instantiated 2 times, each instance of
+ * OSM_MEM has its own BIST_STATUS. Each OSM_MEM contains 1 BIST memory instances, so there are
+ * 1 status bit per register.
  */
 union cvmx_osm_memx_bist_status {
 	uint64_t u64;
 	struct cvmx_osm_memx_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t bist_status                  : 32; /**< BIST status of BIST memory instance 31..0 in bits 31..0 respectively.
+	uint64_t bist_status                  : 32; /**< BIST status with one bit corresponding to each BIST memory instance.
                                                          INTERNAL: Each BIST Memory Instance (1 BIST engine + multiple physical memories) contains
                                                          2 physical memories. */
 #else
@@ -364,8 +565,41 @@ union cvmx_osm_memx_bist_status {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_osm_memx_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t bist_status                  : 1;  /**< BIST status with one bit corresponding to each BIST memory instance.
+                                                         INTERNAL: Each BIST Memory Instance (1 BIST engine + multiple physical memories) contains
+                                                         2 physical memories. */
+#else
+	uint64_t bist_status                  : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} cn73xx;
 	struct cvmx_osm_memx_bist_status_s    cn78xx;
 };
 typedef union cvmx_osm_memx_bist_status cvmx_osm_memx_bist_status_t;
 
+/**
+ * cvmx_osm_mem#_d#
+ */
+union cvmx_osm_memx_dx {
+	uint64_t u64;
+	struct cvmx_osm_memx_dx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t mem                          : 64; /**< OSM memory. THe last index in this memory corresponds to the row of data stored in OSM:
+                                                         D(0) = Data<63:0>.
+                                                         D(1) = Data<127:64>.
+                                                         D(2) = Data<191:128>.
+                                                         D(3) <63> = RAZ.
+                                                         D(3) <62:54> = ECC.(RO)
+                                                         D(3) <53:0> = Data<245:192>. */
+#else
+	uint64_t mem                          : 64;
+#endif
+	} s;
+	struct cvmx_osm_memx_dx_s             cn73xx;
+};
+typedef union cvmx_osm_memx_dx cvmx_osm_memx_dx_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pcie.h b/arch/mips/include/asm/octeon/cvmx-pcie.h
index 5f47db1..acfe933 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcie.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcie.h
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 104992 $<hr>
+ * <hr>$Revision: 108341 $<hr>
  */
 
 #ifndef __CVMX_PCIE_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 5d38c4b..6d7554a 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -53,642 +53,700 @@
 #define __CVMX_PCIEEPVFX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG000(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG000(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG000(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000000ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG000(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000000ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG000(block_id) (0x0000050000000000ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG000(offset) (0x0000050000000000ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG001(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG001(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG001(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000004ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG001(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000004ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG001(block_id) (0x0000050000000004ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG001(offset) (0x0000050000000004ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG002(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG002(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG002(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000008ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG002(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000008ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG002(block_id) (0x0000050000000008ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG002(offset) (0x0000050000000008ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG003(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG003(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG003(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000000Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG003(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000000Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG003(block_id) (0x000005000000000Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG003(offset) (0x000005000000000Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG004(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG004(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG004(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000010ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG004(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000010ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG004(block_id) (0x0000050000000010ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG004(offset) (0x0000050000000010ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG005(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG005(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG005(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000014ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG005(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000014ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG005(block_id) (0x0000050000000014ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG005(offset) (0x0000050000000014ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG006(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG006(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG006(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000018ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG006(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000018ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG006(block_id) (0x0000050000000018ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG006(offset) (0x0000050000000018ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG007(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG007(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG007(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000001Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG007(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000001Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG007(block_id) (0x000005000000001Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG007(offset) (0x000005000000001Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG008(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG008(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG008(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000020ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG008(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000020ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG008(block_id) (0x0000050000000020ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG008(offset) (0x0000050000000020ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG009(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG009(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG009(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000024ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG009(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000024ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG009(block_id) (0x0000050000000024ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG009(offset) (0x0000050000000024ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG010(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG010(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG010(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000028ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG010(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000028ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG010(block_id) (0x0000050000000028ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG010(offset) (0x0000050000000028ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG011(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG011(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG011(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000002Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG011(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000002Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG011(block_id) (0x000005000000002Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG011(offset) (0x000005000000002Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG012(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG012(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG012(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000030ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG012(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000030ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG012(block_id) (0x0000050000000030ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG012(offset) (0x0000050000000030ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG013(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG013(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG013(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000034ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG013(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000034ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG013(block_id) (0x0000050000000034ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG013(offset) (0x0000050000000034ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG015(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG015(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG015(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000003Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG015(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000003Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG015(block_id) (0x000005000000003Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG015(offset) (0x000005000000003Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG028(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG028(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG028(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000070ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG028(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000070ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG028(block_id) (0x0000050000000070ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG028(offset) (0x0000050000000070ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG029(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG029(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG029(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000074ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG029(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000074ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG029(block_id) (0x0000050000000074ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG029(offset) (0x0000050000000074ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG030(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG030(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG030(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000078ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG030(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000078ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG030(block_id) (0x0000050000000078ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG030(offset) (0x0000050000000078ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG031(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG031(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG031(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000007Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG031(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000007Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG031(block_id) (0x000005000000007Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG031(offset) (0x000005000000007Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG032(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG032(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG032(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000080ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG032(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000080ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG032(block_id) (0x0000050000000080ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG032(offset) (0x0000050000000080ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG037(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG037(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG037(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000094ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG037(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000094ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG037(block_id) (0x0000050000000094ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG037(offset) (0x0000050000000094ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG038(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG038(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG038(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000098ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG038(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000098ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG038(block_id) (0x0000050000000098ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG038(offset) (0x0000050000000098ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG039(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG039(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG039(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000009Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG039(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000009Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG039(block_id) (0x000005000000009Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG039(offset) (0x000005000000009Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG040(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG040(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG040(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000000A0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG040(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000000A0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG040(block_id) (0x00000500000000A0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG040(offset) (0x00000500000000A0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG044(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG044(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG044(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000000B0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG044(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000000B0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG044(block_id) (0x00000500000000B0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG044(offset) (0x00000500000000B0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG045(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG045(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG045(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000000B4ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG045(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000000B4ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG045(block_id) (0x00000500000000B4ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG045(offset) (0x00000500000000B4ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG046(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG046(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG046(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000000B8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG046(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000000B8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG046(block_id) (0x00000500000000B8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG046(offset) (0x00000500000000B8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG048(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG048(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG048(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000000C0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG048(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000000C0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG048(block_id) (0x00000500000000C0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG048(offset) (0x00000500000000C0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG049(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG049(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG049(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000000C4ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG049(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000000C4ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG049(block_id) (0x00000500000000C4ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG049(offset) (0x00000500000000C4ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG064(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG064(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG064(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000100ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG064(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000100ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG064(block_id) (0x0000050000000100ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG064(offset) (0x0000050000000100ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG082(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG082(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG082(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000148ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG082(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000148ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG082(block_id) (0x0000050000000148ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG082(offset) (0x0000050000000148ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG083(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG083(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG083(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000014Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG083(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000014Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG083(block_id) (0x000005000000014Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG083(offset) (0x000005000000014Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG448(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG448(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG448(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000700ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG448(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000700ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG448(block_id) (0x0000050000000700ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG448(offset) (0x0000050000000700ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG449(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG449(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG449(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000704ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG449(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000704ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG449(block_id) (0x0000050000000704ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG449(offset) (0x0000050000000704ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG450(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG450(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG450(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000708ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG450(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000708ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG450(block_id) (0x0000050000000708ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG450(offset) (0x0000050000000708ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG451(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG451(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG451(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000070Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG451(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000070Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG451(block_id) (0x000005000000070Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG451(offset) (0x000005000000070Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG452(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG452(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG452(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000710ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG452(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000710ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG452(block_id) (0x0000050000000710ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG452(offset) (0x0000050000000710ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG453(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG453(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG453(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000714ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG453(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000714ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG453(block_id) (0x0000050000000714ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG453(offset) (0x0000050000000714ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG454(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG454(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG454(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000718ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG454(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000718ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG454(block_id) (0x0000050000000718ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG454(offset) (0x0000050000000718ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG455(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG455(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG455(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000071Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG455(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000071Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG455(block_id) (0x000005000000071Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG455(offset) (0x000005000000071Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG456(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG456(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG456(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000720ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG456(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000720ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG456(block_id) (0x0000050000000720ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG456(offset) (0x0000050000000720ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG458(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG458(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG458(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000728ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG458(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000728ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG458(block_id) (0x0000050000000728ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG458(offset) (0x0000050000000728ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG459(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG459(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG459(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000072Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG459(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000072Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG459(block_id) (0x000005000000072Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG459(offset) (0x000005000000072Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG460(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG460(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG460(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000730ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG460(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000730ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG460(block_id) (0x0000050000000730ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG460(offset) (0x0000050000000730ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG461(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG461(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG461(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000734ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG461(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000734ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG461(block_id) (0x0000050000000734ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG461(offset) (0x0000050000000734ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG462(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG462(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG462(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000738ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG462(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000738ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG462(block_id) (0x0000050000000738ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG462(offset) (0x0000050000000738ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG463(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG463(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG463(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000073Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG463(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000073Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG463(block_id) (0x000005000000073Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG463(offset) (0x000005000000073Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG464(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG464(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG464(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000740ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG464(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000740ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG464(block_id) (0x0000050000000740ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG464(offset) (0x0000050000000740ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG465(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG465(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG465(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000744ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG465(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000744ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG465(block_id) (0x0000050000000744ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG465(offset) (0x0000050000000744ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG466(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG466(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG466(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000748ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG466(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000748ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG466(block_id) (0x0000050000000748ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG466(offset) (0x0000050000000748ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG467(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG467(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG467(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000074Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG467(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000074Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG467(block_id) (0x000005000000074Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG467(offset) (0x000005000000074Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG468(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG468(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG468(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000750ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG468(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000750ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG468(block_id) (0x0000050000000750ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG468(offset) (0x0000050000000750ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG490(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG490(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG490(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000007A8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG490(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000007A8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG490(block_id) (0x00000500000007A8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG490(offset) (0x00000500000007A8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG491(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG491(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG491(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000007ACull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG491(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000007ACull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG491(block_id) (0x00000500000007ACull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG491(offset) (0x00000500000007ACull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG492(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG492(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG492(%lu) is invalid on this chip\n", block_id);
-	return 0x00000500000007B0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG492(%lu) is invalid on this chip\n", offset);
+	return 0x00000500000007B0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG492(block_id) (0x00000500000007B0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG492(offset) (0x00000500000007B0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG515(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG515(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG515(%lu) is invalid on this chip\n", block_id);
-	return 0x000005000000080Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG515(%lu) is invalid on this chip\n", offset);
+	return 0x000005000000080Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG515(block_id) (0x000005000000080Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG515(offset) (0x000005000000080Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG516(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG516(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG516(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000810ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG516(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000810ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG516(block_id) (0x0000050000000810ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG516(offset) (0x0000050000000810ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG517(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPVFX_CFG517(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG517(%lu) is invalid on this chip\n", block_id);
-	return 0x0000050000000814ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPVFX_CFG517(%lu) is invalid on this chip\n", offset);
+	return 0x0000050000000814ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG517(block_id) (0x0000050000000814ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG517(offset) (0x0000050000000814ull + ((offset) & 3) * 0x100000000ull)
 #endif
 
 /**
@@ -708,6 +766,7 @@ union cvmx_pcieepvfx_cfg000 {
 	uint32_t devid                        : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg000_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg000_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg000 cvmx_pcieepvfx_cfg000_t;
@@ -773,6 +832,7 @@ union cvmx_pcieepvfx_cfg001 {
 	uint32_t dpe                          : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg001_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg001_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg001 cvmx_pcieepvfx_cfg001_t;
@@ -799,6 +859,7 @@ union cvmx_pcieepvfx_cfg002 {
 	uint32_t bcc                          : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg002_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg002_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg002 cvmx_pcieepvfx_cfg002_t;
@@ -829,6 +890,7 @@ union cvmx_pcieepvfx_cfg003 {
 	uint32_t bist                         : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg003_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg003_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg003 cvmx_pcieepvfx_cfg003_t;
@@ -848,6 +910,7 @@ union cvmx_pcieepvfx_cfg004 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg004_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg004_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg004 cvmx_pcieepvfx_cfg004_t;
@@ -867,6 +930,7 @@ union cvmx_pcieepvfx_cfg005 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg005_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg005_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg005 cvmx_pcieepvfx_cfg005_t;
@@ -886,6 +950,7 @@ union cvmx_pcieepvfx_cfg006 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg006_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg006_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg006 cvmx_pcieepvfx_cfg006_t;
@@ -905,6 +970,7 @@ union cvmx_pcieepvfx_cfg007 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg007_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg007_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg007 cvmx_pcieepvfx_cfg007_t;
@@ -924,6 +990,7 @@ union cvmx_pcieepvfx_cfg008 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg008_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg008_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg008 cvmx_pcieepvfx_cfg008_t;
@@ -943,6 +1010,7 @@ union cvmx_pcieepvfx_cfg009 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg009_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg009_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg009 cvmx_pcieepvfx_cfg009_t;
@@ -962,6 +1030,7 @@ union cvmx_pcieepvfx_cfg010 {
 	uint32_t cisp                         : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg010_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg010_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg010 cvmx_pcieepvfx_cfg010_t;
@@ -983,6 +1052,7 @@ union cvmx_pcieepvfx_cfg011 {
 	uint32_t ssid                         : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg011_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg011_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg011 cvmx_pcieepvfx_cfg011_t;
@@ -1006,6 +1076,7 @@ union cvmx_pcieepvfx_cfg012 {
 	uint32_t eraddr                       : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg012_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg012_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg012 cvmx_pcieepvfx_cfg012_t;
@@ -1027,6 +1098,7 @@ union cvmx_pcieepvfx_cfg013 {
 	uint32_t reserved_8_31                : 24;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg013_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg013_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg013 cvmx_pcieepvfx_cfg013_t;
@@ -1052,6 +1124,7 @@ union cvmx_pcieepvfx_cfg015 {
 	uint32_t ml                           : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg015_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg015_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg015 cvmx_pcieepvfx_cfg015_t;
@@ -1083,6 +1156,7 @@ union cvmx_pcieepvfx_cfg028 {
 	uint32_t reserved_30_31               : 2;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg028_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg028_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg028 cvmx_pcieepvfx_cfg028_t;
@@ -1124,6 +1198,7 @@ union cvmx_pcieepvfx_cfg029 {
 	uint32_t reserved_29_31               : 3;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg029_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg029_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg029 cvmx_pcieepvfx_cfg029_t;
@@ -1197,6 +1272,7 @@ union cvmx_pcieepvfx_cfg030 {
 	uint32_t reserved_22_31               : 10;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg030_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg030_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg030 cvmx_pcieepvfx_cfg030_t;
@@ -1252,6 +1328,7 @@ union cvmx_pcieepvfx_cfg031 {
 	uint32_t pnum                         : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg031_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg031_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg031 cvmx_pcieepvfx_cfg031_t;
@@ -1316,6 +1393,7 @@ union cvmx_pcieepvfx_cfg032 {
 	uint32_t lab                          : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg032_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg032_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg032 cvmx_pcieepvfx_cfg032_t;
@@ -1347,7 +1425,7 @@ union cvmx_pcieepvfx_cfg037 {
 	uint32_t atom64s                      : 1;  /**< 64-bit AtomicOp supported (not supported). */
 	uint32_t atom32s                      : 1;  /**< 32-bit AtomicOp supported (not supported). */
 	uint32_t atom_ops                     : 1;  /**< AtomicOp routing supported (not applicable for EP). */
-	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported. */
+	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not applicable for EP). */
 	uint32_t ctds                         : 1;  /**< Completion timeout disable supported. */
 	uint32_t ctrs                         : 4;  /**< Completion timeout ranges supported. */
 #else
@@ -1369,6 +1447,7 @@ union cvmx_pcieepvfx_cfg037 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg037_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg037_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg037 cvmx_pcieepvfx_cfg037_t;
@@ -1390,7 +1469,7 @@ union cvmx_pcieepvfx_cfg038 {
 	uint32_t id0_cp                       : 1;  /**< ID based ordering completion enable (not supported). */
 	uint32_t id0_rq                       : 1;  /**< ID based ordering request enable (not supported). */
 	uint32_t atom_op_eb                   : 1;  /**< AtomicOp egress blocking (not supported). */
-	uint32_t atom_op                      : 1;  /**< AtomicOp requester enable (not supported). */
+	uint32_t atom_op                      : 1;  /**< AtomicOp requester enable (not applicable for EP). */
 	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not supported). */
 	uint32_t ctd                          : 1;  /**< Completion timeout disable. */
 	uint32_t ctv                          : 4;  /**< Completion timeout value. Completion timeout programming is not supported. Completion
@@ -1409,6 +1488,7 @@ union cvmx_pcieepvfx_cfg038 {
 	uint32_t reserved_16_31               : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg038_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg038_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg038 cvmx_pcieepvfx_cfg038_t;
@@ -1445,6 +1525,7 @@ union cvmx_pcieepvfx_cfg039 {
 	uint32_t reserved_9_31                : 23;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg039_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg039_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg039 cvmx_pcieepvfx_cfg039_t;
@@ -1524,6 +1605,7 @@ union cvmx_pcieepvfx_cfg040 {
 	uint32_t reserved_17_31               : 15;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg040_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg040_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg040 cvmx_pcieepvfx_cfg040_t;
@@ -1556,6 +1638,7 @@ union cvmx_pcieepvfx_cfg044 {
 	uint32_t msixen                       : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg044_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg044_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg044 cvmx_pcieepvfx_cfg044_t;
@@ -1579,6 +1662,7 @@ union cvmx_pcieepvfx_cfg045 {
 	uint32_t msixtoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg045_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg045_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg045 cvmx_pcieepvfx_cfg045_t;
@@ -1603,6 +1687,7 @@ union cvmx_pcieepvfx_cfg046 {
 	uint32_t msixpoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg046_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg046_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg046 cvmx_pcieepvfx_cfg046_t;
@@ -1645,6 +1730,7 @@ union cvmx_pcieepvfx_cfg048 {
 	uint32_t pmes                         : 5;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg048_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg048_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg048 cvmx_pcieepvfx_cfg048_t;
@@ -1691,6 +1777,7 @@ union cvmx_pcieepvfx_cfg049 {
 	uint32_t pmdia                        : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg049_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg049_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg049 cvmx_pcieepvfx_cfg049_t;
@@ -1714,6 +1801,7 @@ union cvmx_pcieepvfx_cfg064 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg064_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg064_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg064 cvmx_pcieepvfx_cfg064_t;
@@ -1737,6 +1825,7 @@ union cvmx_pcieepvfx_cfg082 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg082_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg082_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg082 cvmx_pcieepvfx_cfg082_t;
@@ -1772,6 +1861,7 @@ union cvmx_pcieepvfx_cfg083 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg083_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg083_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg083 cvmx_pcieepvfx_cfg083_t;
@@ -1800,6 +1890,7 @@ union cvmx_pcieepvfx_cfg448 {
 	uint32_t rtl                          : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg448_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg448_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg448 cvmx_pcieepvfx_cfg448_t;
@@ -1826,6 +1917,7 @@ union cvmx_pcieepvfx_cfg449 {
 	uint32_t omr                          : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg449_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg449_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg449 cvmx_pcieepvfx_cfg449_t;
@@ -1896,6 +1988,7 @@ union cvmx_pcieepvfx_cfg450 {
 	uint32_t lpec                         : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg450_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg450_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg450 cvmx_pcieepvfx_cfg450_t;
@@ -1952,6 +2045,7 @@ union cvmx_pcieepvfx_cfg451 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg451_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg451_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg451 cvmx_pcieepvfx_cfg451_t;
@@ -2016,6 +2110,7 @@ union cvmx_pcieepvfx_cfg452 {
 	uint32_t reserved_22_31               : 10;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg452_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg452_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg452 cvmx_pcieepvfx_cfg452_t;
@@ -2046,6 +2141,7 @@ union cvmx_pcieepvfx_cfg453 {
 	uint32_t dlld                         : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg453_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg453_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg453 cvmx_pcieepvfx_cfg453_t;
@@ -2079,6 +2175,7 @@ union cvmx_pcieepvfx_cfg454 {
 	uint32_t reserved_29_31               : 3;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg454_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg454_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg454 cvmx_pcieepvfx_cfg454_t;
@@ -2134,6 +2231,7 @@ union cvmx_pcieepvfx_cfg455 {
 	uint32_t m_cfg0_filt                  : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg455_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg455_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg455 cvmx_pcieepvfx_cfg455_t;
@@ -2161,6 +2259,7 @@ union cvmx_pcieepvfx_cfg456 {
 	uint32_t reserved_4_31                : 28;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg456_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg456_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg456 cvmx_pcieepvfx_cfg456_t;
@@ -2180,6 +2279,7 @@ union cvmx_pcieepvfx_cfg458 {
 	uint32_t dbg_info_l32                 : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg458_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg458_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg458 cvmx_pcieepvfx_cfg458_t;
@@ -2199,6 +2299,7 @@ union cvmx_pcieepvfx_cfg459 {
 	uint32_t dbg_info_u32                 : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg459_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg459_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg459 cvmx_pcieepvfx_cfg459_t;
@@ -2224,6 +2325,7 @@ union cvmx_pcieepvfx_cfg460 {
 	uint32_t reserved_20_31               : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg460_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg460_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg460 cvmx_pcieepvfx_cfg460_t;
@@ -2249,6 +2351,7 @@ union cvmx_pcieepvfx_cfg461 {
 	uint32_t reserved_20_31               : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg461_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg461_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg461 cvmx_pcieepvfx_cfg461_t;
@@ -2274,6 +2377,7 @@ union cvmx_pcieepvfx_cfg462 {
 	uint32_t reserved_20_31               : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg462_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg462_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg462 cvmx_pcieepvfx_cfg462_t;
@@ -2312,6 +2416,7 @@ union cvmx_pcieepvfx_cfg463 {
 	uint32_t fcltoe                       : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg463_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg463_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg463 cvmx_pcieepvfx_cfg463_t;
@@ -2337,6 +2442,7 @@ union cvmx_pcieepvfx_cfg464 {
 	uint32_t wrr_vc3                      : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg464_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg464_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg464 cvmx_pcieepvfx_cfg464_t;
@@ -2362,6 +2468,7 @@ union cvmx_pcieepvfx_cfg465 {
 	uint32_t wrr_vc7                      : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg465_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg465_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg465 cvmx_pcieepvfx_cfg465_t;
@@ -2407,6 +2514,7 @@ union cvmx_pcieepvfx_cfg466 {
 	uint32_t rx_queue_order               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg466_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg466_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg466 cvmx_pcieepvfx_cfg466_t;
@@ -2444,6 +2552,7 @@ union cvmx_pcieepvfx_cfg467 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg467_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg467_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg467 cvmx_pcieepvfx_cfg467_t;
@@ -2482,6 +2591,7 @@ union cvmx_pcieepvfx_cfg468 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg468_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg468_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg468 cvmx_pcieepvfx_cfg468_t;
@@ -2509,6 +2619,7 @@ union cvmx_pcieepvfx_cfg490 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg490_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg490_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg490 cvmx_pcieepvfx_cfg490_t;
@@ -2536,6 +2647,7 @@ union cvmx_pcieepvfx_cfg491 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg491_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg491_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg491 cvmx_pcieepvfx_cfg491_t;
@@ -2563,6 +2675,7 @@ union cvmx_pcieepvfx_cfg492 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg492_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg492_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg492 cvmx_pcieepvfx_cfg492_t;
@@ -2603,6 +2716,7 @@ union cvmx_pcieepvfx_cfg515 {
 	uint32_t reserved_21_31               : 11;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg515_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg515_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg515 cvmx_pcieepvfx_cfg515_t;
@@ -2622,6 +2736,7 @@ union cvmx_pcieepvfx_cfg516 {
 	uint32_t phy_stat                     : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg516_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg516_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg516 cvmx_pcieepvfx_cfg516_t;
@@ -2641,6 +2756,7 @@ union cvmx_pcieepvfx_cfg517 {
 	uint32_t phy_ctrl                     : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg517_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg517_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg517 cvmx_pcieepvfx_cfg517_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index c576d9d..e8182c5 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -53,7 +53,7 @@
 #define __CVMX_PCIEEPX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -61,28 +61,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000000ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000000ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000000ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG000 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG000 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000000ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -95,15 +96,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000000ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000000ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -111,28 +113,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000004ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000004ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000004ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000004ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG001 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG001 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000004ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -145,15 +148,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000004ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000004ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000004ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000004ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -161,28 +165,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000008ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000008ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000008ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000008ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG002 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG002 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000008ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -195,15 +200,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000008ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000008ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000008ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000008ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -211,28 +217,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000000Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000000Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000000Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000000Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG003 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG003 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000000Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -245,15 +252,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000000Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000000Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000000Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000000Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -261,28 +269,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000010ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000010ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000010ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000010ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG004 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG004 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000010ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -295,15 +304,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000010ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000010ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000010ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000010ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -311,28 +321,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000080000010ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000080000010ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030080000010ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030080000010ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG004_MASK (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG004_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000010ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -345,15 +356,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000080000010ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000010ull + (block_id) * 0x100000000ull;
+			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000010ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000010ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -361,28 +373,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000014ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000014ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000014ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000014ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG005 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG005 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000014ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -395,15 +408,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000014ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000014ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000014ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000014ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -411,28 +425,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000080000014ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000080000014ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030080000014ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030080000014ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG005_MASK (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG005_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000014ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -445,15 +460,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000080000014ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000014ull + (block_id) * 0x100000000ull;
+			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000014ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000014ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -461,28 +477,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000018ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000018ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000018ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000018ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG006 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG006 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000018ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -495,15 +512,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000018ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000018ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000018ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000018ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -511,28 +529,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000080000018ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000080000018ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030080000018ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030080000018ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG006_MASK (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG006_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000018ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -545,15 +564,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000080000018ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000018ull + (block_id) * 0x100000000ull;
+			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000018ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000018ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -561,28 +581,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000001Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000001Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000001Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000001Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG007 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG007 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000001Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -595,15 +616,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000001Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000001Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000001Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000001Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -611,28 +633,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000008000001Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000008000001Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003008000001Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003008000001Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG007_MASK (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG007_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000008000001Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -645,15 +668,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000008000001Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003008000001Cull + (block_id) * 0x100000000ull;
+			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003008000001Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000008000001Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -661,28 +685,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000020ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000020ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000020ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000020ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG008 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG008 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000020ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -695,15 +720,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000020ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000020ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000020ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000020ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -711,28 +737,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000080000020ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000080000020ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030080000020ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030080000020ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG008_MASK (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG008_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000020ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -745,15 +772,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000080000020ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000020ull + (block_id) * 0x100000000ull;
+			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000020ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000020ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -761,28 +789,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000024ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000024ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000024ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000024ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG009 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG009 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000024ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -795,15 +824,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000024ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000024ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000024ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000024ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -811,28 +841,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000080000024ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000080000024ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030080000024ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030080000024ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG009_MASK (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG009_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000024ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -845,15 +876,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000080000024ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000024ull + (block_id) * 0x100000000ull;
+			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000024ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000024ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -861,28 +893,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000028ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000028ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000028ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000028ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG010 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG010 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000028ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -895,15 +928,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000028ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000028ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000028ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000028ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -911,28 +945,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000002Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000002Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000002Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000002Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG011 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG011 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000002Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -945,15 +980,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000002Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000002Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000002Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000002Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -961,28 +997,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000030ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000030ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000030ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000030ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG012 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG012 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000030ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -995,15 +1032,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000030ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000030ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000030ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000030ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1011,28 +1049,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000080000030ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000080000030ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030080000030ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030080000030ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG012_MASK (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG012_MASK (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000080000030ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1045,15 +1084,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000080000030ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000030ull + (block_id) * 0x100000000ull;
+			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000030ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000080000030ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1061,28 +1101,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000034ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000034ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000034ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000034ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG013 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG013 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000034ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1095,15 +1136,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000034ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000034ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000034ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000034ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1111,28 +1153,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000003Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000003Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000003Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000003Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG015 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG015 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000003Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1145,15 +1188,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000003Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000003Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000003Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000003Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1161,28 +1205,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000040ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000040ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000040ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000040ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG016 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG016 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000040ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1195,15 +1240,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000040ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000040ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000040ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000040ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1211,28 +1257,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000044ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000044ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000044ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000044ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG017 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG017 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000044ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1245,15 +1292,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000044ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000044ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000044ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000044ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1261,28 +1309,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000050ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000050ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000050ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000050ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG020 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG020 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000050ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1295,15 +1344,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000050ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000050ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000050ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000050ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1311,28 +1361,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000054ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000054ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000054ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000054ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG021 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG021 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000054ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1345,15 +1396,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000054ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000054ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000054ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000054ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1361,28 +1413,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000058ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000058ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000058ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000058ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG022 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG022 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000058ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1395,15 +1448,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000058ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000058ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000058ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000058ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1411,28 +1465,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000005Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000005Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000005Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000005Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG023 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG023 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000005Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1445,39 +1500,42 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000005Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000005Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000005Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000005Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG024(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG024(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG024(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000060ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG024(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000060ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG024(block_id) (0x0000030000000060ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG024(offset) (0x0000030000000060ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG025(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG025(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG025(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000064ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG025(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000064ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG025(block_id) (0x0000030000000064ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG025(offset) (0x0000030000000064ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1485,28 +1543,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000070ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000070ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000070ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000070ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG028 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG028 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000070ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1519,15 +1578,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000070ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000070ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000070ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000070ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1535,28 +1595,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000074ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000074ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000074ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000074ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG029 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG029 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000074ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1569,15 +1630,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000074ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000074ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000074ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000074ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1585,28 +1647,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000078ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000078ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000078ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000078ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG030 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG030 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000078ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1619,15 +1682,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000078ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000078ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000078ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000078ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1635,28 +1699,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000007Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000007Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000007Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000007Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG031 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG031 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000007Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1669,15 +1734,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000007Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000007Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000007Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000007Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1685,28 +1751,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000080ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000080ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000080ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000080ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG032 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG032 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000080ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1719,41 +1786,42 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000080ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000080ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000080ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000080ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG033(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG033(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG033(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG033(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000084ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG033(block_id) (0x0000000000000084ull)
+#define CVMX_PCIEEPX_CFG033(offset) (0x0000000000000084ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG034(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG034(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG034(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG034(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000088ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG034(block_id) (0x0000000000000088ull)
+#define CVMX_PCIEEPX_CFG034(offset) (0x0000000000000088ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1761,28 +1829,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000094ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000094ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000094ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000094ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG037 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG037 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000094ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1795,15 +1864,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000094ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000094ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000094ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000094ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1811,28 +1881,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000098ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000098ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000098ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000098ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG038 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG038 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000098ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1845,15 +1916,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000098ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000098ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000098ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000098ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1861,28 +1933,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000009Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000009Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000009Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000009Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG039 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG039 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000009Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1895,15 +1968,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000009Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000009Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000009Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000009Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1911,28 +1985,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000000A0ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x00000000000000A0ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000300000000A0ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x00000300000000A0ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG040 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG040 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000000A0ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1945,74 +2020,78 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000000A0ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000300000000A0ull + (block_id) * 0x100000000ull;
+			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000300000000A0ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000000A0ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG041(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG041(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG041(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG041(%lu) is invalid on this chip\n", offset);
 	return 0x00000000000000A4ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG041(block_id) (0x00000000000000A4ull)
+#define CVMX_PCIEEPX_CFG041(offset) (0x00000000000000A4ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG042(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG042(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG042(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG042(%lu) is invalid on this chip\n", offset);
 	return 0x00000000000000A8ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG042(block_id) (0x00000000000000A8ull)
+#define CVMX_PCIEEPX_CFG042(offset) (0x00000000000000A8ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG044(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG044(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG044(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000000B0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG044(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000000B0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG044(block_id) (0x00000300000000B0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG044(offset) (0x00000300000000B0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG045(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG045(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG045(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000000B4ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG045(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000000B4ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG045(block_id) (0x00000300000000B4ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG045(offset) (0x00000300000000B4ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG046(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG046(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG046(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000000B8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG046(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000000B8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG046(block_id) (0x00000300000000B8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG046(offset) (0x00000300000000B8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2020,28 +2099,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000100ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000100ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000100ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000100ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG064 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG064 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000100ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2054,15 +2134,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000100ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000100ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000100ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000100ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2070,28 +2151,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000104ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000104ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000104ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000104ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG065 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG065 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000104ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2104,15 +2186,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000104ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000104ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000104ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000104ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2120,28 +2203,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000108ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000108ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000108ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000108ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG066 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG066 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000108ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2154,15 +2238,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000108ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000108ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000108ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000108ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2170,28 +2255,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000010Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000010Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000010Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000010Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG067 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG067 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000010Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2204,15 +2290,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000010Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000010Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000010Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000010Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2220,28 +2307,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000110ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000110ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000110ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000110ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG068 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG068 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000110ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2254,15 +2342,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000110ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000110ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000110ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000110ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2270,28 +2359,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000114ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000114ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000114ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000114ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG069 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG069 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000114ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2304,15 +2394,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000114ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000114ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000114ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000114ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2320,28 +2411,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000118ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000118ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000118ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000118ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG070 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG070 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000118ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2354,15 +2446,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000118ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000118ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000118ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000118ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2370,28 +2463,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000011Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000011Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000011Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000011Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG071 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG071 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000011Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2404,15 +2498,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000011Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000011Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000011Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000011Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2420,28 +2515,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000120ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000120ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000120ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000120ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG072 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG072 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000120ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2454,15 +2550,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000120ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000120ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000120ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000120ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2470,28 +2567,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000124ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000124ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000124ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000124ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG073 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG073 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000124ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2504,15 +2602,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000124ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000124ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000124ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000124ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2520,28 +2619,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000128ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000128ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000128ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000128ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG074 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG074 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000128ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2554,347 +2654,377 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000128ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000128ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000128ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000128ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG078(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG078(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG078(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000138ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG078(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000138ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG078(block_id) (0x0000030000000138ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG078(offset) (0x0000030000000138ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG082(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG082(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG082(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000148ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG082(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000148ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG082(block_id) (0x0000030000000148ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG082(offset) (0x0000030000000148ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG083(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG083(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG083(%lu) is invalid on this chip\n", block_id);
-	return 0x000003000000014Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG083(%lu) is invalid on this chip\n", offset);
+	return 0x000003000000014Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG083(block_id) (0x000003000000014Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG083(offset) (0x000003000000014Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG084(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG084(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG084(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000150ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG084(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000150ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG084(block_id) (0x0000030000000150ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG084(offset) (0x0000030000000150ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG086(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG086(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG086(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000158ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG086(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000158ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG086(block_id) (0x0000030000000158ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG086(offset) (0x0000030000000158ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG087(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG087(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG087(%lu) is invalid on this chip\n", block_id);
-	return 0x000003000000015Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG087(%lu) is invalid on this chip\n", offset);
+	return 0x000003000000015Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG087(block_id) (0x000003000000015Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG087(offset) (0x000003000000015Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG088(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG088(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG088(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000160ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG088(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000160ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG088(block_id) (0x0000030000000160ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG088(offset) (0x0000030000000160ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG089(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG089(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG089(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000164ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG089(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000164ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG089(block_id) (0x0000030000000164ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG089(offset) (0x0000030000000164ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG090(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG090(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG090(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000168ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG090(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000168ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG090(block_id) (0x0000030000000168ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG090(offset) (0x0000030000000168ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG091(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG091(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG091(%lu) is invalid on this chip\n", block_id);
-	return 0x000003000000016Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG091(%lu) is invalid on this chip\n", offset);
+	return 0x000003000000016Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG091(block_id) (0x000003000000016Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG091(offset) (0x000003000000016Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG092(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG092(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG092(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000170ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG092(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000170ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG092(block_id) (0x0000030000000170ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG092(offset) (0x0000030000000170ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG094(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG094(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG094(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000178ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG094(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000178ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG094(block_id) (0x0000030000000178ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG094(offset) (0x0000030000000178ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG095(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG095(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG095(%lu) is invalid on this chip\n", block_id);
-	return 0x000003000000017Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG095(%lu) is invalid on this chip\n", offset);
+	return 0x000003000000017Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG095(block_id) (0x000003000000017Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG095(offset) (0x000003000000017Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG096(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG096(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG096(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000180ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG096(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000180ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG096(block_id) (0x0000030000000180ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG096(offset) (0x0000030000000180ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG097(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG097(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG097(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000184ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG097(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000184ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG097(block_id) (0x0000030000000184ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG097(offset) (0x0000030000000184ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG098(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG098(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG098(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000188ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG098(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000188ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG098(block_id) (0x0000030000000188ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG098(offset) (0x0000030000000188ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG099(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG099(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG099(%lu) is invalid on this chip\n", block_id);
-	return 0x000003000000018Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG099(%lu) is invalid on this chip\n", offset);
+	return 0x000003000000018Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG099(block_id) (0x000003000000018Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG099(offset) (0x000003000000018Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG100(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG100(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG100(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000190ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG100(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000190ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG100(block_id) (0x0000030000000190ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG100(offset) (0x0000030000000190ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG101(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG101(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG101(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000194ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG101(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000194ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG101(block_id) (0x0000030000000194ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG101(offset) (0x0000030000000194ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG102(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG102(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG102(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000198ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG102(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000198ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG102(block_id) (0x0000030000000198ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG102(offset) (0x0000030000000198ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG103(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG103(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG103(%lu) is invalid on this chip\n", block_id);
-	return 0x000003000000019Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG103(%lu) is invalid on this chip\n", offset);
+	return 0x000003000000019Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG103(block_id) (0x000003000000019Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG103(offset) (0x000003000000019Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG104(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG104(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG104(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001A0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG104(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001A0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG104(block_id) (0x00000300000001A0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG104(offset) (0x00000300000001A0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG105(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG105(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG105(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001A4ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG105(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001A4ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG105(block_id) (0x00000300000001A4ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG105(offset) (0x00000300000001A4ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG106(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG106(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG106(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001A8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG106(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001A8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG106(block_id) (0x00000300000001A8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG106(offset) (0x00000300000001A8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG107(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG107(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG107(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001ACull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG107(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001ACull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG107(block_id) (0x00000300000001ACull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG107(offset) (0x00000300000001ACull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG108(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG108(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG108(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001B0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG108(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001B0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG108(block_id) (0x00000300000001B0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG108(offset) (0x00000300000001B0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG109(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG109(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG109(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001B4ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG109(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001B4ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG109(block_id) (0x00000300000001B4ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG109(offset) (0x00000300000001B4ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG110(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG110(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG110(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001B8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG110(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001B8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG110(block_id) (0x00000300000001B8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG110(offset) (0x00000300000001B8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG111(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG111(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG111(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001BCull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG111(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001BCull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG111(block_id) (0x00000300000001BCull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG111(offset) (0x00000300000001BCull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG112(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG112(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG112(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000001C0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG112(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000001C0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG112(block_id) (0x00000300000001C0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG112(offset) (0x00000300000001C0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2902,28 +3032,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000700ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000700ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000700ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000700ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG448 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG448 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000700ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2936,15 +3067,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000700ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000700ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000700ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000700ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2952,28 +3084,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000704ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000704ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000704ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000704ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG449 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG449 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000704ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2986,15 +3119,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000704ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000704ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000704ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000704ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3002,28 +3136,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000708ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000708ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000708ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000708ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG450 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG450 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000708ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3036,15 +3171,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000708ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000708ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000708ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000708ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3052,28 +3188,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000070Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000070Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000070Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000070Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG451 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG451 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000070Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3086,15 +3223,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000070Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000070Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000070Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000070Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3102,28 +3240,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000710ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000710ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000710ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000710ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG452 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG452 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000710ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3136,15 +3275,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000710ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000710ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000710ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000710ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3152,28 +3292,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000714ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000714ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000714ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000714ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG453 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG453 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000714ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3186,15 +3327,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000714ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000714ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000714ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000714ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3202,28 +3344,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000718ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000718ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000718ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000718ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG454 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG454 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000718ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3236,15 +3379,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000718ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000718ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000718ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000718ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3252,28 +3396,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000071Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000071Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000071Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000071Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG455 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG455 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000071Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3286,15 +3431,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000071Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000071Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000071Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000071Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3302,28 +3448,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000720ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000720ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000720ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000720ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG456 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG456 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000720ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3336,15 +3483,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000720ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000720ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000720ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000720ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3352,28 +3500,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000728ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000728ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000728ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000728ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG458 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG458 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000728ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3386,15 +3535,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000728ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000728ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000728ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000728ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3402,28 +3552,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000072Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000072Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000072Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000072Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG459 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG459 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000072Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3436,15 +3587,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000072Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000072Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000072Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000072Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3452,28 +3604,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000730ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000730ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000730ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000730ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG460 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG460 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000730ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3486,15 +3639,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000730ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000730ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000730ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000730ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3502,28 +3656,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000734ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000734ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000734ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000734ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG461 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG461 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000734ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3536,15 +3691,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000734ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000734ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000734ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000734ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3552,28 +3708,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000738ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000738ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000738ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000738ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG462 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG462 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000738ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3586,15 +3743,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000738ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000738ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000738ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000738ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3602,28 +3760,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000073Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000073Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000073Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000073Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG463 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG463 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000073Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3636,15 +3795,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000073Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000073Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000073Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000073Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3652,28 +3812,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000740ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000740ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000740ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000740ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG464 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG464 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000740ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3686,15 +3847,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000740ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000740ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000740ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000740ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3702,28 +3864,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000744ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000744ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000744ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000744ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG465 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG465 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000744ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3736,15 +3899,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000744ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000744ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000744ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000744ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3752,28 +3916,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000748ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000748ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000748ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000748ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG466 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG466 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000748ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3786,15 +3951,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000748ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000748ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000748ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000748ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3802,28 +3968,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000074Cull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x000000000000074Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000074Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000074Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG467 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG467 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000074Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3836,15 +4003,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000074Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000074Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000074Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000074Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3852,28 +4020,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000750ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000750ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000750ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000750ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG468 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG468 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000750ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3886,15 +4055,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000750ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000750ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000750ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000750ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG490(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG490(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3902,24 +4072,24 @@ static inline uint64_t CVMX_PCIEEPX_CFG490(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000007A8ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x00000000000007A8ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000300000007A8ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000300000007A8ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG490 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG490 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000007A8ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG490(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG490(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3932,13 +4102,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG490(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000007A8ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000300000007A8ull + (block_id) * 0x100000000ull;
+			return 0x00000300000007A8ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000007A8ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG491(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG491(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3946,24 +4116,24 @@ static inline uint64_t CVMX_PCIEEPX_CFG491(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000007ACull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x00000000000007ACull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000300000007ACull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000300000007ACull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG491 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG491 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000007ACull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG491(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG491(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3976,13 +4146,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG491(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000007ACull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000300000007ACull + (block_id) * 0x100000000ull;
+			return 0x00000300000007ACull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000007ACull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG492(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG492(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3990,24 +4160,24 @@ static inline uint64_t CVMX_PCIEEPX_CFG492(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000007B0ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x00000000000007B0ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000300000007B0ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000300000007B0ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG492 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG492 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000007B0ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG492(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG492(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4020,13 +4190,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG492(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000007B0ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000300000007B0ull + (block_id) * 0x100000000ull;
+			return 0x00000300000007B0ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000007B0ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4034,23 +4204,24 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000080Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000003000000080Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000003000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000003000000080Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000003000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG515 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG515 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000080Cull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4060,15 +4231,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000080Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000080Cull + (block_id) * 0x100000000ull;
+			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000080Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000080Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4076,28 +4248,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000810ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000810ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000810ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000810ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG516 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG516 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000810ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4110,15 +4283,16 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000810ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000810ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000810ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000810ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4126,28 +4300,29 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000814ull;
 			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return 0x0000000000000814ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000030000000814ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000030000000814ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIEEPX_CFG517 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIEEPX_CFG517 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000814ull;
 }
 #else
-static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4160,45 +4335,49 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000814ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000814ull + (block_id) * 0x100000000ull;
+			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000814ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000814ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG548(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG548(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG548(%lu) is invalid on this chip\n", block_id);
-	return 0x0000030000000890ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG548(%lu) is invalid on this chip\n", offset);
+	return 0x0000030000000890ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG548(block_id) (0x0000030000000890ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG548(offset) (0x0000030000000890ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG554(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG554(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG554(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000008A8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG554(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000008A8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG554(block_id) (0x00000300000008A8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG554(offset) (0x00000300000008A8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPX_CFG558(unsigned long block_id)
+static inline uint64_t CVMX_PCIEEPX_CFG558(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIEEPX_CFG558(%lu) is invalid on this chip\n", block_id);
-	return 0x00000300000008B8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIEEPX_CFG558(%lu) is invalid on this chip\n", offset);
+	return 0x00000300000008B8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPX_CFG558(block_id) (0x00000300000008B8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPX_CFG558(offset) (0x00000300000008B8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 
 /**
@@ -4238,6 +4417,7 @@ union cvmx_pcieepx_cfg000 {
 	struct cvmx_pcieepx_cfg000_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg000_s          cn70xx;
 	struct cvmx_pcieepx_cfg000_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg000_s          cn73xx;
 	struct cvmx_pcieepx_cfg000_s          cn78xx;
 	struct cvmx_pcieepx_cfg000_s          cnf71xx;
 };
@@ -4326,6 +4506,7 @@ union cvmx_pcieepx_cfg001 {
 	struct cvmx_pcieepx_cfg001_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg001_s          cn70xx;
 	struct cvmx_pcieepx_cfg001_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg001_s          cn73xx;
 	struct cvmx_pcieepx_cfg001_s          cn78xx;
 	struct cvmx_pcieepx_cfg001_s          cnf71xx;
 };
@@ -4368,6 +4549,7 @@ union cvmx_pcieepx_cfg002 {
 	struct cvmx_pcieepx_cfg002_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg002_s          cn70xx;
 	struct cvmx_pcieepx_cfg002_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg002_s          cn73xx;
 	struct cvmx_pcieepx_cfg002_s          cn78xx;
 	struct cvmx_pcieepx_cfg002_s          cnf71xx;
 };
@@ -4419,6 +4601,7 @@ union cvmx_pcieepx_cfg003 {
 	struct cvmx_pcieepx_cfg003_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg003_s          cn70xx;
 	struct cvmx_pcieepx_cfg003_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg003_s          cn73xx;
 	struct cvmx_pcieepx_cfg003_s          cn78xx;
 	struct cvmx_pcieepx_cfg003_s          cnf71xx;
 };
@@ -4491,6 +4674,30 @@ union cvmx_pcieepx_cfg004 {
 	struct cvmx_pcieepx_cfg004_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg004_cn52xx     cn70xx;
 	struct cvmx_pcieepx_cfg004_cn52xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg004_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t lbab                         : 8;  /**< Lower bits of the BAR 0 base address. */
+	uint32_t reserved_4_23                : 20;
+	uint32_t pf                           : 1;  /**< Prefetchable. This field is writable through PEM()_CFG_WR. However, the application
+                                                         must not change this field. */
+	uint32_t typ                          : 2;  /**< BAR type.
+                                                         0x0 = 32-bit BAR.
+                                                         0x2 = 64-bit BAR.
+                                                         This field is writable through PEM()_CFG_WR. However, the application must not change
+                                                         this field. */
+	uint32_t mspc                         : 1;  /**< Memory space indicator.
+                                                         0 = BAR 0 is a memory BAR.
+                                                         1 = BAR 0 is an I/O BAR.
+                                                         This field is writable through PEM()_CFG_WR. However, the application must not change
+                                                         this field. */
+#else
+	uint32_t mspc                         : 1;
+	uint32_t typ                          : 2;
+	uint32_t pf                           : 1;
+	uint32_t reserved_4_23                : 20;
+	uint32_t lbab                         : 8;
+#endif
+	} cn73xx;
 	struct cvmx_pcieepx_cfg004_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t lbab                         : 17; /**< Lower bits of the BAR 0 base address. */
@@ -4554,6 +4761,7 @@ union cvmx_pcieepx_cfg004_mask {
 	struct cvmx_pcieepx_cfg004_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg004_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg004_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg004_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg004_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg004_mask_s     cnf71xx;
 };
@@ -4586,6 +4794,7 @@ union cvmx_pcieepx_cfg005 {
 	struct cvmx_pcieepx_cfg005_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg005_s          cn70xx;
 	struct cvmx_pcieepx_cfg005_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg005_s          cn73xx;
 	struct cvmx_pcieepx_cfg005_s          cn78xx;
 	struct cvmx_pcieepx_cfg005_s          cnf71xx;
 };
@@ -4618,6 +4827,7 @@ union cvmx_pcieepx_cfg005_mask {
 	struct cvmx_pcieepx_cfg005_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg005_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg005_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg005_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg005_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg005_mask_s     cnf71xx;
 };
@@ -4668,6 +4878,7 @@ union cvmx_pcieepx_cfg006 {
 	struct cvmx_pcieepx_cfg006_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg006_s          cn70xx;
 	struct cvmx_pcieepx_cfg006_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg006_s          cn73xx;
 	struct cvmx_pcieepx_cfg006_s          cn78xx;
 	struct cvmx_pcieepx_cfg006_s          cnf71xx;
 };
@@ -4708,6 +4919,7 @@ union cvmx_pcieepx_cfg006_mask {
 	struct cvmx_pcieepx_cfg006_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg006_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg006_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg006_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg006_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg006_mask_s     cnf71xx;
 };
@@ -4740,6 +4952,7 @@ union cvmx_pcieepx_cfg007 {
 	struct cvmx_pcieepx_cfg007_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg007_s          cn70xx;
 	struct cvmx_pcieepx_cfg007_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg007_s          cn73xx;
 	struct cvmx_pcieepx_cfg007_s          cn78xx;
 	struct cvmx_pcieepx_cfg007_s          cnf71xx;
 };
@@ -4772,6 +4985,7 @@ union cvmx_pcieepx_cfg007_mask {
 	struct cvmx_pcieepx_cfg007_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg007_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg007_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg007_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg007_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg007_mask_s     cnf71xx;
 };
@@ -4844,6 +5058,7 @@ union cvmx_pcieepx_cfg008 {
 	struct cvmx_pcieepx_cfg008_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg008_s          cn70xx;
 	struct cvmx_pcieepx_cfg008_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg008_s          cn73xx;
 	struct cvmx_pcieepx_cfg008_s          cn78xx;
 	struct cvmx_pcieepx_cfg008_cn52xx     cnf71xx;
 };
@@ -4884,6 +5099,7 @@ union cvmx_pcieepx_cfg008_mask {
 	struct cvmx_pcieepx_cfg008_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg008_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg008_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg008_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg008_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg008_mask_s     cnf71xx;
 };
@@ -4938,6 +5154,7 @@ union cvmx_pcieepx_cfg009 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg009_cn70xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg009_cn70xx     cn73xx;
 	struct cvmx_pcieepx_cfg009_cn70xx     cn78xx;
 	struct cvmx_pcieepx_cfg009_cn61xx     cnf71xx;
 };
@@ -4970,6 +5187,7 @@ union cvmx_pcieepx_cfg009_mask {
 	struct cvmx_pcieepx_cfg009_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg009_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg009_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg009_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg009_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg009_mask_s     cnf71xx;
 };
@@ -5003,6 +5221,7 @@ union cvmx_pcieepx_cfg010 {
 	struct cvmx_pcieepx_cfg010_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg010_s          cn70xx;
 	struct cvmx_pcieepx_cfg010_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg010_s          cn73xx;
 	struct cvmx_pcieepx_cfg010_s          cn78xx;
 	struct cvmx_pcieepx_cfg010_s          cnf71xx;
 };
@@ -5040,6 +5259,7 @@ union cvmx_pcieepx_cfg011 {
 	struct cvmx_pcieepx_cfg011_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg011_s          cn70xx;
 	struct cvmx_pcieepx_cfg011_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg011_s          cn73xx;
 	struct cvmx_pcieepx_cfg011_s          cn78xx;
 	struct cvmx_pcieepx_cfg011_s          cnf71xx;
 };
@@ -5076,6 +5296,7 @@ union cvmx_pcieepx_cfg012 {
 	struct cvmx_pcieepx_cfg012_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg012_s          cn70xx;
 	struct cvmx_pcieepx_cfg012_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg012_s          cn73xx;
 	struct cvmx_pcieepx_cfg012_s          cn78xx;
 	struct cvmx_pcieepx_cfg012_s          cnf71xx;
 };
@@ -5116,6 +5337,7 @@ union cvmx_pcieepx_cfg012_mask {
 	struct cvmx_pcieepx_cfg012_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg012_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg012_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg012_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg012_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg012_mask_s     cnf71xx;
 };
@@ -5153,6 +5375,7 @@ union cvmx_pcieepx_cfg013 {
 	struct cvmx_pcieepx_cfg013_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg013_s          cn70xx;
 	struct cvmx_pcieepx_cfg013_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg013_s          cn73xx;
 	struct cvmx_pcieepx_cfg013_s          cn78xx;
 	struct cvmx_pcieepx_cfg013_s          cnf71xx;
 };
@@ -5196,6 +5419,7 @@ union cvmx_pcieepx_cfg015 {
 	struct cvmx_pcieepx_cfg015_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg015_s          cn70xx;
 	struct cvmx_pcieepx_cfg015_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg015_s          cn73xx;
 	struct cvmx_pcieepx_cfg015_s          cn78xx;
 	struct cvmx_pcieepx_cfg015_s          cnf71xx;
 };
@@ -5261,6 +5485,7 @@ union cvmx_pcieepx_cfg016 {
 	struct cvmx_pcieepx_cfg016_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg016_s          cn70xx;
 	struct cvmx_pcieepx_cfg016_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg016_s          cn73xx;
 	struct cvmx_pcieepx_cfg016_s          cn78xx;
 	struct cvmx_pcieepx_cfg016_s          cnf71xx;
 };
@@ -5326,6 +5551,7 @@ union cvmx_pcieepx_cfg017 {
 	struct cvmx_pcieepx_cfg017_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg017_s          cn70xx;
 	struct cvmx_pcieepx_cfg017_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg017_s          cn73xx;
 	struct cvmx_pcieepx_cfg017_s          cn78xx;
 	struct cvmx_pcieepx_cfg017_s          cnf71xx;
 };
@@ -5408,6 +5634,7 @@ union cvmx_pcieepx_cfg020 {
 	struct cvmx_pcieepx_cfg020_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg020_s          cn70xx;
 	struct cvmx_pcieepx_cfg020_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg020_s          cn73xx;
 	struct cvmx_pcieepx_cfg020_s          cn78xx;
 	struct cvmx_pcieepx_cfg020_s          cnf71xx;
 };
@@ -5442,6 +5669,7 @@ union cvmx_pcieepx_cfg021 {
 	struct cvmx_pcieepx_cfg021_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg021_s          cn70xx;
 	struct cvmx_pcieepx_cfg021_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg021_s          cn73xx;
 	struct cvmx_pcieepx_cfg021_s          cn78xx;
 	struct cvmx_pcieepx_cfg021_s          cnf71xx;
 };
@@ -5474,6 +5702,7 @@ union cvmx_pcieepx_cfg022 {
 	struct cvmx_pcieepx_cfg022_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg022_s          cn70xx;
 	struct cvmx_pcieepx_cfg022_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg022_s          cn73xx;
 	struct cvmx_pcieepx_cfg022_s          cn78xx;
 	struct cvmx_pcieepx_cfg022_s          cnf71xx;
 };
@@ -5510,6 +5739,7 @@ union cvmx_pcieepx_cfg023 {
 	struct cvmx_pcieepx_cfg023_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg023_s          cn70xx;
 	struct cvmx_pcieepx_cfg023_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg023_s          cn73xx;
 	struct cvmx_pcieepx_cfg023_s          cn78xx;
 	struct cvmx_pcieepx_cfg023_s          cnf71xx;
 };
@@ -5533,6 +5763,7 @@ union cvmx_pcieepx_cfg024 {
 	} s;
 	struct cvmx_pcieepx_cfg024_s          cn70xx;
 	struct cvmx_pcieepx_cfg024_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg024_s          cn73xx;
 	struct cvmx_pcieepx_cfg024_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg024 cvmx_pcieepx_cfg024_t;
@@ -5554,6 +5785,7 @@ union cvmx_pcieepx_cfg025 {
 	} s;
 	struct cvmx_pcieepx_cfg025_s          cn70xx;
 	struct cvmx_pcieepx_cfg025_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg025_s          cn73xx;
 	struct cvmx_pcieepx_cfg025_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg025 cvmx_pcieepx_cfg025_t;
@@ -5605,6 +5837,7 @@ union cvmx_pcieepx_cfg028 {
 	struct cvmx_pcieepx_cfg028_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg028_s          cn70xx;
 	struct cvmx_pcieepx_cfg028_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg028_s          cn73xx;
 	struct cvmx_pcieepx_cfg028_s          cn78xx;
 	struct cvmx_pcieepx_cfg028_s          cnf71xx;
 };
@@ -5754,6 +5987,7 @@ union cvmx_pcieepx_cfg029 {
 	struct cvmx_pcieepx_cfg029_cn66xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg029_cn61xx     cn73xx;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn78xx;
 	struct cvmx_pcieepx_cfg029_cn61xx     cnf71xx;
 };
@@ -5961,6 +6195,7 @@ union cvmx_pcieepx_cfg030 {
 	struct cvmx_pcieepx_cfg030_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg030_s          cn70xx;
 	struct cvmx_pcieepx_cfg030_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg030_s          cn73xx;
 	struct cvmx_pcieepx_cfg030_s          cn78xx;
 	struct cvmx_pcieepx_cfg030_s          cnf71xx;
 };
@@ -6090,6 +6325,7 @@ union cvmx_pcieepx_cfg031 {
 	struct cvmx_pcieepx_cfg031_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg031_s          cn70xx;
 	struct cvmx_pcieepx_cfg031_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg031_s          cn73xx;
 	struct cvmx_pcieepx_cfg031_s          cn78xx;
 	struct cvmx_pcieepx_cfg031_s          cnf71xx;
 };
@@ -6300,6 +6536,7 @@ union cvmx_pcieepx_cfg032 {
 	} cn68xxp1;
 	struct cvmx_pcieepx_cfg032_s          cn70xx;
 	struct cvmx_pcieepx_cfg032_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg032_s          cn73xx;
 	struct cvmx_pcieepx_cfg032_s          cn78xx;
 	struct cvmx_pcieepx_cfg032_s          cnf71xx;
 };
@@ -6546,7 +6783,7 @@ union cvmx_pcieepx_cfg037 {
 	struct cvmx_pcieepx_cfg037_cn61xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg037_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg037_cn61xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg037_cn78xx {
+	struct cvmx_pcieepx_cfg037_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
 	uint32_t meetp                        : 2;  /**< Max end-end TLP prefixes.
@@ -6565,7 +6802,7 @@ union cvmx_pcieepx_cfg037 {
 	uint32_t atom64s                      : 1;  /**< 64-bit AtomicOp supported. */
 	uint32_t atom32s                      : 1;  /**< 32-bit AtomicOp supported. */
 	uint32_t atom_ops                     : 1;  /**< AtomicOp routing supported (not applicable for EP). */
-	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not supported). */
+	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not applicable for EP). */
 	uint32_t ctds                         : 1;  /**< Completion timeout disable supported. */
 	uint32_t ctrs                         : 4;  /**< Completion timeout ranges supported. */
 #else
@@ -6586,7 +6823,8 @@ union cvmx_pcieepx_cfg037 {
 	uint32_t meetp                        : 2;
 	uint32_t reserved_24_31               : 8;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg037_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg037_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_20_31               : 12;
@@ -6727,6 +6965,7 @@ union cvmx_pcieepx_cfg038 {
 	struct cvmx_pcieepx_cfg038_cn61xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg038_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg038_cn61xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg038_s          cn73xx;
 	struct cvmx_pcieepx_cfg038_s          cn78xx;
 	struct cvmx_pcieepx_cfg038_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
@@ -6820,6 +7059,7 @@ union cvmx_pcieepx_cfg039 {
 	struct cvmx_pcieepx_cfg039_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg039_s          cn70xx;
 	struct cvmx_pcieepx_cfg039_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg039_s          cn73xx;
 	struct cvmx_pcieepx_cfg039_s          cn78xx;
 	struct cvmx_pcieepx_cfg039_s          cnf71xx;
 };
@@ -7040,6 +7280,7 @@ union cvmx_pcieepx_cfg040 {
 	struct cvmx_pcieepx_cfg040_cn61xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg040_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg040_cn61xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg040_s          cn73xx;
 	struct cvmx_pcieepx_cfg040_s          cn78xx;
 	struct cvmx_pcieepx_cfg040_cn61xx     cnf71xx;
 };
@@ -7122,6 +7363,7 @@ union cvmx_pcieepx_cfg044 {
 	uint32_t msixen                       : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg044_s          cn73xx;
 	struct cvmx_pcieepx_cfg044_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg044 cvmx_pcieepx_cfg044_t;
@@ -7148,6 +7390,7 @@ union cvmx_pcieepx_cfg045 {
 	uint32_t msixtoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg045_s          cn73xx;
 	struct cvmx_pcieepx_cfg045_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg045 cvmx_pcieepx_cfg045_t;
@@ -7174,6 +7417,7 @@ union cvmx_pcieepx_cfg046 {
 	uint32_t msixpoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg046_s          cn73xx;
 	struct cvmx_pcieepx_cfg046_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg046 cvmx_pcieepx_cfg046_t;
@@ -7209,6 +7453,7 @@ union cvmx_pcieepx_cfg064 {
 	struct cvmx_pcieepx_cfg064_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg064_s          cn70xx;
 	struct cvmx_pcieepx_cfg064_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg064_s          cn73xx;
 	struct cvmx_pcieepx_cfg064_s          cn78xx;
 	struct cvmx_pcieepx_cfg064_s          cnf71xx;
 };
@@ -7385,7 +7630,7 @@ union cvmx_pcieepx_cfg065 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg065_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg065_cn78xx {
+	struct cvmx_pcieepx_cfg065_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbes                        : 1;  /**< Unsupported TLP prefix blocked error status. */
@@ -7425,7 +7670,8 @@ union cvmx_pcieepx_cfg065 {
 	uint32_t tpbes                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg065_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg065_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -7639,7 +7885,7 @@ union cvmx_pcieepx_cfg066 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg066_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg066_cn78xx {
+	struct cvmx_pcieepx_cfg066_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbem                        : 1;  /**< Unsupported TLP prefix blocked error mask. */
@@ -7679,7 +7925,8 @@ union cvmx_pcieepx_cfg066 {
 	uint32_t tpbem                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg066_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg066_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -7893,7 +8140,7 @@ union cvmx_pcieepx_cfg067 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg067_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg067_cn78xx {
+	struct cvmx_pcieepx_cfg067_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbes                        : 1;  /**< Unsupported TLP prefix blocked error severity. */
@@ -7910,13 +8157,13 @@ union cvmx_pcieepx_cfg067 {
 	uint32_t cts                          : 1;  /**< Completion timeout severity. */
 	uint32_t fcpes                        : 1;  /**< Flow control protocol error severity. */
 	uint32_t ptlps                        : 1;  /**< Poisoned TLP severity. */
-	uint32_t reserved_5_11                : 7;
+	uint32_t reserved_11_5                : 7;
 	uint32_t dlpes                        : 1;  /**< Data link protocol error severity. */
 	uint32_t reserved_0_3                 : 4;
 #else
 	uint32_t reserved_0_3                 : 4;
 	uint32_t dlpes                        : 1;
-	uint32_t reserved_5_11                : 7;
+	uint32_t reserved_11_5                : 7;
 	uint32_t ptlps                        : 1;
 	uint32_t fcpes                        : 1;
 	uint32_t cts                          : 1;
@@ -7933,7 +8180,8 @@ union cvmx_pcieepx_cfg067 {
 	uint32_t tpbes                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg067_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg067_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -8043,6 +8291,7 @@ union cvmx_pcieepx_cfg068 {
 	struct cvmx_pcieepx_cfg068_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg068_s          cn70xx;
 	struct cvmx_pcieepx_cfg068_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg068_s          cn73xx;
 	struct cvmx_pcieepx_cfg068_s          cn78xx;
 	struct cvmx_pcieepx_cfg068_s          cnf71xx;
 };
@@ -8115,6 +8364,7 @@ union cvmx_pcieepx_cfg069 {
 	struct cvmx_pcieepx_cfg069_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg069_s          cn70xx;
 	struct cvmx_pcieepx_cfg069_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg069_s          cn73xx;
 	struct cvmx_pcieepx_cfg069_s          cn78xx;
 	struct cvmx_pcieepx_cfg069_s          cnf71xx;
 };
@@ -8177,6 +8427,7 @@ union cvmx_pcieepx_cfg070 {
 	struct cvmx_pcieepx_cfg070_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg070_cn52xx     cn70xx;
 	struct cvmx_pcieepx_cfg070_cn52xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg070_s          cn73xx;
 	struct cvmx_pcieepx_cfg070_s          cn78xx;
 	struct cvmx_pcieepx_cfg070_cn52xx     cnf71xx;
 };
@@ -8209,6 +8460,7 @@ union cvmx_pcieepx_cfg071 {
 	struct cvmx_pcieepx_cfg071_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg071_s          cn70xx;
 	struct cvmx_pcieepx_cfg071_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg071_s          cn73xx;
 	struct cvmx_pcieepx_cfg071_s          cn78xx;
 	struct cvmx_pcieepx_cfg071_s          cnf71xx;
 };
@@ -8241,6 +8493,7 @@ union cvmx_pcieepx_cfg072 {
 	struct cvmx_pcieepx_cfg072_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg072_s          cn70xx;
 	struct cvmx_pcieepx_cfg072_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg072_s          cn73xx;
 	struct cvmx_pcieepx_cfg072_s          cn78xx;
 	struct cvmx_pcieepx_cfg072_s          cnf71xx;
 };
@@ -8273,6 +8526,7 @@ union cvmx_pcieepx_cfg073 {
 	struct cvmx_pcieepx_cfg073_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg073_s          cn70xx;
 	struct cvmx_pcieepx_cfg073_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg073_s          cn73xx;
 	struct cvmx_pcieepx_cfg073_s          cn78xx;
 	struct cvmx_pcieepx_cfg073_s          cnf71xx;
 };
@@ -8305,6 +8559,7 @@ union cvmx_pcieepx_cfg074 {
 	struct cvmx_pcieepx_cfg074_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg074_s          cn70xx;
 	struct cvmx_pcieepx_cfg074_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg074_s          cn73xx;
 	struct cvmx_pcieepx_cfg074_s          cn78xx;
 	struct cvmx_pcieepx_cfg074_s          cnf71xx;
 };
@@ -8325,6 +8580,7 @@ union cvmx_pcieepx_cfg078 {
 	uint32_t tlp_pfx_log                  : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg078_s          cn73xx;
 	struct cvmx_pcieepx_cfg078_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg078 cvmx_pcieepx_cfg078_t;
@@ -8360,7 +8616,7 @@ union cvmx_pcieepx_cfg082 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg082_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg082_cn78xx {
+	struct cvmx_pcieepx_cfg082_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t nco                          : 12; /**< Next capability offset. Points to the secondary PCI Express capabilities by default. */
 	uint32_t cv                           : 4;  /**< Capability version. */
@@ -8370,7 +8626,8 @@ union cvmx_pcieepx_cfg082 {
 	uint32_t cv                           : 4;
 	uint32_t nco                          : 12;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg082_cn73xx     cn78xx;
 };
 typedef union cvmx_pcieepx_cfg082 cvmx_pcieepx_cfg082_t;
 
@@ -8410,7 +8667,7 @@ union cvmx_pcieepx_cfg083 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg083_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg083_cn78xx {
+	struct cvmx_pcieepx_cfg083_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_23_31               : 9;
 	uint32_t fg                           : 3;  /**< Function group. */
@@ -8432,7 +8689,8 @@ union cvmx_pcieepx_cfg083 {
 	uint32_t fg                           : 3;
 	uint32_t reserved_23_31               : 9;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg083_cn73xx     cn78xx;
 };
 typedef union cvmx_pcieepx_cfg083 cvmx_pcieepx_cfg083_t;
 
@@ -8485,6 +8743,7 @@ union cvmx_pcieepx_cfg086 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg086_s          cn73xx;
 	struct cvmx_pcieepx_cfg086_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg086 cvmx_pcieepx_cfg086_t;
@@ -8508,6 +8767,7 @@ union cvmx_pcieepx_cfg087 {
 	uint32_t reserved_2_31                : 30;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg087_s          cn73xx;
 	struct cvmx_pcieepx_cfg087_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg087 cvmx_pcieepx_cfg087_t;
@@ -8529,6 +8789,7 @@ union cvmx_pcieepx_cfg088 {
 	uint32_t reserved_8_31                : 24;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg088_s          cn73xx;
 	struct cvmx_pcieepx_cfg088_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg088 cvmx_pcieepx_cfg088_t;
@@ -8564,6 +8825,7 @@ union cvmx_pcieepx_cfg089 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg089_s          cn73xx;
 	struct cvmx_pcieepx_cfg089_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg089 cvmx_pcieepx_cfg089_t;
@@ -8599,6 +8861,7 @@ union cvmx_pcieepx_cfg090 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg090_s          cn73xx;
 	struct cvmx_pcieepx_cfg090_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg090 cvmx_pcieepx_cfg090_t;
@@ -8634,6 +8897,7 @@ union cvmx_pcieepx_cfg091 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg091_s          cn73xx;
 	struct cvmx_pcieepx_cfg091_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg091 cvmx_pcieepx_cfg091_t;
@@ -8669,6 +8933,7 @@ union cvmx_pcieepx_cfg092 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg092_s          cn73xx;
 	struct cvmx_pcieepx_cfg092_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg092 cvmx_pcieepx_cfg092_t;
@@ -8692,6 +8957,7 @@ union cvmx_pcieepx_cfg094 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg094_s          cn73xx;
 	struct cvmx_pcieepx_cfg094_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg094 cvmx_pcieepx_cfg094_t;
@@ -8718,6 +8984,7 @@ union cvmx_pcieepx_cfg095 {
 	uint32_t vfmimn                       : 11;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg095_s          cn73xx;
 	struct cvmx_pcieepx_cfg095_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg095 cvmx_pcieepx_cfg095_t;
@@ -8754,6 +9021,7 @@ union cvmx_pcieepx_cfg096 {
 	uint32_t reserved_17_31               : 15;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg096_s          cn73xx;
 	struct cvmx_pcieepx_cfg096_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg096 cvmx_pcieepx_cfg096_t;
@@ -8775,6 +9043,7 @@ union cvmx_pcieepx_cfg097 {
 	uint32_t tvf                          : 16;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg097_s          cn73xx;
 	struct cvmx_pcieepx_cfg097_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg097 cvmx_pcieepx_cfg097_t;
@@ -8798,6 +9067,7 @@ union cvmx_pcieepx_cfg098 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg098_s          cn73xx;
 	struct cvmx_pcieepx_cfg098_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg098 cvmx_pcieepx_cfg098_t;
@@ -8819,6 +9089,7 @@ union cvmx_pcieepx_cfg099 {
 	uint32_t vfs                          : 16;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg099_s          cn73xx;
 	struct cvmx_pcieepx_cfg099_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg099 cvmx_pcieepx_cfg099_t;
@@ -8840,6 +9111,7 @@ union cvmx_pcieepx_cfg100 {
 	uint32_t vfdev                        : 16;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg100_s          cn73xx;
 	struct cvmx_pcieepx_cfg100_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg100 cvmx_pcieepx_cfg100_t;
@@ -8859,6 +9131,7 @@ union cvmx_pcieepx_cfg101 {
 	uint32_t supps                        : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg101_s          cn73xx;
 	struct cvmx_pcieepx_cfg101_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg101 cvmx_pcieepx_cfg101_t;
@@ -8878,6 +9151,7 @@ union cvmx_pcieepx_cfg102 {
 	uint32_t ps                           : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg102_s          cn73xx;
 	struct cvmx_pcieepx_cfg102_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg102 cvmx_pcieepx_cfg102_t;
@@ -8892,6 +9166,42 @@ union cvmx_pcieepx_cfg103 {
 	uint32_t u32;
 	struct cvmx_pcieepx_cfg103_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_4_31                : 28;
+	uint32_t pf                           : 1;  /**< Prefetchable. */
+	uint32_t typ                          : 2;  /**< BAR type:
+                                                         0x0 = 32-bit BAR.
+                                                         0x2 = 64-bit BAR. */
+	uint32_t mspc                         : 1;  /**< Memory space indicator:
+                                                         0 = BAR 0 is a memory BAR.
+                                                         1 = BAR 0 is an I/O BAR. */
+#else
+	uint32_t mspc                         : 1;
+	uint32_t typ                          : 2;
+	uint32_t pf                           : 1;
+	uint32_t reserved_4_31                : 28;
+#endif
+	} s;
+	struct cvmx_pcieepx_cfg103_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t lbab                         : 12; /**< Lower bits of the VF BAR 0 base address. */
+	uint32_t reserved_4_19                : 16;
+	uint32_t pf                           : 1;  /**< Prefetchable. */
+	uint32_t typ                          : 2;  /**< BAR type:
+                                                         0x0 = 32-bit BAR.
+                                                         0x2 = 64-bit BAR. */
+	uint32_t mspc                         : 1;  /**< Memory space indicator:
+                                                         0 = BAR 0 is a memory BAR.
+                                                         1 = BAR 0 is an I/O BAR. */
+#else
+	uint32_t mspc                         : 1;
+	uint32_t typ                          : 2;
+	uint32_t pf                           : 1;
+	uint32_t reserved_4_19                : 16;
+	uint32_t lbab                         : 12;
+#endif
+	} cn73xx;
+	struct cvmx_pcieepx_cfg103_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t lbab                         : 17; /**< Lower bits of the VF BAR 0 base address. */
 	uint32_t reserved_4_14                : 11;
 	uint32_t pf                           : 1;  /**< Prefetchable. */
@@ -8908,8 +9218,7 @@ union cvmx_pcieepx_cfg103 {
 	uint32_t reserved_4_14                : 11;
 	uint32_t lbab                         : 17;
 #endif
-	} s;
-	struct cvmx_pcieepx_cfg103_s          cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pcieepx_cfg103 cvmx_pcieepx_cfg103_t;
 
@@ -8928,6 +9237,7 @@ union cvmx_pcieepx_cfg104 {
 	uint32_t ubab                         : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg104_s          cn73xx;
 	struct cvmx_pcieepx_cfg104_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg104 cvmx_pcieepx_cfg104_t;
@@ -8947,6 +9257,7 @@ union cvmx_pcieepx_cfg105 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg105_s          cn73xx;
 	struct cvmx_pcieepx_cfg105_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg105 cvmx_pcieepx_cfg105_t;
@@ -8966,6 +9277,7 @@ union cvmx_pcieepx_cfg106 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg106_s          cn73xx;
 	struct cvmx_pcieepx_cfg106_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg106 cvmx_pcieepx_cfg106_t;
@@ -8985,6 +9297,7 @@ union cvmx_pcieepx_cfg107 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg107_s          cn73xx;
 	struct cvmx_pcieepx_cfg107_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg107 cvmx_pcieepx_cfg107_t;
@@ -9004,6 +9317,7 @@ union cvmx_pcieepx_cfg108 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg108_s          cn73xx;
 	struct cvmx_pcieepx_cfg108_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg108 cvmx_pcieepx_cfg108_t;
@@ -9025,6 +9339,7 @@ union cvmx_pcieepx_cfg109 {
 	uint32_t mso                          : 29;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg109_s          cn73xx;
 	struct cvmx_pcieepx_cfg109_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg109 cvmx_pcieepx_cfg109_t;
@@ -9048,6 +9363,7 @@ union cvmx_pcieepx_cfg110 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg110_s          cn73xx;
 	struct cvmx_pcieepx_cfg110_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg110 cvmx_pcieepx_cfg110_t;
@@ -9074,6 +9390,7 @@ union cvmx_pcieepx_cfg111 {
 	uint32_t reserved_30_31               : 2;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg111_s          cn73xx;
 	struct cvmx_pcieepx_cfg111_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg111 cvmx_pcieepx_cfg111_t;
@@ -9102,6 +9419,7 @@ union cvmx_pcieepx_cfg112 {
 	uint32_t reserved_13_31               : 19;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg112_s          cn73xx;
 	struct cvmx_pcieepx_cfg112_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg112 cvmx_pcieepx_cfg112_t;
@@ -9149,6 +9467,7 @@ union cvmx_pcieepx_cfg448 {
 	struct cvmx_pcieepx_cfg448_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg448_s          cn70xx;
 	struct cvmx_pcieepx_cfg448_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg448_s          cn73xx;
 	struct cvmx_pcieepx_cfg448_s          cn78xx;
 	struct cvmx_pcieepx_cfg448_s          cnf71xx;
 };
@@ -9192,6 +9511,7 @@ union cvmx_pcieepx_cfg449 {
 	struct cvmx_pcieepx_cfg449_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg449_s          cn70xx;
 	struct cvmx_pcieepx_cfg449_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg449_s          cn73xx;
 	struct cvmx_pcieepx_cfg449_s          cn78xx;
 	struct cvmx_pcieepx_cfg449_s          cnf71xx;
 };
@@ -9364,6 +9684,7 @@ union cvmx_pcieepx_cfg450 {
 	struct cvmx_pcieepx_cfg450_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg450_s          cn70xx;
 	struct cvmx_pcieepx_cfg450_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg450_cn52xx     cn73xx;
 	struct cvmx_pcieepx_cfg450_cn52xx     cn78xx;
 	struct cvmx_pcieepx_cfg450_cn52xx     cnf71xx;
 };
@@ -9488,6 +9809,7 @@ union cvmx_pcieepx_cfg451 {
 	struct cvmx_pcieepx_cfg451_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg451_s          cn70xx;
 	struct cvmx_pcieepx_cfg451_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg451_s          cn73xx;
 	struct cvmx_pcieepx_cfg451_s          cn78xx;
 	struct cvmx_pcieepx_cfg451_s          cnf71xx;
 };
@@ -9769,6 +10091,7 @@ union cvmx_pcieepx_cfg452 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg452_cn70xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg452_cn70xx     cn73xx;
 	struct cvmx_pcieepx_cfg452_cn70xx     cn78xx;
 	struct cvmx_pcieepx_cfg452_cn61xx     cnf71xx;
 };
@@ -9817,6 +10140,7 @@ union cvmx_pcieepx_cfg453 {
 	struct cvmx_pcieepx_cfg453_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg453_s          cn70xx;
 	struct cvmx_pcieepx_cfg453_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg453_s          cn73xx;
 	struct cvmx_pcieepx_cfg453_s          cn78xx;
 	struct cvmx_pcieepx_cfg453_s          cnf71xx;
 };
@@ -9939,7 +10263,7 @@ union cvmx_pcieepx_cfg454 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg454_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg454_cn78xx {
+	struct cvmx_pcieepx_cfg454_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_29_31               : 3;
 	uint32_t tmfcwt                       : 5;  /**< Used to be 'timer modifier for flow control watchdog timer.' This field is no longer used.
@@ -9959,7 +10283,8 @@ union cvmx_pcieepx_cfg454 {
 	uint32_t tmfcwt                       : 5;
 	uint32_t reserved_29_31               : 3;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg454_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg454_cn61xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg454 cvmx_pcieepx_cfg454_t;
@@ -10028,6 +10353,7 @@ union cvmx_pcieepx_cfg455 {
 	struct cvmx_pcieepx_cfg455_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg455_s          cn70xx;
 	struct cvmx_pcieepx_cfg455_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg455_s          cn73xx;
 	struct cvmx_pcieepx_cfg455_s          cn78xx;
 	struct cvmx_pcieepx_cfg455_s          cnf71xx;
 };
@@ -10078,6 +10404,7 @@ union cvmx_pcieepx_cfg456 {
 	struct cvmx_pcieepx_cfg456_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg456_s          cn70xx;
 	struct cvmx_pcieepx_cfg456_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg456_s          cn73xx;
 	struct cvmx_pcieepx_cfg456_s          cn78xx;
 	struct cvmx_pcieepx_cfg456_s          cnf71xx;
 };
@@ -10110,6 +10437,7 @@ union cvmx_pcieepx_cfg458 {
 	struct cvmx_pcieepx_cfg458_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg458_s          cn70xx;
 	struct cvmx_pcieepx_cfg458_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg458_s          cn73xx;
 	struct cvmx_pcieepx_cfg458_s          cn78xx;
 	struct cvmx_pcieepx_cfg458_s          cnf71xx;
 };
@@ -10142,6 +10470,7 @@ union cvmx_pcieepx_cfg459 {
 	struct cvmx_pcieepx_cfg459_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg459_s          cn70xx;
 	struct cvmx_pcieepx_cfg459_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg459_s          cn73xx;
 	struct cvmx_pcieepx_cfg459_s          cn78xx;
 	struct cvmx_pcieepx_cfg459_s          cnf71xx;
 };
@@ -10182,6 +10511,7 @@ union cvmx_pcieepx_cfg460 {
 	struct cvmx_pcieepx_cfg460_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg460_s          cn70xx;
 	struct cvmx_pcieepx_cfg460_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg460_s          cn73xx;
 	struct cvmx_pcieepx_cfg460_s          cn78xx;
 	struct cvmx_pcieepx_cfg460_s          cnf71xx;
 };
@@ -10222,6 +10552,7 @@ union cvmx_pcieepx_cfg461 {
 	struct cvmx_pcieepx_cfg461_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg461_s          cn70xx;
 	struct cvmx_pcieepx_cfg461_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg461_s          cn73xx;
 	struct cvmx_pcieepx_cfg461_s          cn78xx;
 	struct cvmx_pcieepx_cfg461_s          cnf71xx;
 };
@@ -10262,6 +10593,7 @@ union cvmx_pcieepx_cfg462 {
 	struct cvmx_pcieepx_cfg462_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg462_s          cn70xx;
 	struct cvmx_pcieepx_cfg462_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg462_s          cn73xx;
 	struct cvmx_pcieepx_cfg462_s          cn78xx;
 	struct cvmx_pcieepx_cfg462_s          cnf71xx;
 };
@@ -10334,6 +10666,7 @@ union cvmx_pcieepx_cfg463 {
 	struct cvmx_pcieepx_cfg463_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg463_cn52xx     cn70xx;
 	struct cvmx_pcieepx_cfg463_cn52xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg463_s          cn73xx;
 	struct cvmx_pcieepx_cfg463_s          cn78xx;
 	struct cvmx_pcieepx_cfg463_cn52xx     cnf71xx;
 };
@@ -10372,6 +10705,7 @@ union cvmx_pcieepx_cfg464 {
 	struct cvmx_pcieepx_cfg464_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg464_s          cn70xx;
 	struct cvmx_pcieepx_cfg464_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg464_s          cn73xx;
 	struct cvmx_pcieepx_cfg464_s          cn78xx;
 	struct cvmx_pcieepx_cfg464_s          cnf71xx;
 };
@@ -10410,6 +10744,7 @@ union cvmx_pcieepx_cfg465 {
 	struct cvmx_pcieepx_cfg465_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg465_s          cn70xx;
 	struct cvmx_pcieepx_cfg465_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg465_s          cn73xx;
 	struct cvmx_pcieepx_cfg465_s          cn78xx;
 	struct cvmx_pcieepx_cfg465_s          cnf71xx;
 };
@@ -10484,6 +10819,7 @@ union cvmx_pcieepx_cfg466 {
 	struct cvmx_pcieepx_cfg466_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg466_s          cn70xx;
 	struct cvmx_pcieepx_cfg466_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg466_s          cn73xx;
 	struct cvmx_pcieepx_cfg466_s          cn78xx;
 	struct cvmx_pcieepx_cfg466_s          cnf71xx;
 };
@@ -10540,6 +10876,7 @@ union cvmx_pcieepx_cfg467 {
 	struct cvmx_pcieepx_cfg467_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg467_s          cn70xx;
 	struct cvmx_pcieepx_cfg467_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg467_s          cn73xx;
 	struct cvmx_pcieepx_cfg467_s          cn78xx;
 	struct cvmx_pcieepx_cfg467_s          cnf71xx;
 };
@@ -10596,6 +10933,7 @@ union cvmx_pcieepx_cfg468 {
 	struct cvmx_pcieepx_cfg468_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg468_s          cn70xx;
 	struct cvmx_pcieepx_cfg468_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg468_s          cn73xx;
 	struct cvmx_pcieepx_cfg468_s          cn78xx;
 	struct cvmx_pcieepx_cfg468_s          cnf71xx;
 };
@@ -10791,6 +11129,7 @@ union cvmx_pcieepx_cfg515 {
 	struct cvmx_pcieepx_cfg515_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg515_s          cn70xx;
 	struct cvmx_pcieepx_cfg515_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg515_s          cn73xx;
 	struct cvmx_pcieepx_cfg515_s          cn78xx;
 	struct cvmx_pcieepx_cfg515_s          cnf71xx;
 };
@@ -10823,6 +11162,7 @@ union cvmx_pcieepx_cfg516 {
 	struct cvmx_pcieepx_cfg516_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg516_s          cn70xx;
 	struct cvmx_pcieepx_cfg516_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg516_s          cn73xx;
 	struct cvmx_pcieepx_cfg516_s          cn78xx;
 	struct cvmx_pcieepx_cfg516_s          cnf71xx;
 };
@@ -10855,6 +11195,7 @@ union cvmx_pcieepx_cfg517 {
 	struct cvmx_pcieepx_cfg517_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg517_s          cn70xx;
 	struct cvmx_pcieepx_cfg517_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg517_s          cn73xx;
 	struct cvmx_pcieepx_cfg517_s          cn78xx;
 	struct cvmx_pcieepx_cfg517_s          cnf71xx;
 };
@@ -10898,6 +11239,7 @@ union cvmx_pcieepx_cfg548 {
 	uint32_t reserved_19_31               : 13;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg548_s          cn73xx;
 	struct cvmx_pcieepx_cfg548_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg548 cvmx_pcieepx_cfg548_t;
@@ -10963,6 +11305,7 @@ union cvmx_pcieepx_cfg554 {
 	uint32_t reserved_25_31               : 7;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg554_s          cn73xx;
 	struct cvmx_pcieepx_cfg554_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg554 cvmx_pcieepx_cfg554_t;
@@ -10984,6 +11327,7 @@ union cvmx_pcieepx_cfg558 {
 	uint32_t ple                          : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg558_s          cn73xx;
 	struct cvmx_pcieepx_cfg558_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg558 cvmx_pcieepx_cfg558_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index 1ef13c1..132f020 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -53,7 +53,7 @@
 #define __CVMX_PCIERCX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -63,23 +63,24 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000000ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000000ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG000 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG000 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000000ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -91,15 +92,16 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000000ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000000ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000000ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -109,23 +111,24 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000004ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000004ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000004ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG001 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG001 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000004ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -137,15 +140,16 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000004ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000004ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000004ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000004ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000004ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -155,23 +159,24 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000008ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000008ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000008ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG002 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG002 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000008ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -183,15 +188,16 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000008ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000008ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000008ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000008ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000008ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -201,23 +207,24 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000000Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000000Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000000Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG003 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG003 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000000Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -229,15 +236,16 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000000Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000000Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000000Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000000Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000000Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -247,23 +255,24 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000010ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000010ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000010ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG004 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG004 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000010ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -275,15 +284,16 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000010ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000010ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000010ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000010ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000010ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -293,23 +303,24 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000014ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000014ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000014ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG005 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG005 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000014ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -321,15 +332,16 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000014ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000014ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000014ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000014ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000014ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -339,23 +351,24 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000018ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000018ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000018ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG006 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG006 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000018ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -367,15 +380,16 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000018ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000018ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000018ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000018ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000018ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -385,23 +399,24 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000001Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000001Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000001Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG007 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG007 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000001Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -413,15 +428,16 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000001Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000001Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000001Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000001Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000001Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -431,23 +447,24 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000020ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000020ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000020ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG008 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG008 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000020ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -459,15 +476,16 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000020ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000020ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000020ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000020ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000020ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -477,23 +495,24 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000024ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000024ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000024ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG009 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG009 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000024ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -505,15 +524,16 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000024ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000024ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000024ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000024ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000024ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -523,23 +543,24 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000028ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000028ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000028ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG010 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG010 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000028ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -551,15 +572,16 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000028ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000028ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000028ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000028ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000028ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -569,23 +591,24 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000002Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000002Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000002Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG011 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG011 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000002Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -597,15 +620,16 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000002Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000002Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000002Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000002Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000002Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -615,23 +639,24 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000030ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000030ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000030ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG012 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG012 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000030ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -643,15 +668,16 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000030ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000030ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000030ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000030ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000030ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -661,23 +687,24 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000034ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000034ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000034ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG013 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG013 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000034ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -689,15 +716,16 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000034ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000034ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000034ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000034ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000034ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -707,23 +735,24 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000038ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000038ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000038ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG014 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG014 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000038ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -735,15 +764,16 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000038ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000038ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000038ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000038ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000038ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000038ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -753,23 +783,24 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000003Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000003Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000003Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG015 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG015 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000003Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -781,15 +812,16 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000003Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000003Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000003Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000003Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000003Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -799,23 +831,24 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000040ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000040ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000040ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG016 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG016 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000040ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -827,15 +860,16 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000040ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000040ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000040ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000040ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000040ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -845,23 +879,24 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000044ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000044ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000044ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG017 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG017 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000044ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -873,15 +908,16 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000044ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000044ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000044ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000044ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000044ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -891,23 +927,24 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000050ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000050ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000050ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG020 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG020 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000050ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -919,15 +956,16 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000050ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000050ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000050ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000050ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000050ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -937,23 +975,24 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000054ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000054ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000054ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG021 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG021 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000054ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -965,15 +1004,16 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000054ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000054ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000054ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000054ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000054ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -983,23 +1023,24 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000058ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000058ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000058ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG022 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG022 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000058ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1011,15 +1052,16 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000058ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000058ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000058ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000058ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000058ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1029,23 +1071,24 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000005Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000005Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000005Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG023 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG023 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000005Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1057,15 +1100,16 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000005Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000005Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000005Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000005Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000005Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1075,23 +1119,24 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000070ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000070ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000070ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG028 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG028 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000070ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1103,15 +1148,16 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000070ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000070ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000070ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000070ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000070ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1121,23 +1167,24 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000074ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000074ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000074ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG029 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG029 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000074ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1149,15 +1196,16 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000074ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000074ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000074ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000074ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000074ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1167,23 +1215,24 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000078ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000078ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000078ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG030 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG030 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000078ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1195,15 +1244,16 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000078ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000078ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000078ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000078ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000078ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1213,23 +1263,24 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000007Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000007Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000007Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG031 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG031 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000007Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1241,15 +1292,16 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000007Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000007Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000007Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000007Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000007Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1259,23 +1311,24 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000080ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000080ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000080ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG032 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG032 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000080ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1287,15 +1340,16 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000080ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000080ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000080ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000080ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000080ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1305,23 +1359,24 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000084ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000084ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000084ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG033 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG033 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000084ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1333,15 +1388,16 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000084ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000084ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000084ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000084ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000084ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000084ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1351,23 +1407,24 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000088ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000088ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000088ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG034 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG034 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000088ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1379,15 +1436,16 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000088ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000088ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000088ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000088ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000088ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000088ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1397,23 +1455,24 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000008Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000008Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000008Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG035 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG035 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000008Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1425,15 +1484,16 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000008Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000008Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000008Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000008Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000008Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000008Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1443,23 +1503,24 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000090ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000090ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000090ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG036 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG036 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000090ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1471,15 +1532,16 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000090ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000090ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000090ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000090ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000090ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000090ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1489,23 +1551,24 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000094ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000094ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000094ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG037 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG037 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000094ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1517,15 +1580,16 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000094ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000094ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000094ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000094ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000094ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1535,23 +1599,24 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000098ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000098ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000098ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG038 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG038 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000098ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1563,15 +1628,16 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000098ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000098ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000098ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000098ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000098ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1581,23 +1647,24 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000009Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000009Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000009Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG039 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG039 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000009Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1609,15 +1676,16 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000009Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000009Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000009Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000009Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000009Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1627,23 +1695,24 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000000A0ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000200000000A0ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x00000200000000A0ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG040 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG040 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000000A0ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1655,15 +1724,16 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000000A0ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000000A0ull + (block_id) * 0x100000000ull;
+			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000000A0ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000000A0ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1673,23 +1743,24 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000000A4ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000200000000A4ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x00000200000000A4ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG041 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG041 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000000A4ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1701,15 +1772,16 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000000A4ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000000A4ull + (block_id) * 0x100000000ull;
+			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000000A4ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000000A4ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1719,23 +1791,24 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000000A8ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000200000000A8ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x00000200000000A8ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG042 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG042 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000000A8ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1747,48 +1820,52 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000000A8ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000000A8ull + (block_id) * 0x100000000ull;
+			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000000A8ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000000A8ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG044(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG044(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG044(%lu) is invalid on this chip\n", block_id);
-	return 0x00000200000000B0ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG044(%lu) is invalid on this chip\n", offset);
+	return 0x00000200000000B0ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG044(block_id) (0x00000200000000B0ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG044(offset) (0x00000200000000B0ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG045(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG045(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG045(%lu) is invalid on this chip\n", block_id);
-	return 0x00000200000000B4ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG045(%lu) is invalid on this chip\n", offset);
+	return 0x00000200000000B4ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG045(block_id) (0x00000200000000B4ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG045(offset) (0x00000200000000B4ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG046(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG046(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG046(%lu) is invalid on this chip\n", block_id);
-	return 0x00000200000000B8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG046(%lu) is invalid on this chip\n", offset);
+	return 0x00000200000000B8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG046(block_id) (0x00000200000000B8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG046(offset) (0x00000200000000B8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1798,23 +1875,24 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000100ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000100ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000100ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG064 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG064 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000100ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1826,15 +1904,16 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000100ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000100ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000100ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000100ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000100ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1844,23 +1923,24 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000104ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000104ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000104ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG065 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG065 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000104ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1872,15 +1952,16 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000104ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000104ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000104ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000104ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000104ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1890,23 +1971,24 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000108ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000108ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000108ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG066 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG066 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000108ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1918,15 +2000,16 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000108ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000108ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000108ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000108ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000108ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1936,23 +2019,24 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000010Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000010Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000010Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG067 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG067 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000010Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1964,15 +2048,16 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000010Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000010Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000010Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000010Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000010Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1982,23 +2067,24 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000110ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000110ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000110ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG068 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG068 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000110ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2010,15 +2096,16 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000110ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000110ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000110ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000110ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000110ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2028,23 +2115,24 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000114ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000114ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000114ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG069 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG069 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000114ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2056,15 +2144,16 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000114ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000114ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000114ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000114ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000114ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2074,23 +2163,24 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000118ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000118ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000118ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG070 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG070 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000118ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2102,15 +2192,16 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000118ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000118ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000118ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000118ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000118ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2120,23 +2211,24 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000011Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000011Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000011Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG071 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG071 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000011Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2148,15 +2240,16 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000011Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000011Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000011Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000011Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000011Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2166,23 +2259,24 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000120ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000120ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000120ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG072 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG072 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000120ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2194,15 +2288,16 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000120ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000120ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000120ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000120ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000120ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2212,23 +2307,24 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000124ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000124ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000124ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG073 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG073 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000124ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2240,15 +2336,16 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000124ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000124ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000124ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000124ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000124ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2258,23 +2355,24 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000128ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000128ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000128ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG074 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG074 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000128ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2286,15 +2384,16 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000128ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000128ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000128ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000128ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000128ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2304,23 +2403,24 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000012Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000012Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000012Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG075 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG075 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000012Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2332,15 +2432,16 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000012Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000012Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000012Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000012Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000012Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000012Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2350,23 +2451,24 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000130ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000130ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000130ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG076 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG076 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000130ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2378,15 +2480,16 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000130ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000130ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000130ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000130ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000130ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000130ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2396,23 +2499,24 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000134ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000134ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000134ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG077 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG077 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000134ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2424,92 +2528,100 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000134ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000134ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000134ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000134ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000134ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000134ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG086(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG086(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG086(%lu) is invalid on this chip\n", block_id);
-	return 0x0000020000000158ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG086(%lu) is invalid on this chip\n", offset);
+	return 0x0000020000000158ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG086(block_id) (0x0000020000000158ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG086(offset) (0x0000020000000158ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG087(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG087(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG087(%lu) is invalid on this chip\n", block_id);
-	return 0x000002000000015Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG087(%lu) is invalid on this chip\n", offset);
+	return 0x000002000000015Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG087(block_id) (0x000002000000015Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG087(offset) (0x000002000000015Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG088(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG088(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG088(%lu) is invalid on this chip\n", block_id);
-	return 0x0000020000000160ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG088(%lu) is invalid on this chip\n", offset);
+	return 0x0000020000000160ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG088(block_id) (0x0000020000000160ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG088(offset) (0x0000020000000160ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG089(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG089(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG089(%lu) is invalid on this chip\n", block_id);
-	return 0x0000020000000164ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG089(%lu) is invalid on this chip\n", offset);
+	return 0x0000020000000164ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG089(block_id) (0x0000020000000164ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG089(offset) (0x0000020000000164ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG090(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG090(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG090(%lu) is invalid on this chip\n", block_id);
-	return 0x0000020000000168ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG090(%lu) is invalid on this chip\n", offset);
+	return 0x0000020000000168ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG090(block_id) (0x0000020000000168ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG090(offset) (0x0000020000000168ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG091(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG091(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG091(%lu) is invalid on this chip\n", block_id);
-	return 0x000002000000016Cull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG091(%lu) is invalid on this chip\n", offset);
+	return 0x000002000000016Cull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG091(block_id) (0x000002000000016Cull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG091(offset) (0x000002000000016Cull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG092(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG092(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG092(%lu) is invalid on this chip\n", block_id);
-	return 0x0000020000000170ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG092(%lu) is invalid on this chip\n", offset);
+	return 0x0000020000000170ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG092(block_id) (0x0000020000000170ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG092(offset) (0x0000020000000170ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2519,23 +2631,24 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000700ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000700ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000700ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG448 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG448 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000700ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2547,15 +2660,16 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000700ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000700ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000700ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000700ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000700ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2565,23 +2679,24 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000704ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000704ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000704ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG449 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG449 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000704ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2593,15 +2708,16 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000704ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000704ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000704ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000704ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000704ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2611,23 +2727,24 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000708ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000708ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000708ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG450 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG450 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000708ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2639,15 +2756,16 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000708ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000708ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000708ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000708ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000708ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2657,23 +2775,24 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000070Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000070Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000070Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG451 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG451 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000070Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2685,15 +2804,16 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000070Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000070Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000070Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000070Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000070Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2703,23 +2823,24 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000710ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000710ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000710ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG452 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG452 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000710ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2731,15 +2852,16 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000710ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000710ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000710ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000710ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000710ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2749,23 +2871,24 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000714ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000714ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000714ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG453 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG453 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000714ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2777,15 +2900,16 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000714ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000714ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000714ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000714ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000714ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2795,23 +2919,24 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000718ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000718ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000718ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG454 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG454 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000718ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2823,15 +2948,16 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000718ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000718ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000718ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000718ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000718ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2841,23 +2967,24 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000071Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000071Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000071Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG455 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG455 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000071Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2869,15 +2996,16 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000071Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000071Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000071Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000071Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000071Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2887,23 +3015,24 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000720ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000720ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000720ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG456 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG456 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000720ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2915,15 +3044,16 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000720ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000720ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000720ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000720ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000720ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2933,23 +3063,24 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000728ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000728ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000728ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG458 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG458 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000728ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2961,15 +3092,16 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000728ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000728ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000728ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000728ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000728ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2979,23 +3111,24 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000072Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000072Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000072Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG459 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG459 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000072Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3007,15 +3140,16 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000072Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000072Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000072Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000072Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000072Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3025,23 +3159,24 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000730ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000730ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000730ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG460 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG460 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000730ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3053,15 +3188,16 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000730ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000730ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000730ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000730ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000730ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3071,23 +3207,24 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000734ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000734ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000734ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG461 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG461 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000734ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3099,15 +3236,16 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000734ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000734ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000734ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000734ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000734ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3117,23 +3255,24 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000738ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000738ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000738ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG462 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG462 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000738ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3145,15 +3284,16 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000738ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000738ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000738ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000738ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000738ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3163,23 +3303,24 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000073Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000073Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000073Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG463 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG463 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000073Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3191,15 +3332,16 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000073Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000073Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000073Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000073Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000073Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3209,23 +3351,24 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000740ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000740ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000740ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG464 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG464 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000740ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3237,15 +3380,16 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000740ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000740ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000740ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000740ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000740ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3255,23 +3399,24 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000744ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000744ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000744ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG465 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG465 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000744ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3283,15 +3428,16 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000744ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000744ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000744ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000744ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000744ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3301,23 +3447,24 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000748ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000748ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000748ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG466 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG466 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000748ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3329,15 +3476,16 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000748ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000748ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000748ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000748ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000748ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3347,23 +3495,24 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000074Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000074Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000074Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG467 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG467 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000074Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3375,15 +3524,16 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000074Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000074Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000074Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000074Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000074Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3393,23 +3543,24 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000750ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000750ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000750ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG468 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG468 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000750ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3421,15 +3572,16 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000750ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000750ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000750ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000750ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000750ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG490(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG490(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3439,19 +3591,19 @@ static inline uint64_t CVMX_PCIERCX_CFG490(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000007A8ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000200000007A8ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000200000007A8ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG490 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG490 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000007A8ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG490(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG490(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3463,13 +3615,13 @@ static inline uint64_t CVMX_PCIERCX_CFG490(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000007A8ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000007A8ull + (block_id) * 0x100000000ull;
+			return 0x00000200000007A8ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000007A8ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG491(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG491(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3479,19 +3631,19 @@ static inline uint64_t CVMX_PCIERCX_CFG491(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000007ACull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000200000007ACull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000200000007ACull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG491 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG491 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000007ACull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG491(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG491(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3503,13 +3655,13 @@ static inline uint64_t CVMX_PCIERCX_CFG491(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000007ACull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000007ACull + (block_id) * 0x100000000ull;
+			return 0x00000200000007ACull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000007ACull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG492(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG492(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3519,19 +3671,19 @@ static inline uint64_t CVMX_PCIERCX_CFG492(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x00000000000007B0ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x00000200000007B0ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x00000200000007B0ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG492 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG492 (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000007B0ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG492(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG492(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3543,13 +3695,13 @@ static inline uint64_t CVMX_PCIERCX_CFG492(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000007B0ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x00000200000007B0ull + (block_id) * 0x100000000ull;
+			return 0x00000200000007B0ull + (offset) * 0x100000000ull;
 	}
 	return 0x00000000000007B0ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3557,23 +3709,24 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x000000000000080Cull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x000002000000080Cull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x000002000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x000002000000080Cull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG515 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG515 (offset = %lu) not supported on this chip\n", offset);
 	return 0x000000000000080Cull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3583,15 +3736,16 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x000000000000080Cull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000080Cull + (block_id) * 0x100000000ull;
+			return 0x000002000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000002000000080Cull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000080Cull + (offset) * 0x100000000ull;
 	}
 	return 0x000000000000080Cull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3601,23 +3755,24 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000810ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000810ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000810ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG516 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG516 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000810ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3629,15 +3784,16 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000810ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000810ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000810ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000810ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000810ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3647,23 +3803,24 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long block_id)
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
+			if ((offset <= 1))
 				return 0x0000000000000814ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return 0x0000020000000814ull + ((block_id) & 3) * 0x100000000ull;
+			if ((offset <= 2))
+				return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return 0x0000020000000814ull + ((block_id) & 3) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCIERCX_CFG517 (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_PCIERCX_CFG517 (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000000814ull;
 }
 #else
-static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3675,45 +3832,49 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long block_id)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000814ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000814ull + (block_id) * 0x100000000ull;
+			return 0x0000020000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000020000000814ull + (block_id) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000814ull + (offset) * 0x100000000ull;
 	}
 	return 0x0000000000000814ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG548(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG548(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG548(%lu) is invalid on this chip\n", block_id);
-	return 0x0000020000000890ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG548(%lu) is invalid on this chip\n", offset);
+	return 0x0000020000000890ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG548(block_id) (0x0000020000000890ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG548(offset) (0x0000020000000890ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG554(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG554(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG554(%lu) is invalid on this chip\n", block_id);
-	return 0x00000200000008A8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG554(%lu) is invalid on this chip\n", offset);
+	return 0x00000200000008A8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG554(block_id) (0x00000200000008A8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG554(offset) (0x00000200000008A8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIERCX_CFG558(unsigned long block_id)
+static inline uint64_t CVMX_PCIERCX_CFG558(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PCIERCX_CFG558(%lu) is invalid on this chip\n", block_id);
-	return 0x00000200000008B8ull + ((block_id) & 3) * 0x100000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PCIERCX_CFG558(%lu) is invalid on this chip\n", offset);
+	return 0x00000200000008B8ull + ((offset) & 3) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIERCX_CFG558(block_id) (0x00000200000008B8ull + ((block_id) & 3) * 0x100000000ull)
+#define CVMX_PCIERCX_CFG558(offset) (0x00000200000008B8ull + ((offset) & 3) * 0x100000000ull)
 #endif
 
 /**
@@ -3747,6 +3908,7 @@ union cvmx_pciercx_cfg000 {
 	struct cvmx_pciercx_cfg000_s          cn68xxp1;
 	struct cvmx_pciercx_cfg000_s          cn70xx;
 	struct cvmx_pciercx_cfg000_s          cn70xxp1;
+	struct cvmx_pciercx_cfg000_s          cn73xx;
 	struct cvmx_pciercx_cfg000_s          cn78xx;
 	struct cvmx_pciercx_cfg000_s          cnf71xx;
 };
@@ -3835,6 +3997,7 @@ union cvmx_pciercx_cfg001 {
 	struct cvmx_pciercx_cfg001_s          cn68xxp1;
 	struct cvmx_pciercx_cfg001_s          cn70xx;
 	struct cvmx_pciercx_cfg001_s          cn70xxp1;
+	struct cvmx_pciercx_cfg001_s          cn73xx;
 	struct cvmx_pciercx_cfg001_s          cn78xx;
 	struct cvmx_pciercx_cfg001_s          cnf71xx;
 };
@@ -3877,6 +4040,7 @@ union cvmx_pciercx_cfg002 {
 	struct cvmx_pciercx_cfg002_s          cn68xxp1;
 	struct cvmx_pciercx_cfg002_s          cn70xx;
 	struct cvmx_pciercx_cfg002_s          cn70xxp1;
+	struct cvmx_pciercx_cfg002_s          cn73xx;
 	struct cvmx_pciercx_cfg002_s          cn78xx;
 	struct cvmx_pciercx_cfg002_s          cnf71xx;
 };
@@ -3926,6 +4090,7 @@ union cvmx_pciercx_cfg003 {
 	struct cvmx_pciercx_cfg003_s          cn68xxp1;
 	struct cvmx_pciercx_cfg003_s          cn70xx;
 	struct cvmx_pciercx_cfg003_s          cn70xxp1;
+	struct cvmx_pciercx_cfg003_s          cn73xx;
 	struct cvmx_pciercx_cfg003_s          cn78xx;
 	struct cvmx_pciercx_cfg003_s          cnf71xx;
 };
@@ -3956,9 +4121,16 @@ union cvmx_pciercx_cfg004 {
 	struct cvmx_pciercx_cfg004_s          cn66xx;
 	struct cvmx_pciercx_cfg004_s          cn68xx;
 	struct cvmx_pciercx_cfg004_s          cn68xxp1;
-	struct cvmx_pciercx_cfg004_s          cn70xx;
-	struct cvmx_pciercx_cfg004_s          cn70xxp1;
-	struct cvmx_pciercx_cfg004_s          cn78xx;
+	struct cvmx_pciercx_cfg004_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_31_0                : 32;
+#else
+	uint32_t reserved_31_0                : 32;
+#endif
+	} cn70xx;
+	struct cvmx_pciercx_cfg004_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg004_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg004_cn70xx     cn78xx;
 	struct cvmx_pciercx_cfg004_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg004 cvmx_pciercx_cfg004_t;
@@ -3988,9 +4160,16 @@ union cvmx_pciercx_cfg005 {
 	struct cvmx_pciercx_cfg005_s          cn66xx;
 	struct cvmx_pciercx_cfg005_s          cn68xx;
 	struct cvmx_pciercx_cfg005_s          cn68xxp1;
-	struct cvmx_pciercx_cfg005_s          cn70xx;
-	struct cvmx_pciercx_cfg005_s          cn70xxp1;
-	struct cvmx_pciercx_cfg005_s          cn78xx;
+	struct cvmx_pciercx_cfg005_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_31_0                : 32;
+#else
+	uint32_t reserved_31_0                : 32;
+#endif
+	} cn70xx;
+	struct cvmx_pciercx_cfg005_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg005_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg005_cn70xx     cn78xx;
 	struct cvmx_pciercx_cfg005_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg005 cvmx_pciercx_cfg005_t;
@@ -4029,6 +4208,7 @@ union cvmx_pciercx_cfg006 {
 	struct cvmx_pciercx_cfg006_s          cn68xxp1;
 	struct cvmx_pciercx_cfg006_s          cn70xx;
 	struct cvmx_pciercx_cfg006_s          cn70xxp1;
+	struct cvmx_pciercx_cfg006_s          cn73xx;
 	struct cvmx_pciercx_cfg006_s          cn78xx;
 	struct cvmx_pciercx_cfg006_s          cnf71xx;
 };
@@ -4103,6 +4283,7 @@ union cvmx_pciercx_cfg007 {
 	struct cvmx_pciercx_cfg007_s          cn68xxp1;
 	struct cvmx_pciercx_cfg007_s          cn70xx;
 	struct cvmx_pciercx_cfg007_s          cn70xxp1;
+	struct cvmx_pciercx_cfg007_s          cn73xx;
 	struct cvmx_pciercx_cfg007_s          cn78xx;
 	struct cvmx_pciercx_cfg007_s          cnf71xx;
 };
@@ -4139,9 +4320,22 @@ union cvmx_pciercx_cfg008 {
 	struct cvmx_pciercx_cfg008_s          cn66xx;
 	struct cvmx_pciercx_cfg008_s          cn68xx;
 	struct cvmx_pciercx_cfg008_s          cn68xxp1;
-	struct cvmx_pciercx_cfg008_s          cn70xx;
-	struct cvmx_pciercx_cfg008_s          cn70xxp1;
-	struct cvmx_pciercx_cfg008_s          cn78xx;
+	struct cvmx_pciercx_cfg008_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t ml_addr                      : 12; /**< Memory Limit Address */
+	uint32_t reserved_19_16               : 4;
+	uint32_t mb_addr                      : 12; /**< Memory Base Address */
+	uint32_t reserved_3_0                 : 4;
+#else
+	uint32_t reserved_3_0                 : 4;
+	uint32_t mb_addr                      : 12;
+	uint32_t reserved_19_16               : 4;
+	uint32_t ml_addr                      : 12;
+#endif
+	} cn70xx;
+	struct cvmx_pciercx_cfg008_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg008_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg008_cn70xx     cn78xx;
 	struct cvmx_pciercx_cfg008_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg008 cvmx_pciercx_cfg008_t;
@@ -4190,9 +4384,35 @@ union cvmx_pciercx_cfg009 {
 	struct cvmx_pciercx_cfg009_s          cn66xx;
 	struct cvmx_pciercx_cfg009_s          cn68xx;
 	struct cvmx_pciercx_cfg009_s          cn68xxp1;
-	struct cvmx_pciercx_cfg009_s          cn70xx;
-	struct cvmx_pciercx_cfg009_s          cn70xxp1;
-	struct cvmx_pciercx_cfg009_s          cn78xx;
+	struct cvmx_pciercx_cfg009_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t lmem_limit                   : 12; /**< Upper 12 bits of 32-bit Prefetchable Memory End Address */
+	uint32_t reserved_19_17               : 3;
+	uint32_t mem64b                       : 1;  /**< 64-Bit Memory Addressing
+                                                         o 0 = 32-bit memory addressing
+                                                         o 1 = 64-bit memory addressing */
+	uint32_t lmem_base                    : 12; /**< Upper 12 bits of 32-bit Prefetchable Memory Start Address */
+	uint32_t reserved_3_1                 : 3;
+	uint32_t mem64a                       : 1;  /**< "64-Bit Memory Addressing
+                                                         o 0 = 32-bit memory addressing
+                                                         o 1 = 64-bit memory addressing
+                                                         This bit is writable through PEM#_CFG_WR.
+                                                         When the application
+                                                         writes to this bit through PEM#_CFG_WR,
+                                                         the same value is written
+                                                         to bit 16 of this register." */
+#else
+	uint32_t mem64a                       : 1;
+	uint32_t reserved_3_1                 : 3;
+	uint32_t lmem_base                    : 12;
+	uint32_t mem64b                       : 1;
+	uint32_t reserved_19_17               : 3;
+	uint32_t lmem_limit                   : 12;
+#endif
+	} cn70xx;
+	struct cvmx_pciercx_cfg009_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg009_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg009_cn70xx     cn78xx;
 	struct cvmx_pciercx_cfg009_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg009 cvmx_pciercx_cfg009_t;
@@ -4226,6 +4446,7 @@ union cvmx_pciercx_cfg010 {
 	struct cvmx_pciercx_cfg010_s          cn68xxp1;
 	struct cvmx_pciercx_cfg010_s          cn70xx;
 	struct cvmx_pciercx_cfg010_s          cn70xxp1;
+	struct cvmx_pciercx_cfg010_s          cn73xx;
 	struct cvmx_pciercx_cfg010_s          cn78xx;
 	struct cvmx_pciercx_cfg010_s          cnf71xx;
 };
@@ -4260,6 +4481,7 @@ union cvmx_pciercx_cfg011 {
 	struct cvmx_pciercx_cfg011_s          cn68xxp1;
 	struct cvmx_pciercx_cfg011_s          cn70xx;
 	struct cvmx_pciercx_cfg011_s          cn70xxp1;
+	struct cvmx_pciercx_cfg011_s          cn73xx;
 	struct cvmx_pciercx_cfg011_s          cn78xx;
 	struct cvmx_pciercx_cfg011_s          cnf71xx;
 };
@@ -4296,6 +4518,7 @@ union cvmx_pciercx_cfg012 {
 	struct cvmx_pciercx_cfg012_s          cn68xxp1;
 	struct cvmx_pciercx_cfg012_s          cn70xx;
 	struct cvmx_pciercx_cfg012_s          cn70xxp1;
+	struct cvmx_pciercx_cfg012_s          cn73xx;
 	struct cvmx_pciercx_cfg012_s          cn78xx;
 	struct cvmx_pciercx_cfg012_s          cnf71xx;
 };
@@ -4333,6 +4556,7 @@ union cvmx_pciercx_cfg013 {
 	struct cvmx_pciercx_cfg013_s          cn68xxp1;
 	struct cvmx_pciercx_cfg013_s          cn70xx;
 	struct cvmx_pciercx_cfg013_s          cn70xxp1;
+	struct cvmx_pciercx_cfg013_s          cn73xx;
 	struct cvmx_pciercx_cfg013_s          cn78xx;
 	struct cvmx_pciercx_cfg013_s          cnf71xx;
 };
@@ -4365,6 +4589,7 @@ union cvmx_pciercx_cfg014 {
 	struct cvmx_pciercx_cfg014_s          cn68xxp1;
 	struct cvmx_pciercx_cfg014_s          cn70xx;
 	struct cvmx_pciercx_cfg014_s          cn70xxp1;
+	struct cvmx_pciercx_cfg014_s          cn73xx;
 	struct cvmx_pciercx_cfg014_s          cn78xx;
 	struct cvmx_pciercx_cfg014_s          cnf71xx;
 };
@@ -4440,9 +4665,61 @@ union cvmx_pciercx_cfg015 {
 	struct cvmx_pciercx_cfg015_s          cn66xx;
 	struct cvmx_pciercx_cfg015_s          cn68xx;
 	struct cvmx_pciercx_cfg015_s          cn68xxp1;
-	struct cvmx_pciercx_cfg015_s          cn70xx;
-	struct cvmx_pciercx_cfg015_s          cn70xxp1;
-	struct cvmx_pciercx_cfg015_s          cn78xx;
+	struct cvmx_pciercx_cfg015_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_31_28               : 4;
+	uint32_t dtsees                       : 1;  /**< Discard Timer SERR Enable Status
+                                                         Not applicable to PCI Express, hardwired to 0. */
+	uint32_t dts                          : 1;  /**< Discard Timer Status
+                                                         Not applicable to PCI Express, hardwired to 0. */
+	uint32_t sdt                          : 1;  /**< Secondary Discard Timer
+                                                         Not applicable to PCI Express, hardwired to 0. */
+	uint32_t pdt                          : 1;  /**< Primary Discard Timer
+                                                         Not applicable to PCI Express, hardwired to 0. */
+	uint32_t fbbe                         : 1;  /**< Fast Back-to-Back Transactions Enable
+                                                         Not applicable to PCI Express, hardwired to 0. */
+	uint32_t sbrst                        : 1;  /**< Secondary Bus Reset
+                                                         Hot reset. Causes TS1s with the hot reset bit to be sent to
+                                                         the link partner. When set, SW should wait 2ms before
+                                                         clearing. The link partner normally responds by sending TS1s
+                                                         with the hot reset bit set, which will cause a link
+                                                         down event - refer to "PCIe Link-Down Reset in RC Mode"
+                                                         section. */
+	uint32_t mam                          : 1;  /**< Master Abort Mode
+                                                         Not applicable to PCI Express, hardwired to 0. */
+	uint32_t vga16d                       : 1;  /**< VGA 16-Bit Decode */
+	uint32_t vgae                         : 1;  /**< VGA Enable */
+	uint32_t isae                         : 1;  /**< ISA Enable */
+	uint32_t see                          : 1;  /**< SERR Enable */
+	uint32_t pere                         : 1;  /**< Parity Error Response Enable */
+	uint32_t inta                         : 8;  /**< "Interrupt Pin
+                                                         Identifies the legacy interrupt Message that the device
+                                                         (or device function) uses.
+                                                         The Interrupt Pin register is writable through PEM#_CFG_WR.
+                                                         In a single-function configuration, only INTA is used.
+                                                         Therefore, the application must not change this field." */
+	uint32_t il                           : 8;  /**< Interrupt Line */
+#else
+	uint32_t il                           : 8;
+	uint32_t inta                         : 8;
+	uint32_t pere                         : 1;
+	uint32_t see                          : 1;
+	uint32_t isae                         : 1;
+	uint32_t vgae                         : 1;
+	uint32_t vga16d                       : 1;
+	uint32_t mam                          : 1;
+	uint32_t sbrst                        : 1;
+	uint32_t fbbe                         : 1;
+	uint32_t pdt                          : 1;
+	uint32_t sdt                          : 1;
+	uint32_t dts                          : 1;
+	uint32_t dtsees                       : 1;
+	uint32_t reserved_31_28               : 4;
+#endif
+	} cn70xx;
+	struct cvmx_pciercx_cfg015_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg015_cn70xx     cn73xx;
+	struct cvmx_pciercx_cfg015_cn70xx     cn78xx;
 	struct cvmx_pciercx_cfg015_s          cnf71xx;
 };
 typedef union cvmx_pciercx_cfg015 cvmx_pciercx_cfg015_t;
@@ -4509,6 +4786,7 @@ union cvmx_pciercx_cfg016 {
 	struct cvmx_pciercx_cfg016_s          cn68xxp1;
 	struct cvmx_pciercx_cfg016_s          cn70xx;
 	struct cvmx_pciercx_cfg016_s          cn70xxp1;
+	struct cvmx_pciercx_cfg016_s          cn73xx;
 	struct cvmx_pciercx_cfg016_s          cn78xx;
 	struct cvmx_pciercx_cfg016_s          cnf71xx;
 };
@@ -4574,6 +4852,7 @@ union cvmx_pciercx_cfg017 {
 	struct cvmx_pciercx_cfg017_s          cn68xxp1;
 	struct cvmx_pciercx_cfg017_s          cn70xx;
 	struct cvmx_pciercx_cfg017_s          cn70xxp1;
+	struct cvmx_pciercx_cfg017_s          cn73xx;
 	struct cvmx_pciercx_cfg017_s          cn78xx;
 	struct cvmx_pciercx_cfg017_s          cnf71xx;
 };
@@ -4662,7 +4941,7 @@ union cvmx_pciercx_cfg020 {
 	struct cvmx_pciercx_cfg020_s          cn68xxp1;
 	struct cvmx_pciercx_cfg020_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg020_cn61xx     cn70xxp1;
-	struct cvmx_pciercx_cfg020_cn78xx {
+	struct cvmx_pciercx_cfg020_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
 	uint32_t pvms                         : 1;  /**< Per-vector masking capable. */
@@ -4689,7 +4968,8 @@ union cvmx_pciercx_cfg020 {
 	uint32_t pvms                         : 1;
 	uint32_t reserved_25_31               : 7;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pciercx_cfg020_cn73xx     cn78xx;
 	struct cvmx_pciercx_cfg020_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg020 cvmx_pciercx_cfg020_t;
@@ -4723,6 +5003,7 @@ union cvmx_pciercx_cfg021 {
 	struct cvmx_pciercx_cfg021_s          cn68xxp1;
 	struct cvmx_pciercx_cfg021_s          cn70xx;
 	struct cvmx_pciercx_cfg021_s          cn70xxp1;
+	struct cvmx_pciercx_cfg021_s          cn73xx;
 	struct cvmx_pciercx_cfg021_s          cn78xx;
 	struct cvmx_pciercx_cfg021_s          cnf71xx;
 };
@@ -4755,6 +5036,7 @@ union cvmx_pciercx_cfg022 {
 	struct cvmx_pciercx_cfg022_s          cn68xxp1;
 	struct cvmx_pciercx_cfg022_s          cn70xx;
 	struct cvmx_pciercx_cfg022_s          cn70xxp1;
+	struct cvmx_pciercx_cfg022_s          cn73xx;
 	struct cvmx_pciercx_cfg022_s          cn78xx;
 	struct cvmx_pciercx_cfg022_s          cnf71xx;
 };
@@ -4791,6 +5073,7 @@ union cvmx_pciercx_cfg023 {
 	struct cvmx_pciercx_cfg023_s          cn68xxp1;
 	struct cvmx_pciercx_cfg023_s          cn70xx;
 	struct cvmx_pciercx_cfg023_s          cn70xxp1;
+	struct cvmx_pciercx_cfg023_s          cn73xx;
 	struct cvmx_pciercx_cfg023_s          cn78xx;
 	struct cvmx_pciercx_cfg023_s          cnf71xx;
 };
@@ -4843,6 +5126,7 @@ union cvmx_pciercx_cfg028 {
 	struct cvmx_pciercx_cfg028_s          cn68xxp1;
 	struct cvmx_pciercx_cfg028_s          cn70xx;
 	struct cvmx_pciercx_cfg028_s          cn70xxp1;
+	struct cvmx_pciercx_cfg028_s          cn73xx;
 	struct cvmx_pciercx_cfg028_s          cn78xx;
 	struct cvmx_pciercx_cfg028_s          cnf71xx;
 };
@@ -4908,6 +5192,7 @@ union cvmx_pciercx_cfg029 {
 	struct cvmx_pciercx_cfg029_s          cn68xxp1;
 	struct cvmx_pciercx_cfg029_s          cn70xx;
 	struct cvmx_pciercx_cfg029_s          cn70xxp1;
+	struct cvmx_pciercx_cfg029_s          cn73xx;
 	struct cvmx_pciercx_cfg029_s          cn78xx;
 	struct cvmx_pciercx_cfg029_s          cnf71xx;
 };
@@ -5025,6 +5310,7 @@ union cvmx_pciercx_cfg030 {
 	struct cvmx_pciercx_cfg030_s          cn68xxp1;
 	struct cvmx_pciercx_cfg030_s          cn70xx;
 	struct cvmx_pciercx_cfg030_s          cn70xxp1;
+	struct cvmx_pciercx_cfg030_s          cn73xx;
 	struct cvmx_pciercx_cfg030_s          cn78xx;
 	struct cvmx_pciercx_cfg030_s          cnf71xx;
 };
@@ -5156,6 +5442,7 @@ union cvmx_pciercx_cfg031 {
 	struct cvmx_pciercx_cfg031_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg031_s          cn70xx;
 	struct cvmx_pciercx_cfg031_s          cn70xxp1;
+	struct cvmx_pciercx_cfg031_s          cn73xx;
 	struct cvmx_pciercx_cfg031_s          cn78xx;
 	struct cvmx_pciercx_cfg031_s          cnf71xx;
 };
@@ -5259,6 +5546,7 @@ union cvmx_pciercx_cfg032 {
 	struct cvmx_pciercx_cfg032_s          cn68xxp1;
 	struct cvmx_pciercx_cfg032_s          cn70xx;
 	struct cvmx_pciercx_cfg032_s          cn70xxp1;
+	struct cvmx_pciercx_cfg032_s          cn73xx;
 	struct cvmx_pciercx_cfg032_s          cn78xx;
 	struct cvmx_pciercx_cfg032_s          cnf71xx;
 };
@@ -5323,6 +5611,7 @@ union cvmx_pciercx_cfg033 {
 	struct cvmx_pciercx_cfg033_s          cn68xxp1;
 	struct cvmx_pciercx_cfg033_s          cn70xx;
 	struct cvmx_pciercx_cfg033_s          cn70xxp1;
+	struct cvmx_pciercx_cfg033_s          cn73xx;
 	struct cvmx_pciercx_cfg033_s          cn78xx;
 	struct cvmx_pciercx_cfg033_s          cnf71xx;
 };
@@ -5397,6 +5686,7 @@ union cvmx_pciercx_cfg034 {
 	struct cvmx_pciercx_cfg034_s          cn68xxp1;
 	struct cvmx_pciercx_cfg034_s          cn70xx;
 	struct cvmx_pciercx_cfg034_s          cn70xxp1;
+	struct cvmx_pciercx_cfg034_s          cn73xx;
 	struct cvmx_pciercx_cfg034_s          cn78xx;
 	struct cvmx_pciercx_cfg034_s          cnf71xx;
 };
@@ -5445,6 +5735,7 @@ union cvmx_pciercx_cfg035 {
 	struct cvmx_pciercx_cfg035_s          cn68xxp1;
 	struct cvmx_pciercx_cfg035_s          cn70xx;
 	struct cvmx_pciercx_cfg035_s          cn70xxp1;
+	struct cvmx_pciercx_cfg035_s          cn73xx;
 	struct cvmx_pciercx_cfg035_s          cn78xx;
 	struct cvmx_pciercx_cfg035_s          cnf71xx;
 };
@@ -5483,6 +5774,7 @@ union cvmx_pciercx_cfg036 {
 	struct cvmx_pciercx_cfg036_s          cn68xxp1;
 	struct cvmx_pciercx_cfg036_s          cn70xx;
 	struct cvmx_pciercx_cfg036_s          cn70xxp1;
+	struct cvmx_pciercx_cfg036_s          cn73xx;
 	struct cvmx_pciercx_cfg036_s          cn78xx;
 	struct cvmx_pciercx_cfg036_s          cnf71xx;
 };
@@ -5636,7 +5928,7 @@ union cvmx_pciercx_cfg037 {
 	struct cvmx_pciercx_cfg037_cn66xx     cn68xxp1;
 	struct cvmx_pciercx_cfg037_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg037_cn61xx     cn70xxp1;
-	struct cvmx_pciercx_cfg037_cn78xx {
+	struct cvmx_pciercx_cfg037_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
 	uint32_t meetp                        : 2;  /**< Max end-end TLP prefixes.
@@ -5677,7 +5969,8 @@ union cvmx_pciercx_cfg037 {
 	uint32_t meetp                        : 2;
 	uint32_t reserved_24_31               : 8;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pciercx_cfg037_cn73xx     cn78xx;
 	struct cvmx_pciercx_cfg037_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_20_31               : 12;
@@ -5835,6 +6128,7 @@ union cvmx_pciercx_cfg038 {
 	struct cvmx_pciercx_cfg038_cn61xx     cn68xxp1;
 	struct cvmx_pciercx_cfg038_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg038_cn61xx     cn70xxp1;
+	struct cvmx_pciercx_cfg038_s          cn73xx;
 	struct cvmx_pciercx_cfg038_s          cn78xx;
 	struct cvmx_pciercx_cfg038_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
@@ -5936,6 +6230,7 @@ union cvmx_pciercx_cfg039 {
 	struct cvmx_pciercx_cfg039_s          cn68xxp1;
 	struct cvmx_pciercx_cfg039_s          cn70xx;
 	struct cvmx_pciercx_cfg039_s          cn70xxp1;
+	struct cvmx_pciercx_cfg039_s          cn73xx;
 	struct cvmx_pciercx_cfg039_s          cn78xx;
 	struct cvmx_pciercx_cfg039_s          cnf71xx;
 };
@@ -6164,6 +6459,7 @@ union cvmx_pciercx_cfg040 {
 	struct cvmx_pciercx_cfg040_cn61xx     cn68xxp1;
 	struct cvmx_pciercx_cfg040_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg040_cn61xx     cn70xxp1;
+	struct cvmx_pciercx_cfg040_s          cn73xx;
 	struct cvmx_pciercx_cfg040_s          cn78xx;
 	struct cvmx_pciercx_cfg040_cn61xx     cnf71xx;
 };
@@ -6196,6 +6492,7 @@ union cvmx_pciercx_cfg041 {
 	struct cvmx_pciercx_cfg041_s          cn68xxp1;
 	struct cvmx_pciercx_cfg041_s          cn70xx;
 	struct cvmx_pciercx_cfg041_s          cn70xxp1;
+	struct cvmx_pciercx_cfg041_s          cn73xx;
 	struct cvmx_pciercx_cfg041_s          cn78xx;
 	struct cvmx_pciercx_cfg041_s          cnf71xx;
 };
@@ -6228,6 +6525,7 @@ union cvmx_pciercx_cfg042 {
 	struct cvmx_pciercx_cfg042_s          cn68xxp1;
 	struct cvmx_pciercx_cfg042_s          cn70xx;
 	struct cvmx_pciercx_cfg042_s          cn70xxp1;
+	struct cvmx_pciercx_cfg042_s          cn73xx;
 	struct cvmx_pciercx_cfg042_s          cn78xx;
 	struct cvmx_pciercx_cfg042_s          cnf71xx;
 };
@@ -6262,6 +6560,7 @@ union cvmx_pciercx_cfg044 {
 	uint32_t msixen                       : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg044_s          cn73xx;
 	struct cvmx_pciercx_cfg044_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg044 cvmx_pciercx_cfg044_t;
@@ -6287,6 +6586,7 @@ union cvmx_pciercx_cfg045 {
 	uint32_t msixtoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg045_s          cn73xx;
 	struct cvmx_pciercx_cfg045_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg045 cvmx_pciercx_cfg045_t;
@@ -6312,6 +6612,7 @@ union cvmx_pciercx_cfg046 {
 	uint32_t msixpoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg046_s          cn73xx;
 	struct cvmx_pciercx_cfg046_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg046 cvmx_pciercx_cfg046_t;
@@ -6347,6 +6648,7 @@ union cvmx_pciercx_cfg064 {
 	struct cvmx_pciercx_cfg064_s          cn68xxp1;
 	struct cvmx_pciercx_cfg064_s          cn70xx;
 	struct cvmx_pciercx_cfg064_s          cn70xxp1;
+	struct cvmx_pciercx_cfg064_s          cn73xx;
 	struct cvmx_pciercx_cfg064_s          cn78xx;
 	struct cvmx_pciercx_cfg064_s          cnf71xx;
 };
@@ -6523,6 +6825,7 @@ union cvmx_pciercx_cfg065 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg065_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg065_s          cn73xx;
 	struct cvmx_pciercx_cfg065_s          cn78xx;
 	struct cvmx_pciercx_cfg065_cn70xx     cnf71xx;
 };
@@ -6699,6 +7002,7 @@ union cvmx_pciercx_cfg066 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg066_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg066_s          cn73xx;
 	struct cvmx_pciercx_cfg066_s          cn78xx;
 	struct cvmx_pciercx_cfg066_cn70xx     cnf71xx;
 };
@@ -6871,7 +7175,7 @@ union cvmx_pciercx_cfg067 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg067_cn70xx     cn70xxp1;
-	struct cvmx_pciercx_cfg067_cn78xx {
+	struct cvmx_pciercx_cfg067_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbes                        : 1;  /**< Unsupported TLP prefix blocked error severity. */
@@ -6909,7 +7213,8 @@ union cvmx_pciercx_cfg067 {
 	uint32_t tpbes                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pciercx_cfg067_cn73xx     cn78xx;
 	struct cvmx_pciercx_cfg067_cn70xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg067 cvmx_pciercx_cfg067_t;
@@ -6981,6 +7286,7 @@ union cvmx_pciercx_cfg068 {
 	struct cvmx_pciercx_cfg068_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg068_s          cn70xx;
 	struct cvmx_pciercx_cfg068_s          cn70xxp1;
+	struct cvmx_pciercx_cfg068_s          cn73xx;
 	struct cvmx_pciercx_cfg068_s          cn78xx;
 	struct cvmx_pciercx_cfg068_s          cnf71xx;
 };
@@ -7053,6 +7359,7 @@ union cvmx_pciercx_cfg069 {
 	struct cvmx_pciercx_cfg069_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg069_s          cn70xx;
 	struct cvmx_pciercx_cfg069_s          cn70xxp1;
+	struct cvmx_pciercx_cfg069_s          cn73xx;
 	struct cvmx_pciercx_cfg069_s          cn78xx;
 	struct cvmx_pciercx_cfg069_s          cnf71xx;
 };
@@ -7115,6 +7422,7 @@ union cvmx_pciercx_cfg070 {
 	struct cvmx_pciercx_cfg070_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg070_cn52xx     cn70xx;
 	struct cvmx_pciercx_cfg070_cn52xx     cn70xxp1;
+	struct cvmx_pciercx_cfg070_s          cn73xx;
 	struct cvmx_pciercx_cfg070_s          cn78xx;
 	struct cvmx_pciercx_cfg070_cn52xx     cnf71xx;
 };
@@ -7147,6 +7455,7 @@ union cvmx_pciercx_cfg071 {
 	struct cvmx_pciercx_cfg071_s          cn68xxp1;
 	struct cvmx_pciercx_cfg071_s          cn70xx;
 	struct cvmx_pciercx_cfg071_s          cn70xxp1;
+	struct cvmx_pciercx_cfg071_s          cn73xx;
 	struct cvmx_pciercx_cfg071_s          cn78xx;
 	struct cvmx_pciercx_cfg071_s          cnf71xx;
 };
@@ -7179,6 +7488,7 @@ union cvmx_pciercx_cfg072 {
 	struct cvmx_pciercx_cfg072_s          cn68xxp1;
 	struct cvmx_pciercx_cfg072_s          cn70xx;
 	struct cvmx_pciercx_cfg072_s          cn70xxp1;
+	struct cvmx_pciercx_cfg072_s          cn73xx;
 	struct cvmx_pciercx_cfg072_s          cn78xx;
 	struct cvmx_pciercx_cfg072_s          cnf71xx;
 };
@@ -7211,6 +7521,7 @@ union cvmx_pciercx_cfg073 {
 	struct cvmx_pciercx_cfg073_s          cn68xxp1;
 	struct cvmx_pciercx_cfg073_s          cn70xx;
 	struct cvmx_pciercx_cfg073_s          cn70xxp1;
+	struct cvmx_pciercx_cfg073_s          cn73xx;
 	struct cvmx_pciercx_cfg073_s          cn78xx;
 	struct cvmx_pciercx_cfg073_s          cnf71xx;
 };
@@ -7243,6 +7554,7 @@ union cvmx_pciercx_cfg074 {
 	struct cvmx_pciercx_cfg074_s          cn68xxp1;
 	struct cvmx_pciercx_cfg074_s          cn70xx;
 	struct cvmx_pciercx_cfg074_s          cn70xxp1;
+	struct cvmx_pciercx_cfg074_s          cn73xx;
 	struct cvmx_pciercx_cfg074_s          cn78xx;
 	struct cvmx_pciercx_cfg074_s          cnf71xx;
 };
@@ -7281,6 +7593,7 @@ union cvmx_pciercx_cfg075 {
 	struct cvmx_pciercx_cfg075_s          cn68xxp1;
 	struct cvmx_pciercx_cfg075_s          cn70xx;
 	struct cvmx_pciercx_cfg075_s          cn70xxp1;
+	struct cvmx_pciercx_cfg075_s          cn73xx;
 	struct cvmx_pciercx_cfg075_s          cn78xx;
 	struct cvmx_pciercx_cfg075_s          cnf71xx;
 };
@@ -7330,6 +7643,7 @@ union cvmx_pciercx_cfg076 {
 	struct cvmx_pciercx_cfg076_s          cn68xxp1;
 	struct cvmx_pciercx_cfg076_s          cn70xx;
 	struct cvmx_pciercx_cfg076_s          cn70xxp1;
+	struct cvmx_pciercx_cfg076_s          cn73xx;
 	struct cvmx_pciercx_cfg076_s          cn78xx;
 	struct cvmx_pciercx_cfg076_s          cnf71xx;
 };
@@ -7364,6 +7678,7 @@ union cvmx_pciercx_cfg077 {
 	struct cvmx_pciercx_cfg077_s          cn68xxp1;
 	struct cvmx_pciercx_cfg077_s          cn70xx;
 	struct cvmx_pciercx_cfg077_s          cn70xxp1;
+	struct cvmx_pciercx_cfg077_s          cn73xx;
 	struct cvmx_pciercx_cfg077_s          cn78xx;
 	struct cvmx_pciercx_cfg077_s          cnf71xx;
 };
@@ -7388,6 +7703,7 @@ union cvmx_pciercx_cfg086 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg086_s          cn73xx;
 	struct cvmx_pciercx_cfg086_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg086 cvmx_pciercx_cfg086_t;
@@ -7411,6 +7727,7 @@ union cvmx_pciercx_cfg087 {
 	uint32_t reserved_2_31                : 30;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg087_s          cn73xx;
 	struct cvmx_pciercx_cfg087_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg087 cvmx_pciercx_cfg087_t;
@@ -7432,6 +7749,7 @@ union cvmx_pciercx_cfg088 {
 	uint32_t reserved_8_31                : 24;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg088_s          cn73xx;
 	struct cvmx_pciercx_cfg088_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg088 cvmx_pciercx_cfg088_t;
@@ -7481,6 +7799,7 @@ union cvmx_pciercx_cfg089 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg089_s          cn73xx;
 	struct cvmx_pciercx_cfg089_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg089 cvmx_pciercx_cfg089_t;
@@ -7530,6 +7849,7 @@ union cvmx_pciercx_cfg090 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg090_s          cn73xx;
 	struct cvmx_pciercx_cfg090_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg090 cvmx_pciercx_cfg090_t;
@@ -7579,6 +7899,7 @@ union cvmx_pciercx_cfg091 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg091_s          cn73xx;
 	struct cvmx_pciercx_cfg091_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg091 cvmx_pciercx_cfg091_t;
@@ -7628,6 +7949,7 @@ union cvmx_pciercx_cfg092 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg092_s          cn73xx;
 	struct cvmx_pciercx_cfg092_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg092 cvmx_pciercx_cfg092_t;
@@ -7675,6 +7997,7 @@ union cvmx_pciercx_cfg448 {
 	struct cvmx_pciercx_cfg448_s          cn68xxp1;
 	struct cvmx_pciercx_cfg448_s          cn70xx;
 	struct cvmx_pciercx_cfg448_s          cn70xxp1;
+	struct cvmx_pciercx_cfg448_s          cn73xx;
 	struct cvmx_pciercx_cfg448_s          cn78xx;
 	struct cvmx_pciercx_cfg448_s          cnf71xx;
 };
@@ -7718,6 +8041,7 @@ union cvmx_pciercx_cfg449 {
 	struct cvmx_pciercx_cfg449_s          cn68xxp1;
 	struct cvmx_pciercx_cfg449_s          cn70xx;
 	struct cvmx_pciercx_cfg449_s          cn70xxp1;
+	struct cvmx_pciercx_cfg449_s          cn73xx;
 	struct cvmx_pciercx_cfg449_s          cn78xx;
 	struct cvmx_pciercx_cfg449_s          cnf71xx;
 };
@@ -7888,6 +8212,7 @@ union cvmx_pciercx_cfg450 {
 	struct cvmx_pciercx_cfg450_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg450_s          cn70xx;
 	struct cvmx_pciercx_cfg450_s          cn70xxp1;
+	struct cvmx_pciercx_cfg450_cn52xx     cn73xx;
 	struct cvmx_pciercx_cfg450_cn52xx     cn78xx;
 	struct cvmx_pciercx_cfg450_cn52xx     cnf71xx;
 };
@@ -8012,6 +8337,7 @@ union cvmx_pciercx_cfg451 {
 	struct cvmx_pciercx_cfg451_s          cn68xxp1;
 	struct cvmx_pciercx_cfg451_s          cn70xx;
 	struct cvmx_pciercx_cfg451_s          cn70xxp1;
+	struct cvmx_pciercx_cfg451_s          cn73xx;
 	struct cvmx_pciercx_cfg451_s          cn78xx;
 	struct cvmx_pciercx_cfg451_s          cnf71xx;
 };
@@ -8285,6 +8611,7 @@ union cvmx_pciercx_cfg452 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg452_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg452_cn70xx     cn73xx;
 	struct cvmx_pciercx_cfg452_cn70xx     cn78xx;
 	struct cvmx_pciercx_cfg452_cn61xx     cnf71xx;
 };
@@ -8333,6 +8660,7 @@ union cvmx_pciercx_cfg453 {
 	struct cvmx_pciercx_cfg453_s          cn68xxp1;
 	struct cvmx_pciercx_cfg453_s          cn70xx;
 	struct cvmx_pciercx_cfg453_s          cn70xxp1;
+	struct cvmx_pciercx_cfg453_s          cn73xx;
 	struct cvmx_pciercx_cfg453_s          cn78xx;
 	struct cvmx_pciercx_cfg453_s          cnf71xx;
 };
@@ -8455,7 +8783,7 @@ union cvmx_pciercx_cfg454 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg454_cn70xx     cn70xxp1;
-	struct cvmx_pciercx_cfg454_cn78xx {
+	struct cvmx_pciercx_cfg454_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_29_31               : 3;
 	uint32_t tmfcwt                       : 5;  /**< Used to be 'timer modifier for flow control watchdog timer.' This field is no longer used.
@@ -8475,7 +8803,8 @@ union cvmx_pciercx_cfg454 {
 	uint32_t tmfcwt                       : 5;
 	uint32_t reserved_29_31               : 3;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pciercx_cfg454_cn73xx     cn78xx;
 	struct cvmx_pciercx_cfg454_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg454 cvmx_pciercx_cfg454_t;
@@ -8544,6 +8873,7 @@ union cvmx_pciercx_cfg455 {
 	struct cvmx_pciercx_cfg455_s          cn68xxp1;
 	struct cvmx_pciercx_cfg455_s          cn70xx;
 	struct cvmx_pciercx_cfg455_s          cn70xxp1;
+	struct cvmx_pciercx_cfg455_s          cn73xx;
 	struct cvmx_pciercx_cfg455_s          cn78xx;
 	struct cvmx_pciercx_cfg455_s          cnf71xx;
 };
@@ -8594,6 +8924,7 @@ union cvmx_pciercx_cfg456 {
 	struct cvmx_pciercx_cfg456_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg456_s          cn70xx;
 	struct cvmx_pciercx_cfg456_s          cn70xxp1;
+	struct cvmx_pciercx_cfg456_s          cn73xx;
 	struct cvmx_pciercx_cfg456_s          cn78xx;
 	struct cvmx_pciercx_cfg456_s          cnf71xx;
 };
@@ -8626,6 +8957,7 @@ union cvmx_pciercx_cfg458 {
 	struct cvmx_pciercx_cfg458_s          cn68xxp1;
 	struct cvmx_pciercx_cfg458_s          cn70xx;
 	struct cvmx_pciercx_cfg458_s          cn70xxp1;
+	struct cvmx_pciercx_cfg458_s          cn73xx;
 	struct cvmx_pciercx_cfg458_s          cn78xx;
 	struct cvmx_pciercx_cfg458_s          cnf71xx;
 };
@@ -8658,6 +8990,7 @@ union cvmx_pciercx_cfg459 {
 	struct cvmx_pciercx_cfg459_s          cn68xxp1;
 	struct cvmx_pciercx_cfg459_s          cn70xx;
 	struct cvmx_pciercx_cfg459_s          cn70xxp1;
+	struct cvmx_pciercx_cfg459_s          cn73xx;
 	struct cvmx_pciercx_cfg459_s          cn78xx;
 	struct cvmx_pciercx_cfg459_s          cnf71xx;
 };
@@ -8698,6 +9031,7 @@ union cvmx_pciercx_cfg460 {
 	struct cvmx_pciercx_cfg460_s          cn68xxp1;
 	struct cvmx_pciercx_cfg460_s          cn70xx;
 	struct cvmx_pciercx_cfg460_s          cn70xxp1;
+	struct cvmx_pciercx_cfg460_s          cn73xx;
 	struct cvmx_pciercx_cfg460_s          cn78xx;
 	struct cvmx_pciercx_cfg460_s          cnf71xx;
 };
@@ -8738,6 +9072,7 @@ union cvmx_pciercx_cfg461 {
 	struct cvmx_pciercx_cfg461_s          cn68xxp1;
 	struct cvmx_pciercx_cfg461_s          cn70xx;
 	struct cvmx_pciercx_cfg461_s          cn70xxp1;
+	struct cvmx_pciercx_cfg461_s          cn73xx;
 	struct cvmx_pciercx_cfg461_s          cn78xx;
 	struct cvmx_pciercx_cfg461_s          cnf71xx;
 };
@@ -8778,6 +9113,7 @@ union cvmx_pciercx_cfg462 {
 	struct cvmx_pciercx_cfg462_s          cn68xxp1;
 	struct cvmx_pciercx_cfg462_s          cn70xx;
 	struct cvmx_pciercx_cfg462_s          cn70xxp1;
+	struct cvmx_pciercx_cfg462_s          cn73xx;
 	struct cvmx_pciercx_cfg462_s          cn78xx;
 	struct cvmx_pciercx_cfg462_s          cnf71xx;
 };
@@ -8850,6 +9186,7 @@ union cvmx_pciercx_cfg463 {
 	struct cvmx_pciercx_cfg463_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg463_cn52xx     cn70xx;
 	struct cvmx_pciercx_cfg463_cn52xx     cn70xxp1;
+	struct cvmx_pciercx_cfg463_s          cn73xx;
 	struct cvmx_pciercx_cfg463_s          cn78xx;
 	struct cvmx_pciercx_cfg463_cn52xx     cnf71xx;
 };
@@ -8888,6 +9225,7 @@ union cvmx_pciercx_cfg464 {
 	struct cvmx_pciercx_cfg464_s          cn68xxp1;
 	struct cvmx_pciercx_cfg464_s          cn70xx;
 	struct cvmx_pciercx_cfg464_s          cn70xxp1;
+	struct cvmx_pciercx_cfg464_s          cn73xx;
 	struct cvmx_pciercx_cfg464_s          cn78xx;
 	struct cvmx_pciercx_cfg464_s          cnf71xx;
 };
@@ -8926,6 +9264,7 @@ union cvmx_pciercx_cfg465 {
 	struct cvmx_pciercx_cfg465_s          cn68xxp1;
 	struct cvmx_pciercx_cfg465_s          cn70xx;
 	struct cvmx_pciercx_cfg465_s          cn70xxp1;
+	struct cvmx_pciercx_cfg465_s          cn73xx;
 	struct cvmx_pciercx_cfg465_s          cn78xx;
 	struct cvmx_pciercx_cfg465_s          cnf71xx;
 };
@@ -9000,6 +9339,7 @@ union cvmx_pciercx_cfg466 {
 	struct cvmx_pciercx_cfg466_s          cn68xxp1;
 	struct cvmx_pciercx_cfg466_s          cn70xx;
 	struct cvmx_pciercx_cfg466_s          cn70xxp1;
+	struct cvmx_pciercx_cfg466_s          cn73xx;
 	struct cvmx_pciercx_cfg466_s          cn78xx;
 	struct cvmx_pciercx_cfg466_s          cnf71xx;
 };
@@ -9056,6 +9396,7 @@ union cvmx_pciercx_cfg467 {
 	struct cvmx_pciercx_cfg467_s          cn68xxp1;
 	struct cvmx_pciercx_cfg467_s          cn70xx;
 	struct cvmx_pciercx_cfg467_s          cn70xxp1;
+	struct cvmx_pciercx_cfg467_s          cn73xx;
 	struct cvmx_pciercx_cfg467_s          cn78xx;
 	struct cvmx_pciercx_cfg467_s          cnf71xx;
 };
@@ -9112,6 +9453,7 @@ union cvmx_pciercx_cfg468 {
 	struct cvmx_pciercx_cfg468_s          cn68xxp1;
 	struct cvmx_pciercx_cfg468_s          cn70xx;
 	struct cvmx_pciercx_cfg468_s          cn70xxp1;
+	struct cvmx_pciercx_cfg468_s          cn73xx;
 	struct cvmx_pciercx_cfg468_s          cn78xx;
 	struct cvmx_pciercx_cfg468_s          cnf71xx;
 };
@@ -9307,6 +9649,7 @@ union cvmx_pciercx_cfg515 {
 	struct cvmx_pciercx_cfg515_s          cn68xxp1;
 	struct cvmx_pciercx_cfg515_s          cn70xx;
 	struct cvmx_pciercx_cfg515_s          cn70xxp1;
+	struct cvmx_pciercx_cfg515_s          cn73xx;
 	struct cvmx_pciercx_cfg515_s          cn78xx;
 	struct cvmx_pciercx_cfg515_s          cnf71xx;
 };
@@ -9339,6 +9682,7 @@ union cvmx_pciercx_cfg516 {
 	struct cvmx_pciercx_cfg516_s          cn68xxp1;
 	struct cvmx_pciercx_cfg516_s          cn70xx;
 	struct cvmx_pciercx_cfg516_s          cn70xxp1;
+	struct cvmx_pciercx_cfg516_s          cn73xx;
 	struct cvmx_pciercx_cfg516_s          cn78xx;
 	struct cvmx_pciercx_cfg516_s          cnf71xx;
 };
@@ -9371,6 +9715,7 @@ union cvmx_pciercx_cfg517 {
 	struct cvmx_pciercx_cfg517_s          cn68xxp1;
 	struct cvmx_pciercx_cfg517_s          cn70xx;
 	struct cvmx_pciercx_cfg517_s          cn70xxp1;
+	struct cvmx_pciercx_cfg517_s          cn73xx;
 	struct cvmx_pciercx_cfg517_s          cn78xx;
 	struct cvmx_pciercx_cfg517_s          cnf71xx;
 };
@@ -9414,6 +9759,7 @@ union cvmx_pciercx_cfg548 {
 	uint32_t reserved_19_31               : 13;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg548_s          cn73xx;
 	struct cvmx_pciercx_cfg548_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg548 cvmx_pciercx_cfg548_t;
@@ -9479,6 +9825,7 @@ union cvmx_pciercx_cfg554 {
 	uint32_t reserved_25_31               : 7;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg554_s          cn73xx;
 	struct cvmx_pciercx_cfg554_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg554 cvmx_pciercx_cfg554_t;
@@ -9500,6 +9847,7 @@ union cvmx_pciercx_cfg558 {
 	uint32_t ple                          : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg558_s          cn73xx;
 	struct cvmx_pciercx_cfg558_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg558 cvmx_pciercx_cfg558_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
index e4b3750..7dfa22a 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
@@ -991,8 +991,24 @@ union cvmx_pcsx_anx_ext_st_reg {
 	struct cvmx_pcsx_anx_ext_st_reg_s     cn66xx;
 	struct cvmx_pcsx_anx_ext_st_reg_s     cn68xx;
 	struct cvmx_pcsx_anx_ext_st_reg_s     cn68xxp1;
-	struct cvmx_pcsx_anx_ext_st_reg_s     cn70xx;
-	struct cvmx_pcsx_anx_ext_st_reg_s     cn70xxp1;
+	struct cvmx_pcsx_anx_ext_st_reg_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t thou_xfd                     : 1;  /**< 1 means PHY is 1000BASE-X Full Dup capable */
+	uint64_t thou_xhd                     : 1;  /**< 1 means PHY is 1000BASE-X Half Dup capable */
+	uint64_t thou_tfd                     : 1;  /**< 1 means PHY is 1000BASE-T Full Dup capable */
+	uint64_t thou_thd                     : 1;  /**< 1 means PHY is 1000BASE-T Half Dup capable */
+	uint64_t reserved_11_0                : 12;
+#else
+	uint64_t reserved_11_0                : 12;
+	uint64_t thou_thd                     : 1;
+	uint64_t thou_tfd                     : 1;
+	uint64_t thou_xhd                     : 1;
+	uint64_t thou_xfd                     : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn70xx;
+	struct cvmx_pcsx_anx_ext_st_reg_cn70xx cn70xxp1;
 	struct cvmx_pcsx_anx_ext_st_reg_s     cnf71xx;
 };
 typedef union cvmx_pcsx_anx_ext_st_reg cvmx_pcsx_anx_ext_st_reg_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
index d3e594f..d171c17 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
@@ -53,644 +53,644 @@
 #define __CVMX_PCSXX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_10GBX_STATUS_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_10GBX_STATUS_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_10GBX_STATUS_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_10GBX_STATUS_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_10GBX_STATUS_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_10GBX_STATUS_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_BIST_STATUS_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_BIST_STATUS_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_BIST_STATUS_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_BIST_STATUS_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_BIST_STATUS_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_BIST_STATUS_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_BIT_LOCK_STATUS_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_BIT_LOCK_STATUS_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_BIT_LOCK_STATUS_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_BIT_LOCK_STATUS_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_BIT_LOCK_STATUS_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_BIT_LOCK_STATUS_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_CONTROL1_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_CONTROL1_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_CONTROL1_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_CONTROL1_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_CONTROL1_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_CONTROL1_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_CONTROL2_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_CONTROL2_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_CONTROL2_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_CONTROL2_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_CONTROL2_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_CONTROL2_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_INT_EN_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_INT_EN_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_INT_EN_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_INT_EN_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_INT_EN_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_INT_EN_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_INT_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_INT_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_INT_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_INT_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_LOG_ANL_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_LOG_ANL_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_LOG_ANL_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_LOG_ANL_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_LOG_ANL_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_LOG_ANL_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_MISC_CTL_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_MISC_CTL_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_MISC_CTL_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_MISC_CTL_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_MISC_CTL_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_MISC_CTL_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_RX_SYNC_STATES_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_RX_SYNC_STATES_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_RX_SYNC_STATES_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_RX_SYNC_STATES_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_RX_SYNC_STATES_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_RX_SYNC_STATES_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_SERDES_CRDT_CNT_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_SERDES_CRDT_CNT_REG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_PCSXX_SERDES_CRDT_CNT_REG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_PCSXX_SERDES_CRDT_CNT_REG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800B0000880ull);
 }
 #else
-#define CVMX_PCSXX_SERDES_CRDT_CNT_REG(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000880ull))
+#define CVMX_PCSXX_SERDES_CRDT_CNT_REG(offset) (CVMX_ADD_IO_SEG(0x00011800B0000880ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_SPD_ABIL_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_SPD_ABIL_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_SPD_ABIL_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_SPD_ABIL_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_SPD_ABIL_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_SPD_ABIL_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_STATUS1_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_STATUS1_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_STATUS1_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_STATUS1_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_STATUS1_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_STATUS1_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_STATUS2_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_STATUS2_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_STATUS2_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_STATUS2_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_STATUS2_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_STATUS2_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_TX_RX_POLARITY_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_TX_RX_POLARITY_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_TX_RX_POLARITY_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_TX_RX_POLARITY_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_TX_RX_POLARITY_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_TX_RX_POLARITY_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (offset) * 0x8000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCSXX_TX_RX_STATES_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_TX_RX_STATES_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((block_id) & 1) * 0x8000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((offset) & 1) * 0x8000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((block_id) & 0) * 0x8000000ull;
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((offset) & 0) * 0x8000000ull;
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 4))
-				return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((block_id) & 7) * 0x1000000ull;
+			if ((offset <= 4))
+				return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((offset) & 7) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PCSXX_TX_RX_STATES_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((block_id) & 0) * 0x8000000ull;
+	cvmx_warn("CVMX_PCSXX_TX_RX_STATES_REG (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((offset) & 0) * 0x8000000ull;
 }
 #else
-static inline uint64_t CVMX_PCSXX_TX_RX_STATES_REG(unsigned long block_id)
+static inline uint64_t CVMX_PCSXX_TX_RX_STATES_REG(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (block_id) * 0x8000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (offset) * 0x8000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (block_id) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (offset) * 0x8000000ull;
 }
 #endif
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 92883f8..509d5e4 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -69,6 +69,7 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if (((offset <= 15)) && ((block_id <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
@@ -89,53 +90,56 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((block_id) & 3) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_BAR2_MASK (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_BAR2_MASK (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -143,23 +147,24 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((block_id) & 3) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_BAR_CTL (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_BAR_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -167,17 +172,18 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -185,23 +191,24 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((block_id) & 3) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_BIST_STATUS (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_BIST_STATUS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -209,17 +216,18 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_BIST_STATUS2(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_BIST_STATUS2(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -227,19 +235,19 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS2(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_BIST_STATUS2 (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_BIST_STATUS2 (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_BIST_STATUS2(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_BIST_STATUS2(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -247,118 +255,125 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS2(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_CFG(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PEMX_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_CFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_CFG(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_CFG(offset) (CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_CFG_RD(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_CFG_RD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_CFG_RD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000030ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_CFG_RD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000030ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_CFG_RD(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000030ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_CFG_RD(offset) (CVMX_ADD_IO_SEG(0x00011800C0000030ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_CFG_WR(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_CFG_WR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_CFG_WR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000028ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_CFG_WR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000028ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_CFG_WR(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000028ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_CFG_WR(offset) (CVMX_ADD_IO_SEG(0x00011800C0000028ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_CLK_EN(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_CLK_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PEMX_CLK_EN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000400ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_CLK_EN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000400ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_CLK_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000400ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_CLK_EN(offset) (CVMX_ADD_IO_SEG(0x00011800C0000400ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_CPL_LUT_VALID(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_CPL_LUT_VALID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_CPL_LUT_VALID(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000098ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_CPL_LUT_VALID(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000098ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_CPL_LUT_VALID(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000098ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_CPL_LUT_VALID(offset) (CVMX_ADD_IO_SEG(0x00011800C0000098ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_CTL_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_CTL_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_CTL_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000000ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_CTL_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000000ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_CTL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000000ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_CTL_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C0000000ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_CTL_STATUS2(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_CTL_STATUS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PEMX_CTL_STATUS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_CTL_STATUS2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_CTL_STATUS2(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_CTL_STATUS2(offset) (CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -366,23 +381,24 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((block_id) & 3) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_DBG_INFO (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_DBG_INFO (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -390,146 +406,154 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_DBG_INFO_EN(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_DBG_INFO_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_DBG_INFO_EN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_DBG_INFO_EN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_DBG_INFO_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_DBG_INFO_EN(offset) (CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_DIAG_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_DIAG_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_DIAG_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000020ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_DIAG_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000020ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_DIAG_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000020ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_DIAG_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C0000020ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((block_id) & 3) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_ECC_ENA (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((block_id) & 3) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_ECC_ENA (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((block_id) & 3) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_ECC_SYND_CTRL (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((block_id) & 3) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_ECC_SYND_CTRL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((block_id) & 3) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_INB_READ_CREDITS (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_INB_READ_CREDITS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_INT_ENB(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_INT_ENB(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -537,19 +561,19 @@ static inline uint64_t CVMX_PEMX_INT_ENB(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_INT_ENB (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_INT_ENB (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_INT_ENB(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_INT_ENB(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -557,15 +581,15 @@ static inline uint64_t CVMX_PEMX_INT_ENB(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000430ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000430ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_INT_ENB_INT(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_INT_ENB_INT(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -573,19 +597,19 @@ static inline uint64_t CVMX_PEMX_INT_ENB_INT(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C0000438ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C0000438ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_INT_ENB_INT (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_INT_ENB_INT (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_INT_ENB_INT(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_INT_ENB_INT(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -593,15 +617,15 @@ static inline uint64_t CVMX_PEMX_INT_ENB_INT(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000438ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000438ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -609,23 +633,24 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((block_id) & 1) * 0x1000000ull;
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 2))
-				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((block_id) & 3) * 0x1000000ull;
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((block_id) & 3) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 	}
-	cvmx_warn("CVMX_PEMX_INT_SUM (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((block_id) & 1) * 0x1000000ull;
+	cvmx_warn("CVMX_PEMX_INT_SUM (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -633,77 +658,82 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (block_id) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
 	}
-	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + (block_id) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + (offset) * 0x1000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_ON(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_ON(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PEMX_ON(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_ON(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_ON(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_ON(offset) (CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_P2N_BAR0_START(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_P2N_BAR0_START(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_P2N_BAR0_START(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000080ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_P2N_BAR0_START(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000080ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_P2N_BAR0_START(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000080ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_P2N_BAR0_START(offset) (CVMX_ADD_IO_SEG(0x00011800C0000080ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_P2N_BAR1_START(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_P2N_BAR1_START(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_P2N_BAR1_START(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000088ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_P2N_BAR1_START(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000088ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_P2N_BAR1_START(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000088ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_P2N_BAR1_START(offset) (CVMX_ADD_IO_SEG(0x00011800C0000088ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_P2N_BAR2_START(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_P2N_BAR2_START(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_P2N_BAR2_START(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000090ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_P2N_BAR2_START(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000090ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_P2N_BAR2_START(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000090ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_P2N_BAR2_START(offset) (CVMX_ADD_IO_SEG(0x00011800C0000090ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEMX_P2P_BARX_END(unsigned long offset, unsigned long block_id)
@@ -712,6 +742,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_END(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_END(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000048ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16;
@@ -726,6 +757,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_START(unsigned long offset, unsigned l
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_START(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000040ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16;
@@ -734,68 +766,73 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_START(unsigned long offset, unsigned l
 #define CVMX_PEMX_P2P_BARX_START(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C0000040ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_QLM(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_QLM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PEMX_QLM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_QLM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_QLM(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_QLM(offset) (CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_SPI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_SPI_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PEMX_SPI_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000180ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_SPI_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000180ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_SPI_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000180ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_SPI_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800C0000180ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_SPI_DATA(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_SPI_DATA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PEMX_SPI_DATA(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000188ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_SPI_DATA(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000188ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_SPI_DATA(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000188ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_SPI_DATA(offset) (CVMX_ADD_IO_SEG(0x00011800C0000188ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_STRAP(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_STRAP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PEMX_STRAP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PEMX_STRAP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_STRAP(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_STRAP(offset) (CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PEMX_TLP_CREDITS(unsigned long block_id)
+static inline uint64_t CVMX_PEMX_TLP_CREDITS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PEMX_TLP_CREDITS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000038ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_TLP_CREDITS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000038ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_TLP_CREDITS(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000038ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_PEMX_TLP_CREDITS(offset) (CVMX_ADD_IO_SEG(0x00011800C0000038ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 
 /**
@@ -843,6 +880,7 @@ union cvmx_pemx_bar1_indexx {
 	struct cvmx_pemx_bar1_indexx_cn61xx   cn68xxp1;
 	struct cvmx_pemx_bar1_indexx_s        cn70xx;
 	struct cvmx_pemx_bar1_indexx_s        cn70xxp1;
+	struct cvmx_pemx_bar1_indexx_s        cn73xx;
 	struct cvmx_pemx_bar1_indexx_s        cn78xx;
 	struct cvmx_pemx_bar1_indexx_cn61xx   cnf71xx;
 };
@@ -885,6 +923,7 @@ union cvmx_pemx_bar2_mask {
 	struct cvmx_pemx_bar2_mask_cn61xx     cn68xxp1;
 	struct cvmx_pemx_bar2_mask_cn61xx     cn70xx;
 	struct cvmx_pemx_bar2_mask_cn61xx     cn70xxp1;
+	struct cvmx_pemx_bar2_mask_s          cn73xx;
 	struct cvmx_pemx_bar2_mask_s          cn78xx;
 	struct cvmx_pemx_bar2_mask_cn61xx     cnf71xx;
 };
@@ -927,6 +966,7 @@ union cvmx_pemx_bar_ctl {
 	struct cvmx_pemx_bar_ctl_s            cn68xxp1;
 	struct cvmx_pemx_bar_ctl_s            cn70xx;
 	struct cvmx_pemx_bar_ctl_s            cn70xxp1;
+	struct cvmx_pemx_bar_ctl_s            cn73xx;
 	struct cvmx_pemx_bar_ctl_s            cn78xx;
 	struct cvmx_pemx_bar_ctl_s            cnf71xx;
 };
@@ -1015,7 +1055,7 @@ union cvmx_pemx_bist_status {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_bist_status_cn70xx   cn70xxp1;
-	struct cvmx_pemx_bist_status_cn78xx {
+	struct cvmx_pemx_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_26_63               : 38;
 	uint64_t retryc                       : 1;  /**< Retry buffer memory C. */
@@ -1055,7 +1095,8 @@ union cvmx_pemx_bist_status {
 	uint64_t retryc                       : 1;
 	uint64_t reserved_26_63               : 38;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_bist_status_cn73xx   cn78xx;
 	struct cvmx_pemx_bist_status_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_bist_status cvmx_pemx_bist_status_t;
@@ -1219,7 +1260,7 @@ union cvmx_pemx_cfg {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_cfg_cn70xx           cn70xxp1;
-	struct cvmx_pemx_cfg_cn78xx {
+	struct cvmx_pemx_cfg_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t laneswap                     : 1;  /**< This field enables overwriting the value for lane swapping. The reset value is captured on
@@ -1252,7 +1293,8 @@ union cvmx_pemx_cfg {
 	uint64_t laneswap                     : 1;
 	uint64_t reserved_5_63                : 59;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_cfg_cn73xx           cn78xx;
 };
 typedef union cvmx_pemx_cfg cvmx_pemx_cfg_t;
 
@@ -1282,6 +1324,7 @@ union cvmx_pemx_cfg_rd {
 	struct cvmx_pemx_cfg_rd_s             cn68xxp1;
 	struct cvmx_pemx_cfg_rd_s             cn70xx;
 	struct cvmx_pemx_cfg_rd_s             cn70xxp1;
+	struct cvmx_pemx_cfg_rd_s             cn73xx;
 	struct cvmx_pemx_cfg_rd_s             cn78xx;
 	struct cvmx_pemx_cfg_rd_s             cnf71xx;
 };
@@ -1314,6 +1357,7 @@ union cvmx_pemx_cfg_wr {
 	struct cvmx_pemx_cfg_wr_s             cn68xxp1;
 	struct cvmx_pemx_cfg_wr_s             cn70xx;
 	struct cvmx_pemx_cfg_wr_s             cn70xxp1;
+	struct cvmx_pemx_cfg_wr_s             cn73xx;
 	struct cvmx_pemx_cfg_wr_s             cn78xx;
 	struct cvmx_pemx_cfg_wr_s             cnf71xx;
 };
@@ -1340,6 +1384,7 @@ union cvmx_pemx_clk_en {
 	} s;
 	struct cvmx_pemx_clk_en_s             cn70xx;
 	struct cvmx_pemx_clk_en_s             cn70xxp1;
+	struct cvmx_pemx_clk_en_s             cn73xx;
 	struct cvmx_pemx_clk_en_s             cn78xx;
 };
 typedef union cvmx_pemx_clk_en cvmx_pemx_clk_en_t;
@@ -1377,6 +1422,7 @@ union cvmx_pemx_cpl_lut_valid {
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cn68xxp1;
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cn70xx;
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cn70xxp1;
+	struct cvmx_pemx_cpl_lut_valid_s      cn73xx;
 	struct cvmx_pemx_cpl_lut_valid_s      cn78xx;
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cnf71xx;
 };
@@ -1520,7 +1566,7 @@ union cvmx_pemx_ctl_status {
 	struct cvmx_pemx_ctl_status_cn61xx    cn68xxp1;
 	struct cvmx_pemx_ctl_status_s         cn70xx;
 	struct cvmx_pemx_ctl_status_s         cn70xxp1;
-	struct cvmx_pemx_ctl_status_cn78xx {
+	struct cvmx_pemx_ctl_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
 	uint64_t inv_dpar                     : 1;  /**< Invert the generated parity to be written into the most significant data queue buffer RAM
@@ -1571,7 +1617,8 @@ union cvmx_pemx_ctl_status {
 	uint64_t inv_dpar                     : 1;
 	uint64_t reserved_51_63               : 13;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_ctl_status_cn73xx    cn78xx;
 	struct cvmx_pemx_ctl_status_cn61xx    cnf71xx;
 };
 typedef union cvmx_pemx_ctl_status cvmx_pemx_ctl_status_t;
@@ -1598,6 +1645,7 @@ union cvmx_pemx_ctl_status2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pemx_ctl_status2_s        cn73xx;
 	struct cvmx_pemx_ctl_status2_s        cn78xx;
 };
 typedef union cvmx_pemx_ctl_status2 cvmx_pemx_ctl_status2_t;
@@ -2017,7 +2065,7 @@ union cvmx_pemx_dbg_info {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_dbg_info_cn70xx      cn70xxp1;
-	struct cvmx_pemx_dbg_info_cn78xx {
+	struct cvmx_pemx_dbg_info_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
 	uint64_t qhdr_b1_dbe                  : 1;  /**< Detected a core header queue bank1 double bit error. */
@@ -2147,7 +2195,8 @@ union cvmx_pemx_dbg_info {
 	uint64_t qhdr_b1_dbe                  : 1;
 	uint64_t reserved_58_63               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_dbg_info_cn73xx      cn78xx;
 	struct cvmx_pemx_dbg_info_cn61xx      cnf71xx;
 };
 typedef union cvmx_pemx_dbg_info cvmx_pemx_dbg_info_t;
@@ -2386,7 +2435,7 @@ union cvmx_pemx_diag_status {
 	struct cvmx_pemx_diag_status_cn61xx   cn68xxp1;
 	struct cvmx_pemx_diag_status_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_6_63                : 58;
+	uint64_t reserved_63_6                : 58;
 	uint64_t pm_dst                       : 3;  /**< Current power management DSTATE. */
 	uint64_t pm_stat                      : 1;  /**< Power Management Status. */
 	uint64_t pm_en                        : 1;  /**< Power Management Event Enable. */
@@ -2396,11 +2445,28 @@ union cvmx_pemx_diag_status {
 	uint64_t pm_en                        : 1;
 	uint64_t pm_stat                      : 1;
 	uint64_t pm_dst                       : 3;
-	uint64_t reserved_6_63                : 58;
+	uint64_t reserved_63_6                : 58;
 #endif
 	} cn70xx;
 	struct cvmx_pemx_diag_status_cn70xx   cn70xxp1;
-	struct cvmx_pemx_diag_status_s        cn78xx;
+	struct cvmx_pemx_diag_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_63_9                : 55;
+	uint64_t pwrdwn                       : 3;  /**< Current mac_phy_powerdown state. */
+	uint64_t pm_dst                       : 3;  /**< Current power management DSTATE. */
+	uint64_t pm_stat                      : 1;  /**< Power management status. */
+	uint64_t pm_en                        : 1;  /**< Power management event enable. */
+	uint64_t aux_en                       : 1;  /**< Auxiliary power enable. */
+#else
+	uint64_t aux_en                       : 1;
+	uint64_t pm_en                        : 1;
+	uint64_t pm_stat                      : 1;
+	uint64_t pm_dst                       : 3;
+	uint64_t pwrdwn                       : 3;
+	uint64_t reserved_63_9                : 55;
+#endif
+	} cn73xx;
+	struct cvmx_pemx_diag_status_cn73xx   cn78xx;
 	struct cvmx_pemx_diag_status_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_diag_status cvmx_pemx_diag_status_t;
@@ -2456,7 +2522,7 @@ union cvmx_pemx_ecc_ena {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_ecc_ena_cn70xx       cn70xxp1;
-	struct cvmx_pemx_ecc_ena_cn78xx {
+	struct cvmx_pemx_ecc_ena_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_35_63               : 29;
 	uint64_t qhdr_b1_ena                  : 1;  /**< ECC enable for Core's Q HDR Bank1 RAM. */
@@ -2488,7 +2554,8 @@ union cvmx_pemx_ecc_ena {
 	uint64_t qhdr_b1_ena                  : 1;
 	uint64_t reserved_35_63               : 29;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_ecc_ena_cn73xx       cn78xx;
 };
 typedef union cvmx_pemx_ecc_ena cvmx_pemx_ecc_ena_t;
 
@@ -2543,7 +2610,7 @@ union cvmx_pemx_ecc_synd_ctrl {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_ecc_synd_ctrl_cn70xx cn70xxp1;
-	struct cvmx_pemx_ecc_synd_ctrl_cn78xx {
+	struct cvmx_pemx_ecc_synd_ctrl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_38_63               : 26;
 	uint64_t qhdr_b1_syn                  : 2;  /**< Syndrome flip bits for Core's Q HDR Bank1 RAM. */
@@ -2575,7 +2642,8 @@ union cvmx_pemx_ecc_synd_ctrl {
 	uint64_t qhdr_b1_syn                  : 2;
 	uint64_t reserved_38_63               : 26;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_ecc_synd_ctrl_cn73xx cn78xx;
 };
 typedef union cvmx_pemx_ecc_synd_ctrl cvmx_pemx_ecc_synd_ctrl_t;
 
@@ -2613,6 +2681,7 @@ union cvmx_pemx_inb_read_credits {
 	struct cvmx_pemx_inb_read_credits_cn61xx cn68xx;
 	struct cvmx_pemx_inb_read_credits_cn61xx cn70xx;
 	struct cvmx_pemx_inb_read_credits_cn61xx cn70xxp1;
+	struct cvmx_pemx_inb_read_credits_s   cn73xx;
 	struct cvmx_pemx_inb_read_credits_s   cn78xx;
 	struct cvmx_pemx_inb_read_credits_cn61xx cnf71xx;
 };
@@ -2865,7 +2934,7 @@ union cvmx_pemx_int_sum {
 	struct cvmx_pemx_int_sum_cn61xx       cn68xxp1;
 	struct cvmx_pemx_int_sum_cn61xx       cn70xx;
 	struct cvmx_pemx_int_sum_cn61xx       cn70xxp1;
-	struct cvmx_pemx_int_sum_cn78xx {
+	struct cvmx_pemx_int_sum_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. This is a level-sensitive interrupt. */
 	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. This is a level-sensitive interrupt. */
@@ -2908,7 +2977,8 @@ union cvmx_pemx_int_sum {
 	uint64_t intc                         : 1;
 	uint64_t intd                         : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_int_sum_cn73xx       cn78xx;
 	struct cvmx_pemx_int_sum_cn61xx       cnf71xx;
 };
 typedef union cvmx_pemx_int_sum cvmx_pemx_int_sum_t;
@@ -2936,6 +3006,7 @@ union cvmx_pemx_on {
 	} s;
 	struct cvmx_pemx_on_s                 cn70xx;
 	struct cvmx_pemx_on_s                 cn70xxp1;
+	struct cvmx_pemx_on_s                 cn73xx;
 	struct cvmx_pemx_on_s                 cn78xx;
 };
 typedef union cvmx_pemx_on cvmx_pemx_on_t;
@@ -2950,6 +3021,13 @@ union cvmx_pemx_p2n_bar0_start {
 	uint64_t u64;
 	struct cvmx_pemx_p2n_bar0_start_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} s;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t addr                         : 50; /**< The starting address of the 16KB address space that
                                                          is the BAR0 address space. */
 	uint64_t reserved_0_13                : 14;
@@ -2957,17 +3035,33 @@ union cvmx_pemx_p2n_bar0_start {
 	uint64_t reserved_0_13                : 14;
 	uint64_t addr                         : 50;
 #endif
-	} s;
-	struct cvmx_pemx_p2n_bar0_start_s     cn61xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn63xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn63xxp1;
-	struct cvmx_pemx_p2n_bar0_start_s     cn66xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn68xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn68xxp1;
-	struct cvmx_pemx_p2n_bar0_start_s     cn70xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn70xxp1;
-	struct cvmx_pemx_p2n_bar0_start_s     cn78xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cnf71xx;
+	} cn61xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn63xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn63xxp1;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn66xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn68xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn68xxp1;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn70xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn70xxp1;
+	struct cvmx_pemx_p2n_bar0_start_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t addr                         : 40; /**< The starting address of the 64MB BAR0 address space. */
+	uint64_t reserved_0_23                : 24;
+#else
+	uint64_t reserved_0_23                : 24;
+	uint64_t addr                         : 40;
+#endif
+	} cn73xx;
+	struct cvmx_pemx_p2n_bar0_start_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t addr                         : 49; /**< The starting address of the 32KB BAR0 address space. */
+	uint64_t reserved_0_14                : 15;
+#else
+	uint64_t reserved_0_14                : 15;
+	uint64_t addr                         : 49;
+#endif
+	} cn78xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cnf71xx;
 };
 typedef union cvmx_pemx_p2n_bar0_start cvmx_pemx_p2n_bar0_start_t;
 
@@ -2997,6 +3091,7 @@ union cvmx_pemx_p2n_bar1_start {
 	struct cvmx_pemx_p2n_bar1_start_s     cn68xxp1;
 	struct cvmx_pemx_p2n_bar1_start_s     cn70xx;
 	struct cvmx_pemx_p2n_bar1_start_s     cn70xxp1;
+	struct cvmx_pemx_p2n_bar1_start_s     cn73xx;
 	struct cvmx_pemx_p2n_bar1_start_s     cn78xx;
 	struct cvmx_pemx_p2n_bar1_start_s     cnf71xx;
 };
@@ -3034,7 +3129,7 @@ union cvmx_pemx_p2n_bar2_start {
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cn68xxp1;
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cn70xx;
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cn70xxp1;
-	struct cvmx_pemx_p2n_bar2_start_cn78xx {
+	struct cvmx_pemx_p2n_bar2_start_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t addr                         : 19; /**< The starting address of the 2^45 BAR2 address space. */
 	uint64_t reserved_0_44                : 45;
@@ -3042,7 +3137,8 @@ union cvmx_pemx_p2n_bar2_start {
 	uint64_t reserved_0_44                : 45;
 	uint64_t addr                         : 19;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_p2n_bar2_start_cn73xx cn78xx;
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cnf71xx;
 };
 typedef union cvmx_pemx_p2n_bar2_start cvmx_pemx_p2n_bar2_start_t;
@@ -3071,6 +3167,7 @@ union cvmx_pemx_p2p_barx_end {
 	struct cvmx_pemx_p2p_barx_end_s       cn66xx;
 	struct cvmx_pemx_p2p_barx_end_s       cn68xx;
 	struct cvmx_pemx_p2p_barx_end_s       cn68xxp1;
+	struct cvmx_pemx_p2p_barx_end_s       cn73xx;
 	struct cvmx_pemx_p2p_barx_end_s       cn78xx;
 };
 typedef union cvmx_pemx_p2p_barx_end cvmx_pemx_p2p_barx_end_t;
@@ -3114,6 +3211,7 @@ union cvmx_pemx_p2p_barx_start {
 	struct cvmx_pemx_p2p_barx_start_cn63xx cn66xx;
 	struct cvmx_pemx_p2p_barx_start_cn63xx cn68xx;
 	struct cvmx_pemx_p2p_barx_start_cn63xx cn68xxp1;
+	struct cvmx_pemx_p2p_barx_start_s     cn73xx;
 	struct cvmx_pemx_p2p_barx_start_s     cn78xx;
 };
 typedef union cvmx_pemx_p2p_barx_start cvmx_pemx_p2p_barx_start_t;
@@ -3139,6 +3237,7 @@ union cvmx_pemx_qlm {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pemx_qlm_s                cn73xx;
 	struct cvmx_pemx_qlm_s                cn78xx;
 };
 typedef union cvmx_pemx_qlm cvmx_pemx_qlm_t;
@@ -3169,6 +3268,7 @@ union cvmx_pemx_spi_ctl {
 	} s;
 	struct cvmx_pemx_spi_ctl_s            cn70xx;
 	struct cvmx_pemx_spi_ctl_s            cn70xxp1;
+	struct cvmx_pemx_spi_ctl_s            cn73xx;
 	struct cvmx_pemx_spi_ctl_s            cn78xx;
 };
 typedef union cvmx_pemx_spi_ctl cvmx_pemx_spi_ctl_t;
@@ -3198,6 +3298,7 @@ union cvmx_pemx_spi_data {
 	} s;
 	struct cvmx_pemx_spi_data_s           cn70xx;
 	struct cvmx_pemx_spi_data_s           cn70xxp1;
+	struct cvmx_pemx_spi_data_s           cn73xx;
 	struct cvmx_pemx_spi_data_s           cn78xx;
 };
 typedef union cvmx_pemx_spi_data cvmx_pemx_spi_data_t;
@@ -3235,7 +3336,7 @@ union cvmx_pemx_strap {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_strap_cn70xx         cn70xxp1;
-	struct cvmx_pemx_strap_cn78xx {
+	struct cvmx_pemx_strap_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t pilaneswap                   : 1;  /**< The value of the pi_select_laneswap pin, which is captured on chip cold reset. It is not
@@ -3256,7 +3357,8 @@ union cvmx_pemx_strap {
 	uint64_t pilaneswap                   : 1;
 	uint64_t reserved_4_63                : 60;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_strap_cn73xx         cn78xx;
 };
 typedef union cvmx_pemx_strap cvmx_pemx_strap_t;
 
@@ -3326,24 +3428,77 @@ union cvmx_pemx_tlp_credits {
 	struct cvmx_pemx_tlp_credits_s        cn68xxp1;
 	struct cvmx_pemx_tlp_credits_cn61xx   cn70xx;
 	struct cvmx_pemx_tlp_credits_cn61xx   cn70xxp1;
-	struct cvmx_pemx_tlp_credits_cn78xx {
+	struct cvmx_pemx_tlp_credits_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t pem_cpl                      : 8;  /**< TLP 16B credits for completion TLPs in the peer. Legal values are 0x12 to 0x40. */
 	uint64_t pem_np                       : 8;  /**< TLP 16B credits for nonposted TLPs in the peer. Legal values are 0x4 to 0x8. */
 	uint64_t pem_p                        : 8;  /**< TLP 16B credits for posted TLPs in the peer. Legal values are 0x12 to 0x40. */
 	uint64_t sli_cpl                      : 8;  /**< TLP 8B credits for completion TLPs in the SLI. Legal values are 0x24 to
-                                                         0x80. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
+                                                         0xFF. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
                                                          SLI interface, while PEM(2) and PEM(3) share the other. When both PEMs of a pair
-                                                         are configured, the sum of both PEMs' SLI_CPL fields must not exceed 0x100. */
+                                                         are configured, the sum of both PEMs' SLI_CPL fields must not exceed 0x100. The
+                                                         reset value for this register assumes the minimum (e.g. 4-lane)
+                                                         configuration. This ensures that for configurations where the total number of
+                                                         lanes for a pair of PEMs exceeds 8, the total allocated credits does not
+                                                         oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0xFF
+                                                            2 4-ln PEMs    n    4             0x80
+                                                                          n+1   4             0x80
+                                                            1 4-ln PEM     n    4             0xFF
+                                                            1 8-ln PEM,    n    8             0xAA
+                                                            1 4-ln PEM    n+1   4             0x55
+                                                         </pre> */
 	uint64_t sli_np                       : 8;  /**< TLP 8B credits for nonposted TLPs in the SLI. Legal values are 0x4 to
                                                          0x20. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
                                                          SLI interface, while PEM(2) and PEM(3) share the other. When both PEMs of a pair
-                                                         are configured, the sum of both PEMs' SLI_NP fields must not exceed 0x20. */
+                                                         are configured, the sum of both PEMs' SLI_NP fields must not exceed 0x20. The
+                                                         reset value for this register assumes the minimum (e.g. 4-lane)
+                                                         configuration. This ensures that for configurations where the total number of
+                                                         lanes for a pair of PEMs exceeds 8, the total allocated credits does not
+                                                         oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0x20
+                                                            2 4-ln PEMs    n    4             0x10
+                                                                          n+1   4             0x10
+                                                            1 4-ln PEM     n    4             0x20
+                                                            1 8-ln PEM,    n    8             0x15
+                                                            1 4-ln PEM    n+1   4             0x0B
+                                                         </pre> */
 	uint64_t sli_p                        : 8;  /**< TLP 8B credits for Posted TLPs in the SLI. Legal values are 0x24 to 0xFF. Pairs
                                                          of PEMs share a single SLI interface. PEM(0) and PEM(1) share one SLI interface,
                                                          while PEM(2) and PEM(3) share the other. When both PEMs of a pair are
-                                                         configured, the sum of both PEMs' SLI_P fields must not exceed 0x100. */
+                                                         configured, the sum of both PEMs' SLI_P fields must not exceed 0x100. The reset
+                                                         value for this register assumes the minimum (e.g. 4-lane) configuration. This
+                                                         ensures that for configurations where the total number of lanes for a pair of
+                                                         PEMs exceeds 8, the total allocated credits does not oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0xFF
+                                                            2 4-ln PEMs    n    4             0x80
+                                                                          n+1   4             0x80
+                                                            1 4-ln PEM     n    4             0xFF
+                                                            1 8-ln PEM,    n    8             0xAA
+                                                            1 4-ln PEM    n+1   4             0x55
+                                                         </pre> */
 #else
 	uint64_t sli_p                        : 8;
 	uint64_t sli_np                       : 8;
@@ -3353,7 +3508,8 @@ union cvmx_pemx_tlp_credits {
 	uint64_t pem_cpl                      : 8;
 	uint64_t reserved_48_63               : 16;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_tlp_credits_cn73xx   cn78xx;
 	struct cvmx_pemx_tlp_credits_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_tlp_credits cvmx_pemx_tlp_credits_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pescx-defs.h b/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
index 0aaa881..78b1b7c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
@@ -53,160 +53,160 @@
 #define __CVMX_PESCX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000018ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000018ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000018ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000018ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_BIST_STATUS2(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_BIST_STATUS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_BIST_STATUS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000418ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_BIST_STATUS2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000418ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_BIST_STATUS2(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000418ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_BIST_STATUS2(offset) (CVMX_ADD_IO_SEG(0x00011800C8000418ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_CFG_RD(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_CFG_RD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_CFG_RD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000030ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_CFG_RD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000030ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_CFG_RD(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000030ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_CFG_RD(offset) (CVMX_ADD_IO_SEG(0x00011800C8000030ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_CFG_WR(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_CFG_WR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_CFG_WR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000028ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_CFG_WR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000028ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_CFG_WR(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000028ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_CFG_WR(offset) (CVMX_ADD_IO_SEG(0x00011800C8000028ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_CPL_LUT_VALID(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_CPL_LUT_VALID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_CPL_LUT_VALID(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000098ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_CPL_LUT_VALID(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000098ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_CPL_LUT_VALID(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000098ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_CPL_LUT_VALID(offset) (CVMX_ADD_IO_SEG(0x00011800C8000098ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_CTL_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_CTL_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_CTL_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000000ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_CTL_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000000ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_CTL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000000ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_CTL_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000000ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_CTL_STATUS2(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_CTL_STATUS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_CTL_STATUS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000400ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_CTL_STATUS2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000400ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_CTL_STATUS2(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000400ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_CTL_STATUS2(offset) (CVMX_ADD_IO_SEG(0x00011800C8000400ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_DBG_INFO(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_DBG_INFO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_DBG_INFO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_DBG_INFO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_DBG_INFO(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_DBG_INFO(offset) (CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_DBG_INFO_EN(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_DBG_INFO_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_DBG_INFO_EN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_DBG_INFO_EN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_DBG_INFO_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_DBG_INFO_EN(offset) (CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_DIAG_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_DIAG_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_DIAG_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000020ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_DIAG_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000020ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_DIAG_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000020ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_DIAG_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000020ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_P2N_BAR0_START(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_P2N_BAR0_START(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_P2N_BAR0_START(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000080ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_P2N_BAR0_START(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000080ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_P2N_BAR0_START(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000080ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_P2N_BAR0_START(offset) (CVMX_ADD_IO_SEG(0x00011800C8000080ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_P2N_BAR1_START(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_P2N_BAR1_START(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_P2N_BAR1_START(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000088ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_P2N_BAR1_START(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000088ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_P2N_BAR1_START(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000088ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_P2N_BAR1_START(offset) (CVMX_ADD_IO_SEG(0x00011800C8000088ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_P2N_BAR2_START(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_P2N_BAR2_START(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_P2N_BAR2_START(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000090ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_P2N_BAR2_START(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000090ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_P2N_BAR2_START(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000090ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_P2N_BAR2_START(offset) (CVMX_ADD_IO_SEG(0x00011800C8000090ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PESCX_P2P_BARX_END(unsigned long offset, unsigned long block_id)
@@ -233,16 +233,16 @@ static inline uint64_t CVMX_PESCX_P2P_BARX_START(unsigned long offset, unsigned
 #define CVMX_PESCX_P2P_BARX_START(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C8000040ull) + (((offset) & 3) + ((block_id) & 1) * 0x800000ull) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PESCX_TLP_CREDITS(unsigned long block_id)
+static inline uint64_t CVMX_PESCX_TLP_CREDITS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_PESCX_TLP_CREDITS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000038ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PESCX_TLP_CREDITS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000038ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_PESCX_TLP_CREDITS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000038ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PESCX_TLP_CREDITS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000038ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
index f0ffd92..e41c877 100644
--- a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
@@ -1152,7 +1152,7 @@ static inline uint64_t CVMX_PEXP_NPEI_WINDOW_CTL_FUNC(void)
 #define CVMX_PEXP_SLI_BIST_STATUS CVMX_PEXP_SLI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
 }
@@ -1168,6 +1168,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_CTL_PORTX(%lu) is invalid on this chip\n", offset);
@@ -1180,7 +1181,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 #define CVMX_PEXP_SLI_CTL_STATUS CVMX_PEXP_SLI_CTL_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_CTL_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
 }
@@ -1191,7 +1192,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 #define CVMX_PEXP_SLI_DATA_OUT_CNT CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_DATA_OUT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
 }
@@ -1229,6 +1230,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_CNT(%lu) is invalid on this chip\n", offset);
@@ -1246,6 +1248,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_INT_LEVEL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n", offset);
@@ -1263,6 +1266,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_TIM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_TIM(%lu) is invalid on this chip\n", offset);
@@ -1291,6 +1295,7 @@ static inline uint64_t CVMX_PEXP_SLI_INT_ENB_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n", offset);
@@ -1303,7 +1308,7 @@ static inline uint64_t CVMX_PEXP_SLI_INT_ENB_PORTX(unsigned long offset)
 #define CVMX_PEXP_SLI_INT_SUM CVMX_PEXP_SLI_INT_SUM_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010330ull);
 }
@@ -1358,7 +1363,7 @@ static inline uint64_t CVMX_PEXP_SLI_LAST_WIN_RDATA3_FUNC(void)
 #define CVMX_PEXP_SLI_MAC_CREDIT_CNT CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
 }
@@ -1369,7 +1374,7 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 #define CVMX_PEXP_SLI_MAC_CREDIT_CNT2 CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
 }
@@ -1380,7 +1385,7 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 #define CVMX_PEXP_SLI_MEM_ACCESS_CTL CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
 }
@@ -1396,6 +1401,7 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset >= 12) && (offset <= 27)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset >= 12) && (offset <= 27))))))
 		cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n", offset);
@@ -1452,7 +1458,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_ENB3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV0 CVMX_PEXP_SLI_MSI_RCV0_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
 }
@@ -1463,7 +1469,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV1 CVMX_PEXP_SLI_MSI_RCV1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
 }
@@ -1474,7 +1480,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV2 CVMX_PEXP_SLI_MSI_RCV2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
 }
@@ -1485,7 +1491,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV3 CVMX_PEXP_SLI_MSI_RCV3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
 }
@@ -1496,7 +1502,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RD_MAP CVMX_PEXP_SLI_MSI_RD_MAP_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RD_MAP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
 }
@@ -1595,7 +1601,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_W1S_ENB3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_WR_MAP CVMX_PEXP_SLI_MSI_WR_MAP_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_WR_MAP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
 }
@@ -1606,7 +1612,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
 }
@@ -1617,7 +1623,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
 }
@@ -1628,7 +1634,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
 }
@@ -1639,7 +1645,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
 }
@@ -1655,13 +1661,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_CNTS(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_CNTS(offset) (CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKTX_CNTS(offset) (CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BADDR(unsigned long offset)
@@ -1672,13 +1679,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_INSTR_BADDR(offset) (CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKTX_INSTR_BADDR(offset) (CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
@@ -1689,13 +1697,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(offset) (CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(offset) (CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
@@ -1706,13 +1715,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_HEADER(unsigned long offset)
@@ -1754,13 +1764,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_OUT_SIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_OUT_SIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKTX_OUT_SIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BADDR(unsigned long offset)
@@ -1771,13 +1782,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_SLIST_BADDR(offset) (CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKTX_SLIST_BADDR(offset) (CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
@@ -1788,13 +1800,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(offset) (CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(offset) (CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
@@ -1805,19 +1818,20 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_CNT_INT CVMX_PEXP_SLI_PKT_CNT_INT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_CNT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_CNT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
 }
@@ -1905,7 +1919,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_INPUT_CONTROL_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_INSTR_ENB CVMX_PEXP_SLI_PKT_INSTR_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_INSTR_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_INSTR_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011000ull);
 }
@@ -1965,19 +1979,20 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 63) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(offset) (CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 63) * 16)
+#define CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(offset) (CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
 }
@@ -2010,7 +2025,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IPTR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUTPUT_WMARK CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
 }
@@ -2032,7 +2047,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BMODE_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011240ull);
 }
@@ -2043,7 +2058,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_ENB CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011010ull);
 }
@@ -2109,7 +2124,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_SLIST_ROR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_TIME_INT CVMX_PEXP_SLI_PKT_TIME_INT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_TIME_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_TIME_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
 }
@@ -2147,6 +2162,7 @@ static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n", offset);
@@ -2159,7 +2175,7 @@ static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 #define CVMX_PEXP_SLI_SCRATCH_1 CVMX_PEXP_SLI_SCRATCH_1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_SCRATCH_1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
 }
@@ -2170,7 +2186,7 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 #define CVMX_PEXP_SLI_SCRATCH_2 CVMX_PEXP_SLI_SCRATCH_2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_SCRATCH_2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
 }
@@ -2181,7 +2197,7 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 #define CVMX_PEXP_SLI_STATE1 CVMX_PEXP_SLI_STATE1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
 }
@@ -2192,7 +2208,7 @@ static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 #define CVMX_PEXP_SLI_STATE2 CVMX_PEXP_SLI_STATE2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
 }
@@ -2203,7 +2219,7 @@ static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 #define CVMX_PEXP_SLI_STATE3 CVMX_PEXP_SLI_STATE3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
 }
@@ -2225,7 +2241,7 @@ static inline uint64_t CVMX_PEXP_SLI_TX_PIPE_FUNC(void)
 #define CVMX_PEXP_SLI_WINDOW_CTL CVMX_PEXP_SLI_WINDOW_CTL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_WINDOW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_WINDOW_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-pip-defs.h b/arch/mips/include/asm/octeon/cvmx-pip-defs.h
index bd5437f..2b78b54 100644
--- a/arch/mips/include/asm/octeon/cvmx-pip-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pip-defs.h
@@ -864,15 +864,15 @@ static inline uint64_t CVMX_PIP_STAT_INB_PKTS_PKNDX(unsigned long offset)
 #define CVMX_PIP_STAT_INB_PKTS_PKNDX(offset) (CVMX_ADD_IO_SEG(0x00011800A0020000ull) + ((offset) & 63) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PIP_SUB_PKIND_FCSX(unsigned long block_id)
+static inline uint64_t CVMX_PIP_SUB_PKIND_FCSX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_PIP_SUB_PKIND_FCSX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_PIP_SUB_PKIND_FCSX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800A0080000ull);
 }
 #else
-#define CVMX_PIP_SUB_PKIND_FCSX(block_id) (CVMX_ADD_IO_SEG(0x00011800A0080000ull))
+#define CVMX_PIP_SUB_PKIND_FCSX(offset) (CVMX_ADD_IO_SEG(0x00011800A0080000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PIP_TAG_INCX(unsigned long offset)
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 0a6bc39..dcb418e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_PKI_ACTIVE0 CVMX_PKI_ACTIVE0_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000220ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
 #define CVMX_PKI_ACTIVE1 CVMX_PKI_ACTIVE1_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000230ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
 #define CVMX_PKI_ACTIVE2 CVMX_PKI_ACTIVE2_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000240ull);
 }
@@ -89,6 +89,7 @@ static inline uint64_t CVMX_PKI_ACTIVE2_FUNC(void)
 static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_AURAX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044900000ull) + ((offset) & 1023) * 8;
@@ -100,7 +101,7 @@ static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 #define CVMX_PKI_BIST_STATUS0 CVMX_PKI_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000080ull);
 }
@@ -111,7 +112,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS0_FUNC(void)
 #define CVMX_PKI_BIST_STATUS1 CVMX_PKI_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000088ull);
 }
@@ -122,7 +123,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS1_FUNC(void)
 #define CVMX_PKI_BIST_STATUS2 CVMX_PKI_BIST_STATUS2_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000090ull);
 }
@@ -133,6 +134,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS2_FUNC(void)
 static inline uint64_t CVMX_PKI_BPIDX_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_BPIDX_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044B00000ull) + ((offset) & 1023) * 8;
@@ -144,7 +146,7 @@ static inline uint64_t CVMX_PKI_BPIDX_STATE(unsigned long offset)
 #define CVMX_PKI_BUF_CTL CVMX_PKI_BUF_CTL_FUNC()
 static inline uint64_t CVMX_PKI_BUF_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BUF_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000100ull);
 }
@@ -155,6 +157,7 @@ static inline uint64_t CVMX_PKI_BUF_CTL_FUNC(void)
 static inline uint64_t CVMX_PKI_CHANX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_PKI_CHANX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044A00000ull) + ((offset) & 4095) * 8;
@@ -166,7 +169,7 @@ static inline uint64_t CVMX_PKI_CHANX_CFG(unsigned long offset)
 #define CVMX_PKI_CLKEN CVMX_PKI_CLKEN_FUNC()
 static inline uint64_t CVMX_PKI_CLKEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_CLKEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000410ull);
 }
@@ -174,42 +177,46 @@ static inline uint64_t CVMX_PKI_CLKEN_FUNC(void)
 #define CVMX_PKI_CLKEN (CVMX_ADD_IO_SEG(0x0001180044000410ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PKI_CLX_ECC_CTL(unsigned long block_id)
+static inline uint64_t CVMX_PKI_CLX_ECC_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PKI_CLX_ECC_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118004400C020ull) + ((block_id) & 3) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PKI_CLX_ECC_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118004400C020ull) + ((offset) & 3) * 0x10000ull;
 }
 #else
-#define CVMX_PKI_CLX_ECC_CTL(block_id) (CVMX_ADD_IO_SEG(0x000118004400C020ull) + ((block_id) & 3) * 0x10000ull)
+#define CVMX_PKI_CLX_ECC_CTL(offset) (CVMX_ADD_IO_SEG(0x000118004400C020ull) + ((offset) & 3) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PKI_CLX_ECC_INT(unsigned long block_id)
+static inline uint64_t CVMX_PKI_CLX_ECC_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PKI_CLX_ECC_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118004400C010ull) + ((block_id) & 3) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PKI_CLX_ECC_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118004400C010ull) + ((offset) & 3) * 0x10000ull;
 }
 #else
-#define CVMX_PKI_CLX_ECC_INT(block_id) (CVMX_ADD_IO_SEG(0x000118004400C010ull) + ((block_id) & 3) * 0x10000ull)
+#define CVMX_PKI_CLX_ECC_INT(offset) (CVMX_ADD_IO_SEG(0x000118004400C010ull) + ((offset) & 3) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PKI_CLX_INT(unsigned long block_id)
+static inline uint64_t CVMX_PKI_CLX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PKI_CLX_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118004400C000ull) + ((block_id) & 3) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PKI_CLX_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118004400C000ull) + ((offset) & 3) * 0x10000ull;
 }
 #else
-#define CVMX_PKI_CLX_INT(block_id) (CVMX_ADD_IO_SEG(0x000118004400C000ull) + ((block_id) & 3) * 0x10000ull)
+#define CVMX_PKI_CLX_INT(offset) (CVMX_ADD_IO_SEG(0x000118004400C000ull) + ((offset) & 3) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_CLX_PCAMX_ACTIONX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_ACTIONX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044708000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -221,6 +228,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_ACTIONX(unsigned long a, unsigned long
 static inline uint64_t CVMX_PKI_CLX_PCAMX_MATCHX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_MATCHX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044704000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -232,6 +240,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_MATCHX(unsigned long a, unsigned long
 static inline uint64_t CVMX_PKI_CLX_PCAMX_TERMX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_TERMX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044700000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -243,6 +252,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_TERMX(unsigned long a, unsigned long b
 static inline uint64_t CVMX_PKI_CLX_PKINDX_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300040ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -254,6 +264,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_CFG(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_PKI_CLX_PKINDX_KMEMX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 63)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 63)) && ((c <= 15))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_KMEMX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044200000ull) + ((a) << 16) + ((b) << 8) + ((c) << 3);
@@ -265,6 +276,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_KMEMX(unsigned long a, unsigned long
 static inline uint64_t CVMX_PKI_CLX_PKINDX_L2_CUSTOM(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_L2_CUSTOM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300058ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -276,6 +288,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_L2_CUSTOM(unsigned long offset, unsig
 static inline uint64_t CVMX_PKI_CLX_PKINDX_LG_CUSTOM(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_LG_CUSTOM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300060ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -287,6 +300,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_LG_CUSTOM(unsigned long offset, unsig
 static inline uint64_t CVMX_PKI_CLX_PKINDX_SKIP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_SKIP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300050ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -298,6 +312,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_SKIP(unsigned long offset, unsigned l
 static inline uint64_t CVMX_PKI_CLX_PKINDX_STYLE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_STYLE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300048ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -309,6 +324,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_STYLE(unsigned long offset, unsigned
 static inline uint64_t CVMX_PKI_CLX_SMEMX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 2047)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 2047)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_SMEMX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044400000ull) + (((offset) & 2047) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -317,20 +333,22 @@ static inline uint64_t CVMX_PKI_CLX_SMEMX(unsigned long offset, unsigned long bl
 #define CVMX_PKI_CLX_SMEMX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180044400000ull) + (((offset) & 2047) + ((block_id) & 3) * 0x2000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PKI_CLX_START(unsigned long block_id)
+static inline uint64_t CVMX_PKI_CLX_START(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
-		cvmx_warn("CVMX_PKI_CLX_START(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000118004400C030ull) + ((block_id) & 3) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_PKI_CLX_START(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118004400C030ull) + ((offset) & 3) * 0x10000ull;
 }
 #else
-#define CVMX_PKI_CLX_START(block_id) (CVMX_ADD_IO_SEG(0x000118004400C030ull) + ((block_id) & 3) * 0x10000ull)
+#define CVMX_PKI_CLX_START(offset) (CVMX_ADD_IO_SEG(0x000118004400C030ull) + ((offset) & 3) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_CLX_STYLEX_ALG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_ALG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044501000ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -342,6 +360,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_ALG(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044500000ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -353,6 +372,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_CFG2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044500800ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -361,10 +381,65 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG2(unsigned long offset, unsigned l
 #define CVMX_PKI_CLX_STYLEX_CFG2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180044500800ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT0(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00000ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT0(offset) (CVMX_ADD_IO_SEG(0x0001180044C00000ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT1(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00008ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT1(offset) (CVMX_ADD_IO_SEG(0x0001180044C00008ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT2(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00010ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT2(offset) (CVMX_ADD_IO_SEG(0x0001180044C00010ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT3(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00018ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT3(offset) (CVMX_ADD_IO_SEG(0x0001180044C00018ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT4(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00020ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT4(offset) (CVMX_ADD_IO_SEG(0x0001180044C00020ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKI_ECC_CTL0 CVMX_PKI_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000060ull);
 }
@@ -375,7 +450,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL0_FUNC(void)
 #define CVMX_PKI_ECC_CTL1 CVMX_PKI_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000068ull);
 }
@@ -386,7 +461,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL1_FUNC(void)
 #define CVMX_PKI_ECC_CTL2 CVMX_PKI_ECC_CTL2_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000070ull);
 }
@@ -397,7 +472,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL2_FUNC(void)
 #define CVMX_PKI_ECC_INT0 CVMX_PKI_ECC_INT0_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000040ull);
 }
@@ -408,7 +483,7 @@ static inline uint64_t CVMX_PKI_ECC_INT0_FUNC(void)
 #define CVMX_PKI_ECC_INT1 CVMX_PKI_ECC_INT1_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000048ull);
 }
@@ -419,7 +494,7 @@ static inline uint64_t CVMX_PKI_ECC_INT1_FUNC(void)
 #define CVMX_PKI_ECC_INT2 CVMX_PKI_ECC_INT2_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000050ull);
 }
@@ -430,6 +505,7 @@ static inline uint64_t CVMX_PKI_ECC_INT2_FUNC(void)
 static inline uint64_t CVMX_PKI_FRM_LEN_CHKX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_FRM_LEN_CHKX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044004000ull) + ((offset) & 1) * 8;
@@ -441,7 +517,7 @@ static inline uint64_t CVMX_PKI_FRM_LEN_CHKX(unsigned long offset)
 #define CVMX_PKI_GBL_PEN CVMX_PKI_GBL_PEN_FUNC()
 static inline uint64_t CVMX_PKI_GBL_PEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_GBL_PEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000200ull);
 }
@@ -452,7 +528,7 @@ static inline uint64_t CVMX_PKI_GBL_PEN_FUNC(void)
 #define CVMX_PKI_GEN_INT CVMX_PKI_GEN_INT_FUNC()
 static inline uint64_t CVMX_PKI_GEN_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_GEN_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000020ull);
 }
@@ -463,6 +539,7 @@ static inline uint64_t CVMX_PKI_GEN_INT_FUNC(void)
 static inline uint64_t CVMX_PKI_ICGX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PKI_ICGX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118004400A000ull) + ((offset) & 3) * 8;
@@ -474,6 +551,7 @@ static inline uint64_t CVMX_PKI_ICGX_CFG(unsigned long offset)
 static inline uint64_t CVMX_PKI_IMEMX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_IMEMX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044100000ull) + ((offset) & 2047) * 8;
@@ -485,6 +563,7 @@ static inline uint64_t CVMX_PKI_IMEMX(unsigned long offset)
 static inline uint64_t CVMX_PKI_LTYPEX_MAP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_LTYPEX_MAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044005000ull) + ((offset) & 31) * 8;
@@ -493,10 +572,21 @@ static inline uint64_t CVMX_PKI_LTYPEX_MAP(unsigned long offset)
 #define CVMX_PKI_LTYPEX_MAP(offset) (CVMX_ADD_IO_SEG(0x0001180044005000ull) + ((offset) & 31) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PBE_ECO CVMX_PKI_PBE_ECO_FUNC()
+static inline uint64_t CVMX_PKI_PBE_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKI_PBE_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000710ull);
+}
+#else
+#define CVMX_PKI_PBE_ECO (CVMX_ADD_IO_SEG(0x0001180044000710ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKI_PCAM_LOOKUP CVMX_PKI_PCAM_LOOKUP_FUNC()
 static inline uint64_t CVMX_PKI_PCAM_LOOKUP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PCAM_LOOKUP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000500ull);
 }
@@ -507,7 +597,7 @@ static inline uint64_t CVMX_PKI_PCAM_LOOKUP_FUNC(void)
 #define CVMX_PKI_PCAM_RESULT CVMX_PKI_PCAM_RESULT_FUNC()
 static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PCAM_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000510ull);
 }
@@ -518,7 +608,7 @@ static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 #define CVMX_PKI_PFE_DIAG CVMX_PKI_PFE_DIAG_FUNC()
 static inline uint64_t CVMX_PKI_PFE_DIAG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PFE_DIAG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000560ull);
 }
@@ -526,10 +616,21 @@ static inline uint64_t CVMX_PKI_PFE_DIAG_FUNC(void)
 #define CVMX_PKI_PFE_DIAG (CVMX_ADD_IO_SEG(0x0001180044000560ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PFE_ECO CVMX_PKI_PFE_ECO_FUNC()
+static inline uint64_t CVMX_PKI_PFE_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKI_PFE_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000720ull);
+}
+#else
+#define CVMX_PKI_PFE_ECO (CVMX_ADD_IO_SEG(0x0001180044000720ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKI_PIX_CLKEN CVMX_PKI_PIX_CLKEN_FUNC()
 static inline uint64_t CVMX_PKI_PIX_CLKEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PIX_CLKEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000600ull);
 }
@@ -540,7 +641,7 @@ static inline uint64_t CVMX_PKI_PIX_CLKEN_FUNC(void)
 #define CVMX_PKI_PIX_DIAG CVMX_PKI_PIX_DIAG_FUNC()
 static inline uint64_t CVMX_PKI_PIX_DIAG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PIX_DIAG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000580ull);
 }
@@ -548,9 +649,21 @@ static inline uint64_t CVMX_PKI_PIX_DIAG_FUNC(void)
 #define CVMX_PKI_PIX_DIAG (CVMX_ADD_IO_SEG(0x0001180044000580ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PIX_ECO CVMX_PKI_PIX_ECO_FUNC()
+static inline uint64_t CVMX_PKI_PIX_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKI_PIX_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000700ull);
+}
+#else
+#define CVMX_PKI_PIX_ECO (CVMX_ADD_IO_SEG(0x0001180044000700ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_PKINDX_ICGSEL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKINDX_ICGSEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044010000ull) + ((offset) & 63) * 8;
@@ -562,6 +675,7 @@ static inline uint64_t CVMX_PKI_PKINDX_ICGSEL(unsigned long offset)
 static inline uint64_t CVMX_PKI_PKNDX_INB_STAT0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00000ull) + ((offset) & 63) * 256;
@@ -573,6 +687,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT0(unsigned long offset)
 static inline uint64_t CVMX_PKI_PKNDX_INB_STAT1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00008ull) + ((offset) & 63) * 256;
@@ -584,6 +699,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT1(unsigned long offset)
 static inline uint64_t CVMX_PKI_PKNDX_INB_STAT2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00010ull) + ((offset) & 63) * 256;
@@ -595,7 +711,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT2(unsigned long offset)
 #define CVMX_PKI_PKT_ERR CVMX_PKI_PKT_ERR_FUNC()
 static inline uint64_t CVMX_PKI_PKT_ERR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PKT_ERR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000030ull);
 }
@@ -603,9 +719,21 @@ static inline uint64_t CVMX_PKI_PKT_ERR_FUNC(void)
 #define CVMX_PKI_PKT_ERR (CVMX_ADD_IO_SEG(0x0001180044000030ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_QPG_TBLBX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047)))))
+		cvmx_warn("CVMX_PKI_QPG_TBLBX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044820000ull) + ((offset) & 2047) * 8;
+}
+#else
+#define CVMX_PKI_QPG_TBLBX(offset) (CVMX_ADD_IO_SEG(0x0001180044820000ull) + ((offset) & 2047) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_QPG_TBLX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_QPG_TBLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044800000ull) + ((offset) & 2047) * 8;
@@ -617,6 +745,7 @@ static inline uint64_t CVMX_PKI_QPG_TBLX(unsigned long offset)
 static inline uint64_t CVMX_PKI_REASM_SOPX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_REASM_SOPX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044006000ull) + ((offset) & 1) * 8;
@@ -628,7 +757,7 @@ static inline uint64_t CVMX_PKI_REASM_SOPX(unsigned long offset)
 #define CVMX_PKI_REQ_WGT CVMX_PKI_REQ_WGT_FUNC()
 static inline uint64_t CVMX_PKI_REQ_WGT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_REQ_WGT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000120ull);
 }
@@ -639,7 +768,7 @@ static inline uint64_t CVMX_PKI_REQ_WGT_FUNC(void)
 #define CVMX_PKI_SFT_RST CVMX_PKI_SFT_RST_FUNC()
 static inline uint64_t CVMX_PKI_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000010ull);
 }
@@ -650,6 +779,7 @@ static inline uint64_t CVMX_PKI_SFT_RST_FUNC(void)
 static inline uint64_t CVMX_PKI_STATX_HIST0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00000ull) + ((offset) & 63) * 256;
@@ -661,6 +791,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST0(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00008ull) + ((offset) & 63) * 256;
@@ -672,6 +803,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST1(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00010ull) + ((offset) & 63) * 256;
@@ -683,6 +815,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST2(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00018ull) + ((offset) & 63) * 256;
@@ -694,6 +827,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST3(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00020ull) + ((offset) & 63) * 256;
@@ -705,6 +839,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST4(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST5(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00028ull) + ((offset) & 63) * 256;
@@ -716,6 +851,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST5(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST6(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00030ull) + ((offset) & 63) * 256;
@@ -727,6 +863,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST6(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00038ull) + ((offset) & 63) * 256;
@@ -738,6 +875,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT0(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00040ull) + ((offset) & 63) * 256;
@@ -749,6 +887,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT1(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT10(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT10(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00088ull) + ((offset) & 63) * 256;
@@ -760,6 +899,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT10(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT11(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT11(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00090ull) + ((offset) & 63) * 256;
@@ -771,6 +911,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT11(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT12(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT12(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00098ull) + ((offset) & 63) * 256;
@@ -782,6 +923,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT12(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT13(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT13(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000A0ull) + ((offset) & 63) * 256;
@@ -793,6 +935,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT13(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT14(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT14(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000A8ull) + ((offset) & 63) * 256;
@@ -804,6 +947,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT14(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT15(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT15(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000B0ull) + ((offset) & 63) * 256;
@@ -815,6 +959,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT15(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT16(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT16(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000B8ull) + ((offset) & 63) * 256;
@@ -826,6 +971,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT16(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT17(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT17(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000C0ull) + ((offset) & 63) * 256;
@@ -837,6 +983,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT17(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT18(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT18(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000C8ull) + ((offset) & 63) * 256;
@@ -848,6 +995,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT18(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00048ull) + ((offset) & 63) * 256;
@@ -859,6 +1007,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT2(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00050ull) + ((offset) & 63) * 256;
@@ -870,6 +1019,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT3(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00058ull) + ((offset) & 63) * 256;
@@ -881,6 +1031,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT4(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT5(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00060ull) + ((offset) & 63) * 256;
@@ -892,6 +1043,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT5(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT6(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00068ull) + ((offset) & 63) * 256;
@@ -903,6 +1055,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT6(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT7(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00070ull) + ((offset) & 63) * 256;
@@ -914,6 +1067,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT7(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT8(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00078ull) + ((offset) & 63) * 256;
@@ -925,6 +1079,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT8(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT9(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT9(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00080ull) + ((offset) & 63) * 256;
@@ -936,7 +1091,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT9(unsigned long offset)
 #define CVMX_PKI_STAT_CTL CVMX_PKI_STAT_CTL_FUNC()
 static inline uint64_t CVMX_PKI_STAT_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_STAT_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000110ull);
 }
@@ -947,6 +1102,7 @@ static inline uint64_t CVMX_PKI_STAT_CTL_FUNC(void)
 static inline uint64_t CVMX_PKI_STYLEX_BUF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_BUF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044024000ull) + ((offset) & 63) * 8;
@@ -958,6 +1114,7 @@ static inline uint64_t CVMX_PKI_STYLEX_BUF(unsigned long offset)
 static inline uint64_t CVMX_PKI_STYLEX_TAG_MASK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_TAG_MASK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044021000ull) + ((offset) & 63) * 8;
@@ -969,6 +1126,7 @@ static inline uint64_t CVMX_PKI_STYLEX_TAG_MASK(unsigned long offset)
 static inline uint64_t CVMX_PKI_STYLEX_TAG_SEL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_TAG_SEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044020000ull) + ((offset) & 63) * 8;
@@ -980,6 +1138,7 @@ static inline uint64_t CVMX_PKI_STYLEX_TAG_SEL(unsigned long offset)
 static inline uint64_t CVMX_PKI_STYLEX_WQ2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_WQ2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044022000ull) + ((offset) & 63) * 8;
@@ -991,6 +1150,7 @@ static inline uint64_t CVMX_PKI_STYLEX_WQ2(unsigned long offset)
 static inline uint64_t CVMX_PKI_STYLEX_WQ4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_WQ4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044023000ull) + ((offset) & 63) * 8;
@@ -1002,6 +1162,7 @@ static inline uint64_t CVMX_PKI_STYLEX_WQ4(unsigned long offset)
 static inline uint64_t CVMX_PKI_TAG_INCX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_TAG_INCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044007000ull) + ((offset) & 31) * 8;
@@ -1013,6 +1174,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_CTL(unsigned long offset)
 static inline uint64_t CVMX_PKI_TAG_INCX_MASK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_TAG_INCX_MASK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044008000ull) + ((offset) & 31) * 8;
@@ -1024,7 +1186,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_MASK(unsigned long offset)
 #define CVMX_PKI_TAG_SECRET CVMX_PKI_TAG_SECRET_FUNC()
 static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_TAG_SECRET not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000430ull);
 }
@@ -1035,7 +1197,7 @@ static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 #define CVMX_PKI_X2P_REQ_OFL CVMX_PKI_X2P_REQ_OFL_FUNC()
 static inline uint64_t CVMX_PKI_X2P_REQ_OFL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_X2P_REQ_OFL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000038ull);
 }
@@ -1057,6 +1219,7 @@ union cvmx_pki_active0 {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pki_active0_s             cn73xx;
 	struct cvmx_pki_active0_s             cn78xx;
 };
 typedef union cvmx_pki_active0 cvmx_pki_active0_t;
@@ -1081,6 +1244,7 @@ union cvmx_pki_active1 {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pki_active1_s             cn73xx;
 	struct cvmx_pki_active1_s             cn78xx;
 };
 typedef union cvmx_pki_active1 cvmx_pki_active1_t;
@@ -1099,6 +1263,7 @@ union cvmx_pki_active2 {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_pki_active2_s             cn73xx;
 	struct cvmx_pki_active2_s             cn78xx;
 };
 typedef union cvmx_pki_active2 cvmx_pki_active2_t;
@@ -1140,6 +1305,7 @@ union cvmx_pki_aurax_cfg {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_aurax_cfg_s           cn73xx;
 	struct cvmx_pki_aurax_cfg_s           cn78xx;
 };
 typedef union cvmx_pki_aurax_cfg cvmx_pki_aurax_cfg_t;
@@ -1175,6 +1341,7 @@ union cvmx_pki_bist_status0 {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_pki_bist_status0_s        cn73xx;
 	struct cvmx_pki_bist_status0_s        cn78xx;
 };
 typedef union cvmx_pki_bist_status0 cvmx_pki_bist_status0_t;
@@ -1189,6 +1356,35 @@ union cvmx_pki_bist_status1 {
 	uint64_t u64;
 	struct cvmx_pki_bist_status1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_26_63               : 38;
+	uint64_t bist                         : 26; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
+                                                         register collects status for PKI_PBE.
+                                                         <20> = STATS_MEM0.
+                                                         <19> = STATS_MEM1.
+                                                         <18> = STATS_MEM2.
+                                                         <17> = STATS_MEM3.
+                                                         <16> = SWS.
+                                                         <15> = WQEOUT.
+                                                         <14> = DOA.
+                                                         <13> = BPID.
+                                                         <12 =10> = Reserved.
+                                                         <9> = PLC.
+                                                         <8> = PKTWQ.
+                                                         <7 =6> = Reserved.
+                                                         <5> = TAG.
+                                                         <4> = AURA.
+                                                         <3> = CHAN.
+                                                         <2> = PBTAG.
+                                                         <1> = STYLEWQ.
+                                                         <0> = QPG. */
+#else
+	uint64_t bist                         : 26;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} s;
+	struct cvmx_pki_bist_status1_s        cn73xx;
+	struct cvmx_pki_bist_status1_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_21_63               : 43;
 	uint64_t bist                         : 21; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
                                                          register collects status for PKI_PBE.
@@ -1214,8 +1410,7 @@ union cvmx_pki_bist_status1 {
 	uint64_t bist                         : 21;
 	uint64_t reserved_21_63               : 43;
 #endif
-	} s;
-	struct cvmx_pki_bist_status1_s        cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pki_bist_status1 cvmx_pki_bist_status1_t;
 
@@ -1250,6 +1445,7 @@ union cvmx_pki_bist_status2 {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pki_bist_status2_s        cn73xx;
 	struct cvmx_pki_bist_status2_s        cn78xx;
 };
 typedef union cvmx_pki_bist_status2 cvmx_pki_bist_status2_t;
@@ -1271,6 +1467,7 @@ union cvmx_pki_bpidx_state {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pki_bpidx_state_s         cn73xx;
 	struct cvmx_pki_bpidx_state_s         cn78xx;
 };
 typedef union cvmx_pki_bpidx_state cvmx_pki_bpidx_state_t;
@@ -1315,6 +1512,7 @@ union cvmx_pki_buf_ctl {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_pki_buf_ctl_s             cn73xx;
 	struct cvmx_pki_buf_ctl_s             cn78xx;
 };
 typedef union cvmx_pki_buf_ctl cvmx_pki_buf_ctl_t;
@@ -1345,6 +1543,7 @@ union cvmx_pki_chanx_cfg {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_pki_chanx_cfg_s           cn73xx;
 	struct cvmx_pki_chanx_cfg_s           cn78xx;
 };
 typedef union cvmx_pki_chanx_cfg cvmx_pki_chanx_cfg_t;
@@ -1368,8 +1567,8 @@ union cvmx_pki_clx_ecc_ctl {
 	uint64_t pcam1_cdis                   : 1;  /**< PCAM1 ECC correction disable. */
 	uint64_t pcam0_cdis                   : 1;  /**< PCAM0 ECC correction disable. */
 	uint64_t smem_cdis                    : 1;  /**< SMEM ECC correction disable. */
-	uint64_t dmem_cdis                    : 1;  /**< DMEM parity poising disable. */
-	uint64_t rf_cdis                      : 1;  /**< RF RAM parity poising disable. */
+	uint64_t dmem_cdis                    : 1;  /**< DMEM parity poisoning disable. */
+	uint64_t rf_cdis                      : 1;  /**< RF RAM parity poisoning disable. */
 #else
 	uint64_t rf_cdis                      : 1;
 	uint64_t dmem_cdis                    : 1;
@@ -1386,6 +1585,7 @@ union cvmx_pki_clx_ecc_ctl {
 	uint64_t pcam_en                      : 1;
 #endif
 	} s;
+	struct cvmx_pki_clx_ecc_ctl_s         cn73xx;
 	struct cvmx_pki_clx_ecc_ctl_s         cn78xx;
 };
 typedef union cvmx_pki_clx_ecc_ctl cvmx_pki_clx_ecc_ctl_t;
@@ -1402,8 +1602,10 @@ union cvmx_pki_clx_ecc_int {
 	uint64_t pcam1_sbe                    : 1;  /**< PCAM1 ECC single bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_PCAM1_SBE. */
 	uint64_t pcam0_dbe                    : 1;  /**< PCAM0 ECC double bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_PCAM0_DBE. */
 	uint64_t pcam0_sbe                    : 1;  /**< PCAM0 ECC single bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_PCAM0_SBE. */
-	uint64_t smem_dbe                     : 1;  /**< SMEM ECC double bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_SMEM_DBE. */
-	uint64_t smem_sbe                     : 1;  /**< SMEM ECC single bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_SMEM_SBE. */
+	uint64_t smem_dbe                     : 1;  /**< SMEM ECC double bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_SMEM_DBE. If
+                                                         SMEM_DBE is thrown, software may scrub the error by reloading PKI_CL()_SMEM(). */
+	uint64_t smem_sbe                     : 1;  /**< SMEM ECC single bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_SMEM_SBE. If
+                                                         SMEM_SBE is thrown, software may scrub the error by reloading PKI_CL()_SMEM(). */
 	uint64_t dmem_perr                    : 1;  /**< DMEM parity error. Throws PKI_INTSN_E::PKI_CL()_ECC_DMEM_PERR. */
 	uint64_t rf_perr                      : 1;  /**< RF RAM parity error. Throws PKI_INTSN_E::PKI_CL()_ECC_RF_PERR. */
 #else
@@ -1418,6 +1620,7 @@ union cvmx_pki_clx_ecc_int {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_pki_clx_ecc_int_s         cn73xx;
 	struct cvmx_pki_clx_ecc_int_s         cn78xx;
 };
 typedef union cvmx_pki_clx_ecc_int cvmx_pki_clx_ecc_int_t;
@@ -1447,6 +1650,7 @@ union cvmx_pki_clx_int {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pki_clx_int_s             cn73xx;
 	struct cvmx_pki_clx_int_s             cn78xx;
 };
 typedef union cvmx_pki_clx_int cvmx_pki_clx_int_t;
@@ -1519,6 +1723,7 @@ union cvmx_pki_clx_pcamx_actionx {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_pki_clx_pcamx_actionx_s   cn73xx;
 	struct cvmx_pki_clx_pcamx_actionx_s   cn78xx;
 };
 typedef union cvmx_pki_clx_pcamx_actionx cvmx_pki_clx_pcamx_actionx_t;
@@ -1544,6 +1749,7 @@ union cvmx_pki_clx_pcamx_matchx {
 	uint64_t data1                        : 32;
 #endif
 	} s;
+	struct cvmx_pki_clx_pcamx_matchx_s    cn73xx;
 	struct cvmx_pki_clx_pcamx_matchx_s    cn78xx;
 };
 typedef union cvmx_pki_clx_pcamx_matchx cvmx_pki_clx_pcamx_matchx_t;
@@ -1584,6 +1790,7 @@ union cvmx_pki_clx_pcamx_termx {
 	uint64_t valid                        : 1;
 #endif
 	} s;
+	struct cvmx_pki_clx_pcamx_termx_s     cn73xx;
 	struct cvmx_pki_clx_pcamx_termx_s     cn78xx;
 };
 typedef union cvmx_pki_clx_pcamx_termx cvmx_pki_clx_pcamx_termx_t;
@@ -1637,6 +1844,7 @@ union cvmx_pki_clx_pkindx_cfg {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_cfg_s      cn73xx;
 	struct cvmx_pki_clx_pkindx_cfg_s      cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_cfg cvmx_pki_clx_pkindx_cfg_t;
@@ -1644,11 +1852,28 @@ typedef union cvmx_pki_clx_pkindx_cfg cvmx_pki_clx_pkindx_cfg_t;
 /**
  * cvmx_pki_cl#_pkind#_kmem#
  *
- * The register initialization value for each PKIND and register number (plus 32 or 48 based on
+ * A convenient alias block for the following registers:
+ * * PKI_CL()_PKIND()_CFG
+ * * PKI_CL()_PKIND()_STYLE
+ * * PKI_CL()_PKIND()_SKIP
+ * * PKI_CL()_PKIND()_L2_CUSTOM
+ * * PKI_CL()_PKIND()_LG_CUSTOM
+ *
+ * The PKI_CL(0..1)_PKIND* registers listed above are the preferred access method.
+ *
+ * Software should reload the PKI_CL()_PKIND()_KMEM() registers upon the
+ * detection of KMEM_SBE or KMEM_DBE.
+ *
+ * INTERNAL: The register initialization value for each PKIND and register number (plus 32 or 48
+ * based on
  * PKI_ICG()_CFG[MLO]). The other PKI_PKND* registers alias inside regions of
  * PKI_CL()_PKIND()_KMEM(). To avoid confusing tools, these aliases have address
  * bit 20 set; the PKI address decoder ignores bit 20 when accessing
  * PKI_CL()_PKIND()_KMEM().
+ *
+ * In terms of ECC processing, PFE will unload the entire PKND KMEM register set
+ * potentially introducing an ECC error from an unaliased register.  Therefore the
+ * entire KMEM must be exposed to software to be scrubbed in such an event.
  */
 union cvmx_pki_clx_pkindx_kmemx {
 	uint64_t u64;
@@ -1661,6 +1886,7 @@ union cvmx_pki_clx_pkindx_kmemx {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_kmemx_s    cn73xx;
 	struct cvmx_pki_clx_pkindx_kmemx_s    cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_kmemx cvmx_pki_clx_pkindx_kmemx_t;
@@ -1688,6 +1914,7 @@ union cvmx_pki_clx_pkindx_l2_custom {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_l2_custom_s cn73xx;
 	struct cvmx_pki_clx_pkindx_l2_custom_s cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_l2_custom cvmx_pki_clx_pkindx_l2_custom_t;
@@ -1707,6 +1934,7 @@ union cvmx_pki_clx_pkindx_lg_custom {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_lg_custom_s cn73xx;
 	struct cvmx_pki_clx_pkindx_lg_custom_s cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_lg_custom cvmx_pki_clx_pkindx_lg_custom_t;
@@ -1733,6 +1961,7 @@ union cvmx_pki_clx_pkindx_skip {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_skip_s     cn73xx;
 	struct cvmx_pki_clx_pkindx_skip_s     cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_skip cvmx_pki_clx_pkindx_skip_t;
@@ -1769,6 +1998,7 @@ union cvmx_pki_clx_pkindx_style {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_style_s    cn73xx;
 	struct cvmx_pki_clx_pkindx_style_s    cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_style cvmx_pki_clx_pkindx_style_t;
@@ -1776,9 +2006,23 @@ typedef union cvmx_pki_clx_pkindx_style cvmx_pki_clx_pkindx_style_t;
 /**
  * cvmx_pki_cl#_smem#
  *
- * PKI_STYLE* registers alias inside regions of PKI_CL()_SMEM(). To avoid confusing
+ * A convenient alias block for the following registers:
+ * * PKI_CL()_STYLE()_CFG
+ * * PKI_CL()_STYLE()_CFG2
+ * * PKI_CL()_STYLE()_ALG
+ *
+ * The PKI_CL(0..1)_STYLE* registers listed above are the preferred access method.
+ *
+ * Software should reload the PKI_CL()_SMEM() registers upon the
+ * detection of SMEM_SBE or SMEM_DBE.
+ *
+ * INTERNAL: PKI_STYLE* registers alias inside regions of PKI_CL()_SMEM(). To avoid confusing
  * tools, these aliases have address bit 20 set; the PKI address decoder ignores bit 20 when
  * accessing PKI_CL()_SMEM().
+ *
+ * In terms of ECC processing, ucode will only touch SMEM registers based on the
+ * program so we can limit which SMEM addresses are actually used.  ECC faults to
+ * unused entries will not create a problem but we will expose for symmetry.
  */
 union cvmx_pki_clx_smemx {
 	uint64_t u64;
@@ -1791,6 +2035,7 @@ union cvmx_pki_clx_smemx {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_clx_smemx_s           cn73xx;
 	struct cvmx_pki_clx_smemx_s           cn78xx;
 };
 typedef union cvmx_pki_clx_smemx cvmx_pki_clx_smemx_t;
@@ -1809,6 +2054,7 @@ union cvmx_pki_clx_start {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_pki_clx_start_s           cn73xx;
 	struct cvmx_pki_clx_start_s           cn78xx;
 };
 typedef union cvmx_pki_clx_start cvmx_pki_clx_start_t;
@@ -1831,7 +2077,7 @@ union cvmx_pki_clx_stylex_alg {
                                                          8 = Include port<7:0>.
                                                          else Reserved. */
 	uint64_t reserved_11_16               : 6;
-	uint64_t tag_vni                      : 1;  /**< When VXLAN is found, include VNI in tag generation. When NVGRE is found, include TNI. */
+	uint64_t tag_vni                      : 1;  /**< When NVGRE/VXLAN/GENEVE is found, include VNI in tag generation. When NVGRE is found, include TNI. */
 	uint64_t tag_gtp                      : 1;  /**< When GTP is parsed, include GTP's TEID in tag generation. */
 	uint64_t tag_spi                      : 1;  /**< Include AH/GRE in tag generation.
                                                          0 = Exclude AH/GRE in tag generation.
@@ -1870,6 +2116,7 @@ union cvmx_pki_clx_stylex_alg {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_clx_stylex_alg_s      cn73xx;
 	struct cvmx_pki_clx_stylex_alg_s      cn78xx;
 };
 typedef union cvmx_pki_clx_stylex_alg cvmx_pki_clx_stylex_alg_t;
@@ -1942,6 +2189,7 @@ union cvmx_pki_clx_stylex_cfg {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_pki_clx_stylex_cfg_s      cn73xx;
 	struct cvmx_pki_clx_stylex_cfg_s      cn78xx;
 };
 typedef union cvmx_pki_clx_stylex_cfg cvmx_pki_clx_stylex_cfg_t;
@@ -2017,6 +2265,7 @@ union cvmx_pki_clx_stylex_cfg2 {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_clx_stylex_cfg2_s     cn73xx;
 	struct cvmx_pki_clx_stylex_cfg2_s     cn78xx;
 };
 typedef union cvmx_pki_clx_stylex_cfg2 cvmx_pki_clx_stylex_cfg2_t;
@@ -2037,11 +2286,125 @@ union cvmx_pki_clken {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pki_clken_s               cn73xx;
 	struct cvmx_pki_clken_s               cn78xx;
 };
 typedef union cvmx_pki_clken cvmx_pki_clken_t;
 
 /**
+ * cvmx_pki_dstat#_stat0
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat0 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t pkts                         : 32; /**< Number of non-dropped packets processed by PKI.
+                                                         The corresponding wide statistic is PKI_STAT()_STAT0. */
+#else
+	uint64_t pkts                         : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat0_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat0 cvmx_pki_dstatx_stat0_t;
+
+/**
+ * cvmx_pki_dstat#_stat1
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat1 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t octs                         : 40; /**< Number of non-dropped octets received by PKI (good and bad).
+                                                         The corresponding wide statistic is PKI_STAT()_STAT1. */
+#else
+	uint64_t octs                         : 40;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat1_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat1 cvmx_pki_dstatx_stat1_t;
+
+/**
+ * cvmx_pki_dstat#_stat2
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat2 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t err_pkts                     : 32; /**< Number of packets with errors, including length < minimum, length > maximum, FCS
+                                                         errors, or WQE[ERRLEV]==RE or L2.
+                                                         This corresponds to a sum across the wide statistics PKI_STAT()_STAT7, PKI_STAT()_STAT7,
+                                                         PKI_STAT()_STAT8, PKI_STAT()_STAT9, PKI_STAT()_STAT10, PKI_STAT()_STAT11, and
+                                                         PKI_STAT()_STAT12. */
+#else
+	uint64_t err_pkts                     : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat2_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat2 cvmx_pki_dstatx_stat2_t;
+
+/**
+ * cvmx_pki_dstat#_stat3
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat3 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t drp_pkts                     : 32; /**< Inbound packets dropped by RED, buffer exhaustion, or PKI_CL()_STYLE()_CFG[DROP].
+                                                         The corresponding wide statistic is PKI_STAT()_STAT3. */
+#else
+	uint64_t drp_pkts                     : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat3_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat3 cvmx_pki_dstatx_stat3_t;
+
+/**
+ * cvmx_pki_dstat#_stat4
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat4 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat4_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t drp_octs                     : 40; /**< Inbound octets dropped by RED, buffer exhaustion, or PKI_CL()_STYLE()_CFG[DROP].
+                                                         The corresponding wide statistic is PKI_STAT()_STAT4. */
+#else
+	uint64_t drp_octs                     : 40;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat4_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat4 cvmx_pki_dstatx_stat4_t;
+
+/**
  * cvmx_pki_ecc_ctl0
  *
  * This register allows inserting ECC errors for testing.
@@ -2096,6 +2459,7 @@ union cvmx_pki_ecc_ctl0 {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_pki_ecc_ctl0_s            cn73xx;
 	struct cvmx_pki_ecc_ctl0_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_ctl0 cvmx_pki_ecc_ctl0_t;
@@ -2167,6 +2531,7 @@ union cvmx_pki_ecc_ctl1 {
 	uint64_t reserved_51_63               : 13;
 #endif
 	} s;
+	struct cvmx_pki_ecc_ctl1_s            cn73xx;
 	struct cvmx_pki_ecc_ctl1_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_ctl1 cvmx_pki_ecc_ctl1_t;
@@ -2191,6 +2556,7 @@ union cvmx_pki_ecc_ctl2 {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_pki_ecc_ctl2_s            cn73xx;
 	struct cvmx_pki_ecc_ctl2_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_ctl2 cvmx_pki_ecc_ctl2_t;
@@ -2215,8 +2581,10 @@ union cvmx_pki_ecc_int0 {
 	uint64_t curptag_sbe                  : 1;  /**< CURPTAG ECC single bit error. Throws PKI_INTSN_E::PKI_ECC0_CURPTAG_SBE. */
 	uint64_t nxtblk_dbe                   : 1;  /**< NXTBLK ECC double bit error. Throws PKI_INTSN_E::PKI_ECC0_NXTBLK_DBE. */
 	uint64_t nxtblk_sbe                   : 1;  /**< NXTBLK ECC single bit error. Throws PKI_INTSN_E::PKI_ECC0_NXTBLK_SBE. */
-	uint64_t kmem_dbe                     : 1;  /**< KMEM ECC double bit error. Throws PKI_INTSN_E::PKI_ECC0_KMEM_DBE. */
-	uint64_t kmem_sbe                     : 1;  /**< KMEM ECC single bit error. Throws PKI_INTSN_E::PKI_ECC0_KMEM_SBE. */
+	uint64_t kmem_dbe                     : 1;  /**< KMEM ECC double bit error. Throws PKI_INTSN_E::PKI_ECC0_KMEM_DBE. If KMEM_DBE is
+                                                         thrown, software may scrub the error by reloading PKI_CL()_PKIND()_KMEM(). */
+	uint64_t kmem_sbe                     : 1;  /**< KMEM ECC single bit error. Throws PKI_INTSN_E::PKI_ECC0_KMEM_SBE. If KMEM_SBE is
+                                                         thrown, software may scrub the error by reloading PKI_CL()_PKIND()_KMEM(). */
 	uint64_t asm_dbe                      : 1;  /**< ASM ECC double bit error. Throws PKI_INTSN_E::PKI_ECC0_ASM_DBE. */
 	uint64_t asm_sbe                      : 1;  /**< ASM ECC single bit error. Throws PKI_INTSN_E::PKI_ECC0_ASM_SBE. */
 #else
@@ -2239,6 +2607,7 @@ union cvmx_pki_ecc_int0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_ecc_int0_s            cn73xx;
 	struct cvmx_pki_ecc_int0_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_int0 cvmx_pki_ecc_int0_t;
@@ -2307,6 +2676,7 @@ union cvmx_pki_ecc_int1 {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_pki_ecc_int1_s            cn73xx;
 	struct cvmx_pki_ecc_int1_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_int1 cvmx_pki_ecc_int1_t;
@@ -2319,14 +2689,17 @@ union cvmx_pki_ecc_int2 {
 	struct cvmx_pki_ecc_int2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t imem_dbe                     : 1;  /**< IMEM ECC double bit error. Throws PKI_INTSN_E::PKI_ECC2_IMEM_DBE. */
-	uint64_t imem_sbe                     : 1;  /**< IMEM ECC single bit error. Throws PKI_INTSN_E::PKI_ECC2_IMEM_SBE. */
+	uint64_t imem_dbe                     : 1;  /**< IMEM ECC double bit error. Throws PKI_INTSN_E::PKI_ECC2_IMEM_DBE. If IMEM_DBE is
+                                                         thrown, software may scrub the error by reloading PKI_IMEM(). */
+	uint64_t imem_sbe                     : 1;  /**< IMEM ECC single bit error. Throws PKI_INTSN_E::PKI_ECC2_IMEM_SBE. If IMEM_SBE is
+                                                         thrown, software may scrub the error by reloading PKI_IMEM(). */
 #else
 	uint64_t imem_sbe                     : 1;
 	uint64_t imem_dbe                     : 1;
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pki_ecc_int2_s            cn73xx;
 	struct cvmx_pki_ecc_int2_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_int2 cvmx_pki_ecc_int2_t;
@@ -2347,6 +2720,7 @@ union cvmx_pki_frm_len_chkx {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_frm_len_chkx_s        cn73xx;
 	struct cvmx_pki_frm_len_chkx_s        cn78xx;
 };
 typedef union cvmx_pki_frm_len_chkx cvmx_pki_frm_len_chkx_t;
@@ -2360,9 +2734,9 @@ union cvmx_pki_gbl_pen {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t virt_pen                     : 1;  /**< Virtualization parsing enable.
-                                                         0 = VXLAN/NVGRE is never used in any style. This enables internal power and latency
-                                                         reductions.
-                                                         1 = VXLAN/NVGRE parsing may be used. */
+                                                         0 = VXLAN/NVGRE/GENEVE is never used in any style. This enables internal power
+                                                         and latency reductions.
+                                                         1 = VXLAN/NVGRE/GENEVE parsing may be used. */
 	uint64_t clg_pen                      : 1;  /**< Custom LG parsing enable.
                                                          0 = Custom LG is never used in any style; i.e. PKI_CL()_PKIND()_CFG[LG_CUSTOM] is
                                                          zero for all indices. This enables internal power and latency reductions.
@@ -2414,6 +2788,7 @@ union cvmx_pki_gbl_pen {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_pki_gbl_pen_s             cn73xx;
 	struct cvmx_pki_gbl_pen_s             cn78xx;
 };
 typedef union cvmx_pki_gbl_pen cvmx_pki_gbl_pen_t;
@@ -2425,6 +2800,49 @@ union cvmx_pki_gen_int {
 	uint64_t u64;
 	struct cvmx_pki_gen_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t bufs_oflow                   : 1;  /**< Set when PKI receives a packet that exceeds 256 buffers.
+                                                         Throws PKI_INTSN_E::PKI_GEN_BUFS_OFLOW. */
+	uint64_t pkt_size_oflow               : 1;  /**< Set when PKI receives a packet that exceeds 64 KB.
+                                                         Throws PKI_INTSN_E::PKI_GEN_PKT_SIZE_OFLOW. */
+	uint64_t x2p_req_ofl                  : 1;  /**< Set when a device attempts to have more than the allocated requests outstanding to PKI.
+                                                         Throws PKI_INTSN_E::PKI_GEN_X2P_REQ_OFL. */
+	uint64_t drp_noavail                  : 1;  /**< Set when packet dropped due to no FPA pointers available for the aura the packet
+                                                         requested. Throws PKI_INTSN_E::PKI_GEN_DRP_NOAVAIL. */
+	uint64_t dat                          : 1;  /**< Set when data arrives before a SOP for the same reasm-id for a packet. The first detected
+                                                         error associated with bits [DAT,SOP,EOP] of this register is only set here. A new bit can
+                                                         be set when the previous reported bit is cleared. Throws PKI_INTSN_E::PKI_GEN_DAT. */
+	uint64_t eop                          : 1;  /**< Set when an EOP is followed by an EOP for the same reasm-id for a packet. The first
+                                                         detected error associated with bits [DAT,EOP,SOP] of this register is only set here. A new
+                                                         bit can be set when the previous reported bit is cleared. Also see PKI_PKT_ERR. Throws
+                                                         PKI_INTSN_E::PKI_GEN_EOP. */
+	uint64_t sop                          : 1;  /**< Set when a SOP is followed by an SOP for the same reasm-id for a packet. The first
+                                                         detected error associated with bits [DAT,EOP,SOP] of this register is only set here. A new
+                                                         bit can be set when the previous reported bit is cleared. Also see PKI_PKT_ERR. Throws
+                                                         PKI_INTSN_E::PKI_GEN_SOP. */
+	uint64_t bckprs                       : 1;  /**< PKI asserted backpressure. Set when PKI was unable to accept the next valid data from
+                                                         BGX/DPI/ILK etc. over X2P due to all internal resources being used up, and PKI will
+                                                         backpressure X2P. Throws PKI_INTSN_E::PKI_GEN_BCKPRS. */
+	uint64_t crcerr                       : 1;  /**< PKI calculated bad CRC in the L2 frame. Throws PKI_INTSN_E::PKI_GEN_CRCERR. */
+	uint64_t pktdrp                       : 1;  /**< Packet dropped due to QOS. If the QOS algorithm decides to drop a packet, PKI asserts this
+                                                         interrupt. Throws PKI_INTSN_E::PKI_GEN_PKTDRP. */
+#else
+	uint64_t pktdrp                       : 1;
+	uint64_t crcerr                       : 1;
+	uint64_t bckprs                       : 1;
+	uint64_t sop                          : 1;
+	uint64_t eop                          : 1;
+	uint64_t dat                          : 1;
+	uint64_t drp_noavail                  : 1;
+	uint64_t x2p_req_ofl                  : 1;
+	uint64_t pkt_size_oflow               : 1;
+	uint64_t bufs_oflow                   : 1;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_pki_gen_int_s             cn73xx;
+	struct cvmx_pki_gen_int_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t x2p_req_ofl                  : 1;  /**< Set when a device attempts to have more than the allocated requests outstanding to PKI.
                                                          Throws PKI_INTSN_E::PKI_GEN_X2P_REQ_OFL. */
@@ -2458,8 +2876,7 @@ union cvmx_pki_gen_int {
 	uint64_t x2p_req_ofl                  : 1;
 	uint64_t reserved_8_63                : 56;
 #endif
-	} s;
-	struct cvmx_pki_gen_int_s             cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pki_gen_int cvmx_pki_gen_int_t;
 
@@ -2467,7 +2884,7 @@ typedef union cvmx_pki_gen_int cvmx_pki_gen_int_t;
  * cvmx_pki_icg#_cfg
  *
  * Configures a cluster group.
- *
+ * INTERNAL: Only document a ICG(0..0)
  */
 union cvmx_pki_icgx_cfg {
 	uint64_t u64;
@@ -2481,7 +2898,7 @@ union cvmx_pki_icgx_cfg {
 	uint64_t reserved_36_47               : 12;
 	uint64_t clusters                     : 4;  /**< Bit-mask of clusters in this cluster group. A given cluster can only be enabled in a
                                                          single cluster group. Behavior is undefined for an ICG which receives traffic with a
-                                                         [CLUSTERS] of 0x0. IGC(0)'s entry resets to 0xF, all other entries to 0x0. */
+                                                         [CLUSTERS] of 0x0. ICG(0)'s entry resets to 0xF, all other entries to 0x0. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t release_rqd                  : 1;  /**< Release required. For diagnostic use only. INTERNAL:
                                                          0 = Release of r64 to r95 will occur immediately, no release microop is needed.
@@ -2517,6 +2934,7 @@ union cvmx_pki_icgx_cfg {
 	uint64_t reserved_53_63               : 11;
 #endif
 	} s;
+	struct cvmx_pki_icgx_cfg_s            cn73xx;
 	struct cvmx_pki_icgx_cfg_s            cn78xx;
 };
 typedef union cvmx_pki_icgx_cfg cvmx_pki_icgx_cfg_t;
@@ -2528,11 +2946,13 @@ union cvmx_pki_imemx {
 	uint64_t u64;
 	struct cvmx_pki_imemx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t data                         : 64; /**< Instruction word at given address. */
+	uint64_t data                         : 64; /**< Instruction word at given address. Software should reload PKI_IMEM() upon the
+                                                         detection of IMEM_SBE or IMEM_DBE errors. */
 #else
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_pki_imemx_s               cn73xx;
 	struct cvmx_pki_imemx_s               cn78xx;
 };
 typedef union cvmx_pki_imemx cvmx_pki_imemx_t;
@@ -2553,11 +2973,30 @@ union cvmx_pki_ltypex_map {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_pki_ltypex_map_s          cn73xx;
 	struct cvmx_pki_ltypex_map_s          cn78xx;
 };
 typedef union cvmx_pki_ltypex_map cvmx_pki_ltypex_map_t;
 
 /**
+ * cvmx_pki_pbe_eco
+ */
+union cvmx_pki_pbe_eco {
+	uint64_t u64;
+	struct cvmx_pki_pbe_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_pbe_eco_s             cn73xx;
+};
+typedef union cvmx_pki_pbe_eco cvmx_pki_pbe_eco_t;
+
+/**
  * cvmx_pki_pcam_lookup
  *
  * For diagnostic use only, perform a PCAM lookup against the provided cluster and PCAM instance
@@ -2584,6 +3023,7 @@ union cvmx_pki_pcam_lookup {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
+	struct cvmx_pki_pcam_lookup_s         cn73xx;
 	struct cvmx_pki_pcam_lookup_s         cn78xx;
 };
 typedef union cvmx_pki_pcam_lookup cvmx_pki_pcam_lookup_t;
@@ -2607,7 +3047,7 @@ union cvmx_pki_pcam_result {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
-	struct cvmx_pki_pcam_result_cn78xx {
+	struct cvmx_pki_pcam_result_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t conflict                     : 1;  /**< Conflict. The lookup resulted in multiple entries matching PKI_PCAM_LOOKUP[DATA], [TERM]
                                                          and [STYLE], or zero if no conflict. */
@@ -2623,7 +3063,8 @@ union cvmx_pki_pcam_result {
 	uint64_t reserved_41_62               : 22;
 	uint64_t conflict                     : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pki_pcam_result_cn73xx    cn78xx;
 };
 typedef union cvmx_pki_pcam_result cvmx_pki_pcam_result_t;
 
@@ -2641,11 +3082,30 @@ union cvmx_pki_pfe_diag {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pki_pfe_diag_s            cn73xx;
 	struct cvmx_pki_pfe_diag_s            cn78xx;
 };
 typedef union cvmx_pki_pfe_diag cvmx_pki_pfe_diag_t;
 
 /**
+ * cvmx_pki_pfe_eco
+ */
+union cvmx_pki_pfe_eco {
+	uint64_t u64;
+	struct cvmx_pki_pfe_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_pfe_eco_s             cn73xx;
+};
+typedef union cvmx_pki_pfe_eco cvmx_pki_pfe_eco_t;
+
+/**
  * cvmx_pki_pix_clken
  */
 union cvmx_pki_pix_clken {
@@ -2663,6 +3123,7 @@ union cvmx_pki_pix_clken {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_pki_pix_clken_s           cn73xx;
 	struct cvmx_pki_pix_clken_s           cn78xx;
 };
 typedef union cvmx_pki_pix_clken cvmx_pki_pix_clken_t;
@@ -2681,11 +3142,30 @@ union cvmx_pki_pix_diag {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pki_pix_diag_s            cn73xx;
 	struct cvmx_pki_pix_diag_s            cn78xx;
 };
 typedef union cvmx_pki_pix_diag cvmx_pki_pix_diag_t;
 
 /**
+ * cvmx_pki_pix_eco
+ */
+union cvmx_pki_pix_eco {
+	uint64_t u64;
+	struct cvmx_pki_pix_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_pix_eco_s             cn73xx;
+};
+typedef union cvmx_pki_pix_eco cvmx_pki_pix_eco_t;
+
+/**
  * cvmx_pki_pkind#_icgsel
  */
 union cvmx_pki_pkindx_icgsel {
@@ -2700,6 +3180,7 @@ union cvmx_pki_pkindx_icgsel {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pki_pkindx_icgsel_s       cn73xx;
 	struct cvmx_pki_pkindx_icgsel_s       cn78xx;
 };
 typedef union cvmx_pki_pkindx_icgsel cvmx_pki_pkindx_icgsel_t;
@@ -2721,6 +3202,7 @@ union cvmx_pki_pkndx_inb_stat0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_pkndx_inb_stat0_s     cn73xx;
 	struct cvmx_pki_pkndx_inb_stat0_s     cn78xx;
 };
 typedef union cvmx_pki_pkndx_inb_stat0 cvmx_pki_pkndx_inb_stat0_t;
@@ -2742,6 +3224,7 @@ union cvmx_pki_pkndx_inb_stat1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_pkndx_inb_stat1_s     cn73xx;
 	struct cvmx_pki_pkndx_inb_stat1_s     cn78xx;
 };
 typedef union cvmx_pki_pkndx_inb_stat1 cvmx_pki_pkndx_inb_stat1_t;
@@ -2763,6 +3246,7 @@ union cvmx_pki_pkndx_inb_stat2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_pkndx_inb_stat2_s     cn73xx;
 	struct cvmx_pki_pkndx_inb_stat2_s     cn78xx;
 };
 typedef union cvmx_pki_pkndx_inb_stat2 cvmx_pki_pkndx_inb_stat2_t;
@@ -2782,6 +3266,7 @@ union cvmx_pki_pkt_err {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_pki_pkt_err_s             cn73xx;
 	struct cvmx_pki_pkt_err_s             cn78xx;
 };
 typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
@@ -2791,7 +3276,8 @@ typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
  *
  * The QPG table is used to indirectly calculate the Portadd/Aura/Group from the Diffsrv, HiGig
  * or VLAN information as described in QPG.
- * See also PKI_QPG_TBL2().
+ * See also PKI_QPG_TBLB().
+ * INTERNAL: This register is outside SMEM due to opcode detection.
  */
 union cvmx_pki_qpg_tblx {
 	uint64_t u64;
@@ -2824,11 +3310,36 @@ union cvmx_pki_qpg_tblx {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pki_qpg_tblx_s            cn73xx;
 	struct cvmx_pki_qpg_tblx_s            cn78xx;
 };
 typedef union cvmx_pki_qpg_tblx cvmx_pki_qpg_tblx_t;
 
 /**
+ * cvmx_pki_qpg_tblb#
+ *
+ * This register configures the QPG table. See also PKI_QPG_TBL().
+ *
+ */
+union cvmx_pki_qpg_tblbx {
+	uint64_t u64;
+	struct cvmx_pki_qpg_tblbx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t dstat_id                     : 10; /**< Deep statistic bucket to use for traffic to this QPG. This determines which
+                                                         index of PKI_DSTAT()_STAT0..PKI_DSTAT()_STAT4 will increment. Additionally, if
+                                                         PKI_STAT_CTL[MODE] = 0x2, then DSTAT_ID values 0-63 will increment
+                                                         PKI_STAT()_STAT0..PKI_STAT()_STAT18 and PKI_STAT()_HIST0..PKI_STAT()_HIST6. */
+#else
+	uint64_t dstat_id                     : 10;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_pki_qpg_tblbx_s           cn73xx;
+};
+typedef union cvmx_pki_qpg_tblbx cvmx_pki_qpg_tblbx_t;
+
+/**
  * cvmx_pki_reasm_sop#
  *
  * Set when a SOP is detected on a Reasm-Id, where the Reasm-ID value sets the bit vector of this
@@ -2844,6 +3355,7 @@ union cvmx_pki_reasm_sopx {
 	uint64_t sop                          : 64;
 #endif
 	} s;
+	struct cvmx_pki_reasm_sopx_s          cn73xx;
 	struct cvmx_pki_reasm_sopx_s          cn78xx;
 };
 typedef union cvmx_pki_reasm_sopx cvmx_pki_reasm_sopx_t;
@@ -2881,6 +3393,7 @@ union cvmx_pki_req_wgt {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_pki_req_wgt_s             cn73xx;
 	struct cvmx_pki_req_wgt_s             cn78xx;
 };
 typedef union cvmx_pki_req_wgt cvmx_pki_req_wgt_t;
@@ -2912,6 +3425,7 @@ union cvmx_pki_sft_rst {
 	uint64_t busy                         : 1;
 #endif
 	} s;
+	struct cvmx_pki_sft_rst_s             cn73xx;
 	struct cvmx_pki_sft_rst_s             cn78xx;
 };
 typedef union cvmx_pki_sft_rst cvmx_pki_sft_rst_t;
@@ -2931,6 +3445,7 @@ union cvmx_pki_statx_hist0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist0_s         cn73xx;
 	struct cvmx_pki_statx_hist0_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist0 cvmx_pki_statx_hist0_t;
@@ -2949,6 +3464,7 @@ union cvmx_pki_statx_hist1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist1_s         cn73xx;
 	struct cvmx_pki_statx_hist1_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist1 cvmx_pki_statx_hist1_t;
@@ -2967,6 +3483,7 @@ union cvmx_pki_statx_hist2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist2_s         cn73xx;
 	struct cvmx_pki_statx_hist2_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist2 cvmx_pki_statx_hist2_t;
@@ -2985,6 +3502,7 @@ union cvmx_pki_statx_hist3 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist3_s         cn73xx;
 	struct cvmx_pki_statx_hist3_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist3 cvmx_pki_statx_hist3_t;
@@ -3003,6 +3521,7 @@ union cvmx_pki_statx_hist4 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist4_s         cn73xx;
 	struct cvmx_pki_statx_hist4_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist4 cvmx_pki_statx_hist4_t;
@@ -3021,6 +3540,7 @@ union cvmx_pki_statx_hist5 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist5_s         cn73xx;
 	struct cvmx_pki_statx_hist5_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist5 cvmx_pki_statx_hist5_t;
@@ -3039,6 +3559,7 @@ union cvmx_pki_statx_hist6 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist6_s         cn73xx;
 	struct cvmx_pki_statx_hist6_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist6 cvmx_pki_statx_hist6_t;
@@ -3057,6 +3578,7 @@ union cvmx_pki_statx_stat0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat0_s         cn73xx;
 	struct cvmx_pki_statx_stat0_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat0 cvmx_pki_statx_stat0_t;
@@ -3075,6 +3597,7 @@ union cvmx_pki_statx_stat1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat1_s         cn73xx;
 	struct cvmx_pki_statx_stat1_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat1 cvmx_pki_statx_stat1_t;
@@ -3093,6 +3616,7 @@ union cvmx_pki_statx_stat10 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat10_s        cn73xx;
 	struct cvmx_pki_statx_stat10_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat10 cvmx_pki_statx_stat10_t;
@@ -3111,6 +3635,7 @@ union cvmx_pki_statx_stat11 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat11_s        cn73xx;
 	struct cvmx_pki_statx_stat11_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat11 cvmx_pki_statx_stat11_t;
@@ -3130,6 +3655,7 @@ union cvmx_pki_statx_stat12 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat12_s        cn73xx;
 	struct cvmx_pki_statx_stat12_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat12 cvmx_pki_statx_stat12_t;
@@ -3150,6 +3676,7 @@ union cvmx_pki_statx_stat13 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat13_s        cn73xx;
 	struct cvmx_pki_statx_stat13_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat13 cvmx_pki_statx_stat13_t;
@@ -3169,6 +3696,7 @@ union cvmx_pki_statx_stat14 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat14_s        cn73xx;
 	struct cvmx_pki_statx_stat14_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat14 cvmx_pki_statx_stat14_t;
@@ -3188,6 +3716,7 @@ union cvmx_pki_statx_stat15 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat15_s        cn73xx;
 	struct cvmx_pki_statx_stat15_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat15 cvmx_pki_statx_stat15_t;
@@ -3207,6 +3736,7 @@ union cvmx_pki_statx_stat16 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat16_s        cn73xx;
 	struct cvmx_pki_statx_stat16_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat16 cvmx_pki_statx_stat16_t;
@@ -3226,6 +3756,7 @@ union cvmx_pki_statx_stat17 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat17_s        cn73xx;
 	struct cvmx_pki_statx_stat17_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat17 cvmx_pki_statx_stat17_t;
@@ -3245,6 +3776,7 @@ union cvmx_pki_statx_stat18 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat18_s        cn73xx;
 	struct cvmx_pki_statx_stat18_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat18 cvmx_pki_statx_stat18_t;
@@ -3263,6 +3795,7 @@ union cvmx_pki_statx_stat2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat2_s         cn73xx;
 	struct cvmx_pki_statx_stat2_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat2 cvmx_pki_statx_stat2_t;
@@ -3281,6 +3814,7 @@ union cvmx_pki_statx_stat3 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat3_s         cn73xx;
 	struct cvmx_pki_statx_stat3_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat3 cvmx_pki_statx_stat3_t;
@@ -3299,6 +3833,7 @@ union cvmx_pki_statx_stat4 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat4_s         cn73xx;
 	struct cvmx_pki_statx_stat4_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat4 cvmx_pki_statx_stat4_t;
@@ -3318,6 +3853,7 @@ union cvmx_pki_statx_stat5 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat5_s         cn73xx;
 	struct cvmx_pki_statx_stat5_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat5 cvmx_pki_statx_stat5_t;
@@ -3337,6 +3873,7 @@ union cvmx_pki_statx_stat6 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat6_s         cn73xx;
 	struct cvmx_pki_statx_stat6_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat6 cvmx_pki_statx_stat6_t;
@@ -3355,6 +3892,7 @@ union cvmx_pki_statx_stat7 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat7_s         cn73xx;
 	struct cvmx_pki_statx_stat7_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat7 cvmx_pki_statx_stat7_t;
@@ -3373,6 +3911,7 @@ union cvmx_pki_statx_stat8 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat8_s         cn73xx;
 	struct cvmx_pki_statx_stat8_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat8 cvmx_pki_statx_stat8_t;
@@ -3391,6 +3930,7 @@ union cvmx_pki_statx_stat9 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat9_s         cn73xx;
 	struct cvmx_pki_statx_stat9_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat9 cvmx_pki_statx_stat9_t;
@@ -3410,7 +3950,7 @@ union cvmx_pki_stat_ctl {
                                                          (Does not apply to the PKI_STAT_INB* nor PKI_DSTAT_* registers.)
                                                          _ 0x0 = X represents the packet's pkind.
                                                          _ 0x1 = X represents the low 6-bits of packet's final style.
-                                                         _ 0x2 = X represents the packet's PKI_QPG_TBL2()[DSTAT_ID].
+                                                         _ 0x2 = X represents the packet's PKI_QPG_TBLB()[DSTAT_ID].
                                                            PKI_STAT()_STAT0..PKI_STAT()_STAT18 and PKI_STAT()_HIST0..PKI_STAT()_HIST6 will only
                                                            be incremented if the DSTAT_ID is less than 64; i.e. fits in the index of the
                                                            PKI_STAT()_STAT0 etc. Added in pass 2.
@@ -3420,6 +3960,7 @@ union cvmx_pki_stat_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pki_stat_ctl_s            cn73xx;
 	struct cvmx_pki_stat_ctl_s            cn78xx;
 };
 typedef union cvmx_pki_stat_ctl cvmx_pki_stat_ctl_t;
@@ -3501,6 +4042,7 @@ union cvmx_pki_stylex_buf {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_pki_stylex_buf_s          cn73xx;
 	struct cvmx_pki_stylex_buf_s          cn78xx;
 };
 typedef union cvmx_pki_stylex_buf cvmx_pki_stylex_buf_t;
@@ -3521,6 +4063,7 @@ union cvmx_pki_stylex_tag_mask {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_stylex_tag_mask_s     cn73xx;
 	struct cvmx_pki_stylex_tag_mask_s     cn78xx;
 };
 typedef union cvmx_pki_stylex_tag_mask cvmx_pki_stylex_tag_mask_t;
@@ -3552,6 +4095,7 @@ union cvmx_pki_stylex_tag_sel {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_pki_stylex_tag_sel_s      cn73xx;
 	struct cvmx_pki_stylex_tag_sel_s      cn78xx;
 };
 typedef union cvmx_pki_stylex_tag_sel cvmx_pki_stylex_tag_sel_t;
@@ -3570,6 +4114,7 @@ union cvmx_pki_stylex_wq2 {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_pki_stylex_wq2_s          cn73xx;
 	struct cvmx_pki_stylex_wq2_s          cn78xx;
 };
 typedef union cvmx_pki_stylex_wq2 cvmx_pki_stylex_wq2_t;
@@ -3588,6 +4133,7 @@ union cvmx_pki_stylex_wq4 {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_pki_stylex_wq4_s          cn73xx;
 	struct cvmx_pki_stylex_wq4_s          cn78xx;
 };
 typedef union cvmx_pki_stylex_wq4 cvmx_pki_stylex_wq4_t;
@@ -3628,6 +4174,7 @@ union cvmx_pki_tag_incx_ctl {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_pki_tag_incx_ctl_s        cn73xx;
 	struct cvmx_pki_tag_incx_ctl_s        cn78xx;
 };
 typedef union cvmx_pki_tag_incx_ctl cvmx_pki_tag_incx_ctl_t;
@@ -3645,6 +4192,7 @@ union cvmx_pki_tag_incx_mask {
 	uint64_t en                           : 64;
 #endif
 	} s;
+	struct cvmx_pki_tag_incx_mask_s       cn73xx;
 	struct cvmx_pki_tag_incx_mask_s       cn78xx;
 };
 typedef union cvmx_pki_tag_incx_mask cvmx_pki_tag_incx_mask_t;
@@ -3674,6 +4222,7 @@ union cvmx_pki_tag_secret {
 	uint64_t dst6                         : 16;
 #endif
 	} s;
+	struct cvmx_pki_tag_secret_s          cn73xx;
 	struct cvmx_pki_tag_secret_s          cn78xx;
 };
 typedef union cvmx_pki_tag_secret cvmx_pki_tag_secret_t;
@@ -3693,6 +4242,7 @@ union cvmx_pki_x2p_req_ofl {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pki_x2p_req_ofl_s         cn73xx;
 	struct cvmx_pki_x2p_req_ofl_s         cn78xx;
 };
 typedef union cvmx_pki_x2p_req_ofl cvmx_pki_x2p_req_ofl_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index 9985673..7a0fdc8 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -65,21 +65,26 @@ extern "C" {
 /* *INDENT-ON* */
 #endif
 
+/* PKI AURA and BPID count are equal to FPA AURA count */
+#define CVMX_PKI_NUM_AURA	(cvmx_fpa3_num_auras())
+#define CVMX_PKI_NUM_BPID	(cvmx_fpa3_num_auras())	
+#define CVMX_PKI_NUM_SSO_GROUP	(cvmx_sso_num_xgrp())
+//#define CVMX_PKI_NUM_CLUSTER_GROUP      (4)
+#define CVMX_PKI_NUM_CLUSTER_GROUP_MAX	(4)
+#define CVMX_PKI_NUM_CLUSTER_GROUP	(cvmx_pki_num_cl_grp())
+//#define CVMX_PKI_NUM_CLUSTER		(4)
+#define CVMX_PKI_NUM_CLUSTER	 (cvmx_pki_num_clusters())
+
+//FIXME: Reduce some of these values, convert to routines XXX
 #define CVMX_PKI_NUM_CHANNEL		(4096)
-#define CVMX_PKI_NUM_AURA		(1024)
-#define CVMX_PKI_NUM_BPID		(1024)
 #define CVMX_PKI_NUM_PKIND		(64)
 #define CVMX_PKI_NUM_INTERNAL_STYLE     (256)
 #define CVMX_PKI_NUM_FINAL_STYLE 	(64)
 #define CVMX_PKI_NUM_QPG_ENTRY		(2048)
 #define CVMX_PKI_NUM_LTYPE		(32)
-#define CVMX_PKI_NUM_CLUSTER		(4)
-#define CVMX_PKI_NUM_CLUSTER_GROUP      (4)
 #define CVMX_PKI_NUM_PCAM_BANK		(2)
 #define CVMX_PKI_NUM_PCAM_ENTRY		(192)
 #define CVMX_PKI_NUM_FRAME_CHECK	(2)
-#define CVMX_PKI_NUM_BPID		(1024)
-#define CVMX_PKI_NUM_SSO_GROUP		(256)
 #define CVMX_PKI_NUM_BELTYPE		(32)
 #define CVMX_PKI_MAX_FRAME_SIZE		(65535)
 #define CVMX_PKI_FIND_AVAL_ENTRY        (-1)
@@ -92,6 +97,19 @@ extern "C" {
 #define CVMX_PKI_TOTAL_PCAM_ENTRY	(CVMX_PKI_NUM_PCAM_BANK * CVMX_PKI_NUM_PCAM_ENTRY)
 #endif
 
+static inline unsigned cvmx_pki_num_clusters(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return 2;
+	return 4;
+}
+static inline unsigned cvmx_pki_num_cl_grp(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return 1;
+	return 4;
+}
+
 enum cvmx_pki_pkind_parse_mode {
 	CVMX_PKI_PARSE_LA_TO_LG = 0,	/* parse LA(L2) to LG */
 	CVMX_PKI_PARSE_LB_TO_LG = 1,	/* parse LB(custom) to LG */
@@ -458,7 +476,7 @@ struct cvmx_pki_tag_sec {
 };
 
 struct cvmx_pki_global_config {
-	uint64_t cluster_mask[CVMX_PKI_NUM_CLUSTER_GROUP];	/**< Mask of clusters associated with that cluster group,
+	uint64_t cluster_mask[CVMX_PKI_NUM_CLUSTER_GROUP_MAX];/**< Mask of clusters associated with that cluster group,
 								there are 4 cluster groups and 4 clusters which can be assigned
 								to cluster groups */
 	enum cvmx_pki_stats_mode stat_mode;			/**< The PKI_STAT*_X registers can be indexed either by pkind or final style.
@@ -688,7 +706,7 @@ static inline void cvmx_pki_write_ltype_map(int node,
  * @param cl_grp        cluster group to enable parsing
  *
  */
-static inline int cvmx_pki_parse_enable(int node, int cl_grp)
+static inline int cvmx_pki_parse_enable(int node, unsigned cl_grp)
 {
 	cvmx_pki_icgx_cfg_t pki_cl_grp;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 2c0d8a4..31ee975 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_PKO_CHANNEL_LEVEL CVMX_PKO_CHANNEL_LEVEL_FUNC()
 static inline uint64_t CVMX_PKO_CHANNEL_LEVEL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_CHANNEL_LEVEL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000800F0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_PKO_CHANNEL_LEVEL_FUNC(void)
 #define CVMX_PKO_DPFI_ENA CVMX_PKO_DPFI_ENA_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_ENA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_ENA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00018ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_PKO_DPFI_ENA_FUNC(void)
 #define CVMX_PKO_DPFI_FLUSH CVMX_PKO_DPFI_FLUSH_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_FLUSH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_FLUSH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00008ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_PKO_DPFI_FLUSH_FUNC(void)
 #define CVMX_PKO_DPFI_FPA_AURA CVMX_PKO_DPFI_FPA_AURA_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_FPA_AURA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_FPA_AURA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00010ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_PKO_DPFI_FPA_AURA_FUNC(void)
 #define CVMX_PKO_DPFI_STATUS CVMX_PKO_DPFI_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00000ull);
 }
@@ -111,6 +111,7 @@ static inline uint64_t CVMX_PKO_DPFI_STATUS_FUNC(void)
 static inline uint64_t CVMX_PKO_DQX_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000D8ull) + ((offset) & 1023) * 512;
@@ -122,6 +123,7 @@ static inline uint64_t CVMX_PKO_DQX_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280018ull) + ((offset) & 1023) * 512;
@@ -133,6 +135,7 @@ static inline uint64_t CVMX_PKO_DQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_DROPPED_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_DROPPED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000C8ull) + ((offset) & 1023) * 512;
@@ -144,6 +147,7 @@ static inline uint64_t CVMX_PKO_DQX_DROPPED_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_DROPPED_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_DROPPED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000C0ull) + ((offset) & 1023) * 512;
@@ -155,6 +159,7 @@ static inline uint64_t CVMX_PKO_DQX_DROPPED_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_FIFO(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_FIFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300078ull) + ((offset) & 1023) * 512;
@@ -166,6 +171,7 @@ static inline uint64_t CVMX_PKO_DQX_FIFO(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000D0ull) + ((offset) & 1023) * 512;
@@ -177,6 +183,7 @@ static inline uint64_t CVMX_PKO_DQX_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300070ull) + ((offset) & 1023) * 512;
@@ -188,6 +195,7 @@ static inline uint64_t CVMX_PKO_DQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_PIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280020ull) + ((offset) & 1023) * 512;
@@ -199,6 +207,7 @@ static inline uint64_t CVMX_PKO_DQX_PIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_POINTERS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280078ull) + ((offset) & 1023) * 512;
@@ -210,6 +219,7 @@ static inline uint64_t CVMX_PKO_DQX_POINTERS(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280008ull) + ((offset) & 1023) * 512;
@@ -221,6 +231,7 @@ static inline uint64_t CVMX_PKO_DQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280028ull) + ((offset) & 1023) * 512;
@@ -232,6 +243,7 @@ static inline uint64_t CVMX_PKO_DQX_SCHED_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280010ull) + ((offset) & 1023) * 512;
@@ -243,6 +255,7 @@ static inline uint64_t CVMX_PKO_DQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280030ull) + ((offset) & 1023) * 512;
@@ -254,6 +267,7 @@ static inline uint64_t CVMX_PKO_DQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400002800E0ull) + ((offset) & 1023) * 512;
@@ -265,6 +279,7 @@ static inline uint64_t CVMX_PKO_DQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300000ull) + ((offset) & 1023) * 512;
@@ -276,6 +291,7 @@ static inline uint64_t CVMX_PKO_DQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_BUF_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000E8ull) + ((offset) & 1023) * 512;
@@ -287,6 +303,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CNT(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000F0ull) + ((offset) & 1023) * 512;
@@ -298,6 +315,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL_W1C(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000F8ull) + ((offset) & 1023) * 512;
@@ -309,6 +327,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL_W1C(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000050ull) + ((offset) & 1023) * 512;
@@ -320,6 +339,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CNT(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000040ull) + ((offset) & 1023) * 512;
@@ -331,6 +351,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CTL_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000048ull) + ((offset) & 1023) * 512;
@@ -342,7 +363,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 #define CVMX_PKO_DQ_CSR_BUS_DEBUG CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400003001F8ull);
 }
@@ -353,7 +374,7 @@ static inline uint64_t CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_DQ_DEBUG CVMX_PKO_DQ_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DQ_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300128ull);
 }
@@ -364,7 +385,7 @@ static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
 #define CVMX_PKO_DRAIN_IRQ CVMX_PKO_DRAIN_IRQ_FUNC()
 static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DRAIN_IRQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000140ull);
 }
@@ -375,7 +396,7 @@ static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
 #define CVMX_PKO_ENABLE CVMX_PKO_ENABLE_FUNC()
 static inline uint64_t CVMX_PKO_ENABLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_ENABLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000D00008ull);
 }
@@ -386,6 +407,7 @@ static inline uint64_t CVMX_PKO_ENABLE_FUNC(void)
 static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_PKO_FORMATX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900800ull) + ((offset) & 127) * 8;
@@ -397,7 +419,7 @@ static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 #define CVMX_PKO_L1_SQA_DEBUG CVMX_PKO_L1_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080128ull);
 }
@@ -408,7 +430,7 @@ static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L1_SQB_DEBUG CVMX_PKO_L1_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080130ull);
 }
@@ -419,6 +441,7 @@ static inline uint64_t CVMX_PKO_L1_SQB_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L1_SQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000018ull) + ((offset) & 31) * 512;
@@ -430,6 +453,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_DROPPED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000088ull) + ((offset) & 31) * 512;
@@ -441,6 +465,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_DROPPED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000080ull) + ((offset) & 31) * 512;
@@ -452,6 +477,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_GREEN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080058ull) + ((offset) & 31) * 512;
@@ -463,6 +489,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_GREEN_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000B8ull) + ((offset) & 31) * 512;
@@ -474,6 +501,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_GREEN_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000B0ull) + ((offset) & 31) * 512;
@@ -485,6 +513,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_LINK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_LINK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000038ull) + ((offset) & 31) * 512;
@@ -496,6 +525,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_LINK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080070ull) + ((offset) & 31) * 512;
@@ -507,6 +537,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_RED(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080068ull) + ((offset) & 31) * 512;
@@ -518,6 +549,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_RED_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000098ull) + ((offset) & 31) * 512;
@@ -529,6 +561,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_RED_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000090ull) + ((offset) & 31) * 512;
@@ -540,6 +573,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000008ull) + ((offset) & 31) * 512;
@@ -551,6 +585,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000010ull) + ((offset) & 31) * 512;
@@ -562,6 +597,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000030ull) + ((offset) & 31) * 512;
@@ -573,6 +609,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000E0ull) + ((offset) & 31) * 512;
@@ -584,6 +621,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080000ull) + ((offset) & 31) * 512;
@@ -595,6 +633,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080060ull) + ((offset) & 31) * 512;
@@ -606,6 +645,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000A8ull) + ((offset) & 31) * 512;
@@ -617,6 +657,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000A0ull) + ((offset) & 31) * 512;
@@ -628,7 +669,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 #define CVMX_PKO_L1_SQ_CSR_BUS_DEBUG CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000801F8ull);
 }
@@ -639,7 +680,7 @@ static inline uint64_t CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_L2_SQA_DEBUG CVMX_PKO_L2_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100128ull);
 }
@@ -650,7 +691,7 @@ static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L2_SQB_DEBUG CVMX_PKO_L2_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100130ull);
 }
@@ -661,6 +702,7 @@ static inline uint64_t CVMX_PKO_L2_SQB_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L2_SQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080018ull) + ((offset) & 511) * 512;
@@ -672,6 +714,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_GREEN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100058ull) + ((offset) & 511) * 512;
@@ -683,6 +726,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_GREEN(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100070ull) + ((offset) & 511) * 512;
@@ -694,6 +738,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_PIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080020ull) + ((offset) & 511) * 512;
@@ -705,6 +750,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_PIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080078ull) + ((offset) & 511) * 512;
@@ -716,6 +762,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_POINTERS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_RED(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100068ull) + ((offset) & 511) * 512;
@@ -727,6 +774,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_RED(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080008ull) + ((offset) & 511) * 512;
@@ -738,6 +786,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080028ull) + ((offset) & 511) * 512;
@@ -749,6 +798,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SCHED_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080010ull) + ((offset) & 511) * 512;
@@ -760,6 +810,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080030ull) + ((offset) & 511) * 512;
@@ -771,6 +822,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000800E0ull) + ((offset) & 511) * 512;
@@ -782,6 +834,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100000ull) + ((offset) & 511) * 512;
@@ -793,6 +846,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100060ull) + ((offset) & 511) * 512;
@@ -804,7 +858,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L2_SQ_CSR_BUS_DEBUG CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400001001F8ull);
 }
@@ -815,6 +869,7 @@ static inline uint64_t CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_L2_SQX_CHANNEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080038ull) + ((offset) & 511) * 512;
@@ -826,7 +881,7 @@ static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 #define CVMX_PKO_L3_SQA_DEBUG CVMX_PKO_L3_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180128ull);
 }
@@ -837,7 +892,7 @@ static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L3_SQB_DEBUG CVMX_PKO_L3_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180130ull);
 }
@@ -848,6 +903,7 @@ static inline uint64_t CVMX_PKO_L3_SQB_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L3_SQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100018ull) + ((offset) & 511) * 512;
@@ -859,6 +915,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_GREEN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180058ull) + ((offset) & 511) * 512;
@@ -870,6 +927,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_GREEN(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180070ull) + ((offset) & 511) * 512;
@@ -881,6 +939,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_PIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100020ull) + ((offset) & 511) * 512;
@@ -892,6 +951,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_PIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100078ull) + ((offset) & 511) * 512;
@@ -903,6 +963,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_POINTERS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_RED(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180068ull) + ((offset) & 511) * 512;
@@ -914,6 +975,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_RED(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100008ull) + ((offset) & 511) * 512;
@@ -925,6 +987,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100028ull) + ((offset) & 511) * 512;
@@ -936,6 +999,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SCHED_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100010ull) + ((offset) & 511) * 512;
@@ -947,6 +1011,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100030ull) + ((offset) & 511) * 512;
@@ -958,6 +1023,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400001000E0ull) + ((offset) & 511) * 512;
@@ -969,6 +1035,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180000ull) + ((offset) & 511) * 512;
@@ -980,6 +1047,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180060ull) + ((offset) & 511) * 512;
@@ -991,7 +1059,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L3_SQ_CSR_BUS_DEBUG CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400001801F8ull);
 }
@@ -1354,6 +1422,7 @@ static inline uint64_t CVMX_PKO_L5_SQ_CSR_BUS_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 383))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_LUTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000B00000ull) + ((offset) & 1023) * 8;
@@ -1365,7 +1434,7 @@ static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 #define CVMX_PKO_LUT_BIST_STATUS CVMX_PKO_LUT_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000B02018ull);
 }
@@ -1376,7 +1445,7 @@ static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_LUT_ECC_CTL0 CVMX_PKO_LUT_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFD0ull);
 }
@@ -1387,7 +1456,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_DBE_STS0 CVMX_PKO_LUT_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFF0ull);
 }
@@ -1398,7 +1467,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_DBE_STS_CMB0 CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFD8ull);
 }
@@ -1409,7 +1478,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_SBE_STS0 CVMX_PKO_LUT_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFF8ull);
 }
@@ -1420,7 +1489,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_SBE_STS_CMB0 CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFE8ull);
 }
@@ -1431,6 +1500,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC(void)
 static inline uint64_t CVMX_PKO_MACX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MACX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900000ull) + ((offset) & 31) * 8;
@@ -1464,6 +1534,7 @@ static inline uint64_t CVMX_PKO_MCI0_MAX_CREDX(unsigned long offset)
 static inline uint64_t CVMX_PKO_MCI1_CRED_CNTX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MCI1_CRED_CNTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000A80100ull) + ((offset) & 31) * 8;
@@ -1475,6 +1546,7 @@ static inline uint64_t CVMX_PKO_MCI1_CRED_CNTX(unsigned long offset)
 static inline uint64_t CVMX_PKO_MCI1_MAX_CREDX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MCI1_MAX_CREDX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000A80000ull) + ((offset) & 31) * 8;
@@ -1645,7 +1717,7 @@ static inline uint64_t CVMX_PKO_MEM_THROTTLE_PIPE_FUNC(void)
 #define CVMX_PKO_NCB_BIST_STATUS CVMX_PKO_NCB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_NCB_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFF00ull);
 }
@@ -1656,7 +1728,7 @@ static inline uint64_t CVMX_PKO_NCB_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_NCB_ECC_CTL0 CVMX_PKO_NCB_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFD0ull);
 }
@@ -1667,7 +1739,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_DBE_STS0 CVMX_PKO_NCB_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFF0ull);
 }
@@ -1678,7 +1750,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_DBE_STS_CMB0 CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFD8ull);
 }
@@ -1689,7 +1761,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_SBE_STS0 CVMX_PKO_NCB_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFF8ull);
 }
@@ -1700,7 +1772,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_SBE_STS_CMB0 CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFE8ull);
 }
@@ -1711,7 +1783,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_NCB_INT CVMX_PKO_NCB_INT_FUNC()
 static inline uint64_t CVMX_PKO_NCB_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00010ull);
 }
@@ -1722,7 +1794,7 @@ static inline uint64_t CVMX_PKO_NCB_INT_FUNC(void)
 #define CVMX_PKO_NCB_TX_ERR_INFO CVMX_PKO_NCB_TX_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_NCB_TX_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_TX_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00008ull);
 }
@@ -1733,7 +1805,7 @@ static inline uint64_t CVMX_PKO_NCB_TX_ERR_INFO_FUNC(void)
 #define CVMX_PKO_NCB_TX_ERR_WORD CVMX_PKO_NCB_TX_ERR_WORD_FUNC()
 static inline uint64_t CVMX_PKO_NCB_TX_ERR_WORD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_TX_ERR_WORD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00000ull);
 }
@@ -1744,7 +1816,7 @@ static inline uint64_t CVMX_PKO_NCB_TX_ERR_WORD_FUNC(void)
 #define CVMX_PKO_PDM_BIST_STATUS CVMX_PKO_PDM_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFF00ull);
 }
@@ -1755,7 +1827,7 @@ static inline uint64_t CVMX_PKO_PDM_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PDM_CFG CVMX_PKO_PDM_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800000ull);
 }
@@ -1766,7 +1838,7 @@ static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 #define CVMX_PKO_PDM_CFG_DBG CVMX_PKO_PDM_CFG_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CFG_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800FF8ull);
 }
@@ -1777,7 +1849,7 @@ static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 #define CVMX_PKO_PDM_CP_DBG CVMX_PKO_PDM_CP_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CP_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CP_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800190ull);
 }
@@ -1788,6 +1860,7 @@ static inline uint64_t CVMX_PKO_PDM_CP_DBG_FUNC(void)
 static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_PDM_DQX_MINPAD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008F0000ull) + ((offset) & 1023) * 8;
@@ -1799,7 +1872,7 @@ static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 #define CVMX_PKO_PDM_DRPBUF_DBG CVMX_PKO_PDM_DRPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_DRPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_DRPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000B0ull);
 }
@@ -1810,7 +1883,7 @@ static inline uint64_t CVMX_PKO_PDM_DRPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_DWPBUF_DBG CVMX_PKO_PDM_DWPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_DWPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_DWPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000A8ull);
 }
@@ -1821,7 +1894,7 @@ static inline uint64_t CVMX_PKO_PDM_DWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL0 CVMX_PKO_PDM_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFD0ull);
 }
@@ -1832,7 +1905,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL1 CVMX_PKO_PDM_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFD8ull);
 }
@@ -1843,7 +1916,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
 #define CVMX_PKO_PDM_ECC_DBE_STS0 CVMX_PKO_PDM_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFF0ull);
 }
@@ -1854,7 +1927,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_DBE_STS_CMB0 CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFE0ull);
 }
@@ -1865,7 +1938,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_SBE_STS0 CVMX_PKO_PDM_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFF8ull);
 }
@@ -1876,7 +1949,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_SBE_STS_CMB0 CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFE8ull);
 }
@@ -1887,7 +1960,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG0 CVMX_PKO_PDM_FILLB_DBG0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002A0ull);
 }
@@ -1898,7 +1971,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG0_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG1 CVMX_PKO_PDM_FILLB_DBG1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002A8ull);
 }
@@ -1909,7 +1982,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG1_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG2 CVMX_PKO_PDM_FILLB_DBG2_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002B0ull);
 }
@@ -1920,7 +1993,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG2_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG0 CVMX_PKO_PDM_FLSHB_DBG0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FLSHB_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002B8ull);
 }
@@ -1931,7 +2004,7 @@ static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG0_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG1 CVMX_PKO_PDM_FLSHB_DBG1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FLSHB_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002C0ull);
 }
@@ -1939,10 +2012,21 @@ static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG1_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG1 (CVMX_ADD_IO_SEG(0x00015400008002C0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PDM_INTF_DBG_RD CVMX_PKO_PDM_INTF_DBG_RD_FUNC()
+static inline uint64_t CVMX_PKO_PDM_INTF_DBG_RD_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKO_PDM_INTF_DBG_RD not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000900F20ull);
+}
+#else
+#define CVMX_PKO_PDM_INTF_DBG_RD (CVMX_ADD_IO_SEG(0x0001540000900F20ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PDM_ISRD_DBG CVMX_PKO_PDM_ISRD_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800090ull);
 }
@@ -1953,7 +2037,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRD_DBG_DQ CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG_DQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800290ull);
 }
@@ -1964,7 +2048,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG CVMX_PKO_PDM_ISRM_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800098ull);
 }
@@ -1975,7 +2059,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG_DQ CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG_DQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800298ull);
 }
@@ -1986,7 +2070,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
 #define CVMX_PKO_PDM_MEM_ADDR CVMX_PKO_PDM_MEM_ADDR_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_ADDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800018ull);
 }
@@ -1997,7 +2081,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 #define CVMX_PKO_PDM_MEM_DATA CVMX_PKO_PDM_MEM_DATA_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800010ull);
 }
@@ -2008,7 +2092,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_DATA_FUNC(void)
 #define CVMX_PKO_PDM_MEM_RW_CTL CVMX_PKO_PDM_MEM_RW_CTL_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_RW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_RW_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800020ull);
 }
@@ -2019,7 +2103,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_RW_CTL_FUNC(void)
 #define CVMX_PKO_PDM_MEM_RW_STS CVMX_PKO_PDM_MEM_RW_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_RW_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_RW_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800028ull);
 }
@@ -2030,7 +2114,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_RW_STS_FUNC(void)
 #define CVMX_PKO_PDM_MWPBUF_DBG CVMX_PKO_PDM_MWPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MWPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000A0ull);
 }
@@ -2041,7 +2125,7 @@ static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_STS CVMX_PKO_PDM_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800008ull);
 }
@@ -2052,7 +2136,7 @@ static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 #define CVMX_PKO_PEB_BIST_STATUS CVMX_PKO_PEB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900D00ull);
 }
@@ -2063,7 +2147,7 @@ static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PEB_ECC_CTL0 CVMX_PKO_PEB_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFD0ull);
 }
@@ -2074,7 +2158,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_CTL1 CVMX_PKO_PEB_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFA8ull);
 }
@@ -2085,7 +2169,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_CTL1_FUNC(void)
 #define CVMX_PKO_PEB_ECC_DBE_STS0 CVMX_PKO_PEB_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFF0ull);
 }
@@ -2096,7 +2180,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_DBE_STS_CMB0 CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFD8ull);
 }
@@ -2107,7 +2191,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS0 CVMX_PKO_PEB_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFF8ull);
 }
@@ -2118,7 +2202,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS_CMB0 CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFE8ull);
 }
@@ -2126,10 +2210,21 @@ static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x00015400009FFFE8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PEB_ECO CVMX_PKO_PEB_ECO_FUNC()
+static inline uint64_t CVMX_PKO_PEB_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKO_PEB_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000901000ull);
+}
+#else
+#define CVMX_PKO_PEB_ECO (CVMX_ADD_IO_SEG(0x0001540000901000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PEB_ERR_INT CVMX_PKO_PEB_ERR_INT_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C00ull);
 }
@@ -2140,7 +2235,7 @@ static inline uint64_t CVMX_PKO_PEB_ERR_INT_FUNC(void)
 #define CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C08ull);
 }
@@ -2151,7 +2246,7 @@ static inline uint64_t CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_FCS_SOP_ERR_INFO CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_FCS_SOP_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C18ull);
 }
@@ -2162,7 +2257,7 @@ static inline uint64_t CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_JUMP_DEF_ERR_INFO CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_JUMP_DEF_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C10ull);
 }
@@ -2173,7 +2268,7 @@ static inline uint64_t CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C50ull);
 }
@@ -2184,7 +2279,7 @@ static inline uint64_t CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_MAX_LINK_ERR_INFO CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_MAX_LINK_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C48ull);
 }
@@ -2195,7 +2290,7 @@ static inline uint64_t CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_NCB_CFG CVMX_PKO_PEB_NCB_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PEB_NCB_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_NCB_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900308ull);
 }
@@ -2206,7 +2301,7 @@ static inline uint64_t CVMX_PKO_PEB_NCB_CFG_FUNC(void)
 #define CVMX_PKO_PEB_PAD_ERR_INFO CVMX_PKO_PEB_PAD_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_PAD_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_PAD_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C28ull);
 }
@@ -2217,7 +2312,7 @@ static inline uint64_t CVMX_PKO_PEB_PAD_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_PSE_FIFO_ERR_INFO CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_PSE_FIFO_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C20ull);
 }
@@ -2228,7 +2323,7 @@ static inline uint64_t CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C38ull);
 }
@@ -2239,7 +2334,7 @@ static inline uint64_t CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C40ull);
 }
@@ -2250,7 +2345,7 @@ static inline uint64_t CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TRUNC_ERR_INFO CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_TRUNC_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C30ull);
 }
@@ -2261,7 +2356,7 @@ static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TSO_CFG CVMX_PKO_PEB_TSO_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_TSO_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900310ull);
 }
@@ -2272,7 +2367,7 @@ static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
 #define CVMX_PKO_PQA_DEBUG CVMX_PKO_PQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000128ull);
 }
@@ -2283,7 +2378,7 @@ static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 #define CVMX_PKO_PQB_DEBUG CVMX_PKO_PQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000130ull);
 }
@@ -2294,7 +2389,7 @@ static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
 #define CVMX_PKO_PQ_CSR_BUS_DEBUG CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000001F8ull);
 }
@@ -2305,7 +2400,7 @@ static inline uint64_t CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_GREEN CVMX_PKO_PQ_DEBUG_GREEN_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_GREEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000058ull);
 }
@@ -2316,7 +2411,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_LINKS CVMX_PKO_PQ_DEBUG_LINKS_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_LINKS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000068ull);
 }
@@ -2327,7 +2422,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_YELLOW CVMX_PKO_PQ_DEBUG_YELLOW_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_YELLOW not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000060ull);
 }
@@ -2338,7 +2433,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
 #define CVMX_PKO_PSE_DQ_BIST_STATUS CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300138ull);
 }
@@ -2349,7 +2444,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_CTL0 CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300100ull);
 }
@@ -2360,7 +2455,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_DBE_STS0 CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300118ull);
 }
@@ -2371,7 +2466,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300120ull);
 }
@@ -2382,7 +2477,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS0 CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300108ull);
 }
@@ -2393,7 +2488,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300110ull);
 }
@@ -2404,7 +2499,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_BIST_STATUS CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000138ull);
 }
@@ -2415,7 +2510,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_CTL0 CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000100ull);
 }
@@ -2426,7 +2521,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_DBE_STS0 CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000118ull);
 }
@@ -2437,7 +2532,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000120ull);
 }
@@ -2448,7 +2543,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS0 CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000108ull);
 }
@@ -2459,7 +2554,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000110ull);
 }
@@ -2470,7 +2565,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_BIST_STATUS CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080138ull);
 }
@@ -2481,7 +2576,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_CTL0 CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080100ull);
 }
@@ -2492,7 +2587,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_DBE_STS0 CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080118ull);
 }
@@ -2503,7 +2598,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080120ull);
 }
@@ -2514,7 +2609,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS0 CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080108ull);
 }
@@ -2525,7 +2620,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080110ull);
 }
@@ -2536,7 +2631,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_BIST_STATUS CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100138ull);
 }
@@ -2547,7 +2642,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_CTL0 CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100100ull);
 }
@@ -2558,7 +2653,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_DBE_STS0 CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100118ull);
 }
@@ -2569,7 +2664,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100120ull);
 }
@@ -2580,7 +2675,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS0 CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100108ull);
 }
@@ -2591,7 +2686,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100110ull);
 }
@@ -2602,7 +2697,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_BIST_STATUS CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180138ull);
 }
@@ -2613,7 +2708,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_CTL0 CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180100ull);
 }
@@ -2624,7 +2719,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_DBE_STS0 CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180118ull);
 }
@@ -2635,7 +2730,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180120ull);
 }
@@ -2646,7 +2741,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS0 CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180108ull);
 }
@@ -2657,7 +2752,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180110ull);
 }
@@ -2800,6 +2895,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_SBE_STS_CMB0_FUNC(void)
 static inline uint64_t CVMX_PKO_PTFX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_PTFX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900100ull) + ((offset) & 31) * 8;
@@ -2811,7 +2907,7 @@ static inline uint64_t CVMX_PKO_PTFX_STATUS(unsigned long offset)
 #define CVMX_PKO_PTF_IOBP_CFG CVMX_PKO_PTF_IOBP_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PTF_IOBP_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PTF_IOBP_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900300ull);
 }
@@ -2822,6 +2918,7 @@ static inline uint64_t CVMX_PKO_PTF_IOBP_CFG_FUNC(void)
 static inline uint64_t CVMX_PKO_PTGFX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_PKO_PTGFX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900200ull) + ((offset) & 7) * 8;
@@ -3063,7 +3160,7 @@ static inline uint64_t CVMX_PKO_REG_TIMESTAMP_FUNC(void)
 #define CVMX_PKO_SHAPER_CFG CVMX_PKO_SHAPER_CFG_FUNC()
 static inline uint64_t CVMX_PKO_SHAPER_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_SHAPER_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000800F8ull);
 }
@@ -3071,16 +3168,38 @@ static inline uint64_t CVMX_PKO_SHAPER_CFG_FUNC(void)
 #define CVMX_PKO_SHAPER_CFG (CVMX_ADD_IO_SEG(0x00015400000800F8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKO_STATE_UID_IN_USEX_RD(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PKO_STATE_UID_IN_USEX_RD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001540000900F00ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_PKO_STATE_UID_IN_USEX_RD(offset) (CVMX_ADD_IO_SEG(0x0001540000900F00ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_STATUS CVMX_PKO_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000D00000ull);
 }
 #else
 #define CVMX_PKO_STATUS (CVMX_ADD_IO_SEG(0x0001540000D00000ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKO_TXFX_PKT_CNT_RD(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15)))))
+		cvmx_warn("CVMX_PKO_TXFX_PKT_CNT_RD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001540000900E00ull) + ((offset) & 15) * 8;
+}
+#else
+#define CVMX_PKO_TXFX_PKT_CNT_RD(offset) (CVMX_ADD_IO_SEG(0x0001540000900E00ull) + ((offset) & 15) * 8)
+#endif
 
 /**
  * cvmx_pko_channel_level
@@ -3098,6 +3217,7 @@ union cvmx_pko_channel_level {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_channel_level_s       cn73xx;
 	struct cvmx_pko_channel_level_s       cn78xx;
 };
 typedef union cvmx_pko_channel_level cvmx_pko_channel_level_t;
@@ -3118,6 +3238,7 @@ union cvmx_pko_dpfi_ena {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_dpfi_ena_s            cn73xx;
 	struct cvmx_pko_dpfi_ena_s            cn78xx;
 };
 typedef union cvmx_pko_dpfi_ena cvmx_pko_dpfi_ena_t;
@@ -3140,6 +3261,7 @@ union cvmx_pko_dpfi_flush {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_dpfi_flush_s          cn73xx;
 	struct cvmx_pko_dpfi_flush_s          cn78xx;
 };
 typedef union cvmx_pko_dpfi_flush cvmx_pko_dpfi_flush_t;
@@ -3153,16 +3275,16 @@ union cvmx_pko_dpfi_fpa_aura {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t node                         : 2;  /**< Node number of current chip, to ensure that the aura is on the local node. */
-	uint64_t laura                        : 10; /**< Local aura to use for PKO command buffering. Must be on local CCPI node.
-                                                         The FPA aura selected by LAURA must select an FPA pool whose
-                                                         FPA_POOL()_CFG[NAT_ALIGN]=1, and
-                                                         (FPA_POOL()_CFG[BUF_SIZE] - FPA_POOL()_CFG[BUF_OFFSET]) >= 4 KB/128. */
+	uint64_t laura                        : 10; /**< FPA local-node aura to use for PKO command buffering allocations and frees. The
+                                                         FPA aura selected by LAURA must correspond to a pool where the buffers (after
+                                                         any FPA_POOL()_CFG[BUF_OFFSET]) are at least 4 KB. */
 #else
 	uint64_t laura                        : 10;
 	uint64_t node                         : 2;
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_pko_dpfi_fpa_aura_s       cn73xx;
 	struct cvmx_pko_dpfi_fpa_aura_s       cn78xx;
 };
 typedef union cvmx_pko_dpfi_fpa_aura cvmx_pko_dpfi_fpa_aura_t;
@@ -3213,6 +3335,7 @@ union cvmx_pko_dpfi_status {
 	uint64_t ptr_cnt                      : 32;
 #endif
 	} s;
+	struct cvmx_pko_dpfi_status_s         cn73xx;
 	struct cvmx_pko_dpfi_status_s         cn78xx;
 };
 typedef union cvmx_pko_dpfi_status cvmx_pko_dpfi_status_t;
@@ -3234,6 +3357,7 @@ union cvmx_pko_dqx_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_dqx_bytes_s           cn73xx;
 	struct cvmx_pko_dqx_bytes_s           cn78xx;
 };
 typedef union cvmx_pko_dqx_bytes cvmx_pko_dqx_bytes_t;
@@ -3262,10 +3386,12 @@ union cvmx_pko_dqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -3280,6 +3406,7 @@ union cvmx_pko_dqx_cir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_dqx_cir_s             cn73xx;
 	struct cvmx_pko_dqx_cir_s             cn78xx;
 };
 typedef union cvmx_pko_dqx_cir cvmx_pko_dqx_cir_t;
@@ -3287,7 +3414,7 @@ typedef union cvmx_pko_dqx_cir cvmx_pko_dqx_cir_t;
 /**
  * cvmx_pko_dq#_dropped_bytes
  *
- * This register has the same bit fields as PKO_L1_SQ()_GREEN_BYTES.
+ * This register has the same bit fields as PKO_L1_SQ)_GREEN_BYTES.
  *
  */
 union cvmx_pko_dqx_dropped_bytes {
@@ -3301,6 +3428,7 @@ union cvmx_pko_dqx_dropped_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_dqx_dropped_bytes_s   cn73xx;
 	struct cvmx_pko_dqx_dropped_bytes_s   cn78xx;
 };
 typedef union cvmx_pko_dqx_dropped_bytes cvmx_pko_dqx_dropped_bytes_t;
@@ -3322,6 +3450,7 @@ union cvmx_pko_dqx_dropped_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_dqx_dropped_packets_s cn73xx;
 	struct cvmx_pko_dqx_dropped_packets_s cn78xx;
 };
 typedef union cvmx_pko_dqx_dropped_packets cvmx_pko_dqx_dropped_packets_t;
@@ -3344,6 +3473,7 @@ union cvmx_pko_dqx_fifo {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_pko_dqx_fifo_s            cn73xx;
 	struct cvmx_pko_dqx_fifo_s            cn78xx;
 };
 typedef union cvmx_pko_dqx_fifo cvmx_pko_dqx_fifo_t;
@@ -3365,6 +3495,7 @@ union cvmx_pko_dqx_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_dqx_packets_s         cn73xx;
 	struct cvmx_pko_dqx_packets_s         cn78xx;
 };
 typedef union cvmx_pko_dqx_packets cvmx_pko_dqx_packets_t;
@@ -3372,8 +3503,8 @@ typedef union cvmx_pko_dqx_packets cvmx_pko_dqx_packets_t;
 /**
  * cvmx_pko_dq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the DQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_dqx_pick {
 	uint64_t u64;
@@ -3391,8 +3522,10 @@ union cvmx_pko_dqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -3429,6 +3562,7 @@ union cvmx_pko_dqx_pick {
 	uint64_t dq                           : 10;
 #endif
 	} s;
+	struct cvmx_pko_dqx_pick_s            cn73xx;
 	struct cvmx_pko_dqx_pick_s            cn78xx;
 };
 typedef union cvmx_pko_dqx_pick cvmx_pko_dqx_pick_t;
@@ -3457,10 +3591,12 @@ union cvmx_pko_dqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -3475,6 +3611,7 @@ union cvmx_pko_dqx_pir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_dqx_pir_s             cn73xx;
 	struct cvmx_pko_dqx_pir_s             cn78xx;
 };
 typedef union cvmx_pko_dqx_pir cvmx_pko_dqx_pir_t;
@@ -3482,7 +3619,7 @@ typedef union cvmx_pko_dqx_pir cvmx_pko_dqx_pir_t;
 /**
  * cvmx_pko_dq#_pointers
  *
- * This register has the same bit fields as PKO_L4_SQ()_POINTERS.
+ * This register has the same bit fields as PKO_L3_SQ(0..255)_POINTERS.
  *
  */
 union cvmx_pko_dqx_pointers {
@@ -3500,6 +3637,19 @@ union cvmx_pko_dqx_pointers {
 	uint64_t reserved_26_63               : 38;
 #endif
 	} s;
+	struct cvmx_pko_dqx_pointers_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t prev                         : 8;  /**< Previous pointer. The linked-list previous pointer. */
+	uint64_t reserved_8_15                : 8;
+	uint64_t next                         : 8;  /**< Next pointer. The linked-list next pointer. */
+#else
+	uint64_t next                         : 8;
+	uint64_t reserved_8_15                : 8;
+	uint64_t prev                         : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_dqx_pointers_s        cn78xx;
 };
 typedef union cvmx_pko_dqx_pointers cvmx_pko_dqx_pointers_t;
@@ -3521,6 +3671,7 @@ union cvmx_pko_dqx_sched_state {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_dqx_sched_state_s     cn73xx;
 	struct cvmx_pko_dqx_sched_state_s     cn78xx;
 };
 typedef union cvmx_pko_dqx_sched_state cvmx_pko_dqx_sched_state_t;
@@ -3560,6 +3711,7 @@ union cvmx_pko_dqx_schedule {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_pko_dqx_schedule_s        cn73xx;
 	struct cvmx_pko_dqx_schedule_s        cn78xx;
 };
 typedef union cvmx_pko_dqx_schedule cvmx_pko_dqx_schedule_t;
@@ -3567,7 +3719,7 @@ typedef union cvmx_pko_dqx_schedule cvmx_pko_dqx_schedule_t;
 /**
  * cvmx_pko_dq#_shape
  *
- * This register has the same bit fields as PKO_L5_SQ()_SHAPE.
+ * This register has the same bit fields as PKO_L3_SQ()_SHAPE.
  *
  */
 union cvmx_pko_dqx_shape {
@@ -3592,6 +3744,7 @@ union cvmx_pko_dqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_dqx_shape_s           cn73xx;
 	struct cvmx_pko_dqx_shape_s           cn78xx;
 };
 typedef union cvmx_pko_dqx_shape cvmx_pko_dqx_shape_t;
@@ -3623,6 +3776,7 @@ union cvmx_pko_dqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pko_dqx_shape_state_s     cn73xx;
 	struct cvmx_pko_dqx_shape_state_s     cn78xx;
 };
 typedef union cvmx_pko_dqx_shape_state cvmx_pko_dqx_shape_state_t;
@@ -3638,18 +3792,31 @@ union cvmx_pko_dqx_sw_xoff {
 	struct cvmx_pko_dqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set.  DRAIN_IRQ has no effect unless DRAIN and XOFF is also set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set.
+                                                         DRAIN_NULL_LINK has no effect unless DRAIN and XOFF is also set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared.  DRAIN has no effect unless XOFF is also set. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -3658,6 +3825,7 @@ union cvmx_pko_dqx_sw_xoff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pko_dqx_sw_xoff_s         cn73xx;
 	struct cvmx_pko_dqx_sw_xoff_s         cn78xx;
 };
 typedef union cvmx_pko_dqx_sw_xoff cvmx_pko_dqx_sw_xoff_t;
@@ -3678,6 +3846,17 @@ union cvmx_pko_dqx_topology {
 	uint64_t reserved_26_63               : 38;
 #endif
 	} s;
+	struct cvmx_pko_dqx_topology_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t parent                       : 8;  /**< See PKO_L2_SQ()_TOPOLOGY[PARENT]. */
+	uint64_t reserved_0_15                : 16;
+#else
+	uint64_t reserved_0_15                : 16;
+	uint64_t parent                       : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_dqx_topology_s        cn78xx;
 };
 typedef union cvmx_pko_dqx_topology cvmx_pko_dqx_topology_t;
@@ -3690,12 +3869,13 @@ union cvmx_pko_dqx_wm_buf_cnt {
 	struct cvmx_pko_dqx_wm_buf_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t count                        : 36; /**< Watermark buffer count. The running value of the buffer counter. */
+	uint64_t count                        : 36; /**< Reserved. */
 #else
 	uint64_t count                        : 36;
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_buf_cnt_s      cn73xx;
 	struct cvmx_pko_dqx_wm_buf_cnt_s      cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_buf_cnt cvmx_pko_dqx_wm_buf_cnt_t;
@@ -3708,16 +3888,11 @@ union cvmx_pko_dqx_wm_buf_ctl {
 	struct cvmx_pko_dqx_wm_buf_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t enable                       : 1;  /**< Watermark enable. */
+	uint64_t enable                       : 1;  /**< Reserved. */
 	uint64_t reserved_49_49               : 1;
-	uint64_t intr                         : 1;  /**< Watermark Buffer Interrupt. The interrupt bit is asserted and an interrupt message to the
-                                                         CIU is
-                                                         generated when the specified threshold is reached or crossed. Subsequent interrupt
-                                                         messages are only generated after this bit has been cleared. */
+	uint64_t intr                         : 1;  /**< Reserved. */
 	uint64_t reserved_36_47               : 12;
-	uint64_t threshold                    : 36; /**< Watermark Buffer Threshold. This threshold is compared to the watermark count of
-                                                         PKO_DQ()_WM_BUF_CNT[COUNT] and an interrupt is generated when the count reaches or
-                                                         crosses the threshold. */
+	uint64_t threshold                    : 36; /**< Reserved. */
 #else
 	uint64_t threshold                    : 36;
 	uint64_t reserved_36_47               : 12;
@@ -3727,6 +3902,7 @@ union cvmx_pko_dqx_wm_buf_ctl {
 	uint64_t reserved_51_63               : 13;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_buf_ctl_s      cn73xx;
 	struct cvmx_pko_dqx_wm_buf_ctl_s      cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_buf_ctl cvmx_pko_dqx_wm_buf_ctl_t;
@@ -3739,9 +3915,7 @@ union cvmx_pko_dqx_wm_buf_ctl_w1c {
 	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_49_63               : 15;
-	uint64_t intr                         : 1;  /**< Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is generated
-                                                         when the specified threshold is crossed. Subsequent interrupt messages are only generated
-                                                         after this bit has been cleared by writing 1. Throws PKO_INTSN_E::PKO_DQ()_WM_BUF. */
+	uint64_t intr                         : 1;  /**< Reserved. */
 	uint64_t reserved_0_47                : 48;
 #else
 	uint64_t reserved_0_47                : 48;
@@ -3749,6 +3923,7 @@ union cvmx_pko_dqx_wm_buf_ctl_w1c {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn73xx;
 	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_buf_ctl_w1c cvmx_pko_dqx_wm_buf_ctl_w1c_t;
@@ -3762,12 +3937,18 @@ union cvmx_pko_dqx_wm_cnt {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t count                        : 48; /**< Watermark count. The running value of the watermark counter. This value is a count of
-                                                         bytes or packets as specified in PKO_DQ()_WM_CTL[KIND]. */
+                                                         bytes or packets as specified by PKO_DQ()_WM_CTL[KIND]. [COUNT] covers all descriptors
+                                                         in the DQ between when the PKO SEND LMTDMA/LMTST enqueues the descriptor until
+                                                         PKO PEB (i.e. the packet engines and FIFO's) first receives the meta descriptor.
+                                                         It includes all descriptors whose meta's are held in either L2/DRAM for the DQ
+                                                         (i.e. whose metas are held in PKO PDM) or any DQ or SQ (i.e. whose metas are held
+                                                         in PKO PSE). */
 #else
 	uint64_t count                        : 48;
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_cnt_s          cn73xx;
 	struct cvmx_pko_dqx_wm_cnt_s          cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_cnt cvmx_pko_dqx_wm_cnt_t;
@@ -3779,10 +3960,13 @@ union cvmx_pko_dqx_wm_ctl {
 	uint64_t u64;
 	struct cvmx_pko_dqx_wm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_51_63               : 13;
+	uint64_t reserved_52_63               : 12;
+	uint64_t ncb_query_rsp                : 1;  /**< Reserved. */
 	uint64_t enable                       : 1;  /**< Watermark enable. */
-	uint64_t kind                         : 1;  /**< Watermark kind. The watermark logic can use a byte count or packet count. 0 = Byte count;
-                                                         1 = Packet count. */
+	uint64_t kind                         : 1;  /**< Selects the contents of PKO_DQ()_WM_CNT[COUNT].
+                                                         If [KIND] is clear, PKO_DQ()_WM_CNT[COUNT] is the byte count in the DQ - the
+                                                         sum of the Meta[LENGTH]'s in the DQ, where Meta[LENGTH] is the Meta packet length.
+                                                         If [KIND] is set, PKO_DQ()_WM_CNT[COUNT] is the number of descriptors in the DQ. */
 	uint64_t intr                         : 1;  /**< Watermark Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is
                                                          generated when the specified threshold is reached or crossed. Subsequent interrupt
                                                          messages are only generated after this bit has been cleared. */
@@ -3794,9 +3978,11 @@ union cvmx_pko_dqx_wm_ctl {
 	uint64_t intr                         : 1;
 	uint64_t kind                         : 1;
 	uint64_t enable                       : 1;
-	uint64_t reserved_51_63               : 13;
+	uint64_t ncb_query_rsp                : 1;
+	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_ctl_s          cn73xx;
 	struct cvmx_pko_dqx_wm_ctl_s          cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_ctl cvmx_pko_dqx_wm_ctl_t;
@@ -3819,6 +4005,7 @@ union cvmx_pko_dqx_wm_ctl_w1c {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_ctl_w1c_s      cn73xx;
 	struct cvmx_pko_dqx_wm_ctl_w1c_s      cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_ctl_w1c cvmx_pko_dqx_wm_ctl_w1c_t;
@@ -3835,6 +4022,7 @@ union cvmx_pko_dq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_dq_csr_bus_debug_s    cn73xx;
 	struct cvmx_pko_dq_csr_bus_debug_s    cn78xx;
 };
 typedef union cvmx_pko_dq_csr_bus_debug cvmx_pko_dq_csr_bus_debug_t;
@@ -3851,6 +4039,7 @@ union cvmx_pko_dq_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_dq_debug_s            cn73xx;
 	struct cvmx_pko_dq_debug_s            cn78xx;
 };
 typedef union cvmx_pko_dq_debug cvmx_pko_dq_debug_t;
@@ -3872,6 +4061,7 @@ union cvmx_pko_drain_irq {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_drain_irq_s           cn73xx;
 	struct cvmx_pko_drain_irq_s           cn78xx;
 };
 typedef union cvmx_pko_drain_irq cvmx_pko_drain_irq_t;
@@ -3890,6 +4080,7 @@ union cvmx_pko_enable {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_enable_s              cn73xx;
 	struct cvmx_pko_enable_s              cn78xx;
 };
 typedef union cvmx_pko_enable cvmx_pko_enable_t;
@@ -3904,18 +4095,15 @@ typedef union cvmx_pko_enable cvmx_pko_enable_t;
  *
  * For example, if MARKPTR is 3 and [OFFSET] is 5 and the packet is YELLOW,
  * the PKO marking hardware would do this:
- *
- * _  byte[3]<2:0> |=   Y_VAL<3:1>
- * _  byte[3]<2:0> &= ~Y_MASK<3:1>
- * _  byte[4]<7>   |=   Y_VAL<0>
- * _  byte[4]<7>   &= ~Y_MASK<0>
- *
+ *    byte[3]<2:0> |=   Y_VAL<3:1>
+ *    byte[3]<2:0> &= ~Y_MASK<3:1>
+ *    byte[4]<7>   |=   Y_VAL<0>
+ *    byte[4]<7>   &= ~Y_MASK<0>
  * where byte[3] is the 3rd byte in the packet, and byte[4] the 4th.
  *
  * For another example, if MARKPTR is 3 and [OFFSET] is 0 and the packet is RED_SEND,
- *
- * _   byte[3]<7:4> |=   R_VAL<3:0>
- * _   byte[3]<7:4> &= ~R_MASK<3:0>
+ *    byte[3]<7:4> |=   R_VAL<3:0>
+ *    byte[3]<7:4> &= ~R_MASK<3:0>
  */
 union cvmx_pko_formatx_ctl {
 	uint64_t u64;
@@ -3942,6 +4130,7 @@ union cvmx_pko_formatx_ctl {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_pko_formatx_ctl_s         cn73xx;
 	struct cvmx_pko_formatx_ctl_s         cn78xx;
 };
 typedef union cvmx_pko_formatx_ctl cvmx_pko_formatx_ctl_t;
@@ -3967,10 +4156,12 @@ union cvmx_pko_l1_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -3985,6 +4176,7 @@ union cvmx_pko_l1_sqx_cir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_cir_s          cn73xx;
 	struct cvmx_pko_l1_sqx_cir_s          cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_cir cvmx_pko_l1_sqx_cir_t;
@@ -4006,6 +4198,7 @@ union cvmx_pko_l1_sqx_dropped_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_dropped_bytes_s cn73xx;
 	struct cvmx_pko_l1_sqx_dropped_bytes_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_dropped_bytes cvmx_pko_l1_sqx_dropped_bytes_t;
@@ -4027,6 +4220,7 @@ union cvmx_pko_l1_sqx_dropped_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_dropped_packets_s cn73xx;
 	struct cvmx_pko_l1_sqx_dropped_packets_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_dropped_packets cvmx_pko_l1_sqx_dropped_packets_t;
@@ -4060,6 +4254,7 @@ union cvmx_pko_l1_sqx_green {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_green_s        cn73xx;
 	struct cvmx_pko_l1_sqx_green_s        cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_green cvmx_pko_l1_sqx_green_t;
@@ -4078,6 +4273,7 @@ union cvmx_pko_l1_sqx_green_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_green_bytes_s  cn73xx;
 	struct cvmx_pko_l1_sqx_green_bytes_s  cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_green_bytes cvmx_pko_l1_sqx_green_bytes_t;
@@ -4096,6 +4292,7 @@ union cvmx_pko_l1_sqx_green_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_green_packets_s cn73xx;
 	struct cvmx_pko_l1_sqx_green_packets_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_green_packets cvmx_pko_l1_sqx_green_packets_t;
@@ -4134,12 +4331,44 @@ union cvmx_pko_l1_sqx_link {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_link_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t link                         : 4;  /**< Link index. Must match PKO_L1_SQ()_TOPOLOGY[LINK]. */
+	uint64_t reserved_32_43               : 12;
+	uint64_t cc_word_cnt                  : 20; /**< Channel credit word count. This value, plus 1 MTU, represents the maximum outstanding
+                                                         aggregate word count (words are 16 bytes) for all channels feeding into this PQ. Note that
+                                                         this 20-bit field represents a signed value that decrements towards zero as credits are
+                                                         used. Packets are not allowed to flow when the count is less than zero. As such, the most
+                                                         significant bit should normally be programmed as zero (positive count). This gives a
+                                                         maximum value for this field of 2^19 - 1. */
+	uint64_t cc_packet_cnt                : 10; /**< Channel credit packet count. This value, plus 1, represents the maximum outstanding
+                                                         aggregate packet count for all channels feeding into this PQ. Note that this 10-bit field
+                                                         represents a signed value that decrements towards zero as credits are used. Packets are
+                                                         not allowed to flow when the count is less than zero. As such the most significant bit
+                                                         should normally be programmed as zero (positive count). This gives a maximum value for
+                                                         this field of 2^9 - 1. */
+	uint64_t cc_enable                    : 1;  /**< Channel credit enable. Enables CC_WORD_CNT and CC_PACKET_CNT aggregate credit processing. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t cc_enable                    : 1;
+	uint64_t cc_packet_cnt                : 10;
+	uint64_t cc_word_cnt                  : 20;
+	uint64_t reserved_32_43               : 12;
+	uint64_t link                         : 4;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l1_sqx_link_s         cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_link cvmx_pko_l1_sqx_link_t;
 
 /**
  * cvmx_pko_l1_sq#_pick
+ *
+ * This CSR contains the meta for the L1 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l1_sqx_pick {
 	uint64_t u64;
@@ -4157,8 +4386,10 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -4195,6 +4426,7 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t dq                           : 10;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_pick_s         cn73xx;
 	struct cvmx_pko_l1_sqx_pick_s         cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_pick cvmx_pko_l1_sqx_pick_t;
@@ -4220,6 +4452,7 @@ union cvmx_pko_l1_sqx_red {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_red_s          cn73xx;
 	struct cvmx_pko_l1_sqx_red_s          cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_red cvmx_pko_l1_sqx_red_t;
@@ -4241,6 +4474,7 @@ union cvmx_pko_l1_sqx_red_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_red_bytes_s    cn73xx;
 	struct cvmx_pko_l1_sqx_red_bytes_s    cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_red_bytes cvmx_pko_l1_sqx_red_bytes_t;
@@ -4262,6 +4496,7 @@ union cvmx_pko_l1_sqx_red_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_red_packets_s  cn73xx;
 	struct cvmx_pko_l1_sqx_red_packets_s  cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_red_packets cvmx_pko_l1_sqx_red_packets_t;
@@ -4280,6 +4515,18 @@ union cvmx_pko_l1_sqx_schedule {
 	uint64_t dummy                        : 40;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_schedule_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
+                                                         integer).
+                                                         Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
+                                                         negative accumulations of the deficit count). */
+#else
+	uint64_t rr_quantum                   : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l1_sqx_schedule_s     cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_schedule cvmx_pko_l1_sqx_schedule_t;
@@ -4306,6 +4553,27 @@ union cvmx_pko_l1_sqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_shape_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
+	uint64_t reserved_17_23               : 7;
+	uint64_t link                         : 4;  /**< Link index. Must match PKO_L1_SQ()_TOPOLOGY[LINK]. */
+	uint64_t reserved_9_12                : 4;
+	uint64_t adjust                       : 9;  /**< Shaping and scheduling calculation adjustment. This 9-bit signed value
+                                                         allows -255 .. 255 bytes to be added to the packet length for rate
+                                                         limiting and scheduling calculations. [ADJUST] value 0x100 should
+                                                         not be used. */
+#else
+	uint64_t adjust                       : 9;
+	uint64_t reserved_9_12                : 4;
+	uint64_t link                         : 4;
+	uint64_t reserved_17_23               : 7;
+	uint64_t length_disable               : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l1_sqx_shape_s        cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_shape cvmx_pko_l1_sqx_shape_t;
@@ -4334,6 +4602,7 @@ union cvmx_pko_l1_sqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_shape_state_s  cn73xx;
 	struct cvmx_pko_l1_sqx_shape_state_s  cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_shape_state cvmx_pko_l1_sqx_shape_state_t;
@@ -4346,18 +4615,31 @@ union cvmx_pko_l1_sqx_sw_xoff {
 	struct cvmx_pko_l1_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set.  DRAIN_IRQ has no effect unless DRAIN and XOFF is also set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set.
+                                                         DRAIN_NULL_LINK has no effect unless DRAIN and XOFF is also set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared.  DRAIN has no effect unless XOFF is also set. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -4366,6 +4648,7 @@ union cvmx_pko_l1_sqx_sw_xoff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_sw_xoff_s      cn73xx;
 	struct cvmx_pko_l1_sqx_sw_xoff_s      cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_sw_xoff cvmx_pko_l1_sqx_sw_xoff_t;
@@ -4435,6 +4718,65 @@ union cvmx_pko_l1_sqx_topology {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_topology_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t prio_anchor                  : 8;  /**< Priority Anchor. The base index positioning the static priority child queues of this
+                                                         shaper. A higher-level queue is a child queue of this shaper when its
+                                                         PKO_*_TOPOLOGY[PARENT] selects this shaper, and it further is a static priority child
+                                                         queue when its PKO_*_SQn_SCHEDULE[PRIO] does not equal RR_PRIO. A static priority child
+                                                         queue with priority PRIO must be located at n=PRIO_ANCHOR+PRIO, where
+                                                         PRIO=PKO_*_SQn_SCHEDULE[PRIO]. There can be at most one static priority child queue at
+                                                         each priority. When there are no static priority child queues attached at any priority, or
+                                                         if this shaper isn't used, the hardware does not use PRIO_ANCHOR. In this case, we
+                                                         recommend PRIO_ANCHOR be zero. Note that there are 10 available priorities, 0 through 9,
+                                                         with priority 0 being the highest and priority 9 being the lowest. */
+	uint64_t reserved_20_31               : 12;
+	uint64_t link                         : 4;  /**< Link index. Selects the MAC or NULL FIFO used by the L1 SQ.
+                                                         Legal [LINK] values:
+                                                         <pre>
+                                                                          Relevant
+                                                           [LINK]    PKO_MAC()_CFG CSR    Description
+                                                          -------------------------------------------------
+                                                             0         PKO_MAC0_CFG      LBK loopback
+                                                             1         PKO_MAC1_CFG      DPI packet output
+                                                             2         PKO_MAC2_CFG      BGX0 logical MAC 0
+                                                             3         PKO_MAC3_CFG      BGX0 logical MAC 1
+                                                             4         PKO_MAC4_CFG      BGX0 logical MAC 2
+                                                             5         PKO_MAC5_CFG      BGX0 logical MAC 3
+                                                             6         PKO_MAC6_CFG      BGX1 logical MAC 0
+                                                             7         PKO_MAC7_CFG      BGX1 logical MAC 1
+                                                             8         PKO_MAC8_CFG      BGX1 logical MAC 2
+                                                             9         PKO_MAC9_CFG      BGX1 logical MAC 3
+                                                            10         PKO_MAC10_CFG     BGX2 logical MAC 0
+                                                            11         PKO_MAC11_CFG     BGX2 logical MAC 1
+                                                            12         PKO_MAC12_CFG     BGX2 logical MAC 2
+                                                            13         PKO_MAC13_CFG     BGX2 logical MAC 3
+                                                            14            None           NULL FIFO
+                                                         </pre>
+                                                         When a MAC is used by the L1 SQ, [LINK] must be unique relative to
+                                                         other [LINK]'s. [LINK] should be 14 when the L1 SQ is not used. */
+	uint64_t reserved_5_15                : 11;
+	uint64_t rr_prio                      : 4;  /**< Round-robin priority. The priority assigned to the round-robin scheduler. A higher-level
+                                                         queue is a child queue of this shaper when its PKO_*_TOPOLOGY[PARENT] selects this shaper,
+                                                         and it further is a round robin child queue when its PKO_*_SQn_SCHEDULE[PRIO] equals
+                                                         RR_PRIO. All round-robin queues attached to this shaper must have the same priority. But
+                                                         the number of round-robin child queues attached (at this priority) is limited only by the
+                                                         number of higher-level queues. When this shaper is not used, we recommend RR_PRIO be zero.
+                                                         When a shaper is used, RR_PRIO should be 0xF when there are no priorities with more than
+                                                         one child queue (i.e. when there are no round-robin child queues), and should otherwise be
+                                                         a legal priority (values 0-9). */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t rr_prio                      : 4;
+	uint64_t reserved_5_15                : 11;
+	uint64_t link                         : 4;
+	uint64_t reserved_20_31               : 12;
+	uint64_t prio_anchor                  : 8;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l1_sqx_topology_s     cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_topology cvmx_pko_l1_sqx_topology_t;
@@ -4457,6 +4799,7 @@ union cvmx_pko_l1_sqx_yellow {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_yellow_s       cn73xx;
 	struct cvmx_pko_l1_sqx_yellow_s       cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_yellow cvmx_pko_l1_sqx_yellow_t;
@@ -4478,6 +4821,7 @@ union cvmx_pko_l1_sqx_yellow_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_yellow_bytes_s cn73xx;
 	struct cvmx_pko_l1_sqx_yellow_bytes_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_yellow_bytes cvmx_pko_l1_sqx_yellow_bytes_t;
@@ -4499,6 +4843,7 @@ union cvmx_pko_l1_sqx_yellow_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_yellow_packets_s cn73xx;
 	struct cvmx_pko_l1_sqx_yellow_packets_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_yellow_packets cvmx_pko_l1_sqx_yellow_packets_t;
@@ -4515,6 +4860,7 @@ union cvmx_pko_l1_sq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_l1_sq_csr_bus_debug_s cn73xx;
 	struct cvmx_pko_l1_sq_csr_bus_debug_s cn78xx;
 };
 typedef union cvmx_pko_l1_sq_csr_bus_debug cvmx_pko_l1_sq_csr_bus_debug_t;
@@ -4534,6 +4880,7 @@ union cvmx_pko_l1_sqa_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqa_debug_s        cn73xx;
 	struct cvmx_pko_l1_sqa_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l1_sqa_debug cvmx_pko_l1_sqa_debug_t;
@@ -4553,6 +4900,7 @@ union cvmx_pko_l1_sqb_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqb_debug_s        cn73xx;
 	struct cvmx_pko_l1_sqb_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l1_sqb_debug cvmx_pko_l1_sqb_debug_t;
@@ -4581,10 +4929,12 @@ union cvmx_pko_l2_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -4599,6 +4949,7 @@ union cvmx_pko_l2_sqx_cir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_cir_s          cn73xx;
 	struct cvmx_pko_l2_sqx_cir_s          cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_cir cvmx_pko_l2_sqx_cir_t;
@@ -4635,6 +4986,7 @@ union cvmx_pko_l2_sqx_green {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_green_s        cn73xx;
 	struct cvmx_pko_l2_sqx_green_s        cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_green cvmx_pko_l2_sqx_green_t;
@@ -4642,8 +4994,8 @@ typedef union cvmx_pko_l2_sqx_green cvmx_pko_l2_sqx_green_t;
 /**
  * cvmx_pko_l2_sq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the L2 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l2_sqx_pick {
 	uint64_t u64;
@@ -4661,8 +5013,10 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -4699,6 +5053,7 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t dq                           : 10;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_pick_s         cn73xx;
 	struct cvmx_pko_l2_sqx_pick_s         cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_pick cvmx_pko_l2_sqx_pick_t;
@@ -4727,10 +5082,12 @@ union cvmx_pko_l2_sqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -4745,6 +5102,7 @@ union cvmx_pko_l2_sqx_pir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_pir_s          cn73xx;
 	struct cvmx_pko_l2_sqx_pir_s          cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_pir cvmx_pko_l2_sqx_pir_t;
@@ -4767,6 +5125,19 @@ union cvmx_pko_l2_sqx_pointers {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_pointers_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t prev                         : 8;  /**< Previous pointer. The linked-list previous pointer. */
+	uint64_t reserved_8_15                : 8;
+	uint64_t next                         : 8;  /**< Next pointer. The linked-list next pointer. */
+#else
+	uint64_t next                         : 8;
+	uint64_t reserved_8_15                : 8;
+	uint64_t prev                         : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l2_sqx_pointers_s     cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_pointers cvmx_pko_l2_sqx_pointers_t;
@@ -4792,6 +5163,7 @@ union cvmx_pko_l2_sqx_red {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_red_s          cn73xx;
 	struct cvmx_pko_l2_sqx_red_s          cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_red cvmx_pko_l2_sqx_red_t;
@@ -4810,6 +5182,7 @@ union cvmx_pko_l2_sqx_sched_state {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_sched_state_s  cn73xx;
 	struct cvmx_pko_l2_sqx_sched_state_s  cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_sched_state cvmx_pko_l2_sqx_sched_state_t;
@@ -4846,6 +5219,7 @@ union cvmx_pko_l2_sqx_schedule {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_schedule_s     cn73xx;
 	struct cvmx_pko_l2_sqx_schedule_s     cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_schedule cvmx_pko_l2_sqx_schedule_t;
@@ -4859,8 +5233,7 @@ union cvmx_pko_l2_sqx_shape {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
-                                                         and shaping calculations such that only the values of
-                                                         [ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when
                                                          set. Not used by hardware when corresponding PKO_*_CIR[ENABLE] is clear. */
@@ -4892,8 +5265,8 @@ union cvmx_pko_l2_sqx_shape {
                                                                affecting any RR_COUNT, CIR_ACCUM, or PIR_ACCUM state, and are then
                                                                discarded by PKO. See also PKO_REDALG_E::DISCARD. */
 	uint64_t adjust                       : 9;  /**< Shaping and scheduling calculation adjustment. This 9-bit signed value allows
-                                                         +/- 256 bytes to be added to the packet length for shaping and scheduling
-                                                         calculations. */
+                                                         -255 .. 255 bytes to be added to the packet length for shaping and scheduling
+                                                         calculations. [ADJUST] value 0x100 should not be used. */
 #else
 	uint64_t adjust                       : 9;
 	uint64_t red_algo                     : 2;
@@ -4904,6 +5277,7 @@ union cvmx_pko_l2_sqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_shape_s        cn73xx;
 	struct cvmx_pko_l2_sqx_shape_s        cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_shape cvmx_pko_l2_sqx_shape_t;
@@ -4932,6 +5306,7 @@ union cvmx_pko_l2_sqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_shape_state_s  cn73xx;
 	struct cvmx_pko_l2_sqx_shape_state_s  cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_shape_state cvmx_pko_l2_sqx_shape_state_t;
@@ -4947,18 +5322,31 @@ union cvmx_pko_l2_sqx_sw_xoff {
 	struct cvmx_pko_l2_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set.  DRAIN_IRQ has no effect unless DRAIN and XOFF is also set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set.
+                                                         DRAIN_NULL_LINK has no effect unless DRAIN and XOFF is also set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared.  DRAIN has no effect unless XOFF is also set. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -4967,6 +5355,7 @@ union cvmx_pko_l2_sqx_sw_xoff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_sw_xoff_s      cn73xx;
 	struct cvmx_pko_l2_sqx_sw_xoff_s      cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_sw_xoff cvmx_pko_l2_sqx_sw_xoff_t;
@@ -4999,18 +5388,41 @@ union cvmx_pko_l2_sqx_topology {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
-	struct cvmx_pko_l2_sqx_topology_s     cn78xx;
-};
-typedef union cvmx_pko_l2_sqx_topology cvmx_pko_l2_sqx_topology_t;
-
-/**
- * cvmx_pko_l2_sq#_yellow
- *
- * This register has the same bit fields as PKO_L1_SQ()_YELLOW.
- *
- */
-union cvmx_pko_l2_sqx_yellow {
-	uint64_t u64;
+	struct cvmx_pko_l2_sqx_topology_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t prio_anchor                  : 8;  /**< See PKO_L1_SQ()_TOPOLOGY[PRIO_ANCHOR]. */
+	uint64_t reserved_20_31               : 12;
+	uint64_t parent                       : 4;  /**< Parent queue index. The index of the shaping element at the next lower hierarchical level
+                                                         that accepts this shaping element's outputs. Refer to the PKO_*_SQn_TOPOLOGY
+                                                         [PRIO_ANCHOR,RR_PRIO] descriptions for constraints on which child queues can attach to
+                                                         which shapers at the next lower level. When this shaper is unused, we recommend that
+                                                         PARENT be zero. */
+	uint64_t reserved_5_15                : 11;
+	uint64_t rr_prio                      : 4;  /**< See PKO_L1_SQ()_TOPOLOGY[RR_PRIO]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t rr_prio                      : 4;
+	uint64_t reserved_5_15                : 11;
+	uint64_t parent                       : 4;
+	uint64_t reserved_20_31               : 12;
+	uint64_t prio_anchor                  : 8;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} cn73xx;
+	struct cvmx_pko_l2_sqx_topology_s     cn78xx;
+};
+typedef union cvmx_pko_l2_sqx_topology cvmx_pko_l2_sqx_topology_t;
+
+/**
+ * cvmx_pko_l2_sq#_yellow
+ *
+ * This register has the same bit fields as PKO_L1_SQ()_YELLOW.
+ *
+ */
+union cvmx_pko_l2_sqx_yellow {
+	uint64_t u64;
 	struct cvmx_pko_l2_sqx_yellow_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_19_63               : 45;
@@ -5024,6 +5436,7 @@ union cvmx_pko_l2_sqx_yellow {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_yellow_s       cn73xx;
 	struct cvmx_pko_l2_sqx_yellow_s       cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_yellow cvmx_pko_l2_sqx_yellow_t;
@@ -5040,6 +5453,7 @@ union cvmx_pko_l2_sq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_l2_sq_csr_bus_debug_s cn73xx;
 	struct cvmx_pko_l2_sq_csr_bus_debug_s cn78xx;
 };
 typedef union cvmx_pko_l2_sq_csr_bus_debug cvmx_pko_l2_sq_csr_bus_debug_t;
@@ -5059,6 +5473,7 @@ union cvmx_pko_l2_sqa_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqa_debug_s        cn73xx;
 	struct cvmx_pko_l2_sqa_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l2_sqa_debug cvmx_pko_l2_sqa_debug_t;
@@ -5078,6 +5493,7 @@ union cvmx_pko_l2_sqb_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqb_debug_s        cn73xx;
 	struct cvmx_pko_l2_sqb_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l2_sqb_debug cvmx_pko_l2_sqb_debug_t;
@@ -5103,8 +5519,10 @@ union cvmx_pko_l3_l2_sqx_channel {
                                                          count is less than zero. As such the most significant bit should normally be programmed as
                                                          zero (positive count). This gives a maximum value for this field of 2^9 - 1. */
 	uint64_t cc_enable                    : 1;  /**< Channel credit enable. Enables CC_WORD_CNT and CC_PACKET_CNT credit processing. */
-	uint64_t hw_xoff                      : 1;  /**< Hardware XOFF status. The status of hardware XON/XOFF. This is writable to get around LUT
-                                                         issues and for reconfiguration. */
+	uint64_t hw_xoff                      : 1;  /**< Hardware XOFF status. The status of hardware XON/XOFF (i.e. hardware channel
+                                                         backpressure).  This is writable to get around LUT issues and for reconfiguration.
+                                                         [HW_XOFF] should only be set when there is a valid PKO_LUT entry pointing to the SQ
+                                                         which is being backpressured. */
 #else
 	uint64_t hw_xoff                      : 1;
 	uint64_t cc_enable                    : 1;
@@ -5114,6 +5532,7 @@ union cvmx_pko_l3_l2_sqx_channel {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_l3_l2_sqx_channel_s   cn73xx;
 	struct cvmx_pko_l3_l2_sqx_channel_s   cn78xx;
 };
 typedef union cvmx_pko_l3_l2_sqx_channel cvmx_pko_l3_l2_sqx_channel_t;
@@ -5142,10 +5561,12 @@ union cvmx_pko_l3_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -5160,6 +5581,7 @@ union cvmx_pko_l3_sqx_cir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_cir_s          cn73xx;
 	struct cvmx_pko_l3_sqx_cir_s          cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_cir cvmx_pko_l3_sqx_cir_t;
@@ -5185,6 +5607,26 @@ union cvmx_pko_l3_sqx_green {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_green_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_41_63               : 23;
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
+                                                         scheduling queue are active. For internal use only. */
+	uint64_t reserved_18_19               : 2;
+	uint64_t head                         : 8;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t reserved_8_9                 : 2;
+	uint64_t tail                         : 8;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
+#else
+	uint64_t tail                         : 8;
+	uint64_t reserved_8_9                 : 2;
+	uint64_t head                         : 8;
+	uint64_t reserved_18_19               : 2;
+	uint64_t active_vec                   : 20;
+	uint64_t rr_active                    : 1;
+	uint64_t reserved_41_63               : 23;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_green_s        cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_green cvmx_pko_l3_sqx_green_t;
@@ -5192,8 +5634,8 @@ typedef union cvmx_pko_l3_sqx_green cvmx_pko_l3_sqx_green_t;
 /**
  * cvmx_pko_l3_sq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the L3 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l3_sqx_pick {
 	uint64_t u64;
@@ -5211,8 +5653,10 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -5249,6 +5693,7 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t dq                           : 10;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_pick_s         cn73xx;
 	struct cvmx_pko_l3_sqx_pick_s         cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_pick cvmx_pko_l3_sqx_pick_t;
@@ -5256,7 +5701,7 @@ typedef union cvmx_pko_l3_sqx_pick cvmx_pko_l3_sqx_pick_t;
 /**
  * cvmx_pko_l3_sq#_pir
  *
- * This register has the same bit fields as PKO_L1_SQ()_CIR.
+ * This register has the same bit fields as PKO_L1_SQ(0..15)_CIR.
  *
  */
 union cvmx_pko_l3_sqx_pir {
@@ -5277,10 +5722,12 @@ union cvmx_pko_l3_sqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -5295,6 +5742,7 @@ union cvmx_pko_l3_sqx_pir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_pir_s          cn73xx;
 	struct cvmx_pko_l3_sqx_pir_s          cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_pir cvmx_pko_l3_sqx_pir_t;
@@ -5320,6 +5768,19 @@ union cvmx_pko_l3_sqx_pointers {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_pointers_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t prev                         : 8;  /**< Previous pointer. The linked-list previous pointer. */
+	uint64_t reserved_8_15                : 8;
+	uint64_t next                         : 8;  /**< Next pointer. The linked-list next pointer. */
+#else
+	uint64_t next                         : 8;
+	uint64_t reserved_8_15                : 8;
+	uint64_t prev                         : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_pointers_s     cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_pointers cvmx_pko_l3_sqx_pointers_t;
@@ -5343,6 +5804,19 @@ union cvmx_pko_l3_sqx_red {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_red_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_18_63               : 46;
+	uint64_t head                         : 8;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t reserved_8_9                 : 2;
+	uint64_t tail                         : 8;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
+#else
+	uint64_t tail                         : 8;
+	uint64_t reserved_8_9                 : 2;
+	uint64_t head                         : 8;
+	uint64_t reserved_18_63               : 46;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_red_s          cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_red cvmx_pko_l3_sqx_red_t;
@@ -5350,7 +5824,7 @@ typedef union cvmx_pko_l3_sqx_red cvmx_pko_l3_sqx_red_t;
 /**
  * cvmx_pko_l3_sq#_sched_state
  *
- * This register has the same bit fields as PKO_L2_SQ()_SCHED_STATE.
+ * This register has the same bit fields as PKO_L2_SQ(0..255)_SCHED_STATE.
  *
  */
 union cvmx_pko_l3_sqx_sched_state {
@@ -5364,6 +5838,7 @@ union cvmx_pko_l3_sqx_sched_state {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_sched_state_s  cn73xx;
 	struct cvmx_pko_l3_sqx_sched_state_s  cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_sched_state cvmx_pko_l3_sqx_sched_state_t;
@@ -5403,6 +5878,7 @@ union cvmx_pko_l3_sqx_schedule {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_schedule_s     cn73xx;
 	struct cvmx_pko_l3_sqx_schedule_s     cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_schedule cvmx_pko_l3_sqx_schedule_t;
@@ -5432,6 +5908,7 @@ union cvmx_pko_l3_sqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_shape_s        cn73xx;
 	struct cvmx_pko_l3_sqx_shape_s        cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_shape cvmx_pko_l3_sqx_shape_t;
@@ -5463,6 +5940,7 @@ union cvmx_pko_l3_sqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_shape_state_s  cn73xx;
 	struct cvmx_pko_l3_sqx_shape_state_s  cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_shape_state cvmx_pko_l3_sqx_shape_state_t;
@@ -5478,18 +5956,31 @@ union cvmx_pko_l3_sqx_sw_xoff {
 	struct cvmx_pko_l3_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set.  DRAIN_IRQ has no effect unless DRAIN and XOFF is also set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set.
+                                                         DRAIN_NULL_LINK has no effect unless DRAIN and XOFF is also set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared.  DRAIN has no effect unless XOFF is also set. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -5498,6 +5989,7 @@ union cvmx_pko_l3_sqx_sw_xoff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_sw_xoff_s      cn73xx;
 	struct cvmx_pko_l3_sqx_sw_xoff_s      cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_sw_xoff cvmx_pko_l3_sqx_sw_xoff_t;
@@ -5526,6 +6018,25 @@ union cvmx_pko_l3_sqx_topology {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_topology_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t prio_anchor                  : 8;  /**< See PKO_L1_SQ()_TOPOLOGY[PRIO_ANCHOR]. */
+	uint64_t reserved_24_31               : 8;
+	uint64_t parent                       : 8;  /**< See PKO_L2_SQ()_TOPOLOGY[PARENT]. */
+	uint64_t reserved_5_15                : 11;
+	uint64_t rr_prio                      : 4;  /**< See PKO_L1_SQ()_TOPOLOGY[RR_PRIO]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t rr_prio                      : 4;
+	uint64_t reserved_5_15                : 11;
+	uint64_t parent                       : 8;
+	uint64_t reserved_24_31               : 8;
+	uint64_t prio_anchor                  : 8;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_topology_s     cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_topology cvmx_pko_l3_sqx_topology_t;
@@ -5546,6 +6057,19 @@ union cvmx_pko_l3_sqx_yellow {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_yellow_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_18_63               : 46;
+	uint64_t head                         : 8;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t reserved_8_9                 : 2;
+	uint64_t tail                         : 8;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
+#else
+	uint64_t tail                         : 8;
+	uint64_t reserved_8_9                 : 2;
+	uint64_t head                         : 8;
+	uint64_t reserved_18_63               : 46;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_yellow_s       cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_yellow cvmx_pko_l3_sqx_yellow_t;
@@ -5562,6 +6086,7 @@ union cvmx_pko_l3_sq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_l3_sq_csr_bus_debug_s cn73xx;
 	struct cvmx_pko_l3_sq_csr_bus_debug_s cn78xx;
 };
 typedef union cvmx_pko_l3_sq_csr_bus_debug cvmx_pko_l3_sq_csr_bus_debug_t;
@@ -5581,6 +6106,7 @@ union cvmx_pko_l3_sqa_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqa_debug_s        cn73xx;
 	struct cvmx_pko_l3_sqa_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l3_sqa_debug cvmx_pko_l3_sqa_debug_t;
@@ -5600,6 +6126,7 @@ union cvmx_pko_l3_sqb_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqb_debug_s        cn73xx;
 	struct cvmx_pko_l3_sqb_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l3_sqb_debug cvmx_pko_l3_sqb_debug_t;
@@ -5628,10 +6155,12 @@ union cvmx_pko_l4_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -5681,8 +6210,8 @@ typedef union cvmx_pko_l4_sqx_green cvmx_pko_l4_sqx_green_t;
 /**
  * cvmx_pko_l4_sq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the L4 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l4_sqx_pick {
 	uint64_t u64;
@@ -5700,8 +6229,10 @@ union cvmx_pko_l4_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -5766,10 +6297,12 @@ union cvmx_pko_l4_sqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -5967,18 +6500,31 @@ union cvmx_pko_l4_sqx_sw_xoff {
 	struct cvmx_pko_l4_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set.  DRAIN_IRQ has no effect unless DRAIN and XOFF is also set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set.
+                                                         DRAIN_NULL_LINK has no effect unless DRAIN and XOFF is also set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared.  DRAIN has no effect unless XOFF is also set. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -6120,10 +6666,12 @@ union cvmx_pko_l5_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -6173,8 +6721,8 @@ typedef union cvmx_pko_l5_sqx_green cvmx_pko_l5_sqx_green_t;
 /**
  * cvmx_pko_l5_sq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the L5 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l5_sqx_pick {
 	uint64_t u64;
@@ -6192,8 +6740,10 @@ union cvmx_pko_l5_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -6258,10 +6808,12 @@ union cvmx_pko_l5_sqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -6459,18 +7011,31 @@ union cvmx_pko_l5_sqx_sw_xoff {
 	struct cvmx_pko_l5_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set.  DRAIN_IRQ has no effect unless DRAIN and XOFF is also set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set.
+                                                         DRAIN_NULL_LINK has no effect unless DRAIN and XOFF is also set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared.  DRAIN has no effect unless XOFF is also set. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -6599,25 +7164,20 @@ typedef union cvmx_pko_l5_sqb_debug cvmx_pko_l5_sqb_debug_t;
  *   LINK/   PKI_CHAN_E    Corresponding
  * MAC_NUM   Range         PKO_LUT index   Description
  * -------   -----------   -------------   -----------------
- *    0      0x000-0x03F   0x3C0-0x3FF     LBK Loopback
- *    1      0x100-0x13F   0x380-0x3BF     DPI packet output
- *    2      0x400-0x4FF   0x000-0x0FF     ILK link 0
- *    3      0x500-0x5FF   0x100-0x1FF     ILK link 1
- *    4      0x800-0x80F   0x200-0x20F     BGX0 Logical MAC 0
- *    5      0x810-0x81F   0x210-0x21F     BGX0 Logical MAC 1
- *    6      0x820-0x82F   0x220-0x22F     BGX0 Logical MAC 2
- *    7      0x830-0x83F   0x230-0x23F     BGX0 Logical MAC 3
- *    8      0x900-0x90F   0x240-0x24F     BGX1 Logical MAC 0
- *    9      0x910-0x91F   0x250-0x25F     BGX1 Logical MAC 1
- *   10      0x920-0x92F   0x260-0x26F     BGX1 Logical MAC 2
- *   11      0x930-0x93F   0x270-0x27F     BGX1 Logical MAC 3
- *   12      0xA00-0xA0F   0x280-0x28F     BGX2 Logical MAC 0
- *   13      0xA10-0xA1F   0x290-0x29F     BGX2 Logical MAC 1
- *   ...         ...           ...               ...
- *   24      0xD00-0xD0F   0x340-0x34F     BGX5 Logical MAC 0
- *   25      0xD10-0xD1F   0x350-0x35F     BGX5 Logical MAC 1
- *   26      0xD20-0xD2F   0x360-0x36F     BGX5 Logical MAC 2
- *   27      0xD30-0xD3F   0x370-0x37F     BGX5 Logical MAC 3
+ *     0     0x000-0x03F   0x0C0-0x0FF     LBK Loopback
+ *     1     0x100-0x17F   0x100-0x17F     DPI packet output
+ *     2     0x800-0x80F   0x000-0x00F     BGX0 Logical MAC 0
+ *     3     0x810-0x81F   0x010-0x01F     BGX0 Logical MAC 1
+ *     4     0x820-0x82F   0x020-0x02F     BGX0 Logical MAC 2
+ *     5     0x830-0x83F   0x030-0x03F     BGX0 Logical MAC 3
+ *     6     0x900-0x90F   0x040-0x04F     BGX1 Logical MAC 0
+ *     7     0x910-0x91F   0x050-0x05F     BGX1 Logical MAC 1
+ *     8     0x920-0x92F   0x060-0x06F     BGX1 Logical MAC 2
+ *     9     0x930-0x93F   0x070-0x07F     BGX1 Logical MAC 3
+ *    10     0xA00-0xA0F   0x080-0x08F     BGX2 Logical MAC 0
+ *    11     0xA10-0xA1F   0x090-0x09F     BGX2 Logical MAC 1
+ *    12     0xA20-0xA2F   0x0A0-0x0AF     BGX2 Logical MAC 2
+ *    13     0xA30-0xA3F   0x0B0-0x0BF     BGX2 Logical MAC 3
  * </pre>
  */
 union cvmx_pko_lutx {
@@ -6637,6 +7197,23 @@ union cvmx_pko_lutx {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pko_lutx_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t valid                        : 1;  /**< Declares if the index in the LUT is valid. */
+	uint64_t reserved_13_14               : 2;
+	uint64_t pq_idx                       : 4;  /**< PQ index for channel return processing in the PSE. */
+	uint64_t reserved_8_8                 : 1;
+	uint64_t queue_number                 : 8;  /**< Mapping from this channel to the programmed queue number. */
+#else
+	uint64_t queue_number                 : 8;
+	uint64_t reserved_8_8                 : 1;
+	uint64_t pq_idx                       : 4;
+	uint64_t reserved_13_14               : 2;
+	uint64_t valid                        : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_pko_lutx_s                cn78xx;
 };
 typedef union cvmx_pko_lutx cvmx_pko_lutx_t;
@@ -6655,6 +7232,7 @@ union cvmx_pko_lut_bist_status {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_lut_bist_status_s     cn73xx;
 	struct cvmx_pko_lut_bist_status_s     cn78xx;
 };
 typedef union cvmx_pko_lut_bist_status cvmx_pko_lut_bist_status_t;
@@ -6675,6 +7253,7 @@ union cvmx_pko_lut_ecc_ctl0 {
 	uint64_t c2q_lut_ram_flip             : 2;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_ctl0_s        cn73xx;
 	struct cvmx_pko_lut_ecc_ctl0_s        cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_ctl0 cvmx_pko_lut_ecc_ctl0_t;
@@ -6694,6 +7273,7 @@ union cvmx_pko_lut_ecc_dbe_sts0 {
 	uint64_t c2q_lut_ram_dbe              : 1;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_dbe_sts0_s    cn73xx;
 	struct cvmx_pko_lut_ecc_dbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_dbe_sts0 cvmx_pko_lut_ecc_dbe_sts0_t;
@@ -6716,6 +7296,7 @@ union cvmx_pko_lut_ecc_dbe_sts_cmb0 {
 	uint64_t lut_dbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_dbe_sts_cmb0 cvmx_pko_lut_ecc_dbe_sts_cmb0_t;
@@ -6735,6 +7316,7 @@ union cvmx_pko_lut_ecc_sbe_sts0 {
 	uint64_t c2q_lut_ram_sbe              : 1;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_sbe_sts0_s    cn73xx;
 	struct cvmx_pko_lut_ecc_sbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_sbe_sts0 cvmx_pko_lut_ecc_sbe_sts0_t;
@@ -6757,6 +7339,7 @@ union cvmx_pko_lut_ecc_sbe_sts_cmb0 {
 	uint64_t lut_sbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_sbe_sts_cmb0 cvmx_pko_lut_ecc_sbe_sts_cmb0_t;
@@ -6773,19 +7356,18 @@ typedef union cvmx_pko_lut_ecc_sbe_sts_cmb0 cvmx_pko_lut_ecc_sbe_sts_cmb0_t;
  *   ---------------------------------
  *   PKO_MAC0_CFG   LBK loopback
  *   PKO_MAC1_CFG   DPI packet output
- *   PKO_MAC2_CFG   ILK link 0
- *   PKO_MAC3_CFG   ILK link 1
- *   PKO_MAC4_CFG   BGX0 logical MAC 0
- *   PKO_MAC5_CFG   BGX0 logical MAC 1
- *   PKO_MAC6_CFG   BGX0 logical MAC 2
- *   PKO_MAC7_CFG   BGX0 logical MAC 3
- *   PKO_MAC8_CFG   BGX1 logical MAC 0
- *   PKO_MAC9_CFG   BGX1 logical MAC 1
- *   PKO_MAC10_CFG  BGX1 logical MAC 2
- *   PKO_MAC11_CFG  BGX1 logical MAC 3
- *   PKO_MAC12_CFG  BGX2 logical MAC 0
- *   - ...
- *   PKO_MAC27_CFG  BGX5 logical MAC 3
+ *   PKO_MAC2_CFG   BGX0 logical MAC 0
+ *   PKO_MAC3_CFG   BGX0 logical MAC 1
+ *   PKO_MAC4_CFG   BGX0 logical MAC 2
+ *   PKO_MAC5_CFG   BGX0 logical MAC 3
+ *   PKO_MAC6_CFG   BGX1 logical MAC 0
+ *   PKO_MAC7_CFG   BGX1 logical MAC 1
+ *   PKO_MAC8_CFG   BGX1 logical MAC 2
+ *   PKO_MAC9_CFG   BGX1 logical MAC 3
+ *   PKO_MAC10_CFG  BGX2 logical MAC 0
+ *   PKO_MAC11_CFG  BGX2 logical MAC 1
+ *   PKO_MAC12_CFG  BGX2 logical MAC 2
+ *   PKO_MAC13_CFG  BGX2 logical MAC 3
  * </pre>
  */
 union cvmx_pko_macx_cfg {
@@ -6813,6 +7395,7 @@ union cvmx_pko_macx_cfg {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_pko_macx_cfg_s            cn73xx;
 	struct cvmx_pko_macx_cfg_s            cn78xx;
 };
 typedef union cvmx_pko_macx_cfg cvmx_pko_macx_cfg_t;
@@ -6869,6 +7452,7 @@ union cvmx_pko_mci1_cred_cntx {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_pko_mci1_cred_cntx_s      cn73xx;
 	struct cvmx_pko_mci1_cred_cntx_s      cn78xx;
 };
 typedef union cvmx_pko_mci1_cred_cntx cvmx_pko_mci1_cred_cntx_t;
@@ -6888,6 +7472,7 @@ union cvmx_pko_mci1_max_credx {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_pko_mci1_max_credx_s      cn73xx;
 	struct cvmx_pko_mci1_max_credx_s      cn78xx;
 };
 typedef union cvmx_pko_mci1_max_credx cvmx_pko_mci1_max_credx_t;
@@ -7919,7 +8504,7 @@ union cvmx_pko_mem_debug6 {
 	struct cvmx_pko_mem_debug6_cn68xx     cn68xxp1;
 	struct cvmx_pko_mem_debug6_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_37_63               : 27;
+	uint64_t reserved_63_37               : 27;
 	uint64_t qid_offres                   : 4;  /**< Internal state */
 	uint64_t qid_offths                   : 4;  /**< Internal state */
 	uint64_t preempter                    : 1;  /**< Internal state */
@@ -7945,7 +8530,7 @@ union cvmx_pko_mem_debug6 {
 	uint64_t preempter                    : 1;
 	uint64_t qid_offths                   : 4;
 	uint64_t qid_offres                   : 4;
-	uint64_t reserved_37_63               : 27;
+	uint64_t reserved_63_37               : 27;
 #endif
 	} cn70xx;
 	struct cvmx_pko_mem_debug6_cn70xx     cn70xxp1;
@@ -8963,9 +9548,11 @@ union cvmx_pko_ncb_bist_status {
 	uint64_t ncbo_pdm_cmd_dat_ram_bist_status : 1;/**< BIST status for NCBO_PDM_CMD_DAT_RAM. */
 	uint64_t ncbi_l2_pdm_pref_ram_bist_status : 1;/**< BIST status for NCBI_L2_PDM_PREF_RAM. */
 	uint64_t ncbo_pp_fif_ram_bist_status  : 1;  /**< BIST status for NCBO_PP_FIF_RAM. */
-	uint64_t reserved_0_58                : 59;
+	uint64_t ncbo_skid_fif_ram_bist_status : 1; /**< Reserved. */
+	uint64_t reserved_0_57                : 58;
 #else
-	uint64_t reserved_0_58                : 59;
+	uint64_t reserved_0_57                : 58;
+	uint64_t ncbo_skid_fif_ram_bist_status : 1;
 	uint64_t ncbo_pp_fif_ram_bist_status  : 1;
 	uint64_t ncbi_l2_pdm_pref_ram_bist_status : 1;
 	uint64_t ncbo_pdm_cmd_dat_ram_bist_status : 1;
@@ -8973,6 +9560,7 @@ union cvmx_pko_ncb_bist_status {
 	uint64_t ncbi_l2_out_ram_bist_status  : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_bist_status_s     cn73xx;
 	struct cvmx_pko_ncb_bist_status_s     cn78xx;
 };
 typedef union cvmx_pko_ncb_bist_status cvmx_pko_ncb_bist_status_t;
@@ -8994,9 +9582,13 @@ union cvmx_pko_ncb_ecc_ctl0 {
 	uint64_t ncbi_l2_pdm_pref_ram_cdis    : 1;  /**< NCBI_L2_PDM_PREF_RAM ECC correction disable. */
 	uint64_t ncbo_pp_fif_ram_flip         : 2;  /**< NCBO_PP_FIF_RAM flip syndrome bits on write. */
 	uint64_t ncbo_pp_fif_ram_cdis         : 1;  /**< NCBO_PP_FIF_RAM ECC correction disable. */
-	uint64_t reserved_0_48                : 49;
+	uint64_t ncbo_skid_fif_ram_flip       : 2;  /**< Reserved. */
+	uint64_t ncbo_skid_fif_ram_cdis       : 1;  /**< Reserved. */
+	uint64_t reserved_0_45                : 46;
 #else
-	uint64_t reserved_0_48                : 49;
+	uint64_t reserved_0_45                : 46;
+	uint64_t ncbo_skid_fif_ram_cdis       : 1;
+	uint64_t ncbo_skid_fif_ram_flip       : 2;
 	uint64_t ncbo_pp_fif_ram_cdis         : 1;
 	uint64_t ncbo_pp_fif_ram_flip         : 2;
 	uint64_t ncbi_l2_pdm_pref_ram_cdis    : 1;
@@ -9009,6 +9601,7 @@ union cvmx_pko_ncb_ecc_ctl0 {
 	uint64_t ncbi_l2_out_ram_flip         : 2;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_ctl0_s        cn73xx;
 	struct cvmx_pko_ncb_ecc_ctl0_s        cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_ctl0 cvmx_pko_ncb_ecc_ctl0_t;
@@ -9030,9 +9623,11 @@ union cvmx_pko_ncb_ecc_dbe_sts0 {
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
 	uint64_t ncbo_pp_fif_ram_dbe          : 1;  /**< Double-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
-	uint64_t reserved_0_58                : 59;
+	uint64_t ncbo_skid_fif_ram_dbe        : 1;  /**< Reserved. */
+	uint64_t reserved_0_57                : 58;
 #else
-	uint64_t reserved_0_58                : 59;
+	uint64_t reserved_0_57                : 58;
+	uint64_t ncbo_skid_fif_ram_dbe        : 1;
 	uint64_t ncbo_pp_fif_ram_dbe          : 1;
 	uint64_t ncbi_l2_pdm_pref_ram_dbe     : 1;
 	uint64_t ncbo_pdm_cmd_dat_ram_dbe     : 1;
@@ -9040,6 +9635,7 @@ union cvmx_pko_ncb_ecc_dbe_sts0 {
 	uint64_t ncbi_l2_out_ram_dbe          : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_dbe_sts0_s    cn73xx;
 	struct cvmx_pko_ncb_ecc_dbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_dbe_sts0 cvmx_pko_ncb_ecc_dbe_sts0_t;
@@ -9054,7 +9650,8 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
 	uint64_t ncb_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_DBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_NCB_ECC_DBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0. INTERNAL: Instances:
+                                                         is set. Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0.
+                                                         INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
@@ -9066,6 +9663,7 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
 	uint64_t ncb_dbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_dbe_sts_cmb0 cvmx_pko_ncb_ecc_dbe_sts_cmb0_t;
@@ -9087,9 +9685,11 @@ union cvmx_pko_ncb_ecc_sbe_sts0 {
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
 	uint64_t ncbo_pp_fif_ram_sbe          : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
-	uint64_t reserved_0_58                : 59;
+	uint64_t ncbo_skid_fif_ram_sbe        : 1;  /**< Reserved. */
+	uint64_t reserved_0_57                : 58;
 #else
-	uint64_t reserved_0_58                : 59;
+	uint64_t reserved_0_57                : 58;
+	uint64_t ncbo_skid_fif_ram_sbe        : 1;
 	uint64_t ncbo_pp_fif_ram_sbe          : 1;
 	uint64_t ncbi_l2_pdm_pref_ram_sbe     : 1;
 	uint64_t ncbo_pdm_cmd_dat_ram_sbe     : 1;
@@ -9097,6 +9697,7 @@ union cvmx_pko_ncb_ecc_sbe_sts0 {
 	uint64_t ncbi_l2_out_ram_sbe          : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_sbe_sts0_s    cn73xx;
 	struct cvmx_pko_ncb_ecc_sbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_sbe_sts0 cvmx_pko_ncb_ecc_sbe_sts0_t;
@@ -9111,7 +9712,8 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
 	uint64_t ncb_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_SBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_NCB_ECC_SBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0. INTERNAL: Instances:
+                                                         is set. Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0.
+                                                         INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
@@ -9123,6 +9725,7 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
 	uint64_t ncb_sbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_sbe_sts_cmb0 cvmx_pko_ncb_ecc_sbe_sts_cmb0_t;
@@ -9156,6 +9759,7 @@ union cvmx_pko_ncb_int {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pko_ncb_int_s             cn73xx;
 	struct cvmx_pko_ncb_int_s             cn78xx;
 };
 typedef union cvmx_pko_ncb_int cvmx_pko_ncb_int_t;
@@ -9186,6 +9790,7 @@ union cvmx_pko_ncb_tx_err_info {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pko_ncb_tx_err_info_s     cn73xx;
 	struct cvmx_pko_ncb_tx_err_info_s     cn78xx;
 };
 typedef union cvmx_pko_ncb_tx_err_info cvmx_pko_ncb_tx_err_info_t;
@@ -9204,6 +9809,7 @@ union cvmx_pko_ncb_tx_err_word {
 	uint64_t err_word                     : 64;
 #endif
 	} s;
+	struct cvmx_pko_ncb_tx_err_word_s     cn73xx;
 	struct cvmx_pko_ncb_tx_err_word_s     cn78xx;
 };
 typedef union cvmx_pko_ncb_tx_err_word cvmx_pko_ncb_tx_err_word_t;
@@ -9281,6 +9887,7 @@ union cvmx_pko_pdm_bist_status {
 	uint64_t flshb_cache_lo_ram_bist_status : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_bist_status_s     cn73xx;
 	struct cvmx_pko_pdm_bist_status_s     cn78xx;
 };
 typedef union cvmx_pko_pdm_bist_status cvmx_pko_pdm_bist_status_t;
@@ -9317,6 +9924,7 @@ union cvmx_pko_pdm_cfg {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_pko_pdm_cfg_s             cn73xx;
 	struct cvmx_pko_pdm_cfg_s             cn78xx;
 };
 typedef union cvmx_pko_pdm_cfg cvmx_pko_pdm_cfg_t;
@@ -9338,6 +9946,7 @@ union cvmx_pko_pdm_cfg_dbg {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pko_pdm_cfg_dbg_s         cn73xx;
 	struct cvmx_pko_pdm_cfg_dbg_s         cn78xx;
 };
 typedef union cvmx_pko_pdm_cfg_dbg cvmx_pko_pdm_cfg_dbg_t;
@@ -9365,6 +9974,7 @@ union cvmx_pko_pdm_cp_dbg {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pko_pdm_cp_dbg_s          cn73xx;
 	struct cvmx_pko_pdm_cp_dbg_s          cn78xx;
 };
 typedef union cvmx_pko_pdm_cp_dbg cvmx_pko_pdm_cp_dbg_t;
@@ -9387,6 +9997,7 @@ union cvmx_pko_pdm_dqx_minpad {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_pdm_dqx_minpad_s      cn73xx;
 	struct cvmx_pko_pdm_dqx_minpad_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_dqx_minpad cvmx_pko_pdm_dqx_minpad_t;
@@ -9427,6 +10038,7 @@ union cvmx_pko_pdm_drpbuf_dbg {
 	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
+	struct cvmx_pko_pdm_drpbuf_dbg_s      cn73xx;
 	struct cvmx_pko_pdm_drpbuf_dbg_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_drpbuf_dbg cvmx_pko_pdm_drpbuf_dbg_t;
@@ -9481,6 +10093,47 @@ union cvmx_pko_pdm_dwpbuf_dbg {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_pdm_dwpbuf_dbg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t cmd_proc                     : 1;  /**< Command process signal. */
+	uint64_t reserved_46_46               : 1;
+	uint64_t mem_data_val                 : 1;  /**< Memory data valid. */
+	uint64_t insert_np                    : 1;  /**< Next pointer insertion signal. */
+	uint64_t reserved_43_43               : 1;
+	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
+	uint64_t load_val                     : 1;  /**< Load valid signal. */
+	uint64_t rdy                          : 1;  /**< Ready signal. */
+	uint64_t reserved_37_39               : 3;
+	uint64_t mem_rdy                      : 1;  /**< Memory stage ready signal. */
+	uint64_t reserved_19_35               : 17;
+	uint64_t insert_dp                    : 2;  /**< Descriptor insertion signals. */
+	uint64_t reserved_15_16               : 2;
+	uint64_t mem_addr                     : 11; /**< Memory address for pbuf ram. */
+	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
+                                                         0x3 = Low wen.
+                                                         0x2 = Low cen.
+                                                         0x1 = High wen.
+                                                         0x0 = High cen. */
+#else
+	uint64_t mem_en                       : 4;
+	uint64_t mem_addr                     : 11;
+	uint64_t reserved_15_16               : 2;
+	uint64_t insert_dp                    : 2;
+	uint64_t reserved_19_35               : 17;
+	uint64_t mem_rdy                      : 1;
+	uint64_t reserved_37_39               : 3;
+	uint64_t rdy                          : 1;
+	uint64_t load_val                     : 1;
+	uint64_t sel_nxt_ptr                  : 1;
+	uint64_t reserved_43_43               : 1;
+	uint64_t insert_np                    : 1;
+	uint64_t mem_data_val                 : 1;
+	uint64_t reserved_46_46               : 1;
+	uint64_t cmd_proc                     : 1;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pdm_dwpbuf_dbg_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_dwpbuf_dbg cvmx_pko_pdm_dwpbuf_dbg_t;
@@ -9581,6 +10234,91 @@ union cvmx_pko_pdm_ecc_ctl0 {
 	uint64_t flshb_cache_lo_ram_flip      : 2;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t flshb_cache_lo_ram_flip      : 2;  /**< FLSHB_CACHE_LO_RAM flip syndrome bits on write. */
+	uint64_t flshb_cache_lo_ram_cdis      : 1;  /**< FLSHB_CACHE_LO_RAM ECC correction disable. */
+	uint64_t flshb_cache_hi_ram_flip      : 2;  /**< FLSHB_CACHE_HI_RAM flip syndrome bits on write. */
+	uint64_t flshb_cache_hi_ram_cdis      : 1;  /**< FLSHB_CACHE_HI_RAM ECC correction disable. */
+	uint64_t isrm_ca_iinst_ram_flip       : 2;  /**< ISRM_CA_IINST_RAM flip syndrome bits on write. */
+	uint64_t isrm_ca_iinst_ram_cdis       : 1;  /**< ISRM_CA_IINST_RAM ECC correction disable. */
+	uint64_t isrm_ca_cm_ram_flip          : 2;  /**< ISRM_CA_CM_RAM flip syndrome bits on write. */
+	uint64_t isrm_ca_cm_ram_cdis          : 1;  /**< ISRM_CA_CM_RAM ECC correction disable. */
+	uint64_t isrm_st_ram2_flip            : 2;  /**< ISRM_ST_RAM2 flip syndrome bits on write. */
+	uint64_t isrm_st_ram2_cdis            : 1;  /**< ISRM_ST_RAM2 ECC correction disable. */
+	uint64_t isrm_st_ram1_flip            : 2;  /**< ISRM_ST_RAM1 flip syndrome bits on write. */
+	uint64_t isrm_st_ram1_cdis            : 1;  /**< ISRM_ST_RAM1 ECC correction disable. */
+	uint64_t isrm_st_ram0_flip            : 2;  /**< ISRM_ST_RAM0 flip syndrome bits on write. */
+	uint64_t isrm_st_ram0_cdis            : 1;  /**< ISRM_ST_RAM0 ECC correction disable. */
+	uint64_t isrd_st_ram3_flip            : 2;  /**< ISRD_ST_RAM3 flip syndrome bits on write. */
+	uint64_t isrd_st_ram3_cdis            : 1;  /**< ISRD_ST_RAM3 ECC correction disable. */
+	uint64_t isrd_st_ram2_flip            : 2;  /**< ISRD_ST_RAM2 flip syndrome bits on write. */
+	uint64_t isrd_st_ram2_cdis            : 1;  /**< ISRD_ST_RAM2 ECC correction disable. */
+	uint64_t isrd_st_ram1_flip            : 2;  /**< ISRD_ST_RAM1 flip syndrome bits on write. */
+	uint64_t isrd_st_ram1_cdis            : 1;  /**< ISRD_ST_RAM1 ECC correction disable. */
+	uint64_t isrd_st_ram0_flip            : 2;  /**< ISRD_ST_RAM0 flip syndrome bits on write. */
+	uint64_t isrd_st_ram0_cdis            : 1;  /**< ISRD_ST_RAM0 ECC correction disable. */
+	uint64_t drp_hi_ram_flip              : 2;  /**< DRP_HI_RAM flip syndrome bits on write. */
+	uint64_t drp_hi_ram_cdis              : 1;  /**< DRP_HI_RAM ECC correction disable. */
+	uint64_t drp_lo_ram_flip              : 2;  /**< DRP_LO_RAM flip syndrome bits on write. */
+	uint64_t drp_lo_ram_cdis              : 1;  /**< DRP_LO_RAM ECC correction disable. */
+	uint64_t dwp_hi_ram_flip              : 2;  /**< DWP_HI_RAM flip syndrome bits on write. */
+	uint64_t dwp_hi_ram_cdis              : 1;  /**< DWP_HI_RAM ECC correction disable. */
+	uint64_t dwp_lo_ram_flip              : 2;  /**< DWP_LO_RAM flip syndrome bits on write. */
+	uint64_t dwp_lo_ram_cdis              : 1;  /**< DWP_LO_RAM ECC correction disable. */
+	uint64_t reserved_13_18               : 6;
+	uint64_t fillb_m_rsp_ram_hi_flip      : 2;  /**< FILLB_M_RSP_RAM_HI flip syndrome bits on write. */
+	uint64_t fillb_m_rsp_ram_hi_cdis      : 1;  /**< FILLB_M_RSP_RAM_HI ECC correction disable. */
+	uint64_t fillb_m_rsp_ram_lo_flip      : 2;  /**< FILLB_M_RSP_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_m_rsp_ram_lo_cdis      : 1;  /**< FILLB_M_RSP_RAM_LO ECC correction disable. */
+	uint64_t fillb_d_rsp_ram_hi_flip      : 2;  /**< FILLB_D_RSP_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_d_rsp_ram_hi_cdis      : 1;  /**< FILLB_D_RSP_RAM_HI ECC correction disable. */
+	uint64_t fillb_d_rsp_ram_lo_flip      : 2;  /**< FILLB_D_DAT_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_d_rsp_ram_lo_cdis      : 1;  /**< FILLB_D_RSP_RAM_LO ECC correction disable. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t fillb_d_rsp_ram_lo_cdis      : 1;
+	uint64_t fillb_d_rsp_ram_lo_flip      : 2;
+	uint64_t fillb_d_rsp_ram_hi_cdis      : 1;
+	uint64_t fillb_d_rsp_ram_hi_flip      : 2;
+	uint64_t fillb_m_rsp_ram_lo_cdis      : 1;
+	uint64_t fillb_m_rsp_ram_lo_flip      : 2;
+	uint64_t fillb_m_rsp_ram_hi_cdis      : 1;
+	uint64_t fillb_m_rsp_ram_hi_flip      : 2;
+	uint64_t reserved_13_18               : 6;
+	uint64_t dwp_lo_ram_cdis              : 1;
+	uint64_t dwp_lo_ram_flip              : 2;
+	uint64_t dwp_hi_ram_cdis              : 1;
+	uint64_t dwp_hi_ram_flip              : 2;
+	uint64_t drp_lo_ram_cdis              : 1;
+	uint64_t drp_lo_ram_flip              : 2;
+	uint64_t drp_hi_ram_cdis              : 1;
+	uint64_t drp_hi_ram_flip              : 2;
+	uint64_t isrd_st_ram0_cdis            : 1;
+	uint64_t isrd_st_ram0_flip            : 2;
+	uint64_t isrd_st_ram1_cdis            : 1;
+	uint64_t isrd_st_ram1_flip            : 2;
+	uint64_t isrd_st_ram2_cdis            : 1;
+	uint64_t isrd_st_ram2_flip            : 2;
+	uint64_t isrd_st_ram3_cdis            : 1;
+	uint64_t isrd_st_ram3_flip            : 2;
+	uint64_t isrm_st_ram0_cdis            : 1;
+	uint64_t isrm_st_ram0_flip            : 2;
+	uint64_t isrm_st_ram1_cdis            : 1;
+	uint64_t isrm_st_ram1_flip            : 2;
+	uint64_t isrm_st_ram2_cdis            : 1;
+	uint64_t isrm_st_ram2_flip            : 2;
+	uint64_t isrm_ca_cm_ram_cdis          : 1;
+	uint64_t isrm_ca_cm_ram_flip          : 2;
+	uint64_t isrm_ca_iinst_ram_cdis       : 1;
+	uint64_t isrm_ca_iinst_ram_flip       : 2;
+	uint64_t flshb_cache_hi_ram_cdis      : 1;
+	uint64_t flshb_cache_hi_ram_flip      : 2;
+	uint64_t flshb_cache_lo_ram_cdis      : 1;
+	uint64_t flshb_cache_lo_ram_flip      : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pdm_ecc_ctl0_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_ctl0 cvmx_pko_pdm_ecc_ctl0_t;
@@ -9615,6 +10353,7 @@ union cvmx_pko_pdm_ecc_ctl1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_ctl1_s        cn73xx;
 	struct cvmx_pko_pdm_ecc_ctl1_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_ctl1 cvmx_pko_pdm_ecc_ctl1_t;
@@ -9702,6 +10441,7 @@ union cvmx_pko_pdm_ecc_dbe_sts0 {
 	uint64_t flshb_cache_lo_ram_dbe       : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_dbe_sts0_s    cn73xx;
 	struct cvmx_pko_pdm_ecc_dbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_dbe_sts0 cvmx_pko_pdm_ecc_dbe_sts0_t;
@@ -9744,6 +10484,7 @@ union cvmx_pko_pdm_ecc_dbe_sts_cmb0 {
 	uint64_t pdm_dbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_dbe_sts_cmb0 cvmx_pko_pdm_ecc_dbe_sts_cmb0_t;
@@ -9831,6 +10572,7 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
 	uint64_t flshb_cache_lo_ram_sbe       : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_sbe_sts0_s    cn73xx;
 	struct cvmx_pko_pdm_ecc_sbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_sbe_sts0 cvmx_pko_pdm_ecc_sbe_sts0_t;
@@ -9873,6 +10615,7 @@ union cvmx_pko_pdm_ecc_sbe_sts_cmb0 {
 	uint64_t pdm_sbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_sbe_sts_cmb0 cvmx_pko_pdm_ecc_sbe_sts_cmb0_t;
@@ -9913,6 +10656,7 @@ union cvmx_pko_pdm_fillb_dbg0 {
 	uint64_t reserved_57_63               : 7;
 #endif
 	} s;
+	struct cvmx_pko_pdm_fillb_dbg0_s      cn73xx;
 	struct cvmx_pko_pdm_fillb_dbg0_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_fillb_dbg0 cvmx_pko_pdm_fillb_dbg0_t;
@@ -9953,6 +10697,7 @@ union cvmx_pko_pdm_fillb_dbg1 {
 	uint64_t reserved_57_63               : 7;
 #endif
 	} s;
+	struct cvmx_pko_pdm_fillb_dbg1_s      cn73xx;
 	struct cvmx_pko_pdm_fillb_dbg1_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_fillb_dbg1 cvmx_pko_pdm_fillb_dbg1_t;
@@ -9975,6 +10720,7 @@ union cvmx_pko_pdm_fillb_dbg2 {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_pko_pdm_fillb_dbg2_s      cn73xx;
 	struct cvmx_pko_pdm_fillb_dbg2_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_fillb_dbg2 cvmx_pko_pdm_fillb_dbg2_t;
@@ -10007,6 +10753,7 @@ union cvmx_pko_pdm_flshb_dbg0 {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_pdm_flshb_dbg0_s      cn73xx;
 	struct cvmx_pko_pdm_flshb_dbg0_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_flshb_dbg0 cvmx_pko_pdm_flshb_dbg0_t;
@@ -10025,11 +10772,43 @@ union cvmx_pko_pdm_flshb_dbg1 {
 	uint64_t cam_stdn                     : 32;
 #endif
 	} s;
+	struct cvmx_pko_pdm_flshb_dbg1_s      cn73xx;
 	struct cvmx_pko_pdm_flshb_dbg1_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_flshb_dbg1 cvmx_pko_pdm_flshb_dbg1_t;
 
 /**
+ * cvmx_pko_pdm_intf_dbg_rd
+ *
+ * For diagnostic use only.
+ *
+ */
+union cvmx_pko_pdm_intf_dbg_rd {
+	uint64_t u64;
+	struct cvmx_pko_pdm_intf_dbg_rd_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t in_flight                    : 8;  /**< Number of packets in-flight to PDM. */
+	uint64_t pdm_req_cred_cnt             : 8;  /**< PDM req/ack credit counter. */
+	uint64_t pse_buf_waddr                : 8;  /**< PSE buffer write address. */
+	uint64_t pse_buf_raddr                : 8;  /**< PSE buffer read address. */
+	uint64_t resp_buf_waddr               : 8;  /**< Interface buffer write address. */
+	uint64_t resp_buf_raddr               : 8;  /**< Interface buffer read address. */
+#else
+	uint64_t resp_buf_raddr               : 8;
+	uint64_t resp_buf_waddr               : 8;
+	uint64_t pse_buf_raddr                : 8;
+	uint64_t pse_buf_waddr                : 8;
+	uint64_t pdm_req_cred_cnt             : 8;
+	uint64_t in_flight                    : 8;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_pko_pdm_intf_dbg_rd_s     cn73xx;
+};
+typedef union cvmx_pko_pdm_intf_dbg_rd cvmx_pko_pdm_intf_dbg_rd_t;
+
+/**
  * cvmx_pko_pdm_isrd_dbg
  */
 union cvmx_pko_pdm_isrd_dbg {
@@ -10101,6 +10880,7 @@ union cvmx_pko_pdm_isrd_dbg {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_pdm_isrd_dbg_s        cn73xx;
 	struct cvmx_pko_pdm_isrd_dbg_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_isrd_dbg cvmx_pko_pdm_isrd_dbg_t;
@@ -10131,6 +10911,7 @@ union cvmx_pko_pdm_isrd_dbg_dq {
 	uint64_t reserved_46_63               : 18;
 #endif
 	} s;
+	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn73xx;
 	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn78xx;
 };
 typedef union cvmx_pko_pdm_isrd_dbg_dq cvmx_pko_pdm_isrd_dbg_dq_t;
@@ -10197,6 +10978,7 @@ union cvmx_pko_pdm_isrm_dbg {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_pko_pdm_isrm_dbg_s        cn73xx;
 	struct cvmx_pko_pdm_isrm_dbg_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_isrm_dbg cvmx_pko_pdm_isrm_dbg_t;
@@ -10223,6 +11005,7 @@ union cvmx_pko_pdm_isrm_dbg_dq {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn73xx;
 	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn78xx;
 };
 typedef union cvmx_pko_pdm_isrm_dbg_dq cvmx_pko_pdm_isrm_dbg_dq_t;
@@ -10255,6 +11038,7 @@ union cvmx_pko_pdm_mem_addr {
 	uint64_t memsel                       : 3;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mem_addr_s        cn73xx;
 	struct cvmx_pko_pdm_mem_addr_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_mem_addr cvmx_pko_pdm_mem_addr_t;
@@ -10273,6 +11057,7 @@ union cvmx_pko_pdm_mem_data {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mem_data_s        cn73xx;
 	struct cvmx_pko_pdm_mem_data_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_mem_data cvmx_pko_pdm_mem_data_t;
@@ -10293,6 +11078,7 @@ union cvmx_pko_pdm_mem_rw_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mem_rw_ctl_s      cn73xx;
 	struct cvmx_pko_pdm_mem_rw_ctl_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_mem_rw_ctl cvmx_pko_pdm_mem_rw_ctl_t;
@@ -10311,6 +11097,7 @@ union cvmx_pko_pdm_mem_rw_sts {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mem_rw_sts_s      cn73xx;
 	struct cvmx_pko_pdm_mem_rw_sts_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_mem_rw_sts cvmx_pko_pdm_mem_rw_sts_t;
@@ -10367,6 +11154,58 @@ union cvmx_pko_pdm_mwpbuf_dbg {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mwpbuf_dbg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_49_63               : 15;
+	uint64_t str_proc                     : 1;  /**< Stream process for data streaming. */
+	uint64_t cmd_proc                     : 1;  /**< Command process for memory-type instruction. */
+	uint64_t str_val                      : 1;  /**< streaming valid. */
+	uint64_t mem_data_val                 : 1;  /**< Memory data valid. */
+	uint64_t insert_np                    : 1;  /**< Next pointer insertion. */
+	uint64_t insert_mp                    : 1;  /**< Meta-packet insertion. */
+	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
+	uint64_t load_val                     : 1;  /**< Load valid signal. */
+	uint64_t rdy                          : 1;  /**< Ready signal. */
+	uint64_t cur_state                    : 3;  /**< Stall count value. */
+	uint64_t mem_rdy                      : 1;  /**< Memory stage ready. */
+	uint64_t str_rdy                      : 1;  /**< Streaming logic ready. */
+	uint64_t contention_type              : 2;  /**< Contention detected and type mwpbuf__csr_conflict[1:0] bit 0 - a streamFill followed by a
+                                                         flush (same dq, same dst) bit 1 - a flush followed by a stream (same dq, same dst) */
+	uint64_t reserved_21_32               : 12;
+	uint64_t mem_wen                      : 4;  /**< Memory write enable signals. The order of the bits is:
+                                                         0x3 = wen mem3.
+                                                         0x2 = wen mem2.
+                                                         0x1 = wen mem1.
+                                                         0x0 = wen mem0. */
+	uint64_t reserved_15_16               : 2;
+	uint64_t mem_addr                     : 11; /**< Memory address for pbuf ram. */
+	uint64_t mem_en                       : 4;  /**< Memory chip enable signals. The order of the bits is:
+                                                         0x3 = cen mem3.
+                                                         0x2 = cen mem2.
+                                                         0x1 = cen mem1.
+                                                         0x0 = cen mem0. */
+#else
+	uint64_t mem_en                       : 4;
+	uint64_t mem_addr                     : 11;
+	uint64_t reserved_15_16               : 2;
+	uint64_t mem_wen                      : 4;
+	uint64_t reserved_21_32               : 12;
+	uint64_t contention_type              : 2;
+	uint64_t str_rdy                      : 1;
+	uint64_t mem_rdy                      : 1;
+	uint64_t cur_state                    : 3;
+	uint64_t rdy                          : 1;
+	uint64_t load_val                     : 1;
+	uint64_t sel_nxt_ptr                  : 1;
+	uint64_t insert_mp                    : 1;
+	uint64_t insert_np                    : 1;
+	uint64_t mem_data_val                 : 1;
+	uint64_t str_val                      : 1;
+	uint64_t cmd_proc                     : 1;
+	uint64_t str_proc                     : 1;
+	uint64_t reserved_49_63               : 15;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pdm_mwpbuf_dbg_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_mwpbuf_dbg cvmx_pko_pdm_mwpbuf_dbg_t;
@@ -10459,6 +11298,7 @@ union cvmx_pko_pdm_sts {
 	uint64_t reserved_38_63               : 26;
 #endif
 	} s;
+	struct cvmx_pko_pdm_sts_s             cn73xx;
 	struct cvmx_pko_pdm_sts_s             cn78xx;
 };
 typedef union cvmx_pko_pdm_sts cvmx_pko_pdm_sts_t;
@@ -10528,32 +11368,87 @@ union cvmx_pko_peb_bist_status {
 	uint64_t reserved_26_63               : 38;
 #endif
 	} s;
-	struct cvmx_pko_peb_bist_status_s     cn78xx;
-};
-typedef union cvmx_pko_peb_bist_status cvmx_pko_peb_bist_status_t;
-
-/**
- * cvmx_pko_peb_ecc_ctl0
- */
-union cvmx_pko_peb_ecc_ctl0 {
-	uint64_t u64;
-	struct cvmx_pko_peb_ecc_ctl0_s {
+	struct cvmx_pko_peb_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_flip      : 2;  /**< IOBP1_UID_FIFO_RAM flip syndrome bits on write. */
-	uint64_t iobp1_uid_fifo_ram_cdis      : 1;  /**< IOBP1_UID_FIFO_RAM ECC correction disable. */
-	uint64_t iobp0_fifo_ram_flip          : 2;  /**< IOBP0_FIFO_RAM flip syndrome bits on write. */
-	uint64_t iobp0_fifo_ram_cdis          : 1;  /**< IOBP0_FIFO_RAM ECC correction disable. */
-	uint64_t iobp1_fifo_ram_flip          : 2;  /**< IOBP1_FIFO_RAM flip syndrome bits on write. */
-	uint64_t iobp1_fifo_ram_cdis          : 1;  /**< IOBP1_FIFO_RAM ECC correction disable. */
-	uint64_t pdm_resp_buf_ram_flip        : 2;  /**< PDM_RESP_BUF_RAM flip syndrome bits on write. */
-	uint64_t pdm_resp_buf_ram_cdis        : 1;  /**< PDM_RESP_BUF_RAM ECC correction disable. */
-	uint64_t pdm_pse_buf_ram_flip         : 2;  /**< PDM_PSE_BUF_RAM flip syndrome bits on write. */
-	uint64_t pdm_pse_buf_ram_cdis         : 1;  /**< PDM_PSE_BUF_RAM ECC correction disable. */
-	uint64_t peb_sm_jmp_ram_flip          : 2;  /**< PEB_SM_JMP_RAM flip syndrome bits on write. */
-	uint64_t peb_sm_jmp_ram_cdis          : 1;  /**< PEB_SM_JMP_RAM ECC correction disable. */
-	uint64_t peb_st_inf_ram_flip          : 2;  /**< PEB_ST_INF_RAM flip syndrome bits on write. */
-	uint64_t peb_st_inf_ram_cdis          : 1;  /**< PEB_ST_INF_RAM ECC correction disable. */
-	uint64_t pd_bank3_ram_flip            : 2;  /**< PD_BANK3_RAM flip syndrome bits on write. */
+	uint64_t reserved_26_63               : 38;
+	uint64_t add_work_fifo                : 1;  /**< ADD_WORK_FIFO RAM BIST status. */
+	uint64_t pdm_pse_buf_ram              : 1;  /**< PDM_PSE_BUF RAM BIST status. */
+	uint64_t iobp0_fifo_ram               : 1;  /**< IOBP0_FIFO RAM BIST status. */
+	uint64_t iobp1_fifo_ram               : 1;  /**< IOBP1_FIFO RAM BIST status. */
+	uint64_t state_mem0                   : 1;  /**< STATE_MEM0 RAM BIST status. */
+	uint64_t reserved_19_20               : 2;
+	uint64_t state_mem3                   : 1;  /**< STATE_MEM3 RAM BIST status. */
+	uint64_t iobp1_uid_fifo_ram           : 1;  /**< IOBP1_UID_FIFO RAM BIST status. */
+	uint64_t nxt_link_ptr_ram             : 1;  /**< NXT_LINK_PTR RAM BIST status. */
+	uint64_t pd_bank0_ram                 : 1;  /**< PD_BANK0 RAM BIST status. */
+	uint64_t reserved_13_14               : 2;
+	uint64_t pd_bank3_ram                 : 1;  /**< PD_BANK3 RAM BIST status. */
+	uint64_t pd_var_bank_ram              : 1;  /**< PD_VAR_BANK RAM BIST status. */
+	uint64_t pdm_resp_buf_ram             : 1;  /**< PDM_RESP_BUF RAM BIST status. */
+	uint64_t tx_fifo_pkt_ram              : 1;  /**< TX_FIFO_PKT RAM BIST status. */
+	uint64_t tx_fifo_hdr_ram              : 1;  /**< TX_FIFO_HDR RAM BIST status. */
+	uint64_t tx_fifo_crc_ram              : 1;  /**< TX_FIFO_CRC RAM BIST status. */
+	uint64_t ts_addwork_ram               : 1;  /**< TS_ADDWORK RAM BIST status. */
+	uint64_t send_mem_ts_fifo             : 1;  /**< SEND_MEM_TS_FIFO RAM BIST status. */
+	uint64_t send_mem_stdn_fifo           : 1;  /**< SEND_MEM_STDN_FIFO RAM BIST status. */
+	uint64_t send_mem_fifo                : 1;  /**< SEND_MEM_FIFO RAM BIST status. */
+	uint64_t pkt_mrk_ram                  : 1;  /**< PKT_MRK RAM BIST status. */
+	uint64_t peb_st_inf_ram               : 1;  /**< PEB_ST_INF RAM BIST status. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t peb_st_inf_ram               : 1;
+	uint64_t pkt_mrk_ram                  : 1;
+	uint64_t send_mem_fifo                : 1;
+	uint64_t send_mem_stdn_fifo           : 1;
+	uint64_t send_mem_ts_fifo             : 1;
+	uint64_t ts_addwork_ram               : 1;
+	uint64_t tx_fifo_crc_ram              : 1;
+	uint64_t tx_fifo_hdr_ram              : 1;
+	uint64_t tx_fifo_pkt_ram              : 1;
+	uint64_t pdm_resp_buf_ram             : 1;
+	uint64_t pd_var_bank_ram              : 1;
+	uint64_t pd_bank3_ram                 : 1;
+	uint64_t reserved_13_14               : 2;
+	uint64_t pd_bank0_ram                 : 1;
+	uint64_t nxt_link_ptr_ram             : 1;
+	uint64_t iobp1_uid_fifo_ram           : 1;
+	uint64_t state_mem3                   : 1;
+	uint64_t reserved_19_20               : 2;
+	uint64_t state_mem0                   : 1;
+	uint64_t iobp1_fifo_ram               : 1;
+	uint64_t iobp0_fifo_ram               : 1;
+	uint64_t pdm_pse_buf_ram              : 1;
+	uint64_t add_work_fifo                : 1;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} cn73xx;
+	struct cvmx_pko_peb_bist_status_s     cn78xx;
+};
+typedef union cvmx_pko_peb_bist_status cvmx_pko_peb_bist_status_t;
+
+/**
+ * cvmx_pko_peb_ecc_ctl0
+ */
+union cvmx_pko_peb_ecc_ctl0 {
+	uint64_t u64;
+	struct cvmx_pko_peb_ecc_ctl0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_flip      : 2;  /**< IOBP1_UID_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp1_uid_fifo_ram_cdis      : 1;  /**< IOBP1_UID_FIFO_RAM ECC correction disable. */
+	uint64_t iobp0_fifo_ram_flip          : 2;  /**< IOBP0_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp0_fifo_ram_cdis          : 1;  /**< IOBP0_FIFO_RAM ECC correction disable. */
+	uint64_t iobp1_fifo_ram_flip          : 2;  /**< IOBP1_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp1_fifo_ram_cdis          : 1;  /**< IOBP1_FIFO_RAM ECC correction disable. */
+	uint64_t pdm_resp_buf_ram_flip        : 2;  /**< PDM_RESP_BUF_RAM flip syndrome bits on write. */
+	uint64_t pdm_resp_buf_ram_cdis        : 1;  /**< PDM_RESP_BUF_RAM ECC correction disable. */
+	uint64_t pdm_pse_buf_ram_flip         : 2;  /**< PDM_PSE_BUF_RAM flip syndrome bits on write. */
+	uint64_t pdm_pse_buf_ram_cdis         : 1;  /**< PDM_PSE_BUF_RAM ECC correction disable. */
+	uint64_t peb_sm_jmp_ram_flip          : 2;  /**< PEB_SM_JMP_RAM flip syndrome bits on write. */
+	uint64_t peb_sm_jmp_ram_cdis          : 1;  /**< PEB_SM_JMP_RAM ECC correction disable. */
+	uint64_t peb_st_inf_ram_flip          : 2;  /**< PEB_ST_INF_RAM flip syndrome bits on write. */
+	uint64_t peb_st_inf_ram_cdis          : 1;  /**< PEB_ST_INF_RAM ECC correction disable. */
+	uint64_t pd_bank3_ram_flip            : 2;  /**< PD_BANK3_RAM flip syndrome bits on write. */
 	uint64_t pd_bank3_ram_cdis            : 1;  /**< PD_BANK3_RAM ECC correction disable. */
 	uint64_t pd_bank2_ram_flip            : 2;  /**< PD_BANK2_RAM flip syndrome bits on write (pass 1 only). */
 	uint64_t pd_bank2_ram_cdis            : 1;  /**< PD_BANK2_RAM ECC correction disable (pass 1 only). */
@@ -10628,6 +11523,89 @@ union cvmx_pko_peb_ecc_ctl0 {
 	uint64_t iobp1_uid_fifo_ram_flip      : 2;
 #endif
 	} s;
+	struct cvmx_pko_peb_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_flip      : 2;  /**< IOBP1_UID_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp1_uid_fifo_ram_cdis      : 1;  /**< IOBP1_UID_FIFO_RAM ECC correction disable. */
+	uint64_t iobp0_fifo_ram_flip          : 2;  /**< IOBP0_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp0_fifo_ram_cdis          : 1;  /**< IOBP0_FIFO_RAM ECC correction disable. */
+	uint64_t iobp1_fifo_ram_flip          : 2;  /**< IOBP1_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp1_fifo_ram_cdis          : 1;  /**< IOBP1_FIFO_RAM ECC correction disable. */
+	uint64_t pdm_resp_buf_ram_flip        : 2;  /**< PDM_RESP_BUF_RAM flip syndrome bits on write. */
+	uint64_t pdm_resp_buf_ram_cdis        : 1;  /**< PDM_RESP_BUF_RAM ECC correction disable. */
+	uint64_t pdm_pse_buf_ram_flip         : 2;  /**< PDM_PSE_BUF_RAM flip syndrome bits on write. */
+	uint64_t pdm_pse_buf_ram_cdis         : 1;  /**< PDM_PSE_BUF_RAM ECC correction disable. */
+	uint64_t reserved_46_48               : 3;
+	uint64_t peb_st_inf_ram_flip          : 2;  /**< PEB_ST_INF_RAM flip syndrome bits on write. */
+	uint64_t peb_st_inf_ram_cdis          : 1;  /**< PEB_ST_INF_RAM ECC correction disable. */
+	uint64_t pd_bank3_ram_flip            : 2;  /**< PD_BANK3_RAM flip syndrome bits on write. */
+	uint64_t pd_bank3_ram_cdis            : 1;  /**< PD_BANK3_RAM ECC correction disable. */
+	uint64_t reserved_34_39               : 6;
+	uint64_t pd_bank0_ram_flip            : 2;  /**< PD_BANK0_RAM flip syndrome bits on write. */
+	uint64_t pd_bank0_ram_cdis            : 1;  /**< PD_BANK0_RAM ECC correction disable. */
+	uint64_t pd_var_bank_ram_flip         : 2;  /**< PD_VAR_BANK_RAM flip syndrome bits on write. */
+	uint64_t pd_var_bank_ram_cdis         : 1;  /**< PD_VAR_BANK_RAM ECC correction disable. */
+	uint64_t tx_fifo_crc_ram_flip         : 2;  /**< TX_FIFO_CRC_RAM flip syndrome bits on write. */
+	uint64_t tx_fifo_crc_ram_cdis         : 1;  /**< TX_FIFO_CRC_RAM ECC correction disable. */
+	uint64_t tx_fifo_hdr_ram_flip         : 2;  /**< TX_FIFO_HDR_RAM flip syndrome bits on write. */
+	uint64_t tx_fifo_hdr_ram_cdis         : 1;  /**< TX_FIFO_HDR_RAM ECC correction disable. */
+	uint64_t tx_fifo_pkt_ram_flip         : 2;  /**< TX_FIFO_PKT_RAM flip syndrome bits on write. */
+	uint64_t tx_fifo_pkt_ram_cdis         : 1;  /**< TX_FIFO_PKT_RAM ECC correction disable. */
+	uint64_t add_work_fifo_flip           : 2;  /**< ADD_WORK_FIFO flip syndrome bits on write. */
+	uint64_t add_work_fifo_cdis           : 1;  /**< ADD_WORK_FIFO ECC correction disable. */
+	uint64_t send_mem_fifo_flip           : 2;  /**< SEND_MEM_FIFO flip syndrome bits on write. */
+	uint64_t send_mem_fifo_cdis           : 1;  /**< SEND_MEM_FIFO ECC correction disable. */
+	uint64_t send_mem_stdn_fifo_flip      : 2;  /**< SEND_MEM_STDN_FIFO flip syndrome bits on write. */
+	uint64_t send_mem_stdn_fifo_cdis      : 1;  /**< SEND_MEM_STDN_FIFO ECC correction disable. */
+	uint64_t send_mem_ts_fifo_flip        : 2;  /**< SEND_MEM_TS_FIFO flip syndrome bits on write. */
+	uint64_t send_mem_ts_fifo_cdis        : 1;  /**< SEND_MEM_TS_FIFO ECC correction disable. */
+	uint64_t nxt_link_ptr_ram_flip        : 2;  /**< NXT_LINK_PTR_RAM flip syndrome bits on write. */
+	uint64_t nxt_link_ptr_ram_cdis        : 1;  /**< NXT_LINK_PTR_RAM ECC correction disable. */
+	uint64_t pkt_mrk_ram_flip             : 2;  /**< PKT_MRK_RAM flip syndrome bits on write. */
+	uint64_t pkt_mrk_ram_cdis             : 1;  /**< PKT_MRK_RAM ECC correction disable. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t pkt_mrk_ram_cdis             : 1;
+	uint64_t pkt_mrk_ram_flip             : 2;
+	uint64_t nxt_link_ptr_ram_cdis        : 1;
+	uint64_t nxt_link_ptr_ram_flip        : 2;
+	uint64_t send_mem_ts_fifo_cdis        : 1;
+	uint64_t send_mem_ts_fifo_flip        : 2;
+	uint64_t send_mem_stdn_fifo_cdis      : 1;
+	uint64_t send_mem_stdn_fifo_flip      : 2;
+	uint64_t send_mem_fifo_cdis           : 1;
+	uint64_t send_mem_fifo_flip           : 2;
+	uint64_t add_work_fifo_cdis           : 1;
+	uint64_t add_work_fifo_flip           : 2;
+	uint64_t tx_fifo_pkt_ram_cdis         : 1;
+	uint64_t tx_fifo_pkt_ram_flip         : 2;
+	uint64_t tx_fifo_hdr_ram_cdis         : 1;
+	uint64_t tx_fifo_hdr_ram_flip         : 2;
+	uint64_t tx_fifo_crc_ram_cdis         : 1;
+	uint64_t tx_fifo_crc_ram_flip         : 2;
+	uint64_t pd_var_bank_ram_cdis         : 1;
+	uint64_t pd_var_bank_ram_flip         : 2;
+	uint64_t pd_bank0_ram_cdis            : 1;
+	uint64_t pd_bank0_ram_flip            : 2;
+	uint64_t reserved_34_39               : 6;
+	uint64_t pd_bank3_ram_cdis            : 1;
+	uint64_t pd_bank3_ram_flip            : 2;
+	uint64_t peb_st_inf_ram_cdis          : 1;
+	uint64_t peb_st_inf_ram_flip          : 2;
+	uint64_t reserved_46_48               : 3;
+	uint64_t pdm_pse_buf_ram_cdis         : 1;
+	uint64_t pdm_pse_buf_ram_flip         : 2;
+	uint64_t pdm_resp_buf_ram_cdis        : 1;
+	uint64_t pdm_resp_buf_ram_flip        : 2;
+	uint64_t iobp1_fifo_ram_cdis          : 1;
+	uint64_t iobp1_fifo_ram_flip          : 2;
+	uint64_t iobp0_fifo_ram_cdis          : 1;
+	uint64_t iobp0_fifo_ram_flip          : 2;
+	uint64_t iobp1_uid_fifo_ram_cdis      : 1;
+	uint64_t iobp1_uid_fifo_ram_flip      : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_peb_ecc_ctl0_s        cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_ctl0 cvmx_pko_peb_ecc_ctl0_t;
@@ -10641,14 +11619,35 @@ union cvmx_pko_peb_ecc_ctl1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ts_addwork_ram_flip          : 2;  /**< TS_ADDWORK_RAM flip syndrome bits on write. */
 	uint64_t ts_addwork_ram_cdis          : 1;  /**< TS_ADDWORK_RAM ECC correction disable. */
+	uint64_t state_mem0_flip              : 2;  /**< STATE_MEM0 flip syndrome bits on write. */
+	uint64_t state_mem0_cdis              : 1;  /**< STATE_MEM0 ECC correction disable. */
+	uint64_t reserved_52_57               : 6;
+	uint64_t state_mem3_flip              : 2;  /**< STATE_MEM3 flip syndrome bits on write. */
+	uint64_t state_mem3_cdis              : 1;  /**< STATE_MEM3 ECC correction disable. */
+	uint64_t reserved_0_48                : 49;
+#else
+	uint64_t reserved_0_48                : 49;
+	uint64_t state_mem3_cdis              : 1;
+	uint64_t state_mem3_flip              : 2;
+	uint64_t reserved_52_57               : 6;
+	uint64_t state_mem0_cdis              : 1;
+	uint64_t state_mem0_flip              : 2;
+	uint64_t ts_addwork_ram_cdis          : 1;
+	uint64_t ts_addwork_ram_flip          : 2;
+#endif
+	} s;
+	struct cvmx_pko_peb_ecc_ctl1_s        cn73xx;
+	struct cvmx_pko_peb_ecc_ctl1_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ts_addwork_ram_flip          : 2;  /**< TS_ADDWORK_RAM flip syndrome bits on write. */
+	uint64_t ts_addwork_ram_cdis          : 1;  /**< TS_ADDWORK_RAM ECC correction disable. */
 	uint64_t reserved_0_60                : 61;
 #else
 	uint64_t reserved_0_60                : 61;
 	uint64_t ts_addwork_ram_cdis          : 1;
 	uint64_t ts_addwork_ram_flip          : 2;
 #endif
-	} s;
-	struct cvmx_pko_peb_ecc_ctl1_s        cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_ctl1 cvmx_pko_peb_ecc_ctl1_t;
 
@@ -10703,6 +11702,163 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
 	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t state_mem0_dbe               : 1;  /**< Double-bit error for STATE_MEM0. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem3_dbe               : 1;  /**< Double-bit error for STATE_MEM3. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t reserved_0_37                : 38;
+#else
+	uint64_t reserved_0_37                : 38;
+	uint64_t state_mem3_dbe               : 1;
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem0_dbe               : 1;
+	uint64_t ts_addwork_ram_dbe           : 1;
+	uint64_t pkt_mrk_ram_dbe              : 1;
+	uint64_t nxt_link_ptr_ram_dbe         : 1;
+	uint64_t send_mem_ts_fifo_dbe         : 1;
+	uint64_t send_mem_stdn_fifo_dbe       : 1;
+	uint64_t send_mem_fifo_dbe            : 1;
+	uint64_t add_work_fifo_dbe            : 1;
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;
+	uint64_t tx_fifo_crc_ram_dbe          : 1;
+	uint64_t pd_var_bank_ram_dbe          : 1;
+	uint64_t pd_bank0_ram_dbe             : 1;
+	uint64_t pd_bank1_ram_dbe             : 1;
+	uint64_t pd_bank2_ram_dbe             : 1;
+	uint64_t pd_bank3_ram_dbe             : 1;
+	uint64_t peb_st_inf_ram_dbe           : 1;
+	uint64_t peb_sm_jmp_ram_dbe           : 1;
+	uint64_t pdm_pse_buf_ram_dbe          : 1;
+	uint64_t pdm_resp_buf_ram_dbe         : 1;
+	uint64_t iobp1_fifo_ram_dbe           : 1;
+	uint64_t iobp0_fifo_ram_dbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
+#endif
+	} s;
+	struct cvmx_pko_peb_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t reserved_58_58               : 1;
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t state_mem0_dbe               : 1;  /**< Double-bit error for STATE_MEM0. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem3_dbe               : 1;  /**< Double-bit error for STATE_MEM3. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t reserved_0_37                : 38;
+#else
+	uint64_t reserved_0_37                : 38;
+	uint64_t state_mem3_dbe               : 1;
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem0_dbe               : 1;
+	uint64_t ts_addwork_ram_dbe           : 1;
+	uint64_t pkt_mrk_ram_dbe              : 1;
+	uint64_t nxt_link_ptr_ram_dbe         : 1;
+	uint64_t send_mem_ts_fifo_dbe         : 1;
+	uint64_t send_mem_stdn_fifo_dbe       : 1;
+	uint64_t send_mem_fifo_dbe            : 1;
+	uint64_t add_work_fifo_dbe            : 1;
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;
+	uint64_t tx_fifo_crc_ram_dbe          : 1;
+	uint64_t pd_var_bank_ram_dbe          : 1;
+	uint64_t pd_bank0_ram_dbe             : 1;
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank3_ram_dbe             : 1;
+	uint64_t peb_st_inf_ram_dbe           : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t pdm_pse_buf_ram_dbe          : 1;
+	uint64_t pdm_resp_buf_ram_dbe         : 1;
+	uint64_t iobp1_fifo_ram_dbe           : 1;
+	uint64_t iobp0_fifo_ram_dbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
+#endif
+	} cn73xx;
+	struct cvmx_pko_peb_ecc_dbe_sts0_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t pd_bank2_ram_dbe             : 1;  /**< Double-bit error for PD_BANK2_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
+	uint64_t pd_bank1_ram_dbe             : 1;  /**< Double-bit error for PD_BANK1_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
 	uint64_t reserved_0_41                : 42;
 #else
 	uint64_t reserved_0_41                : 42;
@@ -10729,8 +11885,7 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	uint64_t iobp0_fifo_ram_dbe           : 1;
 	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
 #endif
-	} s;
-	struct cvmx_pko_peb_ecc_dbe_sts0_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_dbe_sts0 cvmx_pko_peb_ecc_dbe_sts0_t;
 
@@ -10772,16 +11927,174 @@ union cvmx_pko_peb_ecc_dbe_sts_cmb0 {
 	uint64_t peb_dbe_cmb0                 : 1;
 #endif
 	} s;
-	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn78xx;
-};
-typedef union cvmx_pko_peb_ecc_dbe_sts_cmb0 cvmx_pko_peb_ecc_dbe_sts_cmb0_t;
-
-/**
- * cvmx_pko_peb_ecc_sbe_sts0
- */
-union cvmx_pko_peb_ecc_sbe_sts0 {
-	uint64_t u64;
-	struct cvmx_pko_peb_ecc_sbe_sts0_s {
+	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn78xx;
+};
+typedef union cvmx_pko_peb_ecc_dbe_sts_cmb0 cvmx_pko_peb_ecc_dbe_sts_cmb0_t;
+
+/**
+ * cvmx_pko_peb_ecc_sbe_sts0
+ */
+union cvmx_pko_peb_ecc_sbe_sts0 {
+	uint64_t u64;
+	struct cvmx_pko_peb_ecc_sbe_sts0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t pd_bank2_ram_sbe             : 1;  /**< Single-bit error for PD_BANK2_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
+	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t state_mem0_sbe               : 1;  /**< Single-bit error for STATE_MEM0. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem3_sbe               : 1;  /**< Single-bit error for STATE_MEM3. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t reserved_0_37                : 38;
+#else
+	uint64_t reserved_0_37                : 38;
+	uint64_t state_mem3_sbe               : 1;
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem0_sbe               : 1;
+	uint64_t ts_addwork_ram_sbe           : 1;
+	uint64_t pkt_mrk_ram_sbe              : 1;
+	uint64_t nxt_link_ptr_ram_sbe         : 1;
+	uint64_t send_mem_ts_fifo_sbe         : 1;
+	uint64_t send_mem_stdn_fifo_sbe       : 1;
+	uint64_t send_mem_fifo_sbe            : 1;
+	uint64_t add_work_fifo_sbe            : 1;
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;
+	uint64_t tx_fifo_crc_ram_sbe          : 1;
+	uint64_t pd_var_bank_ram_sbe          : 1;
+	uint64_t pd_bank0_ram_sbe             : 1;
+	uint64_t pd_bank1_ram_sbe             : 1;
+	uint64_t pd_bank2_ram_sbe             : 1;
+	uint64_t pd_bank3_ram_sbe             : 1;
+	uint64_t peb_st_inf_ram_sbe           : 1;
+	uint64_t peb_sm_jmp_ram_sbe           : 1;
+	uint64_t pdm_pse_buf_ram_sbe          : 1;
+	uint64_t pdm_resp_buf_ram_sbe         : 1;
+	uint64_t iobp1_fifo_ram_sbe           : 1;
+	uint64_t iobp0_fifo_ram_sbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
+#endif
+	} s;
+	struct cvmx_pko_peb_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t reserved_58_58               : 1;
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t state_mem0_sbe               : 1;  /**< Single-bit error for STATE_MEM0. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem3_sbe               : 1;  /**< Single-bit error for STATE_MEM3. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t reserved_0_37                : 38;
+#else
+	uint64_t reserved_0_37                : 38;
+	uint64_t state_mem3_sbe               : 1;
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem0_sbe               : 1;
+	uint64_t ts_addwork_ram_sbe           : 1;
+	uint64_t pkt_mrk_ram_sbe              : 1;
+	uint64_t nxt_link_ptr_ram_sbe         : 1;
+	uint64_t send_mem_ts_fifo_sbe         : 1;
+	uint64_t send_mem_stdn_fifo_sbe       : 1;
+	uint64_t send_mem_fifo_sbe            : 1;
+	uint64_t add_work_fifo_sbe            : 1;
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;
+	uint64_t tx_fifo_crc_ram_sbe          : 1;
+	uint64_t pd_var_bank_ram_sbe          : 1;
+	uint64_t pd_bank0_ram_sbe             : 1;
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank3_ram_sbe             : 1;
+	uint64_t peb_st_inf_ram_sbe           : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t pdm_pse_buf_ram_sbe          : 1;
+	uint64_t pdm_resp_buf_ram_sbe         : 1;
+	uint64_t iobp1_fifo_ram_sbe           : 1;
+	uint64_t iobp0_fifo_ram_sbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
+#endif
+	} cn73xx;
+	struct cvmx_pko_peb_ecc_sbe_sts0_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
@@ -10853,8 +12166,7 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	uint64_t iobp0_fifo_ram_sbe           : 1;
 	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
 #endif
-	} s;
-	struct cvmx_pko_peb_ecc_sbe_sts0_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_sbe_sts0 cvmx_pko_peb_ecc_sbe_sts0_t;
 
@@ -10896,11 +12208,30 @@ union cvmx_pko_peb_ecc_sbe_sts_cmb0 {
 	uint64_t peb_sbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_sbe_sts_cmb0 cvmx_pko_peb_ecc_sbe_sts_cmb0_t;
 
 /**
+ * cvmx_pko_peb_eco
+ */
+union cvmx_pko_peb_eco {
+	uint64_t u64;
+	struct cvmx_pko_peb_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pko_peb_eco_s             cn73xx;
+};
+typedef union cvmx_pko_peb_eco cvmx_pko_peb_eco_t;
+
+/**
  * cvmx_pko_peb_err_int
  */
 union cvmx_pko_peb_err_int {
@@ -10941,6 +12272,7 @@ union cvmx_pko_peb_err_int {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_pko_peb_err_int_s         cn73xx;
 	struct cvmx_pko_peb_err_int_s         cn78xx;
 };
 typedef union cvmx_pko_peb_err_int cvmx_pko_peb_err_int_t;
@@ -10963,6 +12295,7 @@ union cvmx_pko_peb_ext_hdr_def_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_ext_hdr_def_err_info_s cn73xx;
 	struct cvmx_pko_peb_ext_hdr_def_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_ext_hdr_def_err_info cvmx_pko_peb_ext_hdr_def_err_info_t;
@@ -10985,6 +12318,7 @@ union cvmx_pko_peb_fcs_sop_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_fcs_sop_err_info_s cn73xx;
 	struct cvmx_pko_peb_fcs_sop_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_fcs_sop_err_info cvmx_pko_peb_fcs_sop_err_info_t;
@@ -11007,6 +12341,7 @@ union cvmx_pko_peb_jump_def_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_jump_def_err_info_s cn73xx;
 	struct cvmx_pko_peb_jump_def_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_jump_def_err_info cvmx_pko_peb_jump_def_err_info_t;
@@ -11027,6 +12362,7 @@ union cvmx_pko_peb_macx_cfg_wr_err_info {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_pko_peb_macx_cfg_wr_err_info_s cn73xx;
 	struct cvmx_pko_peb_macx_cfg_wr_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_macx_cfg_wr_err_info cvmx_pko_peb_macx_cfg_wr_err_info_t;
@@ -11049,6 +12385,7 @@ union cvmx_pko_peb_max_link_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_max_link_err_info_s cn73xx;
 	struct cvmx_pko_peb_max_link_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_max_link_err_info cvmx_pko_peb_max_link_err_info_t;
@@ -11067,6 +12404,7 @@ union cvmx_pko_peb_ncb_cfg {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_peb_ncb_cfg_s         cn73xx;
 	struct cvmx_pko_peb_ncb_cfg_s         cn78xx;
 };
 typedef union cvmx_pko_peb_ncb_cfg cvmx_pko_peb_ncb_cfg_t;
@@ -11089,6 +12427,7 @@ union cvmx_pko_peb_pad_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_pad_err_info_s    cn73xx;
 	struct cvmx_pko_peb_pad_err_info_s    cn78xx;
 };
 typedef union cvmx_pko_peb_pad_err_info cvmx_pko_peb_pad_err_info_t;
@@ -11111,6 +12450,7 @@ union cvmx_pko_peb_pse_fifo_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_pse_fifo_err_info_s cn73xx;
 	struct cvmx_pko_peb_pse_fifo_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_pse_fifo_err_info cvmx_pko_peb_pse_fifo_err_info_t;
@@ -11133,6 +12473,7 @@ union cvmx_pko_peb_subd_addr_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_subd_addr_err_info_s cn73xx;
 	struct cvmx_pko_peb_subd_addr_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_subd_addr_err_info cvmx_pko_peb_subd_addr_err_info_t;
@@ -11155,6 +12496,7 @@ union cvmx_pko_peb_subd_size_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_subd_size_err_info_s cn73xx;
 	struct cvmx_pko_peb_subd_size_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_subd_size_err_info cvmx_pko_peb_subd_size_err_info_t;
@@ -11177,6 +12519,7 @@ union cvmx_pko_peb_trunc_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_trunc_err_info_s  cn73xx;
 	struct cvmx_pko_peb_trunc_err_info_s  cn78xx;
 };
 typedef union cvmx_pko_peb_trunc_err_info cvmx_pko_peb_trunc_err_info_t;
@@ -11203,6 +12546,7 @@ union cvmx_pko_peb_tso_cfg {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_peb_tso_cfg_s         cn73xx;
 	struct cvmx_pko_peb_tso_cfg_s         cn78xx;
 };
 typedef union cvmx_pko_peb_tso_cfg cvmx_pko_peb_tso_cfg_t;
@@ -11219,6 +12563,7 @@ union cvmx_pko_pq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_pq_csr_bus_debug_s    cn73xx;
 	struct cvmx_pko_pq_csr_bus_debug_s    cn78xx;
 };
 typedef union cvmx_pko_pq_csr_bus_debug cvmx_pko_pq_csr_bus_debug_t;
@@ -11237,6 +12582,7 @@ union cvmx_pko_pq_debug_green {
 	uint64_t g_valid                      : 32;
 #endif
 	} s;
+	struct cvmx_pko_pq_debug_green_s      cn73xx;
 	struct cvmx_pko_pq_debug_green_s      cn78xx;
 };
 typedef union cvmx_pko_pq_debug_green cvmx_pko_pq_debug_green_t;
@@ -11255,6 +12601,7 @@ union cvmx_pko_pq_debug_links {
 	uint64_t links_ready                  : 32;
 #endif
 	} s;
+	struct cvmx_pko_pq_debug_links_s      cn73xx;
 	struct cvmx_pko_pq_debug_links_s      cn78xx;
 };
 typedef union cvmx_pko_pq_debug_links cvmx_pko_pq_debug_links_t;
@@ -11275,6 +12622,7 @@ union cvmx_pko_pq_debug_yellow {
 	uint64_t y_valid                      : 32;
 #endif
 	} s;
+	struct cvmx_pko_pq_debug_yellow_s     cn73xx;
 	struct cvmx_pko_pq_debug_yellow_s     cn78xx;
 };
 typedef union cvmx_pko_pq_debug_yellow cvmx_pko_pq_debug_yellow_t;
@@ -11291,6 +12639,7 @@ union cvmx_pko_pqa_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_pqa_debug_s           cn73xx;
 	struct cvmx_pko_pqa_debug_s           cn78xx;
 };
 typedef union cvmx_pko_pqa_debug cvmx_pko_pqa_debug_t;
@@ -11310,6 +12659,7 @@ union cvmx_pko_pqb_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_pqb_debug_s           cn73xx;
 	struct cvmx_pko_pqb_debug_s           cn78xx;
 };
 typedef union cvmx_pko_pqb_debug cvmx_pko_pqb_debug_t;
@@ -11324,6 +12674,44 @@ union cvmx_pko_pse_dq_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t rt7_sram                     : 1;  /**< Result table 7 - DQ FIFO[1023:896]. */
+	uint64_t rt6_sram                     : 1;  /**< Result table 6 - DQ FIFO[895:768]. */
+	uint64_t rt5_sram                     : 1;  /**< Result table 5 - DQ FIFO[767:640]. */
+	uint64_t reserved_4_4                 : 1;
+	uint64_t rt3_sram                     : 1;  /**< Result table 3 - DQ FIFO[511:384]. */
+	uint64_t rt2_sram                     : 1;  /**< Result table 2 - DQ FIFO[383:256]. */
+	uint64_t rt1_sram                     : 1;  /**< Result table 1 - DQ FIFO[255:128]. */
+	uint64_t rt0_sram                     : 1;  /**< Result table 0 - DQ FIFO[127:0]. */
+#else
+	uint64_t rt0_sram                     : 1;
+	uint64_t rt1_sram                     : 1;
+	uint64_t rt2_sram                     : 1;
+	uint64_t rt3_sram                     : 1;
+	uint64_t reserved_4_4                 : 1;
+	uint64_t rt5_sram                     : 1;
+	uint64_t rt6_sram                     : 1;
+	uint64_t rt7_sram                     : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_pko_pse_dq_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t wt_sram                      : 1;  /**< Work table. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t rt1_sram                     : 1;  /**< Result table 1 - DQ FIFO[255:128]. */
+	uint64_t rt0_sram                     : 1;  /**< Result table 0 - DQ FIFO[127:0]. */
+#else
+	uint64_t rt0_sram                     : 1;
+	uint64_t rt1_sram                     : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t wt_sram                      : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} cn73xx;
+	struct cvmx_pko_pse_dq_bist_status_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t wt_sram                      : 1;  /**< Work table. */
 	uint64_t rt7_sram                     : 1;  /**< Result table 7 - DQ FIFO[1023:896]. */
@@ -11346,8 +12734,7 @@ union cvmx_pko_pse_dq_bist_status {
 	uint64_t wt_sram                      : 1;
 	uint64_t reserved_9_63                : 55;
 #endif
-	} s;
-	struct cvmx_pko_pse_dq_bist_status_s  cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_pse_dq_bist_status cvmx_pko_pse_dq_bist_status_t;
 
@@ -11399,6 +12786,27 @@ union cvmx_pko_pse_dq_ecc_ctl0 {
 	uint64_t dq_wt_ram_flip               : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dq_wt_ram_flip               : 2;  /**< DQ_WT_RAM flip syndrome bits on write. */
+	uint64_t dq_wt_ram_cdis               : 1;  /**< DQ_WT_RAM ECC correction disable. */
+	uint64_t reserved_43_60               : 18;
+	uint64_t dq_rt1_flip                  : 2;  /**< DQ_RT1 flip syndrome bits on write. */
+	uint64_t dq_rt1_cdis                  : 1;  /**< DQ_RT1 ECC correction disable. */
+	uint64_t dq_rt0_flip                  : 2;  /**< DQ_RT0 flip syndrome bits on write. */
+	uint64_t dq_rt0_cdis                  : 1;  /**< DQ_RT0 ECC correction disable. */
+	uint64_t reserved_0_36                : 37;
+#else
+	uint64_t reserved_0_36                : 37;
+	uint64_t dq_rt0_cdis                  : 1;
+	uint64_t dq_rt0_flip                  : 2;
+	uint64_t dq_rt1_cdis                  : 1;
+	uint64_t dq_rt1_flip                  : 2;
+	uint64_t reserved_43_60               : 18;
+	uint64_t dq_wt_ram_cdis               : 1;
+	uint64_t dq_wt_ram_flip               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_dq_ecc_ctl0_s     cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_ctl0 cvmx_pko_pse_dq_ecc_ctl0_t;
@@ -11433,6 +12841,21 @@ union cvmx_pko_pse_dq_ecc_dbe_sts0 {
 	uint64_t dq_wt_ram_dbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dq_wt_ram_dbe                : 1;  /**< Double-bit error for DQ_WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.wt_sram */
+	uint64_t reserved_57_62               : 6;
+	uint64_t dq_rt1_dbe                   : 1;  /**< Double-bit error for DQ_RT1_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt1 */
+	uint64_t dq_rt0_dbe                   : 1;  /**< Double-bit error for DQ_RT0_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt0 */
+	uint64_t reserved_0_54                : 55;
+#else
+	uint64_t reserved_0_54                : 55;
+	uint64_t dq_rt0_dbe                   : 1;
+	uint64_t dq_rt1_dbe                   : 1;
+	uint64_t reserved_57_62               : 6;
+	uint64_t dq_wt_ram_dbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_dbe_sts0 cvmx_pko_pse_dq_ecc_dbe_sts0_t;
@@ -11464,6 +12887,7 @@ union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 {
 	uint64_t pse_dq_dbe_cmb0              : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_t;
@@ -11498,6 +12922,21 @@ union cvmx_pko_pse_dq_ecc_sbe_sts0 {
 	uint64_t dq_wt_ram_sbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dq_wt_ram_sbe                : 1;  /**< Single-bit error for DQ_WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.wt_sram */
+	uint64_t reserved_57_62               : 6;
+	uint64_t dq_rt1_sbe                   : 1;  /**< Single-bit error for DQ_RT1_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt1 */
+	uint64_t dq_rt0_sbe                   : 1;  /**< Single-bit error for DQ_RT0_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt0 */
+	uint64_t reserved_0_54                : 55;
+#else
+	uint64_t reserved_0_54                : 55;
+	uint64_t dq_rt0_sbe                   : 1;
+	uint64_t dq_rt1_sbe                   : 1;
+	uint64_t reserved_57_62               : 6;
+	uint64_t dq_wt_ram_sbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_sbe_sts0 cvmx_pko_pse_dq_ecc_sbe_sts0_t;
@@ -11529,6 +12968,7 @@ union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 {
 	uint64_t pse_dq_sbe_cmb0              : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_t;
@@ -11578,6 +13018,43 @@ union cvmx_pko_pse_pq_bist_status {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t tp_sram                      : 1;  /**< Topology parent - pko_pse_pq_srf32x5e */
+	uint64_t reserved_13_13               : 1;
+	uint64_t wmd_sram                     : 1;  /**< Dynamic watermark state - pko_pse_wmd_srf1024x49e */
+	uint64_t reserved_11_11               : 1;
+	uint64_t cxd_sram                     : 1;  /**< Dynamic channel state - pko_pse_cxd_srf32x31e */
+	uint64_t dqd_sram                     : 1;  /**< DQ dropped stats - pko_pse_stats_srf1024x88 */
+	uint64_t dqs_sram                     : 1;  /**< DQ sent stats - pko_pse_stats_srf1024x88 */
+	uint64_t pqd_sram                     : 1;  /**< PQ dropped stats - pko_pse_stats_srf32x88 */
+	uint64_t pqr_sram                     : 1;  /**< PQ read stats - pko_pse_stats_srf32x88 */
+	uint64_t pqy_sram                     : 1;  /**< PQ yellow stats - pko_pse_stats_srf32x88 */
+	uint64_t pqg_sram                     : 1;  /**< PQ green stats - pko_pse_stats_srf32x88 */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state - pko_pse_std_srf32x105e */
+	uint64_t st_sram                      : 1;  /**< Static shaping configuration - pko_pse_sts_srf32x74e */
+	uint64_t reserved_1_1                 : 1;
+	uint64_t cxs_sram                     : 1;  /**< Static channel credit configuration - pko_pse_cx0_srf32x6e */
+#else
+	uint64_t cxs_sram                     : 1;
+	uint64_t reserved_1_1                 : 1;
+	uint64_t st_sram                      : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t pqg_sram                     : 1;
+	uint64_t pqy_sram                     : 1;
+	uint64_t pqr_sram                     : 1;
+	uint64_t pqd_sram                     : 1;
+	uint64_t dqs_sram                     : 1;
+	uint64_t dqd_sram                     : 1;
+	uint64_t cxd_sram                     : 1;
+	uint64_t reserved_11_11               : 1;
+	uint64_t wmd_sram                     : 1;
+	uint64_t reserved_13_13               : 1;
+	uint64_t tp_sram                      : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_pq_bist_status_s  cn78xx;
 };
 typedef union cvmx_pko_pse_pq_bist_status cvmx_pko_pse_pq_bist_status_t;
@@ -11626,6 +13103,39 @@ union cvmx_pko_pse_pq_ecc_ctl0 {
 	uint64_t pq_cxs_ram_flip              : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pq_cxs_ram_flip              : 2;  /**< PQ_CXS_RAM flip syndrome bits on write. */
+	uint64_t pq_cxs_ram_cdis              : 1;  /**< PQ_CXS_RAM ECC correction disable. */
+	uint64_t pq_cxd_ram_flip              : 2;  /**< PQ_CXD_RAM flip syndrome bits on write. */
+	uint64_t pq_cxd_ram_cdis              : 1;  /**< PQ_CXD_RAM ECC correction disable. */
+	uint64_t reserved_55_57               : 3;
+	uint64_t tp_sram_flip                 : 2;  /**< TP_SRAM flip syndrome bits on write. */
+	uint64_t tp_sram_cdis                 : 1;  /**< TP_SRAM ECC correction disable. */
+	uint64_t pq_std_ram_flip              : 2;  /**< PQ_STD_RAM flip syndrome bits on write. */
+	uint64_t pq_std_ram_cdis              : 1;  /**< PQ_STD_RAM ECC correction disable. */
+	uint64_t pq_st_ram_flip               : 2;  /**< PQ_ST_RAM flip syndrome bits on write. */
+	uint64_t pq_st_ram_cdis               : 1;  /**< PQ_ST_RAM ECC correction disable. */
+	uint64_t pq_wmd_ram_flip              : 2;  /**< PQ_WMD_RAM flip syndrome bits on write. */
+	uint64_t pq_wmd_ram_cdis              : 1;  /**< PQ_WMD_RAM ECC correction disable. */
+	uint64_t reserved_0_42                : 43;
+#else
+	uint64_t reserved_0_42                : 43;
+	uint64_t pq_wmd_ram_cdis              : 1;
+	uint64_t pq_wmd_ram_flip              : 2;
+	uint64_t pq_st_ram_cdis               : 1;
+	uint64_t pq_st_ram_flip               : 2;
+	uint64_t pq_std_ram_cdis              : 1;
+	uint64_t pq_std_ram_flip              : 2;
+	uint64_t tp_sram_cdis                 : 1;
+	uint64_t tp_sram_flip                 : 2;
+	uint64_t reserved_55_57               : 3;
+	uint64_t pq_cxd_ram_cdis              : 1;
+	uint64_t pq_cxd_ram_flip              : 2;
+	uint64_t pq_cxs_ram_cdis              : 1;
+	uint64_t pq_cxs_ram_flip              : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_pq_ecc_ctl0_s     cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_ctl0 cvmx_pko_pse_pq_ecc_ctl0_t;
@@ -11665,6 +13175,32 @@ union cvmx_pko_pse_pq_ecc_dbe_sts0 {
 	uint64_t pq_cxs_ram_dbe               : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pq_cxs_ram_dbe               : 1;  /**< Double-bit error for PQ_CXS_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram */
+	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram */
+	uint64_t reserved_61_61               : 1;
+	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram */
+	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram */
+	uint64_t pq_st_ram_dbe                : 1;  /**< Double-bit error for PQ_ST_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram */
+	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+	uint64_t reserved_0_56                : 57;
+#else
+	uint64_t reserved_0_56                : 57;
+	uint64_t pq_wmd_ram_dbe               : 1;
+	uint64_t pq_st_ram_dbe                : 1;
+	uint64_t pq_std_ram_dbe               : 1;
+	uint64_t tp_sram_dbe                  : 1;
+	uint64_t reserved_61_61               : 1;
+	uint64_t pq_cxd_ram_dbe               : 1;
+	uint64_t pq_cxs_ram_dbe               : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_dbe_sts0 cvmx_pko_pse_pq_ecc_dbe_sts0_t;
@@ -11683,18 +13219,19 @@ union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 {
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram (chip_pass: "o78<2.0")
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram (chip_pass: "o78<2.0") */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
 	uint64_t pse_pq_dbe_cmb0              : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_t;
@@ -11729,11 +13266,37 @@ union cvmx_pko_pse_pq_ecc_sbe_sts0 {
 	uint64_t pq_st_ram_sbe                : 1;
 	uint64_t pq_std_ram_sbe               : 1;
 	uint64_t tp_sram_sbe                  : 1;
-	uint64_t irq_fifo_sram_sbe            : 1;
+	uint64_t irq_fifo_sram_sbe            : 1;
+	uint64_t pq_cxd_ram_sbe               : 1;
+	uint64_t pq_cxs_ram_sbe               : 1;
+#endif
+	} s;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pq_cxs_ram_sbe               : 1;  /**< Single-bit error for PQ_CXS_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram */
+	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram */
+	uint64_t reserved_61_61               : 1;
+	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram */
+	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram */
+	uint64_t pq_st_ram_sbe                : 1;  /**< Single-bit error for PQ_ST_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram */
+	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+	uint64_t reserved_0_56                : 57;
+#else
+	uint64_t reserved_0_56                : 57;
+	uint64_t pq_wmd_ram_sbe               : 1;
+	uint64_t pq_st_ram_sbe                : 1;
+	uint64_t pq_std_ram_sbe               : 1;
+	uint64_t tp_sram_sbe                  : 1;
+	uint64_t reserved_61_61               : 1;
 	uint64_t pq_cxd_ram_sbe               : 1;
 	uint64_t pq_cxs_ram_sbe               : 1;
 #endif
-	} s;
+	} cn73xx;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_sbe_sts0 cvmx_pko_pse_pq_ecc_sbe_sts0_t;
@@ -11752,18 +13315,19 @@ union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 {
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram (chip_pass: "o78<2.0")
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram (chip_pass: "o78<2.0") */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
 	uint64_t pse_pq_sbe_cmb0              : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_t;
@@ -11825,6 +13389,53 @@ union cvmx_pko_pse_sq1_bist_status {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< SQ[5:1] scheduling configuration */
+	uint64_t pc_sram                      : 1;  /**< SQ[1] physical channel - pko_pse_pc_srf32x12e */
+	uint64_t xon_sram                     : 1;  /**< XON SRAM */
+	uint64_t cc_sram                      : 1;  /**< SQ[1] channel credit OK state array */
+	uint64_t vc1_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
+	uint64_t vc0_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
+	uint64_t reserved_20_22               : 3;
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t xo_sram                      : 1;  /**< XOFF SRAM */
+	uint64_t rt_sram                      : 1;  /**< Result table */
+	uint64_t reserved_9_16                : 8;
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM */
+	uint64_t cxd_sram                     : 1;  /**< SQ[1] dynamic channel credit state */
+	uint64_t cxs_sram                     : 1;  /**< SQ[1] static channel credit configuration */
+	uint64_t nt_sram                      : 1;  /**< SQ[5:1] next pointer table */
+	uint64_t pt_sram                      : 1;  /**< SQ[5:1] previous pointer table */
+	uint64_t wt_sram                      : 1;  /**< SQ[5:1] work table */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t cxs_sram                     : 1;
+	uint64_t cxd_sram                     : 1;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t tw1_cmd_fifo                 : 1;
+	uint64_t reserved_9_16                : 8;
+	uint64_t rt_sram                      : 1;
+	uint64_t xo_sram                      : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t reserved_20_22               : 3;
+	uint64_t vc0_sram                     : 1;
+	uint64_t vc1_sram                     : 1;
+	uint64_t cc_sram                      : 1;
+	uint64_t xon_sram                     : 1;
+	uint64_t pc_sram                      : 1;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq1_bist_status_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_bist_status cvmx_pko_pse_sq1_bist_status_t;
@@ -11913,6 +13524,75 @@ union cvmx_pko_pse_sq1_ecc_ctl0 {
 	uint64_t cxs_ram_flip                 : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cxs_ram_flip                 : 2;  /**< CXS_RAM flip syndrome bits on write. */
+	uint64_t cxs_ram_cdis                 : 1;  /**< CXS_RAM ECC correction disable. */
+	uint64_t cxd_ram_flip                 : 2;  /**< CXD_RAM flip syndrome bits on write. */
+	uint64_t cxd_ram_cdis                 : 1;  /**< CXD_RAM ECC correction disable. */
+	uint64_t reserved_55_57               : 3;
+	uint64_t vc0_sram_flip                : 2;  /**< VC0_SRAM flip syndrome bits on write. */
+	uint64_t vc0_sram_cdis                : 1;  /**< VC0_SRAM ECC correction disable. */
+	uint64_t sq_pt_ram_flip               : 2;  /**< SQ_PT_RAM flip syndrome bits on write. */
+	uint64_t sq_pt_ram_cdis               : 1;  /**< SQ_PT_RAM ECC correction disable. */
+	uint64_t sq_nt_ram_flip               : 2;  /**< SQ_NT_RAM flip syndrome bits on write. */
+	uint64_t sq_nt_ram_cdis               : 1;  /**< SQ_NT_RAM ECC correction disable. */
+	uint64_t rt_ram_flip                  : 2;  /**< RT_RAM flip syndrome bits on write. */
+	uint64_t rt_ram_cdis                  : 1;  /**< RT_RAM ECC correction disable. */
+	uint64_t pc_ram_flip                  : 2;  /**< PC_RAM flip syndrome bits on write. */
+	uint64_t pc_ram_cdis                  : 1;  /**< PC_RAM ECC correction disable. */
+	uint64_t reserved_37_39               : 3;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;  /**< TW0_CMD_FIFO_RAM flip syndrome bits on write. */
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;  /**< TW0_CMD_FIFO_RAM ECC correction disable. */
+	uint64_t reserved_31_33               : 3;
+	uint64_t tp0_sram_flip                : 2;  /**< TP0_SRAM flip syndrome bits on write. */
+	uint64_t tp0_sram_cdis                : 1;  /**< TP0_SRAM ECC correction disable. */
+	uint64_t reserved_25_27               : 3;
+	uint64_t sts0_ram_flip                : 2;  /**< STS0_RAM flip syndrome bits on write. */
+	uint64_t sts0_ram_cdis                : 1;  /**< STS0_RAM ECC correction disable. */
+	uint64_t reserved_19_21               : 3;
+	uint64_t std0_ram_flip                : 2;  /**< STD0_RAM flip syndrome bits on write. */
+	uint64_t std0_ram_cdis                : 1;  /**< STD0_RAM ECC correction disable. */
+	uint64_t wt_ram_flip                  : 2;  /**< WT_RAM flip syndrome bits on write. */
+	uint64_t wt_ram_cdis                  : 1;  /**< WT_RAM ECC correction disable. */
+	uint64_t sc_ram_flip                  : 2;  /**< SC_RAM flip syndrome bits on write. */
+	uint64_t sc_ram_cdis                  : 1;  /**< SC_RAM ECC correction disable. */
+	uint64_t reserved_0_9                 : 10;
+#else
+	uint64_t reserved_0_9                 : 10;
+	uint64_t sc_ram_cdis                  : 1;
+	uint64_t sc_ram_flip                  : 2;
+	uint64_t wt_ram_cdis                  : 1;
+	uint64_t wt_ram_flip                  : 2;
+	uint64_t std0_ram_cdis                : 1;
+	uint64_t std0_ram_flip                : 2;
+	uint64_t reserved_19_21               : 3;
+	uint64_t sts0_ram_cdis                : 1;
+	uint64_t sts0_ram_flip                : 2;
+	uint64_t reserved_25_27               : 3;
+	uint64_t tp0_sram_cdis                : 1;
+	uint64_t tp0_sram_flip                : 2;
+	uint64_t reserved_31_33               : 3;
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;
+	uint64_t reserved_37_39               : 3;
+	uint64_t pc_ram_cdis                  : 1;
+	uint64_t pc_ram_flip                  : 2;
+	uint64_t rt_ram_cdis                  : 1;
+	uint64_t rt_ram_flip                  : 2;
+	uint64_t sq_nt_ram_cdis               : 1;
+	uint64_t sq_nt_ram_flip               : 2;
+	uint64_t sq_pt_ram_cdis               : 1;
+	uint64_t sq_pt_ram_flip               : 2;
+	uint64_t vc0_sram_cdis                : 1;
+	uint64_t vc0_sram_flip                : 2;
+	uint64_t reserved_55_57               : 3;
+	uint64_t cxd_ram_cdis                 : 1;
+	uint64_t cxd_ram_flip                 : 2;
+	uint64_t cxs_ram_cdis                 : 1;
+	uint64_t cxs_ram_flip                 : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_ctl0_s    cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_ctl0 cvmx_pko_pse_sq1_ecc_ctl0_t;
@@ -11979,6 +13659,58 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts0 {
 	uint64_t cxs_ram_dbe                  : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cxs_ram_dbe                  : 1;  /**< Double-bit error for CXS_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram */
+	uint64_t cxd_ram_dbe                  : 1;  /**< Double-bit error for CXD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram */
+	uint64_t reserved_61_61               : 1;
+	uint64_t vc0_sram_dbe                 : 1;  /**< Double-bit error for VC0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc0_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram */
+	uint64_t pc_ram_dbe                   : 1;  /**< Double-bit error for PC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram */
+	uint64_t reserved_55_55               : 1;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_1.sq_fifo_sram */
+	uint64_t reserved_53_53               : 1;
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram */
+	uint64_t reserved_51_51               : 1;
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts0_sram */
+	uint64_t reserved_49_49               : 1;
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+	uint64_t reserved_0_45                : 46;
+#else
+	uint64_t reserved_0_45                : 46;
+	uint64_t sc_ram_dbe                   : 1;
+	uint64_t wt_ram_dbe                   : 1;
+	uint64_t std0_ram_dbe                 : 1;
+	uint64_t reserved_49_49               : 1;
+	uint64_t sts0_ram_dbe                 : 1;
+	uint64_t reserved_51_51               : 1;
+	uint64_t tp0_sram_dbe                 : 1;
+	uint64_t reserved_53_53               : 1;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;
+	uint64_t reserved_55_55               : 1;
+	uint64_t pc_ram_dbe                   : 1;
+	uint64_t rt_ram_dbe                   : 1;
+	uint64_t sq_nt_ram_dbe                : 1;
+	uint64_t sq_pt_ram_dbe                : 1;
+	uint64_t vc0_sram_dbe                 : 1;
+	uint64_t reserved_61_61               : 1;
+	uint64_t cxd_ram_dbe                  : 1;
+	uint64_t cxs_ram_dbe                  : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_dbe_sts0 cvmx_pko_pse_sq1_ecc_dbe_sts0_t;
@@ -12019,6 +13751,7 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq1_dbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_t;
@@ -12085,6 +13818,58 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts0 {
 	uint64_t cxs_ram_sbe                  : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cxs_ram_sbe                  : 1;  /**< Single-bit error for CXS_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram */
+	uint64_t cxd_ram_sbe                  : 1;  /**< Single-bit error for CXD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram */
+	uint64_t reserved_61_61               : 1;
+	uint64_t vc0_sram_sbe                 : 1;  /**< Single-bit error for VC0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc1_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram */
+	uint64_t pc_ram_sbe                   : 1;  /**< Single-bit error for PC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram */
+	uint64_t reserved_55_55               : 1;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_1.sq_fifo_sram */
+	uint64_t reserved_53_53               : 1;
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram */
+	uint64_t reserved_51_51               : 1;
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts1_sram */
+	uint64_t reserved_49_49               : 1;
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std1_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+	uint64_t reserved_0_45                : 46;
+#else
+	uint64_t reserved_0_45                : 46;
+	uint64_t sc_ram_sbe                   : 1;
+	uint64_t wt_ram_sbe                   : 1;
+	uint64_t std0_ram_sbe                 : 1;
+	uint64_t reserved_49_49               : 1;
+	uint64_t sts0_ram_sbe                 : 1;
+	uint64_t reserved_51_51               : 1;
+	uint64_t tp0_sram_sbe                 : 1;
+	uint64_t reserved_53_53               : 1;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;
+	uint64_t reserved_55_55               : 1;
+	uint64_t pc_ram_sbe                   : 1;
+	uint64_t rt_ram_sbe                   : 1;
+	uint64_t sq_nt_ram_sbe                : 1;
+	uint64_t sq_pt_ram_sbe                : 1;
+	uint64_t vc0_sram_sbe                 : 1;
+	uint64_t reserved_61_61               : 1;
+	uint64_t cxd_ram_sbe                  : 1;
+	uint64_t cxs_ram_sbe                  : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_sbe_sts0 cvmx_pko_pse_sq1_ecc_sbe_sts0_t;
@@ -12125,6 +13910,7 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq1_sbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_t;
@@ -12174,6 +13960,39 @@ union cvmx_pko_pse_sq2_bist_status {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< Scheduling configuration. */
+	uint64_t reserved_20_27               : 8;
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration. */
+	uint64_t reserved_18_18               : 1;
+	uint64_t rt_sram                      : 1;  /**< Result table. */
+	uint64_t reserved_8_16                : 9;
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration. */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM. */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t nt_sram                      : 1;  /**< Next pointer table. */
+	uint64_t pt_sram                      : 1;  /**< Previous pointer table. */
+	uint64_t wt_sram                      : 1;  /**< Work table. */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t reserved_8_16                : 9;
+	uint64_t rt_sram                      : 1;
+	uint64_t reserved_18_18               : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t reserved_20_27               : 8;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq2_bist_status_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_bist_status cvmx_pko_pse_sq2_bist_status_t;
@@ -12242,6 +14061,57 @@ union cvmx_pko_pse_sq2_ecc_ctl0 {
 	uint64_t sq_pt_ram_flip               : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_flip               : 2;  /**< SQ_PT_RAM flip syndrome bits on write. */
+	uint64_t sq_pt_ram_cdis               : 1;  /**< SQ_PT_RAM ECC correction disable. */
+	uint64_t sq_nt_ram_flip               : 2;  /**< SQ_NT_RAM flip syndrome bits on write. */
+	uint64_t sq_nt_ram_cdis               : 1;  /**< SQ_NT_RAM ECC correction disable. */
+	uint64_t rt_ram_flip                  : 2;  /**< RT_RAM flip syndrome bits on write. */
+	uint64_t rt_ram_cdis                  : 1;  /**< RT_RAM ECC correction disable. */
+	uint64_t reserved_52_54               : 3;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;  /**< TW0_CMD_FIFO_RAM flip syndrome bits on write. */
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;  /**< TW0_CMD_FIFO_RAM ECC correction disable. */
+	uint64_t reserved_46_48               : 3;
+	uint64_t tp0_sram_flip                : 2;  /**< TP0_SRAM flip syndrome bits on write. */
+	uint64_t tp0_sram_cdis                : 1;  /**< TP0_SRAM ECC correction disable. */
+	uint64_t reserved_40_42               : 3;
+	uint64_t sts0_ram_flip                : 2;  /**< STS0_RAM flip syndrome bits on write. */
+	uint64_t sts0_ram_cdis                : 1;  /**< STS0_RAM ECC correction disable. */
+	uint64_t reserved_34_36               : 3;
+	uint64_t std0_ram_flip                : 2;  /**< STD0_RAM flip syndrome bits on write. */
+	uint64_t std0_ram_cdis                : 1;  /**< STD0_RAM ECC correction disable. */
+	uint64_t wt_ram_flip                  : 2;  /**< WT_RAM flip syndrome bits on write. */
+	uint64_t wt_ram_cdis                  : 1;  /**< WT_RAM ECC correction disable. */
+	uint64_t sc_ram_flip                  : 2;  /**< SC_RAM flip syndrome bits on write. */
+	uint64_t sc_ram_cdis                  : 1;  /**< SC_RAM ECC correction disable. */
+	uint64_t reserved_0_24                : 25;
+#else
+	uint64_t reserved_0_24                : 25;
+	uint64_t sc_ram_cdis                  : 1;
+	uint64_t sc_ram_flip                  : 2;
+	uint64_t wt_ram_cdis                  : 1;
+	uint64_t wt_ram_flip                  : 2;
+	uint64_t std0_ram_cdis                : 1;
+	uint64_t std0_ram_flip                : 2;
+	uint64_t reserved_34_36               : 3;
+	uint64_t sts0_ram_cdis                : 1;
+	uint64_t sts0_ram_flip                : 2;
+	uint64_t reserved_40_42               : 3;
+	uint64_t tp0_sram_cdis                : 1;
+	uint64_t tp0_sram_flip                : 2;
+	uint64_t reserved_46_48               : 3;
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;
+	uint64_t reserved_52_54               : 3;
+	uint64_t rt_ram_cdis                  : 1;
+	uint64_t rt_ram_flip                  : 2;
+	uint64_t sq_nt_ram_cdis               : 1;
+	uint64_t sq_nt_ram_flip               : 2;
+	uint64_t sq_pt_ram_cdis               : 1;
+	uint64_t sq_pt_ram_flip               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_ctl0_s    cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_ctl0 cvmx_pko_pse_sq2_ecc_ctl0_t;
@@ -12288,12 +14158,51 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts0 {
 	uint64_t tp0_sram_dbe                 : 1;
 	uint64_t tp1_sram_dbe                 : 1;
 	uint64_t tw0_cmd_fifo_ram_dbe         : 1;
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;
+	uint64_t rt_ram_dbe                   : 1;
+	uint64_t sq_nt_ram_dbe                : 1;
+	uint64_t sq_pt_ram_dbe                : 1;
+#endif
+	} s;
+	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram */
+	uint64_t reserved_60_60               : 1;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram */
+	uint64_t reserved_58_58               : 1;
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram */
+	uint64_t reserved_56_56               : 1;
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram */
+	uint64_t reserved_54_54               : 1;
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+	uint64_t reserved_0_50                : 51;
+#else
+	uint64_t reserved_0_50                : 51;
+	uint64_t sc_ram_dbe                   : 1;
+	uint64_t wt_ram_dbe                   : 1;
+	uint64_t std0_ram_dbe                 : 1;
+	uint64_t reserved_54_54               : 1;
+	uint64_t sts0_ram_dbe                 : 1;
+	uint64_t reserved_56_56               : 1;
+	uint64_t tp0_sram_dbe                 : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;
+	uint64_t reserved_60_60               : 1;
 	uint64_t rt_ram_dbe                   : 1;
 	uint64_t sq_nt_ram_dbe                : 1;
 	uint64_t sq_pt_ram_dbe                : 1;
 #endif
-	} s;
+	} cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_dbe_sts0 cvmx_pko_pse_sq2_ecc_dbe_sts0_t;
@@ -12329,6 +14238,7 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq2_dbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_t;
@@ -12381,6 +14291,45 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts0 {
 	uint64_t sq_pt_ram_sbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram */
+	uint64_t reserved_60_60               : 1;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram */
+	uint64_t reserved_58_58               : 1;
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram */
+	uint64_t reserved_56_56               : 1;
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram */
+	uint64_t reserved_54_54               : 1;
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+	uint64_t reserved_0_50                : 51;
+#else
+	uint64_t reserved_0_50                : 51;
+	uint64_t sc_ram_sbe                   : 1;
+	uint64_t wt_ram_sbe                   : 1;
+	uint64_t std0_ram_sbe                 : 1;
+	uint64_t reserved_54_54               : 1;
+	uint64_t sts0_ram_sbe                 : 1;
+	uint64_t reserved_56_56               : 1;
+	uint64_t tp0_sram_sbe                 : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;
+	uint64_t reserved_60_60               : 1;
+	uint64_t rt_ram_sbe                   : 1;
+	uint64_t sq_nt_ram_sbe                : 1;
+	uint64_t sq_pt_ram_sbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_sbe_sts0 cvmx_pko_pse_sq2_ecc_sbe_sts0_t;
@@ -12416,6 +14365,7 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq2_sbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_t;
@@ -12477,6 +14427,39 @@ union cvmx_pko_pse_sq3_bist_status {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< Scheduling configuration */
+	uint64_t reserved_20_27               : 8;
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t reserved_18_18               : 1;
+	uint64_t rt_sram                      : 1;  /**< Result table */
+	uint64_t reserved_8_16                : 9;
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t nt_sram                      : 1;  /**< Next pointer table */
+	uint64_t pt_sram                      : 1;  /**< Previous pointer table */
+	uint64_t wt_sram                      : 1;  /**< Work table */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t reserved_8_16                : 9;
+	uint64_t rt_sram                      : 1;
+	uint64_t reserved_18_18               : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t reserved_20_27               : 8;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq3_bist_status_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_bist_status cvmx_pko_pse_sq3_bist_status_t;
@@ -12577,6 +14560,57 @@ union cvmx_pko_pse_sq3_ecc_ctl0 {
 	uint64_t sq_pt_ram_flip               : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_flip               : 2;  /**< SQ_PT_RAM flip syndrome bits on write. */
+	uint64_t sq_pt_ram_cdis               : 1;  /**< SQ_PT_RAM ECC correction disable. */
+	uint64_t sq_nt_ram_flip               : 2;  /**< SQ_NT_RAM flip syndrome bits on write. */
+	uint64_t sq_nt_ram_cdis               : 1;  /**< SQ_NT_RAM ECC correction disable. */
+	uint64_t rt_ram_flip                  : 2;  /**< RT_RAM flip syndrome bits on write. */
+	uint64_t rt_ram_cdis                  : 1;  /**< RT_RAM ECC correction disable. */
+	uint64_t reserved_46_54               : 9;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;  /**< TW0_CMD_FIFO_RAM flip syndrome bits on write. */
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;  /**< TW0_CMD_FIFO_RAM ECC correction disable. */
+	uint64_t reserved_34_42               : 9;
+	uint64_t tp0_sram_flip                : 2;  /**< TP0_SRAM flip syndrome bits on write. */
+	uint64_t tp0_sram_cdis                : 1;  /**< TP0_SRAM ECC correction disable. */
+	uint64_t reserved_22_30               : 9;
+	uint64_t sts0_ram_flip                : 2;  /**< STS0_RAM flip syndrome bits on write. */
+	uint64_t sts0_ram_cdis                : 1;  /**< STS0_RAM ECC correction disable. */
+	uint64_t reserved_10_18               : 9;
+	uint64_t std0_ram_flip                : 2;  /**< STD0_RAM flip syndrome bits on write. */
+	uint64_t std0_ram_cdis                : 1;  /**< STD0_RAM ECC correction disable. */
+	uint64_t wt_ram_flip                  : 2;  /**< WT_RAM flip syndrome bits on write. */
+	uint64_t wt_ram_cdis                  : 1;  /**< WT_RAM ECC correction disable. */
+	uint64_t sc_ram_flip                  : 2;  /**< SC_RAM flip syndrome bits on write. */
+	uint64_t sc_ram_cdis                  : 1;  /**< SC_RAM ECC correction disable. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t sc_ram_cdis                  : 1;
+	uint64_t sc_ram_flip                  : 2;
+	uint64_t wt_ram_cdis                  : 1;
+	uint64_t wt_ram_flip                  : 2;
+	uint64_t std0_ram_cdis                : 1;
+	uint64_t std0_ram_flip                : 2;
+	uint64_t reserved_10_18               : 9;
+	uint64_t sts0_ram_cdis                : 1;
+	uint64_t sts0_ram_flip                : 2;
+	uint64_t reserved_22_30               : 9;
+	uint64_t tp0_sram_cdis                : 1;
+	uint64_t tp0_sram_flip                : 2;
+	uint64_t reserved_34_42               : 9;
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;
+	uint64_t reserved_46_54               : 9;
+	uint64_t rt_ram_cdis                  : 1;
+	uint64_t rt_ram_flip                  : 2;
+	uint64_t sq_nt_ram_cdis               : 1;
+	uint64_t sq_nt_ram_flip               : 2;
+	uint64_t sq_pt_ram_cdis               : 1;
+	uint64_t sq_pt_ram_flip               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_ctl0_s    cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_ctl0 cvmx_pko_pse_sq3_ecc_ctl0_t;
@@ -12653,6 +14687,45 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts0 {
 	uint64_t sq_pt_ram_dbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
+	uint64_t reserved_58_60               : 3;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
+	uint64_t reserved_54_56               : 3;
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
+	uint64_t reserved_50_52               : 3;
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
+	uint64_t reserved_46_48               : 3;
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+	uint64_t reserved_0_42                : 43;
+#else
+	uint64_t reserved_0_42                : 43;
+	uint64_t sc_ram_dbe                   : 1;
+	uint64_t wt_ram_dbe                   : 1;
+	uint64_t std0_ram_dbe                 : 1;
+	uint64_t reserved_46_48               : 3;
+	uint64_t sts0_ram_dbe                 : 1;
+	uint64_t reserved_50_52               : 3;
+	uint64_t tp0_sram_dbe                 : 1;
+	uint64_t reserved_54_56               : 3;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;
+	uint64_t reserved_58_60               : 3;
+	uint64_t rt_ram_dbe                   : 1;
+	uint64_t sq_nt_ram_dbe                : 1;
+	uint64_t sq_pt_ram_dbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_dbe_sts0 cvmx_pko_pse_sq3_ecc_dbe_sts0_t;
@@ -12696,6 +14769,7 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq3_dbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_t;
@@ -12772,6 +14846,45 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts0 {
 	uint64_t sq_pt_ram_sbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
+	uint64_t reserved_58_60               : 3;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
+	uint64_t reserved_54_56               : 3;
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
+	uint64_t reserved_50_52               : 3;
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
+	uint64_t reserved_46_48               : 3;
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+	uint64_t reserved_0_42                : 43;
+#else
+	uint64_t reserved_0_42                : 43;
+	uint64_t sc_ram_sbe                   : 1;
+	uint64_t wt_ram_sbe                   : 1;
+	uint64_t std0_ram_sbe                 : 1;
+	uint64_t reserved_46_48               : 3;
+	uint64_t sts0_ram_sbe                 : 1;
+	uint64_t reserved_50_52               : 3;
+	uint64_t tp0_sram_sbe                 : 1;
+	uint64_t reserved_54_56               : 3;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;
+	uint64_t reserved_58_60               : 3;
+	uint64_t rt_ram_sbe                   : 1;
+	uint64_t sq_nt_ram_sbe                : 1;
+	uint64_t sq_pt_ram_sbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_sbe_sts0 cvmx_pko_pse_sq3_ecc_sbe_sts0_t;
@@ -12815,6 +14928,7 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq3_sbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_t;
@@ -13639,6 +15753,7 @@ union cvmx_pko_ptfx_status {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_ptfx_status_s         cn73xx;
 	struct cvmx_pko_ptfx_status_s         cn78xx;
 };
 typedef union cvmx_pko_ptfx_status cvmx_pko_ptfx_status_t;
@@ -13650,7 +15765,8 @@ union cvmx_pko_ptf_iobp_cfg {
 	uint64_t u64;
 	struct cvmx_pko_ptf_iobp_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_43_63               : 21;
+	uint64_t reserved_44_63               : 20;
+	uint64_t iobp1_ds_opt                 : 1;  /**< Reserved. */
 	uint64_t iobp0_l2_allocate            : 1;  /**< Determine L2 allocation (1 = no allocation) when performing IOBP0 requests. */
 	uint64_t iobp1_magic_addr             : 35; /**< IOBP1 read address to be used for any dummy reads */
 	uint64_t max_read_size                : 7;  /**< Maximum number of IOBP1 read requests outstanding to be allowed by any given PEB TX FIFO. */
@@ -13658,9 +15774,11 @@ union cvmx_pko_ptf_iobp_cfg {
 	uint64_t max_read_size                : 7;
 	uint64_t iobp1_magic_addr             : 35;
 	uint64_t iobp0_l2_allocate            : 1;
-	uint64_t reserved_43_63               : 21;
+	uint64_t iobp1_ds_opt                 : 1;
+	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_ptf_iobp_cfg_s        cn73xx;
 	struct cvmx_pko_ptf_iobp_cfg_s        cn78xx;
 };
 typedef union cvmx_pko_ptf_iobp_cfg cvmx_pko_ptf_iobp_cfg_t;
@@ -13668,20 +15786,19 @@ typedef union cvmx_pko_ptf_iobp_cfg cvmx_pko_ptf_iobp_cfg_t;
 /**
  * cvmx_pko_ptgf#_cfg
  *
- * This register configures a PKO TX FIFO group. PKO supports up to 29 independent
- * TX FIFOs, where 0-27 are physical and 28 is Virtual/NULL. (PKO drops packets
+ * This register configures a PKO TX FIFO group. PKO supports up to 17 independent
+ * TX FIFOs, where 0-15 are physical and 16 is Virtual/NULL. (PKO drops packets
  * targeting the NULL FIFO, returning their buffers to the FPA.) PKO puts each
- * FIFO into one of eight groups:
+ * FIFO into one of five groups:
  *
  * <pre>
- *   CSR Name       FIFO's in FIFO Group
- *   -----------------------------------
+ *    CSR Name       FIFO's in FIFO Group
+ *   ------------------------------------
  *   PKO_PTGF0_CFG      0,  1,  2,  3
  *   PKO_PTGF1_CFG      4,  5,  6,  7
  *   PKO_PTGF2_CFG      8,  9, 10, 11
- *   - ...
- *   PKO_PTGF6_CFG     24, 25, 26, 27
- *   PKO_PTGF7_CFG      Virtual/NULL
+ *   PKO_PTGF3_CFG     12, 13, 14, 15
+ *   PKO_PTGF4_CFG      Virtual/NULL
  * </pre>
  */
 union cvmx_pko_ptgfx_cfg {
@@ -13742,6 +15859,61 @@ union cvmx_pko_ptgfx_cfg {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_pko_ptgfx_cfg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t reset                        : 1;  /**< This bit resets the address pointers for the FIFOs in this group. This should only be
+                                                         performed when a PTGF is empty and the SIZE field is to be changed. */
+	uint64_t reserved_5_5                 : 1;
+	uint64_t rate                         : 2;  /**< The rate / number of inflight packets allowed for the FIFO's in this group.
+                                                         An individual FIFO can support up to 50 Gbit/sec (i.e. up to 32 inflight packets).
+                                                         The total aggregate rate across all FIFOs (including the NULL) should never exceed
+                                                         125 Gbit/sec (i.e. up to 80 inflight packets). This field represents the rate for
+                                                         each active FIFO in in the group; thus the calculation for throughput is a function
+                                                         of the SIZE field and whether or not the FIFO's in the group are assigned to a MAC
+                                                         in PKO_MAC()_CFG.
+                                                         Encoding:
+                                                         0x0 = up to   6.25 Gbit/sec (i.e. up to  4 inflight packets)
+                                                         0x1 = up to  12.5  Gbit/sec (i.e. up to  8 inflight packets)
+                                                         0x2 = up to  25    Gbit/sec (i.e. up to 16 inflight packets)
+                                                         0x3 = up to  50    Gbit/sec (i.e. up to 32 inflight packets)
+                                                         [RATE] applies to all FIFO groups including the NULL. */
+	uint64_t size                         : 3;  /**< Determines the size and availability of the FIFO's in the FIFO group.
+                                                         10KB total storage is available to the FIFO group. Two or
+                                                         four FIFOs can be combined to produce a larger FIFO if desired.
+                                                         The supported SIZE values:
+                                                         <pre>
+                                                                   FIFO0   FIFO1   FIFO2   FIFO3
+                                                            SIZE   Size    Size    Size    Size
+                                                           --------------------------------------
+                                                             0     2.5KB   2.5KB   2.5KB   2.5KB
+                                                             1     5.0KB    N/A    2.5KB   2.5KB
+                                                             2     2.5KB   2.5KB   5.0KB    N/A
+                                                             3     5.0KB    N/A    5.0KB    N/A
+                                                             4    10.0KB    N/A     N/A     N/A
+                                                         </pre>
+                                                         Note: 5-7 are illegal SIZE values and should not be used.
+                                                         A FIFO labelled N/A in the above table must not be used, and no
+                                                         PKO_MAC()_CFG[FIFO_NUM] should select it. For example,
+                                                         if PKO_PTGF(2)_CFG[SIZE]=4, FIFO_NUM 8 is available (with
+                                                         10KB), but FIFO_NUMs 9, 10, and 11 are not valid and should
+                                                         not be used.
+                                                         Modifications to this field require two writes. The first
+                                                         write must not modify [SIZE], and must assert [RESET] to
+                                                         reset the address pointers for the FIFOs in this group.
+                                                         The second write has the new [SIZE] value, and should clear
+                                                         [RESET].
+                                                         PKO_PTGF(4)_CFG[SIZE] should not change from its reset value
+                                                         of zero. (The NULL FIFO has no real storage, and the SIZE table
+                                                         above does not apply to the NULL FIFO.) */
+#else
+	uint64_t size                         : 3;
+	uint64_t rate                         : 2;
+	uint64_t reserved_5_5                 : 1;
+	uint64_t reset                        : 1;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} cn73xx;
 	struct cvmx_pko_ptgfx_cfg_s           cn78xx;
 };
 typedef union cvmx_pko_ptgfx_cfg cvmx_pko_ptgfx_cfg_t;
@@ -14047,8 +16219,20 @@ union cvmx_pko_reg_cmd_buf {
 	struct cvmx_pko_reg_cmd_buf_s         cn66xx;
 	struct cvmx_pko_reg_cmd_buf_s         cn68xx;
 	struct cvmx_pko_reg_cmd_buf_s         cn68xxp1;
-	struct cvmx_pko_reg_cmd_buf_s         cn70xx;
-	struct cvmx_pko_reg_cmd_buf_s         cn70xxp1;
+	struct cvmx_pko_reg_cmd_buf_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_23_63               : 41;
+	uint64_t pool                         : 3;  /**< Free list used to free command buffer segments */
+	uint64_t reserved_19_13               : 7;
+	uint64_t size                         : 13; /**< Number of uint64s per command buffer segment */
+#else
+	uint64_t size                         : 13;
+	uint64_t reserved_19_13               : 7;
+	uint64_t pool                         : 3;
+	uint64_t reserved_23_63               : 41;
+#endif
+	} cn70xx;
+	struct cvmx_pko_reg_cmd_buf_cn70xx    cn70xxp1;
 	struct cvmx_pko_reg_cmd_buf_s         cnf71xx;
 };
 typedef union cvmx_pko_reg_cmd_buf cvmx_pko_reg_cmd_buf_t;
@@ -15419,11 +17603,31 @@ union cvmx_pko_shaper_cfg {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pko_shaper_cfg_s          cn73xx;
 	struct cvmx_pko_shaper_cfg_s          cn78xx;
 };
 typedef union cvmx_pko_shaper_cfg cvmx_pko_shaper_cfg_t;
 
 /**
+ * cvmx_pko_state_uid_in_use#_rd
+ *
+ * For diagnostic use only.
+ *
+ */
+union cvmx_pko_state_uid_in_usex_rd {
+	uint64_t u64;
+	struct cvmx_pko_state_uid_in_usex_rd_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t in_use                       : 64; /**< When set, a state memory bucket (aka UID) is assigned. */
+#else
+	uint64_t in_use                       : 64;
+#endif
+	} s;
+	struct cvmx_pko_state_uid_in_usex_rd_s cn73xx;
+};
+typedef union cvmx_pko_state_uid_in_usex_rd cvmx_pko_state_uid_in_usex_rd_t;
+
+/**
  * cvmx_pko_status
  */
 union cvmx_pko_status {
@@ -15465,8 +17669,63 @@ union cvmx_pko_status {
 	uint64_t pko_rdy                      : 1;
 #endif
 	} s;
-	struct cvmx_pko_status_s              cn78xx;
+	struct cvmx_pko_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pko_rdy                      : 1;  /**< PKO ready for configuration. */
+	uint64_t reserved_62_24               : 39;
+	uint64_t c2qlut_rdy                   : 1;  /**< PKO C2Q LUT block ready for configuration. */
+	uint64_t ppfi_rdy                     : 1;  /**< PKO PPFI block ready for configuration. */
+	uint64_t iobp1_rdy                    : 1;  /**< PKO IOBP1 block ready for configuration. */
+	uint64_t ncb_rdy                      : 1;  /**< PKO NCB block ready for configuration. */
+	uint64_t pse_rdy                      : 1;  /**< PKO PSE block ready for configuration. */
+	uint64_t pdm_rdy                      : 1;  /**< PKO PDM block ready for configuration. */
+	uint64_t peb_rdy                      : 1;  /**< PKO PEB block ready for configuration. */
+	uint64_t csi_rdy                      : 1;  /**< PKO CSI block ready for configuration. */
+	uint64_t reserved_15_5                : 11;
+	uint64_t ncb_bist_status              : 1;  /**< PKO NCB block BIST status. 0 = BIST passed; 1 = BIST failed. */
+	uint64_t c2qlut_bist_status           : 1;  /**< PKO C2QLUT block BIST status. 0 = BIST passed; 1 = BIST failed. */
+	uint64_t pdm_bist_status              : 1;  /**< PKO PDM block BIST status. 0 = BIST passed; 1 = BIST failed. */
+	uint64_t peb_bist_status              : 1;  /**< PKO PEB block BIST status. 0 = BIST passed; 1 = BIST failed. */
+	uint64_t pse_bist_status              : 1;  /**< PKO PSE block BIST status. 0 = BIST passed; 1 = BIST failed. */
+#else
+	uint64_t pse_bist_status              : 1;
+	uint64_t peb_bist_status              : 1;
+	uint64_t pdm_bist_status              : 1;
+	uint64_t c2qlut_bist_status           : 1;
+	uint64_t ncb_bist_status              : 1;
+	uint64_t reserved_15_5                : 11;
+	uint64_t csi_rdy                      : 1;
+	uint64_t peb_rdy                      : 1;
+	uint64_t pdm_rdy                      : 1;
+	uint64_t pse_rdy                      : 1;
+	uint64_t ncb_rdy                      : 1;
+	uint64_t iobp1_rdy                    : 1;
+	uint64_t ppfi_rdy                     : 1;
+	uint64_t c2qlut_rdy                   : 1;
+	uint64_t reserved_62_24               : 39;
+	uint64_t pko_rdy                      : 1;
+#endif
+	} cn73xx;
+	struct cvmx_pko_status_cn73xx         cn78xx;
 };
 typedef union cvmx_pko_status cvmx_pko_status_t;
 
+/**
+ * cvmx_pko_txf#_pkt_cnt_rd
+ */
+union cvmx_pko_txfx_pkt_cnt_rd {
+	uint64_t u64;
+	struct cvmx_pko_txfx_pkt_cnt_rd_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t cnt                          : 8;  /**< Number of packets currently sitting in the given TX FIFO. */
+#else
+	uint64_t cnt                          : 8;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_pko_txfx_pkt_cnt_rd_s     cn73xx;
+};
+typedef union cvmx_pko_txfx_pkt_cnt_rd cvmx_pko_txfx_pkt_cnt_rd_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3-queue.h b/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
index 60c5f10..503e432 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
@@ -75,36 +75,6 @@ int cvmx_pko3_get_queue_base(int ipd_port);
 int cvmx_pko3_get_queue_num(int ipd_port);
 
 /*
- * Configure Port Queue and its children Scheduler Queue
- *
- * Port Queues (a.k.a L1) are assigned 1-to-1 to MACs.
- * L2 Scheduler Queues are used for specifying channels, and thus there
- * could be multiple L2 SQs attached to a single L1 PQ, either in a
- * fair round-robin scheduling, or with static and/or round-robin priorities.
- *
- * @param node is the OCI node location for the queues to be configured
- * @param mac_num is the LMAC number to that is associated with the Port Queue,
- * @param which is identical to the Port Queue number that is configured
- * @param child_base is the number of the first L2 SQ attached to the PQ
- * @param child_count is the number of L2 SQ children to attach to PQ
- * @param stat_prio_count is the priority setting for the children L2 SQs
- *
- * If <stat_prio_count> is -1, the L2 children will have equal Round-Robin
- * relationship with eachother. If <stat_prio_count> is 0, all L2 children
- * will be arranged in Weighted-Round-Robin, with the first having the most
- * precedence. If <stat_prio_count> is between 1 and 8, it indicates how
- * many children will have static priority settings (with the first having
- * the most precedence), with the remaining L2 children having WRR scheduling.
- *
- * @returns 0 on success, -1 on failure.
- *
- * Note: this function supports the configuration of node-local unit.
- */
-int cvmx_pko3_pq_config_children(unsigned node, unsigned mac_num,
-			unsigned child_base,
-			unsigned child_count, int stat_prio_count);
-
-/*
  * Configure L3 through L5 Scheduler Queues and Descriptor Queues
  *
  * The Scheduler Queues in Levels 3 to 5 and Descriptor Queues are
@@ -188,6 +158,9 @@ int __cvmx_pko3_ipd_dq_unregister(int xiface, int index);
 void cvmx_pko3_map_channel(unsigned node,
 	unsigned pq_num, unsigned l2_l3_q_num, uint16_t channel);
 
+extern int cvmx_pko3_pq_config(unsigned node, unsigned mac_num,
+			 unsigned pq_num);
+
 extern int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
 		unsigned long rate_kbips, unsigned burst_bytes);
 extern int cvmx_pko3_dq_cir_set(unsigned node, unsigned pq_num,
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index fdd7427..33b409d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -59,6 +59,7 @@ extern "C" {
 #include <asm/octeon/cvmx-ilk.h>
 #include <asm/octeon/cvmx-scratch.h>
 #include <asm/octeon/cvmx-atomic.h>
+#include <asm/octeon/cvmx-pow.h>
 #else
 #include "cvmx-pko-defs.h"
 #include "cvmx-pko3-queue.h"
@@ -66,6 +67,7 @@ extern "C" {
 #include "cvmx-ilk.h"
 #include "cvmx-scratch.h"
 #include "cvmx-atomic.h"
+#include "cvmx-pow.h"
 #endif
 
 /* Use full LMTDMA when PARAMETER_CHECKINS is enabled */
@@ -79,17 +81,17 @@ extern "C" {
 /* Should be unique wrt other uses of CVMSEG, e.g. IOBDMA */
 #define CVMX_PKO_LMTLINE 2ull
 
-enum {
-	CVMX_PKO_PORT_QUEUES = 0,
-	CVMX_PKO_L2_QUEUES,
-	CVMX_PKO_L3_QUEUES,
-	CVMX_PKO_L4_QUEUES,
-	CVMX_PKO_L5_QUEUES,
-	CVMX_PKO_DESCR_QUEUES,
-	CVMX_PKO_NUM_QUEUE_LEVELS
+/* PKO3 queue level identifier */
+enum cvmx_pko3_level_e {
+	CVMX_PKO_LEVEL_INVAL = 0,
+	CVMX_PKO_PORT_QUEUES = 0xd1,
+	CVMX_PKO_L2_QUEUES = 0xc2,
+	CVMX_PKO_L3_QUEUES = 0xb3,
+	CVMX_PKO_L4_QUEUES = 0xa4,
+	CVMX_PKO_L5_QUEUES = 0x95,
+	CVMX_PKO_DESCR_QUEUES = 0x86,
 };
 
-#define CVMX_PKO_MAX_MACS 28
 
 enum cvmx_pko_dqop {
 	CVMX_PKO_DQ_SEND = 0ULL,
@@ -98,6 +100,110 @@ enum cvmx_pko_dqop {
 	CVMX_PKO_DQ_QUERY = 3ULL
 };
 
+/**
+ * @INTERNAL
+ * Return the number of MACs in the PKO (exclusing the NULL MAC)
+ * in a model-dependent manner.
+ */
+static inline unsigned __cvmx_pko3_num_macs(void)
+{
+        if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return 14;
+        if(OCTEON_IS_MODEL(OCTEON_CN78XX))
+		return 28;
+	return 0;
+}
+
+/**
+ * @INTERNAL
+ * Return the number of queue levels, depending on SoC model
+ */
+static inline int __cvmx_pko3_sq_lvl_max(void)
+{
+        if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return CVMX_PKO_L3_QUEUES;
+        if(OCTEON_IS_MODEL(OCTEON_CN78XX))
+		return CVMX_PKO_L5_QUEUES;
+	return -1;
+}
+
+/**
+ * @INTERNAL
+ * Return the next (lower) queue level for a given level
+ */
+static inline enum cvmx_pko3_level_e
+__cvmx_pko3_sq_lvl_next(enum cvmx_pko3_level_e level)
+{
+	switch(level) {
+		default:
+			return CVMX_PKO_LEVEL_INVAL;
+		case CVMX_PKO_PORT_QUEUES:
+			return CVMX_PKO_L2_QUEUES;
+		case CVMX_PKO_L2_QUEUES:
+			return CVMX_PKO_L3_QUEUES;
+		case CVMX_PKO_L3_QUEUES:
+			if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+				return CVMX_PKO_DESCR_QUEUES;
+			return CVMX_PKO_L4_QUEUES;
+		case CVMX_PKO_L4_QUEUES:
+			if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+				return CVMX_PKO_LEVEL_INVAL;
+			return CVMX_PKO_L5_QUEUES;
+		case CVMX_PKO_L5_QUEUES:
+			if(OCTEON_IS_MODEL(OCTEON_CN73XX))
+				return CVMX_PKO_LEVEL_INVAL;
+			return CVMX_PKO_DESCR_QUEUES;
+	}
+}
+
+/**
+ * @INTERNAL
+ * Return an SQ identifier string, for debug messages.
+ */
+static inline char *
+__cvmx_pko3_sq_str(char * buf, enum cvmx_pko3_level_e level, unsigned q)
+{
+	char *p;
+
+	switch(level) {
+		default:
+			strcpy(buf, "ERR-SQ/");
+			break;
+		case CVMX_PKO_PORT_QUEUES:
+			strcpy(buf, "PQ_L1/");
+			break;
+		case CVMX_PKO_L2_QUEUES:
+			strcpy(buf, "SQ_L2/");
+			break;
+		case CVMX_PKO_L3_QUEUES:
+			strcpy(buf, "SQ_L3/");
+			break;
+		case CVMX_PKO_L4_QUEUES:
+			strcpy(buf, "SQ_L4/");
+			break;
+		case CVMX_PKO_L5_QUEUES:
+			strcpy(buf, "SQ_L5/");
+			break;
+		case CVMX_PKO_DESCR_QUEUES:
+			strcpy(buf, "DQ/");
+			break;
+	}
+
+	for(p=buf; *p; p++)
+		;
+	*p++ = '0' + q / 1000;
+	q -= (q / 1000) * 1000;
+	*p++ = '0' + q / 100;
+	q -= (q / 100) * 100;
+	*p++ = '0' + q / 10;
+	q -= (q / 10) * 10;
+	*p++ = '0' + q;
+	*p++ = ':';
+	*p++ = '\0';
+	return buf;
+}
+
+
 union cvmx_pko_query_rtn {
 	uint64_t u64;
 	struct {
@@ -356,6 +462,16 @@ static inline int __cvmx_pko3_get_mac_num(int xiface, int index)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	cvmx_helper_interface_mode_t mode;
 	int interface_index;
+	int ilk_mac_base = -1, bgx_mac_base = -1;
+
+        if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		bgx_mac_base = 2;
+	}
+
+        if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		ilk_mac_base = 2;
+		bgx_mac_base = 4;
+	}
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 	switch (mode) {
@@ -364,41 +480,21 @@ static inline int __cvmx_pko3_get_mac_num(int xiface, int index)
 		case CVMX_HELPER_INTERFACE_MODE_NPI:
 			return 1;
 		case CVMX_HELPER_INTERFACE_MODE_ILK:
+			if (ilk_mac_base < 0)
+				return -1;
 			interface_index = (xi.interface - CVMX_ILK_GBL_BASE());
 			if (interface_index < 0)
 				return -1;
-			return (2 + interface_index);
+			return (ilk_mac_base + interface_index);
 		default:
-			if (xi.interface >= CVMX_ILK_GBL_BASE())
+			if (xi.interface >= CVMX_ILK_GBL_BASE() &&
+			    ilk_mac_base >= 0)
 				return -1;
 			/* All other modes belong to BGX */
-			return (4 + 4 * xi.interface + index);
+			return (bgx_mac_base + 4 * xi.interface + index);
 	}
 }
 
-/*
- * Configure Channel credit level in PKO.
- *
- * @param node is to specify the node to which this configuration is applied.
- * @param level specifies the level at which pko channel queues will be configured,
- *              level : 0 -> L2, level : 1 -> L3 queues.
- * @return returns 0 if successful and -1 on failure.
- */
-static inline int cvmx_pko_setup_channel_credit_level(int node, int level)
-{
-	union cvmx_pko_channel_level channel_level;
-
-	if (level != 0 || level != 1)
-		return -1;
-
-	channel_level.u64 = 0;
-	channel_level.s.cc_level = level;
-	cvmx_write_csr_node(node, CVMX_PKO_CHANNEL_LEVEL, channel_level.u64);
-
-	return 0;
-
-}
-
 /**
  * @INTERNAL
  *
@@ -500,6 +596,9 @@ __cvmx_pko3_lmtdma(uint8_t node, uint16_t dq, unsigned numwords)
 	/* Barrier: make sure all prior writes complete before the following */
 	CVMX_SYNCWS;
 
+	/* Wait to finish tag switch just before issueing LMTDMA */
+	cvmx_pow_tag_sw_wait();
+
 	/* issue PKO DMA */
 	cvmx_write64_uint64(dma_addr, pko_send_dma_data.u64);
 
@@ -611,6 +710,9 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 	/* Barrier: make sure all prior writes complete before the following */
 	CVMX_SYNCWS;
 
+	/* Wait to finish tag switch just before issueing LMTDMA */
+	cvmx_pow_tag_sw_wait();
+
 	/* issue PKO DMA */
 	cvmx_write64_uint64(dma_addr, pko_send_dma_data.u64);
 
@@ -647,6 +749,7 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
  * @param len is the total number of bytes in the packet.
  * @param gaura is the aura to free packet buffers after trasnmit.
  * @param pCounter is an address of a 64-bit counter to atomically
+ * @param ptag is a Flow Tag pointer for packet odering or NULL
  * decrement when packet transmission is complete.
  *
  * @return returns 0 if successful and -1 on failure.
@@ -656,7 +759,7 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
  */
 static inline int
 cvmx_pko3_xmit_link_buf(int dq,cvmx_buf_ptr_pki_t pki_ptr,
-	unsigned len, int gaura, uint64_t *pCounter)
+	unsigned len, int gaura, uint64_t *pCounter, uint32_t *ptag)
 {
 	cvmx_pko_query_rtn_t pko_status;
 	cvmx_pko_send_hdr_t hdr_s;
@@ -703,6 +806,10 @@ cvmx_pko3_xmit_link_buf(int dq,cvmx_buf_ptr_pki_t pki_ptr,
 			mem_s.u64);
 	}
 
+	/* To preserve packet order, go atomic with DQ-specific tag */
+	if (ptag != NULL)
+		cvmx_pow_tag_sw_nocheck(*ptag ^ dq, CVMX_POW_TAG_TYPE_ATOMIC);
+ 
 	/* Do LMTDMA */
 	pko_status = __cvmx_pko3_lmtdma(node, dq, nwords);
 
@@ -825,6 +932,8 @@ extern int cvmx_pko3_interface_options(int xiface, int index,
 extern void cvmx_pko3_dq_options(unsigned node, unsigned dq, bool min_pad);
 
 extern int cvmx_pko3_port_fifo_size(unsigned int xiface, unsigned index);
+extern int cvmx_pko3_channel_credit_level(int node,
+	enum cvmx_pko3_level_e level);
 
 /* Packet descriptor - PKO3 command buffer + internal state */
 typedef struct cvmx_pko3_pdesc_s {
@@ -851,7 +960,8 @@ typedef struct cvmx_pko3_pdesc_s {
 void cvmx_pko3_pdesc_init(cvmx_pko3_pdesc_t *pdesc);
 int cvmx_pko3_pdesc_from_wqe(cvmx_pko3_pdesc_t *pdesc, cvmx_wqe_78xx_t *wqe,
 	bool free_bufs);
-int cvmx_pko3_pdesc_transmit(cvmx_pko3_pdesc_t *pdesc, uint16_t dq);
+int cvmx_pko3_pdesc_transmit(cvmx_pko3_pdesc_t *pdesc, uint16_t dq,
+	uint32_t *flow_tag);
 int cvmx_pko3_pdesc_notify_decrement(cvmx_pko3_pdesc_t *pdesc,
         volatile uint64_t *p_counter);
 int cvmx_pko3_pdesc_notify_wqe(cvmx_pko3_pdesc_t *pdesc, cvmx_wqe_78xx_t *wqe,
diff --git a/arch/mips/include/asm/octeon/cvmx-pow.h b/arch/mips/include/asm/octeon/cvmx-pow.h
index ab6420d..79e7cce 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow.h
@@ -105,7 +105,9 @@ typedef union {
 	};
 } cvmx_xgrp_t;
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL	//XXX- Temporary
 #define CVMX_SSO_NUM_XGRP		(256)
+#endif
 
 /*
  * Softwsare-only structure to convey a return value
@@ -1637,6 +1639,21 @@ enum cvmx_sso_group_modify_mask{
 };
 
 /**
+ * @INTERNAL
+ * Return the number of SSO groups for a given SoC model
+ */
+static inline unsigned cvmx_sso_num_xgrp(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+		return 256;
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return 64;
+	cvmx_printf("ERROR: %s: Unknown model\n", __func__);
+	return 0;
+}
+
+
+/**
  * Get the POW tag for this core. This returns the current
  * tag type, tag, group, and POW entry index associated with
  * this core. Index is only valid if the tag type isn't NULL_NULL.
@@ -2594,8 +2611,9 @@ static inline void cvmx_pow_set_group_mask(uint64_t core_num, uint64_t mask)
 		node = cvmx_coremask_core_to_node(core_num);
 		core = cvmx_coremask_core_on_node(core_num);
 
-		/* 256 groups divided into 4 X 64 bit registers */
-		for (rix = 0; rix < (CVMX_SSO_NUM_XGRP >> 6); rix ++ ) {
+		/* 78xx: 256 groups divided into 4 X 64 bit registers */
+		/* 73xx: 64 groups are in one register */
+		for (rix = 0; rix < (cvmx_sso_num_xgrp() >> 6); rix ++ ) {
 			grp_msk.u64 = 0;
 			for(bit = 0; bit < 64; bit++) {
 				/* 8-bit native XGRP number */
@@ -2668,7 +2686,7 @@ static inline void cvmx_pow_set_xgrp_mask( uint64_t core_num,
 	node = cvmx_coremask_core_to_node(core_num);
 	core = cvmx_coremask_core_on_node(core_num);
 
-	for (grp = 0; grp < (CVMX_SSO_NUM_XGRP >> 6); grp++) {
+	for (grp = 0; grp < (cvmx_sso_num_xgrp() >> 6); grp++) {
 		uint64_t reg_addr;
 
 		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(core, 0, grp),
@@ -2846,7 +2864,7 @@ static inline void cvmx_pow_set_priority(uint64_t core_num, const uint8_t priori
 		grp_pri.s.weight = 0x3f;
 		grp_pri.s.affinity = 0xf;
 
-		for(group = 0; group < CVMX_SSO_NUM_XGRP; group ++ ) {
+		for(group = 0; group < cvmx_sso_num_xgrp(); group ++ ) {
 			grp_pri.u64 = cvmx_read_csr_node(node,
 				CVMX_SSO_GRPX_PRI(group));
 			grp_pri.s.pri = priority[group & 0x7];
@@ -3153,13 +3171,13 @@ static inline uint32_t cvmx_pow_tag_get_hw_bits(uint64_t tag)
 	return (tag & cvmx_build_mask(32 - CVMX_TAG_SW_BITS));
 }
 
-static inline uint64_t cvmx_sso_get_total_wqe_count_78xx(int node)
+static inline uint64_t cvmx_sso3_get_wqe_count(int node)
 {
 	cvmx_sso_grpx_aq_cnt_t aq_cnt;
-	int grp = 0;
+	unsigned grp = 0;
 	uint64_t cnt = 0;
 
-	for( grp = 0; grp < CVMX_SSO_NUM_XGRP; grp++) {
+	for( grp = 0; grp < cvmx_sso_num_xgrp(); grp++) {
 		aq_cnt.u64 = cvmx_read_csr_node(node,
 				CVMX_SSO_GRPX_AQ_CNT(grp));
 		cnt += aq_cnt.s.aq_cnt;
@@ -3172,7 +3190,7 @@ static inline uint64_t cvmx_sso_get_total_wqe_count(void)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
 	{
 		int node = cvmx_get_node_num();
-		return cvmx_sso_get_total_wqe_count_78xx(node);
+		return cvmx_sso3_get_wqe_count(node);
 	}
 	else if (OCTEON_IS_MODEL(OCTEON_CN68XX))
 	{
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index ee98a73..9da28cd 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 107037 $<hr>
+ * <hr>$Revision: 110744 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
@@ -236,7 +236,7 @@ enum cvmx_pemx_cfg_mode {
  * Read QLM and return mode.
  */
 extern enum cvmx_qlm_mode cvmx_qlm_get_mode(int qlm);
-enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm);
+extern enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm);
 extern enum cvmx_qlm_mode cvmx_qlm_get_dlm_mode(int dlm_mode, int interface);
 extern void __cvmx_qlm_set_mult(int qlm, int baud_mhz, int old_multiplier);
 
diff --git a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
index b1bbfb5..f107e20 100644
--- a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
@@ -58,7 +58,7 @@
 #define CVMX_RNM_EER_DBG CVMX_RNM_EER_DBG_FUNC()
 static inline uint64_t CVMX_RNM_EER_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_EER_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000018ull);
 }
@@ -69,7 +69,7 @@ static inline uint64_t CVMX_RNM_EER_DBG_FUNC(void)
 #define CVMX_RNM_EER_KEY CVMX_RNM_EER_KEY_FUNC()
 static inline uint64_t CVMX_RNM_EER_KEY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_EER_KEY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000010ull);
 }
@@ -80,7 +80,7 @@ static inline uint64_t CVMX_RNM_EER_KEY_FUNC(void)
 #define CVMX_RNM_SERIAL_NUM CVMX_RNM_SERIAL_NUM_FUNC()
 static inline uint64_t CVMX_RNM_SERIAL_NUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_SERIAL_NUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000020ull);
 }
@@ -126,6 +126,7 @@ union cvmx_rnm_bist_status {
 	struct cvmx_rnm_bist_status_s         cn68xxp1;
 	struct cvmx_rnm_bist_status_s         cn70xx;
 	struct cvmx_rnm_bist_status_s         cn70xxp1;
+	struct cvmx_rnm_bist_status_s         cn73xx;
 	struct cvmx_rnm_bist_status_s         cn78xx;
 	struct cvmx_rnm_bist_status_s         cnf71xx;
 };
@@ -241,6 +242,7 @@ union cvmx_rnm_ctl_status {
 	struct cvmx_rnm_ctl_status_cn63xx     cn68xxp1;
 	struct cvmx_rnm_ctl_status_s          cn70xx;
 	struct cvmx_rnm_ctl_status_s          cn70xxp1;
+	struct cvmx_rnm_ctl_status_s          cn73xx;
 	struct cvmx_rnm_ctl_status_s          cn78xx;
 	struct cvmx_rnm_ctl_status_s          cnf71xx;
 };
@@ -269,6 +271,7 @@ union cvmx_rnm_eer_dbg {
 	struct cvmx_rnm_eer_dbg_s             cn68xxp1;
 	struct cvmx_rnm_eer_dbg_s             cn70xx;
 	struct cvmx_rnm_eer_dbg_s             cn70xxp1;
+	struct cvmx_rnm_eer_dbg_s             cn73xx;
 	struct cvmx_rnm_eer_dbg_s             cn78xx;
 	struct cvmx_rnm_eer_dbg_s             cnf71xx;
 };
@@ -299,6 +302,7 @@ union cvmx_rnm_eer_key {
 	struct cvmx_rnm_eer_key_s             cn68xxp1;
 	struct cvmx_rnm_eer_key_s             cn70xx;
 	struct cvmx_rnm_eer_key_s             cn70xxp1;
+	struct cvmx_rnm_eer_key_s             cn73xx;
 	struct cvmx_rnm_eer_key_s             cn78xx;
 	struct cvmx_rnm_eer_key_s             cnf71xx;
 };
@@ -331,6 +335,7 @@ union cvmx_rnm_serial_num {
 	struct cvmx_rnm_serial_num_s          cn68xxp1;
 	struct cvmx_rnm_serial_num_s          cn70xx;
 	struct cvmx_rnm_serial_num_s          cn70xxp1;
+	struct cvmx_rnm_serial_num_s          cn73xx;
 	struct cvmx_rnm_serial_num_s          cn78xx;
 	struct cvmx_rnm_serial_num_s          cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 17d74dc..d384a24 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -53,10 +53,21 @@
 #define __CVMX_RST_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_BIST_TIMER CVMX_RST_BIST_TIMER_FUNC()
+static inline uint64_t CVMX_RST_BIST_TIMER_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_BIST_TIMER not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001760ull);
+}
+#else
+#define CVMX_RST_BIST_TIMER (CVMX_ADD_IO_SEG(0x0001180006001760ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_RST_BOOT CVMX_RST_BOOT_FUNC()
 static inline uint64_t CVMX_RST_BOOT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_BOOT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001600ull);
 }
@@ -67,7 +78,7 @@ static inline uint64_t CVMX_RST_BOOT_FUNC(void)
 #define CVMX_RST_CFG CVMX_RST_CFG_FUNC()
 static inline uint64_t CVMX_RST_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001610ull);
 }
@@ -78,7 +89,7 @@ static inline uint64_t CVMX_RST_CFG_FUNC(void)
 #define CVMX_RST_CKILL CVMX_RST_CKILL_FUNC()
 static inline uint64_t CVMX_RST_CKILL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_CKILL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001638ull);
 }
@@ -86,10 +97,22 @@ static inline uint64_t CVMX_RST_CKILL_FUNC(void)
 #define CVMX_RST_CKILL (CVMX_ADD_IO_SEG(0x0001180006001638ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_RST_COLD_DATAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_RST_COLD_DATAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800060017C0ull) + ((offset) & 3) * 8;
+}
+#else
+#define CVMX_RST_COLD_DATAX(offset) (CVMX_ADD_IO_SEG(0x00011800060017C0ull) + ((offset) & 3) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_RST_CTLX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_CTLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180006001640ull) + ((offset) & 3) * 8;
@@ -101,7 +124,7 @@ static inline uint64_t CVMX_RST_CTLX(unsigned long offset)
 #define CVMX_RST_DELAY CVMX_RST_DELAY_FUNC()
 static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_DELAY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001608ull);
 }
@@ -112,7 +135,7 @@ static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 #define CVMX_RST_ECO CVMX_RST_ECO_FUNC()
 static inline uint64_t CVMX_RST_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800060017B8ull);
 }
@@ -123,7 +146,7 @@ static inline uint64_t CVMX_RST_ECO_FUNC(void)
 #define CVMX_RST_INT CVMX_RST_INT_FUNC()
 static inline uint64_t CVMX_RST_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001628ull);
 }
@@ -131,6 +154,17 @@ static inline uint64_t CVMX_RST_INT_FUNC(void)
 #define CVMX_RST_INT (CVMX_ADD_IO_SEG(0x0001180006001628ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_INT_W1S CVMX_RST_INT_W1S_FUNC()
+static inline uint64_t CVMX_RST_INT_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_INT_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001630ull);
+}
+#else
+#define CVMX_RST_INT_W1S (CVMX_ADD_IO_SEG(0x0001180006001630ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_RST_OCX CVMX_RST_OCX_FUNC()
 static inline uint64_t CVMX_RST_OCX_FUNC(void)
 {
@@ -142,10 +176,21 @@ static inline uint64_t CVMX_RST_OCX_FUNC(void)
 #define CVMX_RST_OCX (CVMX_ADD_IO_SEG(0x0001180006001618ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_OUT_CTL CVMX_RST_OUT_CTL_FUNC()
+static inline uint64_t CVMX_RST_OUT_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_OUT_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001688ull);
+}
+#else
+#define CVMX_RST_OUT_CTL (CVMX_ADD_IO_SEG(0x0001180006001688ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_RST_POWER_DBG CVMX_RST_POWER_DBG_FUNC()
 static inline uint64_t CVMX_RST_POWER_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_POWER_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001708ull);
 }
@@ -156,7 +201,7 @@ static inline uint64_t CVMX_RST_POWER_DBG_FUNC(void)
 #define CVMX_RST_PP_POWER CVMX_RST_PP_POWER_FUNC()
 static inline uint64_t CVMX_RST_PP_POWER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_PP_POWER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001700ull);
 }
@@ -164,10 +209,22 @@ static inline uint64_t CVMX_RST_PP_POWER_FUNC(void)
 #define CVMX_RST_PP_POWER (CVMX_ADD_IO_SEG(0x0001180006001700ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_REF_CNTR CVMX_RST_REF_CNTR_FUNC()
+static inline uint64_t CVMX_RST_REF_CNTR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_REF_CNTR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001758ull);
+}
+#else
+#define CVMX_RST_REF_CNTR (CVMX_ADD_IO_SEG(0x0001180006001758ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_RST_SOFT_PRSTX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_SOFT_PRSTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800060016C0ull) + ((offset) & 3) * 8;
@@ -179,13 +236,44 @@ static inline uint64_t CVMX_RST_SOFT_PRSTX(unsigned long offset)
 #define CVMX_RST_SOFT_RST CVMX_RST_SOFT_RST_FUNC()
 static inline uint64_t CVMX_RST_SOFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_SOFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001680ull);
 }
 #else
 #define CVMX_RST_SOFT_RST (CVMX_ADD_IO_SEG(0x0001180006001680ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_THERMAL_ALERT CVMX_RST_THERMAL_ALERT_FUNC()
+static inline uint64_t CVMX_RST_THERMAL_ALERT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_THERMAL_ALERT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001690ull);
+}
+#else
+#define CVMX_RST_THERMAL_ALERT (CVMX_ADD_IO_SEG(0x0001180006001690ull))
+#endif
+
+/**
+ * cvmx_rst_bist_timer
+ */
+union cvmx_rst_bist_timer {
+	uint64_t u64;
+	struct cvmx_rst_bist_timer_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t count                        : 29; /**< Number of 50 Mhz reference clocks that have elapsed during bist and repair during the last
+                                                         reset.
+                                                         If MSB is set the BIST chain did not complete as expected. */
+#else
+	uint64_t count                        : 29;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_rst_bist_timer_s          cn73xx;
+};
+typedef union cvmx_rst_bist_timer cvmx_rst_bist_timer_t;
 
 /**
  * cvmx_rst_boot
@@ -202,7 +290,7 @@ union cvmx_rst_boot {
                                                          in Authentik mode, else 0. */
 	uint64_t ejtagdis                     : 1;  /**< When set, external EJTAG access is disabled. This field resets to 1 in Authentik mode, else 0. */
 	uint64_t romen                        : 1;  /**< When set, Authentik/eMMC boot ROM is visible in the boot bus address space. This field
-                                                         resets to 1 in an Authentik part or when booting from eMMC. Else, resets to 0. */
+                                                         resets to 1 in an Authentik part or when booting from eMMC/SD or SPI. Else, resets to 0. */
 	uint64_t ckill_ppdis                  : 1;  /**< When set, cores other than 0 are disabled during a CHIPKILL.  Writes have no effect when
                                                          RST_BOOT[CHIPKILL]=1. */
 	uint64_t jt_tstmode                   : 1;  /**< JTAG test mode. */
@@ -261,6 +349,7 @@ union cvmx_rst_boot {
 	} s;
 	struct cvmx_rst_boot_s                cn70xx;
 	struct cvmx_rst_boot_s                cn70xxp1;
+	struct cvmx_rst_boot_s                cn73xx;
 	struct cvmx_rst_boot_s                cn78xx;
 };
 typedef union cvmx_rst_boot cvmx_rst_boot_t;
@@ -278,6 +367,23 @@ union cvmx_rst_cfg {
                                                          will not change this field. */
 	uint64_t warm_clr_bist                : 1;  /**< Perform clear BIST during warm reset, instead of a full BIST. A warm/soft reset does not
                                                          change this field. Note that a cold reset always performs a full BIST. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t warm_clr_bist                : 1;
+	uint64_t cntl_clr_bist                : 1;
+	uint64_t reserved_3_5                 : 3;
+	uint64_t bist_delay                   : 58;
+#endif
+	} s;
+	struct cvmx_rst_cfg_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t bist_delay                   : 58; /**< Reserved. */
+	uint64_t reserved_3_5                 : 3;
+	uint64_t cntl_clr_bist                : 1;  /**< Perform clear BIST during control-only reset, instead of a full BIST. A warm/soft reset
+                                                         will not change this field. */
+	uint64_t warm_clr_bist                : 1;  /**< Perform clear BIST during warm reset, instead of a full BIST. A warm/soft reset does not
+                                                         change this field. Note that a cold reset always performs a full BIST. */
 	uint64_t soft_clr_bist                : 1;  /**< Perform clear BIST during soft reset, instead of a full BIST. A warm/soft reset does not
                                                          change this field. Note that a cold reset always performs a full BIST. */
 #else
@@ -287,10 +393,21 @@ union cvmx_rst_cfg {
 	uint64_t reserved_3_5                 : 3;
 	uint64_t bist_delay                   : 58;
 #endif
-	} s;
-	struct cvmx_rst_cfg_s                 cn70xx;
-	struct cvmx_rst_cfg_s                 cn70xxp1;
-	struct cvmx_rst_cfg_s                 cn78xx;
+	} cn70xx;
+	struct cvmx_rst_cfg_cn70xx            cn70xxp1;
+	struct cvmx_rst_cfg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t bist_delay                   : 58; /**< Reserved. */
+	uint64_t reserved_1_5                 : 5;
+	uint64_t clr_bist                     : 1;  /**< Perform clear BIST during a reset, instead of a full BIST. A warm/soft reset does not
+                                                         change this field. Note that a cold reset always performs a full BIST. */
+#else
+	uint64_t clr_bist                     : 1;
+	uint64_t reserved_1_5                 : 5;
+	uint64_t bist_delay                   : 58;
+#endif
+	} cn73xx;
+	struct cvmx_rst_cfg_cn70xx            cn78xx;
 };
 typedef union cvmx_rst_cfg cvmx_rst_cfg_t;
 
@@ -311,11 +428,29 @@ union cvmx_rst_ckill {
 	} s;
 	struct cvmx_rst_ckill_s               cn70xx;
 	struct cvmx_rst_ckill_s               cn70xxp1;
+	struct cvmx_rst_ckill_s               cn73xx;
 	struct cvmx_rst_ckill_s               cn78xx;
 };
 typedef union cvmx_rst_ckill cvmx_rst_ckill_t;
 
 /**
+ * cvmx_rst_cold_data#
+ */
+union cvmx_rst_cold_datax {
+	uint64_t u64;
+	struct cvmx_rst_cold_datax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t data                         : 64; /**< Scratch data registers preserved through warm reset.
+                                                         Reset to 0x0 on cold reset. */
+#else
+	uint64_t data                         : 64;
+#endif
+	} s;
+	struct cvmx_rst_cold_datax_s          cn73xx;
+};
+typedef union cvmx_rst_cold_datax cvmx_rst_cold_datax_t;
+
+/**
  * cvmx_rst_ctl#
  */
 union cvmx_rst_ctlx {
@@ -381,6 +516,7 @@ union cvmx_rst_ctlx {
 	} s;
 	struct cvmx_rst_ctlx_s                cn70xx;
 	struct cvmx_rst_ctlx_s                cn70xxp1;
+	struct cvmx_rst_ctlx_s                cn73xx;
 	struct cvmx_rst_ctlx_s                cn78xx;
 };
 typedef union cvmx_rst_ctlx cvmx_rst_ctlx_t;
@@ -409,6 +545,7 @@ union cvmx_rst_delay {
 	} s;
 	struct cvmx_rst_delay_s               cn70xx;
 	struct cvmx_rst_delay_s               cn70xxp1;
+	struct cvmx_rst_delay_s               cn73xx;
 	struct cvmx_rst_delay_s               cn78xx;
 };
 typedef union cvmx_rst_delay cvmx_rst_delay_t;
@@ -427,6 +564,7 @@ union cvmx_rst_eco {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_rst_eco_s                 cn73xx;
 	struct cvmx_rst_eco_s                 cn78xx;
 };
 typedef union cvmx_rst_eco cvmx_rst_eco_t;
@@ -467,11 +605,36 @@ union cvmx_rst_int {
 #endif
 	} cn70xx;
 	struct cvmx_rst_int_cn70xx            cn70xxp1;
+	struct cvmx_rst_int_s                 cn73xx;
 	struct cvmx_rst_int_s                 cn78xx;
 };
 typedef union cvmx_rst_int cvmx_rst_int_t;
 
 /**
+ * cvmx_rst_int_w1s
+ */
+union cvmx_rst_int_w1s {
+	uint64_t u64;
+	struct cvmx_rst_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t perst                        : 4;  /**< PERST*_L asserted while RST_CTL()[RST_RCV] = 1 and RST_CTL()[RST_CHIP] = 0. One bit
+                                                         corresponds to each controller. */
+	uint64_t reserved_4_7                 : 4;
+	uint64_t rst_link                     : 4;  /**< A controller link-down/hot-reset occurred while RST_CTL()[RST_LINK] = 0. Software must
+                                                         assert then deassert RST_SOFT_PRST()[SOFT_PRST]. One bit corresponds to each controller. */
+#else
+	uint64_t rst_link                     : 4;
+	uint64_t reserved_4_7                 : 4;
+	uint64_t perst                        : 4;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_rst_int_w1s_s             cn73xx;
+};
+typedef union cvmx_rst_int_w1s cvmx_rst_int_w1s_t;
+
+/**
  * cvmx_rst_ocx
  */
 union cvmx_rst_ocx {
@@ -493,6 +656,27 @@ union cvmx_rst_ocx {
 typedef union cvmx_rst_ocx cvmx_rst_ocx_t;
 
 /**
+ * cvmx_rst_out_ctl
+ */
+union cvmx_rst_out_ctl {
+	uint64_t u64;
+	struct cvmx_rst_out_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t soft_rst                     : 1;  /**< Soft reset. When set to 1 by software, this field drives the RST_OUT_N pin
+                                                         active low. In this case the field must also be cleared by software to deassert
+                                                         the pin. The pin is also automatically asserted and deasserted by hardware
+                                                         during a cold/warm/soft reset. */
+#else
+	uint64_t soft_rst                     : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_rst_out_ctl_s             cn73xx;
+};
+typedef union cvmx_rst_out_ctl cvmx_rst_out_ctl_t;
+
+/**
  * cvmx_rst_power_dbg
  */
 union cvmx_rst_power_dbg {
@@ -506,6 +690,7 @@ union cvmx_rst_power_dbg {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_rst_power_dbg_s           cn73xx;
 	struct cvmx_rst_power_dbg_s           cn78xx;
 };
 typedef union cvmx_rst_power_dbg cvmx_rst_power_dbg_t;
@@ -540,11 +725,41 @@ union cvmx_rst_pp_power {
 #endif
 	} cn70xx;
 	struct cvmx_rst_pp_power_cn70xx       cn70xxp1;
+	struct cvmx_rst_pp_power_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t gate                         : 16; /**< Powerdown enable. When both a bit and the corresponding CIU_PP_RST bit are set, the core
+                                                         has voltage removed to save power. In typical operation these bits are setup during
+                                                         initialization and PP resets are controlled through CIU_PP_RST. These bits may only be
+                                                         changed when the corresponding core is in reset using CIU_PP_RST. */
+#else
+	uint64_t gate                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_rst_pp_power_s            cn78xx;
 };
 typedef union cvmx_rst_pp_power cvmx_rst_pp_power_t;
 
 /**
+ * cvmx_rst_ref_cntr
+ */
+union cvmx_rst_ref_cntr {
+	uint64_t u64;
+	struct cvmx_rst_ref_cntr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cnt                          : 64; /**< Count. The counter is initialized to 0x0 during a cold reset and is otherwise continiously
+                                                         running.
+                                                         CNT is incremented every reference clock cycle (i.e. at 50 MHz). */
+#else
+	uint64_t cnt                          : 64;
+#endif
+	} s;
+	struct cvmx_rst_ref_cntr_s            cn73xx;
+};
+typedef union cvmx_rst_ref_cntr cvmx_rst_ref_cntr_t;
+
+/**
  * cvmx_rst_soft_prst#
  */
 union cvmx_rst_soft_prstx {
@@ -565,6 +780,7 @@ union cvmx_rst_soft_prstx {
 	} s;
 	struct cvmx_rst_soft_prstx_s          cn70xx;
 	struct cvmx_rst_soft_prstx_s          cn70xxp1;
+	struct cvmx_rst_soft_prstx_s          cn73xx;
 	struct cvmx_rst_soft_prstx_s          cn78xx;
 };
 typedef union cvmx_rst_soft_prstx cvmx_rst_soft_prstx_t;
@@ -586,8 +802,39 @@ union cvmx_rst_soft_rst {
 	} s;
 	struct cvmx_rst_soft_rst_s            cn70xx;
 	struct cvmx_rst_soft_rst_s            cn70xxp1;
+	struct cvmx_rst_soft_rst_s            cn73xx;
 	struct cvmx_rst_soft_rst_s            cn78xx;
 };
 typedef union cvmx_rst_soft_rst cvmx_rst_soft_rst_t;
 
+/**
+ * cvmx_rst_thermal_alert
+ */
+union cvmx_rst_thermal_alert {
+	uint64_t u64;
+	struct cvmx_rst_thermal_alert_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t trip                         : 1;  /**< This field is set by the onboard temperature sensor. For diagnostic use
+                                                         only. The bit can only be cleared by a deassertion of the PLL_DC_OK pin which
+                                                         completely resets the chip.
+                                                         INTERNAL: Not committed-to in 73xx HRM.
+                                                         Thermal trip pin. When set to 1, drives the THERMAL_TRIP_N pin active low. This field is
+                                                         set by the onboard temperature sensor reaching a failure threshold or writing this bit.
+                                                         The bit can only be cleared by a deassertion of the PLL_DC_OK pin which completely resets
+                                                         the chip. */
+	uint64_t reserved_1_7                 : 7;
+	uint64_t alert                        : 1;  /**< Thermal alert status. When set to 1, indicates the temperature sensor is currently at the
+                                                         failure threshold. */
+#else
+	uint64_t alert                        : 1;
+	uint64_t reserved_1_7                 : 7;
+	uint64_t trip                         : 1;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} s;
+	struct cvmx_rst_thermal_alert_s       cn73xx;
+};
+typedef union cvmx_rst_thermal_alert cvmx_rst_thermal_alert_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-sata-defs.h b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
index fe5b884..23e899d 100644
--- a/arch/mips/include/asm/octeon/cvmx-sata-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_SATA_UAHC_GBL_BISTAFR CVMX_SATA_UAHC_GBL_BISTAFR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_BISTAFR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTAFR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000A0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTAFR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_BISTCR CVMX_SATA_UAHC_GBL_BISTCR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_BISTCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000A4ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTCR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_BISTDECR CVMX_SATA_UAHC_GBL_BISTDECR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_BISTDECR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTDECR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000B0ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTDECR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_BISTFCTR CVMX_SATA_UAHC_GBL_BISTFCTR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_BISTFCTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTFCTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000A8ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTFCTR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_BISTSR CVMX_SATA_UAHC_GBL_BISTSR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_BISTSR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTSR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000ACull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTSR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_CAP CVMX_SATA_UAHC_GBL_CAP_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_CAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_CAP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000000ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_CAP_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_CAP2 CVMX_SATA_UAHC_GBL_CAP2_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_CAP2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_CAP2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000024ull);
 }
@@ -133,7 +133,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_CAP2_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_CCC_CTL CVMX_SATA_UAHC_GBL_CCC_CTL_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_CCC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_CCC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000014ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_CCC_CTL_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_CCC_PORTS CVMX_SATA_UAHC_GBL_CCC_PORTS_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_CCC_PORTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_CCC_PORTS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000018ull);
 }
@@ -155,7 +155,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_CCC_PORTS_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_GHC CVMX_SATA_UAHC_GBL_GHC_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_GHC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_GHC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000004ull);
 }
@@ -166,7 +166,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_GHC_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_GPARAM1R CVMX_SATA_UAHC_GBL_GPARAM1R_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_GPARAM1R_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_GPARAM1R not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000E8ull);
 }
@@ -177,7 +177,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_GPARAM1R_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_GPARAM2R CVMX_SATA_UAHC_GBL_GPARAM2R_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_GPARAM2R_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_GPARAM2R not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000ECull);
 }
@@ -188,7 +188,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_GPARAM2R_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_IDR CVMX_SATA_UAHC_GBL_IDR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_IDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_IDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000FCull);
 }
@@ -199,7 +199,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_IDR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_IS CVMX_SATA_UAHC_GBL_IS_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_IS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_IS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000008ull);
 }
@@ -210,7 +210,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_IS_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_OOBR CVMX_SATA_UAHC_GBL_OOBR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_OOBR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_OOBR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000BCull);
 }
@@ -221,7 +221,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_OOBR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_PI CVMX_SATA_UAHC_GBL_PI_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_PI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_PI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C000000000Cull);
 }
@@ -232,7 +232,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_PI_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_PPARAMR CVMX_SATA_UAHC_GBL_PPARAMR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_PPARAMR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_PPARAMR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000F0ull);
 }
@@ -243,7 +243,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_PPARAMR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_TESTR CVMX_SATA_UAHC_GBL_TESTR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_TESTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_TESTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000F4ull);
 }
@@ -254,7 +254,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_TESTR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_TIMER1MS CVMX_SATA_UAHC_GBL_TIMER1MS_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_TIMER1MS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_TIMER1MS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000E0ull);
 }
@@ -265,7 +265,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_TIMER1MS_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_VERSIONR CVMX_SATA_UAHC_GBL_VERSIONR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_VERSIONR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_VERSIONR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000F8ull);
 }
@@ -276,7 +276,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_VERSIONR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_VS CVMX_SATA_UAHC_GBL_VS_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_VS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_VS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000010ull);
 }
@@ -287,7 +287,8 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_VS_FUNC(void)
 static inline uint64_t CVMX_SATA_UAHC_PX_CI(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_CI(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000138ull) + ((offset) & 1) * 128;
 }
@@ -298,7 +299,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_CI(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_CLB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_CLB(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000100ull) + ((offset) & 1) * 128;
 }
@@ -309,7 +311,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_CLB(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_CMD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_CMD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000118ull) + ((offset) & 1) * 128;
 }
@@ -320,7 +323,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_CMD(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_DMACR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_DMACR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000170ull) + ((offset) & 1) * 128;
 }
@@ -331,7 +335,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_DMACR(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_FB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_FB(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000108ull) + ((offset) & 1) * 128;
 }
@@ -342,7 +347,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_FB(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_FBS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_FBS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000140ull) + ((offset) & 1) * 128;
 }
@@ -353,7 +359,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_FBS(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_IE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_IE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000114ull) + ((offset) & 1) * 128;
 }
@@ -364,7 +371,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_IE(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_IS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_IS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000110ull) + ((offset) & 1) * 128;
 }
@@ -375,7 +383,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_IS(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_PHYCR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_PHYCR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000178ull) + ((offset) & 1) * 128;
 }
@@ -386,7 +395,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_PHYCR(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_PHYSR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_PHYSR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C000000017Cull) + ((offset) & 1) * 128;
 }
@@ -397,7 +407,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_PHYSR(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SACT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SACT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000134ull) + ((offset) & 1) * 128;
 }
@@ -408,7 +419,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SACT(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C000000012Cull) + ((offset) & 1) * 128;
 }
@@ -419,7 +431,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SCTL(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000130ull) + ((offset) & 1) * 128;
 }
@@ -430,7 +443,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SERR(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000124ull) + ((offset) & 1) * 128;
 }
@@ -441,7 +455,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SIG(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SNTF(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SNTF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C000000013Cull) + ((offset) & 1) * 128;
 }
@@ -452,7 +467,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SNTF(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000128ull) + ((offset) & 1) * 128;
 }
@@ -463,7 +479,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SSTS(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_TFD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_TFD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000120ull) + ((offset) & 1) * 128;
 }
@@ -474,7 +491,7 @@ static inline uint64_t CVMX_SATA_UAHC_PX_TFD(unsigned long offset)
 #define CVMX_SATA_UCTL_BIST_STATUS CVMX_SATA_UCTL_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UCTL_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118006C000008ull);
 }
@@ -485,7 +502,7 @@ static inline uint64_t CVMX_SATA_UCTL_BIST_STATUS_FUNC(void)
 #define CVMX_SATA_UCTL_CTL CVMX_SATA_UCTL_CTL_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UCTL_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118006C000000ull);
 }
@@ -493,10 +510,21 @@ static inline uint64_t CVMX_SATA_UCTL_CTL_FUNC(void)
 #define CVMX_SATA_UCTL_CTL (CVMX_ADD_IO_SEG(0x000118006C000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UCTL_ECC CVMX_SATA_UCTL_ECC_FUNC()
+static inline uint64_t CVMX_SATA_UCTL_ECC_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UCTL_ECC not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x000118006C0000F0ull);
+}
+#else
+#define CVMX_SATA_UCTL_ECC (CVMX_ADD_IO_SEG(0x000118006C0000F0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SATA_UCTL_INTSTAT CVMX_SATA_UCTL_INTSTAT_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_INTSTAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UCTL_INTSTAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118006C000030ull);
 }
@@ -507,7 +535,7 @@ static inline uint64_t CVMX_SATA_UCTL_INTSTAT_FUNC(void)
 #define CVMX_SATA_UCTL_SHIM_CFG CVMX_SATA_UCTL_SHIM_CFG_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_SHIM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UCTL_SHIM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118006C0000E8ull);
 }
@@ -526,6 +554,17 @@ static inline uint64_t CVMX_SATA_UCTL_SPARE0_FUNC(void)
 #define CVMX_SATA_UCTL_SPARE0 (CVMX_ADD_IO_SEG(0x000118006C000010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UCTL_SPARE0_ECO CVMX_SATA_UCTL_SPARE0_ECO_FUNC()
+static inline uint64_t CVMX_SATA_UCTL_SPARE0_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UCTL_SPARE0_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x000118006C000010ull);
+}
+#else
+#define CVMX_SATA_UCTL_SPARE0_ECO (CVMX_ADD_IO_SEG(0x000118006C000010ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SATA_UCTL_SPARE1 CVMX_SATA_UCTL_SPARE1_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_SPARE1_FUNC(void)
 {
@@ -536,17 +575,30 @@ static inline uint64_t CVMX_SATA_UCTL_SPARE1_FUNC(void)
 #else
 #define CVMX_SATA_UCTL_SPARE1 (CVMX_ADD_IO_SEG(0x000118006C0000F8ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UCTL_SPARE1_ECO CVMX_SATA_UCTL_SPARE1_ECO_FUNC()
+static inline uint64_t CVMX_SATA_UCTL_SPARE1_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UCTL_SPARE1_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x000118006C0000F8ull);
+}
+#else
+#define CVMX_SATA_UCTL_SPARE1_ECO (CVMX_ADD_IO_SEG(0x000118006C0000F8ull))
+#endif
 
 /**
  * cvmx_sata_uahc_gbl_bistafr
  *
- * INTERNAL: See DWC_ahsata databook v4.10a
- * This register is shared between SATA ports.  Before accessing this
+ * This register is shared between SATA ports. Before accessing this
  * register, first select the required port by writing the port number
- * to the SATA_UAHC_GBL_TESTR[PSEL] field.
+ * to the SATA()_UAHC_GBL_TESTR[PSEL] field.
+ *
  * This register contains the pattern definition (bits 23:16 of the
  * first DWORD) and the data pattern (bits 7:0 of the second DWORD)
  * fields of the received BIST activate FIS.
+ *
+ * INTERNAL: See DWC_ahsata databook v4.20a.
  */
 union cvmx_sata_uahc_gbl_bistafr {
 	uint32_t u32;
@@ -554,19 +606,19 @@ union cvmx_sata_uahc_gbl_bistafr {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_16_31               : 16;
 	uint32_t ncp                          : 8;  /**< Bits 7:0 of the second DWORD of BIST activate FIS.
-                                                         0xF1 = low transition density pattern (LTDP)
-                                                         0xB5 = high transition density pattern (HTDP)
-                                                         0xAB = low frequency spectral component pattern (LFSCP)
-                                                         0x7F = simultaneous switching outputs pattern (SSOP)
-                                                         0x78 = mid frequency test pattern (MFTP)
-                                                         0x4A = high frequency test pattern (HFTP)
-                                                         0x7E = low frequency test pattern (LFTP)
-                                                         All other values = lone bit pattern (LBP) */
+                                                         0xF1 = low transition density pattern (LTDP).
+                                                         0xB5 = high transition density pattern (HTDP).
+                                                         0xAB = low frequency spectral component pattern (LFSCP).
+                                                         0x7F = simultaneous switching outputs pattern (SSOP).
+                                                         0x78 = mid frequency test pattern (MFTP).
+                                                         0x4A = high frequency test pattern (HFTP).
+                                                         0x7E = low frequency test pattern (LFTP).
+                                                         else = lone bit pattern (LBP). */
 	uint32_t pd                           : 8;  /**< Bits 23:16 of the first DWORD of the BIST activate FIS. Only the following values are
                                                          supported:
-                                                         0x10 = Far-end retimed
-                                                         0xC0 = Far-end transmit only
-                                                         0xE0 = Far-end transmit only with scrambler bypassed */
+                                                         0x10 = Far-end retimed.
+                                                         0xC0 = Far-end transmit only.
+                                                         0xE0 = Far-end transmit only with scrambler bypassed. */
 #else
 	uint32_t pd                           : 8;
 	uint32_t ncp                          : 8;
@@ -575,6 +627,7 @@ union cvmx_sata_uahc_gbl_bistafr {
 	} s;
 	struct cvmx_sata_uahc_gbl_bistafr_s   cn70xx;
 	struct cvmx_sata_uahc_gbl_bistafr_s   cn70xxp1;
+	struct cvmx_sata_uahc_gbl_bistafr_s   cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_bistafr cvmx_sata_uahc_gbl_bistafr_t;
 
@@ -638,16 +691,18 @@ union cvmx_sata_uahc_gbl_bistcr {
 	} s;
 	struct cvmx_sata_uahc_gbl_bistcr_s    cn70xx;
 	struct cvmx_sata_uahc_gbl_bistcr_s    cn70xxp1;
+	struct cvmx_sata_uahc_gbl_bistcr_s    cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_bistcr cvmx_sata_uahc_gbl_bistcr_t;
 
 /**
  * cvmx_sata_uahc_gbl_bistdecr
  *
- * INTERNAL: See DWC_ahsata databook v4.10a
- * This register is shared between SATA ports.  Before accessing this
+ * This register is shared between SATA ports. Before accessing this
  * register, first select the required port by writing the port number
- * to the SATA_UAHC_GBL_TESTR[PSEL] field.
+ * to the SATA()_UAHC_GBL_TESTR[PSEL] field.
+ *
+ * INTERNAL: See DWC_ahsata databook v4.20a.
  */
 union cvmx_sata_uahc_gbl_bistdecr {
 	uint32_t u32;
@@ -660,16 +715,18 @@ union cvmx_sata_uahc_gbl_bistdecr {
 	} s;
 	struct cvmx_sata_uahc_gbl_bistdecr_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_bistdecr_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_bistdecr_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_bistdecr cvmx_sata_uahc_gbl_bistdecr_t;
 
 /**
  * cvmx_sata_uahc_gbl_bistfctr
  *
- * INTERNAL: See DWC_ahsata databook v4.10a
- * This register is shared between SATA ports.  Before accessing this
+ * This register is shared between SATA ports. Before accessing this
  * register, first select the required port by writing the port number
- * to the SATA_UAHC_GBL_TESTR[PSEL] field.
+ * to the SATA()_UAHC_GBL_TESTR[PSEL] field.
+ *
+ * INTERNAL: See DWC_ahsata databook v4.20a.
  */
 union cvmx_sata_uahc_gbl_bistfctr {
 	uint32_t u32;
@@ -682,6 +739,7 @@ union cvmx_sata_uahc_gbl_bistfctr {
 	} s;
 	struct cvmx_sata_uahc_gbl_bistfctr_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_bistfctr_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_bistfctr_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_bistfctr cvmx_sata_uahc_gbl_bistfctr_t;
 
@@ -706,6 +764,7 @@ union cvmx_sata_uahc_gbl_bistsr {
 	} s;
 	struct cvmx_sata_uahc_gbl_bistsr_s    cn70xx;
 	struct cvmx_sata_uahc_gbl_bistsr_s    cn70xxp1;
+	struct cvmx_sata_uahc_gbl_bistsr_s    cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_bistsr cvmx_sata_uahc_gbl_bistsr_t;
 
@@ -766,6 +825,7 @@ union cvmx_sata_uahc_gbl_cap {
 	} s;
 	struct cvmx_sata_uahc_gbl_cap_s       cn70xx;
 	struct cvmx_sata_uahc_gbl_cap_s       cn70xxp1;
+	struct cvmx_sata_uahc_gbl_cap_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_cap cvmx_sata_uahc_gbl_cap_t;
 
@@ -798,6 +858,7 @@ union cvmx_sata_uahc_gbl_cap2 {
 	} s;
 	struct cvmx_sata_uahc_gbl_cap2_s      cn70xx;
 	struct cvmx_sata_uahc_gbl_cap2_s      cn70xxp1;
+	struct cvmx_sata_uahc_gbl_cap2_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_cap2 cvmx_sata_uahc_gbl_cap2_t;
 
@@ -826,6 +887,7 @@ union cvmx_sata_uahc_gbl_ccc_ctl {
 	} s;
 	struct cvmx_sata_uahc_gbl_ccc_ctl_s   cn70xx;
 	struct cvmx_sata_uahc_gbl_ccc_ctl_s   cn70xxp1;
+	struct cvmx_sata_uahc_gbl_ccc_ctl_s   cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_ccc_ctl cvmx_sata_uahc_gbl_ccc_ctl_t;
 
@@ -848,6 +910,7 @@ union cvmx_sata_uahc_gbl_ccc_ports {
 	} s;
 	struct cvmx_sata_uahc_gbl_ccc_ports_s cn70xx;
 	struct cvmx_sata_uahc_gbl_ccc_ports_s cn70xxp1;
+	struct cvmx_sata_uahc_gbl_ccc_ports_s cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_ccc_ports cvmx_sata_uahc_gbl_ccc_ports_t;
 
@@ -874,6 +937,7 @@ union cvmx_sata_uahc_gbl_ghc {
 	} s;
 	struct cvmx_sata_uahc_gbl_ghc_s       cn70xx;
 	struct cvmx_sata_uahc_gbl_ghc_s       cn70xxp1;
+	struct cvmx_sata_uahc_gbl_ghc_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_ghc cvmx_sata_uahc_gbl_ghc_t;
 
@@ -920,6 +984,7 @@ union cvmx_sata_uahc_gbl_gparam1r {
 	} s;
 	struct cvmx_sata_uahc_gbl_gparam1r_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_gparam1r_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_gparam1r_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_gparam1r cvmx_sata_uahc_gbl_gparam1r_t;
 
@@ -962,6 +1027,7 @@ union cvmx_sata_uahc_gbl_gparam2r {
 	} s;
 	struct cvmx_sata_uahc_gbl_gparam2r_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_gparam2r_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_gparam2r_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_gparam2r cvmx_sata_uahc_gbl_gparam2r_t;
 
@@ -982,6 +1048,7 @@ union cvmx_sata_uahc_gbl_idr {
 	} s;
 	struct cvmx_sata_uahc_gbl_idr_s       cn70xx;
 	struct cvmx_sata_uahc_gbl_idr_s       cn70xxp1;
+	struct cvmx_sata_uahc_gbl_idr_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_idr cvmx_sata_uahc_gbl_idr_t;
 
@@ -1004,6 +1071,7 @@ union cvmx_sata_uahc_gbl_is {
 	} s;
 	struct cvmx_sata_uahc_gbl_is_s        cn70xx;
 	struct cvmx_sata_uahc_gbl_is_s        cn70xxp1;
+	struct cvmx_sata_uahc_gbl_is_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_is cvmx_sata_uahc_gbl_is_t;
 
@@ -1034,6 +1102,7 @@ union cvmx_sata_uahc_gbl_oobr {
 	} s;
 	struct cvmx_sata_uahc_gbl_oobr_s      cn70xx;
 	struct cvmx_sata_uahc_gbl_oobr_s      cn70xxp1;
+	struct cvmx_sata_uahc_gbl_oobr_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_oobr cvmx_sata_uahc_gbl_oobr_t;
 
@@ -1056,6 +1125,7 @@ union cvmx_sata_uahc_gbl_pi {
 	} s;
 	struct cvmx_sata_uahc_gbl_pi_s        cn70xx;
 	struct cvmx_sata_uahc_gbl_pi_s        cn70xxp1;
+	struct cvmx_sata_uahc_gbl_pi_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_pi cvmx_sata_uahc_gbl_pi_t;
 
@@ -1088,6 +1158,7 @@ union cvmx_sata_uahc_gbl_pparamr {
 	} s;
 	struct cvmx_sata_uahc_gbl_pparamr_s   cn70xx;
 	struct cvmx_sata_uahc_gbl_pparamr_s   cn70xxp1;
+	struct cvmx_sata_uahc_gbl_pparamr_s   cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_pparamr cvmx_sata_uahc_gbl_pparamr_t;
 
@@ -1101,6 +1172,26 @@ union cvmx_sata_uahc_gbl_testr {
 	uint32_t u32;
 	struct cvmx_sata_uahc_gbl_testr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_25_31               : 7;
+	uint32_t bsel                         : 1;  /**< This field is used to select a bank for BIST or Data Protection
+                                                         operation. The options for this field are:
+                                                         0x0 - BIST registers selected
+                                                         0x1 - Data Protection registers selected */
+	uint32_t reserved_19_23               : 5;
+	uint32_t psel                         : 3;  /**< Port select. */
+	uint32_t reserved_1_15                : 15;
+	uint32_t test_if                      : 1;  /**< Test interface. */
+#else
+	uint32_t test_if                      : 1;
+	uint32_t reserved_1_15                : 15;
+	uint32_t psel                         : 3;
+	uint32_t reserved_19_23               : 5;
+	uint32_t bsel                         : 1;
+	uint32_t reserved_25_31               : 7;
+#endif
+	} s;
+	struct cvmx_sata_uahc_gbl_testr_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_19_31               : 13;
 	uint32_t psel                         : 3;  /**< Port select. */
 	uint32_t reserved_1_15                : 15;
@@ -1111,9 +1202,9 @@ union cvmx_sata_uahc_gbl_testr {
 	uint32_t psel                         : 3;
 	uint32_t reserved_19_31               : 13;
 #endif
-	} s;
-	struct cvmx_sata_uahc_gbl_testr_s     cn70xx;
-	struct cvmx_sata_uahc_gbl_testr_s     cn70xxp1;
+	} cn70xx;
+	struct cvmx_sata_uahc_gbl_testr_cn70xx cn70xxp1;
+	struct cvmx_sata_uahc_gbl_testr_s     cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_testr cvmx_sata_uahc_gbl_testr_t;
 
@@ -1136,6 +1227,7 @@ union cvmx_sata_uahc_gbl_timer1ms {
 	} s;
 	struct cvmx_sata_uahc_gbl_timer1ms_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_timer1ms_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_timer1ms_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_timer1ms cvmx_sata_uahc_gbl_timer1ms_t;
 
@@ -1156,6 +1248,7 @@ union cvmx_sata_uahc_gbl_versionr {
 	} s;
 	struct cvmx_sata_uahc_gbl_versionr_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_versionr_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_versionr_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_versionr cvmx_sata_uahc_gbl_versionr_t;
 
@@ -1178,6 +1271,7 @@ union cvmx_sata_uahc_gbl_vs {
 	} s;
 	struct cvmx_sata_uahc_gbl_vs_s        cn70xx;
 	struct cvmx_sata_uahc_gbl_vs_s        cn70xxp1;
+	struct cvmx_sata_uahc_gbl_vs_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_vs cvmx_sata_uahc_gbl_vs_t;
 
@@ -1198,6 +1292,7 @@ union cvmx_sata_uahc_px_ci {
 	} s;
 	struct cvmx_sata_uahc_px_ci_s         cn70xx;
 	struct cvmx_sata_uahc_px_ci_s         cn70xxp1;
+	struct cvmx_sata_uahc_px_ci_s         cn73xx;
 };
 typedef union cvmx_sata_uahc_px_ci cvmx_sata_uahc_px_ci_t;
 
@@ -1220,6 +1315,7 @@ union cvmx_sata_uahc_px_clb {
 	} s;
 	struct cvmx_sata_uahc_px_clb_s        cn70xx;
 	struct cvmx_sata_uahc_px_clb_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_clb_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_clb cvmx_sata_uahc_px_clb_t;
 
@@ -1285,6 +1381,7 @@ union cvmx_sata_uahc_px_cmd {
 	} s;
 	struct cvmx_sata_uahc_px_cmd_s        cn70xx;
 	struct cvmx_sata_uahc_px_cmd_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_cmd_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_cmd cvmx_sata_uahc_px_cmd_t;
 
@@ -1311,6 +1408,7 @@ union cvmx_sata_uahc_px_dmacr {
 	} s;
 	struct cvmx_sata_uahc_px_dmacr_s      cn70xx;
 	struct cvmx_sata_uahc_px_dmacr_s      cn70xxp1;
+	struct cvmx_sata_uahc_px_dmacr_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_px_dmacr cvmx_sata_uahc_px_dmacr_t;
 
@@ -1333,6 +1431,7 @@ union cvmx_sata_uahc_px_fb {
 	} s;
 	struct cvmx_sata_uahc_px_fb_s         cn70xx;
 	struct cvmx_sata_uahc_px_fb_s         cn70xxp1;
+	struct cvmx_sata_uahc_px_fb_s         cn73xx;
 };
 typedef union cvmx_sata_uahc_px_fb cvmx_sata_uahc_px_fb_t;
 
@@ -1367,6 +1466,7 @@ union cvmx_sata_uahc_px_fbs {
 	} s;
 	struct cvmx_sata_uahc_px_fbs_s        cn70xx;
 	struct cvmx_sata_uahc_px_fbs_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_fbs_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_fbs cvmx_sata_uahc_px_fbs_t;
 
@@ -1423,6 +1523,7 @@ union cvmx_sata_uahc_px_ie {
 	} s;
 	struct cvmx_sata_uahc_px_ie_s         cn70xx;
 	struct cvmx_sata_uahc_px_ie_s         cn70xxp1;
+	struct cvmx_sata_uahc_px_ie_s         cn73xx;
 };
 typedef union cvmx_sata_uahc_px_ie cvmx_sata_uahc_px_ie_t;
 
@@ -1479,6 +1580,7 @@ union cvmx_sata_uahc_px_is {
 	} s;
 	struct cvmx_sata_uahc_px_is_s         cn70xx;
 	struct cvmx_sata_uahc_px_is_s         cn70xxp1;
+	struct cvmx_sata_uahc_px_is_s         cn73xx;
 };
 typedef union cvmx_sata_uahc_px_is cvmx_sata_uahc_px_is_t;
 
@@ -1499,6 +1601,7 @@ union cvmx_sata_uahc_px_phycr {
 	} s;
 	struct cvmx_sata_uahc_px_phycr_s      cn70xx;
 	struct cvmx_sata_uahc_px_phycr_s      cn70xxp1;
+	struct cvmx_sata_uahc_px_phycr_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_px_phycr cvmx_sata_uahc_px_phycr_t;
 
@@ -1519,6 +1622,7 @@ union cvmx_sata_uahc_px_physr {
 	} s;
 	struct cvmx_sata_uahc_px_physr_s      cn70xx;
 	struct cvmx_sata_uahc_px_physr_s      cn70xxp1;
+	struct cvmx_sata_uahc_px_physr_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_px_physr cvmx_sata_uahc_px_physr_t;
 
@@ -1539,6 +1643,7 @@ union cvmx_sata_uahc_px_sact {
 	} s;
 	struct cvmx_sata_uahc_px_sact_s       cn70xx;
 	struct cvmx_sata_uahc_px_sact_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_sact_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_sact cvmx_sata_uahc_px_sact_t;
 
@@ -1569,6 +1674,7 @@ union cvmx_sata_uahc_px_sctl {
 	} s;
 	struct cvmx_sata_uahc_px_sctl_s       cn70xx;
 	struct cvmx_sata_uahc_px_sctl_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_sctl_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_sctl cvmx_sata_uahc_px_sctl_t;
 
@@ -1627,6 +1733,7 @@ union cvmx_sata_uahc_px_serr {
 	} s;
 	struct cvmx_sata_uahc_px_serr_s       cn70xx;
 	struct cvmx_sata_uahc_px_serr_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_serr_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_serr cvmx_sata_uahc_px_serr_t;
 
@@ -1647,6 +1754,7 @@ union cvmx_sata_uahc_px_sig {
 	} s;
 	struct cvmx_sata_uahc_px_sig_s        cn70xx;
 	struct cvmx_sata_uahc_px_sig_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_sig_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_sig cvmx_sata_uahc_px_sig_t;
 
@@ -1669,6 +1777,7 @@ union cvmx_sata_uahc_px_sntf {
 	} s;
 	struct cvmx_sata_uahc_px_sntf_s       cn70xx;
 	struct cvmx_sata_uahc_px_sntf_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_sntf_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_sntf cvmx_sata_uahc_px_sntf_t;
 
@@ -1695,6 +1804,7 @@ union cvmx_sata_uahc_px_ssts {
 	} s;
 	struct cvmx_sata_uahc_px_ssts_s       cn70xx;
 	struct cvmx_sata_uahc_px_ssts_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_ssts_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_ssts cvmx_sata_uahc_px_ssts_t;
 
@@ -1719,6 +1829,7 @@ union cvmx_sata_uahc_px_tfd {
 	} s;
 	struct cvmx_sata_uahc_px_tfd_s        cn70xx;
 	struct cvmx_sata_uahc_px_tfd_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_tfd_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_tfd cvmx_sata_uahc_px_tfd_t;
 
@@ -1771,6 +1882,7 @@ union cvmx_sata_uctl_bist_status {
 	} s;
 	struct cvmx_sata_uctl_bist_status_s   cn70xx;
 	struct cvmx_sata_uctl_bist_status_s   cn70xxp1;
+	struct cvmx_sata_uctl_bist_status_s   cn73xx;
 };
 typedef union cvmx_sata_uctl_bist_status cvmx_sata_uctl_bist_status_t;
 
@@ -1826,7 +1938,7 @@ union cvmx_sata_uctl_ctl {
                                                          0x2 = divide by 3 0x6 = divide by 16
                                                          0x3 = divide by 4 0x7 = divide by 24 */
 	uint64_t reserved_5_23                : 19;
-	uint64_t csclk_en                     : 1;  /**< Turns on the USB UCTL interface clock (coprocessor clock). This enables access to UAHC
+	uint64_t csclk_en                     : 1;  /**< Turns on the SATA UCTL interface clock (coprocessor clock). This enables access to UAHC
                                                          registers via the IOI, as well as UCTL registers starting from 0x30 via the RSL bus. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t sata_uahc_rst                : 1;  /**< Software reset; resets UAHC; active-high.
@@ -1857,10 +1969,87 @@ union cvmx_sata_uctl_ctl {
 	} s;
 	struct cvmx_sata_uctl_ctl_s           cn70xx;
 	struct cvmx_sata_uctl_ctl_s           cn70xxp1;
+	struct cvmx_sata_uctl_ctl_s           cn73xx;
 };
 typedef union cvmx_sata_uctl_ctl cvmx_sata_uctl_ctl_t;
 
 /**
+ * cvmx_sata_uctl_ecc
+ *
+ * This register can be used to disable ECC correction, insert ECC errors, and debug ECC
+ * failures.
+ * * The ECC_ERR* fields are captured when there are no outstanding ECC errors indicated in
+ * INTSTAT and a new ECC error arrives. Prioritization for multiple events occurring on the same
+ * cycle is indicated by the ECC_ERR_SOURCE enumeration: highest encoded value has highest
+ * priority.
+ * * The *ECC_*_DIS fields disable ECC correction; SBE and DBE errors are still reported. If
+ * *ECC_*_DIS = 0x1, then no data-correction occurs.
+ * * The *ECC_FLIP_SYND fields flip the syndrome<1:0> bits to generate single-bit/double-bit
+ * error for testing.
+ *
+ * 0x0 = normal operation.
+ * 0x1 = SBE on bit[0].
+ * 0x2 = SBE on bit[1].
+ * 0x3 = DBE on bit[1:0].
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
+ */
+union cvmx_sata_uctl_ecc {
+	uint64_t u64;
+	struct cvmx_sata_uctl_ecc_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_63_63               : 1;
+	uint64_t ecc_err_source               : 5;  /**< Source of ECC error, see UCTL_ECC_ERR_SOURCE_E. */
+	uint64_t ecc_err_syndrome             : 18; /**< Syndrome bits of the ECC error. */
+	uint64_t ecc_err_address              : 8;  /**< RAM address of the ECC error. */
+	uint64_t reserved_24_31               : 8;
+	uint64_t uctl_xm_r_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uctl_xm_r_ecc_cor_dis        : 1;  /**< Enables ECC correction on UCTL AxiMaster read-data FIFO. */
+	uint64_t uctl_xm_w_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uctl_xm_w_ecc_cor_dis        : 1;  /**< Enables ECC correction on UCTL AxiMaster write-data FIFO. */
+	uint64_t uahc_rx_ecc_flip_synd_p0     : 2;  /**< Insert ECC error for testing purposes for the UAHC RX RAM on Port 0. */
+	uint64_t uahc_rx_ecc_cor_dis_p0       : 1;  /**< Enables ECC correction on the UAHC RX RAM on Port 0. */
+	uint64_t uahc_tx_ecc_flip_synd_p0     : 2;  /**< Insert ECC error for testing purposes for the UAHC TX RAM on Port 0. */
+	uint64_t uahc_tx_ecc_cor_dis_p0       : 1;  /**< Enables ECC correction on the UAHC TX RAM on Port 0. */
+	uint64_t uahc_fb_ecc_flip_synd_p0     : 2;  /**< Insert ECC error for testing purposes for the UAHC FB RAM on Port 0. */
+	uint64_t uahc_fb_ecc_cor_dis_p0       : 1;  /**< Enables ECC correction on the UAHC FB RAM on Port 0. */
+	uint64_t uahc_rx_ecc_flip_synd_p1     : 2;  /**< Insert ECC error for testing purposes for the UAHC RX RAM on Port 1. */
+	uint64_t uahc_rx_ecc_cor_dis_p1       : 1;  /**< Enables ECC correction on the UAHC RX RAM on Port 1. */
+	uint64_t uahc_tx_ecc_flip_synd_p1     : 2;  /**< Insert ECC error for testing purposes for the UAHC TX RAM on Port 1. */
+	uint64_t uahc_tx_ecc_cor_dis_p1       : 1;  /**< Enables ECC correction on the UAHC TX RAM on Port 1. */
+	uint64_t uahc_fb_ecc_flip_synd_p1     : 2;  /**< Insert ECC error for testing purposes for the UAHC FB RAM on Port 1. */
+	uint64_t uahc_fb_ecc_cor_dis_p1       : 1;  /**< Enables ECC correction on the UAHC FB RAM on Port 1. */
+#else
+	uint64_t uahc_fb_ecc_cor_dis_p1       : 1;
+	uint64_t uahc_fb_ecc_flip_synd_p1     : 2;
+	uint64_t uahc_tx_ecc_cor_dis_p1       : 1;
+	uint64_t uahc_tx_ecc_flip_synd_p1     : 2;
+	uint64_t uahc_rx_ecc_cor_dis_p1       : 1;
+	uint64_t uahc_rx_ecc_flip_synd_p1     : 2;
+	uint64_t uahc_fb_ecc_cor_dis_p0       : 1;
+	uint64_t uahc_fb_ecc_flip_synd_p0     : 2;
+	uint64_t uahc_tx_ecc_cor_dis_p0       : 1;
+	uint64_t uahc_tx_ecc_flip_synd_p0     : 2;
+	uint64_t uahc_rx_ecc_cor_dis_p0       : 1;
+	uint64_t uahc_rx_ecc_flip_synd_p0     : 2;
+	uint64_t uctl_xm_w_ecc_cor_dis        : 1;
+	uint64_t uctl_xm_w_ecc_flip_synd      : 2;
+	uint64_t uctl_xm_r_ecc_cor_dis        : 1;
+	uint64_t uctl_xm_r_ecc_flip_synd      : 2;
+	uint64_t reserved_24_31               : 8;
+	uint64_t ecc_err_address              : 8;
+	uint64_t ecc_err_syndrome             : 18;
+	uint64_t ecc_err_source               : 5;
+	uint64_t reserved_63_63               : 1;
+#endif
+	} s;
+	struct cvmx_sata_uctl_ecc_s           cn73xx;
+};
+typedef union cvmx_sata_uctl_ecc cvmx_sata_uctl_ecc_t;
+
+/**
  * cvmx_sata_uctl_intstat
  *
  * Accessible by: always
@@ -1871,6 +2060,62 @@ union cvmx_sata_uctl_intstat {
 	uint64_t u64;
 	struct cvmx_sata_uctl_intstat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t fb_dbe_p0                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t rx_dbe_p0                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t tx_dbe_p0                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t fb_dbe_p1                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t rx_dbe_p1                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t tx_dbe_p1                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t fb_sbe_p0                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t rx_sbe_p0                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t tx_sbe_p0                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t fb_sbe_p1                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t rx_sbe_p1                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t tx_sbe_p1                    : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_r_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_r_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_w_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t xm_w_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t reserved_3_25                : 23;
+	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. The error information is logged in
+                                                         SATA_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates the
+                                                         assumptions made by the AXI-to-IOI shim. Such scenarios include: illegal length/size
+                                                         combinations and address out-of-bounds.
+                                                         For more information on exact failures, see description in
+                                                         SATA_UCTL_SHIM_CFG[XM_BAD_DMA_TYPE].
+                                                         The hardware does not translate the request correctly and results may violate IOI
+                                                         protocols. */
+	uint64_t xs_ncb_oob                   : 1;  /**< Detected out-of-bound register access to UAHC over IOI. The UAHC defines 1MB of register
+                                                         space, starting at offset 0x0. Any accesses outside of this register space cause this bit
+                                                         to be set to 1. The error information is logged in SATA_UCTL_SHIM_CFG[XS_NCB_OOB_*]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t xs_ncb_oob                   : 1;
+	uint64_t xm_bad_dma                   : 1;
+	uint64_t reserved_3_25                : 23;
+	uint64_t xm_w_sbe                     : 1;
+	uint64_t xm_w_dbe                     : 1;
+	uint64_t xm_r_sbe                     : 1;
+	uint64_t xm_r_dbe                     : 1;
+	uint64_t tx_sbe_p1                    : 1;
+	uint64_t rx_sbe_p1                    : 1;
+	uint64_t fb_sbe_p1                    : 1;
+	uint64_t tx_sbe_p0                    : 1;
+	uint64_t rx_sbe_p0                    : 1;
+	uint64_t fb_sbe_p0                    : 1;
+	uint64_t tx_dbe_p1                    : 1;
+	uint64_t rx_dbe_p1                    : 1;
+	uint64_t fb_dbe_p1                    : 1;
+	uint64_t tx_dbe_p0                    : 1;
+	uint64_t rx_dbe_p0                    : 1;
+	uint64_t fb_dbe_p0                    : 1;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} s;
+	struct cvmx_sata_uctl_intstat_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
 	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. The error information is logged in
                                                          SATA_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates the
@@ -1890,9 +2135,9 @@ union cvmx_sata_uctl_intstat {
 	uint64_t xm_bad_dma                   : 1;
 	uint64_t reserved_3_63                : 61;
 #endif
-	} s;
-	struct cvmx_sata_uctl_intstat_s       cn70xx;
-	struct cvmx_sata_uctl_intstat_s       cn70xxp1;
+	} cn70xx;
+	struct cvmx_sata_uctl_intstat_cn70xx  cn70xxp1;
+	struct cvmx_sata_uctl_intstat_s       cn73xx;
 };
 typedef union cvmx_sata_uctl_intstat cvmx_sata_uctl_intstat_t;
 
@@ -1913,6 +2158,41 @@ union cvmx_sata_uctl_shim_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t xs_ncb_oob_wrn               : 1;  /**< Read/write error log for out-of-bound UAHC register access.
                                                          0 = read, 1 = write. */
+	uint64_t reserved_60_62               : 3;
+	uint64_t xs_ncb_oob_osrc              : 12; /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB error. */
+	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
+                                                         0 = read error log, 1 = write error log. */
+	uint64_t reserved_44_46               : 3;
+	uint64_t xm_bad_dma_type              : 4;  /**< ErrType error log for bad DMA access from UAHC. Encodes the type of error encountered
+                                                         (error largest encoded value has priority). See SATA_UCTL_XM_BAD_DMA_TYPE_E. */
+	uint64_t reserved_14_39               : 26;
+	uint64_t dma_read_cmd                 : 2;  /**< Selects the IOI read command used by DMA accesses. See SATA_UCTL_DMA_READ_CMD_E. */
+	uint64_t reserved_11_11               : 1;
+	uint64_t dma_write_cmd                : 1;  /**< Selects the NCB write command used by DMA accesses. See UCTL_DMA_WRITE_CMD_E. */
+	uint64_t dma_endian_mode              : 2;  /**< Selects the endian format for DMA accesses to the L2C. See SATA_UCTL_ENDIAN_MODE_E. */
+	uint64_t reserved_2_7                 : 6;
+	uint64_t csr_endian_mode              : 2;  /**< Selects the endian format for IOI CSR accesses to the UAHC. Note that when UAHC CSRs are
+                                                         accessed via RSL, they are returned as big-endian. See SATA_UCTL_ENDIAN_MODE_E. */
+#else
+	uint64_t csr_endian_mode              : 2;
+	uint64_t reserved_2_7                 : 6;
+	uint64_t dma_endian_mode              : 2;
+	uint64_t dma_write_cmd                : 1;
+	uint64_t reserved_11_11               : 1;
+	uint64_t dma_read_cmd                 : 2;
+	uint64_t reserved_14_39               : 26;
+	uint64_t xm_bad_dma_type              : 4;
+	uint64_t reserved_44_46               : 3;
+	uint64_t xm_bad_dma_wrn               : 1;
+	uint64_t xs_ncb_oob_osrc              : 12;
+	uint64_t reserved_60_62               : 3;
+	uint64_t xs_ncb_oob_wrn               : 1;
+#endif
+	} s;
+	struct cvmx_sata_uctl_shim_cfg_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t xs_ncb_oob_wrn               : 1;  /**< Read/write error log for out-of-bound UAHC register access.
+                                                         0 = read, 1 = write. */
 	uint64_t reserved_57_62               : 6;
 	uint64_t xs_ncb_oob_osrc              : 9;  /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB error. */
 	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
@@ -1941,9 +2221,9 @@ union cvmx_sata_uctl_shim_cfg {
 	uint64_t reserved_57_62               : 6;
 	uint64_t xs_ncb_oob_wrn               : 1;
 #endif
-	} s;
-	struct cvmx_sata_uctl_shim_cfg_s      cn70xx;
-	struct cvmx_sata_uctl_shim_cfg_s      cn70xxp1;
+	} cn70xx;
+	struct cvmx_sata_uctl_shim_cfg_cn70xx cn70xxp1;
+	struct cvmx_sata_uctl_shim_cfg_s      cn73xx;
 };
 typedef union cvmx_sata_uctl_shim_cfg cvmx_sata_uctl_shim_cfg_t;
 
@@ -1969,6 +2249,28 @@ union cvmx_sata_uctl_spare0 {
 typedef union cvmx_sata_uctl_spare0 cvmx_sata_uctl_spare0_t;
 
 /**
+ * cvmx_sata_uctl_spare0_eco
+ *
+ * Accessible by: always
+ * Reset by: IOI reset (srst_n)
+ * This register is spare.
+ */
+union cvmx_sata_uctl_spare0_eco {
+	uint64_t u64;
+	struct cvmx_sata_uctl_spare0_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< Spare. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_sata_uctl_spare0_eco_s    cn73xx;
+};
+typedef union cvmx_sata_uctl_spare0_eco cvmx_sata_uctl_spare0_eco_t;
+
+/**
  * cvmx_sata_uctl_spare1
  *
  * Accessible by: only when A_CLKDIV_EN
@@ -1989,4 +2291,26 @@ union cvmx_sata_uctl_spare1 {
 };
 typedef union cvmx_sata_uctl_spare1 cvmx_sata_uctl_spare1_t;
 
+/**
+ * cvmx_sata_uctl_spare1_eco
+ *
+ * Accessible by: only when A_CLKDIV_EN
+ * Reset by: IOI reset (srst_n) or SATA_UCTL_CTL[SATA_UCTL_RST]
+ * This register is spare.
+ */
+union cvmx_sata_uctl_spare1_eco {
+	uint64_t u64;
+	struct cvmx_sata_uctl_spare1_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_sata_uctl_spare1_eco_s    cn73xx;
+};
+typedef union cvmx_sata_uctl_spare1_eco cvmx_sata_uctl_spare1_eco_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 2fdddcd..bfaca54 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_SLI_BIST_STATUS CVMX_SLI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_BIST_STATUS not supported on this chip\n");
 	return 0x0000000000000580ull;
 }
@@ -72,6 +72,7 @@ static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_CTL_PORTX(%lu) is invalid on this chip\n", offset);
@@ -84,7 +85,7 @@ static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 #define CVMX_SLI_CTL_STATUS CVMX_SLI_CTL_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_CTL_STATUS not supported on this chip\n");
 	return 0x0000000000000570ull;
 }
@@ -95,7 +96,7 @@ static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 #define CVMX_SLI_DATA_OUT_CNT CVMX_SLI_DATA_OUT_CNT_FUNC()
 static inline uint64_t CVMX_SLI_DATA_OUT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_DATA_OUT_CNT not supported on this chip\n");
 	return 0x00000000000005F0ull;
 }
@@ -133,6 +134,7 @@ static inline uint64_t CVMX_SLI_DMAX_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_CNT(%lu) is invalid on this chip\n", offset);
@@ -150,6 +152,7 @@ static inline uint64_t CVMX_SLI_DMAX_INT_LEVEL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n", offset);
@@ -167,6 +170,7 @@ static inline uint64_t CVMX_SLI_DMAX_TIM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_TIM(%lu) is invalid on this chip\n", offset);
@@ -195,6 +199,7 @@ static inline uint64_t CVMX_SLI_INT_ENB_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n", offset);
@@ -207,7 +212,7 @@ static inline uint64_t CVMX_SLI_INT_ENB_PORTX(unsigned long offset)
 #define CVMX_SLI_INT_SUM CVMX_SLI_INT_SUM_FUNC()
 static inline uint64_t CVMX_SLI_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_INT_SUM not supported on this chip\n");
 	return 0x0000000000000330ull;
 }
@@ -262,7 +267,7 @@ static inline uint64_t CVMX_SLI_LAST_WIN_RDATA3_FUNC(void)
 #define CVMX_SLI_MAC_CREDIT_CNT CVMX_SLI_MAC_CREDIT_CNT_FUNC()
 static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT not supported on this chip\n");
 	return 0x0000000000003D70ull;
 }
@@ -273,7 +278,7 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 #define CVMX_SLI_MAC_CREDIT_CNT2 CVMX_SLI_MAC_CREDIT_CNT2_FUNC()
 static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
 	return 0x0000000000003E10ull;
 }
@@ -284,18 +289,47 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 #define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
 static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
-		cvmx_warn("CVMX_SLI_MAC_NUMBER not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000003E00ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020050ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MAC_NUMBER not supported on this chip\n");
 	return 0x0000000000003E00ull;
 }
 #else
-#define CVMX_SLI_MAC_NUMBER (0x0000000000003E00ull)
+#define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
+static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000003E00ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020050ull;
+	}
+	return 0x0000000000003E00ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MEM_ACCESS_CTL CVMX_SLI_MEM_ACCESS_CTL_FUNC()
 static inline uint64_t CVMX_SLI_MEM_ACCESS_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MEM_ACCESS_CTL not supported on this chip\n");
 	return 0x00000000000002F0ull;
 }
@@ -311,6 +345,7 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset >= 12) && (offset <= 27)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset >= 12) && (offset <= 27))))))
 		cvmx_warn("CVMX_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n", offset);
@@ -323,45 +358,113 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 #define CVMX_SLI_MEM_CTL CVMX_SLI_MEM_CTL_FUNC()
 static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_MEM_CTL not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MEM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
 }
 #else
-#define CVMX_SLI_MEM_CTL (CVMX_ADD_IO_SEG(0x00011F00000105E0ull))
+#define CVMX_SLI_MEM_CTL CVMX_SLI_MEM_CTL_FUNC()
+static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MEM_INT_SUM CVMX_SLI_MEM_INT_SUM_FUNC()
 static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_MEM_INT_SUM not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MEM_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
 }
 #else
-#define CVMX_SLI_MEM_INT_SUM (CVMX_ADD_IO_SEG(0x00011F00000105D0ull))
+#define CVMX_SLI_MEM_INT_SUM CVMX_SLI_MEM_INT_SUM_FUNC()
+static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 64)))))
-		cvmx_warn("CVMX_SLI_MSIXX_TABLE_ADDR(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 64))
+				return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + ((offset) & 127) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 64))
+				return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + ((offset) & 127) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSIXX_TABLE_ADDR (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_MSIXX_TABLE_ADDR(offset) (CVMX_ADD_IO_SEG(0x00011F0000016000ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + (offset) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 64)))))
-		cvmx_warn("CVMX_SLI_MSIXX_TABLE_DATA(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 64))
+				return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 64))
+				return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + ((offset) & 127) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSIXX_TABLE_DATA (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_MSIXX_TABLE_DATA(offset) (CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + (offset) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(unsigned long offset)
@@ -389,23 +492,57 @@ static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(unsigned long offset)
 #define CVMX_SLI_MSIX_PBA0 CVMX_SLI_MSIX_PBA0_FUNC()
 static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_MSIX_PBA0 not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSIX_PBA0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
 }
 #else
-#define CVMX_SLI_MSIX_PBA0 (CVMX_ADD_IO_SEG(0x00011F0000017000ull))
+#define CVMX_SLI_MSIX_PBA0 CVMX_SLI_MSIX_PBA0_FUNC()
+static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MSIX_PBA1 CVMX_SLI_MSIX_PBA1_FUNC()
 static inline uint64_t CVMX_SLI_MSIX_PBA1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_MSIX_PBA1 not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000001010ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSIX_PBA1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
 }
 #else
-#define CVMX_SLI_MSIX_PBA1 (CVMX_ADD_IO_SEG(0x00011F0000017010ull))
+#define CVMX_SLI_MSIX_PBA1 CVMX_SLI_MSIX_PBA1_FUNC()
+static inline uint64_t CVMX_SLI_MSIX_PBA1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000001010ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MSI_ENB0 CVMX_SLI_MSI_ENB0_FUNC()
@@ -455,7 +592,7 @@ static inline uint64_t CVMX_SLI_MSI_ENB3_FUNC(void)
 #define CVMX_SLI_MSI_RCV0 CVMX_SLI_MSI_RCV0_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV0 not supported on this chip\n");
 	return 0x0000000000003C10ull;
 }
@@ -466,7 +603,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 #define CVMX_SLI_MSI_RCV1 CVMX_SLI_MSI_RCV1_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV1 not supported on this chip\n");
 	return 0x0000000000003C20ull;
 }
@@ -477,7 +614,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 #define CVMX_SLI_MSI_RCV2 CVMX_SLI_MSI_RCV2_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV2 not supported on this chip\n");
 	return 0x0000000000003C30ull;
 }
@@ -488,7 +625,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 #define CVMX_SLI_MSI_RCV3 CVMX_SLI_MSI_RCV3_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV3 not supported on this chip\n");
 	return 0x0000000000003C40ull;
 }
@@ -499,7 +636,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 #define CVMX_SLI_MSI_RD_MAP CVMX_SLI_MSI_RD_MAP_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RD_MAP not supported on this chip\n");
 	return 0x0000000000003CA0ull;
 }
@@ -598,7 +735,7 @@ static inline uint64_t CVMX_SLI_MSI_W1S_ENB3_FUNC(void)
 #define CVMX_SLI_MSI_WR_MAP CVMX_SLI_MSI_WR_MAP_FUNC()
 static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_WR_MAP not supported on this chip\n");
 	return 0x0000000000003C90ull;
 }
@@ -609,7 +746,7 @@ static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV CVMX_SLI_PCIE_MSI_RCV_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV not supported on this chip\n");
 	return 0x0000000000003CB0ull;
 }
@@ -620,7 +757,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B1 CVMX_SLI_PCIE_MSI_RCV_B1_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
 	return 0x0000000000000650ull;
 }
@@ -631,7 +768,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B2 CVMX_SLI_PCIE_MSI_RCV_B2_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
 	return 0x0000000000000660ull;
 }
@@ -642,7 +779,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B3 CVMX_SLI_PCIE_MSI_RCV_B3_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
 	return 0x0000000000000670ull;
 }
@@ -658,24 +795,42 @@ static inline uint64_t CVMX_SLI_PKTX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_CNTS(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002400ull + ((offset) & 63) * 16;
+	return 0x0000000000002400ull + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_CNTS(offset) (0x0000000000002400ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKTX_CNTS(offset) (0x0000000000002400ull + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
-		cvmx_warn("CVMX_SLI_PKTX_INPUT_CONTROL(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_INPUT_CONTROL (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + ((offset) & 63) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_INPUT_CONTROL(offset) (CVMX_ADD_IO_SEG(0x00011F0000014000ull) + ((offset) & 63) * 16)
+static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + (offset) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INSTR_BADDR(unsigned long offset)
@@ -686,13 +841,14 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002800ull + ((offset) & 63) * 16;
+	return 0x0000000000002800ull + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_INSTR_BADDR(offset) (0x0000000000002800ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKTX_INSTR_BADDR(offset) (0x0000000000002800ull + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
@@ -703,13 +859,14 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002C00ull + ((offset) & 63) * 16;
+	return 0x0000000000002C00ull + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(offset) (0x0000000000002C00ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(offset) (0x0000000000002C00ull + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
@@ -720,13 +877,14 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000003000ull + ((offset) & 63) * 16;
+	return 0x0000000000003000ull + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(offset) (0x0000000000003000ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(offset) (0x0000000000003000ull + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INSTR_HEADER(unsigned long offset)
@@ -747,13 +905,30 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_HEADER(unsigned long offset)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INT_LEVELS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
-		cvmx_warn("CVMX_SLI_PKTX_INT_LEVELS(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_INT_LEVELS (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + ((offset) & 63) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_INT_LEVELS(offset) (CVMX_ADD_IO_SEG(0x00011F0000014400ull) + ((offset) & 63) * 16)
+static inline uint64_t CVMX_SLI_PKTX_INT_LEVELS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + (offset) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_IN_BP(unsigned long offset)
@@ -771,15 +946,43 @@ static inline uint64_t CVMX_SLI_PKTX_IN_BP(unsigned long offset)
 #define CVMX_SLI_PKTX_IN_BP(offset) (0x0000000000003800ull + ((offset) & 31) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
+static inline uint64_t CVMX_SLI_PKTX_MBOX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
-		cvmx_warn("CVMX_SLI_PKTX_OUTPUT_CONTROL(%lu) is invalid on this chip\n", offset);
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127)))))
+		cvmx_warn("CVMX_SLI_PKTX_MBOX_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010210ull) + ((offset) & 127) * 0x20000ull;
+}
+#else
+#define CVMX_SLI_PKTX_MBOX_INT(offset) (CVMX_ADD_IO_SEG(0x00011F0000010210ull) + ((offset) & 127) * 0x20000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_OUTPUT_CONTROL (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + ((offset) & 63) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_OUTPUT_CONTROL(offset) (CVMX_ADD_IO_SEG(0x00011F0000014800ull) + ((offset) & 63) * 16)
+static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + (offset) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
@@ -790,13 +993,25 @@ static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000C00ull + ((offset) & 63) * 16;
+	return 0x0000000000000C00ull + ((offset) & 127) * 16;
+}
+#else
+#define CVMX_SLI_PKTX_OUT_SIZE(offset) (0x0000000000000C00ull + ((offset) & 127) * 16)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 63))))))
+		cvmx_warn("CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011F0000010200ull) + (((offset) & 1) + ((block_id) & 63) * 0x4000ull) * 8;
 }
 #else
-#define CVMX_SLI_PKTX_OUT_SIZE(offset) (0x0000000000000C00ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011F0000010200ull) + (((offset) & 1) + ((block_id) & 63) * 0x4000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_SLIST_BADDR(unsigned long offset)
@@ -807,13 +1022,14 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000001400ull + ((offset) & 63) * 16;
+	return 0x0000000000001400ull + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_SLIST_BADDR(offset) (0x0000000000001400ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKTX_SLIST_BADDR(offset) (0x0000000000001400ull + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
@@ -824,13 +1040,14 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000001800ull + ((offset) & 63) * 16;
+	return 0x0000000000001800ull + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(offset) (0x0000000000001800ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(offset) (0x0000000000001800ull + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
@@ -841,13 +1058,14 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000001C00ull + ((offset) & 63) * 16;
+	return 0x0000000000001C00ull + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(offset) (0x0000000000001C00ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(offset) (0x0000000000001C00ull + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_VF_SIG(unsigned long offset)
@@ -864,7 +1082,7 @@ static inline uint64_t CVMX_SLI_PKTX_VF_SIG(unsigned long offset)
 #define CVMX_SLI_PKT_CNT_INT CVMX_SLI_PKT_CNT_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_CNT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_CNT_INT not supported on this chip\n");
 	return 0x0000000000001130ull;
 }
@@ -952,7 +1170,7 @@ static inline uint64_t CVMX_SLI_PKT_INPUT_CONTROL_FUNC(void)
 #define CVMX_SLI_PKT_INSTR_ENB CVMX_SLI_PKT_INSTR_ENB_FUNC()
 static inline uint64_t CVMX_SLI_PKT_INSTR_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_INSTR_ENB not supported on this chip\n");
 	return 0x0000000000001000ull;
 }
@@ -960,6 +1178,17 @@ static inline uint64_t CVMX_SLI_PKT_INSTR_ENB_FUNC(void)
 #define CVMX_SLI_PKT_INSTR_ENB (0x0000000000001000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_PKT_INSTR_ENB2 CVMX_SLI_PKT_INSTR_ENB2_FUNC()
+static inline uint64_t CVMX_SLI_PKT_INSTR_ENB2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SLI_PKT_INSTR_ENB2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029008ull);
+}
+#else
+#define CVMX_SLI_PKT_INSTR_ENB2 (CVMX_ADD_IO_SEG(0x00011F0000029008ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_INSTR_RD_SIZE CVMX_SLI_PKT_INSTR_RD_SIZE_FUNC()
 static inline uint64_t CVMX_SLI_PKT_INSTR_RD_SIZE_FUNC(void)
 {
@@ -985,12 +1214,29 @@ static inline uint64_t CVMX_SLI_PKT_INSTR_SIZE_FUNC(void)
 #define CVMX_SLI_PKT_INT CVMX_SLI_PKT_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_PKT_INT not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
 }
 #else
-#define CVMX_SLI_PKT_INT (CVMX_ADD_IO_SEG(0x00011F0000011160ull))
+#define CVMX_SLI_PKT_INT CVMX_SLI_PKT_INT_FUNC()
+static inline uint64_t CVMX_SLI_PKT_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_INT_LEVELS CVMX_SLI_PKT_INT_LEVELS_FUNC()
@@ -1023,19 +1269,20 @@ static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002000ull + ((offset) & 63) * 16;
+	return 0x0000000000002000ull + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_PKT_IN_DONEX_CNTS(offset) (0x0000000000002000ull + ((offset) & 63) * 16)
+#define CVMX_SLI_PKT_IN_DONEX_CNTS(offset) (0x0000000000002000ull + ((offset) & 127) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_IN_INSTR_COUNTS CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC()
 static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
 	return 0x0000000000001200ull;
 }
@@ -1046,12 +1293,29 @@ static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 #define CVMX_SLI_PKT_IN_INT CVMX_SLI_PKT_IN_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_PKT_IN_INT not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_IN_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
 }
 #else
-#define CVMX_SLI_PKT_IN_INT (CVMX_ADD_IO_SEG(0x00011F0000011150ull))
+#define CVMX_SLI_PKT_IN_INT CVMX_SLI_PKT_IN_INT_FUNC()
+static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_IN_PCIE_PORT CVMX_SLI_PKT_IN_PCIE_PORT_FUNC()
@@ -1120,6 +1384,17 @@ static inline uint64_t CVMX_SLI_PKT_MAC1_SIG1_FUNC(void)
 #define CVMX_SLI_PKT_MAC1_SIG1 (CVMX_ADD_IO_SEG(0x00011F0000011330ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SLI_PKT_MACX_PFX_RINFO(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_SLI_PKT_MACX_PFX_RINFO(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011F0000029030ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
+}
+#else
+#define CVMX_SLI_PKT_MACX_PFX_RINFO(offset, block_id) (CVMX_ADD_IO_SEG(0x00011F0000029030ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKT_MACX_RINFO(unsigned long offset)
 {
 	if (!(
@@ -1134,18 +1409,35 @@ static inline uint64_t CVMX_SLI_PKT_MACX_RINFO(unsigned long offset)
 #define CVMX_SLI_PKT_MEM_CTL CVMX_SLI_PKT_MEM_CTL_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_PKT_MEM_CTL not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_MEM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
 }
 #else
-#define CVMX_SLI_PKT_MEM_CTL (CVMX_ADD_IO_SEG(0x00011F0000011120ull))
+#define CVMX_SLI_PKT_MEM_CTL CVMX_SLI_PKT_MEM_CTL_FUNC()
+static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_OUTPUT_WMARK CVMX_SLI_PKT_OUTPUT_WMARK_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
 	return 0x0000000000001180ull;
 }
@@ -1167,7 +1459,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BMODE_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN CVMX_SLI_PKT_OUT_BP_EN_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN not supported on this chip\n");
 	return 0x0000000000001240ull;
 }
@@ -1175,10 +1467,21 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN (0x0000000000001240ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_PKT_OUT_BP_EN2 CVMX_SLI_PKT_OUT_BP_EN2_FUNC()
+static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029250ull);
+}
+#else
+#define CVMX_SLI_PKT_OUT_BP_EN2 (CVMX_ADD_IO_SEG(0x00011F0000029250ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_OUT_ENB CVMX_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_ENB not supported on this chip\n");
 	return 0x0000000000001010ull;
 }
@@ -1186,6 +1489,17 @@ static inline uint64_t CVMX_SLI_PKT_OUT_ENB_FUNC(void)
 #define CVMX_SLI_PKT_OUT_ENB (0x0000000000001010ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_PKT_OUT_ENB2 CVMX_SLI_PKT_OUT_ENB2_FUNC()
+static inline uint64_t CVMX_SLI_PKT_OUT_ENB2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SLI_PKT_OUT_ENB2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029018ull);
+}
+#else
+#define CVMX_SLI_PKT_OUT_ENB2 (CVMX_ADD_IO_SEG(0x00011F0000029018ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_PCIE_PORT CVMX_SLI_PKT_PCIE_PORT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_PCIE_PORT_FUNC(void)
 {
@@ -1211,12 +1525,29 @@ static inline uint64_t CVMX_SLI_PKT_PORT_IN_RST_FUNC(void)
 #define CVMX_SLI_PKT_RING_RST CVMX_SLI_PKT_RING_RST_FUNC()
 static inline uint64_t CVMX_SLI_PKT_RING_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_PKT_RING_RST not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_RING_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
 }
 #else
-#define CVMX_SLI_PKT_RING_RST (CVMX_ADD_IO_SEG(0x00011F00000111E0ull))
+#define CVMX_SLI_PKT_RING_RST CVMX_SLI_PKT_RING_RST_FUNC()
+static inline uint64_t CVMX_SLI_PKT_RING_RST_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_SLIST_ES CVMX_SLI_PKT_SLIST_ES_FUNC()
@@ -1255,7 +1586,7 @@ static inline uint64_t CVMX_SLI_PKT_SLIST_ROR_FUNC(void)
 #define CVMX_SLI_PKT_TIME_INT CVMX_SLI_PKT_TIME_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_TIME_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_TIME_INT not supported on this chip\n");
 	return 0x0000000000001140ull;
 }
@@ -1274,6 +1605,17 @@ static inline uint64_t CVMX_SLI_PKT_TIME_INT_ENB_FUNC(void)
 #define CVMX_SLI_PKT_TIME_INT_ENB (0x0000000000001160ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_PKT_VF_SIG_INT CVMX_SLI_PKT_VF_SIG_INT_FUNC()
+static inline uint64_t CVMX_SLI_PKT_VF_SIG_INT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SLI_PKT_VF_SIG_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029170ull);
+}
+#else
+#define CVMX_SLI_PKT_VF_SIG_INT (CVMX_ADD_IO_SEG(0x00011F0000029170ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PORTX_PKIND(unsigned long offset)
 {
 	if (!(
@@ -1288,12 +1630,29 @@ static inline uint64_t CVMX_SLI_PORTX_PKIND(unsigned long offset)
 #define CVMX_SLI_S2C_END_MERGE CVMX_SLI_S2C_END_MERGE_FUNC()
 static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_SLI_S2C_END_MERGE not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_S2C_END_MERGE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
 }
 #else
-#define CVMX_SLI_S2C_END_MERGE (CVMX_ADD_IO_SEG(0x00011F0000015000ull))
+#define CVMX_SLI_S2C_END_MERGE CVMX_SLI_S2C_END_MERGE_FUNC()
+static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
@@ -1304,6 +1663,7 @@ static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1316,7 +1676,7 @@ static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 #define CVMX_SLI_SCRATCH_1 CVMX_SLI_SCRATCH_1_FUNC()
 static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_SCRATCH_1 not supported on this chip\n");
 	return 0x00000000000003C0ull;
 }
@@ -1327,7 +1687,7 @@ static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 #define CVMX_SLI_SCRATCH_2 CVMX_SLI_SCRATCH_2_FUNC()
 static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_SCRATCH_2 not supported on this chip\n");
 	return 0x00000000000003D0ull;
 }
@@ -1338,7 +1698,7 @@ static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 #define CVMX_SLI_STATE1 CVMX_SLI_STATE1_FUNC()
 static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE1 not supported on this chip\n");
 	return 0x0000000000000620ull;
 }
@@ -1349,7 +1709,7 @@ static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 #define CVMX_SLI_STATE2 CVMX_SLI_STATE2_FUNC()
 static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE2 not supported on this chip\n");
 	return 0x0000000000000630ull;
 }
@@ -1360,7 +1720,7 @@ static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 #define CVMX_SLI_STATE3 CVMX_SLI_STATE3_FUNC()
 static inline uint64_t CVMX_SLI_STATE3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE3 not supported on this chip\n");
 	return 0x0000000000000640ull;
 }
@@ -1382,7 +1742,7 @@ static inline uint64_t CVMX_SLI_TX_PIPE_FUNC(void)
 #define CVMX_SLI_WINDOW_CTL CVMX_SLI_WINDOW_CTL_FUNC()
 static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_WINDOW_CTL not supported on this chip\n");
 	return 0x00000000000002E0ull;
 }
@@ -1393,56 +1753,201 @@ static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
 #define CVMX_SLI_WIN_RD_ADDR CVMX_SLI_WIN_RD_ADDR_FUNC()
 static inline uint64_t CVMX_SLI_WIN_RD_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
-		cvmx_warn("CVMX_SLI_WIN_RD_ADDR not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000010ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020010ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_WIN_RD_ADDR not supported on this chip\n");
 	return 0x0000000000000010ull;
 }
 #else
-#define CVMX_SLI_WIN_RD_ADDR (0x0000000000000010ull)
+#define CVMX_SLI_WIN_RD_ADDR CVMX_SLI_WIN_RD_ADDR_FUNC()
+static inline uint64_t CVMX_SLI_WIN_RD_ADDR_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000010ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020010ull;
+	}
+	return 0x0000000000000010ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_WIN_RD_DATA CVMX_SLI_WIN_RD_DATA_FUNC()
 static inline uint64_t CVMX_SLI_WIN_RD_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
-		cvmx_warn("CVMX_SLI_WIN_RD_DATA not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000040ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020040ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_WIN_RD_DATA not supported on this chip\n");
 	return 0x0000000000000040ull;
 }
 #else
-#define CVMX_SLI_WIN_RD_DATA (0x0000000000000040ull)
+#define CVMX_SLI_WIN_RD_DATA CVMX_SLI_WIN_RD_DATA_FUNC()
+static inline uint64_t CVMX_SLI_WIN_RD_DATA_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000040ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020040ull;
+	}
+	return 0x0000000000000040ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_WIN_WR_ADDR CVMX_SLI_WIN_WR_ADDR_FUNC()
 static inline uint64_t CVMX_SLI_WIN_WR_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
-		cvmx_warn("CVMX_SLI_WIN_WR_ADDR not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_WIN_WR_ADDR not supported on this chip\n");
 	return 0x0000000000000000ull;
 }
 #else
-#define CVMX_SLI_WIN_WR_ADDR (0x0000000000000000ull)
+#define CVMX_SLI_WIN_WR_ADDR CVMX_SLI_WIN_WR_ADDR_FUNC()
+static inline uint64_t CVMX_SLI_WIN_WR_ADDR_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020000ull;
+	}
+	return 0x0000000000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_WIN_WR_DATA CVMX_SLI_WIN_WR_DATA_FUNC()
 static inline uint64_t CVMX_SLI_WIN_WR_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
-		cvmx_warn("CVMX_SLI_WIN_WR_DATA not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000020ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020020ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_WIN_WR_DATA not supported on this chip\n");
 	return 0x0000000000000020ull;
 }
 #else
-#define CVMX_SLI_WIN_WR_DATA (0x0000000000000020ull)
+#define CVMX_SLI_WIN_WR_DATA CVMX_SLI_WIN_WR_DATA_FUNC()
+static inline uint64_t CVMX_SLI_WIN_WR_DATA_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000020ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020020ull;
+	}
+	return 0x0000000000000020ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_WIN_WR_MASK CVMX_SLI_WIN_WR_MASK_FUNC()
 static inline uint64_t CVMX_SLI_WIN_WR_MASK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
-		cvmx_warn("CVMX_SLI_WIN_WR_MASK not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000030ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020030ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_WIN_WR_MASK not supported on this chip\n");
 	return 0x0000000000000030ull;
 }
 #else
-#define CVMX_SLI_WIN_WR_MASK (0x0000000000000030ull)
+#define CVMX_SLI_WIN_WR_MASK CVMX_SLI_WIN_WR_MASK_FUNC()
+static inline uint64_t CVMX_SLI_WIN_WR_MASK_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000000030ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020030ull;
+	}
+	return 0x0000000000000030ull;
+}
 #endif
 
 /**
@@ -1674,6 +2179,7 @@ union cvmx_sli_bist_status {
 #endif
 	} cn70xx;
 	struct cvmx_sli_bist_status_cn70xx    cn70xxp1;
+	struct cvmx_sli_bist_status_s         cn73xx;
 	struct cvmx_sli_bist_status_s         cn78xx;
 	struct cvmx_sli_bist_status_cn61xx    cnf71xx;
 };
@@ -1752,9 +2258,67 @@ union cvmx_sli_ctl_portx {
 	struct cvmx_sli_ctl_portx_s           cn66xx;
 	struct cvmx_sli_ctl_portx_s           cn68xx;
 	struct cvmx_sli_ctl_portx_s           cn68xxp1;
-	struct cvmx_sli_ctl_portx_s           cn70xx;
-	struct cvmx_sli_ctl_portx_s           cn70xxp1;
-	struct cvmx_sli_ctl_portx_cn78xx {
+	struct cvmx_sli_ctl_portx_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_22_63               : 42;
+	uint64_t intd                         : 1;  /**< When '0' Intd wire asserted. Before mapping. */
+	uint64_t intc                         : 1;  /**< When '0' Intc wire asserted. Before mapping. */
+	uint64_t intb                         : 1;  /**< When '0' Intb wire asserted. Before mapping. */
+	uint64_t inta                         : 1;  /**< When '0' Inta wire asserted. Before mapping. */
+	uint64_t dis_port                     : 1;  /**< When set the output to the MAC is disabled. This
+                                                         occurs when the MAC reset line transitions from
+                                                         de-asserted to asserted. Writing a '1' to this
+                                                         location will clear this condition when the MAC is
+                                                         no longer in reset and the output to the MAC is at
+                                                         the begining of a transfer. */
+	uint64_t waitl_com                    : 1;  /**< When set '1' casues the SLI to wait for a commit
+                                                         from the L2C before sending additional completions
+                                                         to the L2C from a MAC.
+                                                         Set this for more conservative behavior. Clear
+                                                         this for more aggressive, higher-performance
+                                                         behavior */
+	uint64_t intd_map                     : 2;  /**< Maps INTD to INTA(00), INTB(01), INTC(10) or
+                                                         INTD (11). */
+	uint64_t intc_map                     : 2;  /**< Maps INTC to INTA(00), INTB(01), INTC(10) or
+                                                         INTD (11). */
+	uint64_t intb_map                     : 2;  /**< Maps INTB to INTA(00), INTB(01), INTC(10) or
+                                                         INTD (11). */
+	uint64_t inta_map                     : 2;  /**< Maps INTA to INTA(00), INTB(01), INTC(10) or
+                                                         INTD (11). */
+	uint64_t ctlp_ro                      : 1;  /**< Relaxed ordering enable for Completion TLPS. */
+	uint64_t reserved_6_6                 : 1;
+	uint64_t ptlp_ro                      : 1;  /**< Relaxed ordering enable for Posted TLPS. */
+	uint64_t reserved_4_1                 : 4;
+	uint64_t wait_com                     : 1;  /**< When set '1' casues the SLI to wait for a commit
+                                                         from the L2C before sending additional stores to
+                                                         the L2C from a MAC.
+                                                         The SLI will request a commit on the last store
+                                                         if more than one STORE operation is required on
+                                                         the NCB.
+                                                         Most applications will not notice a difference, so
+                                                         should not set this bit. Setting the bit is more
+                                                         conservative on ordering, lower performance */
+#else
+	uint64_t wait_com                     : 1;
+	uint64_t reserved_4_1                 : 4;
+	uint64_t ptlp_ro                      : 1;
+	uint64_t reserved_6_6                 : 1;
+	uint64_t ctlp_ro                      : 1;
+	uint64_t inta_map                     : 2;
+	uint64_t intb_map                     : 2;
+	uint64_t intc_map                     : 2;
+	uint64_t intd_map                     : 2;
+	uint64_t waitl_com                    : 1;
+	uint64_t dis_port                     : 1;
+	uint64_t inta                         : 1;
+	uint64_t intb                         : 1;
+	uint64_t intc                         : 1;
+	uint64_t intd                         : 1;
+	uint64_t reserved_22_63               : 42;
+#endif
+	} cn70xx;
+	struct cvmx_sli_ctl_portx_cn70xx      cn70xxp1;
+	struct cvmx_sli_ctl_portx_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t dis_port                     : 1;  /**< When set, the output to the MAC is disabled. This occurs when the MAC reset line
@@ -1786,7 +2350,8 @@ union cvmx_sli_ctl_portx {
 	uint64_t dis_port                     : 1;
 	uint64_t reserved_18_63               : 46;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_ctl_portx_cn73xx      cn78xx;
 	struct cvmx_sli_ctl_portx_s           cnf71xx;
 };
 typedef union cvmx_sli_ctl_portx cvmx_sli_ctl_portx_t;
@@ -1879,6 +2444,7 @@ union cvmx_sli_ctl_status {
 	struct cvmx_sli_ctl_status_cn63xx     cn68xxp1;
 	struct cvmx_sli_ctl_status_cn63xx     cn70xx;
 	struct cvmx_sli_ctl_status_cn63xx     cn70xxp1;
+	struct cvmx_sli_ctl_status_s          cn73xx;
 	struct cvmx_sli_ctl_status_s          cn78xx;
 	struct cvmx_sli_ctl_status_cn61xx     cnf71xx;
 };
@@ -1923,6 +2489,7 @@ union cvmx_sli_data_out_cnt {
 	struct cvmx_sli_data_out_cnt_s        cn68xxp1;
 	struct cvmx_sli_data_out_cnt_s        cn70xx;
 	struct cvmx_sli_data_out_cnt_s        cn70xxp1;
+	struct cvmx_sli_data_out_cnt_s        cn73xx;
 	struct cvmx_sli_data_out_cnt_s        cn78xx;
 	struct cvmx_sli_data_out_cnt_s        cnf71xx;
 };
@@ -2034,6 +2601,7 @@ union cvmx_sli_dmax_cnt {
 	struct cvmx_sli_dmax_cnt_s            cn68xxp1;
 	struct cvmx_sli_dmax_cnt_s            cn70xx;
 	struct cvmx_sli_dmax_cnt_s            cn70xxp1;
+	struct cvmx_sli_dmax_cnt_s            cn73xx;
 	struct cvmx_sli_dmax_cnt_s            cn78xx;
 	struct cvmx_sli_dmax_cnt_s            cnf71xx;
 };
@@ -2070,6 +2638,7 @@ union cvmx_sli_dmax_int_level {
 	struct cvmx_sli_dmax_int_level_s      cn68xxp1;
 	struct cvmx_sli_dmax_int_level_s      cn70xx;
 	struct cvmx_sli_dmax_int_level_s      cn70xxp1;
+	struct cvmx_sli_dmax_int_level_s      cn73xx;
 	struct cvmx_sli_dmax_int_level_s      cn78xx;
 	struct cvmx_sli_dmax_int_level_s      cnf71xx;
 };
@@ -2102,6 +2671,7 @@ union cvmx_sli_dmax_tim {
 	struct cvmx_sli_dmax_tim_s            cn68xxp1;
 	struct cvmx_sli_dmax_tim_s            cn70xx;
 	struct cvmx_sli_dmax_tim_s            cn70xxp1;
+	struct cvmx_sli_dmax_tim_s            cn73xx;
 	struct cvmx_sli_dmax_tim_s            cn78xx;
 	struct cvmx_sli_dmax_tim_s            cnf71xx;
 };
@@ -2536,7 +3106,7 @@ union cvmx_sli_int_enb_ciu {
 	struct cvmx_sli_int_enb_ciu_cn68xx    cn68xxp1;
 	struct cvmx_sli_int_enb_ciu_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_61_63               : 3;
+	uint64_t reserved_63_61               : 3;
 	uint64_t ill_pad                      : 1;  /**< Illegal packet csr address. */
 	uint64_t sprt3_err                    : 1;  /**< Error Response received on SLI port 3. */
 	uint64_t sprt2_err                    : 1;  /**< Error Response received on SLI port 2. */
@@ -2550,11 +3120,11 @@ union cvmx_sli_int_enb_ciu {
 	uint64_t pout_err                     : 1;  /**< Packet Out Interrupt, Error From PKO. */
 	uint64_t psldbof                      : 1;  /**< Packet Scatterlist Doorbell Count Overflow. */
 	uint64_t pidbof                       : 1;  /**< Packet Instruction Doorbell Count Overflow. */
-	uint64_t reserved_38_47               : 10;
+	uint64_t reserved_47_38               : 10;
 	uint64_t dtime                        : 2;  /**< DMA Timer Interrupts */
 	uint64_t dcnt                         : 2;  /**< DMA Count Interrupts */
 	uint64_t dmafi                        : 2;  /**< DMA set Forced Interrupts */
-	uint64_t reserved_29_31               : 3;
+	uint64_t reserved_31_29               : 3;
 	uint64_t mio_int2                     : 1;  /**< Enables SLI_INT_SUM[28] to generate an
                                                          interrupt on the RSL.
                                                          THIS SHOULD NEVER BE SET */
@@ -2570,7 +3140,7 @@ union cvmx_sli_int_enb_ciu {
                                                          interrupt on the RSL. */
 	uint64_t m2_up_b0                     : 1;  /**< Enables SLI_INT_SUM[20] to generate an
                                                          interrupt on the RSL. */
-	uint64_t reserved_18_19               : 2;
+	uint64_t reserved_19_18               : 2;
 	uint64_t mio_int1                     : 1;  /**< Enables SLI_INT_SUM[17] to generate an
                                                          interrupt on the RSL.
                                                          THIS SHOULD NEVER BE SET */
@@ -2593,7 +3163,7 @@ union cvmx_sli_int_enb_ciu {
                                                          interrupt on the RSL. */
 	uint64_t m0_up_b0                     : 1;  /**< Enables SLI_INT_SUM[8] to generate an
                                                          interrupt on the RSL. */
-	uint64_t reserved_6_7                 : 2;
+	uint64_t reserved_7_6                 : 2;
 	uint64_t ptime                        : 1;  /**< Enables SLI_INT_SUM[5] to generate an
                                                          interrupt on the RSL. */
 	uint64_t pcnt                         : 1;  /**< Enables SLI_INT_SUM[4] to generate an
@@ -2612,7 +3182,7 @@ union cvmx_sli_int_enb_ciu {
 	uint64_t iob2big                      : 1;
 	uint64_t pcnt                         : 1;
 	uint64_t ptime                        : 1;
-	uint64_t reserved_6_7                 : 2;
+	uint64_t reserved_7_6                 : 2;
 	uint64_t m0_up_b0                     : 1;
 	uint64_t m0_up_wi                     : 1;
 	uint64_t m0_un_b0                     : 1;
@@ -2623,7 +3193,7 @@ union cvmx_sli_int_enb_ciu {
 	uint64_t m1_un_wi                     : 1;
 	uint64_t mio_int0                     : 1;
 	uint64_t mio_int1                     : 1;
-	uint64_t reserved_18_19               : 2;
+	uint64_t reserved_19_18               : 2;
 	uint64_t m2_up_b0                     : 1;
 	uint64_t m2_up_wi                     : 1;
 	uint64_t m2_un_b0                     : 1;
@@ -2633,11 +3203,11 @@ union cvmx_sli_int_enb_ciu {
 	uint64_t m3_un_b0                     : 1;
 	uint64_t m3_un_wi                     : 1;
 	uint64_t mio_int2                     : 1;
-	uint64_t reserved_29_31               : 3;
+	uint64_t reserved_31_29               : 3;
 	uint64_t dmafi                        : 2;
 	uint64_t dcnt                         : 2;
 	uint64_t dtime                        : 2;
-	uint64_t reserved_38_47               : 10;
+	uint64_t reserved_47_38               : 10;
 	uint64_t pidbof                       : 1;
 	uint64_t psldbof                      : 1;
 	uint64_t pout_err                     : 1;
@@ -2651,7 +3221,7 @@ union cvmx_sli_int_enb_ciu {
 	uint64_t sprt2_err                    : 1;
 	uint64_t sprt3_err                    : 1;
 	uint64_t ill_pad                      : 1;
-	uint64_t reserved_61_63               : 3;
+	uint64_t reserved_63_61               : 3;
 #endif
 	} cn70xx;
 	struct cvmx_sli_int_enb_ciu_cn70xx    cn70xxp1;
@@ -2732,7 +3302,8 @@ union cvmx_sli_int_enb_portx {
                                                          interrupt to the PCIE core for MSI/inta. */
 	uint64_t m0_up_b0                     : 1;  /**< Enables SLI_INT_SUM[8] to generate an
                                                          interrupt to the PCIE core for MSI/inta. */
-	uint64_t mio_int3                     : 1;  /**< Enables SLI_INT_SUM[MIO_INT3] to generate an interrupt to the MAC core for MSI/INTA. */
+	uint64_t mio_int3                     : 1;  /**< Enables SLI_INT_SUM[MIO_INT3] to generate an interrupt to the MAC core for MSI/INTA.
+                                                         MIO_INT3 should only be set in SLI_INT_ENB_PORT3. */
 	uint64_t reserved_6_6                 : 1;
 	uint64_t ptime                        : 1;  /**< Enables SLI_INT_SUM[5] to generate an
                                                          interrupt to the PCIE core for MSI/inta. */
@@ -3129,7 +3700,7 @@ union cvmx_sli_int_enb_portx {
 	struct cvmx_sli_int_enb_portx_cn68xx  cn68xxp1;
 	struct cvmx_sli_int_enb_portx_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_61_63               : 3;
+	uint64_t reserved_63_61               : 3;
 	uint64_t ill_pad                      : 1;  /**< Illegal packet csr address. */
 	uint64_t sprt3_err                    : 1;  /**< Error Response received on SLI port 3. */
 	uint64_t sprt2_err                    : 1;  /**< Error Response received on SLI port 2. */
@@ -3143,11 +3714,11 @@ union cvmx_sli_int_enb_portx {
 	uint64_t pout_err                     : 1;  /**< Packet Out Interrupt, Error From PKO. */
 	uint64_t psldbof                      : 1;  /**< Packet Scatterlist Doorbell Count Overflow. */
 	uint64_t pidbof                       : 1;  /**< Packet Instruction Doorbell Count Overflow. */
-	uint64_t reserved_38_47               : 10;
+	uint64_t reserved_47_38               : 10;
 	uint64_t dtime                        : 2;  /**< DMA Timer Interrupts */
 	uint64_t dcnt                         : 2;  /**< DMA Count Interrupts */
 	uint64_t dmafi                        : 2;  /**< DMA set Forced Interrupts */
-	uint64_t reserved_30_31               : 2;
+	uint64_t reserved_31_30               : 2;
 	uint64_t mac2_int                     : 1;  /**< Enables SLI_INT_SUM[29] to generate an
                                                          interrupt to the PCIE-Port2 for MSI/inta.
                                                          SLI_INT_ENB_PORT2[MAC0_INT] sould NEVER be set.
@@ -3197,7 +3768,7 @@ union cvmx_sli_int_enb_portx {
                                                          interrupt to the PCIE core for MSI/inta. */
 	uint64_t m0_up_b0                     : 1;  /**< Enables SLI_INT_SUM[8] to generate an
                                                          interrupt to the PCIE core for MSI/inta. */
-	uint64_t reserved_6_7                 : 2;
+	uint64_t reserved_7_6                 : 2;
 	uint64_t ptime                        : 1;  /**< Enables SLI_INT_SUM[5] to generate an
                                                          interrupt to the PCIE core for MSI/inta. */
 	uint64_t pcnt                         : 1;  /**< Enables SLI_INT_SUM[4] to generate an
@@ -3216,7 +3787,7 @@ union cvmx_sli_int_enb_portx {
 	uint64_t iob2big                      : 1;
 	uint64_t pcnt                         : 1;
 	uint64_t ptime                        : 1;
-	uint64_t reserved_6_7                 : 2;
+	uint64_t reserved_7_6                 : 2;
 	uint64_t m0_up_b0                     : 1;
 	uint64_t m0_up_wi                     : 1;
 	uint64_t m0_un_b0                     : 1;
@@ -3239,11 +3810,11 @@ union cvmx_sli_int_enb_portx {
 	uint64_t m3_un_wi                     : 1;
 	uint64_t mio_int2                     : 1;
 	uint64_t mac2_int                     : 1;
-	uint64_t reserved_30_31               : 2;
+	uint64_t reserved_31_30               : 2;
 	uint64_t dmafi                        : 2;
 	uint64_t dcnt                         : 2;
 	uint64_t dtime                        : 2;
-	uint64_t reserved_38_47               : 10;
+	uint64_t reserved_47_38               : 10;
 	uint64_t pidbof                       : 1;
 	uint64_t psldbof                      : 1;
 	uint64_t pout_err                     : 1;
@@ -3257,11 +3828,11 @@ union cvmx_sli_int_enb_portx {
 	uint64_t sprt2_err                    : 1;
 	uint64_t sprt3_err                    : 1;
 	uint64_t ill_pad                      : 1;
-	uint64_t reserved_61_63               : 3;
+	uint64_t reserved_63_61               : 3;
 #endif
 	} cn70xx;
 	struct cvmx_sli_int_enb_portx_cn70xx  cn70xxp1;
-	struct cvmx_sli_int_enb_portx_cn78xx {
+	struct cvmx_sli_int_enb_portx_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t sprt3_err                    : 1;  /**< Enables SLI_INT_SUM[SPRT3_ERR] to generate an interrupt to the MAC core for MSI/INTA. */
@@ -3291,9 +3862,9 @@ union cvmx_sli_int_enb_portx {
 	uint64_t m2_up_b0                     : 1;  /**< Enables SLI_INT_SUM[M2_UP_B0] to generate an interrupt to the MAC core for MSI/INTA. */
 	uint64_t reserved_18_19               : 2;
 	uint64_t mio_int1                     : 1;  /**< Enables SLI_INT_SUM[MIO_INT1] to generate an interrupt to the MAC core for MSI/INTA.
-                                                         SLI_INT_ENB_PORT0[MIO_INT1] should never be set. */
+                                                         MIO_INT1 should only be set in SLI_INT_ENB_PORT1. */
 	uint64_t mio_int0                     : 1;  /**< Enables SLI_INT_SUM[MIO_INT0] to generate an interrupt to the MAC core for MSI/INTA.
-                                                         SLI_INT_ENB_PORT1[MIO_INT0] should never be set. */
+                                                         MIO_INT0 should only be set in SLI_INT_ENB_PORT0. */
 	uint64_t m1_un_wi                     : 1;  /**< Enables SLI_INT_SUM[M1_UN_WI] to generate an interrupt to the MAC core for MSI/INTA. */
 	uint64_t m1_un_b0                     : 1;  /**< Enables SLI_INT_SUM[M1_UN_B0] to generate an interrupt to the MAC core for MSI/INTA. */
 	uint64_t m1_up_wi                     : 1;  /**< Enables SLI_INT_SUM[M1_UP_WI] to generate an interrupt to the MAC core for MSI/INTA. */
@@ -3302,8 +3873,10 @@ union cvmx_sli_int_enb_portx {
 	uint64_t m0_un_b0                     : 1;  /**< Enables SLI_INT_SUM[M0_UN_B0] to generate an interrupt to the MAC core for MSI/INTA. */
 	uint64_t m0_up_wi                     : 1;  /**< Enables SLI_INT_SUM[M0_UP_WI] to generate an interrupt to the MAC core for MSI/INTA. */
 	uint64_t m0_up_b0                     : 1;  /**< Enables SLI_INT_SUM[M0_UP_B0] to generate an interrupt to the MAC core for MSI/INTA. */
-	uint64_t mio_int3                     : 1;  /**< Enables SLI_INT_SUM[MIO_INT3] to generate an interrupt to the MAC core for MSI/INTA. */
-	uint64_t mio_int2                     : 1;  /**< Enables SLI_INT_SUM[MIO_INT2] to generate an interrupt to the MAC core for MSI/INTA. */
+	uint64_t mio_int3                     : 1;  /**< Enables SLI_INT_SUM[MIO_INT3] to generate an interrupt to the MAC core for MSI/INTA.
+                                                         MIO_INT3 should only be set in SLI_INT_ENB_PORT3. */
+	uint64_t mio_int2                     : 1;  /**< Enables SLI_INT_SUM[MIO_INT2] to generate an interrupt to the MAC core for MSI/INTA.
+                                                         MIO_INT2 should only be set in SLI_INT_ENB_PORT2. */
 	uint64_t ptime                        : 1;  /**< Enables SLI_INT_SUM[PTIME] to generate an interrupt to the MAC core for MSI/INTA. */
 	uint64_t pcnt                         : 1;  /**< Enables SLI_INT_SUM[PCNT] to generate an interrupt to the PCIE core for MSI/INTA. */
 	uint64_t reserved_1_3                 : 3;
@@ -3353,7 +3926,8 @@ union cvmx_sli_int_enb_portx {
 	uint64_t sprt3_err                    : 1;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_int_enb_portx_cn73xx  cn78xx;
 	struct cvmx_sli_int_enb_portx_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_int_enb_portx cvmx_sli_int_enb_portx_t;
@@ -3362,7 +3936,8 @@ typedef union cvmx_sli_int_enb_portx cvmx_sli_int_enb_portx_t;
  * cvmx_sli_int_sum
  *
  * The fields in this register are set when an interrupt condition occurs; write 1 to clear. All
- * fields of the CSR are valid when a PF reads the CSR. Not available to VF's, and writes by the
+ * fields of the register are valid when a PF reads the register. Not available to VF's, and
+ * writes by the
  * VF do not modify the register.
  */
 union cvmx_sli_int_sum {
@@ -3456,7 +4031,8 @@ union cvmx_sli_int_sum {
 	uint64_t m0_up_b0                     : 1;  /**< Received Unsupported P-TLP for Bar0 from MAC 0.
                                                          This occurs when the BAR 0 address space is
                                                          disabeled. */
-	uint64_t mio_int3                     : 1;  /**< Interrupt from MIO for Port 3. Throws SLI_INTSN_E::SLI_INT_MIO_INT3. */
+	uint64_t mio_int3                     : 1;  /**< CIU interrupt output for MAC 3. A copy of CIU3_DEST(x)_IO_INT[INTR],
+                                                         where x=CIU_DEST_IO_E::PEM(3) (i.e. x=4). */
 	uint64_t reserved_6_6                 : 1;
 	uint64_t ptime                        : 1;  /**< Packet Timer has an interrupt. Which rings can
                                                          be found in SLI_PKT_TIME_INT. */
@@ -4086,30 +4662,56 @@ union cvmx_sli_int_sum {
 #endif
 	} cn70xx;
 	struct cvmx_sli_int_sum_cn70xx        cn70xxp1;
-	struct cvmx_sli_int_sum_cn78xx {
+	struct cvmx_sli_int_sum_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
-	uint64_t sprt3_err                    : 1;  /**< SLI port 3 error. When an error response is received on SLI port 3, this bit is set.
+	uint64_t sprt3_err                    : 1;  /**< SLI/DPI sets [SPRT3_ERR] when it receives an error response on a completion for a
+                                                         transaction mastered by DPI from MAC3/FPORT=3. When MAC3 is PEM3 (PCIe),
+                                                         the error response may be due to a UR or CA completion, or a timeout. DPI
+                                                         masters all transactions created to service all of DPI Instruction (packet) input,
+                                                         DPI packet output, and DPI DMA Instructions.
                                                          Throws SLI_INTSN_E::SLI_INT_SPRT3_ERR. */
-	uint64_t sprt2_err                    : 1;  /**< SLI port 2 error. When an error response is received on SLI port 2, this bit is set.
+	uint64_t sprt2_err                    : 1;  /**< SLI/DPI sets [SPRT2_ERR] when it receives an error response on a completion for a
+                                                         read mastered by DPI from MAC2/FPORT=2. When MAC2 is PEM2 (PCIe),
+                                                         the error response may be due to a UR or CA completion, or a timeout. DPI
+                                                         masters all transactions created to service all of DPI Instruction (packet) input,
+                                                         DPI packet output, and DPI DMA Instructions.
                                                          Throws SLI_INTSN_E::SLI_INT_SPRT2_ERR. */
-	uint64_t sprt1_err                    : 1;  /**< SLI port 1 error. When an error response is received on SLI port 1, this bit is set.
+	uint64_t sprt1_err                    : 1;  /**< SLI/DPI sets [SPRT1_ERR] when it receives an error response on a completion for a
+                                                         read mastered by DPI from MAC1/FPORT=1. When MAC1 is PEM1 (PCIe),
+                                                         the error response may be due to a UR or CA completion, or a timeout. DPI
+                                                         masters all transactions created to service all of DPI Instruction (packet) input,
+                                                         DPI packet output, and DPI DMA Instructions.
                                                          Throws SLI_INTSN_E::SLI_INT_SPRT1_ERR. */
-	uint64_t sprt0_err                    : 1;  /**< SLI port 0 error. When an error response is received on SLI port 0, this bit is set.
+	uint64_t sprt0_err                    : 1;  /**< SLI/DPI sets [SPRT0_ERR] when it receives an error response on a completion for a
+                                                         read mastered by DPI from MAC0/FPORT=0. When MAC0 is PEM0 (PCIe),
+                                                         the error response may be due to a UR or CA completion, or a timeout. DPI
+                                                         masters all transactions created to service all of DPI Instruction (packet) input,
+                                                         DPI packet output, and DPI DMA Instructions.
                                                          Throws SLI_INTSN_E::SLI_INT_SPRT0_ERR. */
-	uint64_t pins_err                     : 1;  /**< Packet instruction read error. When a read error occurs on a packet instruction, this bit
-                                                         is set. Throws SLI_INTSN_E::SLI_INT_PINS_ERR. */
-	uint64_t pop_err                      : 1;  /**< Packet scatter pointer pair error. When a read error occurs on a packet scatter pointer
-                                                         pair, this bit is set. Throws SLI_INTSN_E::SLI_INT_POP_ERR. */
-	uint64_t pdi_err                      : 1;  /**< Packet data read error. When a read error occurs on a packet data read, this bit is set.
+	uint64_t pins_err                     : 1;  /**< Packet instruction read error. SLI/DPI sets [PINS_ERR] when it receives an error
+                                                         response to a DPI Instruction (packet) input instruction read. Whenever
+                                                         SLI/DPI sets [PINS_ERR], it also will have set one of [SPRT*_ERR].
+                                                         Throws SLI_INTSN_E::SLI_INT_PINS_ERR. */
+	uint64_t pop_err                      : 1;  /**< Packet pointer pair error. SLI/DPI sets [POP_ERR] when it receives
+                                                         an error response on a DPI packet output buffer/info pointer pair read.
+                                                         Whenever SLI/DPI sets [POP_ERR], it also will have set one of [SPRT*_ERR].
+                                                         Throws SLI_INTSN_E::SLI_INT_POP_ERR. */
+	uint64_t pdi_err                      : 1;  /**< Packet data read error. SLI/DPI sets [PDI_ERR] when it receives an error
+                                                         response to a DPI Instruction (packet) input packet data read. Whenever
+                                                         SLI/DPI sets [PDI_ERR], it also will have set one of [SPRT*_ERR].
                                                          Throws SLI_INTSN_E::SLI_INT_PDI_ERR. */
-	uint64_t pgl_err                      : 1;  /**< Packet gather list read error. When a read error occurs on a packet gather list read, this
-                                                         bit is set. Throws SLI_INTSN_E::SLI_INT_PGL_ERR. */
+	uint64_t pgl_err                      : 1;  /**< Packet gather list read error. SLI/DPI sets [PDI_ERR] when it receives an error
+                                                         response to a DPI Instruction (packet) input indirect gather list read. Whenever
+                                                         SLI/DPI sets [PGL_ERR], it also will have set one of [SPRT*_ERR].
+                                                         Throws SLI_INTSN_E::SLI_INT_PGL_ERR. */
 	uint64_t reserved_50_51               : 2;
-	uint64_t psldbof                      : 1;  /**< Packet scatter list doorbell count overflowed. Which doorbell can be found in
-                                                         DPI_PINT_INFO[PSLDBOF]. Throws SLI_INTSN_E::SLI_INT_PSLDBOF. */
-	uint64_t pidbof                       : 1;  /**< Packet instruction doorbell count overflowed. Which doorbell can be found in
-                                                         DPI_PINT_INFO[PIDBOF]. Throws SLI_INTSN_E::SLI_INT_PIDBOF. */
+	uint64_t psldbof                      : 1;  /**< Packet output doorbell count overflowed. SLI/DPI sets [PSLDBOF]
+                                                         whenever a DPI packet output doorbell overflows.
+                                                         Throws SLI_INTSN_E::SLI_INT_PSLDBOF. */
+	uint64_t pidbof                       : 1;  /**< Packet instruction input doorbell count overflowed. SLI/DPI sets
+                                                         [PIDBOF] whenever a DPI Instruction (packet) input doorbell overflows.
+                                                         Throws SLI_INTSN_E::SLI_INT_PIDBOF. */
 	uint64_t reserved_38_47               : 10;
 	uint64_t dtime                        : 2;  /**< Whenever SLI_DMA()_CNT[CNT] is not 0, the SLI_DMA()_TIM[TIM] timer increments
                                                          every SLI clock. DTIME<x> is set whenever SLI_DMA()_TIM[TIM] >
@@ -4118,9 +4720,13 @@ union cvmx_sli_int_sum {
                                                          SLI_INTSN_E::SLI_INT_DTIME0/1. */
 	uint64_t dcnt                         : 2;  /**< DCNT<x> is set whenever SLI_DMAx_CNT[CNT] > SLI_DMA()_INT_LEVEL[CNT]. DCNT<x> is
                                                          normally cleared by decreasing SLI_DMA()_CNT[CNT]. Throws SLI_INTSN_E::SLI_INT_DCNT0/1. */
-	uint64_t dmafi                        : 2;  /**< DMA set forced interrupts. Throws SLI_INTSN_E::SLI_INT_DMAFI0/1. */
+	uint64_t dmafi                        : 2;  /**< DMA set forced interrupts. Set by SLI/DPI after completing a DPI DMA
+                                                         Instruction with DPI_DMA_INSTR_HDR_S[FI] set.
+                                                         Throws SLI_INTSN_E::SLI_INT_DMAFI0/1. */
 	uint64_t reserved_29_31               : 3;
-	uint64_t vf_err                       : 1;  /**< Illegal access from VF. Throws SLI_INTSN_E::SLI_INT_VF_ERR. */
+	uint64_t vf_err                       : 1;  /**< Illegal BAR0 access from a virtual function. SLI/DPI may set [VF_ERR] whenever a
+                                                         virtual function accesses a VF BAR0 address/CSR that it shouldn't have.
+                                                         Throws SLI_INTSN_E::SLI_INT_VF_ERR. */
 	uint64_t m3_un_wi                     : 1;  /**< Received unsupported N-TLP for window register from MAC 3. This occurs when the window
                                                          registers are disabled and a window register access occurs. Throws
                                                          SLI_INTSN_E::SLI_INT_M3_UN_WI. */
@@ -4142,8 +4748,10 @@ union cvmx_sli_int_sum {
 	uint64_t m2_up_b0                     : 1;  /**< Received unsupported P-TLP for Bar0 from MAC 2. This occurs when the BAR 0 address space
                                                          is disabled. Throws SLI_INTSN_E::SLI_INT_M2_UP_B0. */
 	uint64_t reserved_18_19               : 2;
-	uint64_t mio_int1                     : 1;  /**< Interrupt from MIO for PORT 1. Throws SLI_INTSN_E::SLI_INT_MIO_INT1. */
-	uint64_t mio_int0                     : 1;  /**< Interrupt from MIO for PORT 0. Throws SLI_INTSN_E::SLI_INT_MIO_INT0. */
+	uint64_t mio_int1                     : 1;  /**< CIU interrupt output for MAC 1. A copy of CIU3_DEST(x)_IO_INT[INTR],
+                                                         where x=CIU_DEST_IO_E::PEM(1) (i.e. x=2). */
+	uint64_t mio_int0                     : 1;  /**< CIU interrupt output for MAC 0. A copy of CIU3_DEST(x)_IO_INT[INTR],
+                                                         where x=CIU_DEST_IO_E::PEM(0) (i.e. x=1). */
 	uint64_t m1_un_wi                     : 1;  /**< Received unsupported N-TLP for window register from MAC 1. This occurs when the window
                                                          registers are disabled and a window register access occurs. Throws
                                                          SLI_INTSN_E::SLI_INT_M1_UN_WI. */
@@ -4164,12 +4772,16 @@ union cvmx_sli_int_sum {
                                                          SLI_INTSN_E::SLI_INT_M0_UP_WI. */
 	uint64_t m0_up_b0                     : 1;  /**< Received unsupported P-TLP for Bar 0 from MAC 0. This occurs when the BAR 0 address space
                                                          is disabled. Throws SLI_INTSN_E::SLI_INT_M0_UP_B0. */
-	uint64_t mio_int3                     : 1;  /**< Interrupt from MIO for Port 3. Throws SLI_INTSN_E::SLI_INT_MIO_INT3. */
-	uint64_t mio_int2                     : 1;  /**< Interrupt from MIO for Port 2. Throws SLI_INTSN_E::SLI_INT_MIO_INT2. */
-	uint64_t ptime                        : 1;  /**< Packet timer has an interrupt. The specific rings can be found in SLI_PKT_TIME_INT. Throws
-                                                         SLI_INTSN_E::SLI_INT_PTIME. */
-	uint64_t pcnt                         : 1;  /**< Packet counter has an interrupt. The specific rings can be found in SLI_PKT_CNT_INT.
-                                                         Throws SLI_INTSN_E::SLI_INT_PCNT. */
+	uint64_t mio_int3                     : 1;  /**< CIU interrupt output for MAC 3. A copy of CIU3_DEST(x)_IO_INT[INTR],
+                                                         where x=CIU_DEST_IO_E::PEM(3) (i.e. x=4). */
+	uint64_t mio_int2                     : 1;  /**< CIU interrupt output for MAC 2. A copy of CIU3_DEST(x)_IO_INT[INTR],
+                                                         where x=CIU_DEST_IO_E::PEM(2) (i.e. x=3). */
+	uint64_t ptime                        : 1;  /**< Packet timer has an interrupt. Asserts if, for any i, both
+                                                         SLI_PKT_TIME_INT<i> and SLI_PKT(i)_OUTPUT_CONTROL[TENB] are set.
+                                                         [PTIME] assertion throws SLI_INTSN_E::SLI_INT_PTIME to CIU. */
+	uint64_t pcnt                         : 1;  /**< Packet counter has an interrupt. Asserts if, for any i, both
+                                                         SLI_PKT_CNT_INT<i> and SLI_PKT(i)_OUTPUT_CONTROL[CENB] are set.
+                                                         [PCNT] assertion throws SLI_INTSN_E::SLI_INT_PCNT to CIU. */
 	uint64_t reserved_1_3                 : 3;
 	uint64_t rml_to                       : 1;  /**< A read or write transfer to a RSL that did not complete within
                                                          SLI_WINDOW_CTL[TIME] coprocessor-clock cycles, or a notification from the CCPI
@@ -4221,7 +4833,8 @@ union cvmx_sli_int_sum {
 	uint64_t sprt3_err                    : 1;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_int_sum_cn73xx        cn78xx;
 	struct cvmx_sli_int_sum_cn61xx        cnf71xx;
 };
 typedef union cvmx_sli_int_sum cvmx_sli_int_sum_t;
@@ -4405,6 +5018,7 @@ union cvmx_sli_mac_credit_cnt {
 	struct cvmx_sli_mac_credit_cnt_s      cn68xxp1;
 	struct cvmx_sli_mac_credit_cnt_s      cn70xx;
 	struct cvmx_sli_mac_credit_cnt_s      cn70xxp1;
+	struct cvmx_sli_mac_credit_cnt_s      cn73xx;
 	struct cvmx_sli_mac_credit_cnt_s      cn78xx;
 	struct cvmx_sli_mac_credit_cnt_s      cnf71xx;
 };
@@ -4461,6 +5075,7 @@ union cvmx_sli_mac_credit_cnt2 {
 	struct cvmx_sli_mac_credit_cnt2_s     cn66xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cn70xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cn70xxp1;
+	struct cvmx_sli_mac_credit_cnt2_s     cn73xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cn78xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cnf71xx;
 };
@@ -4500,6 +5115,7 @@ union cvmx_sli_mac_number {
 	struct cvmx_sli_mac_number_cn63xx     cn68xxp1;
 	struct cvmx_sli_mac_number_s          cn70xx;
 	struct cvmx_sli_mac_number_s          cn70xxp1;
+	struct cvmx_sli_mac_number_s          cn73xx;
 	struct cvmx_sli_mac_number_s          cn78xx;
 	struct cvmx_sli_mac_number_s          cnf71xx;
 };
@@ -4538,6 +5154,7 @@ union cvmx_sli_mem_access_ctl {
 	struct cvmx_sli_mem_access_ctl_s      cn68xxp1;
 	struct cvmx_sli_mem_access_ctl_s      cn70xx;
 	struct cvmx_sli_mem_access_ctl_s      cn70xxp1;
+	struct cvmx_sli_mem_access_ctl_s      cn73xx;
 	struct cvmx_sli_mem_access_ctl_s      cn78xx;
 	struct cvmx_sli_mem_access_ctl_s      cnf71xx;
 };
@@ -4553,7 +5170,9 @@ union cvmx_sli_mem_access_subidx {
 	uint64_t u64;
 	struct cvmx_sli_mem_access_subidx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_43_63               : 21;
+	uint64_t reserved_60_63               : 4;
+	uint64_t pvf                          : 16; /**< Virtual function. */
+	uint64_t reserved_43_43               : 1;
 	uint64_t zero                         : 1;  /**< Causes all byte reads to be zero length reads.
                                                          Returns to the EXEC a zero for all read data.
                                                          This must be zero for sRIO ports. */
@@ -4591,7 +5210,9 @@ union cvmx_sli_mem_access_subidx {
 	uint64_t nmerge                       : 1;
 	uint64_t port                         : 3;
 	uint64_t zero                         : 1;
-	uint64_t reserved_43_63               : 21;
+	uint64_t reserved_43_43               : 1;
+	uint64_t pvf                          : 16;
+	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
 	struct cvmx_sli_mem_access_subidx_cn61xx {
@@ -4684,6 +5305,40 @@ union cvmx_sli_mem_access_subidx {
 	struct cvmx_sli_mem_access_subidx_cn68xx cn68xxp1;
 	struct cvmx_sli_mem_access_subidx_cn61xx cn70xx;
 	struct cvmx_sli_mem_access_subidx_cn61xx cn70xxp1;
+	struct cvmx_sli_mem_access_subidx_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t pvf                          : 16; /**< Virtual function. */
+	uint64_t reserved_43_43               : 1;
+	uint64_t zero                         : 1;  /**< Causes all byte read operations to be zero-length read operations. Returns 0s to the EXEC
+                                                         for all read data. */
+	uint64_t port                         : 3;  /**< The MAC that reads/writes to this subid are sent. */
+	uint64_t nmerge                       : 1;  /**< When set, no merging is allowed in this window. */
+	uint64_t esr                          : 2;  /**< Endian swap for read operations. ES<1:0> for read operations to this subID. ES<1:0> is the
+                                                         endian-swap attribute for these MAC memory space read operations. */
+	uint64_t esw                          : 2;  /**< Endian swap for write operations. ES<1:0> for write operations to this subID. ES<1:0> is
+                                                         the endian-swap attribute for these MAC memory space write operations. */
+	uint64_t wtype                        : 2;  /**< Write type. ADDRTYPE<1:0> for write operations to this subID.
+                                                         * ADDRTYPE<0> is the relaxed-order attribute.
+                                                         * ADDRTYPE<1> is the no-snoop attribute. */
+	uint64_t rtype                        : 2;  /**< Read type. ADDRTYPE<1:0> for read operations to this subID.
+                                                         * ADDRTYPE<0> is the relaxed-order attribute.
+                                                         * ADDRTYPE<1> is the no-snoop attribute. */
+	uint64_t ba                           : 30; /**< Bus address. Address bits<63:34> for read/write operations that use this subID. */
+#else
+	uint64_t ba                           : 30;
+	uint64_t rtype                        : 2;
+	uint64_t wtype                        : 2;
+	uint64_t esw                          : 2;
+	uint64_t esr                          : 2;
+	uint64_t nmerge                       : 1;
+	uint64_t port                         : 3;
+	uint64_t zero                         : 1;
+	uint64_t reserved_43_43               : 1;
+	uint64_t pvf                          : 16;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} cn73xx;
 	struct cvmx_sli_mem_access_subidx_cn61xx cn78xx;
 	struct cvmx_sli_mem_access_subidx_cn61xx cnf71xx;
 };
@@ -4740,6 +5395,7 @@ union cvmx_sli_mem_ctl {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_sli_mem_ctl_s             cn73xx;
 	struct cvmx_sli_mem_ctl_s             cn78xx;
 };
 typedef union cvmx_sli_mem_ctl cvmx_sli_mem_ctl_t;
@@ -4795,6 +5451,7 @@ union cvmx_sli_mem_int_sum {
 	uint64_t reserved_18_63               : 46;
 #endif
 	} s;
+	struct cvmx_sli_mem_int_sum_s         cn73xx;
 	struct cvmx_sli_mem_int_sum_s         cn78xx;
 };
 typedef union cvmx_sli_mem_int_sum cvmx_sli_mem_int_sum_t;
@@ -4930,6 +5587,7 @@ union cvmx_sli_msi_rcv0 {
 	struct cvmx_sli_msi_rcv0_s            cn68xxp1;
 	struct cvmx_sli_msi_rcv0_s            cn70xx;
 	struct cvmx_sli_msi_rcv0_s            cn70xxp1;
+	struct cvmx_sli_msi_rcv0_s            cn73xx;
 	struct cvmx_sli_msi_rcv0_s            cn78xx;
 	struct cvmx_sli_msi_rcv0_s            cnf71xx;
 };
@@ -4958,6 +5616,7 @@ union cvmx_sli_msi_rcv1 {
 	struct cvmx_sli_msi_rcv1_s            cn68xxp1;
 	struct cvmx_sli_msi_rcv1_s            cn70xx;
 	struct cvmx_sli_msi_rcv1_s            cn70xxp1;
+	struct cvmx_sli_msi_rcv1_s            cn73xx;
 	struct cvmx_sli_msi_rcv1_s            cn78xx;
 	struct cvmx_sli_msi_rcv1_s            cnf71xx;
 };
@@ -4986,6 +5645,7 @@ union cvmx_sli_msi_rcv2 {
 	struct cvmx_sli_msi_rcv2_s            cn68xxp1;
 	struct cvmx_sli_msi_rcv2_s            cn70xx;
 	struct cvmx_sli_msi_rcv2_s            cn70xxp1;
+	struct cvmx_sli_msi_rcv2_s            cn73xx;
 	struct cvmx_sli_msi_rcv2_s            cn78xx;
 	struct cvmx_sli_msi_rcv2_s            cnf71xx;
 };
@@ -5014,6 +5674,7 @@ union cvmx_sli_msi_rcv3 {
 	struct cvmx_sli_msi_rcv3_s            cn68xxp1;
 	struct cvmx_sli_msi_rcv3_s            cn70xx;
 	struct cvmx_sli_msi_rcv3_s            cn70xxp1;
+	struct cvmx_sli_msi_rcv3_s            cn73xx;
 	struct cvmx_sli_msi_rcv3_s            cn78xx;
 	struct cvmx_sli_msi_rcv3_s            cnf71xx;
 };
@@ -5048,6 +5709,7 @@ union cvmx_sli_msi_rd_map {
 	struct cvmx_sli_msi_rd_map_s          cn68xxp1;
 	struct cvmx_sli_msi_rd_map_s          cn70xx;
 	struct cvmx_sli_msi_rd_map_s          cn70xxp1;
+	struct cvmx_sli_msi_rd_map_s          cn73xx;
 	struct cvmx_sli_msi_rd_map_s          cn78xx;
 	struct cvmx_sli_msi_rd_map_s          cnf71xx;
 };
@@ -5317,6 +5979,7 @@ union cvmx_sli_msi_wr_map {
 	struct cvmx_sli_msi_wr_map_s          cn68xxp1;
 	struct cvmx_sli_msi_wr_map_s          cn70xx;
 	struct cvmx_sli_msi_wr_map_s          cn70xxp1;
+	struct cvmx_sli_msi_wr_map_s          cn73xx;
 	struct cvmx_sli_msi_wr_map_s          cn78xx;
 	struct cvmx_sli_msi_wr_map_s          cnf71xx;
 };
@@ -5366,6 +6029,7 @@ union cvmx_sli_msixx_table_addr {
 	uint64_t addr                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_msixx_table_addr_s    cn73xx;
 	struct cvmx_sli_msixx_table_addr_s    cn78xx;
 };
 typedef union cvmx_sli_msixx_table_addr cvmx_sli_msixx_table_addr_t;
@@ -5389,6 +6053,7 @@ union cvmx_sli_msixx_table_data {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_sli_msixx_table_data_s    cn73xx;
 	struct cvmx_sli_msixx_table_data_s    cn78xx;
 };
 typedef union cvmx_sli_msixx_table_data cvmx_sli_msixx_table_data_t;
@@ -5484,6 +6149,7 @@ union cvmx_sli_msix_pba0 {
 	uint64_t msg_pnd                      : 64;
 #endif
 	} s;
+	struct cvmx_sli_msix_pba0_s           cn73xx;
 	struct cvmx_sli_msix_pba0_s           cn78xx;
 };
 typedef union cvmx_sli_msix_pba0 cvmx_sli_msix_pba0_t;
@@ -5513,6 +6179,7 @@ union cvmx_sli_msix_pba1 {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_sli_msix_pba1_s           cn73xx;
 	struct cvmx_sli_msix_pba1_s           cn78xx;
 };
 typedef union cvmx_sli_msix_pba1 cvmx_sli_msix_pba1_t;
@@ -5546,6 +6213,7 @@ union cvmx_sli_pcie_msi_rcv {
 	struct cvmx_sli_pcie_msi_rcv_s        cn68xxp1;
 	struct cvmx_sli_pcie_msi_rcv_s        cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_s        cn70xxp1;
+	struct cvmx_sli_pcie_msi_rcv_s        cn73xx;
 	struct cvmx_sli_pcie_msi_rcv_s        cn78xx;
 	struct cvmx_sli_pcie_msi_rcv_s        cnf71xx;
 };
@@ -5554,7 +6222,8 @@ typedef union cvmx_sli_pcie_msi_rcv cvmx_sli_pcie_msi_rcv_t;
 /**
  * cvmx_sli_pcie_msi_rcv_b1
  *
- * This register is where MSI write operations are directed from the MAC. This CSR can be used by
+ * This register is where MSI write operations are directed from the MAC. This register can be
+ * used by
  * the PCIe MACs.
  */
 union cvmx_sli_pcie_msi_rcv_b1 {
@@ -5582,6 +6251,7 @@ union cvmx_sli_pcie_msi_rcv_b1 {
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn68xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn70xxp1;
+	struct cvmx_sli_pcie_msi_rcv_b1_s     cn73xx;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn78xx;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cnf71xx;
 };
@@ -5590,7 +6260,8 @@ typedef union cvmx_sli_pcie_msi_rcv_b1 cvmx_sli_pcie_msi_rcv_b1_t;
 /**
  * cvmx_sli_pcie_msi_rcv_b2
  *
- * This register is where MSI write operations are directed from the MAC.  This CSR can be used
+ * This register is where MSI write operations are directed from the MAC.  This register can be
+ * used
  * by PCIe MACs.
  */
 union cvmx_sli_pcie_msi_rcv_b2 {
@@ -5618,6 +6289,7 @@ union cvmx_sli_pcie_msi_rcv_b2 {
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn68xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn70xxp1;
+	struct cvmx_sli_pcie_msi_rcv_b2_s     cn73xx;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn78xx;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cnf71xx;
 };
@@ -5626,7 +6298,8 @@ typedef union cvmx_sli_pcie_msi_rcv_b2 cvmx_sli_pcie_msi_rcv_b2_t;
 /**
  * cvmx_sli_pcie_msi_rcv_b3
  *
- * This register is where MSI write operations are directed from the MAC. This CSR can be used by
+ * This register is where MSI write operations are directed from the MAC. This register can be
+ * used by
  * PCIe MACs.
  */
 union cvmx_sli_pcie_msi_rcv_b3 {
@@ -5654,6 +6327,7 @@ union cvmx_sli_pcie_msi_rcv_b3 {
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn68xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn70xxp1;
+	struct cvmx_sli_pcie_msi_rcv_b3_s     cn73xx;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn78xx;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cnf71xx;
 };
@@ -5678,7 +6352,11 @@ union cvmx_sli_pktx_cnts {
                                                          SLI_PKT_CNT_INT (SLI_PKT_TIME_INT) shows the [CNT] ([TIMER]) component
                                                          for this and all other rings. See also SLI_PKT_IN_DONE(i)_CNTS[PO_INT]. */
 	uint64_t pi_int                       : 1;  /**< Packet input interrupt bit for the ring. A copy of SLI_PKT_IN_DONE(0..63)_CNTS[PI_INT]. */
-	uint64_t reserved_54_61               : 8;
+	uint64_t mbox_int                     : 1;  /**< Returns a 1 when corresponding bit when a VF registers */
+	uint64_t reserved_55_60               : 6;
+	uint64_t pi_clr                       : 1;  /**< Writng a 1 to this bit will clear this interrupt.  When SLI_PKT(0..127)_CNTS[CNT]
+                                                         is written and dooes not clear the corresponding SLI_PKT_TIME_INT or SLI_PKT_CNT_INT
+                                                         interrupts, a new MSIX INTA or MSI interrupt will be generated. */
 	uint64_t timer                        : 22; /**< Timer incremented every 1024 core clocks
                                                          when SLI_PKTS#_CNTS[CNT] is non zero. Field
                                                          cleared when SLI_PKTS#_CNTS[CNT] goes to 0.
@@ -5698,7 +6376,9 @@ union cvmx_sli_pktx_cnts {
 #else
 	uint64_t cnt                          : 32;
 	uint64_t timer                        : 22;
-	uint64_t reserved_54_61               : 8;
+	uint64_t pi_clr                       : 1;
+	uint64_t reserved_55_60               : 6;
+	uint64_t mbox_int                     : 1;
 	uint64_t pi_int                       : 1;
 	uint64_t po_int                       : 1;
 #endif
@@ -5733,26 +6413,117 @@ union cvmx_sli_pktx_cnts {
 	struct cvmx_sli_pktx_cnts_cn61xx      cn66xx;
 	struct cvmx_sli_pktx_cnts_cn61xx      cn68xx;
 	struct cvmx_sli_pktx_cnts_cn61xx      cn68xxp1;
-	struct cvmx_sli_pktx_cnts_cn61xx      cn70xx;
-	struct cvmx_sli_pktx_cnts_cn61xx      cn70xxp1;
-	struct cvmx_sli_pktx_cnts_s           cn78xx;
-	struct cvmx_sli_pktx_cnts_cn61xx      cnf71xx;
-};
-typedef union cvmx_sli_pktx_cnts cvmx_sli_pktx_cnts_t;
-
-/**
- * cvmx_sli_pkt#_in_bp
- *
- * "SLI_PKT[0..31]_IN_BP = SLI Packet ring# Input Backpressure
- * The counters and thresholds for input packets to apply backpressure to processing of the
- * packets."
- */
-union cvmx_sli_pktx_in_bp {
-	uint64_t u64;
-	struct cvmx_sli_pktx_in_bp_s {
+	struct cvmx_sli_pktx_cnts_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t wmark                        : 32; /**< When CNT is greater than this threshold no more
-                                                         packets will be processed for this ring.
+	uint64_t reserved_63_54               : 10;
+	uint64_t timer                        : 22; /**< "Timer incremented every 1024 core clocks
+                                                         when SLI_PKTS#_CNTS[CNT] is non zero. Field
+                                                         cleared when SLI_PKTS#_CNTS[CNT] goes to 0.
+                                                         Field is also cleared when SLI_PKT_TIME_INT is
+                                                         cleared.
+                                                         The first increment of this count can occur
+                                                         between 0 to 1023 core clocks." */
+	uint64_t cnt                          : 32; /**< ring counter. This field is incremented as
+                                                         packets are sent out and decremented in response to
+                                                         writes to this field.
+                                                         When SLI_PKT_OUT_BMODE is '0' a value of 1 is
+                                                         added to the register for each packet, when '1'
+                                                         and the info-pointer is NOT used the length of the
+                                                         packet plus 8 is added, when '1' and info-pointer
+                                                         mode IS used the packet length is added to this
+                                                         field. */
+#else
+	uint64_t cnt                          : 32;
+	uint64_t timer                        : 22;
+	uint64_t reserved_63_54               : 10;
+#endif
+	} cn70xx;
+	struct cvmx_sli_pktx_cnts_cn70xx      cn70xxp1;
+	struct cvmx_sli_pktx_cnts_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t po_int                       : 1;  /**< Packet output interrupt bit for the ring (i). [PO_INT] reads as one whenever:
+                                                          * [CNT]   > SLI_PKT(i)_INT_LEVELS[CNT], or
+                                                          * [TIMER] > SLI_PKT(i)_INT_LEVELS[TIME]
+                                                         [PO_INT] can cause an MSI-X interrupt for ring i, and its [CNT] ([TIMER]) component
+                                                         can cause SLI_INT_SUM[PCNT] (SLI_INT_SUM[PTIME]) to be set if
+                                                         SLI_PKT(i)_OUTPUT_CONTROL[CENB] (SLI_PKT(i)_OUTPUT_CONTROL[TENB]) is set.
+                                                         SLI_PKT_CNT_INT (SLI_PKT_TIME_INT) shows the [CNT] ([TIMER]) component
+                                                         for this and all other rings. See also SLI_PKT_IN_DONE(i)_CNTS[PO_INT]. */
+	uint64_t pi_int                       : 1;  /**< Packet input interrupt bit for the ring. A copy of SLI_PKT_IN_DONE(0..127)_CNTS[PI_INT]. */
+	uint64_t mbox_int                     : 1;  /**< Returns a 1 when corresponding bit when a VF registers */
+	uint64_t reserved_60_55               : 6;
+	uint64_t pi_clr                       : 1;  /**< Writng a 1 to this bit will clear this interrupt.  When SLI_PKT(0..127)_CNTS[CNT]
+                                                         is written and dooes not clear the corresponding SLI_PKT_TIME_INT or SLI_PKT_CNT_INT
+                                                         interrupts, a new MSIX INTA or MSI interrupt will be generated. */
+	uint64_t timer                        : 22; /**< Timer, incremented every 1024 coprocessor-clock cycles when [CNT] is
+                                                         not zero. The hardware clears both [TIMER] and [PO_INT] when [CNT]
+                                                         goes to 0. The first increment of this count can occur between 0 to
+                                                         1023 coprocessor-clock cycles after [CNT] becomes non-zero. */
+	uint64_t cnt                          : 32; /**< Ring counter. Hardware adds to [CNT] as it sends packets out. On a write
+                                                         to this register, hardware subtracts the amount written to the [CNT] field from
+                                                         [CNT], which will clear [PO_INT] if [CNT] becomes <= SLI_PKT(i)_INT_LEVELS[CNT].
+                                                         When SLI_PKT()_OUTPUT_CONTROL[BMODE] is clear, the hardware adds 1
+                                                         to [CNT] per packet. When SLI_PKT()_OUTPUT_CONTROL[BMODE] is set, the hardware
+                                                         adds (packet_length+X) to [CNT] per packet. X is zero when info pointer mode
+                                                         is used, 8 when info pointer mode is not used. */
+#else
+	uint64_t cnt                          : 32;
+	uint64_t timer                        : 22;
+	uint64_t pi_clr                       : 1;
+	uint64_t reserved_60_55               : 6;
+	uint64_t mbox_int                     : 1;
+	uint64_t pi_int                       : 1;
+	uint64_t po_int                       : 1;
+#endif
+	} cn73xx;
+	struct cvmx_sli_pktx_cnts_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t po_int                       : 1;  /**< Packet output interrupt bit for the ring (i). [PO_INT] reads as one whenever:
+                                                          * [CNT]   > SLI_PKT(i)_INT_LEVELS[CNT], or
+                                                          * [TIMER] > SLI_PKT(i)_INT_LEVELS[TIME]
+                                                         [PO_INT] can cause an MSI-X interrupt for ring i, and its [CNT] ([TIMER]) component
+                                                         can cause SLI_INT_SUM[PCNT] (SLI_INT_SUM[PTIME]) to be set if
+                                                         SLI_PKT(i)_OUTPUT_CONTROL[CENB] (SLI_PKT(i)_OUTPUT_CONTROL[TENB]) is set.
+                                                         SLI_PKT_CNT_INT (SLI_PKT_TIME_INT) shows the [CNT] ([TIMER]) component
+                                                         for this and all other rings. See also SLI_PKT_IN_DONE(i)_CNTS[PO_INT]. */
+	uint64_t pi_int                       : 1;  /**< Packet input interrupt bit for the ring. A copy of SLI_PKT_IN_DONE(0..63)_CNTS[PI_INT]. */
+	uint64_t reserved_61_54               : 8;
+	uint64_t timer                        : 22; /**< Timer, incremented every 1024 coprocessor-clock cycles when [CNT] is
+                                                         not zero. The hardware clears both [TIMER] and [PO_INT] when [CNT]
+                                                         goes to 0. The first increment of this count can occur between 0 to
+                                                         1023 coprocessor-clock cycles after [CNT] becomes non-zero. */
+	uint64_t cnt                          : 32; /**< Ring counter. Hardware adds to [CNT] as it sends packets out. On a write
+                                                         to this register, hardware subtracts the amount written to the [CNT] field from
+                                                         [CNT], which will clear [PO_INT] if [CNT] becomes <= SLI_PKT(i)_INT_LEVELS[CNT].
+                                                         When SLI_PKT()_OUTPUT_CONTROL[BMODE] is clear, the hardware adds 1
+                                                         to [CNT] per packet. When SLI_PKT()_OUTPUT_CONTROL[BMODE] is set, the hardware
+                                                         adds (packet_length+X) to [CNT] per packet. X is zero when info pointer mode
+                                                         is used, 8 when info pointer mode is not used. */
+#else
+	uint64_t cnt                          : 32;
+	uint64_t timer                        : 22;
+	uint64_t reserved_61_54               : 8;
+	uint64_t pi_int                       : 1;
+	uint64_t po_int                       : 1;
+#endif
+	} cn78xx;
+	struct cvmx_sli_pktx_cnts_cn61xx      cnf71xx;
+};
+typedef union cvmx_sli_pktx_cnts cvmx_sli_pktx_cnts_t;
+
+/**
+ * cvmx_sli_pkt#_in_bp
+ *
+ * "SLI_PKT[0..31]_IN_BP = SLI Packet ring# Input Backpressure
+ * The counters and thresholds for input packets to apply backpressure to processing of the
+ * packets."
+ */
+union cvmx_sli_pktx_in_bp {
+	uint64_t u64;
+	struct cvmx_sli_pktx_in_bp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t wmark                        : 32; /**< When CNT is greater than this threshold no more
+                                                         packets will be processed for this ring.
                                                          When writing this field of the SLI_PKT#_IN_BP
                                                          register, use a 4-byte write so as to not write
                                                          any other field of this register. */
@@ -5789,14 +6560,187 @@ union cvmx_sli_pktx_input_control {
 	uint64_t u64;
 	struct cvmx_sli_pktx_input_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_31_63               : 33;
+	uint64_t mac_num                      : 2;  /**< The MAC (PEM) that the physical function belongs to. Legal value are 0-3.
+                                                         [MAC_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [MAC_NUM] applies to both this input ring and to the output ring of the same
+                                                         index. */
+	uint64_t reserved_27_28               : 2;
+	uint64_t rdsize                       : 2;  /**< Number of instructions to be read in one MAC read request for the 4 ports, 16 rings. Two
+                                                         bit value are:
+                                                         0x0 = 1 Instruction.
+                                                         0x1 = 2 Instructions.
+                                                         0x2 = 3 Instructions.
+                                                         0x3 = 4 Instructions. */
+	uint64_t is_64b                       : 1;  /**< When IS_64B=1, instruction input ring i uses 64B. */
+	uint64_t rst                          : 1;  /**< Packet reset. When [RST]==1, the rings are in reset. [RST] can be set
+                                                         by software writing a 1 to the field, by hardware upon receipt of an
+                                                         FLR to an associated function, or by hardware when it receives an error
+                                                         response for a read associated with the rings.
+                                                         [MAC_NUM] applies to both this input ring and to the output ring of the same
+                                                         index.
+                                                         Software should not clear [RST] from 1->0 until [RST] has been asserted
+                                                         for at least 2ms. A ring reset may clear all state associated with the
+                                                         input and output rings, so software must completely re-initialize both
+                                                         before reusing them.
+                                                         See also SLI_PKT_RING_RST[RST]. */
+	uint64_t enb                          : 1;  /**< Enable for the input ring i. Whenever [RST] is set, hardware forces
+                                                         [ENB] clear.
+                                                         In the PF, [ENB] is also SLI_PKT_INSTR_ENB<i>. */
+	uint64_t pbp_dhi                      : 13; /**< Not used by hardware, but may be cleared by hardware when [RST] is set. */
+	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]==1, [D_NSR] is ADDRTYPE<1> for First Direct and Gather DPTR
+                                                         reads. ADDRTYPE<1> is the no-snoop attribute for PCIe. (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<61> for First Direct and Gather DPTR
+                                                         reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t d_esr                        : 2;  /**< If [USE_CSR]==1, [D_ESR] is ES<1:0> for First Direct and Gather DPTR reads.
+                                                         ES<1:0> is the endian-swap attribute for these MAC memory space reads.
+                                                         (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<63:62> for First Direct and Gather DPTR
+                                                         reads. (ES<1:0> comes from DPTR<63:62> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t d_ror                        : 1;  /**< If [USE_CSR]==1, [D_ROR] is ADDRTYPE<0> for First Direct and Gather DPTR
+                                                         reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<60> for First Direct and Gather DPTR
+                                                         reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t use_csr                      : 1;  /**< When set to 1, [D_ROR], [D_ESR], and [D_NSR] are used for ROR, ESR, and NSR,
+                                                         respectively. (DPTR Format 0) When clear to 0, <63:60> from a First Direct
+                                                         or Gather DPTR are used. (DPTR Format 1) The bits not used for ROR, ESR,
+                                                         and NSR become bits <63:60> of the address used to fetch packet data. */
+	uint64_t nsr                          : 1;  /**< [NSR] is ADDRTYPE<1> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ADDRTYPE<1>
+                                                         is the no-snoop attribute for PCIe. */
+	uint64_t esr                          : 2;  /**< [ESR] is ES<1:0> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ES<1:0> is
+                                                         the endian-swap attribute for these MAC memory space reads. */
+	uint64_t ror                          : 1;  /**< [ROR] is ADDRTYPE<0> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads.
+                                                         ADDRTYPE<0> is the relaxed-order attribute for PCIe. */
+#else
+	uint64_t ror                          : 1;
+	uint64_t esr                          : 2;
+	uint64_t nsr                          : 1;
+	uint64_t use_csr                      : 1;
+	uint64_t d_ror                        : 1;
+	uint64_t d_esr                        : 2;
+	uint64_t d_nsr                        : 1;
+	uint64_t pbp_dhi                      : 13;
+	uint64_t enb                          : 1;
+	uint64_t rst                          : 1;
+	uint64_t is_64b                       : 1;
+	uint64_t rdsize                       : 2;
+	uint64_t reserved_27_28               : 2;
+	uint64_t mac_num                      : 2;
+	uint64_t reserved_31_63               : 33;
+#endif
+	} s;
+	struct cvmx_sli_pktx_input_control_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t pvf_num                      : 16; /**< The function number that the ring belongs to. When [VF_NUM]==0, the physical
+                                                         function controls the ring. When [VF_NUM]!=0, it must correctly indicate the
+                                                         virtual function number that controls the ring. ([VF_NUM]==1 selects the first
+                                                         virtual function within the selected physical function, [VF_NUM]==2 selects
+                                                         the second virtual function within the selected physical function ...)
+                                                         Legal values are 0..64.
+                                                         [VF_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [VF_NUM] applies to both this input ring and to the output ring of the same
+                                                         index. */
+	uint64_t reserved_31_31               : 1;
+	uint64_t mac_num                      : 2;  /**< The MAC (PEM) that the physical function belongs to. Legal value are 0-3.
+                                                         [MAC_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [MAC_NUM] applies to both this input ring and to the output ring of the same
+                                                         index. */
+	uint64_t reserved_27_28               : 2;
+	uint64_t rdsize                       : 2;  /**< Number of instructions to be read in one MAC read request for the 4 ports, 16 rings. Two
+                                                         bit value are:
+                                                         0x0 = 1 Instruction.
+                                                         0x1 = 2 Instructions.
+                                                         0x2 = 3 Instructions.
+                                                         0x3 = 4 Instructions. */
+	uint64_t is_64b                       : 1;  /**< When IS_64B=1, instruction input ring i uses 64B. */
+	uint64_t rst                          : 1;  /**< Packet reset. When [RST]==1, the rings are in reset. [RST] can be set
+                                                         by software writing a 1 to the field, by hardware upon receipt of an
+                                                         FLR to an associated function, or by hardware when it receives an error
+                                                         response for a read associated with the rings.
+                                                         [MAC_NUM] applies to both this input ring and to the output ring of the same
+                                                         index.
+                                                         Software should not clear [RST] from 1->0 until [RST] has been asserted
+                                                         for at least 2ms. A ring reset may clear all state associated with the
+                                                         input and output rings, so software must completely re-initialize both
+                                                         before reusing them.
+                                                         See also SLI_PKT_RING_RST[RST]. */
+	uint64_t enb                          : 1;  /**< Enable for the input ring i. Whenever [RST] is set, hardware forces
+                                                         [ENB] clear.
+                                                         In the PF, [ENB] is also SLI_PKT_INSTR_ENB<i>. */
+	uint64_t pbp_dhi                      : 13; /**< Not used by hardware, but may be cleared by hardware when [RST] is set. */
+	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]==1, [D_NSR] is ADDRTYPE<1> for First Direct and Gather DPTR
+                                                         reads. ADDRTYPE<1> is the no-snoop attribute for PCIe. (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<61> for First Direct and Gather DPTR
+                                                         reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t d_esr                        : 2;  /**< If [USE_CSR]==1, [D_ESR] is ES<1:0> for First Direct and Gather DPTR reads.
+                                                         ES<1:0> is the endian-swap attribute for these MAC memory space reads.
+                                                         (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<63:62> for First Direct and Gather DPTR
+                                                         reads. (ES<1:0> comes from DPTR<63:62> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t d_ror                        : 1;  /**< If [USE_CSR]==1, [D_ROR] is ADDRTYPE<0> for First Direct and Gather DPTR
+                                                         reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<60> for First Direct and Gather DPTR
+                                                         reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t use_csr                      : 1;  /**< When set to 1, [D_ROR], [D_ESR], and [D_NSR] are used for ROR, ESR, and NSR,
+                                                         respectively. (DPTR Format 0) When clear to 0, <63:60> from a First Direct
+                                                         or Gather DPTR are used. (DPTR Format 1) The bits not used for ROR, ESR,
+                                                         and NSR become bits <63:60> of the address used to fetch packet data. */
+	uint64_t nsr                          : 1;  /**< [NSR] is ADDRTYPE<1> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ADDRTYPE<1>
+                                                         is the no-snoop attribute for PCIe. */
+	uint64_t esr                          : 2;  /**< [ESR] is ES<1:0> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ES<1:0> is
+                                                         the endian-swap attribute for these MAC memory space reads. */
+	uint64_t ror                          : 1;  /**< [ROR] is ADDRTYPE<0> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads.
+                                                         ADDRTYPE<0> is the relaxed-order attribute for PCIe. */
+#else
+	uint64_t ror                          : 1;
+	uint64_t esr                          : 2;
+	uint64_t nsr                          : 1;
+	uint64_t use_csr                      : 1;
+	uint64_t d_ror                        : 1;
+	uint64_t d_esr                        : 2;
+	uint64_t d_nsr                        : 1;
+	uint64_t pbp_dhi                      : 13;
+	uint64_t enb                          : 1;
+	uint64_t rst                          : 1;
+	uint64_t is_64b                       : 1;
+	uint64_t rdsize                       : 2;
+	uint64_t reserved_27_28               : 2;
+	uint64_t mac_num                      : 2;
+	uint64_t reserved_31_31               : 1;
+	uint64_t pvf_num                      : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn73xx;
+	struct cvmx_sli_pktx_input_control_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_39_63               : 25;
-	uint64_t vf_num                       : 7;  /**< The VF number that this ring belongs to. A value of 0 means that this ring belongs to the
-                                                         PF. The VF number is the value sent to and received from the MAC. This means that if ring
-                                                         x belongs to MAC0 and ring y belongs to MAC1, they both could have a VF_NUM of 1. Legal
-                                                         value are 0-64. */
+	uint64_t vf_num                       : 7;  /**< The function number that the ring belongs to. When [VF_NUM]==0, the physical
+                                                         function controls the ring. When [VF_NUM]!=0, it must correctly indicate the
+                                                         virtual function number that controls the ring. ([VF_NUM]==1 selects the first
+                                                         virtual function within the selected physical function, [VF_NUM]==2 selects
+                                                         the second virtual function within the selected physical function ...)
+                                                         Legal values are 0..64.
+                                                         [VF_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [VF_NUM] applies to both this input ring and to the output ring of the same
+                                                         index. */
 	uint64_t reserved_31_31               : 1;
-	uint64_t mac_num                      : 2;  /**< The MAC that the ring belongs to. Legal value are 0-3. This applies for both
-                                                         input and output rings. */
+	uint64_t mac_num                      : 2;  /**< The MAC (PEM) that the physical function belongs to. Legal value are 0-3.
+                                                         [MAC_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [MAC_NUM] applies to both this input ring and to the output ring of the same
+                                                         index. */
 	uint64_t reserved_27_28               : 2;
 	uint64_t rdsize                       : 2;  /**< Number of instructions to be read in one MAC read request for the 4 ports, 16 rings. Two
                                                          bit value are:
@@ -5805,55 +6749,50 @@ union cvmx_sli_pktx_input_control {
                                                          0x2 = 3 Instructions.
                                                          0x3 = 4 Instructions. */
 	uint64_t is_64b                       : 1;  /**< When IS_64B=1, instruction input ring i uses 64B. */
-	uint64_t rst                          : 1;  /**< Packet reset. This bit is set for a ring when the ring enters the reset state. This can be
-                                                         done by writing a 1 to the field, when a FLR associated with the ring occurs, or when an
-                                                         error response is received for a read done by the ring. This applies for both
-                                                         input and output rings. See SLI_INT_SUM[PGL_ERR]. When
-                                                         receiving a PGL_ERR interrupt, software should:
-                                                         1. Wait 2ms to allow any outstanding reads to return or be timed out.
-                                                         2. Write a 0 to this bit.
-                                                         3. Start up the packet input/output again (all previous CSR setting of the packet-
-                                                         input/output will be lost).
+	uint64_t rst                          : 1;  /**< Packet reset. When [RST]==1, the rings are in reset. [RST] can be set
+                                                         by software writing a 1 to the field, by hardware upon receipt of an
+                                                         FLR to an associated function, or by hardware when it receives an error
+                                                         response for a read associated with the rings.
+                                                         [MAC_NUM] applies to both this input ring and to the output ring of the same
+                                                         index.
+                                                         Software should not clear [RST] from 1->0 until [RST] has been asserted
+                                                         for at least 2ms. A ring reset may clear all state associated with the
+                                                         input and output rings, so software must completely re-initialize both
+                                                         before reusing them.
                                                          See also SLI_PKT_RING_RST[RST]. */
-	uint64_t enb                          : 1;  /**< Packet output enable. When ENB<i>=1, packet output ring i is enabled.
-                                                         When the ring is in reset, caused by a failing read associated with the ring, the ring
-                                                         being put into
-                                                         reset by writing the reset bit associated with a ring, a FLR or the MAC the ring is
-                                                         associated with
-                                                         being in reset, will cause this bit to clear and be able to be set again till the reset
-                                                         condition is removed. */
-	uint64_t pbp_dhi                      : 13; /**< PBP_DHI replaces address bits that are used for parse mode and skip-length when
-                                                         SLI_PKTi_INSTR_HEADER[PBP] = 1. PBP_DHI becomes either MACADD<63:55> or MACADD<59:51> for
-                                                         the instruction DPTR read operations in this case. The instruction DPTR read operations
-                                                         are called first direct or first indirect. When PBP = 1, if first direct and USE_CSR = 0,
-                                                         PBP_DHI becomes MACADD<59:51>, else MACADD<63:55>. */
-	uint64_t d_nsr                        : 1;  /**< ADDRTYPE<1> or MACADD<61> for packet input data read operations. D_NSR becomes either
-                                                         ADDRTYPE<1> or MACADD<61> for MAC memory space read operations of packet input data
-                                                         fetched for any packet input ring. ADDRTYPE<1> if USE_CSR = 1, else MACADD<61>. In the
-                                                         latter case, ADDRTYPE<1> comes from DPTR<61>. ADDRTYPE<1> is the no-snoop attribute for
-                                                         PCIe. */
-	uint64_t d_esr                        : 2;  /**< ES<1:0> or MACADD<63:62> for packet input data read operations. D_ESR becomes either
-                                                         ES<1:0> or MACADD<63:62> for MAC memory space read operations of packet input data fetched
-                                                         for any packet input ring. ES<1:0> if USE_CSR = 1, else MACADD<63:62>. In the latter case,
-                                                         ES<1:0> comes from DPTR<63:62>. ES<1:0> is the endian-swap attribute for these MAC memory
-                                                         space read operations. */
-	uint64_t d_ror                        : 1;  /**< ADDRTYPE<0> or MACADD<60> for packet input data read operations. D_ROR becomes either
-                                                         ADDRTYPE<0> or MACADD<60> for MAC memory space read operations of packet input data
-                                                         fetched for any packet input ring. ADDRTYPE<0> if USE_CSR = 1, else MACADD<60>. In the
-                                                         latter case, ADDRTYPE<0> comes from DPTR<60>. ADDRTYPE<0> is the relaxed-order attribute
-                                                         for PCIe. */
-	uint64_t use_csr                      : 1;  /**< When set to 1, the CSR value is used for ROR, ESR, and NSR. When clear to 0, the value in
-                                                         DPTR is used. In turn, the bits not used for ROR, ESR, and NSR are used for bits [63:60]
-                                                         of the address used to fetch packet data. */
-	uint64_t nsr                          : 1;  /**< ADDRTYPE<1> for packet input instruction read operations and gather list (i.e. DPI
-                                                         component) read operations from MAC memory space. ADDRTYPE<1> is the no-snoop attribute
-                                                         for PCIe. */
-	uint64_t esr                          : 2;  /**< ES<1:0> for packet input instruction read operations and gather list (i.e. DPI component)
-                                                         read operations from MAC memory space. ES<1:0> is the endian-swap attribute for these MAC
-                                                         memory space read operations. */
-	uint64_t ror                          : 1;  /**< ADDRTYPE<0> for packet input instruction read operations and gather list (i.e. DPI
-                                                         component) read operations from MAC memory space. ADDRTYPE<0> is the relaxed-order
-                                                         attribute for PCIe. */
+	uint64_t enb                          : 1;  /**< Enable for the input ring i. Whenever [RST] is set, hardware forces
+                                                         [ENB] clear.
+                                                         In the PF, [ENB] is also SLI_PKT_INSTR_ENB<i>. */
+	uint64_t pbp_dhi                      : 13; /**< Not used by hardware, but may be cleared by hardware when [RST] is set. */
+	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]==1, [D_NSR] is ADDRTYPE<1> for First Direct and Gather DPTR
+                                                         reads. ADDRTYPE<1> is the no-snoop attribute for PCIe. (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<61> for First Direct and Gather DPTR
+                                                         reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t d_esr                        : 2;  /**< If [USE_CSR]==1, [D_ESR] is ES<1:0> for First Direct and Gather DPTR reads.
+                                                         ES<1:0> is the endian-swap attribute for these MAC memory space reads.
+                                                         (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<63:62> for First Direct and Gather DPTR
+                                                         reads. (ES<1:0> comes from DPTR<63:62> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t d_ror                        : 1;  /**< If [USE_CSR]==1, [D_ROR] is ADDRTYPE<0> for First Direct and Gather DPTR
+                                                         reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<60> for First Direct and Gather DPTR
+                                                         reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t use_csr                      : 1;  /**< When set to 1, [D_ROR], [D_ESR], and [D_NSR] are used for ROR, ESR, and NSR,
+                                                         respectively. (DPTR Format 0) When clear to 0, <63:60> from a First Direct
+                                                         or Gather DPTR are used. (DPTR Format 1) The bits not used for ROR, ESR,
+                                                         and NSR become bits <63:60> of the address used to fetch packet data. */
+	uint64_t nsr                          : 1;  /**< [NSR] is ADDRTYPE<1> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ADDRTYPE<1>
+                                                         is the no-snoop attribute for PCIe. */
+	uint64_t esr                          : 2;  /**< [ESR] is ES<1:0> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ES<1:0> is
+                                                         the endian-swap attribute for these MAC memory space reads. */
+	uint64_t ror                          : 1;  /**< [ROR] is ADDRTYPE<0> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads.
+                                                         ADDRTYPE<0> is the relaxed-order attribute for PCIe. */
 #else
 	uint64_t ror                          : 1;
 	uint64_t esr                          : 2;
@@ -5873,8 +6812,7 @@ union cvmx_sli_pktx_input_control {
 	uint64_t vf_num                       : 7;
 	uint64_t reserved_39_63               : 25;
 #endif
-	} s;
-	struct cvmx_sli_pktx_input_control_s  cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_sli_pktx_input_control cvmx_sli_pktx_input_control_t;
 
@@ -5903,6 +6841,7 @@ union cvmx_sli_pktx_instr_baddr {
 	struct cvmx_sli_pktx_instr_baddr_s    cn68xxp1;
 	struct cvmx_sli_pktx_instr_baddr_s    cn70xx;
 	struct cvmx_sli_pktx_instr_baddr_s    cn70xxp1;
+	struct cvmx_sli_pktx_instr_baddr_s    cn73xx;
 	struct cvmx_sli_pktx_instr_baddr_s    cn78xx;
 	struct cvmx_sli_pktx_instr_baddr_s    cnf71xx;
 };
@@ -5937,6 +6876,7 @@ union cvmx_sli_pktx_instr_baoff_dbell {
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn68xxp1;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn70xx;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn70xxp1;
+	struct cvmx_sli_pktx_instr_baoff_dbell_s cn73xx;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn78xx;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cnf71xx;
 };
@@ -5973,6 +6913,7 @@ union cvmx_sli_pktx_instr_fifo_rsize {
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn68xxp1;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn70xx;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn70xxp1;
+	struct cvmx_sli_pktx_instr_fifo_rsize_s cn73xx;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn78xx;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cnf71xx;
 };
@@ -6125,8 +7066,73 @@ union cvmx_sli_pktx_instr_header {
 	struct cvmx_sli_pktx_instr_header_cn61xx cn66xx;
 	struct cvmx_sli_pktx_instr_header_s   cn68xx;
 	struct cvmx_sli_pktx_instr_header_cn61xx cn68xxp1;
-	struct cvmx_sli_pktx_instr_header_cn61xx cn70xx;
-	struct cvmx_sli_pktx_instr_header_cn61xx cn70xxp1;
+	struct cvmx_sli_pktx_instr_header_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_44_63               : 20;
+	uint64_t pbp                          : 1;  /**< Enable Packet-by-packet mode.
+                                                         Allows DPI to generate PKT_INST_HDR[PM,SL]
+                                                         differently per DPI instruction.
+                                                         USE_IHDR must be set whenever PBP is set. */
+	uint64_t reserved_38_42               : 5;
+	uint64_t rparmode                     : 2;  /**< Parse Mode. Becomes PKT_INST_HDR[PM]
+                                                         when DPI_INST_HDR[R]==1 and PBP==0 */
+	uint64_t reserved_35_35               : 1;
+	uint64_t rskp_len                     : 7;  /**< Skip Length. Becomes PKT_INST_HDR[SL]
+                                                         when DPI_INST_HDR[R]==1 and PBP==0 */
+	uint64_t reserved_27_26               : 2;
+	uint64_t rnqos                        : 1;  /**< Becomes PKT_INST_HDR[NQOS]
+                                                         when DPI_INST_HDR[R]==1 */
+	uint64_t rngrp                        : 1;  /**< Becomes PKT_INST_HDR[NGRP]
+                                                         when DPI_INST_HDR[R]==1 */
+	uint64_t rntt                         : 1;  /**< Becomes PKT_INST_HDR[NTT]
+                                                         when DPI_INST_HDR[R]==1 */
+	uint64_t rntag                        : 1;  /**< Becomes PKT_INST_HDR[NTAG]
+                                                         when DPI_INST_HDR[R]==1 */
+	uint64_t use_ihdr                     : 1;  /**< When set '1' DPI always prepends a PKT_INST_HDR
+                                                         as part of the packet data sent to PIP/IPD,
+                                                         regardless of DPI_INST_HDR[R]. (DPI also always
+                                                         prepends a PKT_INST_HDR when DPI_INST_HDR[R]=1.)
+                                                         USE_IHDR must be set whenever PBP is set. */
+	uint64_t reserved_20_16               : 5;
+	uint64_t par_mode                     : 2;  /**< Parse Mode. Becomes PKT_INST_HDR[PM]
+                                                         when DPI_INST_HDR[R]==0 and USE_IHDR==1 and PBP==0 */
+	uint64_t reserved_13_13               : 1;
+	uint64_t skp_len                      : 7;  /**< Skip Length. Becomes PKT_INST_HDR[SL]
+                                                         when DPI_INST_HDR[R]==0 and USE_IHDR==1 and PBP==0 */
+	uint64_t reserved_5_4                 : 2;
+	uint64_t nqos                         : 1;  /**< Becomes PKT_INST_HDR[NQOS]
+                                                         when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
+	uint64_t ngrp                         : 1;  /**< Becomes PKT_INST_HDR[NGRP]
+                                                         when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
+	uint64_t ntt                          : 1;  /**< Becomes PKT_INST_HDR[NTT]
+                                                         when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
+	uint64_t ntag                         : 1;  /**< Becomes PKT_INST_HDR[NTAG]
+                                                         when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
+#else
+	uint64_t ntag                         : 1;
+	uint64_t ntt                          : 1;
+	uint64_t ngrp                         : 1;
+	uint64_t nqos                         : 1;
+	uint64_t reserved_5_4                 : 2;
+	uint64_t skp_len                      : 7;
+	uint64_t reserved_13_13               : 1;
+	uint64_t par_mode                     : 2;
+	uint64_t reserved_20_16               : 5;
+	uint64_t use_ihdr                     : 1;
+	uint64_t rntag                        : 1;
+	uint64_t rntt                         : 1;
+	uint64_t rngrp                        : 1;
+	uint64_t rnqos                        : 1;
+	uint64_t reserved_27_26               : 2;
+	uint64_t rskp_len                     : 7;
+	uint64_t reserved_35_35               : 1;
+	uint64_t rparmode                     : 2;
+	uint64_t reserved_38_42               : 5;
+	uint64_t pbp                          : 1;
+	uint64_t reserved_44_63               : 20;
+#endif
+	} cn70xx;
+	struct cvmx_sli_pktx_instr_header_cn70xx cn70xxp1;
 	struct cvmx_sli_pktx_instr_header_cn61xx cnf71xx;
 };
 typedef union cvmx_sli_pktx_instr_header cvmx_sli_pktx_instr_header_t;
@@ -6146,13 +7152,13 @@ union cvmx_sli_pktx_int_levels {
                                                          (and SLI_PKT_TIME_INT<i> and SLI_PKT_INT<i>), and may cause an MSI-X, MSI, or
                                                          INTA/B/C/D interrupt, whenever SLI_PKT(i)_CNTS[TIMER] > [TIME].
                                                          Whenever software changes the value of [TIME], it should also subsequently write
-                                                         the corresponding SLI_PKT()_CNTS CSR (with a value of zero if desired)
+                                                         the corresponding SLI_PKT()_CNTS register (with a value of zero if desired)
                                                          to ensure that the hardware correspondingly updates SLI_PKT(i)_CNTS[PO_INT]. */
 	uint64_t cnt                          : 32; /**< Output ring counter interrupt threshold. SLI sets SLI_PKT(i)_CNTS[PO_INT]
                                                          (and SLI_PKT_CNT_INT<i> and SLI_PKT_INT<i>), and may cause an MSI-X, MSI, or
                                                          INTA/B/C/D interrupt, whenever SLI_PKT(i)_CNTS[CNT] > [CNT].
                                                          Whenever software changes the value of [TIME], it should also subsequently write
-                                                         the corresponding SLI_PKT()_CNTS CSR (with a value of zero if desired)
+                                                         the corresponding SLI_PKT()_CNTS register (with a value of zero if desired)
                                                          to ensure that the hardware correspondingly updates SLI_PKT(i)_CNTS[PO_INT]. */
 #else
 	uint64_t cnt                          : 32;
@@ -6160,11 +7166,50 @@ union cvmx_sli_pktx_int_levels {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
+	struct cvmx_sli_pktx_int_levels_s     cn73xx;
 	struct cvmx_sli_pktx_int_levels_s     cn78xx;
 };
 typedef union cvmx_sli_pktx_int_levels cvmx_sli_pktx_int_levels_t;
 
 /**
+ * cvmx_sli_pkt#_mbox_int
+ *
+ * This register contains information to service mbox interrupts from the VF
+ *
+ */
+union cvmx_sli_pktx_mbox_int {
+	uint64_t u64;
+	struct cvmx_sli_pktx_mbox_int_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t po_int                       : 1;  /**< "Returns a 1 when either the corresponding bit in SLI_PKT_TIME_INT[RING<\#>] or
+                                                         SLI_PKT_CNT_INT[RING<\#>] is set. This interrupt can be cleared by writing
+                                                         SLI_PKT()_CNTS[CNT]." */
+	uint64_t pi_int                       : 1;  /**< "Returns a 1 when the corresponding bit of SLI_PKT_IN_INT[RING<\#>] is set. This interrupt
+                                                         can be cleared by writing SLI_PKT_IN_DONE()_CNTS." */
+	uint64_t mbox_int                     : 1;  /**< Set to one when a PF writes the corresponding ring SLI_PKT(0..63)_PF_VF_MBOX_SIG(0)
+                                                         register. Writes will clear this interrupt.  This bit can only be written by the VF side.
+                                                         It cannot be cleared by the PF. [MBOX_INT] can cause an MSI-X interrupt for the ring,
+                                                         but will never cause an INTA/B/C/D nor MSI interrupt nor set any SLI_INT_SUM bit. */
+	uint64_t resend                       : 1;  /**< A write of 1 will resend an interrupt message if there is a pending interrupt in P0_INT
+                                                         PI_INT or MBOX_INT. */
+	uint64_t reserved_1_59                : 59;
+	uint64_t mbox_en                      : 1;  /**< Enables interrupt to the MSIX vector associated with this VF when the PF writes the
+                                                         corresponding
+                                                         ring in SLI_PKT(0..63)_VF_MBOX_SIG2 */
+#else
+	uint64_t mbox_en                      : 1;
+	uint64_t reserved_1_59                : 59;
+	uint64_t resend                       : 1;
+	uint64_t mbox_int                     : 1;
+	uint64_t pi_int                       : 1;
+	uint64_t po_int                       : 1;
+#endif
+	} s;
+	struct cvmx_sli_pktx_mbox_int_s       cn73xx;
+};
+typedef union cvmx_sli_pktx_mbox_int cvmx_sli_pktx_mbox_int_t;
+
+/**
  * cvmx_sli_pkt#_out_size
  *
  * This register contains the BSIZE and ISIZE for output packet rings.
@@ -6192,6 +7237,7 @@ union cvmx_sli_pktx_out_size {
 	struct cvmx_sli_pktx_out_size_s       cn68xxp1;
 	struct cvmx_sli_pktx_out_size_s       cn70xx;
 	struct cvmx_sli_pktx_out_size_s       cn70xxp1;
+	struct cvmx_sli_pktx_out_size_s       cn73xx;
 	struct cvmx_sli_pktx_out_size_s       cn78xx;
 	struct cvmx_sli_pktx_out_size_s       cnf71xx;
 };
@@ -6208,55 +7254,61 @@ union cvmx_sli_pktx_output_control {
 	struct cvmx_sli_pktx_output_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t tenb                         : 1;  /**< Output ring packet timer interrupt enable. When both TENB and corresponding
-                                                         SLI_PKT_TIME_INT[PORT<i>] are set, for any i, SLI_INT_SUM[PTIME] is set, which can cause
-                                                         an interrupt. */
-	uint64_t cenb                         : 1;  /**< Output ring packet counter interrupt enable. When both CENB and corresponding
-                                                         SLI_PKT_CNT_INT[PORT<i>] are set, for any i, SLI_INT_SUM[PCNT] is set, which can cause an
-                                                         interrupt. */
+	uint64_t tenb                         : 1;  /**< SLI_INT_SUM[PTIME] interrupt enable for this ring i. When [TENB] is set and
+                                                         (SLI_PKT(i)_CNTS[TIMER] > SLI_PKT(i)_INT_LEVELS[TIME]), SLI_INT_SUM[PTIME]
+                                                         will be set, and SLI_INT_SUM interrupts can occur if SLI_INT_SUM[PTIME]
+                                                         is enabled to generate interrupts.
+                                                         When [TENB] is clear, SLI_INT_SUM[PTIME] will never assert due to ring i.
+                                                         [TENB] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [TENB] has no effect on SLI_PKT_TIME_INT or SLI_PKT_INT, and
+                                                         has no effect on any non-SLI_INT_SUM interrupt. */
+	uint64_t cenb                         : 1;  /**< SLI_INT_SUM[PCNT] interrupt enable for this ring i. When [CENB] is set and
+                                                         (SLI_PKT(i)_CNTS[TIMER] > SLI_PKT(i)_INT_LEVELS[TIME]), SLI_INT_SUM[PCNT]
+                                                         will be set, and SLI_INT_SUM interrupts can occur if SLI_INT_SUM[PCNT]
+                                                         is enabled to generate interrupts.
+                                                         When [CENB] is clear, SLI_INT_SUM[PCNT] will never assert due to ring i.
+                                                         [CENB] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [CENB] has no effect on SLI_PKT_CNT_INT or SLI_PKT_INT, and
+                                                         has no effect on any non-SLI_INT_SUM interrupt. */
 	uint64_t iptr                         : 1;  /**< When IPTR=1, packet output ring is in info-pointer mode; otherwise the packet output ring
                                                          is in buffer-pointer-only mode. */
-	uint64_t es                           : 2;  /**< ES or MACADD<63:62> for buffer/info write operations to buffer/info pair MAC memory space
-                                                         addresses fetched from packet output ring. ES<1:0> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1,
-                                                         else MACADD<63:62>. In the latter case, ES<1:0> comes from DPTR<63:62>. ES<1:0> is the
-                                                         endian-swap attribute for these MAC memory space writes. */
-	uint64_t nsr                          : 1;  /**< ADDRTYPE<1> or MACADD<61> for buffer/info write operations. NSR    becomes either
-                                                         ADDRTYPE<1> or MACADD<61> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<1> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1, else
-                                                         MACADD<61>. In the latter case, ADDRTYPE<1> comes from DPTR<61>. ADDRTYPE<1> is the no-
-                                                         snoop attribute for PCIe. */
-	uint64_t ror                          : 1;  /**< ADDRTYPE<0> or MACADD<60> for buffer/info write operations. ROR    becomes either
-                                                         ADDRTYPE<0> or MACADD<60> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<0> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1, else
-                                                         MACADD<60>. In the latter case, ADDRTYPE<0> comes from DPTR<60>. ADDRTYPE<0> is the
-                                                         relaxed-order attribute for PCIe. */
-	uint64_t dptr                         : 1;  /**< Determines whether buffer/info pointers are DPTR format 0 or DPTR format 1. When DPTR=1,
-                                                         the buffer/info pointers fetched from packet output ring are DPTR format 0. When DPTR=0,
-                                                         the buffer/info pointers fetched from packet output ring i are DPTR format 1. (Replace
-                                                         SLI_PKT()_INPUT_CONTROL[D_ESR,D_NSR,D_ROR] in the descriptions of DPTR format 0/1 in
-                                                         DPI Instruction Input Initialization with SLI_PKT()_OUTPUT_CONTROL[ES],
-                                                         SLI_PKT()_OUTPUT_CONTROL[NSR], and SLI_PKT()_OUTPUT_CONTROL[ROR], respectively, though.) */
+	uint64_t es                           : 2;  /**< If [DPTR]==1, [ES] is ES<1:0> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. ES<1:0> is the
+                                                         endian-swap attribute for these MAC memory space writes. (DPTR Format 0)
+                                                         If [DPTR]==0, [ES] is MACADD<63:62> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. (<63:62> of the
+                                                         buffer or info pointer is ES<1:0> for the writes in this case when [DPTR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t nsr                          : 1;  /**< If [DPTR]==1, [NSR] is ADDRTYPE<1> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. ADDRTYPE<1> is
+                                                         the no-snoop attribute for PCIe. (DPTR Format 0)
+                                                         If [DPTR]==0, [NSR] is MACADD<61> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. (<61> of the
+                                                         buffer or info pointer is ADDRTYPE<1> for the writes in this case when [DPTR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t ror                          : 1;  /**< If [DPTR]==1, [ROR] is ADDRTYPE<0> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. ADDRTYPE<0> is
+                                                         the relaxed-order attribute for PCIe. (DPTR Format 0)
+                                                         If [DPTR]==0, [ROR] is MACADD<60> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. (<60> of the
+                                                         buffer or info pointer is ADDRTYPE<0> for the writes in this case when [DPTR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t dptr                         : 1;  /**< Determines [ES,NSR,ROR] usage and the format of buffer/info pointers. When set,
+                                                         buffer/info pointers are DPTR format 0. When clear, buffer/info pointers
+                                                         are DPTR format 1. */
 	uint64_t bmode                        : 1;  /**< Determines whether SLI_PKT()_CNTS[CNT] is a byte or packet counter. When BMODE=1,
                                                          SLI_PKT()_CNTS[CNT] is a byte counter, else SLI_PKT()_CNTS[CNT] is a packet counter. */
-	uint64_t es_p                         : 2;  /**< ES<1:0> for the packet output ring reads that fetch buffer/info pointer pairs. ES<1:0> is
-                                                         the endian-swap attribute for these MAC memory space reads. */
-	uint64_t nsr_p                        : 1;  /**< ADDRTYPE<1> or MACADD<61> for buffer/info write operations. NSR    becomes either
-                                                         ADDRTYPE<1> or MACADD<61> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<1> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1,
-                                                         else MACADD<61>. In the latter case, ADDRTYPE<1> comes from DPTR<61>. ADDRTYPE<1> is the
-                                                         no-snoop attribute for PCIe. */
-	uint64_t ror_p                        : 1;  /**< ADDRTYPE<0> for the packet output ring reads that fetch buffer/info pointer pairs. ROR
-                                                         becomes ADDRTYPE<0> in DPI/SLI reads that fetch buffer/info pairs from packet output ring
-                                                         (from address SLI_PKT()_SLIST_BADDR+ in MAC memory space.) ADDRTYPE<0> is the relaxed-
-                                                         order
-                                                         attribute for PCIe. */
-	uint64_t enb                          : 1;  /**< Packet output enable. When ENB=1, packet output ring is enabled. When the ring is in
-                                                         reset,
-                                                         caused by a failing read associated with the ring, the ring being put into reset by
-                                                         writing the reset bit associated with a ring, a FLR or the MAC the ring is associated with
-                                                         being in reset, will cause this bit to clear and be able to be set again till the reset
-                                                         condition is removed. This is a mirror of SLI_PKT_OUT_ENB (setting a bit here will set a
-                                                         bit in that CSR). */
+	uint64_t es_p                         : 2;  /**< [ES_P] is ES<1:0> for the packet output ring reads that fetch buffer/info pointer pairs
+                                                         (from SLI_PKT()_SLIST_BADDR[ADDR]+). ES<1:0> is the endian-swap attribute for these
+                                                         MAC memory space reads. */
+	uint64_t nsr_p                        : 1;  /**< [NSR_P] is ADDRTYPE<1> for the packet output ring reads that fetch buffer/info pointer
+                                                         pairs (from SLI_PKT()_SLIST_BADDR[ADDR]+). ADDRTYPE<1> is the no-snoop attribute for PCIe. */
+	uint64_t ror_p                        : 1;  /**< [ROR_P] is ADDRTYPE<0> for the packet output ring reads that fetch buffer/info pointer
+                                                         pairs (from SLI_PKT()_SLIST_BADDR[ADDR]+). ADDRTYPE<0> is the relaxed-order attribute
+                                                         for PCIe. */
+	uint64_t enb                          : 1;  /**< Enable for the output ring i. Whenever SLI_PKT(i)_INPUT_CONTROL[RST] is set, hardware
+                                                         forces [ENB] clear.
+                                                         In the PF, [ENB] is also SLI_PKT_OUT_ENB<i>. */
 #else
 	uint64_t enb                          : 1;
 	uint64_t ror_p                        : 1;
@@ -6273,11 +7325,38 @@ union cvmx_sli_pktx_output_control {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_sli_pktx_output_control_s cn73xx;
 	struct cvmx_sli_pktx_output_control_s cn78xx;
 };
 typedef union cvmx_sli_pktx_output_control cvmx_sli_pktx_output_control_t;
 
 /**
+ * cvmx_sli_pkt#_pf_vf_mbox_sig#
+ *
+ * This register is used for communication of data from the VF to the PF
+ * A PF will write to SLI_PKT()_PF_VF_MBOX_SIG().
+ * Each VF may access the same storage using SLIVF_PKT()_VF_PF_MBOX_SIG().
+ * Writes from the PF to SLI_PKT(0..127)_PF_VF_MBOX_SIG(0) will cause an
+ * interrupt to be set in the corresponding SLIVF_PKT(0..7)_MBOX_INT[MBOX_INT],
+ * SLIVF_PKT_IN_DONE()_CNTS[MBOX_INT], SLIVF_PKT()_CNTS[MBOX_INT] fields and
+ * corresponding bit in SLIVF_PKT_MBOX_INT.  Each PF can only access the
+ * rings that its owns as programmed by SLI_PKT_MAC()_RINFO.
+ */
+union cvmx_sli_pktx_pf_vf_mbox_sigx {
+	uint64_t u64;
+	struct cvmx_sli_pktx_pf_vf_mbox_sigx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t data                         : 64; /**< Communication data from PF to VF. Writes to SLI_PKT(0..127)_PF_VF_MBOX_SIG(0)
+                                                         in the corresponding VF. */
+#else
+	uint64_t data                         : 64;
+#endif
+	} s;
+	struct cvmx_sli_pktx_pf_vf_mbox_sigx_s cn73xx;
+};
+typedef union cvmx_sli_pktx_pf_vf_mbox_sigx cvmx_sli_pktx_pf_vf_mbox_sigx_t;
+
+/**
  * cvmx_sli_pkt#_slist_baddr
  *
  * This register contains the start of scatter list for output-packet pointers. This address must
@@ -6302,6 +7381,7 @@ union cvmx_sli_pktx_slist_baddr {
 	struct cvmx_sli_pktx_slist_baddr_s    cn68xxp1;
 	struct cvmx_sli_pktx_slist_baddr_s    cn70xx;
 	struct cvmx_sli_pktx_slist_baddr_s    cn70xxp1;
+	struct cvmx_sli_pktx_slist_baddr_s    cn73xx;
 	struct cvmx_sli_pktx_slist_baddr_s    cn78xx;
 	struct cvmx_sli_pktx_slist_baddr_s    cnf71xx;
 };
@@ -6340,6 +7420,7 @@ union cvmx_sli_pktx_slist_baoff_dbell {
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn68xxp1;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn70xx;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn70xxp1;
+	struct cvmx_sli_pktx_slist_baoff_dbell_s cn73xx;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn78xx;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cnf71xx;
 };
@@ -6369,9 +7450,19 @@ union cvmx_sli_pktx_slist_fifo_rsize {
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cn66xx;
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cn68xx;
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cn68xxp1;
-	struct cvmx_sli_pktx_slist_fifo_rsize_s cn70xx;
-	struct cvmx_sli_pktx_slist_fifo_rsize_s cn70xxp1;
-	struct cvmx_sli_pktx_slist_fifo_rsize_s cn78xx;
+	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_63_32               : 32;
+	uint64_t rsize                        : 32; /**< The number of scatter pointer pairs contained in
+                                                         the scatter list ring. */
+#else
+	uint64_t rsize                        : 32;
+	uint64_t reserved_63_32               : 32;
+#endif
+	} cn70xx;
+	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx cn70xxp1;
+	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx cn73xx;
+	struct cvmx_sli_pktx_slist_fifo_rsize_cn70xx cn78xx;
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cnf71xx;
 };
 typedef union cvmx_sli_pktx_slist_fifo_rsize cvmx_sli_pktx_slist_fifo_rsize_t;
@@ -6379,7 +7470,7 @@ typedef union cvmx_sli_pktx_slist_fifo_rsize cvmx_sli_pktx_slist_fifo_rsize_t;
 /**
  * cvmx_sli_pkt#_vf_sig
  *
- * This register is used to signal between PF/VF. These 64 CSRs are index by VF number.
+ * This register is used to signal between PF/VF. These 64 registers are index by VF number.
  *
  */
 union cvmx_sli_pktx_vf_sig {
@@ -6433,7 +7524,7 @@ union cvmx_sli_pkt_cnt_int {
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cn68xxp1;
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cn70xx;
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cn70xxp1;
-	struct cvmx_sli_pkt_cnt_int_cn78xx {
+	struct cvmx_sli_pkt_cnt_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ring                         : 64; /**< Multi-ring output ring packet counter interrupt bits. RING<i> is one
                                                          whenever SLI_PKT(i)_CNTS[CNT] > SLI_PKT(i)_INT_LEVELS[CNT].
@@ -6441,11 +7532,13 @@ union cvmx_sli_pkt_cnt_int {
                                                          (and SLI_PKT_IN_DONE(i)_CNTS[PO_INT]), and one of the components
                                                          of SLI_PKT_INT[RING<i>]. Hardware may not update RING<i> when
                                                          software modifies SLI_PKT(i)_INT_LEVELS[CNT] - refer to the
-                                                         description of SLI_PKT(0..63)_INT_LEVELS[CNT]. */
+                                                         description of SLI_PKT(0..63)_INT_LEVELS[CNT].
+                                                         SLI_PKT(i)_OUTPUT_CONTROL[CENB] does not affect RING<i>. */
 #else
 	uint64_t ring                         : 64;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_pkt_cnt_int_cn73xx    cn78xx;
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cnf71xx;
 };
 typedef union cvmx_sli_pkt_cnt_int cvmx_sli_pkt_cnt_int_t;
@@ -6752,9 +7845,47 @@ union cvmx_sli_pkt_in_donex_cnts {
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cn66xx;
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cn68xx;
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cn68xxp1;
-	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cn70xx;
-	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cn70xxp1;
-	struct cvmx_sli_pkt_in_donex_cnts_s   cn78xx;
+	struct cvmx_sli_pkt_in_donex_cnts_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_63_32               : 32;
+	uint64_t cnt                          : 32; /**< This field is incrmented by '1' when an instruction
+                                                         is completed. This field is incremented as the
+                                                         last of the data is read from the MAC. */
+#else
+	uint64_t cnt                          : 32;
+	uint64_t reserved_63_32               : 32;
+#endif
+	} cn70xx;
+	struct cvmx_sli_pkt_in_donex_cnts_cn70xx cn70xxp1;
+	struct cvmx_sli_pkt_in_donex_cnts_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t po_int                       : 1;  /**< "Returns a 1 when either the corresponding bit in SLI_PKT_TIME_INT[RING[\#]] or
+                                                         SLI_PKT_CNT_INT[RING[\#]] is set." */
+	uint64_t pi_int                       : 1;  /**< Packet input interrupt bit for the ring. The hardware sets [PI_INT] whenever it updates
+                                                         [CNT<15:0>] to equal [WMARK] when CINT_ENB is set. Writing a 1 clears [PI_INT].
+                                                         [PI_INT] can cause an MSI-X interrupt for the ring, but will never cause an INTA/B/C/D
+                                                         nor MSI interrupt nor set any SLI_INT_SUM bit. SLI_PKT_IN_INT is a multi-ring version of
+                                                         [PI_INT], and [PI_INT] is one component of SLI_PKT_INT. See also
+                                                         SLI_PKT(0..127)_CNTS[PI_INT]. */
+	uint64_t reserved_61_49               : 13;
+	uint64_t cint_enb                     : 1;  /**< Packet input interrupt enable bit for the ring. When [CINT_ENB] is set, the hardware will
+                                                         set [PI_INT] whenever it updates [CNT<15:0>] to equal [WMARK]. When [CINT_ENB]
+                                                         is clear, the hardware will never set [PI_INT]. */
+	uint64_t wmark                        : 16; /**< Packet input interrupt watermark for the ring. If [CINT_ENB] is set, the hardware
+                                                         sets [PI_INT] whenever it updates [CNT<15:0>] to equal [WMARK]. */
+	uint64_t cnt                          : 32; /**< Packet input done count for the ring. The hardware increments [CNT] by one
+                                                         after it finishes reading (from the remote host) an instruction from the ring
+                                                         and all of its associated packet data. */
+#else
+	uint64_t cnt                          : 32;
+	uint64_t wmark                        : 16;
+	uint64_t cint_enb                     : 1;
+	uint64_t reserved_61_49               : 13;
+	uint64_t pi_int                       : 1;
+	uint64_t po_int                       : 1;
+#endif
+	} cn73xx;
+	struct cvmx_sli_pkt_in_donex_cnts_cn73xx cn78xx;
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cnf71xx;
 };
 typedef union cvmx_sli_pkt_in_donex_cnts cvmx_sli_pkt_in_donex_cnts_t;
@@ -6763,7 +7894,7 @@ typedef union cvmx_sli_pkt_in_donex_cnts cvmx_sli_pkt_in_donex_cnts_t;
  * cvmx_sli_pkt_in_instr_counts
  *
  * This register contains keeps track of the number of instructions read into the FIFO and
- * packets sent to PKI.
+ * packets sent to PKI. This register is PF-only.
  */
 union cvmx_sli_pkt_in_instr_counts {
 	uint64_t u64;
@@ -6786,6 +7917,7 @@ union cvmx_sli_pkt_in_instr_counts {
 	struct cvmx_sli_pkt_in_instr_counts_s cn68xxp1;
 	struct cvmx_sli_pkt_in_instr_counts_s cn70xx;
 	struct cvmx_sli_pkt_in_instr_counts_s cn70xxp1;
+	struct cvmx_sli_pkt_in_instr_counts_s cn73xx;
 	struct cvmx_sli_pkt_in_instr_counts_s cn78xx;
 	struct cvmx_sli_pkt_in_instr_counts_s cnf71xx;
 };
@@ -6794,7 +7926,7 @@ typedef union cvmx_sli_pkt_in_instr_counts cvmx_sli_pkt_in_instr_counts_t;
 /**
  * cvmx_sli_pkt_in_int
  *
- * This register specifies which inpit packets rings are interrupting because of done cnts.
+ * This register specifies which input packets rings are interrupting because of done cnts.
  * A bit set in this intterupt register will set a corresponding bit in SLI_PKT_INT which
  * can cause a MSIX interrupt.  When read by a function, this register informs which rings
  * owned by the function (0 to N, N as large as 63) have this interrupt pending.
@@ -6811,6 +7943,7 @@ union cvmx_sli_pkt_in_int {
 	uint64_t ring                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_in_int_s          cn73xx;
 	struct cvmx_sli_pkt_in_int_s          cn78xx;
 };
 typedef union cvmx_sli_pkt_in_int cvmx_sli_pkt_in_int_t;
@@ -7042,8 +8175,8 @@ typedef union cvmx_sli_pkt_input_control cvmx_sli_pkt_input_control_t;
 /**
  * cvmx_sli_pkt_instr_enb
  *
- * This register enables the instruction fetch for a packet ring. This is the PF version; also
- * see SLI_PKT()_INPUT_CONTROL[ENB].
+ * Multi-ring instruction input enable register. This register is PF-only.
+ *
  */
 union cvmx_sli_pkt_instr_enb {
 	uint64_t u64;
@@ -7070,12 +8203,32 @@ union cvmx_sli_pkt_instr_enb {
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn68xxp1;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn70xx;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn70xxp1;
+	struct cvmx_sli_pkt_instr_enb_s       cn73xx;
 	struct cvmx_sli_pkt_instr_enb_s       cn78xx;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_pkt_instr_enb cvmx_sli_pkt_instr_enb_t;
 
 /**
+ * cvmx_sli_pkt_instr_enb2
+ *
+ * Multi-ring instruction input enable register. This register is PF-only.
+ *
+ */
+union cvmx_sli_pkt_instr_enb2 {
+	uint64_t u64;
+	struct cvmx_sli_pkt_instr_enb2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t enb                          : 64; /**< Packet input enables for multiple rings. ENB<i> is also SLI_PKT(i)_INPUT_CONTROL[ENB]. */
+#else
+	uint64_t enb                          : 64;
+#endif
+	} s;
+	struct cvmx_sli_pkt_instr_enb2_s      cn73xx;
+};
+typedef union cvmx_sli_pkt_instr_enb2 cvmx_sli_pkt_instr_enb2_t;
+
+/**
  * cvmx_sli_pkt_instr_rd_size
  *
  * The number of instruction allowed to be read at one time.
@@ -7148,8 +8301,6 @@ typedef union cvmx_sli_pkt_instr_size cvmx_sli_pkt_instr_size_t;
  * This register combines the SLI_PKT_CNT_INT, SLI_PKT_TIME_INT or SLI_PKT_IN_INT interrupt
  * registers. When read by a function, this register informs which rings owned by the function
  * (0 to N, N as large as 63) have an interrupt pending.
- * attributes:
- * vf_reg_type: "bw"
  */
 union cvmx_sli_pkt_int {
 	uint64_t u64;
@@ -7164,11 +8315,13 @@ union cvmx_sli_pkt_int {
                                                           * SLI_PKT_IN_DONE(i)_CNTS[PI_INT] (i.e. SLI_PKT_IN_INT<i>) is set.
                                                          Any of these three conditions can cause an MSI-X interrupt, but only
                                                          the first two (i.e. SLI_PKT_CNT_INT and SLI_PKT_TIME_INT) can cause
-                                                         INTA/B/C/D and MSI interrupts. */
+                                                         INTA/B/C/D and MSI interrupts.
+                                                         SLI_PKT(i)_OUTPUT_CONTROL[CENB,TENB] have no effect on RING<i>. */
 #else
 	uint64_t ring                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_int_s             cn73xx;
 	struct cvmx_sli_pkt_int_s             cn78xx;
 };
 typedef union cvmx_sli_pkt_int cvmx_sli_pkt_int_t;
@@ -7239,10 +8392,40 @@ union cvmx_sli_pkt_iptr {
 typedef union cvmx_sli_pkt_iptr cvmx_sli_pkt_iptr_t;
 
 /**
+ * cvmx_sli_pkt_mac#_pf#_rinfo
+ *
+ * This register sets the total number and starting number of rings for a given MAC and PF
+ * combination.
+ * CNXXXX valid copies are MAC0 PF0, MAC0 PF1, MAC1 PF0, MAC2 PF0, MAC3 PF3.
+ */
+union cvmx_sli_pkt_macx_pfx_rinfo {
+	uint64_t u64;
+	struct cvmx_sli_pkt_macx_pfx_rinfo_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t rpvf                         : 8;  /**< The number of rings assigned to a VF for this MAC. Legal values are 0 to 64. */
+	uint64_t reserved_24_31               : 8;
+	uint64_t trs                          : 8;  /**< The number of rings assigned to the MAC. Legal value are 0 to 64. */
+	uint64_t reserved_7_15                : 9;
+	uint64_t srn                          : 7;  /**< The starting ring number used by the MAC. Legal value are 0 to 63. */
+#else
+	uint64_t srn                          : 7;
+	uint64_t reserved_7_15                : 9;
+	uint64_t trs                          : 8;
+	uint64_t reserved_24_31               : 8;
+	uint64_t rpvf                         : 8;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} s;
+	struct cvmx_sli_pkt_macx_pfx_rinfo_s  cn73xx;
+};
+typedef union cvmx_sli_pkt_macx_pfx_rinfo cvmx_sli_pkt_macx_pfx_rinfo_t;
+
+/**
  * cvmx_sli_pkt_mac#_rinfo
  *
  * This register sets the total number and starting number of rings used by the MAC.
- *
+ * This register is PF-only.
  */
 union cvmx_sli_pkt_macx_rinfo {
 	uint64_t u64;
@@ -7270,8 +8453,8 @@ typedef union cvmx_sli_pkt_macx_rinfo cvmx_sli_pkt_macx_rinfo_t;
 /**
  * cvmx_sli_pkt_mac0_sig0
  *
- * This register is used to signal between PF/VF. This CSR can be R/W by the PF from MAC0 and any VF.
- *
+ * This register is used to signal between PF/VF. This register can be R/W by the PF from MAC0
+ * and any VF.
  */
 union cvmx_sli_pkt_mac0_sig0 {
 	uint64_t u64;
@@ -7289,8 +8472,8 @@ typedef union cvmx_sli_pkt_mac0_sig0 cvmx_sli_pkt_mac0_sig0_t;
 /**
  * cvmx_sli_pkt_mac0_sig1
  *
- * This register is used to signal between PF/VF. This CSR can be R/W by the PF from MAC0 and any VF.
- *
+ * This register is used to signal between PF/VF. This register can be R/W by the PF from MAC0
+ * and any VF.
  */
 union cvmx_sli_pkt_mac0_sig1 {
 	uint64_t u64;
@@ -7308,8 +8491,8 @@ typedef union cvmx_sli_pkt_mac0_sig1 cvmx_sli_pkt_mac0_sig1_t;
 /**
  * cvmx_sli_pkt_mac1_sig0
  *
- * This register is used to signal between PF/VF. This CSR can be R/W by the PF from MAC1 and any VF.
- *
+ * This register is used to signal between PF/VF. This register can be R/W by the PF from MAC1
+ * and any VF.
  */
 union cvmx_sli_pkt_mac1_sig0 {
 	uint64_t u64;
@@ -7327,8 +8510,8 @@ typedef union cvmx_sli_pkt_mac1_sig0 cvmx_sli_pkt_mac1_sig0_t;
 /**
  * cvmx_sli_pkt_mac1_sig1
  *
- * This register is used to signal between PF/VF. This CSR can be R/W by the PF from MAC1 and any VF.
- *
+ * This register is used to signal between PF/VF. This register can be R/W by the PF from MAC1
+ * and any VF.
  */
 union cvmx_sli_pkt_mac1_sig1 {
 	uint64_t u64;
@@ -7416,6 +8599,7 @@ union cvmx_sli_pkt_mem_ctl {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_sli_pkt_mem_ctl_s         cn73xx;
 	struct cvmx_sli_pkt_mem_ctl_s         cn78xx;
 };
 typedef union cvmx_sli_pkt_mem_ctl cvmx_sli_pkt_mem_ctl_t;
@@ -7464,7 +8648,7 @@ union cvmx_sli_pkt_out_bp_en {
 	struct cvmx_sli_pkt_out_bp_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t bp_en                        : 64; /**< When set, enable the channel-level backpressure to be sent to PKO. Backpressure is sent to
-                                                         the PKO on the channels 0x100-0x13F. */
+                                                         the PKO on the channels 0x100-0x13F. See SLI_PKT_OUTPUT_WMARK[WMARK]. */
 #else
 	uint64_t bp_en                        : 64;
 #endif
@@ -7482,11 +8666,32 @@ union cvmx_sli_pkt_out_bp_en {
 #endif
 	} cn68xx;
 	struct cvmx_sli_pkt_out_bp_en_cn68xx  cn68xxp1;
+	struct cvmx_sli_pkt_out_bp_en_s       cn73xx;
 	struct cvmx_sli_pkt_out_bp_en_s       cn78xx;
 };
 typedef union cvmx_sli_pkt_out_bp_en cvmx_sli_pkt_out_bp_en_t;
 
 /**
+ * cvmx_sli_pkt_out_bp_en2
+ *
+ * This register enables sending backpressure to PKO.
+ *
+ */
+union cvmx_sli_pkt_out_bp_en2 {
+	uint64_t u64;
+	struct cvmx_sli_pkt_out_bp_en2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t bp_en                        : 64; /**< When set, enable the channel-level backpressure to be sent to PKO. Backpressure is sent to
+                                                         the PKO on the channels 0x140-0x17F. See SLI_PKT_OUTPUT_WMARK[WMARK]. */
+#else
+	uint64_t bp_en                        : 64;
+#endif
+	} s;
+	struct cvmx_sli_pkt_out_bp_en2_s      cn73xx;
+};
+typedef union cvmx_sli_pkt_out_bp_en2 cvmx_sli_pkt_out_bp_en2_t;
+
+/**
  * cvmx_sli_pkt_out_enb
  *
  * This register enables the output packet engines. This is the PF version; also see
@@ -7523,17 +8728,37 @@ union cvmx_sli_pkt_out_enb {
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn68xxp1;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn70xx;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn70xxp1;
+	struct cvmx_sli_pkt_out_enb_s         cn73xx;
 	struct cvmx_sli_pkt_out_enb_s         cn78xx;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cnf71xx;
 };
 typedef union cvmx_sli_pkt_out_enb cvmx_sli_pkt_out_enb_t;
 
 /**
+ * cvmx_sli_pkt_out_enb2
+ *
+ * This register enables the output packet engines. This is the PF version; also see
+ * SLI_PKT()_OUTPUT_CONTROL[ENB].
+ */
+union cvmx_sli_pkt_out_enb2 {
+	uint64_t u64;
+	struct cvmx_sli_pkt_out_enb2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t enb                          : 64; /**< Packet output enables for multiple rings. ENB<i> is also SLI_PKT(i)_OUTPUT_CONTROL[ENB]. */
+#else
+	uint64_t enb                          : 64;
+#endif
+	} s;
+	struct cvmx_sli_pkt_out_enb2_s        cn73xx;
+};
+typedef union cvmx_sli_pkt_out_enb2 cvmx_sli_pkt_out_enb2_t;
+
+/**
  * cvmx_sli_pkt_output_wmark
  *
  * This register sets the value that determines when backpressure is applied to the PKO. When
  * SLI_PKT()_SLIST_BAOFF_DBELL[DBELL] is less than [WMARK], backpressure is sent to PKO for
- * the associated channel.
+ * the associated channel. This register is PF-only.
  */
 union cvmx_sli_pkt_output_wmark {
 	uint64_t u64;
@@ -7555,6 +8780,7 @@ union cvmx_sli_pkt_output_wmark {
 	struct cvmx_sli_pkt_output_wmark_s    cn68xxp1;
 	struct cvmx_sli_pkt_output_wmark_s    cn70xx;
 	struct cvmx_sli_pkt_output_wmark_s    cn70xxp1;
+	struct cvmx_sli_pkt_output_wmark_s    cn73xx;
 	struct cvmx_sli_pkt_output_wmark_s    cn78xx;
 	struct cvmx_sli_pkt_output_wmark_s    cnf71xx;
 };
@@ -7632,11 +8858,12 @@ union cvmx_sli_pkt_ring_rst {
 	uint64_t u64;
 	struct cvmx_sli_pkt_ring_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t rst                          : 64; /**< Ring in reset. When asserted 1, the vector bit corresponding to the packet ring is in reset. */
+	uint64_t rst                          : 64; /**< RST<i> is a RO copy of SLI_PKT(i)_INPUT_CONTROL[RST]. */
 #else
 	uint64_t rst                          : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_ring_rst_s        cn73xx;
 	struct cvmx_sli_pkt_ring_rst_s        cn78xx;
 };
 typedef union cvmx_sli_pkt_ring_rst cvmx_sli_pkt_ring_rst_t;
@@ -7785,7 +9012,7 @@ union cvmx_sli_pkt_time_int {
 	struct cvmx_sli_pkt_time_int_cn61xx   cn68xxp1;
 	struct cvmx_sli_pkt_time_int_cn61xx   cn70xx;
 	struct cvmx_sli_pkt_time_int_cn61xx   cn70xxp1;
-	struct cvmx_sli_pkt_time_int_cn78xx {
+	struct cvmx_sli_pkt_time_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ring                         : 64; /**< Multi-ring output ring packet time interrupt bits. RING<i> reads as one
                                                          whenever SLI_PKT(i)_CNTS[TIMER] > SLI_PKT(i)_INT_LEVELS[TIME].
@@ -7793,11 +9020,13 @@ union cvmx_sli_pkt_time_int {
                                                          (and SLI_PKT_IN_DONE(i)_CNTS[PO_INT]), and one of the components
                                                          of SLI_PKT_INT[RING<i>]. Hardware may not update RING<i> when
                                                          software modifies SLI_PKT(i)_INT_LEVELS[TIME] - refer to the
-                                                         description of SLI_PKT(0..63)_INT_LEVELS[TIME]. */
+                                                         description of SLI_PKT(0..63)_INT_LEVELS[TIME].
+                                                         SLI_PKT(i)_OUTPUT_CONTROL[TENB] does not affect RING<i>. */
 #else
 	uint64_t ring                         : 64;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_pkt_time_int_cn73xx   cn78xx;
 	struct cvmx_sli_pkt_time_int_cn61xx   cnf71xx;
 };
 typedef union cvmx_sli_pkt_time_int cvmx_sli_pkt_time_int_t;
@@ -7836,6 +9065,25 @@ union cvmx_sli_pkt_time_int_enb {
 typedef union cvmx_sli_pkt_time_int_enb cvmx_sli_pkt_time_int_enb_t;
 
 /**
+ * cvmx_sli_pkt_vf_sig_int
+ *
+ * attributes:
+ * vf_reg_type: "bw"
+ */
+union cvmx_sli_pkt_vf_sig_int {
+	uint64_t u64;
+	struct cvmx_sli_pkt_vf_sig_int_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ring                         : 64; /**< When a PF or VF writes to a SLI_PKT(0..127)_VF_SIG2 register */
+#else
+	uint64_t ring                         : 64;
+#endif
+	} s;
+	struct cvmx_sli_pkt_vf_sig_int_s      cn73xx;
+};
+typedef union cvmx_sli_pkt_vf_sig_int cvmx_sli_pkt_vf_sig_int_t;
+
+/**
  * cvmx_sli_port#_pkind
  *
  * SLI_PORT[0..31]_PKIND = SLI Port Pkind
@@ -7911,6 +9159,7 @@ union cvmx_sli_s2c_end_merge {
 	uint64_t reserved_0_63                : 64;
 #endif
 	} s;
+	struct cvmx_sli_s2c_end_merge_s       cn73xx;
 	struct cvmx_sli_s2c_end_merge_s       cn78xx;
 };
 typedef union cvmx_sli_s2c_end_merge cvmx_sli_s2c_end_merge_t;
@@ -7929,7 +9178,7 @@ union cvmx_sli_s2m_portx_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
 	uint64_t lcl_node                     : 1;  /**< Local CCPI node. When set to 1, all window access is treated as local CCPI
-                                                         access. Normally, if address bits [37:36] of the window address CSRs are not
+                                                         access. Normally, if address bits [37:36] of the window address registers are not
                                                          equal to the chip's CCPI value, the window operation is sent to the CCPI for
                                                          remote chip access. This field, when set, disables this and treats all access to
                                                          be for the local CCPI. */
@@ -7993,7 +9242,7 @@ union cvmx_sli_s2m_portx_ctl {
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cn68xxp1;
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cn70xx;
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cn70xxp1;
-	struct cvmx_sli_s2m_portx_ctl_cn78xx {
+	struct cvmx_sli_s2m_portx_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
 	uint64_t lcl_node                     : 1;  /**< Local CCPI node. When set to 1, all window access is treated as local CCPI
@@ -8004,9 +9253,10 @@ union cvmx_sli_s2m_portx_ctl {
 	uint64_t wind_d                       : 1;  /**< Window disable. When set to 1, disables access to the window registers from the MAC port. */
 	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set to 1, disables access from the MAC to BAR0 for the following
                                                          address offsets:
-                                                         * 0x0-0x32F.
-                                                         * 0x3CD0.
-                                                         * greater than 0x3D70, excluding 0x3E00. */
+                                                         * 20000-20040
+                                                         * 28020-282F0
+                                                         * 286E0
+                                                         * 25000 */
 	uint64_t ld_cmd                       : 2;  /**< When SLI issues a load command to the L2C that is to be cached, this field selects the
                                                          type of load command to use:
                                                          0x0 = LDD.
@@ -8022,7 +9272,8 @@ union cvmx_sli_s2m_portx_ctl {
 	uint64_t lcl_node                     : 1;
 	uint64_t reserved_6_63                : 58;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_s2m_portx_ctl_cn73xx  cn78xx;
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_s2m_portx_ctl cvmx_sli_s2m_portx_ctl_t;
@@ -8050,6 +9301,7 @@ union cvmx_sli_scratch_1 {
 	struct cvmx_sli_scratch_1_s           cn68xxp1;
 	struct cvmx_sli_scratch_1_s           cn70xx;
 	struct cvmx_sli_scratch_1_s           cn70xxp1;
+	struct cvmx_sli_scratch_1_s           cn73xx;
 	struct cvmx_sli_scratch_1_s           cn78xx;
 	struct cvmx_sli_scratch_1_s           cnf71xx;
 };
@@ -8078,6 +9330,7 @@ union cvmx_sli_scratch_2 {
 	struct cvmx_sli_scratch_2_s           cn68xxp1;
 	struct cvmx_sli_scratch_2_s           cn70xx;
 	struct cvmx_sli_scratch_2_s           cn70xxp1;
+	struct cvmx_sli_scratch_2_s           cn73xx;
 	struct cvmx_sli_scratch_2_s           cn78xx;
 	struct cvmx_sli_scratch_2_s           cnf71xx;
 };
@@ -8112,6 +9365,7 @@ union cvmx_sli_state1 {
 	struct cvmx_sli_state1_s              cn68xxp1;
 	struct cvmx_sli_state1_s              cn70xx;
 	struct cvmx_sli_state1_s              cn70xxp1;
+	struct cvmx_sli_state1_s              cn73xx;
 	struct cvmx_sli_state1_s              cn78xx;
 	struct cvmx_sli_state1_s              cnf71xx;
 };
@@ -8160,7 +9414,7 @@ union cvmx_sli_state2 {
 	struct cvmx_sli_state2_cn61xx         cn68xxp1;
 	struct cvmx_sli_state2_cn61xx         cn70xx;
 	struct cvmx_sli_state2_cn61xx         cn70xxp1;
-	struct cvmx_sli_state2_cn78xx {
+	struct cvmx_sli_state2_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_57_63               : 7;
 	uint64_t nnp1                         : 8;  /**< NNP1 state. */
@@ -8180,7 +9434,8 @@ union cvmx_sli_state2 {
 	uint64_t nnp1                         : 8;
 	uint64_t reserved_57_63               : 7;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_state2_cn73xx         cn78xx;
 	struct cvmx_sli_state2_cn61xx         cnf71xx;
 };
 typedef union cvmx_sli_state2 cvmx_sli_state2_t;
@@ -8222,7 +9477,7 @@ union cvmx_sli_state3 {
 	struct cvmx_sli_state3_cn61xx         cn68xxp1;
 	struct cvmx_sli_state3_cn61xx         cn70xx;
 	struct cvmx_sli_state3_cn61xx         cn70xxp1;
-	struct cvmx_sli_state3_cn78xx {
+	struct cvmx_sli_state3_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t psm1                         : 15; /**< PSM1 state. */
@@ -8236,7 +9491,8 @@ union cvmx_sli_state3 {
 	uint64_t psm1                         : 15;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_state3_cn73xx         cn78xx;
 	struct cvmx_sli_state3_cn61xx         cnf71xx;
 };
 typedef union cvmx_sli_state3 cvmx_sli_state3_t;
@@ -8290,8 +9546,10 @@ typedef union cvmx_sli_tx_pipe cvmx_sli_tx_pipe_t;
 /**
  * cvmx_sli_win_rd_addr
  *
- * When the LSB of this CSR is written, the address in this CSR will be read. The data returned
- * from this read will be placed in the WIN_RD_DATA CSR. This CSR should NOT be used to read
+ * When the LSB of this register is written, the address in this register will be read. The data
+ * returned
+ * from this read will be placed in the WIN_RD_DATA register. This register should NOT be used to
+ * read
  * SLI_* registers.
  *
  * If SLI_S2M_PORT()_CTL[LCL_NODE] the MAC that it is set for will not be able to write
@@ -8329,6 +9587,7 @@ union cvmx_sli_win_rd_addr {
 	struct cvmx_sli_win_rd_addr_s         cn68xxp1;
 	struct cvmx_sli_win_rd_addr_s         cn70xx;
 	struct cvmx_sli_win_rd_addr_s         cn70xxp1;
+	struct cvmx_sli_win_rd_addr_s         cn73xx;
 	struct cvmx_sli_win_rd_addr_s         cn78xx;
 	struct cvmx_sli_win_rd_addr_s         cnf71xx;
 };
@@ -8337,8 +9596,8 @@ typedef union cvmx_sli_win_rd_addr cvmx_sli_win_rd_addr_t;
 /**
  * cvmx_sli_win_rd_data
  *
- * This CSR holds the data returned when a read operation is started by the writing of the
- * SLI_WIN_RD_ADDR CSR.
+ * This register holds the data returned when a read operation is started by the writing of the
+ * SLI_WIN_RD_ADDR register.
  */
 union cvmx_sli_win_rd_data {
 	uint64_t u64;
@@ -8357,6 +9616,7 @@ union cvmx_sli_win_rd_data {
 	struct cvmx_sli_win_rd_data_s         cn68xxp1;
 	struct cvmx_sli_win_rd_data_s         cn70xx;
 	struct cvmx_sli_win_rd_data_s         cn70xxp1;
+	struct cvmx_sli_win_rd_data_s         cn73xx;
 	struct cvmx_sli_win_rd_data_s         cn78xx;
 	struct cvmx_sli_win_rd_data_s         cnf71xx;
 };
@@ -8412,6 +9672,7 @@ union cvmx_sli_win_wr_addr {
 	struct cvmx_sli_win_wr_addr_s         cn68xxp1;
 	struct cvmx_sli_win_wr_addr_s         cn70xx;
 	struct cvmx_sli_win_wr_addr_s         cn70xxp1;
+	struct cvmx_sli_win_wr_addr_s         cn73xx;
 	struct cvmx_sli_win_wr_addr_s         cn78xx;
 	struct cvmx_sli_win_wr_addr_s         cnf71xx;
 };
@@ -8443,6 +9704,7 @@ union cvmx_sli_win_wr_data {
 	struct cvmx_sli_win_wr_data_s         cn68xxp1;
 	struct cvmx_sli_win_wr_data_s         cn70xx;
 	struct cvmx_sli_win_wr_data_s         cn70xxp1;
+	struct cvmx_sli_win_wr_data_s         cn73xx;
 	struct cvmx_sli_win_wr_data_s         cn78xx;
 	struct cvmx_sli_win_wr_data_s         cnf71xx;
 };
@@ -8477,6 +9739,7 @@ union cvmx_sli_win_wr_mask {
 	struct cvmx_sli_win_wr_mask_s         cn68xxp1;
 	struct cvmx_sli_win_wr_mask_s         cn70xx;
 	struct cvmx_sli_win_wr_mask_s         cn70xxp1;
+	struct cvmx_sli_win_wr_mask_s         cn73xx;
 	struct cvmx_sli_win_wr_mask_s         cn78xx;
 	struct cvmx_sli_win_wr_mask_s         cnf71xx;
 };
@@ -8525,6 +9788,7 @@ union cvmx_sli_window_ctl {
 	struct cvmx_sli_window_ctl_cn61xx     cn68xxp1;
 	struct cvmx_sli_window_ctl_cn61xx     cn70xx;
 	struct cvmx_sli_window_ctl_cn61xx     cn70xxp1;
+	struct cvmx_sli_window_ctl_s          cn73xx;
 	struct cvmx_sli_window_ctl_s          cn78xx;
 	struct cvmx_sli_window_ctl_cn61xx     cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-smix-defs.h b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
index 5583676..dfcb582 100644
--- a/arch/mips/include/asm/octeon/cvmx-smix-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
@@ -79,6 +79,10 @@ static inline uint64_t CVMX_SMIX_CLK(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_CLK (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001818ull) + ((offset) & 1) * 256;
@@ -104,6 +108,8 @@ static inline uint64_t CVMX_SMIX_CLK(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001818ull) + (offset) * 256;
 }
@@ -135,6 +141,10 @@ static inline uint64_t CVMX_SMIX_CMD(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_CMD (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001800ull) + ((offset) & 1) * 256;
@@ -160,6 +170,8 @@ static inline uint64_t CVMX_SMIX_CMD(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001800ull) + (offset) * 256;
 }
@@ -191,6 +203,10 @@ static inline uint64_t CVMX_SMIX_EN(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_EN (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001820ull) + ((offset) & 1) * 256;
@@ -216,6 +232,8 @@ static inline uint64_t CVMX_SMIX_EN(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001820ull) + (offset) * 256;
 }
@@ -247,6 +265,10 @@ static inline uint64_t CVMX_SMIX_RD_DAT(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_RD_DAT (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001810ull) + ((offset) & 1) * 256;
@@ -272,6 +294,8 @@ static inline uint64_t CVMX_SMIX_RD_DAT(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001810ull) + (offset) * 256;
 }
@@ -303,6 +327,10 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_WR_DAT (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001808ull) + ((offset) & 1) * 256;
@@ -328,6 +356,8 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001808ull) + (offset) * 256;
 }
@@ -440,6 +470,7 @@ union cvmx_smix_clk {
 	struct cvmx_smix_clk_s                cn68xxp1;
 	struct cvmx_smix_clk_s                cn70xx;
 	struct cvmx_smix_clk_s                cn70xxp1;
+	struct cvmx_smix_clk_s                cn73xx;
 	struct cvmx_smix_clk_s                cn78xx;
 	struct cvmx_smix_clk_s                cnf71xx;
 };
@@ -516,6 +547,7 @@ union cvmx_smix_cmd {
 	struct cvmx_smix_cmd_s                cn68xxp1;
 	struct cvmx_smix_cmd_s                cn70xx;
 	struct cvmx_smix_cmd_s                cn70xxp1;
+	struct cvmx_smix_cmd_s                cn73xx;
 	struct cvmx_smix_cmd_s                cn78xx;
 	struct cvmx_smix_cmd_s                cnf71xx;
 };
@@ -559,6 +591,7 @@ union cvmx_smix_en {
 	struct cvmx_smix_en_s                 cn68xxp1;
 	struct cvmx_smix_en_s                 cn70xx;
 	struct cvmx_smix_en_s                 cn70xxp1;
+	struct cvmx_smix_en_s                 cn73xx;
 	struct cvmx_smix_en_s                 cn78xx;
 	struct cvmx_smix_en_s                 cnf71xx;
 };
@@ -604,6 +637,7 @@ union cvmx_smix_rd_dat {
 	struct cvmx_smix_rd_dat_s             cn68xxp1;
 	struct cvmx_smix_rd_dat_s             cn70xx;
 	struct cvmx_smix_rd_dat_s             cn70xxp1;
+	struct cvmx_smix_rd_dat_s             cn73xx;
 	struct cvmx_smix_rd_dat_s             cn78xx;
 	struct cvmx_smix_rd_dat_s             cnf71xx;
 };
@@ -649,6 +683,7 @@ union cvmx_smix_wr_dat {
 	struct cvmx_smix_wr_dat_s             cn68xxp1;
 	struct cvmx_smix_wr_dat_s             cn70xx;
 	struct cvmx_smix_wr_dat_s             cn70xxp1;
+	struct cvmx_smix_wr_dat_s             cn73xx;
 	struct cvmx_smix_wr_dat_s             cn78xx;
 	struct cvmx_smix_wr_dat_s             cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-spinlock.h b/arch/mips/include/asm/octeon/cvmx-spinlock.h
index 5d1d439..5bf8788 100644
--- a/arch/mips/include/asm/octeon/cvmx-spinlock.h
+++ b/arch/mips/include/asm/octeon/cvmx-spinlock.h
@@ -42,7 +42,7 @@
  *
  * Implementation of spinlocks.
  *
- * <hr>$Revision: 107108 $<hr>
+ * <hr>$Revision: 108918 $<hr>
  */
 
 #ifndef __CVMX_SPINLOCK_H__
@@ -392,6 +392,162 @@ static inline void cvmx_spinlock_rec_lock(cvmx_spinlock_rec_t * lock)
 
 }
 
+
+/*
+ * New style spinlock implementation using C11 standard atomic
+ * operations.
+ * This spinlock is much faster and fair.
+ * Note these can be used on the host or target but they require
+ * GCC 4.7 and above.
+ * @EXPERIMENTAL
+ */
+
+/* This is only supported for GCC 4.7 and above.  */
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)
+
+/* Include stdatomic if we are using C11 toolchain.  */
+#if defined(__GNUC__) && !defined(__HAS_ATOMIC)
+# if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 9)
+#  include <stdatomic.h>
+#  define __HAS_ATOMIC
+# endif
+#endif
+
+#ifndef __HAS_ATOMIC
+/* Used for readability from C11, define our own versions.
+ * Documentation on the atomic functions built into GCC 4.7 found here:
+ * http://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/_005f_005fatomic-Builtins.html
+ */
+#undef _Atomic
+#define	_Atomic
+#define atomic_fetch_sub_explicit(PTR,VAL,AMM) \
+  __atomic_fetch_sub ((PTR), (VAL), (AMM))
+#define atomic_fetch_add_explicit(PTR,VAL,AMM) \
+  __atomic_fetch_add ((PTR), (VAL), (AMM))
+#define atomic_store_explicit(PTR,VAL,AMM) \
+  __atomic_store_n((PTR), (VAL), (AMM))
+#define atomic_exchange_explicit(PTR,VAL,AMM) \
+  __atomic_exchange_n((PTR), (VAL), (AMM))
+#define atomic_compare_exchange_strong_explicit(PTR,EXP,DES,SUCC,FAIL) \
+  (__atomic_compare_exchange_n((PTR),(EXP),(DES),1,(SUCC),FAIL))
+#define atomic_load_explicit(PTR,AMM) __atomic_load_n((PTR), (AMM))
+
+#define memory_order_seq_cst __ATOMIC_SEQ_CST
+#define memory_order_acquire __ATOMIC_ACQUIRE
+#define memory_order_release __ATOMIC_RELEASE
+#define memory_order_relaxed __ATOMIC_RELAXED
+
+#endif /* !__HAS_ATOMIC */
+
+/*
+ * Atomic fair spinlock type
+ *
+ * Two atomic 64-bit counters are used.
+ * When the counters are equal, the spinlock is free.
+ * A lock operation increments the 'ticket_waiter" counter,
+ * and waits until 'ticket_server' catches up to the pre-increment
+ * value of the 'ticket_waiter'
+ * An unlock operation increments 'ticket_server'.
+ */
+typedef struct {
+	_Atomic unsigned long long
+		ticket_waiter, ticket_server;
+} cvmx_atomic_spinlock_t;
+
+#define CVMX_ATOMIC_SPINLOCK_UNLOCKED_INITIALIZER \
+	((cvmx_atomic_spinlock_t) {0ull, 0ull})
+
+/**
+ * Initialize a spinlock to unlocked state
+ */
+static inline void cvmx_atomic_spinlock_init(cvmx_atomic_spinlock_t *lock)
+{
+	atomic_store_explicit(&lock->ticket_waiter, 0, memory_order_relaxed);
+	atomic_store_explicit(&lock->ticket_server, 0, memory_order_release);
+}
+
+/**
+ * Check if a spinlock is busy
+ *
+ * @return non-zero if the spinlock is busy, 0 if it is free
+ */
+static inline int cvmx_atomic_spinlock_locked(cvmx_atomic_spinlock_t * lock)
+{
+	unsigned long long ticket;
+
+	ticket =
+	    atomic_load_explicit(&lock->ticket_server,
+		memory_order_relaxed);
+
+	return
+	    ticket !=
+	        atomic_load_explicit(&lock->ticket_waiter,
+			memory_order_acquire);
+}
+
+/**
+ * Acquire a lock, wait if needed
+ *
+ */
+static inline void cvmx_atomic_spinlock_lock(cvmx_atomic_spinlock_t *lock)
+{
+	unsigned long long ticket;
+
+	ticket = atomic_fetch_add_explicit(&lock->ticket_waiter, 1,
+		memory_order_relaxed);
+
+	while (ticket != atomic_load_explicit(&lock->ticket_server,
+		memory_order_acquire))
+		/* do nothing */ ;
+
+}
+
+/**
+ * Release a lock
+ *
+ */
+static inline void cvmx_atomic_spinlock_unlock(cvmx_atomic_spinlock_t * lock)
+{
+	/* Previous value not needed, but this is the only standard add call */
+	(void) atomic_fetch_add_explicit(&lock->ticket_server, 1,
+		memory_order_release);
+}
+
+/**
+ * Try to acquire the lock without blocking
+ *
+ * @return 0 on soccess
+ *         1: lock not taken, held by someone else
+ *        
+ */
+static inline int cvmx_atomic_spinlock_trylock(cvmx_atomic_spinlock_t *lock)
+{
+	unsigned long long waiter, server;
+
+	waiter = atomic_load_explicit(&lock->ticket_waiter,
+		memory_order_acquire);
+	server = atomic_load_explicit(&lock->ticket_server,
+		memory_order_acquire);
+
+	/* If tickets differ, the lock is busy */
+	if (waiter != server)
+		return 1;
+
+	/* If 'ticket_waiter" has moved since the first load,
+	 * it means at least that someone tried to acquire the lock,
+	 * so we lose.
+	 * If nobody touched it, means it is still free, and we
+	 * take the lock by incremebting it.
+	 */
+	return (!atomic_compare_exchange_strong_explicit(
+			&lock->ticket_waiter,
+			&waiter, waiter+1,
+			memory_order_seq_cst, memory_order_relaxed));
+}
+
+#endif
+
+
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-spxx-defs.h b/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
index 11f2cb1..20604f3 100644
--- a/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
@@ -53,196 +53,196 @@
 #define __CVMX_SPXX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_BCKPRS_CNT(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_BCKPRS_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_BCKPRS_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000340ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_BCKPRS_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000340ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_BCKPRS_CNT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000340ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_BCKPRS_CNT(offset) (CVMX_ADD_IO_SEG(0x0001180090000340ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_BIST_STAT(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_BIST_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_BIST_STAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800900007F8ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_BIST_STAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800900007F8ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_BIST_STAT(block_id) (CVMX_ADD_IO_SEG(0x00011800900007F8ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_BIST_STAT(offset) (CVMX_ADD_IO_SEG(0x00011800900007F8ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_CLK_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_CLK_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_CLK_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000348ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_CLK_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000348ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_CLK_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000348ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_CLK_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000348ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_CLK_STAT(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_CLK_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_CLK_STAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000350ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_CLK_STAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000350ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_CLK_STAT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000350ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_CLK_STAT(offset) (CVMX_ADD_IO_SEG(0x0001180090000350ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_DBG_DESKEW_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_DBG_DESKEW_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_DBG_DESKEW_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000368ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_DBG_DESKEW_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000368ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_DBG_DESKEW_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000368ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_DBG_DESKEW_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000368ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_DBG_DESKEW_STATE(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_DBG_DESKEW_STATE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_DBG_DESKEW_STATE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000370ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_DBG_DESKEW_STATE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000370ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_DBG_DESKEW_STATE(block_id) (CVMX_ADD_IO_SEG(0x0001180090000370ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_DBG_DESKEW_STATE(offset) (CVMX_ADD_IO_SEG(0x0001180090000370ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_DRV_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_DRV_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_DRV_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000358ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_DRV_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000358ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_DRV_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000358ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_DRV_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000358ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_ERR_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_ERR_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_ERR_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000320ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_ERR_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000320ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_ERR_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000320ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_ERR_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000320ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_INT_DAT(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_INT_DAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_INT_DAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000318ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_INT_DAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000318ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_INT_DAT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000318ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_INT_DAT(offset) (CVMX_ADD_IO_SEG(0x0001180090000318ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_INT_MSK(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_INT_MSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_INT_MSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_INT_MSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_INT_MSK(block_id) (CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_INT_MSK(offset) (CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_INT_REG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_INT_REG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_INT_REG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_INT_REG(block_id) (CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_INT_REG(offset) (CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_INT_SYNC(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_INT_SYNC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_INT_SYNC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000310ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_INT_SYNC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000310ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_INT_SYNC(block_id) (CVMX_ADD_IO_SEG(0x0001180090000310ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_INT_SYNC(offset) (CVMX_ADD_IO_SEG(0x0001180090000310ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_TPA_ACC(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_TPA_ACC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_TPA_ACC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000338ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_TPA_ACC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000338ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_TPA_ACC(block_id) (CVMX_ADD_IO_SEG(0x0001180090000338ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_TPA_ACC(offset) (CVMX_ADD_IO_SEG(0x0001180090000338ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_TPA_MAX(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_TPA_MAX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_TPA_MAX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000330ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_TPA_MAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000330ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_TPA_MAX(block_id) (CVMX_ADD_IO_SEG(0x0001180090000330ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_TPA_MAX(offset) (CVMX_ADD_IO_SEG(0x0001180090000330ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_TPA_SEL(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_TPA_SEL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_TPA_SEL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000328ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_TPA_SEL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000328ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_TPA_SEL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000328ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_TPA_SEL(offset) (CVMX_ADD_IO_SEG(0x0001180090000328ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SPXX_TRN4_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SPXX_TRN4_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SPXX_TRN4_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000360ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SPXX_TRN4_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000360ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SPXX_TRN4_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000360ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SPXX_TRN4_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000360ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
index f382a85..3438a9a 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
@@ -53,28 +53,28 @@
 #define __CVMX_SRIOMAINTX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ASMBLY_ID(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ASMBLY_ID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ASMBLY_ID(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ASMBLY_ID(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000008ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ASMBLY_ID(block_id) (0x0000000000000008ull)
+#define CVMX_SRIOMAINTX_ASMBLY_ID(offset) (0x0000000000000008ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ASMBLY_INFO(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ASMBLY_INFO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ASMBLY_INFO(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ASMBLY_INFO(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000000Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_ASMBLY_INFO(block_id) (0x000000000000000Cull)
+#define CVMX_SRIOMAINTX_ASMBLY_INFO(offset) (0x000000000000000Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_BAR1_IDXX(unsigned long offset, unsigned long block_id)
@@ -89,436 +89,436 @@ static inline uint64_t CVMX_SRIOMAINTX_BAR1_IDXX(unsigned long offset, unsigned
 #define CVMX_SRIOMAINTX_BAR1_IDXX(offset, block_id) (0x0000000000200010ull + (((offset) & 15) + ((block_id) & 3) * 0x0ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_BELL_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_BELL_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_BELL_STATUS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_BELL_STATUS(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200080ull;
 }
 #else
-#define CVMX_SRIOMAINTX_BELL_STATUS(block_id) (0x0000000000200080ull)
+#define CVMX_SRIOMAINTX_BELL_STATUS(offset) (0x0000000000200080ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_COMP_TAG(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_COMP_TAG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_COMP_TAG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_COMP_TAG(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000006Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_COMP_TAG(block_id) (0x000000000000006Cull)
+#define CVMX_SRIOMAINTX_COMP_TAG(offset) (0x000000000000006Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_CORE_ENABLES(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_CORE_ENABLES(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_CORE_ENABLES(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_CORE_ENABLES(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200070ull;
 }
 #else
-#define CVMX_SRIOMAINTX_CORE_ENABLES(block_id) (0x0000000000200070ull)
+#define CVMX_SRIOMAINTX_CORE_ENABLES(offset) (0x0000000000200070ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_DEV_ID(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_DEV_ID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_DEV_ID(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_DEV_ID(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_DEV_ID(block_id) (0x0000000000000000ull)
+#define CVMX_SRIOMAINTX_DEV_ID(offset) (0x0000000000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_DEV_REV(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_DEV_REV(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_DEV_REV(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_DEV_REV(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000004ull;
 }
 #else
-#define CVMX_SRIOMAINTX_DEV_REV(block_id) (0x0000000000000004ull)
+#define CVMX_SRIOMAINTX_DEV_REV(offset) (0x0000000000000004ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_DST_OPS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_DST_OPS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_DST_OPS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_DST_OPS(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000001Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_DST_OPS(block_id) (0x000000000000001Cull)
+#define CVMX_SRIOMAINTX_DST_OPS(offset) (0x000000000000001Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_ATTR_CAPT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ATTR_CAPT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ATTR_CAPT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_ATTR_CAPT(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002048ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ATTR_CAPT(block_id) (0x0000000000002048ull)
+#define CVMX_SRIOMAINTX_ERB_ATTR_CAPT(offset) (0x0000000000002048ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_DET(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_DET(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_DET(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_DET(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002040ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ERR_DET(block_id) (0x0000000000002040ull)
+#define CVMX_SRIOMAINTX_ERB_ERR_DET(offset) (0x0000000000002040ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002068ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ERR_RATE(block_id) (0x0000000000002068ull)
+#define CVMX_SRIOMAINTX_ERB_ERR_RATE(offset) (0x0000000000002068ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002044ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(block_id) (0x0000000000002044ull)
+#define CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(offset) (0x0000000000002044ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000206Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(block_id) (0x000000000000206Cull)
+#define CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(offset) (0x000000000000206Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_HDR(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_HDR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_HDR(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_HDR(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_HDR(block_id) (0x0000000000002000ull)
+#define CVMX_SRIOMAINTX_ERB_HDR(offset) (0x0000000000002000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002010ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(block_id) (0x0000000000002010ull)
+#define CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(offset) (0x0000000000002010ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002014ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(block_id) (0x0000000000002014ull)
+#define CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(offset) (0x0000000000002014ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000201Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(block_id) (0x000000000000201Cull)
+#define CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(offset) (0x000000000000201Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_DEV_ID(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_DEV_ID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_DEV_ID(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_DEV_ID(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002028ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_DEV_ID(block_id) (0x0000000000002028ull)
+#define CVMX_SRIOMAINTX_ERB_LT_DEV_ID(offset) (0x0000000000002028ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002018ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(block_id) (0x0000000000002018ull)
+#define CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(offset) (0x0000000000002018ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ERR_DET(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ERR_DET(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ERR_DET(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ERR_DET(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002008ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_ERR_DET(block_id) (0x0000000000002008ull)
+#define CVMX_SRIOMAINTX_ERB_LT_ERR_DET(offset) (0x0000000000002008ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ERR_EN(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_LT_ERR_EN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ERR_EN(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_LT_ERR_EN(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000200Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_LT_ERR_EN(block_id) (0x000000000000200Cull)
+#define CVMX_SRIOMAINTX_ERB_LT_ERR_EN(offset) (0x000000000000200Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002050ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(block_id) (0x0000000000002050ull)
+#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(offset) (0x0000000000002050ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002054ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(block_id) (0x0000000000002054ull)
+#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(offset) (0x0000000000002054ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000002058ull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(block_id) (0x0000000000002058ull)
+#define CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(offset) (0x0000000000002058ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000204Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(block_id) (0x000000000000204Cull)
+#define CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(offset) (0x000000000000204Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000068ull;
 }
 #else
-#define CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(block_id) (0x0000000000000068ull)
+#define CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(offset) (0x0000000000000068ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000102000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(block_id) (0x0000000000102000ull)
+#define CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(offset) (0x0000000000102000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000102004ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(block_id) (0x0000000000102004ull)
+#define CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(offset) (0x0000000000102004ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000107028ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(block_id) (0x0000000000107028ull)
+#define CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(offset) (0x0000000000107028ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_PD_PHY_STAT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_PD_PHY_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_PD_PHY_STAT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_PD_PHY_STAT(%lu) is invalid on this chip\n", offset);
 	return 0x000000000010702Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_PD_PHY_STAT(block_id) (0x000000000010702Cull)
+#define CVMX_SRIOMAINTX_IR_PD_PHY_STAT(offset) (0x000000000010702Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000107020ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(block_id) (0x0000000000107020ull)
+#define CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(offset) (0x0000000000107020ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_PI_PHY_STAT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_PI_PHY_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_PI_PHY_STAT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_PI_PHY_STAT(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000107024ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_PI_PHY_STAT(block_id) (0x0000000000107024ull)
+#define CVMX_SRIOMAINTX_IR_PI_PHY_STAT(offset) (0x0000000000107024ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_CTRL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_CTRL(%lu) is invalid on this chip\n", offset);
 	return 0x000000000010700Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_RX_CTRL(block_id) (0x000000000010700Cull)
+#define CVMX_SRIOMAINTX_IR_SP_RX_CTRL(offset) (0x000000000010700Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_DATA(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_DATA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_DATA(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_DATA(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000107014ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_RX_DATA(block_id) (0x0000000000107014ull)
+#define CVMX_SRIOMAINTX_IR_SP_RX_DATA(offset) (0x0000000000107014ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_STAT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_RX_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_STAT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_RX_STAT(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000107010ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_RX_STAT(block_id) (0x0000000000107010ull)
+#define CVMX_SRIOMAINTX_IR_SP_RX_STAT(offset) (0x0000000000107010ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_CTRL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_CTRL(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000107000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_TX_CTRL(block_id) (0x0000000000107000ull)
+#define CVMX_SRIOMAINTX_IR_SP_TX_CTRL(offset) (0x0000000000107000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_DATA(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_DATA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_DATA(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_DATA(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000107008ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_TX_DATA(block_id) (0x0000000000107008ull)
+#define CVMX_SRIOMAINTX_IR_SP_TX_DATA(offset) (0x0000000000107008ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_STAT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_IR_SP_TX_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_STAT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_IR_SP_TX_STAT(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000107004ull;
 }
 #else
-#define CVMX_SRIOMAINTX_IR_SP_TX_STAT(block_id) (0x0000000000107004ull)
+#define CVMX_SRIOMAINTX_IR_SP_TX_STAT(offset) (0x0000000000107004ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOMAINTX_LANE_X_STATUS_0(unsigned long offset, unsigned long block_id)
@@ -533,328 +533,328 @@ static inline uint64_t CVMX_SRIOMAINTX_LANE_X_STATUS_0(unsigned long offset, uns
 #define CVMX_SRIOMAINTX_LANE_X_STATUS_0(offset, block_id) (0x0000000000001010ull + (((offset) & 3) + ((block_id) & 3) * 0x0ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_LCS_BA0(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_LCS_BA0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_LCS_BA0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_LCS_BA0(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000058ull;
 }
 #else
-#define CVMX_SRIOMAINTX_LCS_BA0(block_id) (0x0000000000000058ull)
+#define CVMX_SRIOMAINTX_LCS_BA0(offset) (0x0000000000000058ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_LCS_BA1(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_LCS_BA1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_LCS_BA1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_LCS_BA1(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000005Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_LCS_BA1(block_id) (0x000000000000005Cull)
+#define CVMX_SRIOMAINTX_LCS_BA1(offset) (0x000000000000005Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR0_START0(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR0_START0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR0_START0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR0_START0(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR0_START0(block_id) (0x0000000000200000ull)
+#define CVMX_SRIOMAINTX_M2S_BAR0_START0(offset) (0x0000000000200000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR0_START1(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR0_START1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR0_START1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR0_START1(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200004ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR0_START1(block_id) (0x0000000000200004ull)
+#define CVMX_SRIOMAINTX_M2S_BAR0_START1(offset) (0x0000000000200004ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR1_START0(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR1_START0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR1_START0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR1_START0(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200008ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR1_START0(block_id) (0x0000000000200008ull)
+#define CVMX_SRIOMAINTX_M2S_BAR1_START0(offset) (0x0000000000200008ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR1_START1(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR1_START1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR1_START1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR1_START1(%lu) is invalid on this chip\n", offset);
 	return 0x000000000020000Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR1_START1(block_id) (0x000000000020000Cull)
+#define CVMX_SRIOMAINTX_M2S_BAR1_START1(offset) (0x000000000020000Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR2_START(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_M2S_BAR2_START(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR2_START(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_M2S_BAR2_START(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200050ull;
 }
 #else
-#define CVMX_SRIOMAINTX_M2S_BAR2_START(block_id) (0x0000000000200050ull)
+#define CVMX_SRIOMAINTX_M2S_BAR2_START(offset) (0x0000000000200050ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_MAC_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_MAC_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_MAC_CTRL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_MAC_CTRL(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200068ull;
 }
 #else
-#define CVMX_SRIOMAINTX_MAC_CTRL(block_id) (0x0000000000200068ull)
+#define CVMX_SRIOMAINTX_MAC_CTRL(offset) (0x0000000000200068ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PE_FEAT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PE_FEAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PE_FEAT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PE_FEAT(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000010ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PE_FEAT(block_id) (0x0000000000000010ull)
+#define CVMX_SRIOMAINTX_PE_FEAT(offset) (0x0000000000000010ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PE_LLC(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PE_LLC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PE_LLC(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PE_LLC(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000004Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_PE_LLC(block_id) (0x000000000000004Cull)
+#define CVMX_SRIOMAINTX_PE_LLC(offset) (0x000000000000004Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_0_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_CTL(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000015Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_CTL(block_id) (0x000000000000015Cull)
+#define CVMX_SRIOMAINTX_PORT_0_CTL(offset) (0x000000000000015Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_0_CTL2(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_CTL2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_CTL2(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_CTL2(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000154ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_CTL2(block_id) (0x0000000000000154ull)
+#define CVMX_SRIOMAINTX_PORT_0_CTL2(offset) (0x0000000000000154ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_0_ERR_STAT(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_ERR_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_ERR_STAT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_ERR_STAT(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000158ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_ERR_STAT(block_id) (0x0000000000000158ull)
+#define CVMX_SRIOMAINTX_PORT_0_ERR_STAT(offset) (0x0000000000000158ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LINK_REQ(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LINK_REQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LINK_REQ(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LINK_REQ(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000140ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_LINK_REQ(block_id) (0x0000000000000140ull)
+#define CVMX_SRIOMAINTX_PORT_0_LINK_REQ(offset) (0x0000000000000140ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LINK_RESP(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LINK_RESP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LINK_RESP(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LINK_RESP(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000144ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_LINK_RESP(block_id) (0x0000000000000144ull)
+#define CVMX_SRIOMAINTX_PORT_0_LINK_RESP(offset) (0x0000000000000144ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000148ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(block_id) (0x0000000000000148ull)
+#define CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(offset) (0x0000000000000148ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_GEN_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_GEN_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_GEN_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_GEN_CTL(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000013Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_GEN_CTL(block_id) (0x000000000000013Cull)
+#define CVMX_SRIOMAINTX_PORT_GEN_CTL(offset) (0x000000000000013Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_LT_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_LT_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_LT_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_LT_CTL(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000120ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_LT_CTL(block_id) (0x0000000000000120ull)
+#define CVMX_SRIOMAINTX_PORT_LT_CTL(offset) (0x0000000000000120ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_MBH0(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_MBH0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_MBH0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_MBH0(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000100ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_MBH0(block_id) (0x0000000000000100ull)
+#define CVMX_SRIOMAINTX_PORT_MBH0(offset) (0x0000000000000100ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_RT_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_RT_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_RT_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_RT_CTL(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000124ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_RT_CTL(block_id) (0x0000000000000124ull)
+#define CVMX_SRIOMAINTX_PORT_RT_CTL(offset) (0x0000000000000124ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PORT_TTL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PORT_TTL_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PORT_TTL_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PORT_TTL_CTL(%lu) is invalid on this chip\n", offset);
 	return 0x000000000000012Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_PORT_TTL_CTL(block_id) (0x000000000000012Cull)
+#define CVMX_SRIOMAINTX_PORT_TTL_CTL(offset) (0x000000000000012Cull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_PRI_DEV_ID(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_PRI_DEV_ID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_PRI_DEV_ID(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_PRI_DEV_ID(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000060ull;
 }
 #else
-#define CVMX_SRIOMAINTX_PRI_DEV_ID(block_id) (0x0000000000000060ull)
+#define CVMX_SRIOMAINTX_PRI_DEV_ID(offset) (0x0000000000000060ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_SEC_DEV_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_SEC_DEV_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_SEC_DEV_CTRL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_SEC_DEV_CTRL(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200064ull;
 }
 #else
-#define CVMX_SRIOMAINTX_SEC_DEV_CTRL(block_id) (0x0000000000200064ull)
+#define CVMX_SRIOMAINTX_SEC_DEV_CTRL(offset) (0x0000000000200064ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_SEC_DEV_ID(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_SEC_DEV_ID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_SEC_DEV_ID(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_SEC_DEV_ID(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000200060ull;
 }
 #else
-#define CVMX_SRIOMAINTX_SEC_DEV_ID(block_id) (0x0000000000200060ull)
+#define CVMX_SRIOMAINTX_SEC_DEV_ID(offset) (0x0000000000200060ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_SERIAL_LANE_HDR(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_SERIAL_LANE_HDR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_SERIAL_LANE_HDR(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_SERIAL_LANE_HDR(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000001000ull;
 }
 #else
-#define CVMX_SRIOMAINTX_SERIAL_LANE_HDR(block_id) (0x0000000000001000ull)
+#define CVMX_SRIOMAINTX_SERIAL_LANE_HDR(offset) (0x0000000000001000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_SRC_OPS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_SRC_OPS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_SRC_OPS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_SRC_OPS(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000018ull;
 }
 #else
-#define CVMX_SRIOMAINTX_SRC_OPS(block_id) (0x0000000000000018ull)
+#define CVMX_SRIOMAINTX_SRC_OPS(offset) (0x0000000000000018ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOMAINTX_TX_DROP(unsigned long block_id)
+static inline uint64_t CVMX_SRIOMAINTX_TX_DROP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOMAINTX_TX_DROP(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOMAINTX_TX_DROP(%lu) is invalid on this chip\n", offset);
 	return 0x000000000020006Cull;
 }
 #else
-#define CVMX_SRIOMAINTX_TX_DROP(block_id) (0x000000000020006Cull)
+#define CVMX_SRIOMAINTX_TX_DROP(offset) (0x000000000020006Cull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
index 9415497..b172d96 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
@@ -53,76 +53,76 @@
 #define __CVMX_SRIOX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_ACC_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_ACC_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_ACC_CTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000148ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_ACC_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000148ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_ACC_CTRL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000148ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_ACC_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000148ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_ASMBLY_ID(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_ASMBLY_ID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_ASMBLY_ID(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000200ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_ASMBLY_ID(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000200ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_ASMBLY_ID(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000200ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_ASMBLY_ID(offset) (CVMX_ADD_IO_SEG(0x00011800C8000200ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_ASMBLY_INFO(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_ASMBLY_INFO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_ASMBLY_INFO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000208ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_ASMBLY_INFO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000208ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_ASMBLY_INFO(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000208ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_ASMBLY_INFO(offset) (CVMX_ADD_IO_SEG(0x00011800C8000208ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_BELL_RESP_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_BELL_RESP_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_BELL_RESP_CTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000310ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_BELL_RESP_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000310ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_BELL_RESP_CTRL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000310ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_BELL_RESP_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000310ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000108ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000108ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000108ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000108ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_IMSG_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_IMSG_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_IMSG_CTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000508ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_IMSG_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000508ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_IMSG_CTRL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000508ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_IMSG_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000508ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_IMSG_INST_HDRX(unsigned long offset, unsigned long block_id)
@@ -161,195 +161,195 @@ static inline uint64_t CVMX_SRIOX_IMSG_STATUSX(unsigned long offset, unsigned lo
 #define CVMX_SRIOX_IMSG_STATUSX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C8000700ull) + (((offset) & 31) + ((block_id) & 3) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_IMSG_VPORT_THR(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_IMSG_VPORT_THR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_IMSG_VPORT_THR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000500ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_IMSG_VPORT_THR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000500ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_IMSG_VPORT_THR(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000500ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_IMSG_VPORT_THR(offset) (CVMX_ADD_IO_SEG(0x00011800C8000500ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_IMSG_VPORT_THR2(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_IMSG_VPORT_THR2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_IMSG_VPORT_THR2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000528ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_IMSG_VPORT_THR2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000528ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_IMSG_VPORT_THR2(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000528ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_IMSG_VPORT_THR2(offset) (CVMX_ADD_IO_SEG(0x00011800C8000528ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_INT2_ENABLE(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_INT2_ENABLE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_INT2_ENABLE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C80003E0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_INT2_ENABLE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C80003E0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_INT2_ENABLE(block_id) (CVMX_ADD_IO_SEG(0x00011800C80003E0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_INT2_ENABLE(offset) (CVMX_ADD_IO_SEG(0x00011800C80003E0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_INT2_REG(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_INT2_REG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_INT2_REG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C80003E8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_INT2_REG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C80003E8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_INT2_REG(block_id) (CVMX_ADD_IO_SEG(0x00011800C80003E8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_INT2_REG(offset) (CVMX_ADD_IO_SEG(0x00011800C80003E8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_INT_ENABLE(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_INT_ENABLE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_INT_ENABLE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_INT_ENABLE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_INT_ENABLE(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_INT_ENABLE(offset) (CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_INT_INFO0(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_INT_INFO0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_INT_INFO0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000120ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_INT_INFO0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000120ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_INT_INFO0(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000120ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_INT_INFO0(offset) (CVMX_ADD_IO_SEG(0x00011800C8000120ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_INT_INFO1(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_INT_INFO1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_INT_INFO1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000128ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_INT_INFO1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000128ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_INT_INFO1(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000128ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_INT_INFO1(offset) (CVMX_ADD_IO_SEG(0x00011800C8000128ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_INT_INFO2(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_INT_INFO2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_INT_INFO2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000130ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_INT_INFO2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000130ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_INT_INFO2(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000130ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_INT_INFO2(offset) (CVMX_ADD_IO_SEG(0x00011800C8000130ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_INT_INFO3(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_INT_INFO3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_INT_INFO3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000138ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_INT_INFO3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000138ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_INT_INFO3(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000138ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_INT_INFO3(offset) (CVMX_ADD_IO_SEG(0x00011800C8000138ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_INT_REG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_INT_REG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_INT_REG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_INT_REG(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_INT_REG(offset) (CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_IP_FEATURE(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_IP_FEATURE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_IP_FEATURE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C80003F8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_IP_FEATURE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C80003F8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_IP_FEATURE(block_id) (CVMX_ADD_IO_SEG(0x00011800C80003F8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_IP_FEATURE(offset) (CVMX_ADD_IO_SEG(0x00011800C80003F8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_MAC_BUFFERS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_MAC_BUFFERS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_MAC_BUFFERS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000390ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_MAC_BUFFERS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000390ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_MAC_BUFFERS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000390ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_MAC_BUFFERS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000390ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_MAINT_OP(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_MAINT_OP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_MAINT_OP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000158ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_MAINT_OP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000158ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_MAINT_OP(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000158ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_MAINT_OP(offset) (CVMX_ADD_IO_SEG(0x00011800C8000158ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_MAINT_RD_DATA(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_MAINT_RD_DATA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_MAINT_RD_DATA(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000160ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_MAINT_RD_DATA(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000160ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_MAINT_RD_DATA(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000160ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_MAINT_RD_DATA(offset) (CVMX_ADD_IO_SEG(0x00011800C8000160ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_MCE_TX_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_MCE_TX_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_MCE_TX_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000240ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_MCE_TX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000240ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_MCE_TX_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000240ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_MCE_TX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000240ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_MEM_OP_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_MEM_OP_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_MEM_OP_CTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000168ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_MEM_OP_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000168ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_MEM_OP_CTRL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000168ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_MEM_OP_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000168ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_OMSG_CTRLX(unsigned long offset, unsigned long block_id)
@@ -412,16 +412,16 @@ static inline uint64_t CVMX_SRIOX_OMSG_PORTX(unsigned long offset, unsigned long
 #define CVMX_SRIOX_OMSG_PORTX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C8000480ull) + (((offset) & 1) + ((block_id) & 3) * 0x40000ull) * 64)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_OMSG_SILO_THR(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_OMSG_SILO_THR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_OMSG_SILO_THR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C80004F8ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_OMSG_SILO_THR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C80004F8ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_OMSG_SILO_THR(block_id) (CVMX_ADD_IO_SEG(0x00011800C80004F8ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_OMSG_SILO_THR(offset) (CVMX_ADD_IO_SEG(0x00011800C80004F8ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_OMSG_SP_MRX(unsigned long offset, unsigned long block_id)
@@ -448,40 +448,40 @@ static inline uint64_t CVMX_SRIOX_PRIOX_IN_USE(unsigned long offset, unsigned lo
 #define CVMX_SRIOX_PRIOX_IN_USE(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C80003C0ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_RX_BELL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_RX_BELL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_RX_BELL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000308ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_RX_BELL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000308ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_RX_BELL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000308ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_RX_BELL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000308ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_RX_BELL_SEQ(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_RX_BELL_SEQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_RX_BELL_SEQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000300ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_RX_BELL_SEQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000300ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_RX_BELL_SEQ(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000300ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_RX_BELL_SEQ(offset) (CVMX_ADD_IO_SEG(0x00011800C8000300ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_RX_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_RX_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_RX_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000380ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_RX_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000380ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_RX_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000380ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_RX_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000380ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRIOX_S2M_TYPEX(unsigned long offset, unsigned long block_id)
@@ -496,124 +496,124 @@ static inline uint64_t CVMX_SRIOX_S2M_TYPEX(unsigned long offset, unsigned long
 #define CVMX_SRIOX_S2M_TYPEX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800C8000180ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_SEQ(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_SEQ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_SEQ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000278ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_SEQ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000278ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_SEQ(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000278ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_SEQ(offset) (CVMX_ADD_IO_SEG(0x00011800C8000278ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_STATUS_REG(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_STATUS_REG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_STATUS_REG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000100ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_STATUS_REG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000100ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_STATUS_REG(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000100ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_STATUS_REG(offset) (CVMX_ADD_IO_SEG(0x00011800C8000100ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_TAG_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_TAG_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_TAG_CTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000178ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_TAG_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000178ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_TAG_CTRL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000178ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_TAG_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000178ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_TLP_CREDITS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_TLP_CREDITS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_TLP_CREDITS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000150ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_TLP_CREDITS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000150ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_TLP_CREDITS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000150ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_TLP_CREDITS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000150ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_TX_BELL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_TX_BELL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_TX_BELL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000280ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_TX_BELL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000280ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_TX_BELL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000280ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_TX_BELL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000280ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_TX_BELL_INFO(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_TX_BELL_INFO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_TX_BELL_INFO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000288ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_TX_BELL_INFO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000288ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_TX_BELL_INFO(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000288ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_TX_BELL_INFO(offset) (CVMX_ADD_IO_SEG(0x00011800C8000288ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_TX_CTRL(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_TX_CTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_TX_CTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000170ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_TX_CTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000170ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_TX_CTRL(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000170ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_TX_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800C8000170ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_TX_EMPHASIS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_TX_EMPHASIS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_TX_EMPHASIS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C80003F0ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_TX_EMPHASIS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C80003F0ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_TX_EMPHASIS(block_id) (CVMX_ADD_IO_SEG(0x00011800C80003F0ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_TX_EMPHASIS(offset) (CVMX_ADD_IO_SEG(0x00011800C80003F0ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_TX_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_TX_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_TX_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000388ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_TX_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000388ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_TX_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000388ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_TX_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000388ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRIOX_WR_DONE_COUNTS(unsigned long block_id)
+static inline uint64_t CVMX_SRIOX_WR_DONE_COUNTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0) || ((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_SRIOX_WR_DONE_COUNTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C8000340ull) + ((block_id) & 3) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0) || ((offset >= 2) && (offset <= 3))))))
+		cvmx_warn("CVMX_SRIOX_WR_DONE_COUNTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C8000340ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_SRIOX_WR_DONE_COUNTS(block_id) (CVMX_ADD_IO_SEG(0x00011800C8000340ull) + ((block_id) & 3) * 0x1000000ull)
+#define CVMX_SRIOX_WR_DONE_COUNTS(offset) (CVMX_ADD_IO_SEG(0x00011800C8000340ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-srxx-defs.h b/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
index ffae2d0..859e2b3 100644
--- a/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
@@ -53,28 +53,28 @@
 #define __CVMX_SRXX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRXX_COM_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SRXX_COM_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SRXX_COM_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRXX_COM_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SRXX_COM_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SRXX_COM_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRXX_IGN_RX_FULL(unsigned long block_id)
+static inline uint64_t CVMX_SRXX_IGN_RX_FULL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SRXX_IGN_RX_FULL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000218ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRXX_IGN_RX_FULL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000218ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SRXX_IGN_RX_FULL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000218ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SRXX_IGN_RX_FULL(offset) (CVMX_ADD_IO_SEG(0x0001180090000218ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SRXX_SPI4_CALX(unsigned long offset, unsigned long block_id)
@@ -89,40 +89,40 @@ static inline uint64_t CVMX_SRXX_SPI4_CALX(unsigned long offset, unsigned long b
 #define CVMX_SRXX_SPI4_CALX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090000000ull) + (((offset) & 31) + ((block_id) & 1) * 0x1000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRXX_SPI4_STAT(unsigned long block_id)
+static inline uint64_t CVMX_SRXX_SPI4_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SRXX_SPI4_STAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000208ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRXX_SPI4_STAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000208ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SRXX_SPI4_STAT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000208ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SRXX_SPI4_STAT(offset) (CVMX_ADD_IO_SEG(0x0001180090000208ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRXX_SW_TICK_CTL(unsigned long block_id)
+static inline uint64_t CVMX_SRXX_SW_TICK_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SRXX_SW_TICK_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000220ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRXX_SW_TICK_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000220ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SRXX_SW_TICK_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000220ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SRXX_SW_TICK_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000220ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SRXX_SW_TICK_DAT(unsigned long block_id)
+static inline uint64_t CVMX_SRXX_SW_TICK_DAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_SRXX_SW_TICK_DAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000228ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_SRXX_SW_TICK_DAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000228ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_SRXX_SW_TICK_DAT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000228ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_SRXX_SW_TICK_DAT(offset) (CVMX_ADD_IO_SEG(0x0001180090000228ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index 5eca181..b0a9b9d 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -67,6 +67,7 @@ static inline uint64_t CVMX_SSO_ACTIVE_CYCLES_FUNC(void)
 static inline uint64_t CVMX_SSO_ACTIVE_CYCLESX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_SSO_ACTIVE_CYCLESX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000001100ull) + ((offset) & 3) * 8;
@@ -78,7 +79,7 @@ static inline uint64_t CVMX_SSO_ACTIVE_CYCLESX(unsigned long offset)
 #define CVMX_SSO_AW_ADD CVMX_SSO_AW_ADD_FUNC()
 static inline uint64_t CVMX_SSO_AW_ADD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_ADD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002080ull);
 }
@@ -89,7 +90,7 @@ static inline uint64_t CVMX_SSO_AW_ADD_FUNC(void)
 #define CVMX_SSO_AW_CFG CVMX_SSO_AW_CFG_FUNC()
 static inline uint64_t CVMX_SSO_AW_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010F0ull);
 }
@@ -100,7 +101,7 @@ static inline uint64_t CVMX_SSO_AW_CFG_FUNC(void)
 #define CVMX_SSO_AW_READ_ARB CVMX_SSO_AW_READ_ARB_FUNC()
 static inline uint64_t CVMX_SSO_AW_READ_ARB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_READ_ARB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002090ull);
 }
@@ -111,7 +112,7 @@ static inline uint64_t CVMX_SSO_AW_READ_ARB_FUNC(void)
 #define CVMX_SSO_AW_STATUS CVMX_SSO_AW_STATUS_FUNC()
 static inline uint64_t CVMX_SSO_AW_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010E0ull);
 }
@@ -122,7 +123,7 @@ static inline uint64_t CVMX_SSO_AW_STATUS_FUNC(void)
 #define CVMX_SSO_AW_TAG_LATENCY_PC CVMX_SSO_AW_TAG_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_SSO_AW_TAG_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_TAG_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020A8ull);
 }
@@ -133,7 +134,7 @@ static inline uint64_t CVMX_SSO_AW_TAG_LATENCY_PC_FUNC(void)
 #define CVMX_SSO_AW_TAG_REQ_PC CVMX_SSO_AW_TAG_REQ_PC_FUNC()
 static inline uint64_t CVMX_SSO_AW_TAG_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_TAG_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020A0ull);
 }
@@ -144,7 +145,7 @@ static inline uint64_t CVMX_SSO_AW_TAG_REQ_PC_FUNC(void)
 #define CVMX_SSO_AW_WE CVMX_SSO_AW_WE_FUNC()
 static inline uint64_t CVMX_SSO_AW_WE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_WE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001080ull);
 }
@@ -166,7 +167,7 @@ static inline uint64_t CVMX_SSO_BIST_STAT_FUNC(void)
 #define CVMX_SSO_BIST_STATUS0 CVMX_SSO_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001200ull);
 }
@@ -177,7 +178,7 @@ static inline uint64_t CVMX_SSO_BIST_STATUS0_FUNC(void)
 #define CVMX_SSO_BIST_STATUS1 CVMX_SSO_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001208ull);
 }
@@ -188,7 +189,7 @@ static inline uint64_t CVMX_SSO_BIST_STATUS1_FUNC(void)
 #define CVMX_SSO_BIST_STATUS2 CVMX_SSO_BIST_STATUS2_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001210ull);
 }
@@ -221,7 +222,7 @@ static inline uint64_t CVMX_SSO_DS_PC_FUNC(void)
 #define CVMX_SSO_ECC_CTL0 CVMX_SSO_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001280ull);
 }
@@ -232,7 +233,7 @@ static inline uint64_t CVMX_SSO_ECC_CTL0_FUNC(void)
 #define CVMX_SSO_ECC_CTL1 CVMX_SSO_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001288ull);
 }
@@ -243,7 +244,7 @@ static inline uint64_t CVMX_SSO_ECC_CTL1_FUNC(void)
 #define CVMX_SSO_ECC_CTL2 CVMX_SSO_ECC_CTL2_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001290ull);
 }
@@ -265,7 +266,7 @@ static inline uint64_t CVMX_SSO_ERR_FUNC(void)
 #define CVMX_SSO_ERR0 CVMX_SSO_ERR0_FUNC()
 static inline uint64_t CVMX_SSO_ERR0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001240ull);
 }
@@ -276,7 +277,7 @@ static inline uint64_t CVMX_SSO_ERR0_FUNC(void)
 #define CVMX_SSO_ERR1 CVMX_SSO_ERR1_FUNC()
 static inline uint64_t CVMX_SSO_ERR1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001248ull);
 }
@@ -287,7 +288,7 @@ static inline uint64_t CVMX_SSO_ERR1_FUNC(void)
 #define CVMX_SSO_ERR2 CVMX_SSO_ERR2_FUNC()
 static inline uint64_t CVMX_SSO_ERR2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001250ull);
 }
@@ -339,153 +340,166 @@ static inline uint64_t CVMX_SSO_FPAGE_CNT_FUNC(void)
 #define CVMX_SSO_FPAGE_CNT (CVMX_ADD_IO_SEG(0x0001670000001090ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_AQ_CNT(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_AQ_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_AQ_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020000700ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_AQ_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020000700ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_AQ_CNT(block_id) (CVMX_ADD_IO_SEG(0x0001670020000700ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_AQ_CNT(offset) (CVMX_ADD_IO_SEG(0x0001670020000700ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_AQ_THR(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_AQ_THR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_AQ_THR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020000800ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_AQ_THR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020000800ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_AQ_THR(block_id) (CVMX_ADD_IO_SEG(0x0001670020000800ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_AQ_THR(offset) (CVMX_ADD_IO_SEG(0x0001670020000800ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_DS_PC(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_DS_PC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_DS_PC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020001400ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_DS_PC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020001400ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_DS_PC(block_id) (CVMX_ADD_IO_SEG(0x0001670020001400ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_DS_PC(offset) (CVMX_ADD_IO_SEG(0x0001670020001400ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_EXT_PC(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_EXT_PC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_EXT_PC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020001100ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_EXT_PC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020001100ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_EXT_PC(block_id) (CVMX_ADD_IO_SEG(0x0001670020001100ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_EXT_PC(offset) (CVMX_ADD_IO_SEG(0x0001670020001100ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_IAQ_THR(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_IAQ_THR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_IAQ_THR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020000000ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_IAQ_THR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020000000ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_IAQ_THR(block_id) (CVMX_ADD_IO_SEG(0x0001670020000000ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_IAQ_THR(offset) (CVMX_ADD_IO_SEG(0x0001670020000000ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_INT(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_INT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_INT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020000400ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_INT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020000400ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_INT(block_id) (CVMX_ADD_IO_SEG(0x0001670020000400ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_INT(offset) (CVMX_ADD_IO_SEG(0x0001670020000400ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_INT_CNT(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_INT_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_INT_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020000600ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_INT_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020000600ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_INT_CNT(block_id) (CVMX_ADD_IO_SEG(0x0001670020000600ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_INT_CNT(offset) (CVMX_ADD_IO_SEG(0x0001670020000600ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_INT_THR(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_INT_THR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_INT_THR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020000500ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_INT_THR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020000500ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_INT_THR(block_id) (CVMX_ADD_IO_SEG(0x0001670020000500ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_INT_THR(offset) (CVMX_ADD_IO_SEG(0x0001670020000500ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_PRI(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_PRI(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_PRI(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020000200ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_PRI(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020000200ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_PRI(block_id) (CVMX_ADD_IO_SEG(0x0001670020000200ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_PRI(offset) (CVMX_ADD_IO_SEG(0x0001670020000200ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_TAQ_THR(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_TAQ_THR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_TAQ_THR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020000100ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_TAQ_THR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020000100ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_TAQ_THR(block_id) (CVMX_ADD_IO_SEG(0x0001670020000100ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_TAQ_THR(offset) (CVMX_ADD_IO_SEG(0x0001670020000100ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_TS_PC(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_TS_PC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_TS_PC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020001300ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_TS_PC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020001300ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_TS_PC(block_id) (CVMX_ADD_IO_SEG(0x0001670020001300ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_TS_PC(offset) (CVMX_ADD_IO_SEG(0x0001670020001300ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_WA_PC(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_WA_PC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_WA_PC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020001200ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_WA_PC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020001200ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_WA_PC(block_id) (CVMX_ADD_IO_SEG(0x0001670020001200ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_WA_PC(offset) (CVMX_ADD_IO_SEG(0x0001670020001200ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_GRPX_WS_PC(unsigned long block_id)
+static inline uint64_t CVMX_SSO_GRPX_WS_PC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
-		cvmx_warn("CVMX_SSO_GRPX_WS_PC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670020001000ull) + ((block_id) & 255) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
+		cvmx_warn("CVMX_SSO_GRPX_WS_PC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670020001000ull) + ((offset) & 255) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_GRPX_WS_PC(block_id) (CVMX_ADD_IO_SEG(0x0001670020001000ull) + ((block_id) & 255) * 0x10000ull)
+#define CVMX_SSO_GRPX_WS_PC(offset) (CVMX_ADD_IO_SEG(0x0001670020001000ull) + ((offset) & 255) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SSO_GWE_CFG CVMX_SSO_GWE_CFG_FUNC()
 static inline uint64_t CVMX_SSO_GWE_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_GWE_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001098ull);
 }
@@ -496,7 +510,7 @@ static inline uint64_t CVMX_SSO_GWE_CFG_FUNC(void)
 #define CVMX_SSO_GWE_RANDOM CVMX_SSO_GWE_RANDOM_FUNC()
 static inline uint64_t CVMX_SSO_GWE_RANDOM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_GWE_RANDOM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010B0ull);
 }
@@ -529,6 +543,7 @@ static inline uint64_t CVMX_SSO_IDX_ECC_ST_FUNC(void)
 static inline uint64_t CVMX_SSO_IENTX_LINKS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_LINKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0060000ull) + ((offset) & 4095) * 8;
@@ -540,6 +555,7 @@ static inline uint64_t CVMX_SSO_IENTX_LINKS(unsigned long offset)
 static inline uint64_t CVMX_SSO_IENTX_PENDTAG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_PENDTAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0040000ull) + ((offset) & 4095) * 8;
@@ -551,6 +567,7 @@ static inline uint64_t CVMX_SSO_IENTX_PENDTAG(unsigned long offset)
 static inline uint64_t CVMX_SSO_IENTX_QLINKS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_QLINKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0080000ull) + ((offset) & 4095) * 8;
@@ -562,6 +579,7 @@ static inline uint64_t CVMX_SSO_IENTX_QLINKS(unsigned long offset)
 static inline uint64_t CVMX_SSO_IENTX_TAG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_TAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0000000ull) + ((offset) & 4095) * 8;
@@ -573,6 +591,7 @@ static inline uint64_t CVMX_SSO_IENTX_TAG(unsigned long offset)
 static inline uint64_t CVMX_SSO_IENTX_WQPGRP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_WQPGRP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0020000ull) + ((offset) & 4095) * 8;
@@ -584,6 +603,7 @@ static inline uint64_t CVMX_SSO_IENTX_WQPGRP(unsigned long offset)
 static inline uint64_t CVMX_SSO_IPL_CONFX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_CONFX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080080000ull) + ((offset) & 255) * 8;
@@ -595,6 +615,7 @@ static inline uint64_t CVMX_SSO_IPL_CONFX(unsigned long offset)
 static inline uint64_t CVMX_SSO_IPL_DESCHEDX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_DESCHEDX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080060000ull) + ((offset) & 255) * 8;
@@ -606,6 +627,7 @@ static inline uint64_t CVMX_SSO_IPL_DESCHEDX(unsigned long offset)
 static inline uint64_t CVMX_SSO_IPL_FREEX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_SSO_IPL_FREEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080000000ull) + ((offset) & 7) * 8;
@@ -617,6 +639,7 @@ static inline uint64_t CVMX_SSO_IPL_FREEX(unsigned long offset)
 static inline uint64_t CVMX_SSO_IPL_IAQX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_IAQX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080040000ull) + ((offset) & 255) * 8;
@@ -683,7 +706,7 @@ static inline uint64_t CVMX_SSO_IQ_THRX(unsigned long offset)
 #define CVMX_SSO_NOS_CNT CVMX_SSO_NOS_CNT_FUNC()
 static inline uint64_t CVMX_SSO_NOS_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_NOS_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001040ull);
 }
@@ -694,7 +717,7 @@ static inline uint64_t CVMX_SSO_NOS_CNT_FUNC(void)
 #define CVMX_SSO_NW_TIM CVMX_SSO_NW_TIM_FUNC()
 static inline uint64_t CVMX_SSO_NW_TIM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_NW_TIM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001028ull);
 }
@@ -727,7 +750,7 @@ static inline uint64_t CVMX_SSO_OTH_ECC_ST_FUNC(void)
 #define CVMX_SSO_PAGE_CNT CVMX_SSO_PAGE_CNT_FUNC()
 static inline uint64_t CVMX_SSO_PAGE_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_PAGE_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001090ull);
 }
@@ -757,15 +780,16 @@ static inline uint64_t CVMX_SSO_PND_ECC_ST_FUNC(void)
 #define CVMX_SSO_PND_ECC_ST (CVMX_ADD_IO_SEG(0x00016700000010A8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_PPX_ARB(unsigned long block_id)
+static inline uint64_t CVMX_SSO_PPX_ARB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
-		cvmx_warn("CVMX_SSO_PPX_ARB(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670040000000ull) + ((block_id) & 63) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
+		cvmx_warn("CVMX_SSO_PPX_ARB(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670040000000ull) + ((offset) & 63) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_PPX_ARB(block_id) (CVMX_ADD_IO_SEG(0x0001670040000000ull) + ((block_id) & 63) * 0x10000ull)
+#define CVMX_SSO_PPX_ARB(offset) (CVMX_ADD_IO_SEG(0x0001670040000000ull) + ((offset) & 63) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SSO_PPX_GRP_MSK(unsigned long offset)
@@ -793,6 +817,7 @@ static inline uint64_t CVMX_SSO_PPX_QOS_PRI(unsigned long offset)
 static inline uint64_t CVMX_SSO_PPX_SX_GRPMSKX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 15)) && ((b <= 1)) && ((c == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 47)) && ((b <= 1)) && ((c <= 3))))))
 		cvmx_warn("CVMX_SSO_PPX_SX_GRPMSKX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001670040001000ull) + ((a) << 16) + ((b) << 5) + ((c) << 3);
@@ -850,6 +875,7 @@ static inline uint64_t CVMX_SSO_RESET_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
@@ -865,6 +891,7 @@ static inline uint64_t CVMX_SSO_RESET_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F0ull);
@@ -917,64 +944,70 @@ static inline uint64_t CVMX_SSO_RWQ_TAIL_PTRX(unsigned long offset)
 #define CVMX_SSO_RWQ_TAIL_PTRX(offset) (CVMX_ADD_IO_SEG(0x000167000000C200ull) + ((offset) & 7) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_SL_PPX_LINKS(unsigned long block_id)
+static inline uint64_t CVMX_SSO_SL_PPX_LINKS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
-		cvmx_warn("CVMX_SSO_SL_PPX_LINKS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670060000040ull) + ((block_id) & 63) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
+		cvmx_warn("CVMX_SSO_SL_PPX_LINKS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670060000040ull) + ((offset) & 63) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_SL_PPX_LINKS(block_id) (CVMX_ADD_IO_SEG(0x0001670060000040ull) + ((block_id) & 63) * 0x10000ull)
+#define CVMX_SSO_SL_PPX_LINKS(offset) (CVMX_ADD_IO_SEG(0x0001670060000040ull) + ((offset) & 63) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_SL_PPX_PENDTAG(unsigned long block_id)
+static inline uint64_t CVMX_SSO_SL_PPX_PENDTAG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
-		cvmx_warn("CVMX_SSO_SL_PPX_PENDTAG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670060000000ull) + ((block_id) & 63) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
+		cvmx_warn("CVMX_SSO_SL_PPX_PENDTAG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670060000000ull) + ((offset) & 63) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_SL_PPX_PENDTAG(block_id) (CVMX_ADD_IO_SEG(0x0001670060000000ull) + ((block_id) & 63) * 0x10000ull)
+#define CVMX_SSO_SL_PPX_PENDTAG(offset) (CVMX_ADD_IO_SEG(0x0001670060000000ull) + ((offset) & 63) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_SL_PPX_PENDWQP(unsigned long block_id)
+static inline uint64_t CVMX_SSO_SL_PPX_PENDWQP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
-		cvmx_warn("CVMX_SSO_SL_PPX_PENDWQP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670060000010ull) + ((block_id) & 63) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
+		cvmx_warn("CVMX_SSO_SL_PPX_PENDWQP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670060000010ull) + ((offset) & 63) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_SL_PPX_PENDWQP(block_id) (CVMX_ADD_IO_SEG(0x0001670060000010ull) + ((block_id) & 63) * 0x10000ull)
+#define CVMX_SSO_SL_PPX_PENDWQP(offset) (CVMX_ADD_IO_SEG(0x0001670060000010ull) + ((offset) & 63) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_SL_PPX_TAG(unsigned long block_id)
+static inline uint64_t CVMX_SSO_SL_PPX_TAG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
-		cvmx_warn("CVMX_SSO_SL_PPX_TAG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670060000020ull) + ((block_id) & 63) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
+		cvmx_warn("CVMX_SSO_SL_PPX_TAG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670060000020ull) + ((offset) & 63) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_SL_PPX_TAG(block_id) (CVMX_ADD_IO_SEG(0x0001670060000020ull) + ((block_id) & 63) * 0x10000ull)
+#define CVMX_SSO_SL_PPX_TAG(offset) (CVMX_ADD_IO_SEG(0x0001670060000020ull) + ((offset) & 63) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_SSO_SL_PPX_WQP(unsigned long block_id)
+static inline uint64_t CVMX_SSO_SL_PPX_WQP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
-		cvmx_warn("CVMX_SSO_SL_PPX_WQP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001670060000030ull) + ((block_id) & 63) * 0x10000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47)))))
+		cvmx_warn("CVMX_SSO_SL_PPX_WQP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001670060000030ull) + ((offset) & 63) * 0x10000ull;
 }
 #else
-#define CVMX_SSO_SL_PPX_WQP(block_id) (CVMX_ADD_IO_SEG(0x0001670060000030ull) + ((block_id) & 63) * 0x10000ull)
+#define CVMX_SSO_SL_PPX_WQP(offset) (CVMX_ADD_IO_SEG(0x0001670060000030ull) + ((offset) & 63) * 0x10000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SSO_TAQX_LINK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 319))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1279)))))
 		cvmx_warn("CVMX_SSO_TAQX_LINK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700C0000000ull) + ((offset) & 2047) * 4096;
@@ -986,6 +1019,7 @@ static inline uint64_t CVMX_SSO_TAQX_LINK(unsigned long offset)
 static inline uint64_t CVMX_SSO_TAQX_WAEX_TAG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 1279))))))
 		cvmx_warn("CVMX_SSO_TAQX_WAEX_TAG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00016700D0000000ull) + (((offset) & 15) + ((block_id) & 2047) * 0x100ull) * 16;
@@ -997,6 +1031,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_TAG(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_SSO_TAQX_WAEX_WQP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 1279))))))
 		cvmx_warn("CVMX_SSO_TAQX_WAEX_WQP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00016700D0000008ull) + (((offset) & 15) + ((block_id) & 2047) * 0x100ull) * 16;
@@ -1008,7 +1043,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_WQP(unsigned long offset, unsigned lon
 #define CVMX_SSO_TAQ_ADD CVMX_SSO_TAQ_ADD_FUNC()
 static inline uint64_t CVMX_SSO_TAQ_ADD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_TAQ_ADD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020E0ull);
 }
@@ -1019,7 +1054,7 @@ static inline uint64_t CVMX_SSO_TAQ_ADD_FUNC(void)
 #define CVMX_SSO_TAQ_CNT CVMX_SSO_TAQ_CNT_FUNC()
 static inline uint64_t CVMX_SSO_TAQ_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_TAQ_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020C0ull);
 }
@@ -1030,6 +1065,7 @@ static inline uint64_t CVMX_SSO_TAQ_CNT_FUNC(void)
 static inline uint64_t CVMX_SSO_TIAQX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_TIAQX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000C0000ull) + ((offset) & 255) * 8;
@@ -1041,6 +1077,7 @@ static inline uint64_t CVMX_SSO_TIAQX_STATUS(unsigned long offset)
 static inline uint64_t CVMX_SSO_TOAQX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_TOAQX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000D0000ull) + ((offset) & 255) * 8;
@@ -1107,7 +1144,7 @@ static inline uint64_t CVMX_SSO_WQ_INT_CNTX(unsigned long offset)
 #define CVMX_SSO_WQ_INT_PC CVMX_SSO_WQ_INT_PC_FUNC()
 static inline uint64_t CVMX_SSO_WQ_INT_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_WQ_INT_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001020ull);
 }
@@ -1140,7 +1177,7 @@ static inline uint64_t CVMX_SSO_WQ_IQ_DIS_FUNC(void)
 #define CVMX_SSO_WS_CFG CVMX_SSO_WS_CFG_FUNC()
 static inline uint64_t CVMX_SSO_WS_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_WS_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001088ull);
 }
@@ -1162,6 +1199,7 @@ static inline uint64_t CVMX_SSO_WS_PCX(unsigned long offset)
 static inline uint64_t CVMX_SSO_XAQX_HEAD_NEXT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_HEAD_NEXT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000A0000ull) + ((offset) & 255) * 8;
@@ -1173,6 +1211,7 @@ static inline uint64_t CVMX_SSO_XAQX_HEAD_NEXT(unsigned long offset)
 static inline uint64_t CVMX_SSO_XAQX_HEAD_PTR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_HEAD_PTR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000080000ull) + ((offset) & 255) * 8;
@@ -1184,6 +1223,7 @@ static inline uint64_t CVMX_SSO_XAQX_HEAD_PTR(unsigned long offset)
 static inline uint64_t CVMX_SSO_XAQX_TAIL_NEXT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_TAIL_NEXT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000B0000ull) + ((offset) & 255) * 8;
@@ -1195,6 +1235,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_NEXT(unsigned long offset)
 static inline uint64_t CVMX_SSO_XAQX_TAIL_PTR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_TAIL_PTR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000090000ull) + ((offset) & 255) * 8;
@@ -1206,7 +1247,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_PTR(unsigned long offset)
 #define CVMX_SSO_XAQ_AURA CVMX_SSO_XAQ_AURA_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_AURA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_AURA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002100ull);
 }
@@ -1217,7 +1258,7 @@ static inline uint64_t CVMX_SSO_XAQ_AURA_FUNC(void)
 #define CVMX_SSO_XAQ_LATENCY_PC CVMX_SSO_XAQ_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020B8ull);
 }
@@ -1228,7 +1269,7 @@ static inline uint64_t CVMX_SSO_XAQ_LATENCY_PC_FUNC(void)
 #define CVMX_SSO_XAQ_REQ_PC CVMX_SSO_XAQ_REQ_PC_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020B0ull);
 }
@@ -1272,6 +1313,7 @@ union cvmx_sso_active_cyclesx {
 	uint64_t act_cyc                      : 64;
 #endif
 	} s;
+	struct cvmx_sso_active_cyclesx_s      cn73xx;
 	struct cvmx_sso_active_cyclesx_s      cn78xx;
 };
 typedef union cvmx_sso_active_cyclesx cvmx_sso_active_cyclesx_t;
@@ -1293,6 +1335,7 @@ union cvmx_sso_aw_add {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_sso_aw_add_s              cn73xx;
 	struct cvmx_sso_aw_add_s              cn78xx;
 };
 typedef union cvmx_sso_aw_add cvmx_sso_aw_add_t;
@@ -1333,6 +1376,7 @@ union cvmx_sso_aw_cfg {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_sso_aw_cfg_s              cn73xx;
 	struct cvmx_sso_aw_cfg_s              cn78xx;
 };
 typedef union cvmx_sso_aw_cfg cvmx_sso_aw_cfg_t;
@@ -1367,6 +1411,7 @@ union cvmx_sso_aw_read_arb {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_sso_aw_read_arb_s         cn73xx;
 	struct cvmx_sso_aw_read_arb_s         cn78xx;
 };
 typedef union cvmx_sso_aw_read_arb cvmx_sso_aw_read_arb_t;
@@ -1388,6 +1433,7 @@ union cvmx_sso_aw_status {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_sso_aw_status_s           cn73xx;
 	struct cvmx_sso_aw_status_s           cn78xx;
 };
 typedef union cvmx_sso_aw_status cvmx_sso_aw_status_t;
@@ -1405,6 +1451,7 @@ union cvmx_sso_aw_tag_latency_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_sso_aw_tag_latency_pc_s   cn73xx;
 	struct cvmx_sso_aw_tag_latency_pc_s   cn78xx;
 };
 typedef union cvmx_sso_aw_tag_latency_pc cvmx_sso_aw_tag_latency_pc_t;
@@ -1421,6 +1468,7 @@ union cvmx_sso_aw_tag_req_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_sso_aw_tag_req_pc_s       cn73xx;
 	struct cvmx_sso_aw_tag_req_pc_s       cn78xx;
 };
 typedef union cvmx_sso_aw_tag_req_pc cvmx_sso_aw_tag_req_pc_t;
@@ -1447,6 +1495,7 @@ union cvmx_sso_aw_we {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
+	struct cvmx_sso_aw_we_s               cn73xx;
 	struct cvmx_sso_aw_we_s               cn78xx;
 };
 typedef union cvmx_sso_aw_we cvmx_sso_aw_we_t;
@@ -1585,6 +1634,7 @@ union cvmx_sso_bist_status0 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_sso_bist_status0_s        cn73xx;
 	struct cvmx_sso_bist_status0_s        cn78xx;
 };
 typedef union cvmx_sso_bist_status0 cvmx_sso_bist_status0_t;
@@ -1613,6 +1663,7 @@ union cvmx_sso_bist_status1 {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_sso_bist_status1_s        cn73xx;
 	struct cvmx_sso_bist_status1_s        cn78xx;
 };
 typedef union cvmx_sso_bist_status1 cvmx_sso_bist_status1_t;
@@ -1643,6 +1694,7 @@ union cvmx_sso_bist_status2 {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_sso_bist_status2_s        cn73xx;
 	struct cvmx_sso_bist_status2_s        cn78xx;
 };
 typedef union cvmx_sso_bist_status2 cvmx_sso_bist_status2_t;
@@ -1810,6 +1862,7 @@ union cvmx_sso_ecc_ctl0 {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_sso_ecc_ctl0_s            cn73xx;
 	struct cvmx_sso_ecc_ctl0_s            cn78xx;
 };
 typedef union cvmx_sso_ecc_ctl0 cvmx_sso_ecc_ctl0_t;
@@ -1855,6 +1908,7 @@ union cvmx_sso_ecc_ctl1 {
 	uint64_t reserved_21_63               : 43;
 #endif
 	} s;
+	struct cvmx_sso_ecc_ctl1_s            cn73xx;
 	struct cvmx_sso_ecc_ctl1_s            cn78xx;
 };
 typedef union cvmx_sso_ecc_ctl1 cvmx_sso_ecc_ctl1_t;
@@ -1892,6 +1946,7 @@ union cvmx_sso_ecc_ctl2 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_sso_ecc_ctl2_s            cn73xx;
 	struct cvmx_sso_ecc_ctl2_s            cn78xx;
 };
 typedef union cvmx_sso_ecc_ctl2 cvmx_sso_ecc_ctl2_t;
@@ -2055,6 +2110,7 @@ union cvmx_sso_err0 {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_sso_err0_s                cn73xx;
 	struct cvmx_sso_err0_s                cn78xx;
 };
 typedef union cvmx_sso_err0 cvmx_sso_err0_t;
@@ -2102,6 +2158,7 @@ union cvmx_sso_err1 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_sso_err1_s                cn73xx;
 	struct cvmx_sso_err1_s                cn78xx;
 };
 typedef union cvmx_sso_err1 cvmx_sso_err1_t;
@@ -2163,6 +2220,7 @@ union cvmx_sso_err2 {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_err2_s                cn73xx;
 	struct cvmx_sso_err2_s                cn78xx;
 };
 typedef union cvmx_sso_err2 cvmx_sso_err2_t;
@@ -2319,6 +2377,7 @@ union cvmx_sso_grpx_aq_cnt {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_sso_grpx_aq_cnt_s         cn73xx;
 	struct cvmx_sso_grpx_aq_cnt_s         cn78xx;
 };
 typedef union cvmx_sso_grpx_aq_cnt cvmx_sso_grpx_aq_cnt_t;
@@ -2338,6 +2397,7 @@ union cvmx_sso_grpx_aq_thr {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_sso_grpx_aq_thr_s         cn73xx;
 	struct cvmx_sso_grpx_aq_thr_s         cn78xx;
 };
 typedef union cvmx_sso_grpx_aq_thr cvmx_sso_grpx_aq_thr_t;
@@ -2358,6 +2418,7 @@ union cvmx_sso_grpx_ds_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_ds_pc_s          cn73xx;
 	struct cvmx_sso_grpx_ds_pc_s          cn78xx;
 };
 typedef union cvmx_sso_grpx_ds_pc cvmx_sso_grpx_ds_pc_t;
@@ -2379,6 +2440,7 @@ union cvmx_sso_grpx_ext_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_ext_pc_s         cn73xx;
 	struct cvmx_sso_grpx_ext_pc_s         cn78xx;
 };
 typedef union cvmx_sso_grpx_ext_pc cvmx_sso_grpx_ext_pc_t;
@@ -2415,6 +2477,7 @@ union cvmx_sso_grpx_iaq_thr {
 	uint64_t reserved_61_63               : 3;
 #endif
 	} s;
+	struct cvmx_sso_grpx_iaq_thr_s        cn73xx;
 	struct cvmx_sso_grpx_iaq_thr_s        cn78xx;
 };
 typedef union cvmx_sso_grpx_iaq_thr cvmx_sso_grpx_iaq_thr_t;
@@ -2458,6 +2521,7 @@ union cvmx_sso_grpx_int {
 	uint64_t exe_dis                      : 1;
 #endif
 	} s;
+	struct cvmx_sso_grpx_int_s            cn73xx;
 	struct cvmx_sso_grpx_int_s            cn78xx;
 };
 typedef union cvmx_sso_grpx_int cvmx_sso_grpx_int_t;
@@ -2499,6 +2563,7 @@ union cvmx_sso_grpx_int_cnt {
 	uint64_t reserved_61_63               : 3;
 #endif
 	} s;
+	struct cvmx_sso_grpx_int_cnt_s        cn73xx;
 	struct cvmx_sso_grpx_int_cnt_s        cn78xx;
 };
 typedef union cvmx_sso_grpx_int_cnt cvmx_sso_grpx_int_cnt_t;
@@ -2542,6 +2607,7 @@ union cvmx_sso_grpx_int_thr {
 	uint64_t tc_en                        : 1;
 #endif
 	} s;
+	struct cvmx_sso_grpx_int_thr_s        cn73xx;
 	struct cvmx_sso_grpx_int_thr_s        cn78xx;
 };
 typedef union cvmx_sso_grpx_int_thr cvmx_sso_grpx_int_thr_t;
@@ -2582,6 +2648,7 @@ union cvmx_sso_grpx_pri {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_sso_grpx_pri_s            cn73xx;
 	struct cvmx_sso_grpx_pri_s            cn78xx;
 };
 typedef union cvmx_sso_grpx_pri cvmx_sso_grpx_pri_t;
@@ -2617,6 +2684,7 @@ union cvmx_sso_grpx_taq_thr {
 	uint64_t reserved_59_63               : 5;
 #endif
 	} s;
+	struct cvmx_sso_grpx_taq_thr_s        cn73xx;
 	struct cvmx_sso_grpx_taq_thr_s        cn78xx;
 };
 typedef union cvmx_sso_grpx_taq_thr cvmx_sso_grpx_taq_thr_t;
@@ -2637,6 +2705,7 @@ union cvmx_sso_grpx_ts_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_ts_pc_s          cn73xx;
 	struct cvmx_sso_grpx_ts_pc_s          cn78xx;
 };
 typedef union cvmx_sso_grpx_ts_pc cvmx_sso_grpx_ts_pc_t;
@@ -2658,6 +2727,7 @@ union cvmx_sso_grpx_wa_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_wa_pc_s          cn73xx;
 	struct cvmx_sso_grpx_wa_pc_s          cn78xx;
 };
 typedef union cvmx_sso_grpx_wa_pc cvmx_sso_grpx_wa_pc_t;
@@ -2678,6 +2748,7 @@ union cvmx_sso_grpx_ws_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_ws_pc_s          cn73xx;
 	struct cvmx_sso_grpx_ws_pc_s          cn78xx;
 };
 typedef union cvmx_sso_grpx_ws_pc cvmx_sso_grpx_ws_pc_t;
@@ -2760,19 +2831,19 @@ union cvmx_sso_gwe_cfg {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} cn68xxp1;
-	struct cvmx_sso_gwe_cfg_cn78xx {
+	struct cvmx_sso_gwe_cfg_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t dis_wgt_credit               : 1;  /**< Disable group weight credits. When set, groups have infinite weight credit. */
 	uint64_t ws_retries                   : 8;  /**< Work slot retries. When a given work-slot performs this number of retries without
-                                                         successfully finding work then NO_WORK will be returned. Zero disables the retry counter.
-                                                         Values 1, 2, 3 are reserved. */
+                                                         successfully finding work then NO_WORK will be returned. Values 0, 1, 2, 3 are reserved. */
 #else
 	uint64_t ws_retries                   : 8;
 	uint64_t dis_wgt_credit               : 1;
 	uint64_t reserved_9_63                : 55;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sso_gwe_cfg_cn73xx        cn78xx;
 };
 typedef union cvmx_sso_gwe_cfg cvmx_sso_gwe_cfg_t;
 
@@ -2806,6 +2877,7 @@ union cvmx_sso_gwe_random {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_sso_gwe_random_s          cn73xx;
 	struct cvmx_sso_gwe_random_s          cn78xx;
 };
 typedef union cvmx_sso_gwe_random cvmx_sso_gwe_random_t;
@@ -2879,6 +2951,35 @@ union cvmx_sso_ientx_links {
 	uint64_t reserved_28_63               : 36;
 	uint64_t prev_index                   : 12; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
                                                          or the head of a conflicted tag chain. */
+	uint64_t reserved_0_15                : 16;
+#else
+	uint64_t reserved_0_15                : 16;
+	uint64_t prev_index                   : 12;
+	uint64_t reserved_28_63               : 36;
+#endif
+	} s;
+	struct cvmx_sso_ientx_links_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_26_63               : 38;
+	uint64_t prev_index                   : 10; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
+                                                         or the head of a conflicted tag chain. */
+	uint64_t reserved_11_15               : 5;
+	uint64_t next_index_vld               : 1;  /**< The NEXT_INDEX is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
+	uint64_t next_index                   : 10; /**< The next entry in the tag chain or conflicted tag chain. Unpredictable if the entry is at
+                                                         the tail of the list. */
+#else
+	uint64_t next_index                   : 10;
+	uint64_t next_index_vld               : 1;
+	uint64_t reserved_11_15               : 5;
+	uint64_t prev_index                   : 10;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} cn73xx;
+	struct cvmx_sso_ientx_links_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_28_63               : 36;
+	uint64_t prev_index                   : 12; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
+                                                         or the head of a conflicted tag chain. */
 	uint64_t reserved_13_15               : 3;
 	uint64_t next_index_vld               : 1;  /**< The NEXT_INDEX is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
 	uint64_t next_index                   : 12; /**< The next entry in the tag chain or conflicted tag chain. Unpredictable if the entry is at
@@ -2890,8 +2991,7 @@ union cvmx_sso_ientx_links {
 	uint64_t prev_index                   : 12;
 	uint64_t reserved_28_63               : 36;
 #endif
-	} s;
-	struct cvmx_sso_ientx_links_s         cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_sso_ientx_links cvmx_sso_ientx_links_t;
 
@@ -2919,6 +3019,7 @@ union cvmx_sso_ientx_pendtag {
 	uint64_t reserved_38_63               : 26;
 #endif
 	} s;
+	struct cvmx_sso_ientx_pendtag_s       cn73xx;
 	struct cvmx_sso_ientx_pendtag_s       cn78xx;
 };
 typedef union cvmx_sso_ientx_pendtag cvmx_sso_ientx_pendtag_t;
@@ -2940,6 +3041,7 @@ union cvmx_sso_ientx_qlinks {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_sso_ientx_qlinks_s        cn73xx;
 	struct cvmx_sso_ientx_qlinks_s        cn78xx;
 };
 typedef union cvmx_sso_ientx_qlinks cvmx_sso_ientx_qlinks_t;
@@ -2970,6 +3072,7 @@ union cvmx_sso_ientx_tag {
 	uint64_t reserved_39_63               : 25;
 #endif
 	} s;
+	struct cvmx_sso_ientx_tag_s           cn73xx;
 	struct cvmx_sso_ientx_tag_s           cn78xx;
 };
 typedef union cvmx_sso_ientx_tag cvmx_sso_ientx_tag_t;
@@ -3002,6 +3105,27 @@ union cvmx_sso_ientx_wqpgrp {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_sso_ientx_wqpgrp_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_62_63               : 2;
+	uint64_t head                         : 1;  /**< SSO entry is at the head of a tag chain that is descheduled. */
+	uint64_t nosched                      : 1;  /**< The nosched bit for the SSO entry. */
+	uint64_t reserved_56_59               : 4;
+	uint64_t grp                          : 8;  /**< Group of the SSO entry.
+                                                         INTERNAL:
+                                                         The upper bits are not stored in the RAM, but rather indicate the OCI node number. */
+	uint64_t reserved_42_47               : 6;
+	uint64_t wqp                          : 42; /**< Work queue pointer held in the SSO entry. */
+#else
+	uint64_t wqp                          : 42;
+	uint64_t reserved_42_47               : 6;
+	uint64_t grp                          : 8;
+	uint64_t reserved_56_59               : 4;
+	uint64_t nosched                      : 1;
+	uint64_t head                         : 1;
+	uint64_t reserved_62_63               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_sso_ientx_wqpgrp_s        cn78xx;
 };
 typedef union cvmx_sso_ientx_wqpgrp cvmx_sso_ientx_wqpgrp_t;
@@ -3033,6 +3157,7 @@ union cvmx_sso_ipl_confx {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_sso_ipl_confx_s           cn73xx;
 	struct cvmx_sso_ipl_confx_s           cn78xx;
 };
 typedef union cvmx_sso_ipl_confx cvmx_sso_ipl_confx_t;
@@ -3064,6 +3189,7 @@ union cvmx_sso_ipl_deschedx {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_sso_ipl_deschedx_s        cn73xx;
 	struct cvmx_sso_ipl_deschedx_s        cn78xx;
 };
 typedef union cvmx_sso_ipl_deschedx cvmx_sso_ipl_deschedx_t;
@@ -3080,13 +3206,13 @@ union cvmx_sso_ipl_freex {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_62_63               : 2;
 	uint64_t qnum_head                    : 3;  /**< Subqueue with current head. */
-	uint64_t qnum_tail                    : 3;  /**< Subqueue with current tail. */
+	uint64_t qnum_tail                    : 3;  /**< Subqueue for next tail. */
 	uint64_t reserved_28_55               : 28;
-	uint64_t queue_val                    : 1;  /**< One or more valid entries are in the queue. */
+	uint64_t queue_val                    : 1;  /**< One or more valid entries are in this subqueue. */
 	uint64_t reserved_25_26               : 2;
-	uint64_t queue_head                   : 12; /**< Index of entry at the head of the queue. */
+	uint64_t queue_head                   : 12; /**< Index of entry at the head of this subqueue. */
 	uint64_t reserved_12_12               : 1;
-	uint64_t queue_tail                   : 12; /**< Index of entry at the tail of the queue. */
+	uint64_t queue_tail                   : 12; /**< Index of entry at the tail of this subqueue. */
 #else
 	uint64_t queue_tail                   : 12;
 	uint64_t reserved_12_12               : 1;
@@ -3099,6 +3225,29 @@ union cvmx_sso_ipl_freex {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_sso_ipl_freex_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_62_63               : 2;
+	uint64_t qnum_head                    : 3;  /**< Subqueue with current head. */
+	uint64_t qnum_tail                    : 3;  /**< Subqueue for next tail. */
+	uint64_t reserved_28_55               : 28;
+	uint64_t queue_val                    : 1;  /**< One or more valid entries are in this subqueue. */
+	uint64_t reserved_23_26               : 4;
+	uint64_t queue_head                   : 10; /**< Index of entry at the head of this subqueue. */
+	uint64_t reserved_10_12               : 3;
+	uint64_t queue_tail                   : 10; /**< Index of entry at the tail of this subqueue. */
+#else
+	uint64_t queue_tail                   : 10;
+	uint64_t reserved_10_12               : 3;
+	uint64_t queue_head                   : 10;
+	uint64_t reserved_23_26               : 4;
+	uint64_t queue_val                    : 1;
+	uint64_t reserved_28_55               : 28;
+	uint64_t qnum_tail                    : 3;
+	uint64_t qnum_head                    : 3;
+	uint64_t reserved_62_63               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_sso_ipl_freex_s           cn78xx;
 };
 typedef union cvmx_sso_ipl_freex cvmx_sso_ipl_freex_t;
@@ -3130,6 +3279,7 @@ union cvmx_sso_ipl_iaqx {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_sso_ipl_iaqx_s            cn73xx;
 	struct cvmx_sso_ipl_iaqx_s            cn78xx;
 };
 typedef union cvmx_sso_ipl_iaqx cvmx_sso_ipl_iaqx_t;
@@ -3286,6 +3436,7 @@ union cvmx_sso_nos_cnt {
 #endif
 	} cn68xx;
 	struct cvmx_sso_nos_cnt_cn68xx        cn68xxp1;
+	struct cvmx_sso_nos_cnt_s             cn73xx;
 	struct cvmx_sso_nos_cnt_s             cn78xx;
 };
 typedef union cvmx_sso_nos_cnt cvmx_sso_nos_cnt_t;
@@ -3314,6 +3465,7 @@ union cvmx_sso_nw_tim {
 	} s;
 	struct cvmx_sso_nw_tim_s              cn68xx;
 	struct cvmx_sso_nw_tim_s              cn68xxp1;
+	struct cvmx_sso_nw_tim_s              cn73xx;
 	struct cvmx_sso_nw_tim_s              cn78xx;
 };
 typedef union cvmx_sso_nw_tim cvmx_sso_nw_tim_t;
@@ -3405,6 +3557,7 @@ union cvmx_sso_page_cnt {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_sso_page_cnt_s            cn73xx;
 	struct cvmx_sso_page_cnt_s            cn78xx;
 };
 typedef union cvmx_sso_page_cnt cvmx_sso_page_cnt_t;
@@ -3502,6 +3655,7 @@ union cvmx_sso_ppx_arb {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_sso_ppx_arb_s             cn73xx;
 	struct cvmx_sso_ppx_arb_s             cn78xx;
 };
 typedef union cvmx_sso_ppx_arb cvmx_sso_ppx_arb_t;
@@ -3604,7 +3758,7 @@ typedef union cvmx_sso_ppx_qos_pri cvmx_sso_ppx_qos_pri_t;
  * cvmx_sso_pp#_s#_grpmsk#
  *
  * These registers select which group or groups a core belongs to. There are 2 sets of masks per
- * core, each with 4 registers corresponding to 64 bit slices of the 256 groups.
+ * core, each with 1 register corresponding to 64 groups.
  */
 union cvmx_sso_ppx_sx_grpmskx {
 	uint64_t u64;
@@ -3624,6 +3778,7 @@ union cvmx_sso_ppx_sx_grpmskx {
 	uint64_t grp_msk                      : 64;
 #endif
 	} s;
+	struct cvmx_sso_ppx_sx_grpmskx_s      cn73xx;
 	struct cvmx_sso_ppx_sx_grpmskx_s      cn78xx;
 };
 typedef union cvmx_sso_ppx_sx_grpmskx cvmx_sso_ppx_sx_grpmskx_t;
@@ -3803,6 +3958,7 @@ union cvmx_sso_reset {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} cn68xx;
+	struct cvmx_sso_reset_s               cn73xx;
 	struct cvmx_sso_reset_s               cn78xx;
 };
 typedef union cvmx_sso_reset cvmx_sso_reset_t;
@@ -3966,6 +4122,62 @@ union cvmx_sso_sl_ppx_links {
                                                          The upper two bits are hardcoded to the node number. */
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t reserved_0_25                : 26;
+#else
+	uint64_t reserved_0_25                : 26;
+	uint64_t tail                         : 1;
+	uint64_t head                         : 1;
+	uint64_t grp                          : 10;
+	uint64_t reserved_38_47               : 10;
+	uint64_t index                        : 12;
+	uint64_t reserved_60_62               : 3;
+	uint64_t tailc                        : 1;
+#endif
+	} s;
+	struct cvmx_sso_sl_ppx_links_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t tailc                        : 1;  /**< Set when this SSO entry is the tail of the conflicted tail chain, and so there are no
+                                                         additional conflicts on this tag chain. */
+	uint64_t reserved_58_62               : 5;
+	uint64_t index                        : 10; /**< The SSO entry attached to the core. */
+	uint64_t reserved_36_47               : 12;
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         INTERNAL:
+                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t reserved_21_25               : 5;
+	uint64_t revlink_index                : 10; /**< Prior SSO entry in the tag list when HEAD=0 and TT is not UNTAGGED nor EMPTY, otherwise
+                                                         unpredictable. */
+	uint64_t link_index_vld               : 1;  /**< Indicates LINK_INDEX is valid. LINK_INDEX_VLD is itself valid when TAIL=1 and TT=ATOMIC,
+                                                         otherwise unpredictable. */
+	uint64_t link_index                   : 10; /**< Next SSO entry in the tag list when LINK_INDEX_VLD=1, TAILC=0 and TT=ATOMIC,
+                                                         otherwise unpredictable. */
+#else
+	uint64_t link_index                   : 10;
+	uint64_t link_index_vld               : 1;
+	uint64_t revlink_index                : 10;
+	uint64_t reserved_21_25               : 5;
+	uint64_t tail                         : 1;
+	uint64_t head                         : 1;
+	uint64_t grp                          : 8;
+	uint64_t reserved_36_47               : 12;
+	uint64_t index                        : 10;
+	uint64_t reserved_58_62               : 5;
+	uint64_t tailc                        : 1;
+#endif
+	} cn73xx;
+	struct cvmx_sso_sl_ppx_links_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t tailc                        : 1;  /**< Set when this SSO entry is the tail of the conflicted tail chain, and so there are no
+                                                         additional conflicts on this tag chain. */
+	uint64_t reserved_60_62               : 3;
+	uint64_t index                        : 12; /**< The SSO entry attached to the core. */
+	uint64_t reserved_38_47               : 10;
+	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t reserved_25_25               : 1;
 	uint64_t revlink_index                : 12; /**< Prior SSO entry in the tag list when HEAD=0 and TT is not UNTAGGED nor EMPTY, otherwise
                                                          unpredictable. */
@@ -3986,8 +4198,7 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t reserved_60_62               : 3;
 	uint64_t tailc                        : 1;
 #endif
-	} s;
-	struct cvmx_sso_sl_ppx_links_s        cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_links cvmx_sso_sl_ppx_links_t;
 
@@ -4026,6 +4237,7 @@ union cvmx_sso_sl_ppx_pendtag {
 	uint64_t pend_switch                  : 1;
 #endif
 	} s;
+	struct cvmx_sso_sl_ppx_pendtag_s      cn73xx;
 	struct cvmx_sso_sl_ppx_pendtag_s      cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_pendtag cvmx_sso_sl_ppx_pendtag_t;
@@ -4067,6 +4279,35 @@ union cvmx_sso_sl_ppx_pendwqp {
 	uint64_t pend_switch                  : 1;
 #endif
 	} s;
+	struct cvmx_sso_sl_ppx_pendwqp_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pend_switch                  : 1;  /**< Set when there is a pending SWTAG, SWTAG_DESCHED, or SWTAG_FULL to ORDERED or ATOMIC. If
+                                                         the status load was issued after an indexed GET_WORK, the DESCHED portion of a
+                                                         SWTAG_DESCHED cannot still be pending. */
+	uint64_t pend_get_work                : 1;  /**< Set when there is a pending GET_WORK. */
+	uint64_t pend_get_work_wait           : 1;  /**< When PEND_GET_WORK is set, indicates that the WAITW bit was set. */
+	uint64_t pend_nosched                 : 1;  /**< Set when nosched is desired and PEND_DESCHED is set. */
+	uint64_t pend_nosched_clr             : 1;  /**< Set when there is a pending CLR_NSCHED. */
+	uint64_t pend_desched                 : 1;  /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
+	uint64_t pend_alloc_we                : 1;  /**< Set when there is a pending ALLOC_WE. */
+	uint64_t reserved_54_56               : 3;
+	uint64_t pend_index                   : 10; /**< The index when PEND_NOSCHED_CLR is set. */
+	uint64_t reserved_42_43               : 2;
+	uint64_t pend_wqp                     : 42; /**< The WQP when PEND_NOSCHED_CLR is set. */
+#else
+	uint64_t pend_wqp                     : 42;
+	uint64_t reserved_42_43               : 2;
+	uint64_t pend_index                   : 10;
+	uint64_t reserved_54_56               : 3;
+	uint64_t pend_alloc_we                : 1;
+	uint64_t pend_desched                 : 1;
+	uint64_t pend_nosched_clr             : 1;
+	uint64_t pend_nosched                 : 1;
+	uint64_t pend_get_work_wait           : 1;
+	uint64_t pend_get_work                : 1;
+	uint64_t pend_switch                  : 1;
+#endif
+	} cn73xx;
 	struct cvmx_sso_sl_ppx_pendwqp_s      cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_pendwqp cvmx_sso_sl_ppx_pendwqp_t;
@@ -4106,6 +4347,34 @@ union cvmx_sso_sl_ppx_tag {
 	uint64_t tailc                        : 1;
 #endif
 	} s;
+	struct cvmx_sso_sl_ppx_tag_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t tailc                        : 1;  /**< Set when this SSO entry is the tail of the conflicted tail chain, and so there are no
+                                                         additional conflicts on this tag chain. */
+	uint64_t reserved_58_62               : 5;
+	uint64_t index                        : 10; /**< The SSO entry attached to the core. */
+	uint64_t reserved_44_47               : 4;
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         INTERNAL:
+                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t tt                           : 2;  /**< The tag type attached to the core (updated when new tag list entered on SWTAG, SWTAG_FULL,
+                                                         or SWTAG_DESCHED.) */
+	uint64_t tag                          : 32; /**< The tag attached to the core (updated when new tag list entered on SWTAG, SWTAG_FULL, or
+                                                         SWTAG_DESCHED.) */
+#else
+	uint64_t tag                          : 32;
+	uint64_t tt                           : 2;
+	uint64_t tail                         : 1;
+	uint64_t head                         : 1;
+	uint64_t grp                          : 8;
+	uint64_t reserved_44_47               : 4;
+	uint64_t index                        : 10;
+	uint64_t reserved_58_62               : 5;
+	uint64_t tailc                        : 1;
+#endif
+	} cn73xx;
 	struct cvmx_sso_sl_ppx_tag_s          cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_tag cvmx_sso_sl_ppx_tag_t;
@@ -4132,6 +4401,21 @@ union cvmx_sso_sl_ppx_wqp {
 	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
+	struct cvmx_sso_sl_ppx_wqp_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_56_63               : 8;
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         INTERNAL:
+                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t reserved_42_47               : 6;
+	uint64_t wqp                          : 42; /**< The WQP attached to the core (updated when new tag list entered on SWTAG_FULL.) */
+#else
+	uint64_t wqp                          : 42;
+	uint64_t reserved_42_47               : 6;
+	uint64_t grp                          : 8;
+	uint64_t reserved_56_63               : 8;
+#endif
+	} cn73xx;
 	struct cvmx_sso_sl_ppx_wqp_s          cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_wqp cvmx_sso_sl_ppx_wqp_t;
@@ -4153,6 +4437,7 @@ union cvmx_sso_taqx_link {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_sso_taqx_link_s           cn73xx;
 	struct cvmx_sso_taqx_link_s           cn78xx;
 };
 typedef union cvmx_sso_taqx_link cvmx_sso_taqx_link_t;
@@ -4176,6 +4461,7 @@ union cvmx_sso_taqx_waex_tag {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_sso_taqx_waex_tag_s       cn73xx;
 	struct cvmx_sso_taqx_waex_tag_s       cn78xx;
 };
 typedef union cvmx_sso_taqx_waex_tag cvmx_sso_taqx_waex_tag_t;
@@ -4197,6 +4483,7 @@ union cvmx_sso_taqx_waex_wqp {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_taqx_waex_wqp_s       cn73xx;
 	struct cvmx_sso_taqx_waex_wqp_s       cn78xx;
 };
 typedef union cvmx_sso_taqx_waex_wqp cvmx_sso_taqx_waex_wqp_t;
@@ -4218,6 +4505,7 @@ union cvmx_sso_taq_add {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
+	struct cvmx_sso_taq_add_s             cn73xx;
 	struct cvmx_sso_taq_add_s             cn78xx;
 };
 typedef union cvmx_sso_taq_add cvmx_sso_taq_add_t;
@@ -4244,6 +4532,7 @@ union cvmx_sso_taq_cnt {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_sso_taq_cnt_s             cn73xx;
 	struct cvmx_sso_taq_cnt_s             cn78xx;
 };
 typedef union cvmx_sso_taq_cnt cvmx_sso_taq_cnt_t;
@@ -4283,6 +4572,7 @@ union cvmx_sso_tiaqx_status {
 	uint64_t wae_head                     : 4;
 #endif
 	} s;
+	struct cvmx_sso_tiaqx_status_s        cn73xx;
 	struct cvmx_sso_tiaqx_status_s        cn78xx;
 };
 typedef union cvmx_sso_tiaqx_status cvmx_sso_tiaqx_status_t;
@@ -4325,6 +4615,7 @@ union cvmx_sso_toaqx_status {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_sso_toaqx_status_s        cn73xx;
 	struct cvmx_sso_toaqx_status_s        cn78xx;
 };
 typedef union cvmx_sso_toaqx_status cvmx_sso_toaqx_status_t;
@@ -4501,7 +4792,8 @@ union cvmx_sso_wq_int_pc {
 	uint64_t reserved_60_63               : 4;
 	uint64_t pc                           : 28; /**< Work-executable interrupt periodic counter. */
 	uint64_t reserved_28_31               : 4;
-	uint64_t pc_thr                       : 20; /**< Work-executable interrupt periodic counter threshold. Zero disables the counter. */
+	uint64_t pc_thr                       : 20; /**< Work-executable interrupt periodic counter threshold. Zero disables the counter.
+                                                         If non-zero, the value must be >= 3. */
 	uint64_t reserved_0_7                 : 8;
 #else
 	uint64_t reserved_0_7                 : 8;
@@ -4513,6 +4805,7 @@ union cvmx_sso_wq_int_pc {
 	} s;
 	struct cvmx_sso_wq_int_pc_s           cn68xx;
 	struct cvmx_sso_wq_int_pc_s           cn68xxp1;
+	struct cvmx_sso_wq_int_pc_s           cn73xx;
 	struct cvmx_sso_wq_int_pc_s           cn78xx;
 };
 typedef union cvmx_sso_wq_int_pc cvmx_sso_wq_int_pc_t;
@@ -4617,6 +4910,41 @@ union cvmx_sso_ws_cfg {
                                                          <50> = Work-slot CAM access. (arbc).
                                                          <49> = Work-slot RAM access. (arbr).
                                                          <48> = Work-slot pushes to AQ, CQ, DQ. (arbq). */
+	uint64_t reserved_7_47                : 41;
+	uint64_t aw_clk_dis                   : 1;  /**< Reserved. */
+	uint64_t gw_clk_dis                   : 1;  /**< Reserved. */
+	uint64_t disable_pw                   : 1;  /**< Reserved. */
+	uint64_t arbc_step_en                 : 1;  /**< Enable single-stepping WS CAM arbiter, twice per 16 clocks. For diagnostic use only. */
+	uint64_t ncbo_step_en                 : 1;  /**< Enable single-stepping commands from NCBO, once per 32 clocks. For diagnostic use only. */
+	uint64_t soc_ccam_dis                 : 1;  /**< Disable power saving SOC conditional CAM. */
+	uint64_t sso_cclk_dis                 : 1;  /**< Disable power saving SSO conditional clocking, */
+#else
+	uint64_t sso_cclk_dis                 : 1;
+	uint64_t soc_ccam_dis                 : 1;
+	uint64_t ncbo_step_en                 : 1;
+	uint64_t arbc_step_en                 : 1;
+	uint64_t disable_pw                   : 1;
+	uint64_t gw_clk_dis                   : 1;
+	uint64_t aw_clk_dis                   : 1;
+	uint64_t reserved_7_47                : 41;
+	uint64_t ocla_bp                      : 8;
+	uint64_t reserved_56_63               : 8;
+#endif
+	} s;
+	struct cvmx_sso_ws_cfg_s              cn73xx;
+	struct cvmx_sso_ws_cfg_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_56_63               : 8;
+	uint64_t ocla_bp                      : 8;  /**< Enable OCLA backpressure stalls. For diagnostic use only.
+                                                         INTERNAL:
+                                                         <55> = NCBB input fifo stall (ncbo).
+                                                         <54> = Work-slot response. (arbrsp).
+                                                         <53> = Work-slot switching of descheduled work entries. (arbx).
+                                                         <52> = Work-slot SWTAG response. (arbs).
+                                                         <51> = Work-slot access to get-work engine. (arbgw).
+                                                         <50> = Work-slot CAM access. (arbc).
+                                                         <49> = Work-slot RAM access. (arbr).
+                                                         <48> = Work-slot pushes to AQ, CQ, DQ. (arbq). */
 	uint64_t reserved_5_47                : 43;
 	uint64_t disable_pw                   : 1;  /**< Reserved. */
 	uint64_t arbc_step_en                 : 1;  /**< Enable single-stepping WS CAM arbiter, twice per 16 clocks. For diagnostic use only. */
@@ -4633,8 +4961,7 @@ union cvmx_sso_ws_cfg {
 	uint64_t ocla_bp                      : 8;
 	uint64_t reserved_56_63               : 8;
 #endif
-	} s;
-	struct cvmx_sso_ws_cfg_s              cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_sso_ws_cfg cvmx_sso_ws_cfg_t;
 
@@ -4683,6 +5010,7 @@ union cvmx_sso_xaqx_head_next {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_xaqx_head_next_s      cn73xx;
 	struct cvmx_sso_xaqx_head_next_s      cn78xx;
 };
 typedef union cvmx_sso_xaqx_head_next cvmx_sso_xaqx_head_next_t;
@@ -4711,6 +5039,7 @@ union cvmx_sso_xaqx_head_ptr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_xaqx_head_ptr_s       cn73xx;
 	struct cvmx_sso_xaqx_head_ptr_s       cn78xx;
 };
 typedef union cvmx_sso_xaqx_head_ptr cvmx_sso_xaqx_head_ptr_t;
@@ -4736,6 +5065,7 @@ union cvmx_sso_xaqx_tail_next {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_xaqx_tail_next_s      cn73xx;
 	struct cvmx_sso_xaqx_tail_next_s      cn78xx;
 };
 typedef union cvmx_sso_xaqx_tail_next cvmx_sso_xaqx_tail_next_t;
@@ -4762,6 +5092,7 @@ union cvmx_sso_xaqx_tail_ptr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_xaqx_tail_ptr_s       cn73xx;
 	struct cvmx_sso_xaqx_tail_ptr_s       cn78xx;
 };
 typedef union cvmx_sso_xaqx_tail_ptr cvmx_sso_xaqx_tail_ptr_t;
@@ -4775,15 +5106,16 @@ union cvmx_sso_xaq_aura {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t node                         : 2;  /**< Node number of current chip, to ensure that the aura is on the local node. */
-	uint64_t laura                        : 10; /**< FPA local-node aura to use for SSO XAQ allocations and frees. The FPA aura selected by
-                                                         LAURA must select a pool with FPA_POOL()_CFG[NAT_ALIGN]=1, and
-                                                         (FPA_POOL()_CFG[BUF_SIZE] - FPA_POOL()_CFG[BUF_OFFSET]) >= 4 KB / 128. */
+	uint64_t laura                        : 10; /**< FPA local-node aura to use for SSO XAQ allocations and frees. The FPA aura
+                                                         selected by LAURA must correspond to a pool where the buffers (after any
+                                                         FPA_POOL()_CFG[BUF_OFFSET]) are at least 4 KB. */
 #else
 	uint64_t laura                        : 10;
 	uint64_t node                         : 2;
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_sso_xaq_aura_s            cn73xx;
 	struct cvmx_sso_xaq_aura_s            cn78xx;
 };
 typedef union cvmx_sso_xaq_aura cvmx_sso_xaq_aura_t;
@@ -4801,6 +5133,7 @@ union cvmx_sso_xaq_latency_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_sso_xaq_latency_pc_s      cn73xx;
 	struct cvmx_sso_xaq_latency_pc_s      cn78xx;
 };
 typedef union cvmx_sso_xaq_latency_pc cvmx_sso_xaq_latency_pc_t;
@@ -4817,6 +5150,7 @@ union cvmx_sso_xaq_req_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_sso_xaq_req_pc_s          cn73xx;
 	struct cvmx_sso_xaq_req_pc_s          cn78xx;
 };
 typedef union cvmx_sso_xaq_req_pc cvmx_sso_xaq_req_pc_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-stxx-defs.h b/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
index d27ccd0..8d30529 100644
--- a/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
@@ -53,112 +53,112 @@
 #define __CVMX_STXX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_ARB_CTL(unsigned long block_id)
+static inline uint64_t CVMX_STXX_ARB_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_ARB_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000608ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_ARB_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000608ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_ARB_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000608ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_ARB_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000608ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_BCKPRS_CNT(unsigned long block_id)
+static inline uint64_t CVMX_STXX_BCKPRS_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_BCKPRS_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000688ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_BCKPRS_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000688ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_BCKPRS_CNT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000688ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_BCKPRS_CNT(offset) (CVMX_ADD_IO_SEG(0x0001180090000688ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_COM_CTL(unsigned long block_id)
+static inline uint64_t CVMX_STXX_COM_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_COM_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000600ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_COM_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000600ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_COM_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000600ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_COM_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000600ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_DIP_CNT(unsigned long block_id)
+static inline uint64_t CVMX_STXX_DIP_CNT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_DIP_CNT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000690ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_DIP_CNT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000690ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_DIP_CNT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000690ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_DIP_CNT(offset) (CVMX_ADD_IO_SEG(0x0001180090000690ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_IGN_CAL(unsigned long block_id)
+static inline uint64_t CVMX_STXX_IGN_CAL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_IGN_CAL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000610ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_IGN_CAL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000610ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_IGN_CAL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000610ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_IGN_CAL(offset) (CVMX_ADD_IO_SEG(0x0001180090000610ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_INT_MSK(unsigned long block_id)
+static inline uint64_t CVMX_STXX_INT_MSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_INT_MSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_INT_MSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_INT_MSK(block_id) (CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_INT_MSK(offset) (CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_STXX_INT_REG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_INT_REG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_INT_REG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_INT_REG(block_id) (CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_INT_REG(offset) (CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_INT_SYNC(unsigned long block_id)
+static inline uint64_t CVMX_STXX_INT_SYNC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_INT_SYNC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800900006A8ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_INT_SYNC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800900006A8ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_INT_SYNC(block_id) (CVMX_ADD_IO_SEG(0x00011800900006A8ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_INT_SYNC(offset) (CVMX_ADD_IO_SEG(0x00011800900006A8ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_MIN_BST(unsigned long block_id)
+static inline uint64_t CVMX_STXX_MIN_BST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_MIN_BST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000618ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_MIN_BST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000618ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_MIN_BST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000618ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_MIN_BST(offset) (CVMX_ADD_IO_SEG(0x0001180090000618ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_STXX_SPI4_CALX(unsigned long offset, unsigned long block_id)
@@ -173,76 +173,76 @@ static inline uint64_t CVMX_STXX_SPI4_CALX(unsigned long offset, unsigned long b
 #define CVMX_STXX_SPI4_CALX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090000400ull) + (((offset) & 31) + ((block_id) & 1) * 0x1000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_SPI4_DAT(unsigned long block_id)
+static inline uint64_t CVMX_STXX_SPI4_DAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_SPI4_DAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000628ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_SPI4_DAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000628ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_SPI4_DAT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000628ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_SPI4_DAT(offset) (CVMX_ADD_IO_SEG(0x0001180090000628ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_SPI4_STAT(unsigned long block_id)
+static inline uint64_t CVMX_STXX_SPI4_STAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_SPI4_STAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000630ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_SPI4_STAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000630ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_SPI4_STAT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000630ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_SPI4_STAT(offset) (CVMX_ADD_IO_SEG(0x0001180090000630ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_STAT_BYTES_HI(unsigned long block_id)
+static inline uint64_t CVMX_STXX_STAT_BYTES_HI(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_STAT_BYTES_HI(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000648ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_STAT_BYTES_HI(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000648ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_STAT_BYTES_HI(block_id) (CVMX_ADD_IO_SEG(0x0001180090000648ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_STAT_BYTES_HI(offset) (CVMX_ADD_IO_SEG(0x0001180090000648ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_STAT_BYTES_LO(unsigned long block_id)
+static inline uint64_t CVMX_STXX_STAT_BYTES_LO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_STAT_BYTES_LO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000680ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_STAT_BYTES_LO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000680ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_STAT_BYTES_LO(block_id) (CVMX_ADD_IO_SEG(0x0001180090000680ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_STAT_BYTES_LO(offset) (CVMX_ADD_IO_SEG(0x0001180090000680ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_STAT_CTL(unsigned long block_id)
+static inline uint64_t CVMX_STXX_STAT_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_STAT_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000638ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_STAT_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000638ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_STAT_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000638ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_STAT_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180090000638ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_STXX_STAT_PKT_XMT(unsigned long block_id)
+static inline uint64_t CVMX_STXX_STAT_PKT_XMT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_STXX_STAT_PKT_XMT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090000640ull) + ((block_id) & 1) * 0x8000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_STXX_STAT_PKT_XMT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090000640ull) + ((offset) & 1) * 0x8000000ull;
 }
 #else
-#define CVMX_STXX_STAT_PKT_XMT(block_id) (CVMX_ADD_IO_SEG(0x0001180090000640ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_STXX_STAT_PKT_XMT(offset) (CVMX_ADD_IO_SEG(0x0001180090000640ull) + ((offset) & 1) * 0x8000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h b/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
index b994cd8..f99192a 100644
--- a/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
@@ -53,48 +53,48 @@
 #define __CVMX_UAHCX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_CAPLENGTH(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_CAPLENGTH(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_CAPLENGTH(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_CAPLENGTH(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000000ull);
 }
 #else
-#define CVMX_UAHCX_CAPLENGTH(block_id) (CVMX_ADD_IO_SEG(0x0001680000000000ull))
+#define CVMX_UAHCX_CAPLENGTH(offset) (CVMX_ADD_IO_SEG(0x0001680000000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_CONFIG(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_CONFIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_CONFIG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_CONFIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000058ull);
 }
 #else
-#define CVMX_UAHCX_CONFIG(block_id) (CVMX_ADD_IO_SEG(0x0001680000000058ull))
+#define CVMX_UAHCX_CONFIG(offset) (CVMX_ADD_IO_SEG(0x0001680000000058ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_CRCR(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_CRCR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_CRCR(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_CRCR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000038ull);
 }
 #else
-#define CVMX_UAHCX_CRCR(block_id) (CVMX_ADD_IO_SEG(0x0001680000000038ull))
+#define CVMX_UAHCX_CRCR(offset) (CVMX_ADD_IO_SEG(0x0001680000000038ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_DBOFF(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_DBOFF(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_DBOFF(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_DBOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000014ull);
 }
 #else
-#define CVMX_UAHCX_DBOFF(block_id) (CVMX_ADD_IO_SEG(0x0001680000000014ull))
+#define CVMX_UAHCX_DBOFF(offset) (CVMX_ADD_IO_SEG(0x0001680000000014ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_DBX(unsigned long offset, unsigned long block_id)
@@ -108,221 +108,221 @@ static inline uint64_t CVMX_UAHCX_DBX(unsigned long offset, unsigned long block_
 #define CVMX_UAHCX_DBX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000480ull) + (((offset) & 127) + ((block_id) & 0) * 0x0ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_DCBAAP(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_DCBAAP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_DCBAAP(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_DCBAAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000050ull);
 }
 #else
-#define CVMX_UAHCX_DCBAAP(block_id) (CVMX_ADD_IO_SEG(0x0001680000000050ull))
+#define CVMX_UAHCX_DCBAAP(offset) (CVMX_ADD_IO_SEG(0x0001680000000050ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_DNCTRL(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_DNCTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_DNCTRL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_DNCTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000034ull);
 }
 #else
-#define CVMX_UAHCX_DNCTRL(block_id) (CVMX_ADD_IO_SEG(0x0001680000000034ull))
+#define CVMX_UAHCX_DNCTRL(offset) (CVMX_ADD_IO_SEG(0x0001680000000034ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_ASYNCLISTADDR(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_ASYNCLISTADDR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_ASYNCLISTADDR(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_ASYNCLISTADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000028ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_ASYNCLISTADDR(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000028ull))
+#define CVMX_UAHCX_EHCI_ASYNCLISTADDR(offset) (CVMX_ADD_IO_SEG(0x00016F0000000028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_CONFIGFLAG(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_CONFIGFLAG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_CONFIGFLAG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_CONFIGFLAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000050ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_CONFIGFLAG(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000050ull))
+#define CVMX_UAHCX_EHCI_CONFIGFLAG(offset) (CVMX_ADD_IO_SEG(0x00016F0000000050ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_CTRLDSSEGMENT(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_CTRLDSSEGMENT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_CTRLDSSEGMENT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_CTRLDSSEGMENT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000020ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_CTRLDSSEGMENT(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000020ull))
+#define CVMX_UAHCX_EHCI_CTRLDSSEGMENT(offset) (CVMX_ADD_IO_SEG(0x00016F0000000020ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_FRINDEX(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_FRINDEX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_FRINDEX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_FRINDEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F000000001Cull);
 }
 #else
-#define CVMX_UAHCX_EHCI_FRINDEX(block_id) (CVMX_ADD_IO_SEG(0x00016F000000001Cull))
+#define CVMX_UAHCX_EHCI_FRINDEX(offset) (CVMX_ADD_IO_SEG(0x00016F000000001Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_HCCAPBASE(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_HCCAPBASE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_HCCAPBASE(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_HCCAPBASE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000000ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_HCCAPBASE(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000000ull))
+#define CVMX_UAHCX_EHCI_HCCAPBASE(offset) (CVMX_ADD_IO_SEG(0x00016F0000000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_HCCPARAMS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_HCCPARAMS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_HCCPARAMS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_HCCPARAMS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000008ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_HCCPARAMS(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000008ull))
+#define CVMX_UAHCX_EHCI_HCCPARAMS(offset) (CVMX_ADD_IO_SEG(0x00016F0000000008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_HCSPARAMS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_HCSPARAMS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_HCSPARAMS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_HCSPARAMS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000004ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_HCSPARAMS(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000004ull))
+#define CVMX_UAHCX_EHCI_HCSPARAMS(offset) (CVMX_ADD_IO_SEG(0x00016F0000000004ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_INSNREG00(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_INSNREG00(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG00(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG00(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000090ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_INSNREG00(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000090ull))
+#define CVMX_UAHCX_EHCI_INSNREG00(offset) (CVMX_ADD_IO_SEG(0x00016F0000000090ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_INSNREG03(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_INSNREG03(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG03(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG03(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F000000009Cull);
 }
 #else
-#define CVMX_UAHCX_EHCI_INSNREG03(block_id) (CVMX_ADD_IO_SEG(0x00016F000000009Cull))
+#define CVMX_UAHCX_EHCI_INSNREG03(offset) (CVMX_ADD_IO_SEG(0x00016F000000009Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_INSNREG04(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_INSNREG04(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG04(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG04(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F00000000A0ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_INSNREG04(block_id) (CVMX_ADD_IO_SEG(0x00016F00000000A0ull))
+#define CVMX_UAHCX_EHCI_INSNREG04(offset) (CVMX_ADD_IO_SEG(0x00016F00000000A0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_INSNREG06(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_INSNREG06(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG06(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG06(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F00000000E8ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_INSNREG06(block_id) (CVMX_ADD_IO_SEG(0x00016F00000000E8ull))
+#define CVMX_UAHCX_EHCI_INSNREG06(offset) (CVMX_ADD_IO_SEG(0x00016F00000000E8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_INSNREG07(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_INSNREG07(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG07(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_INSNREG07(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F00000000ECull);
 }
 #else
-#define CVMX_UAHCX_EHCI_INSNREG07(block_id) (CVMX_ADD_IO_SEG(0x00016F00000000ECull))
+#define CVMX_UAHCX_EHCI_INSNREG07(offset) (CVMX_ADD_IO_SEG(0x00016F00000000ECull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_PERIODICLISTBASE(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_PERIODICLISTBASE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_PERIODICLISTBASE(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_PERIODICLISTBASE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000024ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_PERIODICLISTBASE(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000024ull))
+#define CVMX_UAHCX_EHCI_PERIODICLISTBASE(offset) (CVMX_ADD_IO_SEG(0x00016F0000000024ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_EHCI_PORTSCX(unsigned long offset, unsigned long block_id)
@@ -340,49 +340,49 @@ static inline uint64_t CVMX_UAHCX_EHCI_PORTSCX(unsigned long offset, unsigned lo
 #define CVMX_UAHCX_EHCI_PORTSCX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0000000050ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_USBCMD(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_USBCMD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_USBCMD(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_USBCMD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000010ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_USBCMD(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000010ull))
+#define CVMX_UAHCX_EHCI_USBCMD(offset) (CVMX_ADD_IO_SEG(0x00016F0000000010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_USBINTR(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_USBINTR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_USBINTR(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_USBINTR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000018ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_USBINTR(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000018ull))
+#define CVMX_UAHCX_EHCI_USBINTR(offset) (CVMX_ADD_IO_SEG(0x00016F0000000018ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_EHCI_USBSTS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_EHCI_USBSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_EHCI_USBSTS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_EHCI_USBSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000014ull);
 }
 #else
-#define CVMX_UAHCX_EHCI_USBSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000014ull))
+#define CVMX_UAHCX_EHCI_USBSTS(offset) (CVMX_ADD_IO_SEG(0x00016F0000000014ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_ERDPX(unsigned long offset, unsigned long block_id)
@@ -418,301 +418,301 @@ static inline uint64_t CVMX_UAHCX_ERSTSZX(unsigned long offset, unsigned long bl
 #define CVMX_UAHCX_ERSTSZX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000468ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GBUSERRADDR(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GBUSERRADDR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GBUSERRADDR(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GBUSERRADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C130ull);
 }
 #else
-#define CVMX_UAHCX_GBUSERRADDR(block_id) (CVMX_ADD_IO_SEG(0x000168000000C130ull))
+#define CVMX_UAHCX_GBUSERRADDR(offset) (CVMX_ADD_IO_SEG(0x000168000000C130ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GCTL(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GCTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C110ull);
 }
 #else
-#define CVMX_UAHCX_GCTL(block_id) (CVMX_ADD_IO_SEG(0x000168000000C110ull))
+#define CVMX_UAHCX_GCTL(offset) (CVMX_ADD_IO_SEG(0x000168000000C110ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GDBGBMU(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GDBGBMU(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GDBGBMU(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GDBGBMU(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C16Cull);
 }
 #else
-#define CVMX_UAHCX_GDBGBMU(block_id) (CVMX_ADD_IO_SEG(0x000168000000C16Cull))
+#define CVMX_UAHCX_GDBGBMU(offset) (CVMX_ADD_IO_SEG(0x000168000000C16Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GDBGEPINFO(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GDBGEPINFO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GDBGEPINFO(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GDBGEPINFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C178ull);
 }
 #else
-#define CVMX_UAHCX_GDBGEPINFO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C178ull))
+#define CVMX_UAHCX_GDBGEPINFO(offset) (CVMX_ADD_IO_SEG(0x000168000000C178ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GDBGFIFOSPACE(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GDBGFIFOSPACE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GDBGFIFOSPACE(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GDBGFIFOSPACE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C160ull);
 }
 #else
-#define CVMX_UAHCX_GDBGFIFOSPACE(block_id) (CVMX_ADD_IO_SEG(0x000168000000C160ull))
+#define CVMX_UAHCX_GDBGFIFOSPACE(offset) (CVMX_ADD_IO_SEG(0x000168000000C160ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GDBGLNMCC(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GDBGLNMCC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GDBGLNMCC(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GDBGLNMCC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C168ull);
 }
 #else
-#define CVMX_UAHCX_GDBGLNMCC(block_id) (CVMX_ADD_IO_SEG(0x000168000000C168ull))
+#define CVMX_UAHCX_GDBGLNMCC(offset) (CVMX_ADD_IO_SEG(0x000168000000C168ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GDBGLSP(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GDBGLSP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GDBGLSP(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GDBGLSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C174ull);
 }
 #else
-#define CVMX_UAHCX_GDBGLSP(block_id) (CVMX_ADD_IO_SEG(0x000168000000C174ull))
+#define CVMX_UAHCX_GDBGLSP(offset) (CVMX_ADD_IO_SEG(0x000168000000C174ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GDBGLSPMUX(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GDBGLSPMUX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GDBGLSPMUX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GDBGLSPMUX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C170ull);
 }
 #else
-#define CVMX_UAHCX_GDBGLSPMUX(block_id) (CVMX_ADD_IO_SEG(0x000168000000C170ull))
+#define CVMX_UAHCX_GDBGLSPMUX(offset) (CVMX_ADD_IO_SEG(0x000168000000C170ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GDBGLTSSM(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GDBGLTSSM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GDBGLTSSM(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GDBGLTSSM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C164ull);
 }
 #else
-#define CVMX_UAHCX_GDBGLTSSM(block_id) (CVMX_ADD_IO_SEG(0x000168000000C164ull))
+#define CVMX_UAHCX_GDBGLTSSM(offset) (CVMX_ADD_IO_SEG(0x000168000000C164ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GDMAHLRATIO(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GDMAHLRATIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GDMAHLRATIO(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GDMAHLRATIO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C624ull);
 }
 #else
-#define CVMX_UAHCX_GDMAHLRATIO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C624ull))
+#define CVMX_UAHCX_GDMAHLRATIO(offset) (CVMX_ADD_IO_SEG(0x000168000000C624ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GFLADJ(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GFLADJ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GFLADJ(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GFLADJ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C630ull);
 }
 #else
-#define CVMX_UAHCX_GFLADJ(block_id) (CVMX_ADD_IO_SEG(0x000168000000C630ull))
+#define CVMX_UAHCX_GFLADJ(offset) (CVMX_ADD_IO_SEG(0x000168000000C630ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GGPIO(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GGPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GGPIO(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GGPIO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C124ull);
 }
 #else
-#define CVMX_UAHCX_GGPIO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C124ull))
+#define CVMX_UAHCX_GGPIO(offset) (CVMX_ADD_IO_SEG(0x000168000000C124ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS0(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C140ull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS0(block_id) (CVMX_ADD_IO_SEG(0x000168000000C140ull))
+#define CVMX_UAHCX_GHWPARAMS0(offset) (CVMX_ADD_IO_SEG(0x000168000000C140ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS1(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C144ull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C144ull))
+#define CVMX_UAHCX_GHWPARAMS1(offset) (CVMX_ADD_IO_SEG(0x000168000000C144ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS2(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS2(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C148ull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS2(block_id) (CVMX_ADD_IO_SEG(0x000168000000C148ull))
+#define CVMX_UAHCX_GHWPARAMS2(offset) (CVMX_ADD_IO_SEG(0x000168000000C148ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS3(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS3(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C14Cull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS3(block_id) (CVMX_ADD_IO_SEG(0x000168000000C14Cull))
+#define CVMX_UAHCX_GHWPARAMS3(offset) (CVMX_ADD_IO_SEG(0x000168000000C14Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS4(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS4(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C150ull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS4(block_id) (CVMX_ADD_IO_SEG(0x000168000000C150ull))
+#define CVMX_UAHCX_GHWPARAMS4(offset) (CVMX_ADD_IO_SEG(0x000168000000C150ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS5(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS5(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS5(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C154ull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS5(block_id) (CVMX_ADD_IO_SEG(0x000168000000C154ull))
+#define CVMX_UAHCX_GHWPARAMS5(offset) (CVMX_ADD_IO_SEG(0x000168000000C154ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS6(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS6(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS6(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C158ull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS6(block_id) (CVMX_ADD_IO_SEG(0x000168000000C158ull))
+#define CVMX_UAHCX_GHWPARAMS6(offset) (CVMX_ADD_IO_SEG(0x000168000000C158ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS7(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS7(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS7(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C15Cull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS7(block_id) (CVMX_ADD_IO_SEG(0x000168000000C15Cull))
+#define CVMX_UAHCX_GHWPARAMS7(offset) (CVMX_ADD_IO_SEG(0x000168000000C15Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GHWPARAMS8(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GHWPARAMS8(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GHWPARAMS8(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GHWPARAMS8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C600ull);
 }
 #else
-#define CVMX_UAHCX_GHWPARAMS8(block_id) (CVMX_ADD_IO_SEG(0x000168000000C600ull))
+#define CVMX_UAHCX_GHWPARAMS8(offset) (CVMX_ADD_IO_SEG(0x000168000000C600ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GPMSTS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GPMSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GPMSTS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GPMSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C114ull);
 }
 #else
-#define CVMX_UAHCX_GPMSTS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C114ull))
+#define CVMX_UAHCX_GPMSTS(offset) (CVMX_ADD_IO_SEG(0x000168000000C114ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GPRTBIMAP(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GPRTBIMAP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GPRTBIMAP(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GPRTBIMAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C138ull);
 }
 #else
-#define CVMX_UAHCX_GPRTBIMAP(block_id) (CVMX_ADD_IO_SEG(0x000168000000C138ull))
+#define CVMX_UAHCX_GPRTBIMAP(offset) (CVMX_ADD_IO_SEG(0x000168000000C138ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GPRTBIMAP_FS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GPRTBIMAP_FS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GPRTBIMAP_FS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GPRTBIMAP_FS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C188ull);
 }
 #else
-#define CVMX_UAHCX_GPRTBIMAP_FS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C188ull))
+#define CVMX_UAHCX_GPRTBIMAP_FS(offset) (CVMX_ADD_IO_SEG(0x000168000000C188ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GPRTBIMAP_HS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GPRTBIMAP_HS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GPRTBIMAP_HS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GPRTBIMAP_HS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C180ull);
 }
 #else
-#define CVMX_UAHCX_GPRTBIMAP_HS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C180ull))
+#define CVMX_UAHCX_GPRTBIMAP_HS(offset) (CVMX_ADD_IO_SEG(0x000168000000C180ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GRLSID(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GRLSID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GRLSID(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GRLSID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C120ull);
 }
 #else
-#define CVMX_UAHCX_GRLSID(block_id) (CVMX_ADD_IO_SEG(0x000168000000C120ull))
+#define CVMX_UAHCX_GRLSID(offset) (CVMX_ADD_IO_SEG(0x000168000000C120ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GRXFIFOPRIHST(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GRXFIFOPRIHST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GRXFIFOPRIHST(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GRXFIFOPRIHST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C61Cull);
 }
 #else
-#define CVMX_UAHCX_GRXFIFOPRIHST(block_id) (CVMX_ADD_IO_SEG(0x000168000000C61Cull))
+#define CVMX_UAHCX_GRXFIFOPRIHST(offset) (CVMX_ADD_IO_SEG(0x000168000000C61Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_GRXFIFOSIZX(unsigned long offset, unsigned long block_id)
@@ -726,59 +726,59 @@ static inline uint64_t CVMX_UAHCX_GRXFIFOSIZX(unsigned long offset, unsigned lon
 #define CVMX_UAHCX_GRXFIFOSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C380ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GRXTHRCFG(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GRXTHRCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GRXTHRCFG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GRXTHRCFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C10Cull);
 }
 #else
-#define CVMX_UAHCX_GRXTHRCFG(block_id) (CVMX_ADD_IO_SEG(0x000168000000C10Cull))
+#define CVMX_UAHCX_GRXTHRCFG(offset) (CVMX_ADD_IO_SEG(0x000168000000C10Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GSBUSCFG0(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GSBUSCFG0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GSBUSCFG0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GSBUSCFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C100ull);
 }
 #else
-#define CVMX_UAHCX_GSBUSCFG0(block_id) (CVMX_ADD_IO_SEG(0x000168000000C100ull))
+#define CVMX_UAHCX_GSBUSCFG0(offset) (CVMX_ADD_IO_SEG(0x000168000000C100ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GSBUSCFG1(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GSBUSCFG1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GSBUSCFG1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GSBUSCFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C104ull);
 }
 #else
-#define CVMX_UAHCX_GSBUSCFG1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C104ull))
+#define CVMX_UAHCX_GSBUSCFG1(offset) (CVMX_ADD_IO_SEG(0x000168000000C104ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GSTS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GSTS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C118ull);
 }
 #else
-#define CVMX_UAHCX_GSTS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C118ull))
+#define CVMX_UAHCX_GSTS(offset) (CVMX_ADD_IO_SEG(0x000168000000C118ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GTXFIFOPRIHST(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GTXFIFOPRIHST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GTXFIFOPRIHST(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GTXFIFOPRIHST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C618ull);
 }
 #else
-#define CVMX_UAHCX_GTXFIFOPRIHST(block_id) (CVMX_ADD_IO_SEG(0x000168000000C618ull))
+#define CVMX_UAHCX_GTXFIFOPRIHST(offset) (CVMX_ADD_IO_SEG(0x000168000000C618ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_GTXFIFOSIZX(unsigned long offset, unsigned long block_id)
@@ -792,48 +792,48 @@ static inline uint64_t CVMX_UAHCX_GTXFIFOSIZX(unsigned long offset, unsigned lon
 #define CVMX_UAHCX_GTXFIFOSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C300ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GTXTHRCFG(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GTXTHRCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GTXTHRCFG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GTXTHRCFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C108ull);
 }
 #else
-#define CVMX_UAHCX_GTXTHRCFG(block_id) (CVMX_ADD_IO_SEG(0x000168000000C108ull))
+#define CVMX_UAHCX_GTXTHRCFG(offset) (CVMX_ADD_IO_SEG(0x000168000000C108ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GUCTL(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GUCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GUCTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GUCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C12Cull);
 }
 #else
-#define CVMX_UAHCX_GUCTL(block_id) (CVMX_ADD_IO_SEG(0x000168000000C12Cull))
+#define CVMX_UAHCX_GUCTL(offset) (CVMX_ADD_IO_SEG(0x000168000000C12Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GUCTL1(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GUCTL1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GUCTL1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GUCTL1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C11Cull);
 }
 #else
-#define CVMX_UAHCX_GUCTL1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C11Cull))
+#define CVMX_UAHCX_GUCTL1(offset) (CVMX_ADD_IO_SEG(0x000168000000C11Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_GUID(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_GUID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_GUID(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_GUID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C128ull);
 }
 #else
-#define CVMX_UAHCX_GUID(block_id) (CVMX_ADD_IO_SEG(0x000168000000C128ull))
+#define CVMX_UAHCX_GUID(offset) (CVMX_ADD_IO_SEG(0x000168000000C128ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_GUSB2I2CCTLX(unsigned long offset, unsigned long block_id)
@@ -869,48 +869,48 @@ static inline uint64_t CVMX_UAHCX_GUSB3PIPECTLX(unsigned long offset, unsigned l
 #define CVMX_UAHCX_GUSB3PIPECTLX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C2C0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_HCCPARAMS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_HCCPARAMS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_HCCPARAMS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_HCCPARAMS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000010ull);
 }
 #else
-#define CVMX_UAHCX_HCCPARAMS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000010ull))
+#define CVMX_UAHCX_HCCPARAMS(offset) (CVMX_ADD_IO_SEG(0x0001680000000010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_HCSPARAMS1(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_HCSPARAMS1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_HCSPARAMS1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_HCSPARAMS1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000004ull);
 }
 #else
-#define CVMX_UAHCX_HCSPARAMS1(block_id) (CVMX_ADD_IO_SEG(0x0001680000000004ull))
+#define CVMX_UAHCX_HCSPARAMS1(offset) (CVMX_ADD_IO_SEG(0x0001680000000004ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_HCSPARAMS2(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_HCSPARAMS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_HCSPARAMS2(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_HCSPARAMS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000008ull);
 }
 #else
-#define CVMX_UAHCX_HCSPARAMS2(block_id) (CVMX_ADD_IO_SEG(0x0001680000000008ull))
+#define CVMX_UAHCX_HCSPARAMS2(offset) (CVMX_ADD_IO_SEG(0x0001680000000008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_HCSPARAMS3(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_HCSPARAMS3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_HCSPARAMS3(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_HCSPARAMS3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000000Cull);
 }
 #else
-#define CVMX_UAHCX_HCSPARAMS3(block_id) (CVMX_ADD_IO_SEG(0x000168000000000Cull))
+#define CVMX_UAHCX_HCSPARAMS3(offset) (CVMX_ADD_IO_SEG(0x000168000000000Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_IMANX(unsigned long offset, unsigned long block_id)
@@ -935,315 +935,315 @@ static inline uint64_t CVMX_UAHCX_IMODX(unsigned long offset, unsigned long bloc
 #define CVMX_UAHCX_IMODX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000464ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_MFINDEX(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_MFINDEX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_MFINDEX(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_MFINDEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000440ull);
 }
 #else
-#define CVMX_UAHCX_MFINDEX(block_id) (CVMX_ADD_IO_SEG(0x0001680000000440ull))
+#define CVMX_UAHCX_MFINDEX(offset) (CVMX_ADD_IO_SEG(0x0001680000000440ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCBULKCURRENTED(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCBULKCURRENTED(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCBULKCURRENTED(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCBULKCURRENTED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F000000042Cull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCBULKCURRENTED(block_id) (CVMX_ADD_IO_SEG(0x00016F000000042Cull))
+#define CVMX_UAHCX_OHCI0_HCBULKCURRENTED(offset) (CVMX_ADD_IO_SEG(0x00016F000000042Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCBULKHEADED(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCBULKHEADED(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCBULKHEADED(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCBULKHEADED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000428ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCBULKHEADED(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000428ull))
+#define CVMX_UAHCX_OHCI0_HCBULKHEADED(offset) (CVMX_ADD_IO_SEG(0x00016F0000000428ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCCOMMANDSTATUS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCCOMMANDSTATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCCOMMANDSTATUS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCCOMMANDSTATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000408ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCCOMMANDSTATUS(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000408ull))
+#define CVMX_UAHCX_OHCI0_HCCOMMANDSTATUS(offset) (CVMX_ADD_IO_SEG(0x00016F0000000408ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCCONTROL(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCCONTROL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCCONTROL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCCONTROL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000404ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCCONTROL(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000404ull))
+#define CVMX_UAHCX_OHCI0_HCCONTROL(offset) (CVMX_ADD_IO_SEG(0x00016F0000000404ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCCONTROLCURRENTED(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCCONTROLCURRENTED(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCCONTROLCURRENTED(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCCONTROLCURRENTED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000424ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCCONTROLCURRENTED(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000424ull))
+#define CVMX_UAHCX_OHCI0_HCCONTROLCURRENTED(offset) (CVMX_ADD_IO_SEG(0x00016F0000000424ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCCONTROLHEADED(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCCONTROLHEADED(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCCONTROLHEADED(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCCONTROLHEADED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000420ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCCONTROLHEADED(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000420ull))
+#define CVMX_UAHCX_OHCI0_HCCONTROLHEADED(offset) (CVMX_ADD_IO_SEG(0x00016F0000000420ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCDONEHEAD(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCDONEHEAD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCDONEHEAD(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCDONEHEAD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000430ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCDONEHEAD(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000430ull))
+#define CVMX_UAHCX_OHCI0_HCDONEHEAD(offset) (CVMX_ADD_IO_SEG(0x00016F0000000430ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCFMINTERVAL(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCFMINTERVAL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCFMINTERVAL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCFMINTERVAL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000434ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCFMINTERVAL(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000434ull))
+#define CVMX_UAHCX_OHCI0_HCFMINTERVAL(offset) (CVMX_ADD_IO_SEG(0x00016F0000000434ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCFMNUMBER(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCFMNUMBER(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCFMNUMBER(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCFMNUMBER(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F000000043Cull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCFMNUMBER(block_id) (CVMX_ADD_IO_SEG(0x00016F000000043Cull))
+#define CVMX_UAHCX_OHCI0_HCFMNUMBER(offset) (CVMX_ADD_IO_SEG(0x00016F000000043Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCFMREMAINING(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCFMREMAINING(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCFMREMAINING(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCFMREMAINING(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000438ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCFMREMAINING(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000438ull))
+#define CVMX_UAHCX_OHCI0_HCFMREMAINING(offset) (CVMX_ADD_IO_SEG(0x00016F0000000438ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCHCCA(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCHCCA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCHCCA(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCHCCA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000418ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCHCCA(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000418ull))
+#define CVMX_UAHCX_OHCI0_HCHCCA(offset) (CVMX_ADD_IO_SEG(0x00016F0000000418ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCINTERRUPTDISABLE(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCINTERRUPTDISABLE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCINTERRUPTDISABLE(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCINTERRUPTDISABLE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000414ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCINTERRUPTDISABLE(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000414ull))
+#define CVMX_UAHCX_OHCI0_HCINTERRUPTDISABLE(offset) (CVMX_ADD_IO_SEG(0x00016F0000000414ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCINTERRUPTENABLE(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCINTERRUPTENABLE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCINTERRUPTENABLE(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCINTERRUPTENABLE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000410ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCINTERRUPTENABLE(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000410ull))
+#define CVMX_UAHCX_OHCI0_HCINTERRUPTENABLE(offset) (CVMX_ADD_IO_SEG(0x00016F0000000410ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCINTERRUPTSTATUS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCINTERRUPTSTATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCINTERRUPTSTATUS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCINTERRUPTSTATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F000000040Cull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCINTERRUPTSTATUS(block_id) (CVMX_ADD_IO_SEG(0x00016F000000040Cull))
+#define CVMX_UAHCX_OHCI0_HCINTERRUPTSTATUS(offset) (CVMX_ADD_IO_SEG(0x00016F000000040Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCLSTHRESHOLD(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCLSTHRESHOLD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCLSTHRESHOLD(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCLSTHRESHOLD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000444ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCLSTHRESHOLD(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000444ull))
+#define CVMX_UAHCX_OHCI0_HCLSTHRESHOLD(offset) (CVMX_ADD_IO_SEG(0x00016F0000000444ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCPERIODCURRENTED(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCPERIODCURRENTED(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCPERIODCURRENTED(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCPERIODCURRENTED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F000000041Cull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCPERIODCURRENTED(block_id) (CVMX_ADD_IO_SEG(0x00016F000000041Cull))
+#define CVMX_UAHCX_OHCI0_HCPERIODCURRENTED(offset) (CVMX_ADD_IO_SEG(0x00016F000000041Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCPERIODICSTART(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCPERIODICSTART(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCPERIODICSTART(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCPERIODICSTART(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000440ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCPERIODICSTART(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000440ull))
+#define CVMX_UAHCX_OHCI0_HCPERIODICSTART(offset) (CVMX_ADD_IO_SEG(0x00016F0000000440ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCREVISION(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCREVISION(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCREVISION(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCREVISION(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000400ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCREVISION(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000400ull))
+#define CVMX_UAHCX_OHCI0_HCREVISION(offset) (CVMX_ADD_IO_SEG(0x00016F0000000400ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCRHDESCRIPTORA(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCRHDESCRIPTORA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCRHDESCRIPTORA(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCRHDESCRIPTORA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000448ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCRHDESCRIPTORA(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000448ull))
+#define CVMX_UAHCX_OHCI0_HCRHDESCRIPTORA(offset) (CVMX_ADD_IO_SEG(0x00016F0000000448ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCRHDESCRIPTORB(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCRHDESCRIPTORB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCRHDESCRIPTORB(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCRHDESCRIPTORB(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F000000044Cull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCRHDESCRIPTORB(block_id) (CVMX_ADD_IO_SEG(0x00016F000000044Cull))
+#define CVMX_UAHCX_OHCI0_HCRHDESCRIPTORB(offset) (CVMX_ADD_IO_SEG(0x00016F000000044Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_OHCI0_HCRHPORTSTATUSX(unsigned long offset, unsigned long block_id)
@@ -1261,60 +1261,60 @@ static inline uint64_t CVMX_UAHCX_OHCI0_HCRHPORTSTATUSX(unsigned long offset, un
 #define CVMX_UAHCX_OHCI0_HCRHPORTSTATUSX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0000000450ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_HCRHSTATUS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_HCRHSTATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_HCRHSTATUS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_HCRHSTATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000450ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_HCRHSTATUS(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000450ull))
+#define CVMX_UAHCX_OHCI0_HCRHSTATUS(offset) (CVMX_ADD_IO_SEG(0x00016F0000000450ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_INSNREG06(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_INSNREG06(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_INSNREG06(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_INSNREG06(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F0000000498ull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_INSNREG06(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000498ull))
+#define CVMX_UAHCX_OHCI0_INSNREG06(offset) (CVMX_ADD_IO_SEG(0x00016F0000000498ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_OHCI0_INSNREG07(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_OHCI0_INSNREG07(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_OHCI0_INSNREG07(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_OHCI0_INSNREG07(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016F000000049Cull);
 }
 #else
-#define CVMX_UAHCX_OHCI0_INSNREG07(block_id) (CVMX_ADD_IO_SEG(0x00016F000000049Cull))
+#define CVMX_UAHCX_OHCI0_INSNREG07(offset) (CVMX_ADD_IO_SEG(0x00016F000000049Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_PAGESIZE(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_PAGESIZE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_PAGESIZE(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_PAGESIZE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000028ull);
 }
 #else
-#define CVMX_UAHCX_PAGESIZE(block_id) (CVMX_ADD_IO_SEG(0x0001680000000028ull))
+#define CVMX_UAHCX_PAGESIZE(offset) (CVMX_ADD_IO_SEG(0x0001680000000028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UAHCX_PORTHLPMC_20X(unsigned long offset, unsigned long block_id)
@@ -1394,147 +1394,147 @@ static inline uint64_t CVMX_UAHCX_PORTSCX(unsigned long offset, unsigned long bl
 #define CVMX_UAHCX_PORTSCX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000420ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_RTSOFF(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_RTSOFF(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_RTSOFF(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_RTSOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000018ull);
 }
 #else
-#define CVMX_UAHCX_RTSOFF(block_id) (CVMX_ADD_IO_SEG(0x0001680000000018ull))
+#define CVMX_UAHCX_RTSOFF(offset) (CVMX_ADD_IO_SEG(0x0001680000000018ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW0(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000890ull);
 }
 #else
-#define CVMX_UAHCX_SUPTPRT2_DW0(block_id) (CVMX_ADD_IO_SEG(0x0001680000000890ull))
+#define CVMX_UAHCX_SUPTPRT2_DW0(offset) (CVMX_ADD_IO_SEG(0x0001680000000890ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW1(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000894ull);
 }
 #else
-#define CVMX_UAHCX_SUPTPRT2_DW1(block_id) (CVMX_ADD_IO_SEG(0x0001680000000894ull))
+#define CVMX_UAHCX_SUPTPRT2_DW1(offset) (CVMX_ADD_IO_SEG(0x0001680000000894ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW2(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW2(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000898ull);
 }
 #else
-#define CVMX_UAHCX_SUPTPRT2_DW2(block_id) (CVMX_ADD_IO_SEG(0x0001680000000898ull))
+#define CVMX_UAHCX_SUPTPRT2_DW2(offset) (CVMX_ADD_IO_SEG(0x0001680000000898ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW3(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW3(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000089Cull);
 }
 #else
-#define CVMX_UAHCX_SUPTPRT2_DW3(block_id) (CVMX_ADD_IO_SEG(0x000168000000089Cull))
+#define CVMX_UAHCX_SUPTPRT2_DW3(offset) (CVMX_ADD_IO_SEG(0x000168000000089Cull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW0(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A0ull);
 }
 #else
-#define CVMX_UAHCX_SUPTPRT3_DW0(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A0ull))
+#define CVMX_UAHCX_SUPTPRT3_DW0(offset) (CVMX_ADD_IO_SEG(0x00016800000008A0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW1(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A4ull);
 }
 #else
-#define CVMX_UAHCX_SUPTPRT3_DW1(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A4ull))
+#define CVMX_UAHCX_SUPTPRT3_DW1(offset) (CVMX_ADD_IO_SEG(0x00016800000008A4ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW2(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW2(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A8ull);
 }
 #else
-#define CVMX_UAHCX_SUPTPRT3_DW2(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A8ull))
+#define CVMX_UAHCX_SUPTPRT3_DW2(offset) (CVMX_ADD_IO_SEG(0x00016800000008A8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW3(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW3(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008ACull);
 }
 #else
-#define CVMX_UAHCX_SUPTPRT3_DW3(block_id) (CVMX_ADD_IO_SEG(0x00016800000008ACull))
+#define CVMX_UAHCX_SUPTPRT3_DW3(offset) (CVMX_ADD_IO_SEG(0x00016800000008ACull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_USBCMD(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_USBCMD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_USBCMD(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_USBCMD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000020ull);
 }
 #else
-#define CVMX_UAHCX_USBCMD(block_id) (CVMX_ADD_IO_SEG(0x0001680000000020ull))
+#define CVMX_UAHCX_USBCMD(offset) (CVMX_ADD_IO_SEG(0x0001680000000020ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_USBLEGCTLSTS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_USBLEGCTLSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_USBLEGCTLSTS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_USBLEGCTLSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000884ull);
 }
 #else
-#define CVMX_UAHCX_USBLEGCTLSTS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000884ull))
+#define CVMX_UAHCX_USBLEGCTLSTS(offset) (CVMX_ADD_IO_SEG(0x0001680000000884ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_USBLEGSUP(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_USBLEGSUP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_USBLEGSUP(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_USBLEGSUP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000880ull);
 }
 #else
-#define CVMX_UAHCX_USBLEGSUP(block_id) (CVMX_ADD_IO_SEG(0x0001680000000880ull))
+#define CVMX_UAHCX_USBLEGSUP(offset) (CVMX_ADD_IO_SEG(0x0001680000000880ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UAHCX_USBSTS(unsigned long block_id)
+static inline uint64_t CVMX_UAHCX_USBSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UAHCX_USBSTS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UAHCX_USBSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000024ull);
 }
 #else
-#define CVMX_UAHCX_USBSTS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000024ull))
+#define CVMX_UAHCX_USBSTS(offset) (CVMX_ADD_IO_SEG(0x0001680000000024ull))
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
index 59f6e90..0a9c527 100644
--- a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
@@ -53,7 +53,7 @@
 #define __CVMX_UCTLX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_BIST_STATUS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -61,19 +61,19 @@ static inline uint64_t CVMX_UCTLX_BIST_STATUS(unsigned long block_id)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x000118006F0000A0ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
+			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180068000008ull);
 			break;
 	}
-	cvmx_warn("CVMX_UCTLX_BIST_STATUS (block_id = %lu) not supported on this chip\n", block_id);
+	cvmx_warn("CVMX_UCTLX_BIST_STATUS (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F0000A0ull);
 }
 #else
-static inline uint64_t CVMX_UCTLX_BIST_STATUS(unsigned long block_id __attribute__ ((unused)))
+static inline uint64_t CVMX_UCTLX_BIST_STATUS(unsigned long offset __attribute__ ((unused)))
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -89,183 +89,183 @@ static inline uint64_t CVMX_UCTLX_BIST_STATUS(unsigned long block_id __attribute
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_CLK_RST_CTL(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_CLK_RST_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_CLK_RST_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_CLK_RST_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000000ull);
 }
 #else
-#define CVMX_UCTLX_CLK_RST_CTL(block_id) (CVMX_ADD_IO_SEG(0x000118006F000000ull))
+#define CVMX_UCTLX_CLK_RST_CTL(offset) (CVMX_ADD_IO_SEG(0x000118006F000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_CTL(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000000ull);
 }
 #else
-#define CVMX_UCTLX_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180068000000ull))
+#define CVMX_UCTLX_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180068000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_ECC(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_ECC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_ECC(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_ECC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000F0ull);
 }
 #else
-#define CVMX_UCTLX_ECC(block_id) (CVMX_ADD_IO_SEG(0x00011800680000F0ull))
+#define CVMX_UCTLX_ECC(offset) (CVMX_ADD_IO_SEG(0x00011800680000F0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_EHCI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_EHCI_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_EHCI_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_EHCI_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000080ull);
 }
 #else
-#define CVMX_UCTLX_EHCI_CTL(block_id) (CVMX_ADD_IO_SEG(0x000118006F000080ull))
+#define CVMX_UCTLX_EHCI_CTL(offset) (CVMX_ADD_IO_SEG(0x000118006F000080ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_EHCI_FLA(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_EHCI_FLA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_EHCI_FLA(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_EHCI_FLA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F0000A8ull);
 }
 #else
-#define CVMX_UCTLX_EHCI_FLA(block_id) (CVMX_ADD_IO_SEG(0x000118006F0000A8ull))
+#define CVMX_UCTLX_EHCI_FLA(offset) (CVMX_ADD_IO_SEG(0x000118006F0000A8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_ERTO_CTL(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_ERTO_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_ERTO_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_ERTO_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000090ull);
 }
 #else
-#define CVMX_UCTLX_ERTO_CTL(block_id) (CVMX_ADD_IO_SEG(0x000118006F000090ull))
+#define CVMX_UCTLX_ERTO_CTL(offset) (CVMX_ADD_IO_SEG(0x000118006F000090ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_HOST_CFG(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_HOST_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_HOST_CFG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_HOST_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000E0ull);
 }
 #else
-#define CVMX_UCTLX_HOST_CFG(block_id) (CVMX_ADD_IO_SEG(0x00011800680000E0ull))
+#define CVMX_UCTLX_HOST_CFG(offset) (CVMX_ADD_IO_SEG(0x00011800680000E0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_IF_ENA(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_IF_ENA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_IF_ENA(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_IF_ENA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000030ull);
 }
 #else
-#define CVMX_UCTLX_IF_ENA(block_id) (CVMX_ADD_IO_SEG(0x000118006F000030ull))
+#define CVMX_UCTLX_IF_ENA(offset) (CVMX_ADD_IO_SEG(0x000118006F000030ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_INTSTAT(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_INTSTAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_INTSTAT(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_INTSTAT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000030ull);
 }
 #else
-#define CVMX_UCTLX_INTSTAT(block_id) (CVMX_ADD_IO_SEG(0x0001180068000030ull))
+#define CVMX_UCTLX_INTSTAT(offset) (CVMX_ADD_IO_SEG(0x0001180068000030ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_INT_ENA(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_INT_ENA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_INT_ENA(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_INT_ENA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000028ull);
 }
 #else
-#define CVMX_UCTLX_INT_ENA(block_id) (CVMX_ADD_IO_SEG(0x000118006F000028ull))
+#define CVMX_UCTLX_INT_ENA(offset) (CVMX_ADD_IO_SEG(0x000118006F000028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_INT_REG(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_INT_REG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_INT_REG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_INT_REG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000020ull);
 }
 #else
-#define CVMX_UCTLX_INT_REG(block_id) (CVMX_ADD_IO_SEG(0x000118006F000020ull))
+#define CVMX_UCTLX_INT_REG(offset) (CVMX_ADD_IO_SEG(0x000118006F000020ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_OHCI_CTL(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_OHCI_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_OHCI_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_OHCI_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000088ull);
 }
 #else
-#define CVMX_UCTLX_OHCI_CTL(block_id) (CVMX_ADD_IO_SEG(0x000118006F000088ull))
+#define CVMX_UCTLX_OHCI_CTL(offset) (CVMX_ADD_IO_SEG(0x000118006F000088ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_ORTO_CTL(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_ORTO_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_ORTO_CTL(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_ORTO_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000098ull);
 }
 #else
-#define CVMX_UCTLX_ORTO_CTL(block_id) (CVMX_ADD_IO_SEG(0x000118006F000098ull))
+#define CVMX_UCTLX_ORTO_CTL(offset) (CVMX_ADD_IO_SEG(0x000118006F000098ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UCTLX_PORTX_CFG_HS(unsigned long offset, unsigned long block_id)
@@ -312,66 +312,66 @@ static inline uint64_t CVMX_UCTLX_PORTX_CR_DBG_STATUS(unsigned long offset, unsi
 #define CVMX_UCTLX_PORTX_CR_DBG_STATUS(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180068000058ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_PPAF_WM(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_PPAF_WM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_PPAF_WM(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_PPAF_WM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000038ull);
 }
 #else
-#define CVMX_UCTLX_PPAF_WM(block_id) (CVMX_ADD_IO_SEG(0x000118006F000038ull))
+#define CVMX_UCTLX_PPAF_WM(offset) (CVMX_ADD_IO_SEG(0x000118006F000038ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_SHIM_CFG(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_SHIM_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_SHIM_CFG(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_SHIM_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000E8ull);
 }
 #else
-#define CVMX_UCTLX_SHIM_CFG(block_id) (CVMX_ADD_IO_SEG(0x00011800680000E8ull))
+#define CVMX_UCTLX_SHIM_CFG(offset) (CVMX_ADD_IO_SEG(0x00011800680000E8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_SPARE0(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_SPARE0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_SPARE0(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_SPARE0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000010ull);
 }
 #else
-#define CVMX_UCTLX_SPARE0(block_id) (CVMX_ADD_IO_SEG(0x0001180068000010ull))
+#define CVMX_UCTLX_SPARE0(offset) (CVMX_ADD_IO_SEG(0x0001180068000010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_SPARE1(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_SPARE1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_SPARE1(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_SPARE1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000F8ull);
 }
 #else
-#define CVMX_UCTLX_SPARE1(block_id) (CVMX_ADD_IO_SEG(0x00011800680000F8ull))
+#define CVMX_UCTLX_SPARE1(offset) (CVMX_ADD_IO_SEG(0x00011800680000F8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_UCTLX_UPHY_CTL_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_UCTLX_UPHY_CTL_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_UCTLX_UPHY_CTL_STATUS(%lu) is invalid on this chip\n", block_id);
+	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_UCTLX_UPHY_CTL_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118006F000008ull);
 }
 #else
-#define CVMX_UCTLX_UPHY_CTL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x000118006F000008ull))
+#define CVMX_UCTLX_UPHY_CTL_STATUS(offset) (CVMX_ADD_IO_SEG(0x000118006F000008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_UCTLX_UPHY_PORTX_CTL_STATUS(unsigned long offset, unsigned long block_id)
diff --git a/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
index d705c57..95b1d86 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
@@ -53,64 +53,64 @@
 #define __CVMX_USBCX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DAINT(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DAINT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DAINT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000818ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DAINT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000818ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DAINT(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000818ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DAINT(offset) (CVMX_ADD_IO_SEG(0x00016F0010000818ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DAINTMSK(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DAINTMSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DAINTMSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F001000081Cull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DAINTMSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F001000081Cull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DAINTMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F001000081Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DAINTMSK(offset) (CVMX_ADD_IO_SEG(0x00016F001000081Cull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DCFG(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000800ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DCFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000800ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DCFG(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000800ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DCFG(offset) (CVMX_ADD_IO_SEG(0x00016F0010000800ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DCTL(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000804ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DCTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000804ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DCTL(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000804ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DCTL(offset) (CVMX_ADD_IO_SEG(0x00016F0010000804ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBCX_DIEPCTLX(unsigned long offset, unsigned long block_id)
@@ -143,19 +143,19 @@ static inline uint64_t CVMX_USBCX_DIEPINTX(unsigned long offset, unsigned long b
 #define CVMX_USBCX_DIEPINTX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000908ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DIEPMSK(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DIEPMSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DIEPMSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000810ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DIEPMSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000810ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DIEPMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000810ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DIEPMSK(offset) (CVMX_ADD_IO_SEG(0x00016F0010000810ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBCX_DIEPTSIZX(unsigned long offset, unsigned long block_id)
@@ -203,19 +203,19 @@ static inline uint64_t CVMX_USBCX_DOEPINTX(unsigned long offset, unsigned long b
 #define CVMX_USBCX_DOEPINTX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000B08ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DOEPMSK(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DOEPMSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DOEPMSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000814ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DOEPMSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000814ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DOEPMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000814ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DOEPMSK(offset) (CVMX_ADD_IO_SEG(0x00016F0010000814ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBCX_DOEPTSIZX(unsigned long offset, unsigned long block_id)
@@ -248,394 +248,394 @@ static inline uint64_t CVMX_USBCX_DPTXFSIZX(unsigned long offset, unsigned long
 #define CVMX_USBCX_DPTXFSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000100ull) + (((offset) & 7) + ((block_id) & 1) * 0x40000000000ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000808ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000808ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000808ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DSTS(offset) (CVMX_ADD_IO_SEG(0x00016F0010000808ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DTKNQR1(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DTKNQR1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DTKNQR1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000820ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DTKNQR1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000820ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DTKNQR1(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000820ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DTKNQR1(offset) (CVMX_ADD_IO_SEG(0x00016F0010000820ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DTKNQR2(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DTKNQR2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DTKNQR2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000824ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DTKNQR2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000824ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DTKNQR2(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000824ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DTKNQR2(offset) (CVMX_ADD_IO_SEG(0x00016F0010000824ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DTKNQR3(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DTKNQR3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DTKNQR3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000830ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DTKNQR3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000830ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DTKNQR3(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000830ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DTKNQR3(offset) (CVMX_ADD_IO_SEG(0x00016F0010000830ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_DTKNQR4(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_DTKNQR4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_DTKNQR4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000834ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_DTKNQR4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000834ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_DTKNQR4(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000834ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_DTKNQR4(offset) (CVMX_ADD_IO_SEG(0x00016F0010000834ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GAHBCFG(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GAHBCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GAHBCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000008ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GAHBCFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000008ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GAHBCFG(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000008ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GAHBCFG(offset) (CVMX_ADD_IO_SEG(0x00016F0010000008ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GHWCFG1(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GHWCFG1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GHWCFG1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000044ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GHWCFG1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000044ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GHWCFG1(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000044ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GHWCFG1(offset) (CVMX_ADD_IO_SEG(0x00016F0010000044ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GHWCFG2(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GHWCFG2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GHWCFG2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000048ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GHWCFG2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000048ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GHWCFG2(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000048ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GHWCFG2(offset) (CVMX_ADD_IO_SEG(0x00016F0010000048ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GHWCFG3(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GHWCFG3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GHWCFG3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F001000004Cull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GHWCFG3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F001000004Cull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GHWCFG3(block_id) (CVMX_ADD_IO_SEG(0x00016F001000004Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GHWCFG3(offset) (CVMX_ADD_IO_SEG(0x00016F001000004Cull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GHWCFG4(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GHWCFG4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GHWCFG4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000050ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GHWCFG4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000050ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GHWCFG4(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000050ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GHWCFG4(offset) (CVMX_ADD_IO_SEG(0x00016F0010000050ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GINTMSK(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GINTMSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GINTMSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000018ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GINTMSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000018ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GINTMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000018ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GINTMSK(offset) (CVMX_ADD_IO_SEG(0x00016F0010000018ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GINTSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GINTSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GINTSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000014ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GINTSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000014ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GINTSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000014ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GINTSTS(offset) (CVMX_ADD_IO_SEG(0x00016F0010000014ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GNPTXFSIZ(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GNPTXFSIZ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GNPTXFSIZ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000028ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GNPTXFSIZ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000028ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GNPTXFSIZ(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000028ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GNPTXFSIZ(offset) (CVMX_ADD_IO_SEG(0x00016F0010000028ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GNPTXSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GNPTXSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GNPTXSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F001000002Cull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GNPTXSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F001000002Cull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GNPTXSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F001000002Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GNPTXSTS(offset) (CVMX_ADD_IO_SEG(0x00016F001000002Cull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GOTGCTL(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GOTGCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GOTGCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000000ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GOTGCTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000000ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GOTGCTL(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000000ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GOTGCTL(offset) (CVMX_ADD_IO_SEG(0x00016F0010000000ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GOTGINT(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GOTGINT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GOTGINT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000004ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GOTGINT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000004ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GOTGINT(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000004ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GOTGINT(offset) (CVMX_ADD_IO_SEG(0x00016F0010000004ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GRSTCTL(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GRSTCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GRSTCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000010ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GRSTCTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000010ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GRSTCTL(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000010ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRSTCTL(offset) (CVMX_ADD_IO_SEG(0x00016F0010000010ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GRXFSIZ(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GRXFSIZ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GRXFSIZ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000024ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GRXFSIZ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000024ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GRXFSIZ(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000024ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXFSIZ(offset) (CVMX_ADD_IO_SEG(0x00016F0010000024ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GRXSTSPD(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GRXSTSPD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GRXSTSPD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010040020ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GRXSTSPD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010040020ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GRXSTSPD(block_id) (CVMX_ADD_IO_SEG(0x00016F0010040020ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXSTSPD(offset) (CVMX_ADD_IO_SEG(0x00016F0010040020ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GRXSTSPH(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GRXSTSPH(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GRXSTSPH(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000020ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GRXSTSPH(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000020ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GRXSTSPH(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000020ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXSTSPH(offset) (CVMX_ADD_IO_SEG(0x00016F0010000020ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GRXSTSRD(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GRXSTSRD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GRXSTSRD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F001004001Cull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GRXSTSRD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F001004001Cull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GRXSTSRD(block_id) (CVMX_ADD_IO_SEG(0x00016F001004001Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXSTSRD(offset) (CVMX_ADD_IO_SEG(0x00016F001004001Cull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GRXSTSRH(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GRXSTSRH(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GRXSTSRH(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F001000001Cull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GRXSTSRH(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F001000001Cull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GRXSTSRH(block_id) (CVMX_ADD_IO_SEG(0x00016F001000001Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GRXSTSRH(offset) (CVMX_ADD_IO_SEG(0x00016F001000001Cull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GSNPSID(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GSNPSID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GSNPSID(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000040ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GSNPSID(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000040ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GSNPSID(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000040ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GSNPSID(offset) (CVMX_ADD_IO_SEG(0x00016F0010000040ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_GUSBCFG(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_GUSBCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_GUSBCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F001000000Cull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_GUSBCFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F001000000Cull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_GUSBCFG(block_id) (CVMX_ADD_IO_SEG(0x00016F001000000Cull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_GUSBCFG(offset) (CVMX_ADD_IO_SEG(0x00016F001000000Cull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_HAINT(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_HAINT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_HAINT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000414ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_HAINT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000414ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_HAINT(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000414ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HAINT(offset) (CVMX_ADD_IO_SEG(0x00016F0010000414ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_HAINTMSK(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_HAINTMSK(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_HAINTMSK(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000418ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_HAINTMSK(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000418ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_HAINTMSK(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000418ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HAINTMSK(offset) (CVMX_ADD_IO_SEG(0x00016F0010000418ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBCX_HCCHARX(unsigned long offset, unsigned long block_id)
@@ -653,19 +653,19 @@ static inline uint64_t CVMX_USBCX_HCCHARX(unsigned long offset, unsigned long bl
 #define CVMX_USBCX_HCCHARX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000500ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_HCFG(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_HCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_HCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000400ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_HCFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000400ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_HCFG(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000400ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HCFG(offset) (CVMX_ADD_IO_SEG(0x00016F0010000400ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBCX_HCINTMSKX(unsigned long offset, unsigned long block_id)
@@ -728,79 +728,79 @@ static inline uint64_t CVMX_USBCX_HCTSIZX(unsigned long offset, unsigned long bl
 #define CVMX_USBCX_HCTSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010000510ull) + (((offset) & 7) + ((block_id) & 1) * 0x8000000000ull) * 32)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_HFIR(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_HFIR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_HFIR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000404ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_HFIR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000404ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_HFIR(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000404ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HFIR(offset) (CVMX_ADD_IO_SEG(0x00016F0010000404ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_HFNUM(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_HFNUM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_HFNUM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000408ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_HFNUM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000408ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_HFNUM(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000408ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HFNUM(offset) (CVMX_ADD_IO_SEG(0x00016F0010000408ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_HPRT(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_HPRT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_HPRT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000440ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_HPRT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000440ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_HPRT(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000440ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HPRT(offset) (CVMX_ADD_IO_SEG(0x00016F0010000440ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_HPTXFSIZ(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_HPTXFSIZ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_HPTXFSIZ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000100ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_HPTXFSIZ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000100ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_HPTXFSIZ(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000100ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HPTXFSIZ(offset) (CVMX_ADD_IO_SEG(0x00016F0010000100ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_HPTXSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_HPTXSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_HPTXSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000410ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_HPTXSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000410ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_HPTXSTS(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000410ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_HPTXSTS(offset) (CVMX_ADD_IO_SEG(0x00016F0010000410ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBCX_NPTXDFIFOX(unsigned long offset, unsigned long block_id)
@@ -818,19 +818,19 @@ static inline uint64_t CVMX_USBCX_NPTXDFIFOX(unsigned long offset, unsigned long
 #define CVMX_USBCX_NPTXDFIFOX(offset, block_id) (CVMX_ADD_IO_SEG(0x00016F0010001000ull) + (((offset) & 7) + ((block_id) & 1) * 0x100000000ull) * 4096)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBCX_PCGCCTL(unsigned long block_id)
+static inline uint64_t CVMX_USBCX_PCGCCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBCX_PCGCCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0010000E00ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBCX_PCGCCTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0010000E00ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBCX_PCGCCTL(block_id) (CVMX_ADD_IO_SEG(0x00016F0010000E00ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBCX_PCGCCTL(offset) (CVMX_ADD_IO_SEG(0x00016F0010000E00ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
index 2eefa07..64ac510 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
@@ -53,65 +53,71 @@
 #define __CVMX_USBDRDX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_CAPLENGTH(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_CAPLENGTH(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_CAPLENGTH(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000000ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_CAPLENGTH(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000000ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_CAPLENGTH(block_id) (CVMX_ADD_IO_SEG(0x0001680000000000ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_CAPLENGTH(offset) (CVMX_ADD_IO_SEG(0x0001680000000000ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_CONFIG(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_CONFIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_CONFIG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000058ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_CONFIG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000058ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_CONFIG(block_id) (CVMX_ADD_IO_SEG(0x0001680000000058ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_CONFIG(offset) (CVMX_ADD_IO_SEG(0x0001680000000058ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_CRCR(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_CRCR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_CRCR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000038ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_CRCR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000038ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_CRCR(block_id) (CVMX_ADD_IO_SEG(0x0001680000000038ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_CRCR(offset) (CVMX_ADD_IO_SEG(0x0001680000000038ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DALEPENA(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DALEPENA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DALEPENA(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C720ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DALEPENA(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C720ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DALEPENA(block_id) (CVMX_ADD_IO_SEG(0x000168000000C720ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DALEPENA(offset) (CVMX_ADD_IO_SEG(0x000168000000C720ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DBOFF(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DBOFF(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DBOFF(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000014ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DBOFF(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000014ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DBOFF(block_id) (CVMX_ADD_IO_SEG(0x0001680000000014ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DBOFF(offset) (CVMX_ADD_IO_SEG(0x0001680000000014ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DBX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 64)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 64)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 64)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DBX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000480ull) + (((offset) & 127) + ((block_id) & 1) * 0x4000000000ull) * 4;
 }
@@ -119,43 +125,47 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DBX(unsigned long offset, unsigned long
 #define CVMX_USBDRDX_UAHC_DBX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000480ull) + (((offset) & 127) + ((block_id) & 1) * 0x4000000000ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DCBAAP(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DCBAAP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DCBAAP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000050ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DCBAAP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000050ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DCBAAP(block_id) (CVMX_ADD_IO_SEG(0x0001680000000050ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DCBAAP(offset) (CVMX_ADD_IO_SEG(0x0001680000000050ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DCFG(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C700ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DCFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C700ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DCFG(block_id) (CVMX_ADD_IO_SEG(0x000168000000C700ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DCFG(offset) (CVMX_ADD_IO_SEG(0x000168000000C700ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DCTL(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C704ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DCTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C704ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DCTL(block_id) (CVMX_ADD_IO_SEG(0x000168000000C704ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DCTL(offset) (CVMX_ADD_IO_SEG(0x000168000000C704ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C808ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -166,7 +176,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C804ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -177,7 +188,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C800ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -188,7 +200,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C80Cull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -196,65 +209,71 @@ static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDX(unsigned long offset, unsigned
 #define CVMX_USBDRDX_UAHC_DEPCMDX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C80Cull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DEVTEN(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DEVTEN(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DEVTEN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C708ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DEVTEN(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C708ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DEVTEN(block_id) (CVMX_ADD_IO_SEG(0x000168000000C708ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DEVTEN(offset) (CVMX_ADD_IO_SEG(0x000168000000C708ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DGCMD(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DGCMD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DGCMD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C714ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DGCMD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C714ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DGCMD(block_id) (CVMX_ADD_IO_SEG(0x000168000000C714ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DGCMD(offset) (CVMX_ADD_IO_SEG(0x000168000000C714ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DGCMDPAR(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DGCMDPAR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DGCMDPAR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C710ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DGCMDPAR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C710ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DGCMDPAR(block_id) (CVMX_ADD_IO_SEG(0x000168000000C710ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DGCMDPAR(offset) (CVMX_ADD_IO_SEG(0x000168000000C710ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DNCTRL(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DNCTRL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DNCTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000034ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DNCTRL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000034ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DNCTRL(block_id) (CVMX_ADD_IO_SEG(0x0001680000000034ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DNCTRL(offset) (CVMX_ADD_IO_SEG(0x0001680000000034ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_DSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_DSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C70Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_DSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C70Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DSTS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C70Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_DSTS(offset) (CVMX_ADD_IO_SEG(0x000168000000C70Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_ERDPX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_ERDPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000478ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -265,7 +284,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_ERDPX(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_USBDRDX_UAHC_ERSTBAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_ERSTBAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000470ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -276,7 +296,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_ERSTBAX(unsigned long offset, unsigned
 static inline uint64_t CVMX_USBDRDX_UAHC_ERSTSZX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_ERSTSZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000468ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -284,120 +305,131 @@ static inline uint64_t CVMX_USBDRDX_UAHC_ERSTSZX(unsigned long offset, unsigned
 #define CVMX_USBDRDX_UAHC_ERSTSZX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000468ull) + ((block_id) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GBUSERRADDR(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GBUSERRADDR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GBUSERRADDR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C130ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GBUSERRADDR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C130ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GBUSERRADDR(block_id) (CVMX_ADD_IO_SEG(0x000168000000C130ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GBUSERRADDR(offset) (CVMX_ADD_IO_SEG(0x000168000000C130ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GCTL(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C110ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GCTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C110ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GCTL(block_id) (CVMX_ADD_IO_SEG(0x000168000000C110ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GCTL(offset) (CVMX_ADD_IO_SEG(0x000168000000C110ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GDBGBMU(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGBMU(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGBMU(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C16Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGBMU(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C16Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGBMU(block_id) (CVMX_ADD_IO_SEG(0x000168000000C16Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GDBGBMU(offset) (CVMX_ADD_IO_SEG(0x000168000000C16Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GDBGEPINFO(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGEPINFO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGEPINFO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C178ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGEPINFO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C178ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGEPINFO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C178ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GDBGEPINFO(offset) (CVMX_ADD_IO_SEG(0x000168000000C178ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C160ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C160ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(block_id) (CVMX_ADD_IO_SEG(0x000168000000C160ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(offset) (CVMX_ADD_IO_SEG(0x000168000000C160ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLNMCC(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLNMCC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLNMCC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C168ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLNMCC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C168ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGLNMCC(block_id) (CVMX_ADD_IO_SEG(0x000168000000C168ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GDBGLNMCC(offset) (CVMX_ADD_IO_SEG(0x000168000000C168ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSP(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C174ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C174ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGLSP(block_id) (CVMX_ADD_IO_SEG(0x000168000000C174ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GDBGLSP(offset) (CVMX_ADD_IO_SEG(0x000168000000C174ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSPMUX(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSPMUX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSPMUX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C170ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSPMUX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C170ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGLSPMUX(block_id) (CVMX_ADD_IO_SEG(0x000168000000C170ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GDBGLSPMUX(offset) (CVMX_ADD_IO_SEG(0x000168000000C170ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLTSSM(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLTSSM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLTSSM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C164ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLTSSM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C164ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGLTSSM(block_id) (CVMX_ADD_IO_SEG(0x000168000000C164ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GDBGLTSSM(offset) (CVMX_ADD_IO_SEG(0x000168000000C164ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GDMAHLRATIO(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDMAHLRATIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDMAHLRATIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C624ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GDMAHLRATIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C624ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDMAHLRATIO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C624ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GDMAHLRATIO(offset) (CVMX_ADD_IO_SEG(0x000168000000C624ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTADRX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTADRX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C400ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -408,7 +440,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTADRX(unsigned long offset, unsigne
 static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTCOUNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTCOUNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C40Cull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -419,7 +452,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTCOUNTX(unsigned long offset, unsig
 static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTSIZX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C408ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -427,197 +461,215 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTSIZX(unsigned long offset, unsigne
 #define CVMX_USBDRDX_UAHC_GEVNTSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C408ull) + ((block_id) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GFLADJ(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GFLADJ(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GFLADJ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C630ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GFLADJ(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C630ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GFLADJ(block_id) (CVMX_ADD_IO_SEG(0x000168000000C630ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GFLADJ(offset) (CVMX_ADD_IO_SEG(0x000168000000C630ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GGPIO(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GGPIO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GGPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C124ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GGPIO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C124ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GGPIO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C124ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GGPIO(offset) (CVMX_ADD_IO_SEG(0x000168000000C124ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS0(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C140ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C140ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS0(block_id) (CVMX_ADD_IO_SEG(0x000168000000C140ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS0(offset) (CVMX_ADD_IO_SEG(0x000168000000C140ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS1(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C144ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C144ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C144ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS1(offset) (CVMX_ADD_IO_SEG(0x000168000000C144ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS2(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C148ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C148ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS2(block_id) (CVMX_ADD_IO_SEG(0x000168000000C148ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS2(offset) (CVMX_ADD_IO_SEG(0x000168000000C148ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS3(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C14Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C14Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS3(block_id) (CVMX_ADD_IO_SEG(0x000168000000C14Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS3(offset) (CVMX_ADD_IO_SEG(0x000168000000C14Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS4(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C150ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C150ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS4(block_id) (CVMX_ADD_IO_SEG(0x000168000000C150ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS4(offset) (CVMX_ADD_IO_SEG(0x000168000000C150ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS5(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS5(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS5(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C154ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS5(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C154ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS5(block_id) (CVMX_ADD_IO_SEG(0x000168000000C154ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS5(offset) (CVMX_ADD_IO_SEG(0x000168000000C154ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS6(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS6(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS6(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C158ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS6(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C158ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS6(block_id) (CVMX_ADD_IO_SEG(0x000168000000C158ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS6(offset) (CVMX_ADD_IO_SEG(0x000168000000C158ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS7(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS7(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS7(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C15Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS7(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C15Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS7(block_id) (CVMX_ADD_IO_SEG(0x000168000000C15Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS7(offset) (CVMX_ADD_IO_SEG(0x000168000000C15Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS8(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS8(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS8(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C600ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS8(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C600ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS8(block_id) (CVMX_ADD_IO_SEG(0x000168000000C600ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GHWPARAMS8(offset) (CVMX_ADD_IO_SEG(0x000168000000C600ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GPMSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GPMSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GPMSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C114ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GPMSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C114ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GPMSTS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C114ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GPMSTS(offset) (CVMX_ADD_IO_SEG(0x000168000000C114ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C138ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C138ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GPRTBIMAP(block_id) (CVMX_ADD_IO_SEG(0x000168000000C138ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GPRTBIMAP(offset) (CVMX_ADD_IO_SEG(0x000168000000C138ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C188ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C188ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C188ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(offset) (CVMX_ADD_IO_SEG(0x000168000000C188ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C180ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C180ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C180ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(offset) (CVMX_ADD_IO_SEG(0x000168000000C180ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GRLSID(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GRLSID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GRLSID(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C120ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GRLSID(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C120ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GRLSID(block_id) (CVMX_ADD_IO_SEG(0x000168000000C120ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GRLSID(offset) (CVMX_ADD_IO_SEG(0x000168000000C120ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C61Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C61Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(block_id) (CVMX_ADD_IO_SEG(0x000168000000C61Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(offset) (CVMX_ADD_IO_SEG(0x000168000000C61Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOSIZX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 2)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 2)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 2)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C380ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4;
 }
@@ -625,76 +677,83 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOSIZX(unsigned long offset, unsig
 #define CVMX_USBDRDX_UAHC_GRXFIFOSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C380ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GRXTHRCFG(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GRXTHRCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GRXTHRCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C10Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GRXTHRCFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C10Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GRXTHRCFG(block_id) (CVMX_ADD_IO_SEG(0x000168000000C10Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GRXTHRCFG(offset) (CVMX_ADD_IO_SEG(0x000168000000C10Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG0(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C100ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C100ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GSBUSCFG0(block_id) (CVMX_ADD_IO_SEG(0x000168000000C100ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GSBUSCFG0(offset) (CVMX_ADD_IO_SEG(0x000168000000C100ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG1(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C104ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C104ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GSBUSCFG1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C104ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GSBUSCFG1(offset) (CVMX_ADD_IO_SEG(0x000168000000C104ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C118ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C118ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GSTS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C118ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GSTS(offset) (CVMX_ADD_IO_SEG(0x000168000000C118ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C610ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C610ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(block_id) (CVMX_ADD_IO_SEG(0x000168000000C610ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(offset) (CVMX_ADD_IO_SEG(0x000168000000C610ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C618ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C618ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(block_id) (CVMX_ADD_IO_SEG(0x000168000000C618ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(offset) (CVMX_ADD_IO_SEG(0x000168000000C618ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOSIZX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C300ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4;
 }
@@ -702,54 +761,59 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOSIZX(unsigned long offset, unsig
 #define CVMX_USBDRDX_UAHC_GTXFIFOSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C300ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GTXTHRCFG(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GTXTHRCFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GTXTHRCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C108ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GTXTHRCFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C108ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GTXTHRCFG(block_id) (CVMX_ADD_IO_SEG(0x000168000000C108ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GTXTHRCFG(offset) (CVMX_ADD_IO_SEG(0x000168000000C108ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C12Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C12Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUCTL(block_id) (CVMX_ADD_IO_SEG(0x000168000000C12Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GUCTL(offset) (CVMX_ADD_IO_SEG(0x000168000000C12Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL1(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C11Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C11Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUCTL1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C11Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GUCTL1(offset) (CVMX_ADD_IO_SEG(0x000168000000C11Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_GUID(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUID(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUID(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C128ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_GUID(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000C128ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUID(block_id) (CVMX_ADD_IO_SEG(0x000168000000C128ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_GUID(offset) (CVMX_ADD_IO_SEG(0x000168000000C128ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C240ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -760,7 +824,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C200ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -771,7 +836,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C2C0ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -779,54 +845,59 @@ static inline uint64_t CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(unsigned long offset, uns
 #define CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C2C0ull) + ((block_id) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_HCCPARAMS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_HCCPARAMS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_HCCPARAMS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000010ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_HCCPARAMS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000010ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_HCCPARAMS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000010ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_HCCPARAMS(offset) (CVMX_ADD_IO_SEG(0x0001680000000010ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS1(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000004ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000004ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_HCSPARAMS1(block_id) (CVMX_ADD_IO_SEG(0x0001680000000004ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_HCSPARAMS1(offset) (CVMX_ADD_IO_SEG(0x0001680000000004ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS2(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000008ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000008ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_HCSPARAMS2(block_id) (CVMX_ADD_IO_SEG(0x0001680000000008ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_HCSPARAMS2(offset) (CVMX_ADD_IO_SEG(0x0001680000000008ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS3(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000000Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000000Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_HCSPARAMS3(block_id) (CVMX_ADD_IO_SEG(0x000168000000000Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_HCSPARAMS3(offset) (CVMX_ADD_IO_SEG(0x000168000000000Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_IMANX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_IMANX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000460ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -837,7 +908,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_IMANX(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_USBDRDX_UAHC_IMODX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_IMODX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000464ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -845,32 +917,35 @@ static inline uint64_t CVMX_USBDRDX_UAHC_IMODX(unsigned long offset, unsigned lo
 #define CVMX_USBDRDX_UAHC_IMODX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000464ull) + ((block_id) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_MFINDEX(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_MFINDEX(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_MFINDEX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000440ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_MFINDEX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000440ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_MFINDEX(block_id) (CVMX_ADD_IO_SEG(0x0001680000000440ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_MFINDEX(offset) (CVMX_ADD_IO_SEG(0x0001680000000440ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_PAGESIZE(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_PAGESIZE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PAGESIZE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000028ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_PAGESIZE(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000028ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_PAGESIZE(block_id) (CVMX_ADD_IO_SEG(0x0001680000000028ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_PAGESIZE(offset) (CVMX_ADD_IO_SEG(0x0001680000000028ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_20X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTHLPMC_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000042Cull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -881,7 +956,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_20X(unsigned long offset, uns
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000043Cull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -892,7 +968,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(unsigned long offset, uns
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_20X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTLI_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000428ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -903,7 +980,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_20X(unsigned long offset, unsign
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_SSX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTLI_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000438ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -914,7 +992,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_SSX(unsigned long offset, unsign
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_20X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTPMSC_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000424ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -925,7 +1004,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_20X(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_SSX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTPMSC_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000434ull) + ((block_id) & 1) * 0x10000000000ull;
 }
@@ -936,7 +1016,8 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_SSX(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTSCX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UAHC_PORTSCX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000420ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000000000ull) * 16;
 }
@@ -944,208 +1025,227 @@ static inline uint64_t CVMX_USBDRDX_UAHC_PORTSCX(unsigned long offset, unsigned
 #define CVMX_USBDRDX_UAHC_PORTSCX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000420ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000000000ull) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_RTSOFF(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_RTSOFF(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_RTSOFF(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000018ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_RTSOFF(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000018ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_RTSOFF(block_id) (CVMX_ADD_IO_SEG(0x0001680000000018ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_RTSOFF(offset) (CVMX_ADD_IO_SEG(0x0001680000000018ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000890ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000890ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(block_id) (CVMX_ADD_IO_SEG(0x0001680000000890ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(offset) (CVMX_ADD_IO_SEG(0x0001680000000890ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000894ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000894ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(block_id) (CVMX_ADD_IO_SEG(0x0001680000000894ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(offset) (CVMX_ADD_IO_SEG(0x0001680000000894ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000898ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000898ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(block_id) (CVMX_ADD_IO_SEG(0x0001680000000898ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(offset) (CVMX_ADD_IO_SEG(0x0001680000000898ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000089Cull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000168000000089Cull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(block_id) (CVMX_ADD_IO_SEG(0x000168000000089Cull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(offset) (CVMX_ADD_IO_SEG(0x000168000000089Cull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016800000008A0ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016800000008A0ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A0ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(offset) (CVMX_ADD_IO_SEG(0x00016800000008A0ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016800000008A4ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016800000008A4ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A4ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(offset) (CVMX_ADD_IO_SEG(0x00016800000008A4ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016800000008A8ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016800000008A8ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A8ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(offset) (CVMX_ADD_IO_SEG(0x00016800000008A8ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016800000008ACull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016800000008ACull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(block_id) (CVMX_ADD_IO_SEG(0x00016800000008ACull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(offset) (CVMX_ADD_IO_SEG(0x00016800000008ACull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_USBCMD(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_USBCMD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_USBCMD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000020ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_USBCMD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000020ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_USBCMD(block_id) (CVMX_ADD_IO_SEG(0x0001680000000020ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_USBCMD(offset) (CVMX_ADD_IO_SEG(0x0001680000000020ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGCTLSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGCTLSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGCTLSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000884ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGCTLSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000884ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_USBLEGCTLSTS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000884ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_USBLEGCTLSTS(offset) (CVMX_ADD_IO_SEG(0x0001680000000884ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGSUP(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGSUP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGSUP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000880ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGSUP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000880ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_USBLEGSUP(block_id) (CVMX_ADD_IO_SEG(0x0001680000000880ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_USBLEGSUP(offset) (CVMX_ADD_IO_SEG(0x0001680000000880ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UAHC_USBSTS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UAHC_USBSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_USBSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000024ull) + ((block_id) & 1) * 0x10000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UAHC_USBSTS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001680000000024ull) + ((offset) & 1) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_USBSTS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000024ull) + ((block_id) & 1) * 0x10000000000ull)
+#define CVMX_USBDRDX_UAHC_USBSTS(offset) (CVMX_ADD_IO_SEG(0x0001680000000024ull) + ((offset) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UCTL_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UCTL_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_USBDRDX_UCTL_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UCTL_CTL(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UCTL_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_USBDRDX_UCTL_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UCTL_ECC(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UCTL_ECC(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_ECC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800680000F0ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_ECC(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800680000F0ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_ECC(block_id) (CVMX_ADD_IO_SEG(0x00011800680000F0ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_USBDRDX_UCTL_ECC(offset) (CVMX_ADD_IO_SEG(0x00011800680000F0ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UCTL_HOST_CFG(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UCTL_HOST_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_HOST_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800680000E0ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_HOST_CFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800680000E0ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_HOST_CFG(block_id) (CVMX_ADD_IO_SEG(0x00011800680000E0ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_USBDRDX_UCTL_HOST_CFG(offset) (CVMX_ADD_IO_SEG(0x00011800680000E0ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UCTL_INTSTAT(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UCTL_INTSTAT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_INTSTAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000030ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_INTSTAT(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000030ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_INTSTAT(block_id) (CVMX_ADD_IO_SEG(0x0001180068000030ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_USBDRDX_UCTL_INTSTAT(offset) (CVMX_ADD_IO_SEG(0x0001180068000030ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_HS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CFG_HS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000040ull) + ((block_id) & 1) * 0x1000000ull;
 }
@@ -1156,7 +1256,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_HS(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_SS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CFG_SS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000048ull) + ((block_id) & 1) * 0x1000000ull;
 }
@@ -1167,7 +1268,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_SS(unsigned long offset, unsi
 static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000050ull) + ((block_id) & 1) * 0x1000000ull;
 }
@@ -1178,7 +1280,8 @@ static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(unsigned long offset,
 static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000058ull) + ((block_id) & 1) * 0x1000000ull;
 }
@@ -1186,37 +1289,60 @@ static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(unsigned long offse
 #define CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180068000058ull) + ((block_id) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UCTL_SHIM_CFG(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UCTL_SHIM_CFG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_SHIM_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800680000E8ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_SHIM_CFG(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800680000E8ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_SHIM_CFG(block_id) (CVMX_ADD_IO_SEG(0x00011800680000E8ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_USBDRDX_UCTL_SHIM_CFG(offset) (CVMX_ADD_IO_SEG(0x00011800680000E8ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UCTL_SPARE0(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UCTL_SPARE0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_SPARE0(block_id) (CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_USBDRDX_UCTL_SPARE0(offset) (CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1(unsigned long block_id)
+static inline uint64_t CVMX_USBDRDX_UCTL_SPARE0_ECO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800680000F8ull) + ((block_id) & 1) * 0x1000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE0_ECO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_SPARE1(block_id) (CVMX_ADD_IO_SEG(0x00011800680000F8ull) + ((block_id) & 1) * 0x1000000ull)
+#define CVMX_USBDRDX_UCTL_SPARE0_ECO(offset) (CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800680000F8ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_USBDRDX_UCTL_SPARE1(offset) (CVMX_ADD_IO_SEG(0x00011800680000F8ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1_ECO(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE1_ECO(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800680000F8ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_USBDRDX_UCTL_SPARE1_ECO(offset) (CVMX_ADD_IO_SEG(0x00011800680000F8ull) + ((offset) & 1) * 0x1000000ull)
 #endif
 
 /**
@@ -1240,6 +1366,7 @@ union cvmx_usbdrdx_uahc_caplength {
 	} s;
 	struct cvmx_usbdrdx_uahc_caplength_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_caplength_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_caplength_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_caplength cvmx_usbdrdx_uahc_caplength_t;
 
@@ -1266,6 +1393,7 @@ union cvmx_usbdrdx_uahc_config {
 	} s;
 	struct cvmx_usbdrdx_uahc_config_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_config_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_config_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_config cvmx_usbdrdx_uahc_config_t;
 
@@ -1300,6 +1428,7 @@ union cvmx_usbdrdx_uahc_crcr {
 	} s;
 	struct cvmx_usbdrdx_uahc_crcr_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_crcr_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_crcr_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_crcr cvmx_usbdrdx_uahc_crcr_t;
 
@@ -1313,7 +1442,7 @@ typedef union cvmx_usbdrdx_uahc_crcr cvmx_usbdrdx_uahc_crcr_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.2.1.
  */
 union cvmx_usbdrdx_uahc_dalepena {
 	uint32_t u32;
@@ -1336,13 +1465,14 @@ union cvmx_usbdrdx_uahc_dalepena {
                                                          and SetInterface requests, the application must program endpoint registers
                                                          accordingly and set these bits.
                                                          INTERNAL: For more information, see 'Flexible Endpoint Mapping' on Synopsys DWC_usb3
-                                                         Databook v2.50a, page 82. */
+                                                         Databook v2.80a, page 82. */
 #else
 	uint32_t usbactep                     : 32;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dalepena_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_dalepena_s   cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dalepena_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dalepena cvmx_usbdrdx_uahc_dalepena_t;
 
@@ -1374,6 +1504,7 @@ union cvmx_usbdrdx_uahc_dbx {
 	} s;
 	struct cvmx_usbdrdx_uahc_dbx_s        cn70xx;
 	struct cvmx_usbdrdx_uahc_dbx_s        cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dbx_s        cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dbx cvmx_usbdrdx_uahc_dbx_t;
 
@@ -1396,6 +1527,7 @@ union cvmx_usbdrdx_uahc_dboff {
 	} s;
 	struct cvmx_usbdrdx_uahc_dboff_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_dboff_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dboff_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dboff cvmx_usbdrdx_uahc_dboff_t;
 
@@ -1422,6 +1554,7 @@ union cvmx_usbdrdx_uahc_dcbaap {
 	} s;
 	struct cvmx_usbdrdx_uahc_dcbaap_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_dcbaap_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dcbaap_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dcbaap cvmx_usbdrdx_uahc_dcbaap_t;
 
@@ -1432,7 +1565,7 @@ typedef union cvmx_usbdrdx_uahc_dcbaap cvmx_usbdrdx_uahc_dcbaap_t;
  * commands or enumeration. Do not make changes to this register after initial programming.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.1.1.
  */
 union cvmx_usbdrdx_uahc_dcfg {
 	uint32_t u32;
@@ -1498,6 +1631,7 @@ union cvmx_usbdrdx_uahc_dcfg {
 	} s;
 	struct cvmx_usbdrdx_uahc_dcfg_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dcfg_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dcfg_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dcfg cvmx_usbdrdx_uahc_dcfg_t;
 
@@ -1507,7 +1641,7 @@ typedef union cvmx_usbdrdx_uahc_dcfg cvmx_usbdrdx_uahc_dcfg_t;
  * This register controls devlice mode.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.1.2.
  */
 union cvmx_usbdrdx_uahc_dctl {
 	uint32_t u32;
@@ -1693,6 +1827,7 @@ union cvmx_usbdrdx_uahc_dctl {
 	} s;
 	struct cvmx_usbdrdx_uahc_dctl_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dctl_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dctl_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dctl cvmx_usbdrdx_uahc_dctl_t;
 
@@ -1713,7 +1848,7 @@ typedef union cvmx_usbdrdx_uahc_dctl cvmx_usbdrdx_uahc_dctl_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.5.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.2.5.
  */
 union cvmx_usbdrdx_uahc_depcmdx {
 	uint32_t u32;
@@ -1804,7 +1939,7 @@ union cvmx_usbdrdx_uahc_depcmdx {
                                                                resources to be assigned than have been configured in the hardware.
                                                          In response to a End Transfer command:
                                                          _ [15:12] = 0x1: Indicates an invalid transfer resource was specified.
-                                                         INTERNAL: For abort handling, see also Synopsys DWC_usb3 Databook v2.50a, Section 8.4. */
+                                                         INTERNAL: For abort handling, see also Synopsys DWC_usb3 Databook v2.80a, Section 8.4. */
 	uint32_t hipri_forcerm                : 1;  /**< HighPriority: Only valid for Start Transfer command.
                                                          ForceRM: Only valid for End Transfer command. */
 	uint32_t cmdact                       : 1;  /**< Software sets this bit to 1 to enable the device endpoint controller to
@@ -1847,6 +1982,7 @@ union cvmx_usbdrdx_uahc_depcmdx {
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdx_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_depcmdx_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdx cvmx_usbdrdx_uahc_depcmdx_t;
 
@@ -1860,7 +1996,7 @@ typedef union cvmx_usbdrdx_uahc_depcmdx cvmx_usbdrdx_uahc_depcmdx_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.4.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.2.4.
  */
 union cvmx_usbdrdx_uahc_depcmdpar0_x {
 	uint32_t u32;
@@ -1873,6 +2009,7 @@ union cvmx_usbdrdx_uahc_depcmdpar0_x {
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar0_x cvmx_usbdrdx_uahc_depcmdpar0_x_t;
 
@@ -1886,7 +2023,7 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar0_x cvmx_usbdrdx_uahc_depcmdpar0_x_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.3.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.2.3.
  */
 union cvmx_usbdrdx_uahc_depcmdpar1_x {
 	uint32_t u32;
@@ -1899,6 +2036,7 @@ union cvmx_usbdrdx_uahc_depcmdpar1_x {
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar1_x cvmx_usbdrdx_uahc_depcmdpar1_x_t;
 
@@ -1912,7 +2050,7 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar1_x cvmx_usbdrdx_uahc_depcmdpar1_x_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.2.2.
  */
 union cvmx_usbdrdx_uahc_depcmdpar2_x {
 	uint32_t u32;
@@ -1925,6 +2063,7 @@ union cvmx_usbdrdx_uahc_depcmdpar2_x {
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar2_x cvmx_usbdrdx_uahc_depcmdpar2_x_t;
 
@@ -1935,7 +2074,7 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar2_x cvmx_usbdrdx_uahc_depcmdpar2_x_t;
  * If an enable bit is set to 0, the event will not be generated.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.1.2.
  */
 union cvmx_usbdrdx_uahc_devten {
 	uint32_t u32;
@@ -1974,6 +2113,7 @@ union cvmx_usbdrdx_uahc_devten {
 	} s;
 	struct cvmx_usbdrdx_uahc_devten_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_devten_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_devten_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_devten cvmx_usbdrdx_uahc_devten_t;
 
@@ -1989,7 +2129,7 @@ typedef union cvmx_usbdrdx_uahc_devten cvmx_usbdrdx_uahc_devten_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.5.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.1.5.
  */
 union cvmx_usbdrdx_uahc_dgcmd {
 	uint32_t u32;
@@ -2025,6 +2165,7 @@ union cvmx_usbdrdx_uahc_dgcmd {
 	} s;
 	struct cvmx_usbdrdx_uahc_dgcmd_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_dgcmd_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dgcmd_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dgcmd cvmx_usbdrdx_uahc_dgcmd_t;
 
@@ -2039,7 +2180,7 @@ typedef union cvmx_usbdrdx_uahc_dgcmd cvmx_usbdrdx_uahc_dgcmd_t;
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.4.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.1.4.
  */
 union cvmx_usbdrdx_uahc_dgcmdpar {
 	uint32_t u32;
@@ -2054,6 +2195,7 @@ union cvmx_usbdrdx_uahc_dgcmdpar {
 	} s;
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dgcmdpar cvmx_usbdrdx_uahc_dgcmdpar_t;
 
@@ -2080,6 +2222,7 @@ union cvmx_usbdrdx_uahc_dnctrl {
 	} s;
 	struct cvmx_usbdrdx_uahc_dnctrl_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_dnctrl_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dnctrl_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dnctrl cvmx_usbdrdx_uahc_dnctrl_t;
 
@@ -2090,7 +2233,7 @@ typedef union cvmx_usbdrdx_uahc_dnctrl cvmx_usbdrdx_uahc_dnctrl_t;
  * events.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.3.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.3.1.3.
  */
 union cvmx_usbdrdx_uahc_dsts {
 	uint32_t u32;
@@ -2187,6 +2330,7 @@ union cvmx_usbdrdx_uahc_dsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_dsts_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dsts_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dsts_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dsts cvmx_usbdrdx_uahc_dsts_t;
 
@@ -2215,6 +2359,7 @@ union cvmx_usbdrdx_uahc_erdpx {
 	} s;
 	struct cvmx_usbdrdx_uahc_erdpx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_erdpx_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_erdpx_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_erdpx cvmx_usbdrdx_uahc_erdpx_t;
 
@@ -2241,6 +2386,7 @@ union cvmx_usbdrdx_uahc_erstbax {
 	} s;
 	struct cvmx_usbdrdx_uahc_erstbax_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_erstbax_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_erstbax_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_erstbax cvmx_usbdrdx_uahc_erstbax_t;
 
@@ -2249,7 +2395,7 @@ typedef union cvmx_usbdrdx_uahc_erstbax cvmx_usbdrdx_uahc_erstbax_t;
  *
  * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.3.1.
  *
- * This register can be reset by IOI reset,
+ * This register can be reset by NCB reset,
  * or USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
@@ -2267,6 +2413,7 @@ union cvmx_usbdrdx_uahc_erstszx {
 	} s;
 	struct cvmx_usbdrdx_uahc_erstszx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_erstszx_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_erstszx_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
 
@@ -2281,8 +2428,7 @@ typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
  * outstanding transactions. Instead, it keeps track of the start address of the DMA transfer
  * associated with all active transactions. It is this address that is reported in
  * USBDRD()_UAHC_GBUSERRADDR when a bus error occurs. For example, if the host controller
- * initiates
- * a DMA
+ * initiates a DMA
  * transfer to write 1k of packet data starting at buffer address 0xABCD0000, and this DMA is
  * broken up into multiple 256B bursts on the AXI, then if a bus error occurs on any of these
  * associated AXI transfers, USBDRD()_UAHC_GBUSERRADDR reflects the DMA start address of
@@ -2291,7 +2437,7 @@ typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.12.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.12.
  */
 union cvmx_usbdrdx_uahc_gbuserraddr {
 	uint64_t u64;
@@ -2306,6 +2452,7 @@ union cvmx_usbdrdx_uahc_gbuserraddr {
 	} s;
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gbuserraddr cvmx_usbdrdx_uahc_gbuserraddr_t;
 
@@ -2314,7 +2461,7 @@ typedef union cvmx_usbdrdx_uahc_gbuserraddr cvmx_usbdrdx_uahc_gbuserraddr_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.5.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.5.
  */
 union cvmx_usbdrdx_uahc_gctl {
 	uint32_t u32;
@@ -2358,8 +2505,8 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          0x2 = Interval is 31.25 us.
                                                          0x3 = Interval is 15.625 us.
                                                          For full-speed mode, the scale-down value is multiplied by 8. */
-	uint32_t prtcapdir                    : 2;  /**< 0x1: for Host configurations.
-                                                         0x2: for Device configurations. */
+	uint32_t prtcapdir                    : 2;  /**< 0x1 = for Host configurations.
+                                                         0x2 = for Device configurations. */
 	uint32_t coresoftreset                : 1;  /**< Core soft reset: 1 = soft reset to core, 0 = no soft reset.
                                                          Clears the interrupts and all the USBDRD()_UAHC_* CSRs except the
                                                          following registers: USBDRD()_UAHC_GCTL, USBDRD()_UAHC_GUCTL, USBDRD()_UAHC_GSTS,
@@ -2463,6 +2610,7 @@ union cvmx_usbdrdx_uahc_gctl {
 	} s;
 	struct cvmx_usbdrdx_uahc_gctl_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_gctl_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gctl_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gctl cvmx_usbdrdx_uahc_gctl_t;
 
@@ -2473,7 +2621,7 @@ typedef union cvmx_usbdrdx_uahc_gctl cvmx_usbdrdx_uahc_gctl_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.5.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.4.5.
  */
 union cvmx_usbdrdx_uahc_gdbgbmu {
 	uint32_t u32;
@@ -2490,6 +2638,7 @@ union cvmx_usbdrdx_uahc_gdbgbmu {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgbmu cvmx_usbdrdx_uahc_gdbgbmu_t;
 
@@ -2511,6 +2660,7 @@ union cvmx_usbdrdx_uahc_gdbgepinfo {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgepinfo cvmx_usbdrdx_uahc_gdbgepinfo_t;
 
@@ -2525,7 +2675,7 @@ typedef union cvmx_usbdrdx_uahc_gdbgepinfo cvmx_usbdrdx_uahc_gdbgepinfo_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.4.2.
  * INTERNAL: Contact Synopsys directly.
  */
 union cvmx_usbdrdx_uahc_gdbgfifospace {
@@ -2555,6 +2705,7 @@ union cvmx_usbdrdx_uahc_gdbgfifospace {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgfifospace cvmx_usbdrdx_uahc_gdbgfifospace_t;
 
@@ -2565,7 +2716,7 @@ typedef union cvmx_usbdrdx_uahc_gdbgfifospace cvmx_usbdrdx_uahc_gdbgfifospace_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.4.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.4.4.
  */
 union cvmx_usbdrdx_uahc_gdbglnmcc {
 	uint32_t u32;
@@ -2582,6 +2733,7 @@ union cvmx_usbdrdx_uahc_gdbglnmcc {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglnmcc cvmx_usbdrdx_uahc_gdbglnmcc_t;
 
@@ -2603,6 +2755,7 @@ union cvmx_usbdrdx_uahc_gdbglsp {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglsp cvmx_usbdrdx_uahc_gdbglsp_t;
 
@@ -2613,7 +2766,7 @@ typedef union cvmx_usbdrdx_uahc_gdbglsp cvmx_usbdrdx_uahc_gdbglsp_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.6.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.4.6.
  * INTERNAL: This register is for Synopsys internal use only.
  */
 union cvmx_usbdrdx_uahc_gdbglspmux {
@@ -2641,6 +2794,7 @@ union cvmx_usbdrdx_uahc_gdbglspmux {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglspmux cvmx_usbdrdx_uahc_gdbglspmux_t;
 
@@ -2654,7 +2808,7 @@ typedef union cvmx_usbdrdx_uahc_gdbglspmux cvmx_usbdrdx_uahc_gdbglspmux_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.3.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.4.3.
  */
 union cvmx_usbdrdx_uahc_gdbgltssm {
 	uint32_t u32;
@@ -2699,6 +2853,7 @@ union cvmx_usbdrdx_uahc_gdbgltssm {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgltssm cvmx_usbdrdx_uahc_gdbgltssm_t;
 
@@ -2726,7 +2881,7 @@ typedef union cvmx_usbdrdx_uahc_gdbgltssm cvmx_usbdrdx_uahc_gdbgltssm_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.5.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.9.5.
  */
 union cvmx_usbdrdx_uahc_gdmahlratio {
 	uint32_t u32;
@@ -2745,6 +2900,7 @@ union cvmx_usbdrdx_uahc_gdmahlratio {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdmahlratio cvmx_usbdrdx_uahc_gdmahlratio_t;
 
@@ -2762,7 +2918,7 @@ typedef union cvmx_usbdrdx_uahc_gdmahlratio cvmx_usbdrdx_uahc_gdmahlratio_t;
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.7.1.
  */
 union cvmx_usbdrdx_uahc_gevntadrx {
 	uint64_t u64;
@@ -2777,6 +2933,7 @@ union cvmx_usbdrdx_uahc_gevntadrx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntadrx cvmx_usbdrdx_uahc_gevntadrx_t;
 
@@ -2801,7 +2958,7 @@ typedef union cvmx_usbdrdx_uahc_gevntadrx cvmx_usbdrdx_uahc_gevntadrx_t;
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.3.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.7.3.
  */
 union cvmx_usbdrdx_uahc_gevntcountx {
 	uint32_t u32;
@@ -2818,6 +2975,7 @@ union cvmx_usbdrdx_uahc_gevntcountx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gevntcountx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gevntcountx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gevntcountx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntcountx cvmx_usbdrdx_uahc_gevntcountx_t;
 
@@ -2835,7 +2993,7 @@ typedef union cvmx_usbdrdx_uahc_gevntcountx cvmx_usbdrdx_uahc_gevntcountx_t;
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.7.2.
  */
 union cvmx_usbdrdx_uahc_gevntsizx {
 	uint32_t u32;
@@ -2853,8 +3011,22 @@ union cvmx_usbdrdx_uahc_gevntsizx {
 	uint32_t evntintmask                  : 1;
 #endif
 	} s;
-	struct cvmx_usbdrdx_uahc_gevntsizx_s  cn70xx;
-	struct cvmx_usbdrdx_uahc_gevntsizx_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gevntsizx_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t evntintmask                  : 1;  /**< When set to 1, this prevents the interrupt from being generated.
+                                                         However, even when the mask is set, the events are queued. */
+	uint32_t reserved_30_16               : 15;
+	uint32_t evntsiz                      : 16; /**< Holds the size of the Event Buffer in bytes; must be a multiple of
+                                                         four. This is programmed by software once during initialization.
+                                                         The minimum size of the event buffer is 32 bytes. */
+#else
+	uint32_t evntsiz                      : 16;
+	uint32_t reserved_30_16               : 15;
+	uint32_t evntintmask                  : 1;
+#endif
+	} cn70xx;
+	struct cvmx_usbdrdx_uahc_gevntsizx_cn70xx cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gevntsizx_cn70xx cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntsizx cvmx_usbdrdx_uahc_gevntsizx_t;
 
@@ -2870,7 +3042,7 @@ typedef union cvmx_usbdrdx_uahc_gevntsizx cvmx_usbdrdx_uahc_gevntsizx_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.6.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.9.6.
  */
 union cvmx_usbdrdx_uahc_gfladj {
 	uint32_t u32;
@@ -2959,6 +3131,7 @@ union cvmx_usbdrdx_uahc_gfladj {
 	} s;
 	struct cvmx_usbdrdx_uahc_gfladj_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_gfladj_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gfladj_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gfladj cvmx_usbdrdx_uahc_gfladj_t;
 
@@ -2970,7 +3143,7 @@ typedef union cvmx_usbdrdx_uahc_gfladj cvmx_usbdrdx_uahc_gfladj_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.9.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.9.
  */
 union cvmx_usbdrdx_uahc_ggpio {
 	uint32_t u32;
@@ -2985,6 +3158,7 @@ union cvmx_usbdrdx_uahc_ggpio {
 	} s;
 	struct cvmx_usbdrdx_uahc_ggpio_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_ggpio_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ggpio_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ggpio cvmx_usbdrdx_uahc_ggpio_t;
 
@@ -2993,7 +3167,7 @@ typedef union cvmx_usbdrdx_uahc_ggpio cvmx_usbdrdx_uahc_ggpio_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.3.1.
  */
 union cvmx_usbdrdx_uahc_ghwparams0 {
 	uint32_t u32;
@@ -3016,6 +3190,7 @@ union cvmx_usbdrdx_uahc_ghwparams0 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams0_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams0_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams0 cvmx_usbdrdx_uahc_ghwparams0_t;
 
@@ -3024,7 +3199,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams0 cvmx_usbdrdx_uahc_ghwparams0_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.3.2.
  */
 union cvmx_usbdrdx_uahc_ghwparams1 {
 	uint32_t u32;
@@ -3068,6 +3243,7 @@ union cvmx_usbdrdx_uahc_ghwparams1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams1_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams1_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams1 cvmx_usbdrdx_uahc_ghwparams1_t;
 
@@ -3076,7 +3252,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams1 cvmx_usbdrdx_uahc_ghwparams1_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.3.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.3.3.
  */
 union cvmx_usbdrdx_uahc_ghwparams2 {
 	uint32_t u32;
@@ -3089,6 +3265,7 @@ union cvmx_usbdrdx_uahc_ghwparams2 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams2_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams2_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams2 cvmx_usbdrdx_uahc_ghwparams2_t;
 
@@ -3097,7 +3274,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams2 cvmx_usbdrdx_uahc_ghwparams2_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.4.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.3.4.
  */
 union cvmx_usbdrdx_uahc_ghwparams3 {
 	uint32_t u32;
@@ -3130,6 +3307,7 @@ union cvmx_usbdrdx_uahc_ghwparams3 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams3_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams3_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams3 cvmx_usbdrdx_uahc_ghwparams3_t;
 
@@ -3138,7 +3316,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams3 cvmx_usbdrdx_uahc_ghwparams3_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.5.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.3.5.
  */
 union cvmx_usbdrdx_uahc_ghwparams4 {
 	uint32_t u32;
@@ -3167,6 +3345,7 @@ union cvmx_usbdrdx_uahc_ghwparams4 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams4_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams4_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams4_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams4 cvmx_usbdrdx_uahc_ghwparams4_t;
 
@@ -3175,7 +3354,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams4 cvmx_usbdrdx_uahc_ghwparams4_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.6.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.3.6.
  */
 union cvmx_usbdrdx_uahc_ghwparams5 {
 	uint32_t u32;
@@ -3198,6 +3377,7 @@ union cvmx_usbdrdx_uahc_ghwparams5 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams5_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams5_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams5_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams5 cvmx_usbdrdx_uahc_ghwparams5_t;
 
@@ -3206,7 +3386,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams5 cvmx_usbdrdx_uahc_ghwparams5_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.7.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.3.7.
  */
 union cvmx_usbdrdx_uahc_ghwparams6 {
 	uint32_t u32;
@@ -3239,6 +3419,7 @@ union cvmx_usbdrdx_uahc_ghwparams6 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams6_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams6_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams6_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams6 cvmx_usbdrdx_uahc_ghwparams6_t;
 
@@ -3247,7 +3428,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams6 cvmx_usbdrdx_uahc_ghwparams6_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.8.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.3.8.
  */
 union cvmx_usbdrdx_uahc_ghwparams7 {
 	uint32_t u32;
@@ -3262,13 +3443,14 @@ union cvmx_usbdrdx_uahc_ghwparams7 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams7_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams7_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams7_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams7 cvmx_usbdrdx_uahc_ghwparams7_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams8
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  *           See Synopsys DWC_usb3 Databook v2.20a, section 6.2.3.9.
  */
@@ -3283,6 +3465,7 @@ union cvmx_usbdrdx_uahc_ghwparams8 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams8_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams8_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams8_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams8 cvmx_usbdrdx_uahc_ghwparams8_t;
 
@@ -3297,7 +3480,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams8 cvmx_usbdrdx_uahc_ghwparams8_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.4.1.
  * INTERNAL: Contact Synopsys directly.
  */
 union cvmx_usbdrdx_uahc_gpmsts {
@@ -3334,6 +3517,7 @@ union cvmx_usbdrdx_uahc_gpmsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_gpmsts_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_gpmsts_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gpmsts_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gpmsts cvmx_usbdrdx_uahc_gpmsts_t;
 
@@ -3348,7 +3532,7 @@ typedef union cvmx_usbdrdx_uahc_gpmsts cvmx_usbdrdx_uahc_gpmsts_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.2.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.2.1.
  */
 union cvmx_usbdrdx_uahc_gprtbimap {
 	uint64_t u64;
@@ -3363,6 +3547,7 @@ union cvmx_usbdrdx_uahc_gprtbimap {
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap cvmx_usbdrdx_uahc_gprtbimap_t;
 
@@ -3392,6 +3577,7 @@ union cvmx_usbdrdx_uahc_gprtbimap_fs {
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap_fs cvmx_usbdrdx_uahc_gprtbimap_fs_t;
 
@@ -3421,6 +3607,7 @@ union cvmx_usbdrdx_uahc_gprtbimap_hs {
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap_hs cvmx_usbdrdx_uahc_gprtbimap_hs_t;
 
@@ -3429,7 +3616,7 @@ typedef union cvmx_usbdrdx_uahc_gprtbimap_hs cvmx_usbdrdx_uahc_gprtbimap_hs_t;
  *
  * This is a read-only register that contains the release number of the core.
  * INTERNAL: Original name: GSNPSID = Synopsys ID.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.8.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.8.
  */
 union cvmx_usbdrdx_uahc_grlsid {
 	uint32_t u32;
@@ -3437,15 +3624,16 @@ union cvmx_usbdrdx_uahc_grlsid {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t releaseid                    : 32; /**< Software can use this register to configure release-specific features in the driver.
                                                          INTERNAL: Synopsys ID
-                                                                 * SynopsysID[31:16] indicates Core Identification Number. 0x5533 is ASCII for U3
-                                                         (DWC_usb3).
-                                                                 * SynopsysID[15:0] indicates the release number. Current Release is 2.50a. */
+                                                          * SynopsysID[31:16] indicates Core Identification Number. 0x5533 is ASCII for
+                                                         U3 (DWC_usb3).
+                                                          * SynopsysID[15:0] indicates the release number. Current Release is 2.80a. */
 #else
 	uint32_t releaseid                    : 32;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_grlsid_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_grlsid_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_grlsid_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_grlsid cvmx_usbdrdx_uahc_grlsid_t;
 
@@ -3475,7 +3663,7 @@ typedef union cvmx_usbdrdx_uahc_grlsid cvmx_usbdrdx_uahc_grlsid_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.3.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.9.3.
  */
 union cvmx_usbdrdx_uahc_grxfifoprihst {
 	uint32_t u32;
@@ -3490,6 +3678,7 @@ union cvmx_usbdrdx_uahc_grxfifoprihst {
 	} s;
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn70xx;
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxfifoprihst cvmx_usbdrdx_uahc_grxfifoprihst_t;
 
@@ -3526,6 +3715,7 @@ union cvmx_usbdrdx_uahc_grxfifosizx {
 	} s;
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxfifosizx cvmx_usbdrdx_uahc_grxfifosizx_t;
 
@@ -3552,7 +3742,7 @@ typedef union cvmx_usbdrdx_uahc_grxfifosizx cvmx_usbdrdx_uahc_grxfifosizx_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.4.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.4.
  */
 union cvmx_usbdrdx_uahc_grxthrcfg {
 	uint32_t u32;
@@ -3596,6 +3786,7 @@ union cvmx_usbdrdx_uahc_grxthrcfg {
 	} s;
 	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxthrcfg cvmx_usbdrdx_uahc_grxthrcfg_t;
 
@@ -3612,7 +3803,7 @@ typedef union cvmx_usbdrdx_uahc_grxthrcfg cvmx_usbdrdx_uahc_grxthrcfg_t;
  *
  * INTERNAL: The AXI cache signals are not connected in Cavium's hookup, so the *REQINFO fields
  * can be ignored.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.1.
  */
 union cvmx_usbdrdx_uahc_gsbuscfg0 {
 	uint32_t u32;
@@ -3663,6 +3854,7 @@ union cvmx_usbdrdx_uahc_gsbuscfg0 {
 	} s;
 	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsbuscfg0 cvmx_usbdrdx_uahc_gsbuscfg0_t;
 
@@ -3676,7 +3868,7 @@ typedef union cvmx_usbdrdx_uahc_gsbuscfg0 cvmx_usbdrdx_uahc_gsbuscfg0_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.2.
  */
 union cvmx_usbdrdx_uahc_gsbuscfg1 {
 	uint32_t u32;
@@ -3708,6 +3900,7 @@ union cvmx_usbdrdx_uahc_gsbuscfg1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsbuscfg1 cvmx_usbdrdx_uahc_gsbuscfg1_t;
 
@@ -3716,7 +3909,7 @@ typedef union cvmx_usbdrdx_uahc_gsbuscfg1 cvmx_usbdrdx_uahc_gsbuscfg1_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.6.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.6.
  */
 union cvmx_usbdrdx_uahc_gsts {
 	uint32_t u32;
@@ -3748,6 +3941,7 @@ union cvmx_usbdrdx_uahc_gsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_gsts_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_gsts_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gsts_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsts cvmx_usbdrdx_uahc_gsts_t;
 
@@ -3781,7 +3975,7 @@ typedef union cvmx_usbdrdx_uahc_gsts cvmx_usbdrdx_uahc_gsts_t;
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.9.1.
  */
 union cvmx_usbdrdx_uahc_gtxfifopridev {
 	uint32_t u32;
@@ -3797,6 +3991,7 @@ union cvmx_usbdrdx_uahc_gtxfifopridev {
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifopridev cvmx_usbdrdx_uahc_gtxfifopridev_t;
 
@@ -3828,7 +4023,7 @@ typedef union cvmx_usbdrdx_uahc_gtxfifopridev cvmx_usbdrdx_uahc_gtxfifopridev_t;
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.9.2.
  */
 union cvmx_usbdrdx_uahc_gtxfifoprihst {
 	uint32_t u32;
@@ -3844,6 +4039,7 @@ union cvmx_usbdrdx_uahc_gtxfifoprihst {
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifoprihst cvmx_usbdrdx_uahc_gtxfifoprihst_t;
 
@@ -3881,6 +4077,7 @@ union cvmx_usbdrdx_uahc_gtxfifosizx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifosizx cvmx_usbdrdx_uahc_gtxfifosizx_t;
 
@@ -3904,7 +4101,7 @@ typedef union cvmx_usbdrdx_uahc_gtxfifosizx cvmx_usbdrdx_uahc_gtxfifosizx_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.3.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.3.
  */
 union cvmx_usbdrdx_uahc_gtxthrcfg {
 	uint32_t u32;
@@ -3942,6 +4139,7 @@ union cvmx_usbdrdx_uahc_gtxthrcfg {
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxthrcfg cvmx_usbdrdx_uahc_gtxthrcfg_t;
 
@@ -3953,7 +4151,7 @@ typedef union cvmx_usbdrdx_uahc_gtxthrcfg cvmx_usbdrdx_uahc_gtxthrcfg_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.11.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.11.
  */
 union cvmx_usbdrdx_uahc_guctl {
 	uint32_t u32;
@@ -4002,6 +4200,115 @@ union cvmx_usbdrdx_uahc_guctl {
                                                          only. This allows you to easily identify a device connected to a port in the Lecroy or
                                                          Eliisys trace during hardware debug.
                                                          This bit is used in host mode only. */
+	uint32_t reserved_14_14               : 1;
+	uint32_t enoverlapchk                 : 1;  /**< Enable check for LFPS overlap during remote Ux Exit. If this bit is set to:
+                                                         0 = When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS
+                                                         overlap.
+                                                         1 = The SuperSpeed link, when exiting U1/U2/U3, waits for either the remote link LFPS or
+                                                         TS1/TS2 training symbols before it confirms that the LFPS handshake is complete. This is
+                                                         done to handle the case where the LFPS glitch causes the link to start exiting from the
+                                                         low power state. Looking for the LFPS overlap makes sure that the link partner also sees
+                                                         the LFPS. */
+	uint32_t extcapsupten                 : 1;  /**< External extended capability support enable. If disabled, a read
+                                                         USBDRD()_UAHC_SUPTPRT3_DW0
+                                                         [NEXTCAPPTR] returns 0 in the next capability pointer field. This indicates there are no
+                                                         more capabilities. If enabled, a read to USBDRD()_UAHC_SUPTPRT3_DW0[NEXTCAPPTR] returns 4
+                                                         in
+                                                         the
+                                                         next capability pointer field.
+                                                         Always set to 0x0. */
+	uint32_t insrtextrfsbodi              : 1;  /**< Insert extra delay between full-speed bulk OUT transactions. Some full-speed devices are
+                                                         slow to receive bulk OUT data and can get stuck when there are consecutive bulk OUT
+                                                         transactions with short inter-transaction delays. This bit is used to control whether the
+                                                         host inserts extra delay between consecutive bulk OUT transactions to a full-speed
+                                                         endpoint.
+                                                         0 = Host does not insert extra delay.
+                                                         Setting this bit to 1 reduces the bulk OUT transfer performance for most of the full-speed
+                                                         devices.
+                                                         1 = Host inserts about 12 us extra delay between consecutive bulk OUT transactions to an
+                                                         full-speed endpoint to work around the device issue. */
+	uint32_t dtct                         : 2;  /**< Device timeout coarse tuning. This field determines how long the host waits for a response
+                                                         from device before considering a timeout.
+                                                         The core first checks the DTCT value. If it is 0, then the timeout value is defined by the
+                                                         DTFT. If it is non-zero, then it uses the following timeout values:
+                                                         0x0 = 0 us; use DTFT value instead.
+                                                         0x1 = 500 us.
+                                                         0x2 = 1.5 ms.
+                                                         0x3 = 6.5 ms. */
+	uint32_t dtft                         : 9;  /**< Device timeout fine tuning. This field determines how long the host waits for a response
+                                                         from a device before considering a timeout. For DTFT to take effect, DTCT must be set to
+                                                         0x0.
+                                                         The DTFT value specifies the number of 125MHz clock cycles * 256 to count before
+                                                         considering a device timeout. For the 125 MHz clock cycles (8 ns period), this is
+                                                         calculated as follows:
+                                                         _ [DTFT value] * 256 * 8 (ns)
+                                                         0x2 = 2 * 256 * 8 -> 4 us.
+                                                         0x5 = 5 * 256 * 8 -> 10 us.
+                                                         0xA = 10 * 256 * 8 -> 20 us.
+                                                         0x10 = 16 * 256 * 8 -> 32 us.
+                                                         0x19 = 25 * 256 * 8 -> 51 us.
+                                                         0x31 = 49 * 256 * 8 -> 100 us.
+                                                         0x62 = 98 * 256 * 8 -> 200 us. */
+#else
+	uint32_t dtft                         : 9;
+	uint32_t dtct                         : 2;
+	uint32_t insrtextrfsbodi              : 1;
+	uint32_t extcapsupten                 : 1;
+	uint32_t enoverlapchk                 : 1;
+	uint32_t reserved_14_14               : 1;
+	uint32_t cmdevaddr                    : 1;
+	uint32_t resbwhseps                   : 1;
+	uint32_t sprsctrltransen              : 1;
+	uint32_t psqextrressp                 : 3;
+	uint32_t noextrdl                     : 1;
+	uint32_t refclkper                    : 10;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uahc_guctl_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t refclkper                    : 10; /**< Reference-clock period. Indicates (in terms of ns) the period of REF_CLK. The default
+                                                         value is set to 0x8
+                                                         (8 ns/125 MHz). This field must be updated during power on initialization if
+                                                         USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1 or USBDRD()_UAHC_GFLADJ [GFLADJ_REFCLK_LPM_SEL] = 1.
+                                                         The
+                                                         programmable maximum value 62 ns, and the minimum value is 8 ns. You use a reference clock
+                                                         with a period that is a integer multiple, so that ITP can meet the jitter margin of 32 ns.
+                                                         The allowable REF_CLK frequencies whose period is not integer multiples are
+                                                         16/17/19.2/24/39.7 MHz.
+                                                         This field should not be set to 0x0 at any time. If you do not plan to use this feature,
+                                                         then you need to set this field to 0x8, the default value. */
+	uint32_t noextrdl                     : 1;  /**< No extra delay between SOF and the first packet.
+                                                         Some high-speed devices misbehave when the host sends a packet immediately after an SOF.
+                                                         However, adding an extra delay between an SOF and the first packet can reduce the USB data
+                                                         rate and performance.
+                                                         This bit is used to control whether the host should wait for 2 us before it sends the
+                                                         first packet after a SOF, or not. You can set this bit to 1 to improve the performance if
+                                                         those problematic devices are not a concern in your host environment.
+                                                         0 = host waits for 2 us after an SOF before it sends the first USB packet.
+                                                         1 = host does not wait after an SOF before it sends the first USB packet. */
+	uint32_t psqextrressp                 : 3;  /**< PSQ extra reserved space. This is a debug feature, and is not intended for normal usage.
+                                                         This parameter specifies how much additional space in the PSQ (protocol-status queue) must
+                                                         be reserved before the U3PTL initiates a new USB transaction and burst beats. */
+	uint32_t sprsctrltransen              : 1;  /**< Sparse control transaction enable. Some devices are slow in responding to control
+                                                         transfers. Scheduling multiple transactions in one microframe/frame can cause these
+                                                         devices to misbehave. If this bit is set to 1, the host controller schedules transactions
+                                                         for a control transfer in different microframes/frames. */
+	uint32_t resbwhseps                   : 1;  /**< Reserving 85% bandwidth for high-speed periodic EPs. By default, host controller reserves
+                                                         80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85%
+                                                         to accommodate two high-speed, high-bandwidth ISOC EPs.
+                                                         USB 2.0 required 80% bandwidth allocated for ISOC traffic. If two high bandwidth ISOC
+                                                         devices (HD webcams) are connected, and if each requires 1024-bytes * 3 packets per
+                                                         microframe, then the bandwidth required is around 82%. If this bit is set to 1, it is
+                                                         possible to connect two webcams of 1024 bytes * 3 payload per microframe each. Otherwise,
+                                                         you may have to reduce the resolution of the webcams. */
+	uint32_t cmdevaddr                    : 1;  /**< Compliance mode for device address. When set to 1, slot ID can have different value than
+                                                         device address if max_slot_enabled < 128.
+                                                         0 = Device address is equal to slot ID.
+                                                         1 = Increment device address on each address device command.
+                                                         The xHCI compliance requires this bit to be set to 1. The 0 mode is for debug purpose
+                                                         only. This allows you to easily identify a device connected to a port in the Lecroy or
+                                                         Eliisys trace during hardware debug.
+                                                         This bit is used in host mode only. */
 	uint32_t usbhstinautoretryen          : 1;  /**< Host IN auto-retry enable. When set, this field enables the auto-retry feature. For IN
                                                          transfers (non-isochronous) that encounter data packets with CRC errors or internal
                                                          overrun scenarios, the auto-retry feature causes the host core to reply to the device with
@@ -4070,9 +4377,122 @@ union cvmx_usbdrdx_uahc_guctl {
 	uint32_t noextrdl                     : 1;
 	uint32_t refclkper                    : 10;
 #endif
-	} s;
-	struct cvmx_usbdrdx_uahc_guctl_s      cn70xx;
-	struct cvmx_usbdrdx_uahc_guctl_s      cn70xxp1;
+	} cn70xx;
+	struct cvmx_usbdrdx_uahc_guctl_cn70xx cn70xxp1;
+	struct cvmx_usbdrdx_uahc_guctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t refclkper                    : 10; /**< Reference-clock period. Indicates (in terms of ns) the period of REF_CLK. The default
+                                                         value is set to 0x8
+                                                         (8 ns/125 MHz). This field must be updated during power on initialization if
+                                                         USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1 or USBDRD()_UAHC_GFLADJ [GFLADJ_REFCLK_LPM_SEL] = 1.
+                                                         The
+                                                         programmable maximum value 62 ns, and the minimum value is 8 ns. You use a reference clock
+                                                         with a period that is a integer multiple, so that ITP can meet the jitter margin of 32 ns.
+                                                         The allowable REF_CLK frequencies whose period is not integer multiples are
+                                                         16/17/19.2/24/39.7 MHz.
+                                                         This field should not be set to 0x0 at any time. If you do not plan to use this feature,
+                                                         then you need to set this field to 0x8, the default value. */
+	uint32_t noextrdl                     : 1;  /**< No extra delay between SOF and the first packet.
+                                                         Some high-speed devices misbehave when the host sends a packet immediately after an SOF.
+                                                         However, adding an extra delay between an SOF and the first packet can reduce the USB data
+                                                         rate and performance.
+                                                         This bit is used to control whether the host should wait for 2 us before it sends the
+                                                         first packet after a SOF, or not. You can set this bit to 1 to improve the performance if
+                                                         those problematic devices are not a concern in your host environment.
+                                                         0 = host waits for 2 us after an SOF before it sends the first USB packet.
+                                                         1 = host does not wait after an SOF before it sends the first USB packet. */
+	uint32_t psqextrressp                 : 3;  /**< PSQ extra reserved space. This is a debug feature, and is not intended for normal usage.
+                                                         This parameter specifies how much additional space in the PSQ (protocol-status queue) must
+                                                         be reserved before the U3PTL initiates a new USB transaction and burst beats. */
+	uint32_t sprsctrltransen              : 1;  /**< Sparse control transaction enable. Some devices are slow in responding to control
+                                                         transfers. Scheduling multiple transactions in one microframe/frame can cause these
+                                                         devices to misbehave. If this bit is set to 1, the host controller schedules transactions
+                                                         for a control transfer in different microframes/frames. */
+	uint32_t resbwhseps                   : 1;  /**< Reserving 85% bandwidth for high-speed periodic EPs. By default, host controller reserves
+                                                         80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85%
+                                                         to accommodate two high-speed, high-bandwidth ISOC EPs.
+                                                         USB 2.0 required 80% bandwidth allocated for ISOC traffic. If two high bandwidth ISOC
+                                                         devices (HD webcams) are connected, and if each requires 1024-bytes * 3 packets per
+                                                         microframe, then the bandwidth required is around 82%. If this bit is set to 1, it is
+                                                         possible to connect two webcams of 1024 bytes * 3 payload per microframe each. Otherwise,
+                                                         you may have to reduce the resolution of the webcams. */
+	uint32_t cmdevaddr                    : 1;  /**< Compliance mode for device address. When set to 1, slot ID can have different value than
+                                                         device address if max_slot_enabled < 128.
+                                                         0 = Device address is equal to slot ID.
+                                                         1 = Increment device address on each address device command.
+                                                         The xHCI compliance requires this bit to be set to 1. The 0 mode is for debug purpose
+                                                         only. This allows you to easily identify a device connected to a port in the Lecroy or
+                                                         Eliisys trace during hardware debug.
+                                                         This bit is used in host mode only. */
+	uint32_t usbdrdstinautoretryen        : 1;  /**< Host IN auto-retry enable. When set, this field enables the auto-retry feature. For IN
+                                                         transfers (non-isochronous) that encounter data packets with CRC errors or internal
+                                                         overrun scenarios, the auto-retry feature causes the host core to reply to the device with
+                                                         a non-terminating retry ACK (i.e. an ACK transaction packet with Retry = 1 and NumP != 0).
+                                                         If the auto-retry feature is disabled (default), the core responds with a terminating
+                                                         retry ACK (i.e. an ACK transaction packet with Retry = 1 and NumP = 0). */
+	uint32_t enoverlapchk                 : 1;  /**< Enable check for LFPS overlap during remote Ux Exit. If this bit is set to:
+                                                         0 = When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS
+                                                         overlap.
+                                                         1 = The SuperSpeed link, when exiting U1/U2/U3, waits for either the remote link LFPS or
+                                                         TS1/TS2 training symbols before it confirms that the LFPS handshake is complete. This is
+                                                         done to handle the case where the LFPS glitch causes the link to start exiting from the
+                                                         low power state. Looking for the LFPS overlap makes sure that the link partner also sees
+                                                         the LFPS. */
+	uint32_t extcapsupten                 : 1;  /**< External extended capability support enable. If disabled, a read
+                                                         USBDRD()_UAHC_SUPTPRT3_DW0
+                                                         [NEXTCAPPTR] returns 0 in the next capability pointer field. This indicates there are no
+                                                         more capabilities. If enabled, a read to USBDRD()_UAHC_SUPTPRT3_DW0[NEXTCAPPTR] returns 4
+                                                         in
+                                                         the
+                                                         next capability pointer field.
+                                                         Always set to 0x0. */
+	uint32_t insrtextrfsbodi              : 1;  /**< Insert extra delay between full-speed bulk OUT transactions. Some full-speed devices are
+                                                         slow to receive bulk OUT data and can get stuck when there are consecutive bulk OUT
+                                                         transactions with short inter-transaction delays. This bit is used to control whether the
+                                                         host inserts extra delay between consecutive bulk OUT transactions to a full-speed
+                                                         endpoint.
+                                                         0 = Host does not insert extra delay.
+                                                         Setting this bit to 1 reduces the bulk OUT transfer performance for most of the full-speed
+                                                         devices.
+                                                         1 = Host inserts about 12 us extra delay between consecutive bulk OUT transactions to an
+                                                         full-speed endpoint to work around the device issue. */
+	uint32_t dtct                         : 2;  /**< Device timeout coarse tuning. This field determines how long the host waits for a response
+                                                         from device before considering a timeout.
+                                                         The core first checks the DTCT value. If it is 0, then the timeout value is defined by the
+                                                         DTFT. If it is non-zero, then it uses the following timeout values:
+                                                         0x0 = 0 us; use DTFT value instead.
+                                                         0x1 = 500 us.
+                                                         0x2 = 1.5 ms.
+                                                         0x3 = 6.5 ms. */
+	uint32_t dtft                         : 9;  /**< Device timeout fine tuning. This field determines how long the host waits for a response
+                                                         from a device before considering a timeout. For DTFT to take effect, DTCT must be set to
+                                                         0x0.
+                                                         The DTFT value specifies the number of 125MHz clock cycles * 256 to count before
+                                                         considering a device timeout. For the 125 MHz clock cycles (8 ns period), this is
+                                                         calculated as follows:
+                                                         _ [DTFT value] * 256 * 8 (ns)
+                                                         0x2 = 2 * 256 * 8 -> 4 us.
+                                                         0x5 = 5 * 256 * 8 -> 10 us.
+                                                         0xA = 10 * 256 * 8 -> 20 us.
+                                                         0x10 = 16 * 256 * 8 -> 32 us.
+                                                         0x19 = 25 * 256 * 8 -> 51 us.
+                                                         0x31 = 49 * 256 * 8 -> 100 us.
+                                                         0x62 = 98 * 256 * 8 -> 200 us. */
+#else
+	uint32_t dtft                         : 9;
+	uint32_t dtct                         : 2;
+	uint32_t insrtextrfsbodi              : 1;
+	uint32_t extcapsupten                 : 1;
+	uint32_t enoverlapchk                 : 1;
+	uint32_t usbdrdstinautoretryen        : 1;
+	uint32_t cmdevaddr                    : 1;
+	uint32_t resbwhseps                   : 1;
+	uint32_t sprsctrltransen              : 1;
+	uint32_t psqextrressp                 : 3;
+	uint32_t noextrdl                     : 1;
+	uint32_t refclkper                    : 10;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_guctl cvmx_usbdrdx_uahc_guctl_t;
 
@@ -4081,7 +4501,7 @@ typedef union cvmx_usbdrdx_uahc_guctl cvmx_usbdrdx_uahc_guctl_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.7.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.7.
  */
 union cvmx_usbdrdx_uahc_guctl1 {
 	uint32_t u32;
@@ -4101,6 +4521,7 @@ union cvmx_usbdrdx_uahc_guctl1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_guctl1_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_guctl1_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_guctl1_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_guctl1 cvmx_usbdrdx_uahc_guctl1_t;
 
@@ -4116,7 +4537,7 @@ typedef union cvmx_usbdrdx_uahc_guctl1 cvmx_usbdrdx_uahc_guctl1_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.10.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.80a, section 6.2.1.10.
  */
 union cvmx_usbdrdx_uahc_guid {
 	uint32_t u32;
@@ -4129,6 +4550,7 @@ union cvmx_usbdrdx_uahc_guid {
 	} s;
 	struct cvmx_usbdrdx_uahc_guid_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_guid_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_guid_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_guid cvmx_usbdrdx_uahc_guid_t;
 
@@ -4152,6 +4574,7 @@ union cvmx_usbdrdx_uahc_gusb2i2cctlx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb2i2cctlx cvmx_usbdrdx_uahc_gusb2i2cctlx_t;
 
@@ -4261,6 +4684,7 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb2phycfgx cvmx_usbdrdx_uahc_gusb2phycfgx_t;
 
@@ -4435,6 +4859,7 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb3pipectlx cvmx_usbdrdx_uahc_gusb3pipectlx_t;
 
@@ -4477,6 +4902,7 @@ union cvmx_usbdrdx_uahc_hccparams {
 	} s;
 	struct cvmx_usbdrdx_uahc_hccparams_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_hccparams_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_hccparams_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_hccparams cvmx_usbdrdx_uahc_hccparams_t;
 
@@ -4503,6 +4929,7 @@ union cvmx_usbdrdx_uahc_hcsparams1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams1_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_hcsparams1_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams1 cvmx_usbdrdx_uahc_hcsparams1_t;
 
@@ -4533,6 +4960,7 @@ union cvmx_usbdrdx_uahc_hcsparams2 {
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams2_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_hcsparams2_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams2 cvmx_usbdrdx_uahc_hcsparams2_t;
 
@@ -4557,6 +4985,7 @@ union cvmx_usbdrdx_uahc_hcsparams3 {
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams3_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_hcsparams3_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams3 cvmx_usbdrdx_uahc_hcsparams3_t;
 
@@ -4585,6 +5014,7 @@ union cvmx_usbdrdx_uahc_imanx {
 	} s;
 	struct cvmx_usbdrdx_uahc_imanx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_imanx_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_imanx_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_imanx cvmx_usbdrdx_uahc_imanx_t;
 
@@ -4611,6 +5041,7 @@ union cvmx_usbdrdx_uahc_imodx {
 	} s;
 	struct cvmx_usbdrdx_uahc_imodx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_imodx_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_imodx_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_imodx cvmx_usbdrdx_uahc_imodx_t;
 
@@ -4637,6 +5068,7 @@ union cvmx_usbdrdx_uahc_mfindex {
 	} s;
 	struct cvmx_usbdrdx_uahc_mfindex_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_mfindex_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_mfindex_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_mfindex cvmx_usbdrdx_uahc_mfindex_t;
 
@@ -4659,6 +5091,7 @@ union cvmx_usbdrdx_uahc_pagesize {
 	} s;
 	struct cvmx_usbdrdx_uahc_pagesize_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_pagesize_s   cn70xxp1;
+	struct cvmx_usbdrdx_uahc_pagesize_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_pagesize cvmx_usbdrdx_uahc_pagesize_t;
 
@@ -4700,6 +5133,7 @@ union cvmx_usbdrdx_uahc_porthlpmc_20x {
 	} s;
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_porthlpmc_20x cvmx_usbdrdx_uahc_porthlpmc_20x_t;
 
@@ -4725,6 +5159,7 @@ union cvmx_usbdrdx_uahc_porthlpmc_ssx {
 	} s;
 	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_porthlpmc_ssx cvmx_usbdrdx_uahc_porthlpmc_ssx_t;
 
@@ -4745,6 +5180,7 @@ union cvmx_usbdrdx_uahc_portli_20x {
 	} s;
 	struct cvmx_usbdrdx_uahc_portli_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portli_20x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portli_20x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portli_20x cvmx_usbdrdx_uahc_portli_20x_t;
 
@@ -4767,6 +5203,7 @@ union cvmx_usbdrdx_uahc_portli_ssx {
 	} s;
 	struct cvmx_usbdrdx_uahc_portli_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portli_ssx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portli_ssx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portli_ssx cvmx_usbdrdx_uahc_portli_ssx_t;
 
@@ -4803,6 +5240,7 @@ union cvmx_usbdrdx_uahc_portpmsc_20x {
 	} s;
 	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portpmsc_20x cvmx_usbdrdx_uahc_portpmsc_20x_t;
 
@@ -4833,6 +5271,7 @@ union cvmx_usbdrdx_uahc_portpmsc_ssx {
 	} s;
 	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portpmsc_ssx cvmx_usbdrdx_uahc_portpmsc_ssx_t;
 
@@ -4904,6 +5343,7 @@ union cvmx_usbdrdx_uahc_portscx {
 	} s;
 	struct cvmx_usbdrdx_uahc_portscx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_portscx_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portscx_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portscx cvmx_usbdrdx_uahc_portscx_t;
 
@@ -4926,6 +5366,7 @@ union cvmx_usbdrdx_uahc_rtsoff {
 	} s;
 	struct cvmx_usbdrdx_uahc_rtsoff_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_rtsoff_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_rtsoff_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_rtsoff cvmx_usbdrdx_uahc_rtsoff_t;
 
@@ -4952,6 +5393,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw0 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw0 cvmx_usbdrdx_uahc_suptprt2_dw0_t;
 
@@ -4972,6 +5414,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw1 cvmx_usbdrdx_uahc_suptprt2_dw1_t;
 
@@ -5008,6 +5451,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw2 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw2 cvmx_usbdrdx_uahc_suptprt2_dw2_t;
 
@@ -5030,6 +5474,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw3 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw3 cvmx_usbdrdx_uahc_suptprt2_dw3_t;
 
@@ -5059,6 +5504,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw0 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw0 cvmx_usbdrdx_uahc_suptprt3_dw0_t;
 
@@ -5079,6 +5525,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw1 cvmx_usbdrdx_uahc_suptprt3_dw1_t;
 
@@ -5105,6 +5552,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw2 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw2 cvmx_usbdrdx_uahc_suptprt3_dw2_t;
 
@@ -5127,6 +5575,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw3 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw3 cvmx_usbdrdx_uahc_suptprt3_dw3_t;
 
@@ -5171,6 +5620,7 @@ union cvmx_usbdrdx_uahc_usbcmd {
 	} s;
 	struct cvmx_usbdrdx_uahc_usbcmd_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_usbcmd_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_usbcmd_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_usbcmd cvmx_usbdrdx_uahc_usbcmd_t;
 
@@ -5230,6 +5680,7 @@ union cvmx_usbdrdx_uahc_usblegctlsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn70xx;
 	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_usblegctlsts cvmx_usbdrdx_uahc_usblegctlsts_t;
 
@@ -5264,6 +5715,7 @@ union cvmx_usbdrdx_uahc_usblegsup {
 	} s;
 	struct cvmx_usbdrdx_uahc_usblegsup_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_usblegsup_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_usblegsup_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_usblegsup cvmx_usbdrdx_uahc_usblegsup_t;
 
@@ -5310,13 +5762,15 @@ union cvmx_usbdrdx_uahc_usbsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_usbsts_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_usbsts_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_usbsts_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_usbsts cvmx_usbdrdx_uahc_usbsts_t;
 
 /**
  * cvmx_usbdrd#_uctl_bist_status
  *
- * This register indicates the results from the built-in self-test (BIST) runs of USBH memories.
+ * This register indicates the results from the built-in self-test (BIST) runs of USBDRD
+ * memories.
  * A 0 indicates pass or never run, a 1 indicates fail. This register can be reset by IOI reset.
  */
 union cvmx_usbdrdx_uctl_bist_status {
@@ -5356,6 +5810,7 @@ union cvmx_usbdrdx_uctl_bist_status {
 	} s;
 	struct cvmx_usbdrdx_uctl_bist_status_s cn70xx;
 	struct cvmx_usbdrdx_uctl_bist_status_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_bist_status_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_bist_status cvmx_usbdrdx_uctl_bist_status_t;
 
@@ -5370,7 +5825,8 @@ union cvmx_usbdrdx_uctl_ctl {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uctl_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t clear_bist                   : 1;  /**< BIST fast-clear mode select. A BIST run with this bit set clears all entries in USBH RAMs
+	uint64_t clear_bist                   : 1;  /**< BIST fast-clear mode select. A BIST run with this bit set clears all entries in USBDRD
+                                                         RAMs
                                                          to 0x0.
                                                          There are two major modes of BIST: full and clear. Full BIST is run by the BIST state
                                                          machine when CLEAR_BIST is deasserted during BIST. Clear BIST is run if CLEAR_BIST is
@@ -5391,18 +5847,17 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          cycles
                                                          for
                                                          the largest RAM. */
-	uint64_t ref_clk_sel                  : 2;  /**< Choose reference clock source for the SuperSpeed and HighSpeed PLL blocks.
-                                                           0x0 = Reference clock source for both PLLs is DLMC_REF_CLK0.
-                                                           0x1 = Reference clock source for both PLLs is DLMC_REF_CLK1.
-                                                           0x2 = Reference clock source for SuperSpeed PLL is DLMC_REF_CLK0,
-                                                                 reference clock source for HighSpeed PLL is PLL_REF_CLK.
-                                                           0x3 = Reference clock source for SuperSpeed PLL is DLMC_REF_CLK1,
-                                                                 reference clock source for HighSpeed PLL is PLL_REF_CLK.
-                                                         The DLMC_REF_CLK*'s are the shared reference clocks from the SERDES blocks.
-                                                         The PLL_REF_CLK is a 50MHz reference clock from an on-chip PLL.
+	uint64_t ref_clk_sel                  : 2;  /**< Reference clock select. Choose reference-clock source for the SuperSpeed and high-speed
+                                                         PLL blocks.
+                                                         0x0 = Reference clock source for both PLLs come from the USB pads.
+                                                         0x1 = Reserved.
+                                                         0x2 = Reserved.
+                                                         0x3 = Reserved.
                                                          This value can be changed only during UPHY_RST.
-                                                         Note: If REF_CLK_SEL = 0x0 or 0x1, then the DLMC_REF_CLK* input chosen
-                                                         cannot be spread-spectrum. */
+                                                         If REF_CLK_SEL = 0x0, then the reference clock input cannot be spread-spectrum.
+                                                         INTERNAL: For the 0x1 selection, reference clock source for SuperSpeed PLL is from the USB
+                                                         pads, reference clock source for HighSpeed PLL is PLL_REF_CLK. But in 78xx, PLL_REF_CLK
+                                                         cannot be routed to USB without violating jitter requirements */
 	uint64_t ssc_en                       : 1;  /**< Spread-spectrum clock enable. Enables spread-spectrum clock production in the SuperSpeed
                                                          function. If the input reference clock for the SuperSpeed PLL is already spread-spectrum,
                                                          then do not enable this feature. The clocks sourced to the SuperSpeed function must have
@@ -5537,7 +5992,8 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          being reset.
                                                          This also resets the suspend-clock divider. */
 	uint64_t reserved_27_27               : 1;
-	uint64_t h_clkdiv_sel                 : 3;  /**< The hclk frequency is sclk frequency divided by H_CLKDIV_SEL.
+	uint64_t h_clkdiv_sel                 : 3;  /**< Controller clock-frequency-divider select. The controller-clock frequency is the
+                                                         coprocessor-clock frequency divided by H_CLKDIV_SEL and must be at or below 300 MHz.
                                                          The divider values are the following:
                                                          0x0 = divide by 1.
                                                          0x1 = divide by 2.
@@ -5560,11 +6016,11 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          for any USB2 operation.
                                                          This field can be changed only when H_CLKDIV_RST = 1.
                                                          INTERNAL: 150MHz is from the maximum of:
-                                                                     Synopsys DWC_usb3 Databook v2.50a, table A-16, row 1, col 12.
-                                                                     Synopsys DWC_usb3 Databook v2.50a, table A-17, row 7, col 9.
-                                                                     Synopsys DWC_usb3 Databook v2.50a, table A-16, row 7, col 9.
-                                                                   DEVICE>125MHz is from Synopsys DWC_usb3 Databook v2.50a, section A.12.4.
-                                                                   HOST2>62.5MHz in HOST mode is from Synopsys DWC_usb3 Databook v2.50a,
+                                                                     Synopsys DWC_usb3 Databook v2.80a, table A-16, row 1, col 12.
+                                                                     Synopsys DWC_usb3 Databook v2.80a, table A-17, row 7, col 9.
+                                                                     Synopsys DWC_usb3 Databook v2.80a, table A-16, row 7, col 9.
+                                                                   DEVICE>125MHz is from Synopsys DWC_usb3 Databook v2.80a, section A.12.4.
+                                                                   HOST2>62.5MHz in HOST mode is from Synopsys DWC_usb3 Databook v2.80a,
                                                                      section A.12.5, 3rd bullet in Note on page 894.
                                                                    HOST2>90MHz was arrived at from some math: 62.5MHz +
                                                                      (diff between row 1 and 2, col 12 of table A-16). */
@@ -5604,14 +6060,14 @@ union cvmx_usbdrdx_uctl_ctl {
 	uint64_t uphy_rst                     : 1;  /**< PHY reset; resets UPHY; active-high. */
 	uint64_t uahc_rst                     : 1;  /**< Software reset; resets UAHC; active-high.
                                                          INTERNAL: Note that soft-resetting the UAHC while it is active may cause violations of RSL
-                                                         or IOI protocols. */
+                                                         or NCB protocols. */
 	uint64_t uctl_rst                     : 1;  /**< Software reset; resets UCTL; active-high.
                                                          Resets UAHC DMA and register shims. Resets UCTL RSL registers 0x30-0xF8.
                                                          Does not reset UCTL RSL registers 0x0-0x28.
                                                          UCTL RSL registers starting from 0x30 can be accessed only after the controller clock is
                                                          active and UCTL_RST is deasserted.
                                                          INTERNAL: Note that soft-resetting the UCTL while it is active may cause violations of
-                                                         RSL, IOI, and CIB protocols. */
+                                                         RSL, NCB, and CIB protocols. */
 #else
 	uint64_t uctl_rst                     : 1;
 	uint64_t uahc_rst                     : 1;
@@ -5650,13 +6106,13 @@ union cvmx_usbdrdx_uctl_ctl {
 	} s;
 	struct cvmx_usbdrdx_uctl_ctl_s        cn70xx;
 	struct cvmx_usbdrdx_uctl_ctl_s        cn70xxp1;
+	struct cvmx_usbdrdx_uctl_ctl_s        cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_ctl cvmx_usbdrdx_uctl_ctl_t;
 
 /**
  * cvmx_usbdrd#_uctl_ecc
  *
- * Accessible by: only when H_CLKDIV_EN.
  * This register can be used to disable ECC correction, insert ECC errors, and debug ECC
  * failures.
  * * The ECC_ERR* fields are captured when there are no outstanding ECC errors indicated in
@@ -5673,6 +6129,8 @@ typedef union cvmx_usbdrdx_uctl_ctl cvmx_usbdrdx_uctl_ctl_t;
  * 0x2 = SBE on bit[1].
  * 0x3 = DBE on bit[1:0].
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_ecc {
@@ -5683,6 +6141,43 @@ union cvmx_usbdrdx_uctl_ecc {
 	uint64_t ecc_err_source               : 4;  /**< Source of ECC error, see USBDRD_UCTL_ECC_ERR_SOURCE_E. */
 	uint64_t ecc_err_syndrome             : 8;  /**< Syndrome bits of the ECC error. */
 	uint64_t ecc_err_address              : 16; /**< RAM address of the ECC error. */
+	uint64_t reserved_21_31               : 11;
+	uint64_t uctl_xm_r_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uctl_xm_r_ecc_cor_dis        : 1;  /**< Enables ECC correction on UCTL AxiMaster read-data FIFO. */
+	uint64_t uctl_xm_w_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uctl_xm_w_ecc_cor_dis        : 1;  /**< Enables ECC correction on UCTL AxiMaster write-data FIFO. */
+	uint64_t reserved_9_14                : 6;
+	uint64_t uahc_ram2_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram2_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC RxFIFO RAMs (RAM2). */
+	uint64_t uahc_ram1_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram1_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC TxFIFO RAMs (RAM1). */
+	uint64_t uahc_ram0_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram0_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC Desc/Reg cache (RAM0). */
+#else
+	uint64_t uahc_ram0_ecc_cor_dis        : 1;
+	uint64_t uahc_ram0_ecc_flip_synd      : 2;
+	uint64_t uahc_ram1_ecc_cor_dis        : 1;
+	uint64_t uahc_ram1_ecc_flip_synd      : 2;
+	uint64_t uahc_ram2_ecc_cor_dis        : 1;
+	uint64_t uahc_ram2_ecc_flip_synd      : 2;
+	uint64_t reserved_9_14                : 6;
+	uint64_t uctl_xm_w_ecc_cor_dis        : 1;
+	uint64_t uctl_xm_w_ecc_flip_synd      : 2;
+	uint64_t uctl_xm_r_ecc_cor_dis        : 1;
+	uint64_t uctl_xm_r_ecc_flip_synd      : 2;
+	uint64_t reserved_21_31               : 11;
+	uint64_t ecc_err_address              : 16;
+	uint64_t ecc_err_syndrome             : 8;
+	uint64_t ecc_err_source               : 4;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_ecc_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t ecc_err_source               : 4;  /**< Source of ECC error, see USBDRD_UCTL_ECC_ERR_SOURCE_E. */
+	uint64_t ecc_err_syndrome             : 8;  /**< Syndrome bits of the ECC error. */
+	uint64_t ecc_err_address              : 16; /**< RAM address of the ECC error. */
 	uint64_t reserved_9_31                : 23;
 	uint64_t uahc_ram2_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
 	uint64_t uahc_ram2_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC RxFIFO RAMs (RAM2). */
@@ -5703,20 +6198,20 @@ union cvmx_usbdrdx_uctl_ecc {
 	uint64_t ecc_err_source               : 4;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} s;
-	struct cvmx_usbdrdx_uctl_ecc_s        cn70xx;
-	struct cvmx_usbdrdx_uctl_ecc_s        cn70xxp1;
+	} cn70xx;
+	struct cvmx_usbdrdx_uctl_ecc_cn70xx   cn70xxp1;
+	struct cvmx_usbdrdx_uctl_ecc_s        cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_ecc cvmx_usbdrdx_uctl_ecc_t;
 
 /**
  * cvmx_usbdrd#_uctl_host_cfg
  *
- * Accessible by: only when H_CLKDIV_EN.
- *
  * This register allows configuration of various host controller (UAHC) features. Most of these
  * are strap signals and should be modified only while the controller is not running.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_host_cfg {
@@ -5785,6 +6280,7 @@ union cvmx_usbdrdx_uctl_host_cfg {
 	} s;
 	struct cvmx_usbdrdx_uctl_host_cfg_s   cn70xx;
 	struct cvmx_usbdrdx_uctl_host_cfg_s   cn70xxp1;
+	struct cvmx_usbdrdx_uctl_host_cfg_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_host_cfg cvmx_usbdrdx_uctl_host_cfg_t;
 
@@ -5801,6 +6297,52 @@ union cvmx_usbdrdx_uctl_intstat {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uctl_intstat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_30_63               : 34;
+	uint64_t xm_r_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_r_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_w_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t xm_w_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t reserved_22_25               : 4;
+	uint64_t ram2_dbe                     : 1;  /**< Detected double-bit error on the UAHC RxFIFO RAMs (RAM2). */
+	uint64_t ram2_sbe                     : 1;  /**< Detected single-bit error on the UAHC RxFIFO RAMs (RAM2). */
+	uint64_t ram1_dbe                     : 1;  /**< Detected double-bit error on the UAHC TxFIFO RAMs (RAM1). */
+	uint64_t ram1_sbe                     : 1;  /**< Detected single-bit error on the UAHC TxFIFO RAMs (RAM1). */
+	uint64_t ram0_dbe                     : 1;  /**< Detected double-bit error on the UAHC Desc/Reg Cache (RAM0). */
+	uint64_t ram0_sbe                     : 1;  /**< Detected single-bit error on the UAHC Desc/Reg Cache (RAM0). */
+	uint64_t reserved_3_15                : 13;
+	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. Error information is logged in
+                                                         USBDRD()_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates
+                                                         the assumptions made by the AXI-to-IOI shim. Such scenarios include: illegal length/size
+                                                         combinations and address out-of-bounds.
+                                                         For more information on exact failures, see the description in
+                                                         USBDRD()_UCTL_SHIM_CFG[XM_BAD_DMA_TYPE]. The hardware does not translate the request
+                                                         correctly
+                                                         and results may violate IOI protocols. */
+	uint64_t xs_ncb_oob                   : 1;  /**< Detected out-of-bound register access to UAHC over IOI. The UAHC defines 1MB of register
+                                                         space, starting at offset 0x0. Any accesses outside of this register space cause this bit
+                                                         to be set to 1. Error information is logged in USBDRD()_UCTL_SHIM_CFG[XS_NCB_OOB_*]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t xs_ncb_oob                   : 1;
+	uint64_t xm_bad_dma                   : 1;
+	uint64_t reserved_3_15                : 13;
+	uint64_t ram0_sbe                     : 1;
+	uint64_t ram0_dbe                     : 1;
+	uint64_t ram1_sbe                     : 1;
+	uint64_t ram1_dbe                     : 1;
+	uint64_t ram2_sbe                     : 1;
+	uint64_t ram2_dbe                     : 1;
+	uint64_t reserved_22_25               : 4;
+	uint64_t xm_w_sbe                     : 1;
+	uint64_t xm_w_dbe                     : 1;
+	uint64_t xm_r_sbe                     : 1;
+	uint64_t xm_r_dbe                     : 1;
+	uint64_t reserved_30_63               : 34;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_intstat_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_22_63               : 42;
 	uint64_t ram2_dbe                     : 1;  /**< Detected double-bit error on the UAHC RxFIFO RAMs (RAM2). */
 	uint64_t ram2_sbe                     : 1;  /**< Detected single-bit error on the UAHC RxFIFO RAMs (RAM2). */
@@ -5834,16 +6376,16 @@ union cvmx_usbdrdx_uctl_intstat {
 	uint64_t ram2_dbe                     : 1;
 	uint64_t reserved_22_63               : 42;
 #endif
-	} s;
-	struct cvmx_usbdrdx_uctl_intstat_s    cn70xx;
-	struct cvmx_usbdrdx_uctl_intstat_s    cn70xxp1;
+	} cn70xx;
+	struct cvmx_usbdrdx_uctl_intstat_cn70xx cn70xxp1;
+	struct cvmx_usbdrdx_uctl_intstat_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_intstat cvmx_usbdrdx_uctl_intstat_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cfg_hs
  *
- * This register controls configuration and test controls for the HS port 0 PHY.
+ * This register controls configuration and test controls for the high-speed port 0 PHY.
  *
  * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
  *
@@ -5874,10 +6416,10 @@ union cvmx_usbdrdx_uctl_portx_cfg_hs {
 	uint64_t reserved_46_47               : 2;
 	uint64_t tx_hs_xv_tune                : 2;  /**< Transmitter high-speed crossover adjustment. This bus adjusts the voltage at which the DP0
                                                          and DM0 signals cross while transmitting in high-speed mode.
-                                                         0x3 = default setting.
-                                                         0x2 = +15 mV.
+                                                         0x0 = reserved.
                                                          0x1 = -15 mV.
-                                                         0x0 = reserved. */
+                                                         0x2 = +15 mV.
+                                                         0x3 = default setting. */
 	uint64_t tx_preemp_amp_tune           : 2;  /**< High-speed transmitter pre-emphasis current control. Controls the amount of current
                                                          sourced to DP0 and DM0 after a J-to-K or K-to-J transition. The high-speed transmitter
                                                          preemphasis current is defined in terms of unit amounts. One unit amount is approximately
@@ -5960,15 +6502,17 @@ union cvmx_usbdrdx_uctl_portx_cfg_hs {
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cfg_hs cvmx_usbdrdx_uctl_portx_cfg_hs_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cfg_ss
  *
- * Accessible by: only when H_CLKDIV_EN.
  * This register controls configuration and test controls for the SS port 0 PHY.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  *
  * INTERNAL: All these settings are for high-speed functionality, connect on DVDD power domain.
@@ -6093,17 +6637,18 @@ union cvmx_usbdrdx_uctl_portx_cfg_ss {
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cfg_ss cvmx_usbdrdx_uctl_portx_cfg_ss_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cr_dbg_cfg
  *
- * Accessible by: only when H_CLKDIV_EN
- *
  * This register allows indirect access to the configuration and test controls for the port 0
  * PHY.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  *
  * INTERNAL: (In body of HRM)
@@ -6184,16 +6729,18 @@ union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg {
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cr_dbg_status
  *
- * Accessible by: only when H_CLKDIV_EN.
  * This register allows indirect access to the configuration and test controls for the port 0
  * PHY.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_portx_cr_dbg_status {
@@ -6213,18 +6760,20 @@ union cvmx_usbdrdx_uctl_portx_cr_dbg_status {
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cr_dbg_status cvmx_usbdrdx_uctl_portx_cr_dbg_status_t;
 
 /**
  * cvmx_usbdrd#_uctl_shim_cfg
  *
- * Accessible by: only when H_CLKDIV_EN.
  * This register allows configuration of various shim (UCTL) features. The fields XS_NCB_OOB_*
  * are captured when there are no outstanding OOB errors indicated in INTSTAT and a new OOB error
  * arrives. The fields XS_BAD_DMA_* are captured when there are no outstanding DMA errors
  * indicated in INTSTAT and a new DMA error arrives.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_shim_cfg {
@@ -6237,6 +6786,46 @@ union cvmx_usbdrdx_uctl_shim_cfg {
 	uint64_t xs_ncb_oob_osrc              : 12; /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB
                                                          error.
                                                          <59:58> = chipID.
+                                                         <57> = Request source: 0 = core, 1 = IOI-device.
+                                                         <56:51> = Core/IOI-device number. Note that for IOI devices, <56> is always 0.
+                                                         <50:48> = SubID. */
+	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
+                                                         0 = read error log, 1 = write error log */
+	uint64_t reserved_44_46               : 3;
+	uint64_t xm_bad_dma_type              : 4;  /**< ErrType error log for bad DMA access from UAHC. Encodes the type of error encountered
+                                                         (error largest encoded value has priority). See USBDRD_UCTL_XM_BAD_DMA_TYPE_E. */
+	uint64_t reserved_14_39               : 26;
+	uint64_t dma_read_cmd                 : 2;  /**< Selects the IOI read command used by DMA accesses. See USBDRD_UCTL_DMA_READ_CMD_E. */
+	uint64_t reserved_11_11               : 1;
+	uint64_t dma_write_cmd                : 1;  /**< Selects the NCB write command used by DMA accesses. See UCTL_DMA_WRITE_CMD_E. */
+	uint64_t dma_endian_mode              : 2;  /**< Selects the endian format for DMA accesses to the L2C. See USBDRD_UCTL_ENDIAN_MODE_E. */
+	uint64_t reserved_2_7                 : 6;
+	uint64_t csr_endian_mode              : 2;  /**< Selects the endian format for IOI CSR accesses to the UAHC. Note that when UAHC CSRs are
+                                                         accessed via RSL, they are returned as big-endian. See USBDRD_UCTL_ENDIAN_MODE_E. */
+#else
+	uint64_t csr_endian_mode              : 2;
+	uint64_t reserved_2_7                 : 6;
+	uint64_t dma_endian_mode              : 2;
+	uint64_t dma_write_cmd                : 1;
+	uint64_t reserved_11_11               : 1;
+	uint64_t dma_read_cmd                 : 2;
+	uint64_t reserved_14_39               : 26;
+	uint64_t xm_bad_dma_type              : 4;
+	uint64_t reserved_44_46               : 3;
+	uint64_t xm_bad_dma_wrn               : 1;
+	uint64_t xs_ncb_oob_osrc              : 12;
+	uint64_t reserved_60_62               : 3;
+	uint64_t xs_ncb_oob_wrn               : 1;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_shim_cfg_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t xs_ncb_oob_wrn               : 1;  /**< Read/write error log for out-of-bound UAHC register access.
+                                                         0 = read, 1 = write. */
+	uint64_t reserved_60_62               : 3;
+	uint64_t xs_ncb_oob_osrc              : 12; /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB
+                                                         error.
+                                                         <59:58> = chipID.
                                                          <57> = Request source: 0 = core, 1 = NCB-device.
                                                          <56:51> = Core/NCB-device number. Note that for NCB devices, <56> is always 0.
                                                          <50:48> = SubID. */
@@ -6266,9 +6855,9 @@ union cvmx_usbdrdx_uctl_shim_cfg {
 	uint64_t reserved_60_62               : 3;
 	uint64_t xs_ncb_oob_wrn               : 1;
 #endif
-	} s;
-	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn70xx;
-	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn70xxp1;
+	} cn70xx;
+	struct cvmx_usbdrdx_uctl_shim_cfg_cn70xx cn70xxp1;
+	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_shim_cfg cvmx_usbdrdx_uctl_shim_cfg_t;
 
@@ -6294,6 +6883,27 @@ union cvmx_usbdrdx_uctl_spare0 {
 typedef union cvmx_usbdrdx_uctl_spare0 cvmx_usbdrdx_uctl_spare0_t;
 
 /**
+ * cvmx_usbdrd#_uctl_spare0_eco
+ *
+ * This register is a spare register. This register can be reset by IOI reset.
+ *
+ */
+union cvmx_usbdrdx_uctl_spare0_eco {
+	uint64_t u64;
+	struct cvmx_usbdrdx_uctl_spare0_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_spare0_eco_s cn73xx;
+};
+typedef union cvmx_usbdrdx_uctl_spare0_eco cvmx_usbdrdx_uctl_spare0_eco_t;
+
+/**
  * cvmx_usbdrd#_uctl_spare1
  *
  * Accessible by: only when H_CLKDIV_EN.
@@ -6314,4 +6924,26 @@ union cvmx_usbdrdx_uctl_spare1 {
 };
 typedef union cvmx_usbdrdx_uctl_spare1 cvmx_usbdrdx_uctl_spare1_t;
 
+/**
+ * cvmx_usbdrd#_uctl_spare1_eco
+ *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
+ */
+union cvmx_usbdrdx_uctl_spare1_eco {
+	uint64_t u64;
+	struct cvmx_usbdrdx_uctl_spare1_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_spare1_eco_s cn73xx;
+};
+typedef union cvmx_usbdrdx_uctl_spare1_eco cvmx_usbdrdx_uctl_spare1_eco_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
index d98e97a..070f2c63 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
@@ -53,349 +53,349 @@
 #define __CVMX_USBNX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_BIST_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800680007F8ull) + ((block_id) & 1) * 0x10000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800680007F8ull) + ((offset) & 1) * 0x10000000ull;
 }
 #else
-#define CVMX_USBNX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800680007F8ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800680007F8ull) + ((offset) & 1) * 0x10000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_CLK_CTL(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_CLK_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_CLK_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((block_id) & 1) * 0x10000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_CLK_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((offset) & 1) * 0x10000000ull;
 }
 #else
-#define CVMX_USBNX_CLK_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_CLK_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((offset) & 1) * 0x10000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_CTL_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_CTL_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_CTL_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000800ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_CTL_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000800ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_CTL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000800ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_CTL_STATUS(offset) (CVMX_ADD_IO_SEG(0x00016F0000000800ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_INB_CHN0(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_INB_CHN0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000818ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000818ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_INB_CHN0(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000818ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN0(offset) (CVMX_ADD_IO_SEG(0x00016F0000000818ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_INB_CHN1(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_INB_CHN1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000820ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000820ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_INB_CHN1(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000820ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN1(offset) (CVMX_ADD_IO_SEG(0x00016F0000000820ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_INB_CHN2(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_INB_CHN2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000828ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000828ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_INB_CHN2(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000828ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN2(offset) (CVMX_ADD_IO_SEG(0x00016F0000000828ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_INB_CHN3(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_INB_CHN3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000830ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000830ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_INB_CHN3(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000830ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN3(offset) (CVMX_ADD_IO_SEG(0x00016F0000000830ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_INB_CHN4(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_INB_CHN4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000838ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000838ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_INB_CHN4(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000838ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN4(offset) (CVMX_ADD_IO_SEG(0x00016F0000000838ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_INB_CHN5(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_INB_CHN5(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN5(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000840ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN5(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000840ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_INB_CHN5(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000840ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN5(offset) (CVMX_ADD_IO_SEG(0x00016F0000000840ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_INB_CHN6(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_INB_CHN6(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN6(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000848ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN6(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000848ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_INB_CHN6(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000848ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN6(offset) (CVMX_ADD_IO_SEG(0x00016F0000000848ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_INB_CHN7(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_INB_CHN7(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN7(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000850ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_INB_CHN7(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000850ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_INB_CHN7(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000850ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_INB_CHN7(offset) (CVMX_ADD_IO_SEG(0x00016F0000000850ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN0(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN0(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000858ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000858ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_OUTB_CHN0(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000858ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN0(offset) (CVMX_ADD_IO_SEG(0x00016F0000000858ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN1(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000860ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000860ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_OUTB_CHN1(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000860ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN1(offset) (CVMX_ADD_IO_SEG(0x00016F0000000860ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN2(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000868ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000868ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_OUTB_CHN2(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000868ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN2(offset) (CVMX_ADD_IO_SEG(0x00016F0000000868ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN3(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN3(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000870ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000870ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_OUTB_CHN3(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000870ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN3(offset) (CVMX_ADD_IO_SEG(0x00016F0000000870ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN4(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN4(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000878ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000878ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_OUTB_CHN4(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000878ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN4(offset) (CVMX_ADD_IO_SEG(0x00016F0000000878ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN5(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN5(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN5(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000880ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN5(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000880ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_OUTB_CHN5(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000880ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN5(offset) (CVMX_ADD_IO_SEG(0x00016F0000000880ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN6(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN6(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN6(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000888ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN6(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000888ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_OUTB_CHN6(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000888ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN6(offset) (CVMX_ADD_IO_SEG(0x00016F0000000888ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN7(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA0_OUTB_CHN7(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN7(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000890ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA0_OUTB_CHN7(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000890ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA0_OUTB_CHN7(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000890ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA0_OUTB_CHN7(offset) (CVMX_ADD_IO_SEG(0x00016F0000000890ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_DMA_TEST(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_DMA_TEST(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_DMA_TEST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016F0000000808ull) + ((block_id) & 1) * 0x100000000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_DMA_TEST(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00016F0000000808ull) + ((offset) & 1) * 0x100000000000ull;
 }
 #else
-#define CVMX_USBNX_DMA_TEST(block_id) (CVMX_ADD_IO_SEG(0x00016F0000000808ull) + ((block_id) & 1) * 0x100000000000ull)
+#define CVMX_USBNX_DMA_TEST(offset) (CVMX_ADD_IO_SEG(0x00016F0000000808ull) + ((offset) & 1) * 0x100000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_INT_ENB(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_INT_ENB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_INT_ENB(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id) & 1) * 0x10000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_INT_ENB(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((offset) & 1) * 0x10000000ull;
 }
 #else
-#define CVMX_USBNX_INT_ENB(block_id) (CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_INT_ENB(offset) (CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((offset) & 1) * 0x10000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_INT_SUM(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_INT_SUM(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_INT_SUM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id) & 1) * 0x10000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_INT_SUM(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((offset) & 1) * 0x10000000ull;
 }
 #else
-#define CVMX_USBNX_INT_SUM(block_id) (CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_INT_SUM(offset) (CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((offset) & 1) * 0x10000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_USBNX_USBP_CTL_STATUS(unsigned long block_id)
+static inline uint64_t CVMX_USBNX_USBP_CTL_STATUS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((block_id == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((block_id <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_USBNX_USBP_CTL_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000018ull) + ((block_id) & 1) * 0x10000000ull;
+	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset == 0)))))
+		cvmx_warn("CVMX_USBNX_USBP_CTL_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180068000018ull) + ((offset) & 1) * 0x10000000ull;
 }
 #else
-#define CVMX_USBNX_USBP_CTL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180068000018ull) + ((block_id) & 1) * 0x10000000ull)
+#define CVMX_USBNX_USBP_CTL_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180068000018ull) + ((offset) & 1) * 0x10000000ull)
 #endif
 
 /**
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index a9a9d84..fcdfea1 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -176,8 +176,6 @@ typedef enum {
 				/**<  On of the BGX is used for MIX */
 	OCTEON_FEATURE_HNA,
 				/**<  Octeon has HNA */
-	OCTEON_FEATURE_OCX,
-				/**<  Octeon has OCX */
 	OCTEON_MAX_FEATURE
 } octeon_feature_t;
 
@@ -198,12 +196,13 @@ static inline int octeon_has_feature_OCTEON_FEATURE_ZIP(void)
 
 static inline int octeon_has_feature_OCTEON_FEATURE_ZIP3(void)
 {
-	return (OCTEON_IS_MODEL(OCTEON_CN78XX));
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+	     || OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_BCH(void)
 {
-	return OCTEON_IS_MODEL(OCTEON_CN70XX);
+	return (OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_CRYPTO(void)
@@ -325,7 +324,7 @@ static inline int octeon_has_feature_OCTEON_FEATURE_HFA(void)
 
 static inline int octeon_has_feature_OCTEON_FEATURE_HNA(void)
 {
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return !cvmx_fuse_read(134);
 	else
 		return 0;
@@ -353,6 +352,7 @@ static inline int octeon_has_feature_OCTEON_FEATURE_NPEI(void)
 static inline int octeon_has_feature_OCTEON_FEATURE_PKND(void)
 {
 	return OCTEON_IS_MODEL(OCTEON_CN68XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN78XX);
 }
 
@@ -368,12 +368,13 @@ static inline int octeon_has_feature_OCTEON_FEATURE_CIU2(void)
 
 static inline int octeon_has_feature_OCTEON_FEATURE_CIU3(void)
 {
-	return (OCTEON_IS_MODEL(OCTEON_CN78XX));
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_FPA3(void)
 {
-	return (OCTEON_IS_MODEL(OCTEON_CN78XX));
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_NAND(void)
@@ -439,12 +440,15 @@ static inline int octeon_has_feature_OCTEON_FEATURE_MULTICAST_TIMER(void)
 
 static inline int octeon_has_feature_OCTEON_FEATURE_MULTINODE(void)
 {
-	return OCTEON_IS_MODEL(OCTEON_CN78XX);
+	return (!OCTEON_IS_MODEL(OCTEON_CN76XX)
+		&& OCTEON_IS_MODEL(OCTEON_CN78XX)
+		&& !OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_CN78XX_WQE(void)
 {
-	return (OCTEON_IS_MODEL(OCTEON_CN78XX));
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_SPI(void)
@@ -459,12 +463,14 @@ static inline int octeon_has_feature_OCTEON_FEATURE_SPI(void)
 
 static inline int octeon_has_feature_OCTEON_FEATURE_PKI(void)
 {
-	return OCTEON_IS_MODEL(OCTEON_CN78XX);
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_PKO3(void)
 {
-	return OCTEON_IS_MODEL(OCTEON_CN78XX);
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_OCLA(void)
@@ -474,23 +480,20 @@ static inline int octeon_has_feature_OCTEON_FEATURE_OCLA(void)
 
 static inline int octeon_has_feature_OCTEON_FEATURE_FAU(void)
 {
-	return !OCTEON_IS_MODEL(OCTEON_CN78XX);
+	return (!OCTEON_IS_MODEL(OCTEON_CN78XX)
+		&& !OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_BGX(void)
 {
-	return OCTEON_IS_MODEL(OCTEON_CN78XX);
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_BGX_MIX(void)
 {
-	return OCTEON_IS_MODEL(OCTEON_CN78XX);
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
-static inline int octeon_has_feature_OCTEON_FEATURE_OCX(void)
-{
-	return OCTEON_IS_MODEL(OCTEON_CN78XX) && !OCTEON_IS_MODEL(OCTEON_CN76XX);
-}
 /*
  * bit map for octeon features
  */
-- 
2.6.2

