From 150814515673d575fca98ba32e27756215c1fcc9 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 5 Mar 2015 14:25:18 -0800
Subject: [PATCH 093/184] netdev: octeon-bgx: Fix race conditions in status
 polling work.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 4b4fec9cc41893991c9cc63c4a1e5a7ea8922c3e
Description:

All locking is safe to do with a mutex, use that to make sure we can
cleanly shut down and restart the status polling work.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-port.c | 24 +++++++++++++++++-------
 1 file changed, 17 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 75167be..4c79c7f 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -54,11 +54,12 @@ struct bgx_port_priv {
 	struct phy_device *phydev;
 	struct device_node *phy_np;
 	struct net_device *netdev;
-	spinlock_t lock;
+	struct mutex lock;
 	unsigned int last_duplex;
 	unsigned int last_link;
 	unsigned int last_speed;
 	struct delayed_work dwork;
+	bool work_queued;
 };
 
 static struct workqueue_struct *check_state_wq;
@@ -227,9 +228,8 @@ static void bgx_port_adjust_link(struct net_device *netdev)
 	struct bgx_port_priv *p = bgx_port_netdev2priv(netdev);
 	int link_changed = 0;
 	unsigned int link, speed, duplex;
-	unsigned long flags;
 
-	spin_lock_irqsave(&p->lock, flags);
+	mutex_lock(&p->lock);
 
 	if (!p->phydev->link && p->last_link)
 		link_changed = -1;
@@ -245,7 +245,7 @@ static void bgx_port_adjust_link(struct net_device *netdev)
 	speed = p->last_speed = p->phydev->speed;
 	duplex = p->last_duplex = p->phydev->duplex;
 
-	spin_unlock_irqrestore(&p->lock, flags);
+	mutex_unlock(&p->lock);
 
 	if (link_changed != 0) {
 		cvmx_helper_link_info_t link_info;
@@ -289,7 +289,10 @@ static void bgx_port_check_state(struct work_struct *work)
 			pr_info("%s: Link is down\n", priv->netdev->name);
 	}
 
-	queue_delayed_work(check_state_wq, &priv->dwork, HZ);
+	mutex_lock(&priv->lock);
+	if (priv->work_queued)
+		queue_delayed_work(check_state_wq, &priv->dwork, HZ);
+	mutex_unlock(&priv->lock);
 }
 
 int bgx_port_enable(struct net_device *netdev)
@@ -376,8 +379,11 @@ int bgx_port_enable(struct net_device *netdev)
 			return -ENOMEM;
 
 		if(priv->dwork.work.func != bgx_port_check_state) {
+			mutex_lock(&priv->lock);
 			INIT_DELAYED_WORK(&priv->dwork, bgx_port_check_state);
 			queue_delayed_work(check_state_wq, &priv->dwork, 0);
+			priv->work_queued = true;
+			mutex_unlock(&priv->lock);
 		}
 		pr_info("%s: Link is not ready\n", netdev->name);
 
@@ -413,8 +419,12 @@ int bgx_port_disable(struct net_device *netdev)
 	priv->last_link = 0;
 	cvmx_helper_link_set(priv->ipd_port, link_info);
 
-	if (priv->phy_np == NULL)
+	mutex_lock(&priv->lock);
+	if (priv->work_queued) {
 		cancel_delayed_work_sync(&priv->dwork);
+		priv->work_queued = false;
+	}
+	mutex_unlock(&priv->lock);
 
 	return 0;
 }
@@ -488,7 +498,7 @@ static int bgx_port_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	spin_lock_init(&priv->lock);
+	mutex_init(&priv->lock);
 	priv->numa_node = numa_node;
 	priv->bgx_interface = (addr >> 24) & 0xf;
 	priv->index = index;
-- 
1.9.1

