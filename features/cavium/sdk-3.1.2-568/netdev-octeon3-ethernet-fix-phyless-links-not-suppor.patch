From 076652fa07d8e0118890068260251e6978a9da55 Mon Sep 17 00:00:00 2001
From: Catalin Enache <catalin.enache@windriver.com>
Date: Thu, 3 May 2018 14:24:46 +0300
Subject: [PATCH] netdev: octeon3-ethernet: fix phyless links not supported
 issue

This commit was validated by Cavium Technical Support Team.

The changes are taken from:
- sdk-3.1.2-p9.1: changes in drivers/net/ethernet/octeon/octeon-bgx-port.c
- sdk-3.1.2-p12: changes in arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c

It fixes the following issue:

For some SGMII link, modify the device-tree node "ethernet-mac" to have:
cavium,sgmii-mac-phy-mode = "1";
cavium,sgmii-mac-1000x-mode = "1";
and remove the phy-handle and the corresponding phy in the device-tree.

Configure the corresponding interface:
"eth2: Link is not ready" message is displayed

The interface is not working

Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |   20 +++++++++-----------
 drivers/net/ethernet/octeon/octeon-bgx-port.c      |   10 +++++++---
 2 files changed, 16 insertions(+), 14 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 8158d41..1c379e1 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -613,6 +613,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link(int xiface, int index)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
+	int autoneg = 0;
 
 	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
@@ -638,23 +639,20 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link(int xiface, int index)
 
 	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
 
-	if (cvmx_helper_get_port_phy_present(xiface, index)) {
-	/* Write GMP_PCS_MR*_CONTROL[RST_AN]=1 to ensure a fresh SGMII
-	   negotiation starts. */
 	gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, xi.interface));
-	gmp_control.s.rst_an = 1;
-		gmp_control.s.an_en = (cmr_config.s.lmac_type != 5) &&
-			cvmx_helper_get_port_autonegotiation(xiface, index);
+	if (cvmx_helper_get_port_phy_present(xiface, index)) {
 	gmp_control.s.pwr_dn = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, xi.interface), gmp_control.u64);
 	} else {
-		gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, xi.interface));
 		gmp_control.s.spdmsb = 1;
 		gmp_control.s.spdlsb = 0;
-		gmp_control.s.an_en = 0;
 		gmp_control.s.pwr_dn = 0;
-		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, xi.interface), gmp_control.u64);
 	}
+	/* Write GMP_PCS_MR*_CONTROL[RST_AN]=1 to ensure a fresh SGMII
+		negotiation starts. */
+	autoneg = cvmx_helper_get_port_autonegotiation(xiface, index);
+	gmp_control.s.rst_an = 1;
+	gmp_control.s.an_en = (cmr_config.s.lmac_type != 5) && autoneg;
+	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, xi.interface), gmp_control.u64);
 
 	phy_mode = cvmx_helper_get_mac_phy_mode(xiface, index);
 	mode_1000x = cvmx_helper_get_1000x_mode(xiface, index);
@@ -664,7 +662,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link(int xiface, int index)
 	gmp_misc_ctl.s.mode = mode_1000x;
 	cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, xi.interface), gmp_misc_ctl.u64);
 
-	if (phy_mode || !cvmx_helper_get_port_autonegotiation(xiface, index))
+	if (phy_mode || !autoneg)
 		/* In PHY mode we can't query the link status so we just
 		   assume that the link is up */
 		return 0;
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 89e44a5..44765f2 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -301,9 +301,6 @@ int bgx_port_enable(struct net_device *netdev)
 	union cvmx_bgxx_cmrx_config cfg;
 	struct bgx_port_priv *priv = bgx_port_netdev2priv(netdev);
 
-	cvmx_helper_set_1000x_mode(priv->xiface, priv->index, false);
-	cvmx_helper_set_mac_phy_mode(priv->xiface, priv->index, false);
-
 	cfg.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface));
 	if (cfg.s.lmac_type == 0) {
 		/* 1G */
@@ -537,6 +534,13 @@ static int bgx_port_probe(struct platform_device *pdev)
 	if (mac)
 		priv->mac_addr = mac;
 
+	cvmx_helper_set_mac_phy_mode(priv->xiface, priv->index,
+							of_get_property(pdev->dev.of_node,
+									"cavium,sgmii-mac-phy-mode", NULL));
+	cvmx_helper_set_1000x_mode(priv->xiface, priv->index,
+							of_get_property(pdev->dev.of_node,
+									"cavium,sgmii-mac-1000x-mode", NULL));
+
 	priv->phy_np = of_parse_phandle(pdev->dev.of_node, "phy-handle", 0);
 
 	if (priv->phy_np == NULL)
-- 
1.7.5.4

