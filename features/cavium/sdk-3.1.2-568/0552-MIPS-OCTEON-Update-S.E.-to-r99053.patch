From a4eab610dde24442e48d5542e280ba5586c7c8b3 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sat, 22 Feb 2014 13:46:59 -0800
Subject: [PATCH 552/974] MIPS: OCTEON: Update S.E. to r99053.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bch.c       | 43 +---------------
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |  2 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      | 60 ++++++++++++++--------
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       | 40 +++++----------
 arch/mips/include/asm/octeon/cvmx-pko3.h           |  2 +-
 5 files changed, 56 insertions(+), 91 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index 5e2b3f4..c90a78d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -53,11 +53,7 @@
 # include <asm/octeon/cvmx-fpa1.h>
 # include <asm/octeon/cvmx-helper-fpa.h>
 # include <asm/octeon/cvmx-cmd-queue.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-
 #elif defined(CVMX_BUILD_FOR_UBOOT)
-
 # include <common.h>
 # include <asm/arch/cvmx.h>
 # include <asm/arch/cvmx-bch-defs.h>
@@ -90,7 +86,6 @@ CVMX_SHARED cvmx_bch_app_config_t bch_config = {
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 extern int cvm_oct_mem_fill_fpa(int pool, int elements);
 extern int cvm_oct_alloc_fpa_pool(int pool, int size);
-static uint8_t *bounce_buff;
 #endif
 
 /**
@@ -108,7 +103,6 @@ int cvmx_bch_initialize(void)
 
 	/* Initialize FPA pool for BCH pool buffers */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	int i;
 	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
 	bch_pool_size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE;
 
@@ -121,11 +115,7 @@ int cvmx_bch_initialize(void)
 		pr_err("cvm_oct_alloc_fpa_pool(%d, %lld)\n", bch_pool, bch_pool_size);
 		return -ENOMEM;
 	}
-
-	for (i = 0; i < 16; i++) {
-		cvmx_fpa1_free(kmalloc(bch_pool_size, GFP_KERNEL), bch_pool, 0);
-	}
-	bounce_buff = cvmx_fpa1_alloc(bch_pool);
+	cvm_oct_mem_fill_fpa(bch_pool, 128);
 #else
 	bch_pool = (int)cvmx_fpa_get_bch_pool();
 	bch_pool_size = cvmx_fpa_get_bch_pool_block_size();
@@ -180,7 +170,6 @@ EXPORT_SYMBOL(cvmx_bch_initialize);
 int cvmx_bch_shutdown(void)
 {
 	cvmx_bch_ctl_t bch_ctl;
-	int bch_pool;
 
 	debug("%s: ENTER\n", __func__);
 	bch_ctl.u64 = cvmx_read_csr(CVMX_BCH_CTL);
@@ -188,26 +177,8 @@ int cvmx_bch_shutdown(void)
 	cvmx_write_csr(CVMX_BCH_CTL, bch_ctl.u64);
 	cvmx_wait(4);
 
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
-#else
-	bch_pool = (int)cvmx_fpa_get_bch_pool();
-#endif
 	cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_BCH);
 
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	/* FIXME: BCH cleanup in SE : AJ */
-	{
-		int i;
-		for (i = 0; i < 16; i++) {
-			kfree(cvmx_fpa1_alloc(bch_pool));
-		}
-		cvmx_fpa1_free(bounce_buff, bch_pool, 0);
-	}
-#else
-	cvmx_fpa_shutdown_pool(bch_pool);
-#endif
-	/* AJ: Fix for FPA3 */
 	return 0;
 }
 EXPORT_SYMBOL(cvmx_bch_shutdown);
@@ -257,14 +228,6 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 
 	debug("%s(%p, %u, %u, %p, %p) ENTRY\n", __func__, block, block_size,
 	      ecc_level, ecc, response);
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	/* there was a problem when the first argument is used directly
-	 * despite of the fact it was 8-byte aligned (maybe not proper
-	 * cvmx_prt_to_phys), so we copy data to dedicated 'bounce_buff'
-	 * and set command.s.iword.prt to cvmx_ptr_to_phys((void *)bounce_buff)
-	 */
-	memcpy(bounce_buff, block, block_size);
-#endif
 	memset(&result, 0, sizeof(result));
 	memset(&command, 0, sizeof(command));
 	command.s.cword.ecc_gen = CVMX_BCH_INST_ECC_GENERATION;
@@ -272,11 +235,7 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 	command.s.cword.size = block_size;
 
 	command.s.oword.ptr = cvmx_ptr_to_phys(ecc);
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	command.s.iword.ptr = cvmx_ptr_to_phys((void *)bounce_buff);
-#else
 	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);
-#endif
 	command.s.resp.ptr = cvmx_ptr_to_phys((void *)response);
 	debug("Command: cword: 0x%llx, oword: 0x%llx, iword: 0x%llx, resp: 0x%llx\n",
 	      command.u64[0], command.u64[1], command.u64[2], command.u64[3]);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index b1c71ff..beccd5f 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -320,7 +320,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init(int xiface, int num_ports)
 
 		/* Set TX Threshold */
 		gmi_tx_thresh.u64 = 0;
-		gmi_tx_thresh.s.cnt = 0x1ff; /* has 4 ports */
+		gmi_tx_thresh.s.cnt = 0x20;
 		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_THRESH(index, interface),
 					gmi_tx_thresh.u64);
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 74ad10c..34148f4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -707,61 +707,64 @@ static int cvmx_pko_setup_macs(int node)
 	}
 
 
-	/* Setup PKO MCI0/MCI1 credits */
+	/* Setup PKO MCI0/MCI1/SKID credits */
 	for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
 		cvmx_pko_mci0_max_credx_t pko_mci0_max_cred;
 		cvmx_pko_mci1_max_credx_t pko_mci1_max_cred;
-		unsigned credit, mac_credit;
-		unsigned fifo_req_size, fifo_size;
+		cvmx_pko_macx_cfg_t pko_mac_cfg;
+		unsigned fifo_credit, mac_credit, skid_credit;
+		unsigned pko_fifo_cnt, fifo_size;
 		unsigned mac_fifo_cnt;
+		unsigned tmp;
 
 		/* FIXME- this section has no basis in HRM, revisit */
 		/* Loosely based on packet/clear78.x */
-		fifo_req_size = cvmx_pko3_mac_table[mac_num].fifo_cnt;
+		pko_fifo_cnt = cvmx_pko3_mac_table[mac_num].fifo_cnt;
 		mac_fifo_cnt = cvmx_pko3_mac_table[mac_num].mac_fifo_cnt;
 
 		/* Skip unused MACs */
-		if (fifo_req_size == 0)
+		if (pko_fifo_cnt == 0)
 			continue;
 
 		/* Check for sanity */
-		if (fifo_req_size > 4)
-			fifo_req_size = 1;
+		if (pko_fifo_cnt > 4)
+			pko_fifo_cnt = 1;
 
 		fifo_size = (2 * 1024) + (1024 / 2); /* 2.5KiB */
-		credit = fifo_req_size * fifo_size;
+		fifo_credit = pko_fifo_cnt * fifo_size;
 
 		/* FIXME- This code is chip-dependent, not portable! */
 		switch (mac_num) {
 			case 0: /* loopback */
 				mac_credit = 4096; /* From HRM Sec 13.0 */
+				skid_credit = 0;
 				break;
 			case 1: /* DPI */
 				mac_credit = 2 * 1024;
+				skid_credit = 0;
 				break;
 			case 2: /* ILK0 */
 			case 3: /* ILK1 */
 				mac_credit = 4 * 1024; /* 4KB fifo */
+				skid_credit = 0;
 				break;
 			default: /* BGX */
-				/* 8K in BGX + 16 so PKO doesn't deadlock with BGX on large packets */
-				mac_credit = mac_fifo_cnt * 8 * 1024 + 16;
+				mac_credit = mac_fifo_cnt * 8 * 1024;
+				skid_credit = mac_fifo_cnt * 256;
 				break;
 		} /* switch mac_num */
 
-		credit += mac_credit;
-
-		if(debug)
-			cvmx_dprintf(
-				"%s: mac %u "
-				"mci0.max_cred=%u mci1.max_cred=%u\n",
-				__FUNCTION__, mac_num, credit, mac_credit);
+		if(debug) cvmx_dprintf(
+			"%s: mac %u "
+			"pko_fifo_credit=%u mac_credit=%u\n",
+			__FUNCTION__, mac_num, fifo_credit, mac_credit);
 
+		tmp = (fifo_credit + mac_credit) / 16;
 		pko_mci0_max_cred.u64 = 0;
-		pko_mci0_max_cred.s.max_cred_lim = credit / 16;
+		pko_mci0_max_cred.s.max_cred_lim = tmp;
 
 		/* Check for overflow */
-		if (pko_mci0_max_cred.s.max_cred_lim != (credit / 16)) {
+		if (pko_mci0_max_cred.s.max_cred_lim != tmp) {
 			cvmx_dprintf("%s: MCI0 credit overflow\n",__FUNCTION__);
 			pko_mci0_max_cred.s.max_cred_lim = 0xfff;
 		}
@@ -769,17 +772,32 @@ static int cvmx_pko_setup_macs(int node)
 		cvmx_write_csr_node(node, CVMX_PKO_MCI0_MAX_CREDX(mac_num),
 					pko_mci0_max_cred.u64);
 
+		tmp = (mac_credit + skid_credit) / 16;
 		pko_mci1_max_cred.u64 = 0;
-		pko_mci1_max_cred.s.max_cred_lim = (mac_credit / 16);
+		pko_mci1_max_cred.s.max_cred_lim = tmp;
 
 		/* Check for overflow */
-		if (pko_mci1_max_cred.s.max_cred_lim != (mac_credit / 16)) {
+		if (pko_mci1_max_cred.s.max_cred_lim != tmp) {
 			cvmx_dprintf("%s: MCI1 credit overflow\n",__FUNCTION__);
 			pko_mci1_max_cred.s.max_cred_lim = 0xfff;
 		}
 
 		cvmx_write_csr_node(node, CVMX_PKO_MCI1_MAX_CREDX(mac_num),
 					pko_mci1_max_cred.u64);
+
+		tmp = (skid_credit / 256) >> 1; /* valid 0,1,2 */
+		pko_mac_cfg.u64 =
+			cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(mac_num));
+		pko_mac_cfg.s.skid_max_cnt = tmp;
+		cvmx_write_csr_node(node, CVMX_PKO_MACX_CFG(mac_num),
+			pko_mac_cfg.u64);
+
+		if(debug) cvmx_dprintf(
+			"%s: mac %u PKO_MCI0_MAX_CREDX=%u PKO_MCI1_MAX_CREDX=%u PKO_MACX_CFG[SKID_MAX_CNT]=%u\n",
+			__FUNCTION__,  mac_num,
+			pko_mci0_max_cred.s.max_cred_lim,
+			pko_mci1_max_cred.s.max_cred_lim,
+			pko_mac_cfg.s.skid_max_cnt);
 	} /* for mac_num */
 
 	return 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 74459e6..c3305c5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 98868 $<hr>
+ * <hr>$Revision: 99024 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1210,6 +1210,7 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 	if (gserx_cfg.s.pcie) {
 		switch (qlm) {
 		case 0: /* Either PEM0 x4 or PEM0 x8 */
+		case 1: /* Either PEM0 x8 or PEM1 x4 */
 		{
 			cvmx_pemx_cfg_t pemx_cfg;
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(0));
@@ -1218,18 +1219,6 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 			else
 				return CVMX_QLM_MODE_PCIE;     /* PEM0 x4 */
 		}
-		case 1: /* Either PEM0 x8 or PEM1 x4 */
-		{
-			cvmx_pemx_cfg_t pemx_cfg;
-			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(0));
-			if (pemx_cfg.cn78xx.lanes8)
-				return CVMX_QLM_MODE_DISABLED; /* PEM0 x8 */
-			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(1));
-			if (pemx_cfg.cn78xx.lanes8 == 0)
-				return CVMX_QLM_MODE_PCIE;     /* PEM1 x4 */
-			else
-				return CVMX_QLM_MODE_DISABLED; /* PEM0 x8 */
-		}
 		case 2: /* Either PEM2 x4 or PEM2 x8 */
 		{
 			cvmx_pemx_cfg_t pemx_cfg;
@@ -1239,29 +1228,28 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 			else
 				return CVMX_QLM_MODE_PCIE;      /* PEM2 x4 */
 		}
-		case 3: /* Either PEM2 x8 or PEM3 x4 */
+		case 3: /* Either PEM2 x8 or PEM3 x4 or PEM3 x8 */
 		{
 			cvmx_pemx_cfg_t pemx_cfg;
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(2));
 			if (pemx_cfg.cn78xx.lanes8)
-				return CVMX_QLM_MODE_DISABLED;  /* PEM2 x8 */
+				return CVMX_QLM_MODE_PCIE_1X8;  /* PEM2 x8 */
 
+			/* Can be first 4 lanes of PEM3 */
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(3));
-			if (pemx_cfg.cn78xx.lanes8 == 0) {
-				if (cvmx_read_csr_node(node, CVMX_PEMX_QLM(3)) == 0)
-					return CVMX_QLM_MODE_PCIE; /* PEM3 x4 */
-			}
-			return CVMX_QLM_MODE_DISABLED;  /* PEM2 x8 or uses QLM4 */
+			if (pemx_cfg.cn78xx.lanes8)
+				return CVMX_QLM_MODE_PCIE_1X8;  /* PEM3 x8 */
+			else
+				return CVMX_QLM_MODE_PCIE; /* PEM2 x4 */
 		}
-		case 4: /* PEM3 x4 */
+		case 4: /* Either PEM3 x8 or PEM3 x4 */
 		{
 			cvmx_pemx_cfg_t pemx_cfg;
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(3));
-			if (pemx_cfg.cn78xx.lanes8 == 0) {
-				if (cvmx_read_csr_node(node, CVMX_PEMX_QLM(3)))
-					return CVMX_QLM_MODE_PCIE; /* PEM3 x4 */
-			}
-			return CVMX_QLM_MODE_DISABLED;  /* PEM2 x8 or uses QLM3 */
+			if (pemx_cfg.cn78xx.lanes8)
+				return CVMX_QLM_MODE_PCIE_1X8; /* PEM3 x8 */
+			else
+				return CVMX_QLM_MODE_PCIE; /* PEM3 x4 */
 		}
 		default:
 			return CVMX_QLM_MODE_DISABLED;
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index 4619b83..5ca85e4 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -423,7 +423,7 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 			pko_status.s.dqstatus = PKO_DQSTATUS_NOFPABUF;
 			return pko_status;
 			}
-		cached_buf_count *= (4096/8)-1/48;
+		cached_buf_count *= ((4096/8)-1)/48;
 		}
 	}
 #endif
-- 
2.6.2

