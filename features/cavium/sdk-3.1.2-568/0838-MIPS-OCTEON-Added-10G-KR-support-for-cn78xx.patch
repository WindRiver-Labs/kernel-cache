From 7b99fe8a98f0a6da7fe42e5f454a7bb7d22cfe8d Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Fri, 18 Jul 2014 18:05:50 -0700
Subject: [PATCH 838/974] MIPS:OCTEON: Added 10G-KR support for cn78xx

  - Disable BGXX_SPUX_INT[training_done, training_failure, an_link_good,
    an_page_rx], these bits are checked locally by the interface
  - Sync-up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c | 264 +++++++++++++++------
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       | 233 +++++++++++++-----
 arch/mips/cavium-octeon/octeon-78xx-errors.c       | 120 ----------
 arch/mips/include/asm/octeon/cvmx-helper-bgx.h     |   2 +-
 drivers/net/ethernet/octeon/octeon-bgx-port.c      |   5 +-
 5 files changed, 369 insertions(+), 255 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index f46e9bf..9ceb187 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2014  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2014-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -96,19 +96,39 @@ int __cvmx_helper_bgx_enumerate(int xiface)
 	else
 		mode = cvmx_qlm_get_mode(qlm);
 
-	if (mode == CVMX_QLM_MODE_SGMII) {
+	switch (mode) {
+	case CVMX_QLM_MODE_SGMII:
+	case CVMX_QLM_MODE_10G_KR:
+	case CVMX_QLM_MODE_XFI:
+		if (OCTEON_IS_MODEL(OCTEON_CN73XX)
+		    && (qlm == 5 || qlm == 6))
+			return 2;
 		return 4;
-	} else if (mode == CVMX_QLM_MODE_XAUI
-		   || mode == CVMX_QLM_MODE_XLAUI
-		   || mode == CVMX_QLM_MODE_40G_KR4) {
+	case CVMX_QLM_MODE_XAUI:
+	case CVMX_QLM_MODE_40G_KR4:
+	case CVMX_QLM_MODE_XLAUI:
+	case CVMX_QLM_MODE_RGMII_XAUI:
+	case CVMX_QLM_MODE_RGMII_40G_KR4:
+	case CVMX_QLM_MODE_RGMII_XLAUI:
 		return 1;
-	} else if (mode == CVMX_QLM_MODE_RXAUI) {
+	case CVMX_QLM_MODE_RXAUI:
+	case CVMX_QLM_MODE_RGMII_RXAUI:
+		if (OCTEON_IS_MODEL(OCTEON_CN73XX)
+		    && (qlm == 5 || qlm == 6))
+			return 1;
 		return 2;
-	} else if (mode == CVMX_QLM_MODE_XFI
-		   || mode == CVMX_QLM_MODE_10G_KR) {
-		return 4;
-	} else
+	case CVMX_QLM_MODE_RGMII_SGMII:
+	case CVMX_QLM_MODE_RGMII_10G_KR:
+	case CVMX_QLM_MODE_RGMII_XFI:
+		if (qlm == 5)
+			return 1;
+		else if (qlm == 6)
+			return 2;
+		else
+			return 3;
+	default:
 		return 0;
+	}
 }
 
 /**
@@ -130,6 +150,30 @@ static int cvmx_helper_bgx_index(int xiface, int index,
 	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
 		*lmac = ((xi.interface & 1 ) << 1) + (index & 1);
 		*block = xi.interface >> 1;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		static int lmac_mask[4] = {0};
+		static int is_lmac_mask_set = 0;
+
+		*block = (xi.interface < 2) ? xi.interface : 2;
+		if (is_lmac_mask_set == 0) {
+			cvmx_bgxx_cmrx_config_t cmr_config;
+			int i;
+			for (i = 0; i < 4; i++) {
+				cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(i, xi.interface));
+				lmac_mask[i] |= (cmr_config.s.lmac_type << (i * 4));	
+			}
+			is_lmac_mask_set = 1;
+		}
+		if (xi.interface < 2)
+			*lmac = (lmac_mask[0] != 5) ? index : (index + 1);
+		else if (xi.interface == 3)
+			*lmac = index+2;
+		else {
+			if (lmac_mask[0] == 5)
+				*lmac = index + 1;
+			else
+				*lmac = index;
+		}
 	} else {
 		*block = xi.interface;
 		*lmac = index;
@@ -165,7 +209,6 @@ void cvmx_helper_bgx_disable(int xipd_port)
 }
 
 
-
 /**
  * @INTERNAL
  * Configure the bgx mac.
@@ -190,6 +233,10 @@ static void __cvmx_bgx_common_init(int xiface, int index)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
 		__func__, xi.node, xi.interface, index);
 
+	/* Nothing to do here, already configured by u-boot */
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		return;
+
 	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
 		return;
 
@@ -236,7 +283,6 @@ static void __cvmx_bgx_common_init(int xiface, int index)
 	cmr_config.s.data_pkt_tx_en = 0;
 	cmr_config.s.data_pkt_rx_en = 0;
 	cmr_config.s.lmac_type = lmac_type;
-	//XXX This logic is obscore, needs clarification! FIXME.
 	cmr_config.s.lane_to_sds = ((lane_to_sds == 1) ? lmac
 				: ((lane_to_sds == 0)
 				? (lmac ? 0xe : 4) : lane_to_sds));
@@ -283,12 +329,6 @@ static void __cvmx_bgx_common_init_pknd(int xiface, int index)
 	bgx_rx_bp_on.u64 = 0;
 	bgx_rx_bp_on.s.mark = (CVMX_BGX_RX_FIFO_SIZE / (num_ports * 4 * 16));
 
-	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
-		/* o75 always uses 4 LMACs */
-		bgx_rx_bp_on.s.mark = (CVMX_BGX_RX_FIFO_SIZE / (4 * 4 * 16));
-	}
-
-
 	/* Setup pkind */
 	pknd = cvmx_helper_get_pknd(xiface, index);
 	cmr_rx_id_map.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(lmac, unit));
@@ -431,11 +471,10 @@ static int __cvmx_helper_bgx_sgmii_hardware_init(int xiface, int num_ports)
 	for (index = 0; index < num_ports; index++) {
 		int xipd_port = cvmx_helper_get_ipd_port(xiface, index);
 
-		__cvmx_helper_bgx_port_init(xipd_port, 0);
-
 		if (!cvmx_helper_is_port_valid(xiface, index))
 			continue;
 
+		__cvmx_helper_bgx_port_init(xipd_port, 0, 0);
 
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 		/*
@@ -579,7 +618,6 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link_speed(int xiface,
 	cvmx_bgxx_gmp_pcs_miscx_ctl_t gmp_miscx_ctl;
 	cvmx_bgxx_gmp_gmi_prtx_cfg_t gmp_prtx_cfg;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int interface = xi.interface;
 	int node = xi.node;
 	unsigned unit, lmac;
 
@@ -608,7 +646,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link_speed(int xiface,
 	    CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_GMP_GMI_PRTX_CFG(lmac, unit),
 				  cvmx_bgxx_gmp_gmi_prtx_cfg_t, tx_idle, ==, 1, 10000)) {
 		cvmx_dprintf("SGMII%d:%d: Timeout waiting for port %d to be idle\n",
-			     node, interface, index);
+			     node, unit, lmac);
 		return -1;
 	}
 
@@ -899,7 +937,6 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	int interface = xi.interface;
 	int node = xi.node;
 	int use_auto_neg = 0;
-	int use_training = 0;
 	int xipd_port = cvmx_helper_get_ipd_port(xiface, index);
 	unsigned unit, lmac;
 
@@ -914,8 +951,7 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 
 	if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
 	    || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4) {
-		use_training = 1;
-		use_auto_neg = 0;
+		use_auto_neg = 1;
 	}
 
 	/* NOTE: This code was moved first, out of order compared to the HRM
@@ -988,13 +1024,7 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 
 		/* 4c. For 10GBASE-KR or 40GBASE-KR, enable link training by writing
 		     BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] = 1. */
-		if (use_training) {
-			cvmx_bgxx_spux_br_pmd_control_t spu_br_pmd_control;
-			spu_br_pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
-			spu_br_pmd_control.s.train_en = 1;
-			cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), spu_br_pmd_control.u64);
-
-		}
+		/* Moved to xaui_link */
 	} else { /* enable for simulator */
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(lmac, unit));
 		cmr_config.s.enable = 1;
@@ -1076,10 +1106,88 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	smu_tx_ctl.s.uni_en = 0;
 	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(lmac, unit), smu_tx_ctl.u64);
 
+	{
+		/* Calculate the number of s-clk cycles per usec. */
+		const uint64_t clock_mhz = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK) / 1000000;
+		cvmx_bgxx_spu_dbg_control_t dbg_control;
+		dbg_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(unit));
+		dbg_control.s.us_clk_period = clock_mhz - 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(unit), dbg_control.u64);
+	}
 	return 0;
 }
 
-int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres)
+static void __cvmx_bgx_start_training(int node, int unit, int lmac)
+{
+	cvmx_bgxx_spux_int_t spu_int;
+	cvmx_bgxx_spux_br_pmd_control_t pmd_control;
+	cvmx_bgxx_spux_an_control_t an_control;
+
+	/* Clear the training interrupts (W1C) */
+	spu_int.u64 = 0;
+	spu_int.s.training_failure = 1;
+	spu_int.s.training_done = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit), spu_int.u64);
+
+	/* These registers aren't cleared when training is restarted. Manually
+	   clear them as per Errata BGX-20968. */
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_LP_CUP(lmac, unit), 0);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_LD_CUP(lmac, unit), 0);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_LD_REP(lmac, unit), 0);
+
+	/* Disable autonegotiation */
+	an_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(lmac, unit));
+	an_control.s.an_en = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(lmac, unit), an_control.u64);
+	cvmx_wait_usec(1);
+
+	/* Restart training */
+	pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
+	pmd_control.s.train_en = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), pmd_control.u64);
+
+	cvmx_wait_usec(1);
+	pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
+	pmd_control.s.train_restart = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), pmd_control.u64);
+}
+
+static void __cvmx_bgx_restart_training(int node, int unit, int lmac)
+{
+	cvmx_bgxx_spux_int_t spu_int;
+	cvmx_bgxx_spux_br_pmd_control_t pmd_control;
+
+	/* Clear the training interrupts (W1C) */
+	spu_int.u64 = 0;
+	spu_int.s.training_failure = 1;
+	spu_int.s.training_done = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit), spu_int.u64);
+
+	cvmx_wait_usec(1700);  /* Wait 1.7 msec */
+
+	/* These registers aren't cleared when training is restarted. Manually
+	   clear them as per Errata BGX-20968. */
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_LP_CUP(lmac, unit), 0);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_LD_CUP(lmac, unit), 0);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_LD_REP(lmac, unit), 0);
+
+	/* Restart training */
+	pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
+	pmd_control.s.train_restart = 1;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), pmd_control.u64);
+}
+
+/*
+ * @INTERNAL
+ * Wrapper function to configure the BGX, does not enable.
+ *
+ * @param xipd_port IPD/PKO port to configure.
+ * @param phy_pres  If set, enable disparity, only applies to RXAUI interface
+ * @param is_mix    Configure lmac for MIX interface
+ *
+ * @return Zero on success, negative on failure.
+ */ 
+int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres, int is_mix)
 {
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
@@ -1099,6 +1207,9 @@ int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres)
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
+	if (is_mix)
+		__cvmx_bgx_common_init(xiface, index);
+
 	__cvmx_bgx_common_init_pknd(xiface, index);
 
 	if (mode == CVMX_HELPER_INTERFACE_MODE_SGMII) {
@@ -1234,26 +1345,50 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(lmac, unit), spu_misc_control.u64);
 
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-		if (use_training) {
-			spu_int.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit));
-			if (!spu_int.s.training_done) {
-				cvmx_bgxx_spux_br_pmd_control_t pmd_control;
-				/* Clear the training interrupts (W1C) */
-
+		cvmx_bgxx_spux_an_control_t spu_an_control;
+		cvmx_bgxx_spux_br_pmd_control_t pmd_control;
+
+		spu_an_control.u64 = cvmx_read_csr_node(node,
+					CVMX_BGXX_SPUX_AN_CONTROL(index, interface));
+		if (spu_an_control.s.an_en) {
+			spu_int.u64 = cvmx_read_csr_node(node,
+						CVMX_BGXX_SPUX_INT(index, interface));
+			if (!spu_int.s.an_link_good) {
+				/* Clear the auto negotiation (W1C) */
 				spu_int.u64 = 0;
-				spu_int.s.training_failure = 1;
-				spu_int.s.training_done = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit), spu_int.u64);
+				spu_int.s.an_complete = 1;
+				spu_int.s.an_link_good = 1;
+				spu_int.s.an_page_rx = 1;
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), spu_int.u64);
+
+				/* Restart auto negotiation */
+				spu_an_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface));
+				spu_an_control.s.an_restart = 1;
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface), spu_an_control.u64);
+				return -1;
+			}
+		}
 
-				/* Restart training */
-				pmd_control.u64 = cvmx_read_csr_node(node,
-							CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
-				pmd_control.s.train_restart = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), pmd_control.u64);
+		if (use_training) {
+			pmd_control.u64 = cvmx_read_csr_node(node,
+						CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
 
-				/*cvmx_dprintf("Restarting link training\n"); */
+			if (pmd_control.s.train_en == 0) {
+				__cvmx_bgx_start_training(node, interface, index);
 				return -1;
 			}
+			else {
+				spu_int.u64 = cvmx_read_csr_node(node,
+						  CVMX_BGXX_SPUX_INT(index, interface));
+				if (spu_int.s.training_failure) {
+					__cvmx_bgx_restart_training(node, interface, index);
+					return -1;
+				}
+				if (!spu_int.s.training_done) {
+					cvmx_dprintf("Waiting for link training\n");
+					return -1;
+				}
+			}
 		}
 
 		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_CONTROL1(lmac, unit),
@@ -1291,19 +1426,8 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive fault, need to retry\n",
 					node, interface, index);
 
-			if (use_training) {
-				cvmx_bgxx_spux_br_pmd_control_t pmd_control;
-				spu_int.u64 = 0;
-				spu_int.s.training_failure = 1;
-				spu_int.s.training_done = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(lmac, unit), spu_int.u64);
-
-				/* Restart training */
-				pmd_control.u64 = cvmx_read_csr_node(node,
-							CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit));
-				pmd_control.s.train_restart = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(lmac, unit), pmd_control.u64);
-			}
+			if (use_training)
+				__cvmx_bgx_restart_training(node, interface, index);
 			/*cvmx_dprintf("training restarting\n"); */
 			return -1;
 		}
@@ -1384,7 +1508,7 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 			phy_pres = 1;
 		else
 			phy_pres = 0;
-		if (__cvmx_helper_bgx_port_init(xipd_port, phy_pres))
+		if (__cvmx_helper_bgx_port_init(xipd_port, phy_pres, 0))
 			return -1;
 
 		res = __cvmx_helper_bgx_xaui_link_init(index, xiface);
@@ -1807,20 +1931,18 @@ int cvmx_bgx_set_backpressure_override(int xiface, unsigned port_mask)
 
 	if (debug)
 		cvmx_dprintf("%s: interface %u:%d port_mask=%#x\n",
-			__func__, xi.node, xi.interface, (unsigned int)port_mask);
+			__func__, xi.node, xi.interface, port_mask);
 
 	if (__cvmx_helper_bgx_enumerate(xiface) <= 0)
 		return -1;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN75XX)) {
-		lmac = ((xi.interface & 1 ) << 1) + (index & 1);
-		unit = xi.interface >> 1;
-		port_mask = port_mask << lmac;
-	} else {
-		unit = xi.interface;
-		lmac = index;
-	}
+	/* check number of BGX unit against per-model max */
+	if (cvmx_helper_bgx_index(xiface, index, &unit, &lmac) < 0)
+		return -1;
 
+	/* Full-BGX interfaces, lmac==0, half-BGX interfaces lmax = 0 or 2 */
+	/* Adjust port_mask for half-BGX interfaces */
+	port_mask <<= lmac;
 
 	/* Check for valid arguments */
 	rx_ovr_bp.u64 = 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index a5da608..afec9cb 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2011-2014  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2011-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 111541 $<hr>
+ * <hr>$Revision: 113180 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -219,15 +219,12 @@ int cvmx_qlm_interface(int xiface)
 		cvmx_gserx_cfg_t gserx_cfg;
 		int qlm;
 
-		if (xi.interface < 6) {
+		/* QLM2, QLM3, QLM5/QLM6 */
+		if (xi.interface < 4) {
 			if (xi.interface < 2)
-				qlm = 2;
-			else if (xi.interface < 4)
-				qlm = 3;
-			else if	(xi.interface == 4)
-				qlm = 5;
+				qlm = xi.interface + 2;
 			else
-				qlm = 6;
+				qlm = xi.interface + 3;
 
 			phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(qlm));
 			if (phy_ctl.s.phy_pd || phy_ctl.s.phy_reset) {
@@ -677,7 +674,6 @@ int cvmx_qlm_get_gbaud_mhz_node(int node, int qlm)
 	cvmx_gserx_lane_mode_t lane_mode;
 	cvmx_gserx_cfg_t cfg;
 
-	//FIXME: 73XX has QLM bot not OCI, wrong feature
 	if (!octeon_has_feature(OCTEON_FEATURE_MULTINODE))
 		return 0;
 
@@ -907,9 +903,41 @@ int cvmx_qlm_get_gbaud_mhz(int qlm)
 		mpll_multiplier.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_MPLL_MULTIPLIER(qlm, 0));
 		freq = meas_refclock * mpll_multiplier.s.mpll_multiplier;
 		freq = (freq + 500000) / 1000000;
+
 		return freq;
 	} else if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 		return cvmx_qlm_get_gbaud_mhz_node(cvmx_get_node_num(), qlm);
+	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		cvmx_gserx_lane_mode_t lane_mode;
+		lane_mode.u64 = cvmx_read_csr(CVMX_GSERX_LANE_MODE(qlm));
+		switch (lane_mode.s.lmode) {
+		case R_25G_REFCLK100:
+			return 2500;
+		case R_5G_REFCLK100:
+			return 5000;
+		case R_8G_REFCLK100:
+			return 8000;
+		case R_125G_REFCLK15625_KX:
+			return 1250;
+		case R_3125G_REFCLK15625_XAUI:
+			return 3125;
+		case R_103125G_REFCLK15625_KR:
+			return 10312;
+		case R_125G_REFCLK15625_SGMII:
+			return 1250;
+		case R_5G_REFCLK15625_QSGMII:
+			return 5000;
+		case R_625G_REFCLK15625_RXAUI:
+			return 6250;
+		case R_25G_REFCLK125:
+			return 2500;
+		case R_5G_REFCLK125:
+			return 5000;
+		case R_8G_REFCLK125:
+			return 8000;
+		default:
+			return 0;
+		}
 	}
 	return 0;
 }
@@ -1314,10 +1342,22 @@ void __cvmx_qlm_set_mult(int qlm, int baud_mhz, int old_multiplier)
 enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 {
 	cvmx_gserx_cfg_t gserx_cfg;
+#ifdef CVMX_BUILD_FOR_UBOOT
+	int qlm_mode[2][9] = {
+		{-1, -1, -1, -1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1, -1, -1, -1}};
+#else
+	static int qlm_mode[2][9] = {
+		{-1, -1, -1, -1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1, -1, -1, -1}};
+#endif
 
 	if (qlm >= 8)
 		return CVMX_QLM_MODE_OCI;
 
+	if (qlm_mode[node][qlm] != -1)
+		return qlm_mode[node][qlm];
+
 	gserx_cfg.u64 = cvmx_read_csr_node(node, CVMX_GSERX_CFG(qlm));
 	if (gserx_cfg.s.pcie) {
 		switch (qlm) {
@@ -1327,75 +1367,92 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 			cvmx_pemx_cfg_t pemx_cfg;
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(0));
 			if (pemx_cfg.cn78xx.lanes8)
-				return CVMX_QLM_MODE_PCIE_1X8; /* PEM0 x8 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE_1X8; /* PEM0 x8 */
 			else
-				return CVMX_QLM_MODE_PCIE;     /* PEM0 x4 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE;     /* PEM0 x4 */
+			break;
 		}
 		case 2: /* Either PEM2 x4 or PEM2 x8 */
 		{
 			cvmx_pemx_cfg_t pemx_cfg;
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(2));
 			if (pemx_cfg.cn78xx.lanes8)
-				return CVMX_QLM_MODE_PCIE_1X8;  /* PEM2 x8 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE_1X8;  /* PEM2 x8 */
 			else
-				return CVMX_QLM_MODE_PCIE;      /* PEM2 x4 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE;      /* PEM2 x4 */
+			break;
 		}
 		case 3: /* Either PEM2 x8 or PEM3 x4 or PEM3 x8 */
 		{
 			cvmx_pemx_cfg_t pemx_cfg;
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(2));
 			if (pemx_cfg.cn78xx.lanes8)
-				return CVMX_QLM_MODE_PCIE_1X8;  /* PEM2 x8 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE_1X8;  /* PEM2 x8 */
 
 			/* Can be first 4 lanes of PEM3 */
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(3));
 			if (pemx_cfg.cn78xx.lanes8)
-				return CVMX_QLM_MODE_PCIE_1X8;  /* PEM3 x8 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE_1X8;  /* PEM3 x8 */
 			else
-				return CVMX_QLM_MODE_PCIE; /* PEM2 x4 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE; /* PEM2 x4 */
+			break;
 		}
 		case 4: /* Either PEM3 x8 or PEM3 x4 */
 		{
 			cvmx_pemx_cfg_t pemx_cfg;
 			pemx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PEMX_CFG(3));
 			if (pemx_cfg.cn78xx.lanes8)
-				return CVMX_QLM_MODE_PCIE_1X8; /* PEM3 x8 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE_1X8; /* PEM3 x8 */
 			else
-				return CVMX_QLM_MODE_PCIE; /* PEM3 x4 */
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_PCIE; /* PEM3 x4 */
+			break;
 		}
 		default:
-			return CVMX_QLM_MODE_DISABLED;
+			qlm_mode[node][qlm] = CVMX_QLM_MODE_DISABLED;
+			break;
 		}
 	} else if (gserx_cfg.s.ila) {
-		return CVMX_QLM_MODE_ILK;
+		qlm_mode[node][qlm] = CVMX_QLM_MODE_ILK;
 	} else if (gserx_cfg.s.bgx) {
 		cvmx_bgxx_cmrx_config_t cmr_config;
 		cvmx_bgxx_spux_br_pmd_control_t pmd_control;
 		int bgx = (qlm < 2) ? qlm : qlm - 2;
-		
+
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, bgx));
 		pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx));
-		
+
 		switch(cmr_config.s.lmac_type) {
-		case 0: return CVMX_QLM_MODE_SGMII;
-		case 1:	return CVMX_QLM_MODE_XAUI;
-		case 2:	return CVMX_QLM_MODE_RXAUI;
-		case 3:	
+		case 0: qlm_mode[node][qlm] = CVMX_QLM_MODE_SGMII; break;
+		case 1:	qlm_mode[node][qlm] = CVMX_QLM_MODE_XAUI; break;
+		case 2:	qlm_mode[node][qlm] = CVMX_QLM_MODE_RXAUI; break;
+		case 3:
 			/* Use training to determine if we're in 10GBASE-KR or XFI */
 			if (pmd_control.s.train_en)
-				return CVMX_QLM_MODE_10G_KR;
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_10G_KR;
 			else
-				return CVMX_QLM_MODE_XFI;
-		case 4:	
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_XFI;
+			pmd_control.s.train_en = 0;
+			cvmx_write_csr_node(node, 
+				CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx), pmd_control.u64);
+			break;
+		case 4:
 			/* Use training to determine if we're in 10GBASE-KR or XFI */
 			if (pmd_control.s.train_en)
-				return CVMX_QLM_MODE_40G_KR4;
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_40G_KR4;
 			else
-				return CVMX_QLM_MODE_XLAUI;
-		default: return CVMX_QLM_MODE_DISABLED;
+				qlm_mode[node][qlm] = CVMX_QLM_MODE_XLAUI;
+			pmd_control.s.train_en = 0;
+			cvmx_write_csr_node(node, 
+				CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx), pmd_control.u64);
+			break;
+		default:
+			qlm_mode[node][qlm] = CVMX_QLM_MODE_DISABLED;
+			break;
 		}
 	} else
-		return CVMX_QLM_MODE_DISABLED;
+		qlm_mode[node][qlm] = CVMX_QLM_MODE_DISABLED;
+
+	return qlm_mode[node][qlm];
 }
 
 enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
@@ -1407,7 +1464,39 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 
 	gserx_cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
 	if (gserx_cfg.s.pcie) {
-		/* FIXME later */
+		cvmx_pemx_cfg_t pemx_cfg;
+		switch (qlm) {
+		case 0: /* Either PEM0 x4 or PEM0 x8 */
+		case 1: /* Either PEM0 x8 or PEM1 x4 */
+		{
+			pemx_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(0));
+			if (pemx_cfg.cn78xx.lanes8)
+				return CVMX_QLM_MODE_PCIE_1X8; /* PEM0 x8 */
+			else
+				return CVMX_QLM_MODE_PCIE;     /* PEM0/PEM1 x4 */
+		}
+		case 2: /* Either PEM2 x4 or PEM2 x8 */
+		{
+			pemx_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(2));
+			if (pemx_cfg.cn78xx.lanes8)
+				return CVMX_QLM_MODE_PCIE_1X8;  /* PEM2 x8 */
+			else
+				return CVMX_QLM_MODE_PCIE;      /* PEM2 x4 */
+		}
+		case 5:
+		case 6:	/* PEM3 x2 */
+			return CVMX_QLM_MODE_PCIE_1X2; /* PEM3 x2 */
+		case 3: /* Either PEM2 x8 or PEM3 x4 */
+		{
+			pemx_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(2));
+			if (pemx_cfg.cn78xx.lanes8)
+				return CVMX_QLM_MODE_PCIE_1X8;  /* PEM2 x8 */
+			else
+				return CVMX_QLM_MODE_PCIE; /* PEM3 x4 */
+		}
+		default:
+			return CVMX_QLM_MODE_DISABLED;
+		}
 	} else if (gserx_cfg.s.bgx) {
 		cvmx_bgxx_cmrx_config_t cmr_config;
 		cvmx_bgxx_spux_br_pmd_control_t pmd_control;
@@ -1417,7 +1506,7 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 		if (qlm < 4)
 			bgx = qlm - 2;
 		else if (qlm == 5 || qlm == 6)
-			bgx = qlm - 3;
+			bgx = 2;
 
 		for (index = 0; index < 4; index++) {
 			cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(index, bgx));
@@ -1425,18 +1514,18 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 			lane_mask |= (cmr_config.s.lmac_type << (index * 4));
 			train_mask |= (pmd_control.s.train_en << (index * 4));
 		}
-		
+
 		switch(lane_mask) {
 		case 0:		return CVMX_QLM_MODE_SGMII;
-		case 0x1111:	return CVMX_QLM_MODE_XAUI;
-		case 0x2222:	return CVMX_QLM_MODE_RXAUI;
-		case 0x3333:	
+		case 0x1:	return CVMX_QLM_MODE_XAUI;
+		case 0x22:	return CVMX_QLM_MODE_RXAUI;
+		case 0x3333:
 			/* Use training to determine if we're in 10GBASE-KR or XFI */
 			if (train_mask)
 				return CVMX_QLM_MODE_10G_KR;
 			else
 				return CVMX_QLM_MODE_XFI;
-		case 0x4444:	
+		case 0x4:
 			/* Use training to determine if we're in 10GBASE-KR or XFI */
 			if (train_mask)
 				return CVMX_QLM_MODE_40G_KR4;
@@ -1447,34 +1536,49 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 					return CVMX_QLM_MODE_RGMII_10G_KR;
 				else
 					return CVMX_QLM_MODE_RGMII_XFI;
-		case 0x4445:	if (train_mask)
+		case 0x45:	if (train_mask)
 					return CVMX_QLM_MODE_RGMII_40G_KR4;
 				else
 					return CVMX_QLM_MODE_RGMII_XLAUI;
-		case 0x2225:	return CVMX_QLM_MODE_RGMII_RXAUI;
-		case 0x1115:	return CVMX_QLM_MODE_RGMII_XAUI;
-		case 0x3330:	if (train_mask)
-					return CVMX_QLM_MODE_SGMII_10G_KR;
+		case 0x225:	return CVMX_QLM_MODE_RGMII_RXAUI;
+		case 0x15:	return CVMX_QLM_MODE_RGMII_XAUI;
+		case 0x3300:	if (qlm == 5)
+					return CVMX_QLM_MODE_SGMII;
+				if (train_mask)
+					return CVMX_QLM_MODE_10G_KR;
+				else
+					return CVMX_QLM_MODE_XFI;
+		case 0x200:	if (qlm == 5)
+					return CVMX_QLM_MODE_SGMII;
+				return CVMX_QLM_MODE_RXAUI;
+		case 0x233:	if (qlm == 6)
+					return CVMX_QLM_MODE_RXAUI; 
+				if (train_mask)
+					return CVMX_QLM_MODE_10G_KR;
 				else
-					return CVMX_QLM_MODE_SGMII_XFI;
-		case 0x2200:	return CVMX_QLM_MODE_SGMII_RXAUI;
-		case 0x2244:	if (train_mask)
-					return CVMX_QLM_MODE_40G_KR4_RXAUI;
+					return CVMX_QLM_MODE_XFI;
+		case 0x3305:	if (qlm == 5)
+					return CVMX_QLM_MODE_RGMII_SGMII; 
+				if (train_mask)
+					return CVMX_QLM_MODE_10G_KR;
 				else
-					return CVMX_QLM_MODE_XLAUI_RXAUI;
-		case 0x3305:	if (train_mask)
-					return CVMX_QLM_MODE_RGMII_SGMII_10G_KR;
+					return CVMX_QLM_MODE_XFI;
+		case 0x205:	if (qlm == 5)
+					return CVMX_QLM_MODE_RGMII_SGMII;
 				else
-					return CVMX_QLM_MODE_RGMII_SGMII_XFI;
-		case 0x2205:	return CVMX_QLM_MODE_RGMII_SGMII_RXAUI;
-		case 0x0035:	if (train_mask)
-					return CVMX_QLM_MODE_RGMII_10G_KR_SGMII;
+					return CVMX_QLM_MODE_RXAUI;
+		case 0x0035:	if (qlm == 6)
+					return CVMX_QLM_MODE_SGMII; 
+				if (train_mask)
+					return CVMX_QLM_MODE_RGMII_10G_KR;
 				else
-					return CVMX_QLM_MODE_RGMII_XFI_SGMII;
-		case 0x2235:	if (train_mask)
-					return CVMX_QLM_MODE_RGMII_10G_KR_RXAUI;
+					return CVMX_QLM_MODE_RGMII_XFI;
+		case 0x235:	if (qlm == 6)
+					return CVMX_QLM_MODE_RXAUI;
+				if (train_mask)
+					return CVMX_QLM_MODE_RGMII_10G_KR;
 				else
-					return CVMX_QLM_MODE_RGMII_XFI_RXAUI;
+					return CVMX_QLM_MODE_RGMII_XFI;
 		default: return CVMX_QLM_MODE_DISABLED;
 		}
 	}
@@ -1619,6 +1723,13 @@ int cvmx_qlm_measure_clock(int qlm)
 	cvmx_write_csr(CVMX_MIO_PTP_CLOCK_CFG, ptp_clock.u64);
 	/* Clock counted down, so reverse it */
 	count = 1000000000 - count;
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+		cvmx_gserx_dlmx_ref_clkdiv2_t ref_clkdiv2;
+
+		ref_clkdiv2.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_REF_CLKDIV2(qlm, 0));
+		if (ref_clkdiv2.s.ref_clkdiv2)
+			count *= 2;
+	}
 	/* Return the rate */
 	ref_clock[qlm] = count * cvmx_clock_get_rate(CVMX_CLOCK_CORE) / (stop_cycle - start_cycle);
 	return ref_clock[qlm];
diff --git a/arch/mips/cavium-octeon/octeon-78xx-errors.c b/arch/mips/cavium-octeon/octeon-78xx-errors.c
index 499ccb8..8028fef 100644
--- a/arch/mips/cavium-octeon/octeon-78xx-errors.c
+++ b/arch/mips/cavium-octeon/octeon-78xx-errors.c
@@ -2493,11 +2493,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e0010220ull,	"Error: CVMX_BGX0_SPU000_INT[%llx][%u]",	0xe0107,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e0010220ull,	"Error: CVMX_BGX0_SPU000_INT[%llx][%u]",	0xe0108,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e0010220ull,	"Error: CVMX_BGX0_SPU000_INT[%llx][%u]",	0xe0109,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e0010220ull,	"Error: CVMX_BGX0_SPU000_INT[%llx][%u]",	0xe010a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e0010220ull,	"Error: CVMX_BGX0_SPU000_INT[%llx][%u]",	0xe010b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e0010220ull,	"Error: CVMX_BGX0_SPU000_INT[%llx][%u]",	0xe010c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e0010220ull,	"Error: CVMX_BGX0_SPU000_INT[%llx][%u]",	0xe010d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e0010220ull,	"Error: CVMX_BGX0_SPU000_INT[%llx][%u]",	0xe010e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e0010310ull,	"Error: CVMX_BGX0_SPU_MEM_INT[%llx][%u]",	0xe0120,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_BUF_DBE<0> */,
 	{ 0x11800e0010310ull,	"Error: CVMX_BGX0_SPU_MEM_INT[%llx][%u]",	0xe0121,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_BUF_DBE<1> */,
 	{ 0x11800e0010310ull,	"Error: CVMX_BGX0_SPU_MEM_INT[%llx][%u]",	0xe0122,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RX_BUF_DBE<2> */,
@@ -2516,11 +2511,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e0110220ull,	"Error: CVMX_BGX0_SPU001_INT[%llx][%u]",	0xe0147,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e0110220ull,	"Error: CVMX_BGX0_SPU001_INT[%llx][%u]",	0xe0148,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e0110220ull,	"Error: CVMX_BGX0_SPU001_INT[%llx][%u]",	0xe0149,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e0110220ull,	"Error: CVMX_BGX0_SPU001_INT[%llx][%u]",	0xe014a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e0110220ull,	"Error: CVMX_BGX0_SPU001_INT[%llx][%u]",	0xe014b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e0110220ull,	"Error: CVMX_BGX0_SPU001_INT[%llx][%u]",	0xe014c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e0110220ull,	"Error: CVMX_BGX0_SPU001_INT[%llx][%u]",	0xe014d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e0110220ull,	"Error: CVMX_BGX0_SPU001_INT[%llx][%u]",	0xe014e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe0180,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe0181,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe0182,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -2531,11 +2521,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe0187,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe0188,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe0189,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe018a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe018b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe018c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe018d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e0210220ull,	"Error: CVMX_BGX0_SPU002_INT[%llx][%u]",	0xe018e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01c0,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01c1,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01c2,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -2546,11 +2531,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01c7,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01c8,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01c9,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01ca,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01cb,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01cc,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01cd,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e0310220ull,	"Error: CVMX_BGX0_SPU003_INT[%llx][%u]",	0xe01ce,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e0020000ull,	"Error: CVMX_BGX0_SMU000_RX_INT[%llx][%u]",	0xe0200,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* JABBER */,
 	{ 0x11800e0020000ull,	"Error: CVMX_BGX0_SMU000_RX_INT[%llx][%u]",	0xe0201,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* FCSERR */,
 	{ 0x11800e0020000ull,	"Error: CVMX_BGX0_SMU000_RX_INT[%llx][%u]",	0xe0202,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RCVERR */,
@@ -2771,11 +2751,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e1010220ull,	"Error: CVMX_BGX1_SPU000_INT[%llx][%u]",	0xe1107,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e1010220ull,	"Error: CVMX_BGX1_SPU000_INT[%llx][%u]",	0xe1108,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e1010220ull,	"Error: CVMX_BGX1_SPU000_INT[%llx][%u]",	0xe1109,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e1010220ull,	"Error: CVMX_BGX1_SPU000_INT[%llx][%u]",	0xe110a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e1010220ull,	"Error: CVMX_BGX1_SPU000_INT[%llx][%u]",	0xe110b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e1010220ull,	"Error: CVMX_BGX1_SPU000_INT[%llx][%u]",	0xe110c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e1010220ull,	"Error: CVMX_BGX1_SPU000_INT[%llx][%u]",	0xe110d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e1010220ull,	"Error: CVMX_BGX1_SPU000_INT[%llx][%u]",	0xe110e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e1010310ull,	"Error: CVMX_BGX1_SPU_MEM_INT[%llx][%u]",	0xe1120,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_BUF_DBE<0> */,
 	{ 0x11800e1010310ull,	"Error: CVMX_BGX1_SPU_MEM_INT[%llx][%u]",	0xe1121,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_BUF_DBE<1> */,
 	{ 0x11800e1010310ull,	"Error: CVMX_BGX1_SPU_MEM_INT[%llx][%u]",	0xe1122,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RX_BUF_DBE<2> */,
@@ -2794,11 +2769,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e1110220ull,	"Error: CVMX_BGX1_SPU001_INT[%llx][%u]",	0xe1147,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e1110220ull,	"Error: CVMX_BGX1_SPU001_INT[%llx][%u]",	0xe1148,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e1110220ull,	"Error: CVMX_BGX1_SPU001_INT[%llx][%u]",	0xe1149,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e1110220ull,	"Error: CVMX_BGX1_SPU001_INT[%llx][%u]",	0xe114a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e1110220ull,	"Error: CVMX_BGX1_SPU001_INT[%llx][%u]",	0xe114b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e1110220ull,	"Error: CVMX_BGX1_SPU001_INT[%llx][%u]",	0xe114c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e1110220ull,	"Error: CVMX_BGX1_SPU001_INT[%llx][%u]",	0xe114d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e1110220ull,	"Error: CVMX_BGX1_SPU001_INT[%llx][%u]",	0xe114e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe1180,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe1181,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe1182,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -2809,11 +2779,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe1187,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe1188,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe1189,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe118a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe118b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe118c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe118d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e1210220ull,	"Error: CVMX_BGX1_SPU002_INT[%llx][%u]",	0xe118e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11c0,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11c1,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11c2,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -2824,11 +2789,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11c7,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11c8,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11c9,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11ca,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11cb,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11cc,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11cd,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e1310220ull,	"Error: CVMX_BGX1_SPU003_INT[%llx][%u]",	0xe11ce,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e1020000ull,	"Error: CVMX_BGX1_SMU000_RX_INT[%llx][%u]",	0xe1200,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* JABBER */,
 	{ 0x11800e1020000ull,	"Error: CVMX_BGX1_SMU000_RX_INT[%llx][%u]",	0xe1201,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* FCSERR */,
 	{ 0x11800e1020000ull,	"Error: CVMX_BGX1_SMU000_RX_INT[%llx][%u]",	0xe1202,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RCVERR */,
@@ -3049,11 +3009,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e2010220ull,	"Error: CVMX_BGX2_SPU000_INT[%llx][%u]",	0xe2107,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e2010220ull,	"Error: CVMX_BGX2_SPU000_INT[%llx][%u]",	0xe2108,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e2010220ull,	"Error: CVMX_BGX2_SPU000_INT[%llx][%u]",	0xe2109,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e2010220ull,	"Error: CVMX_BGX2_SPU000_INT[%llx][%u]",	0xe210a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e2010220ull,	"Error: CVMX_BGX2_SPU000_INT[%llx][%u]",	0xe210b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e2010220ull,	"Error: CVMX_BGX2_SPU000_INT[%llx][%u]",	0xe210c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e2010220ull,	"Error: CVMX_BGX2_SPU000_INT[%llx][%u]",	0xe210d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e2010220ull,	"Error: CVMX_BGX2_SPU000_INT[%llx][%u]",	0xe210e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e2010310ull,	"Error: CVMX_BGX2_SPU_MEM_INT[%llx][%u]",	0xe2120,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_BUF_DBE<0> */,
 	{ 0x11800e2010310ull,	"Error: CVMX_BGX2_SPU_MEM_INT[%llx][%u]",	0xe2121,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_BUF_DBE<1> */,
 	{ 0x11800e2010310ull,	"Error: CVMX_BGX2_SPU_MEM_INT[%llx][%u]",	0xe2122,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RX_BUF_DBE<2> */,
@@ -3072,11 +3027,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e2110220ull,	"Error: CVMX_BGX2_SPU001_INT[%llx][%u]",	0xe2147,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e2110220ull,	"Error: CVMX_BGX2_SPU001_INT[%llx][%u]",	0xe2148,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e2110220ull,	"Error: CVMX_BGX2_SPU001_INT[%llx][%u]",	0xe2149,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e2110220ull,	"Error: CVMX_BGX2_SPU001_INT[%llx][%u]",	0xe214a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e2110220ull,	"Error: CVMX_BGX2_SPU001_INT[%llx][%u]",	0xe214b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e2110220ull,	"Error: CVMX_BGX2_SPU001_INT[%llx][%u]",	0xe214c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e2110220ull,	"Error: CVMX_BGX2_SPU001_INT[%llx][%u]",	0xe214d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e2110220ull,	"Error: CVMX_BGX2_SPU001_INT[%llx][%u]",	0xe214e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe2180,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe2181,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe2182,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -3087,11 +3037,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe2187,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe2188,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe2189,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe218a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe218b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe218c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe218d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e2210220ull,	"Error: CVMX_BGX2_SPU002_INT[%llx][%u]",	0xe218e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21c0,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21c1,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21c2,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -3102,11 +3047,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21c7,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21c8,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21c9,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21ca,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21cb,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21cc,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21cd,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e2310220ull,	"Error: CVMX_BGX2_SPU003_INT[%llx][%u]",	0xe21ce,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e2020000ull,	"Error: CVMX_BGX2_SMU000_RX_INT[%llx][%u]",	0xe2200,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* JABBER */,
 	{ 0x11800e2020000ull,	"Error: CVMX_BGX2_SMU000_RX_INT[%llx][%u]",	0xe2201,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* FCSERR */,
 	{ 0x11800e2020000ull,	"Error: CVMX_BGX2_SMU000_RX_INT[%llx][%u]",	0xe2202,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RCVERR */,
@@ -3327,11 +3267,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e3010220ull,	"Error: CVMX_BGX3_SPU000_INT[%llx][%u]",	0xe3107,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e3010220ull,	"Error: CVMX_BGX3_SPU000_INT[%llx][%u]",	0xe3108,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e3010220ull,	"Error: CVMX_BGX3_SPU000_INT[%llx][%u]",	0xe3109,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e3010220ull,	"Error: CVMX_BGX3_SPU000_INT[%llx][%u]",	0xe310a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e3010220ull,	"Error: CVMX_BGX3_SPU000_INT[%llx][%u]",	0xe310b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e3010220ull,	"Error: CVMX_BGX3_SPU000_INT[%llx][%u]",	0xe310c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e3010220ull,	"Error: CVMX_BGX3_SPU000_INT[%llx][%u]",	0xe310d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e3010220ull,	"Error: CVMX_BGX3_SPU000_INT[%llx][%u]",	0xe310e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e3010310ull,	"Error: CVMX_BGX3_SPU_MEM_INT[%llx][%u]",	0xe3120,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_BUF_DBE<0> */,
 	{ 0x11800e3010310ull,	"Error: CVMX_BGX3_SPU_MEM_INT[%llx][%u]",	0xe3121,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_BUF_DBE<1> */,
 	{ 0x11800e3010310ull,	"Error: CVMX_BGX3_SPU_MEM_INT[%llx][%u]",	0xe3122,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RX_BUF_DBE<2> */,
@@ -3350,11 +3285,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e3110220ull,	"Error: CVMX_BGX3_SPU001_INT[%llx][%u]",	0xe3147,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e3110220ull,	"Error: CVMX_BGX3_SPU001_INT[%llx][%u]",	0xe3148,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e3110220ull,	"Error: CVMX_BGX3_SPU001_INT[%llx][%u]",	0xe3149,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e3110220ull,	"Error: CVMX_BGX3_SPU001_INT[%llx][%u]",	0xe314a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e3110220ull,	"Error: CVMX_BGX3_SPU001_INT[%llx][%u]",	0xe314b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e3110220ull,	"Error: CVMX_BGX3_SPU001_INT[%llx][%u]",	0xe314c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e3110220ull,	"Error: CVMX_BGX3_SPU001_INT[%llx][%u]",	0xe314d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e3110220ull,	"Error: CVMX_BGX3_SPU001_INT[%llx][%u]",	0xe314e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe3180,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe3181,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe3182,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -3365,11 +3295,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe3187,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe3188,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe3189,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe318a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe318b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe318c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe318d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e3210220ull,	"Error: CVMX_BGX3_SPU002_INT[%llx][%u]",	0xe318e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31c0,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31c1,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31c2,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -3380,11 +3305,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31c7,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31c8,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31c9,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31ca,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31cb,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31cc,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31cd,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e3310220ull,	"Error: CVMX_BGX3_SPU003_INT[%llx][%u]",	0xe31ce,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e3020000ull,	"Error: CVMX_BGX3_SMU000_RX_INT[%llx][%u]",	0xe3200,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* JABBER */,
 	{ 0x11800e3020000ull,	"Error: CVMX_BGX3_SMU000_RX_INT[%llx][%u]",	0xe3201,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* FCSERR */,
 	{ 0x11800e3020000ull,	"Error: CVMX_BGX3_SMU000_RX_INT[%llx][%u]",	0xe3202,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RCVERR */,
@@ -3605,11 +3525,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e4010220ull,	"Error: CVMX_BGX4_SPU000_INT[%llx][%u]",	0xe4107,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e4010220ull,	"Error: CVMX_BGX4_SPU000_INT[%llx][%u]",	0xe4108,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e4010220ull,	"Error: CVMX_BGX4_SPU000_INT[%llx][%u]",	0xe4109,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e4010220ull,	"Error: CVMX_BGX4_SPU000_INT[%llx][%u]",	0xe410a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e4010220ull,	"Error: CVMX_BGX4_SPU000_INT[%llx][%u]",	0xe410b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e4010220ull,	"Error: CVMX_BGX4_SPU000_INT[%llx][%u]",	0xe410c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e4010220ull,	"Error: CVMX_BGX4_SPU000_INT[%llx][%u]",	0xe410d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e4010220ull,	"Error: CVMX_BGX4_SPU000_INT[%llx][%u]",	0xe410e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e4010310ull,	"Error: CVMX_BGX4_SPU_MEM_INT[%llx][%u]",	0xe4120,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_BUF_DBE<0> */,
 	{ 0x11800e4010310ull,	"Error: CVMX_BGX4_SPU_MEM_INT[%llx][%u]",	0xe4121,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_BUF_DBE<1> */,
 	{ 0x11800e4010310ull,	"Error: CVMX_BGX4_SPU_MEM_INT[%llx][%u]",	0xe4122,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RX_BUF_DBE<2> */,
@@ -3628,11 +3543,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e4110220ull,	"Error: CVMX_BGX4_SPU001_INT[%llx][%u]",	0xe4147,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e4110220ull,	"Error: CVMX_BGX4_SPU001_INT[%llx][%u]",	0xe4148,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e4110220ull,	"Error: CVMX_BGX4_SPU001_INT[%llx][%u]",	0xe4149,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e4110220ull,	"Error: CVMX_BGX4_SPU001_INT[%llx][%u]",	0xe414a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e4110220ull,	"Error: CVMX_BGX4_SPU001_INT[%llx][%u]",	0xe414b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e4110220ull,	"Error: CVMX_BGX4_SPU001_INT[%llx][%u]",	0xe414c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e4110220ull,	"Error: CVMX_BGX4_SPU001_INT[%llx][%u]",	0xe414d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e4110220ull,	"Error: CVMX_BGX4_SPU001_INT[%llx][%u]",	0xe414e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe4180,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe4181,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe4182,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -3643,11 +3553,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe4187,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe4188,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe4189,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe418a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe418b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe418c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe418d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e4210220ull,	"Error: CVMX_BGX4_SPU002_INT[%llx][%u]",	0xe418e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41c0,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41c1,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41c2,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -3658,11 +3563,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41c7,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41c8,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41c9,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41ca,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41cb,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41cc,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41cd,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e4310220ull,	"Error: CVMX_BGX4_SPU003_INT[%llx][%u]",	0xe41ce,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e4020000ull,	"Error: CVMX_BGX4_SMU000_RX_INT[%llx][%u]",	0xe4200,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* JABBER */,
 	{ 0x11800e4020000ull,	"Error: CVMX_BGX4_SMU000_RX_INT[%llx][%u]",	0xe4201,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* FCSERR */,
 	{ 0x11800e4020000ull,	"Error: CVMX_BGX4_SMU000_RX_INT[%llx][%u]",	0xe4202,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RCVERR */,
@@ -3883,11 +3783,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e5010220ull,	"Error: CVMX_BGX5_SPU000_INT[%llx][%u]",	0xe5107,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e5010220ull,	"Error: CVMX_BGX5_SPU000_INT[%llx][%u]",	0xe5108,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e5010220ull,	"Error: CVMX_BGX5_SPU000_INT[%llx][%u]",	0xe5109,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e5010220ull,	"Error: CVMX_BGX5_SPU000_INT[%llx][%u]",	0xe510a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e5010220ull,	"Error: CVMX_BGX5_SPU000_INT[%llx][%u]",	0xe510b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e5010220ull,	"Error: CVMX_BGX5_SPU000_INT[%llx][%u]",	0xe510c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e5010220ull,	"Error: CVMX_BGX5_SPU000_INT[%llx][%u]",	0xe510d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e5010220ull,	"Error: CVMX_BGX5_SPU000_INT[%llx][%u]",	0xe510e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e5010310ull,	"Error: CVMX_BGX5_SPU_MEM_INT[%llx][%u]",	0xe5120,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_BUF_DBE<0> */,
 	{ 0x11800e5010310ull,	"Error: CVMX_BGX5_SPU_MEM_INT[%llx][%u]",	0xe5121,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_BUF_DBE<1> */,
 	{ 0x11800e5010310ull,	"Error: CVMX_BGX5_SPU_MEM_INT[%llx][%u]",	0xe5122,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RX_BUF_DBE<2> */,
@@ -3906,11 +3801,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e5110220ull,	"Error: CVMX_BGX5_SPU001_INT[%llx][%u]",	0xe5147,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e5110220ull,	"Error: CVMX_BGX5_SPU001_INT[%llx][%u]",	0xe5148,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e5110220ull,	"Error: CVMX_BGX5_SPU001_INT[%llx][%u]",	0xe5149,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e5110220ull,	"Error: CVMX_BGX5_SPU001_INT[%llx][%u]",	0xe514a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e5110220ull,	"Error: CVMX_BGX5_SPU001_INT[%llx][%u]",	0xe514b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e5110220ull,	"Error: CVMX_BGX5_SPU001_INT[%llx][%u]",	0xe514c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e5110220ull,	"Error: CVMX_BGX5_SPU001_INT[%llx][%u]",	0xe514d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e5110220ull,	"Error: CVMX_BGX5_SPU001_INT[%llx][%u]",	0xe514e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe5180,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe5181,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe5182,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -3921,11 +3811,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe5187,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe5188,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe5189,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe518a,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe518b,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe518c,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe518d,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e5210220ull,	"Error: CVMX_BGX5_SPU002_INT[%llx][%u]",	0xe518e,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51c0,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* RX_LINK_UP */,
 	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51c1,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* RX_LINK_DOWN */,
 	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51c2,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* ERR_BLK */,
@@ -3936,11 +3821,6 @@ struct cvmx_error_78xx error_array_cn78xxp1[] = {
 	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51c7,	0,	CVMX_ERROR_GROUP_ETHERNET,	7}	/* BIP_ERR */,
 	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51c8,	0,	CVMX_ERROR_GROUP_ETHERNET,	8}	/* FEC_CORR */,
 	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51c9,	0,	CVMX_ERROR_GROUP_ETHERNET,	9}	/* FEC_UNCORR */,
-	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51ca,	0,	CVMX_ERROR_GROUP_ETHERNET,	10}	/* AN_PAGE_RX */,
-	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51cb,	0,	CVMX_ERROR_GROUP_ETHERNET,	11}	/* AN_LINK_GOOD */,
-	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51cc,	0,	CVMX_ERROR_GROUP_ETHERNET,	12}	/* AN_COMPLETE */,
-	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51cd,	0,	CVMX_ERROR_GROUP_ETHERNET,	13}	/* TRAINING_DONE */,
-	{ 0x11800e5310220ull,	"Error: CVMX_BGX5_SPU003_INT[%llx][%u]",	0xe51ce,	0,	CVMX_ERROR_GROUP_ETHERNET,	14}	/* TRAINING_FAILURE */,
 	{ 0x11800e5020000ull,	"Error: CVMX_BGX5_SMU000_RX_INT[%llx][%u]",	0xe5200,	0,	CVMX_ERROR_GROUP_ETHERNET,	0}	/* JABBER */,
 	{ 0x11800e5020000ull,	"Error: CVMX_BGX5_SMU000_RX_INT[%llx][%u]",	0xe5201,	0,	CVMX_ERROR_GROUP_ETHERNET,	1}	/* FCSERR */,
 	{ 0x11800e5020000ull,	"Error: CVMX_BGX5_SMU000_RX_INT[%llx][%u]",	0xe5202,	0,	CVMX_ERROR_GROUP_ETHERNET,	2}	/* RCVERR */,
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
index 8e635fd..c11391d 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
@@ -258,7 +258,7 @@ extern void cvmx_helper_bgx_tx_options(unsigned node,
 extern void cvmx_helper_bgx_set_mac(int xipd_port, int bcst, int mcst, uint64_t mac);
 
 
-extern int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres);
+extern int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres, int is_mix);
 extern void cvmx_helper_bgx_set_jabber(int xiface, unsigned index, unsigned size);
 extern int cvmx_helper_bgx_shutdown_port(int xiface, int index);
 extern int cvmx_bgx_set_backpressure_override(int xiface, unsigned port_mask);
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 78a82d6..bc677d9 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -500,10 +500,11 @@ static int bgx_port_probe(struct platform_device *pdev)
 
 	r = dev_set_drvdata(&pdev->dev, priv);
 
+printk("cmrx_config = 0x%lx\n", cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface)));
 	if (priv->phy_np)
-		__cvmx_helper_bgx_port_init(priv->ipd_port, 1);
+		__cvmx_helper_bgx_port_init(priv->ipd_port, 1, 0);
 	else
-		__cvmx_helper_bgx_port_init(priv->ipd_port, 0);
+		__cvmx_helper_bgx_port_init(priv->ipd_port, 0, 0);
 
 	if (r)
 		goto err;
-- 
2.6.2

