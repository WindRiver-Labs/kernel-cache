From da66937399c69e64e42ebadc170eb85695fc6d4f Mon Sep 17 00:00:00 2001
From: Emil <egoranov@caviumnetworks.com>
Date: Thu, 27 Feb 2014 13:46:59 -0800
Subject: [PATCH 605/974] MIPS: OCTEON: Update NAND driver bug fix from S.E.
 sources

Fixed and improved cvmx-nand.c:
+ make sure NDF is realy done for 'read' and 'write' operations
  before releasing the bus;
+ set max debounce delay for BOOT_WAIT_L signal;
+ add wait_cmd before and after BUS_REL cmd according to ONFO/HRN;
+ setup-dma before send Read and Write cmds to NDF_CMD queue

svn_log: r100251 | egoranov | 2014-06-18 20:55:19 -0700

Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-nand.c | 47 +++++++++++++++++++++++++--
 1 file changed, 44 insertions(+), 3 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-nand.c b/arch/mips/cavium-octeon/executive/cvmx-nand.c
index 62dd1ad..b9f9ce5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-nand.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-nand.c
@@ -305,7 +305,8 @@ static inline int __cvmx_nand_select(int select)
 
 	if (OCTEON_IS_OCTEON3()) {
 		mio_boot_ctl.u64 = cvmx_read_csr(CVMX_MIO_BOOT_CTL);
-		cvmx_write_csr(CVMX_MIO_BOOT_CTL, !!select);
+		if (mio_boot_ctl.s.sel != !!select)
+			cvmx_write_csr(CVMX_MIO_BOOT_CTL, !!select);
 		return mio_boot_ctl.s.sel;
 	}
 	return 0;
@@ -669,6 +670,8 @@ cvmx_nand_status_t cvmx_nand_initialize(cvmx_nand_initialize_flags_t flags,
 	/* Bring the fifo out of reset */
 	cvmx_wait_usec(1);
 	ndf_misc.s.rst_ff = 0;
+	/* Try maximum debounce delay */
+	ndf_misc.s.wait_cnt = 0x3f;
 	cvmx_write_csr(CVMX_NDF_MISC, ndf_misc.u64);
 	cvmx_read_csr(CVMX_NDF_MISC);
 	cvmx_wait_usec(1);
@@ -1325,6 +1328,14 @@ static inline cvmx_nand_status_t __cvmx_nand_build_post_cmd(void)
 	if (result)
 		CVMX_NAND_RETURN(result);
 
+	/* Wait with TM_PAR1 */
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.wait.two = 2;
+	cmd.wait.n = 1;
+	result = cvmx_nand_submit(cmd);
+	if (result)
+		CVMX_NAND_RETURN(result);
+
 	/* Send bus release */
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.bus_rel.fifteen = 15;
@@ -1332,6 +1343,14 @@ static inline cvmx_nand_status_t __cvmx_nand_build_post_cmd(void)
 	if (result)
 		CVMX_NAND_RETURN(result);
 
+	/* Wait with TM_PAR5 */
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.wait.two = 2;
+	cmd.wait.n = 5;
+	result = cvmx_nand_submit(cmd);
+	if (result)
+		CVMX_NAND_RETURN(result);
+
 	/* Ring the doorbell */
 	cvmx_write_csr(CVMX_NDF_DRBELL, 1);
 	CVMX_NAND_RETURN(CVMX_NAND_SUCCESS);
@@ -1525,6 +1544,17 @@ static inline int __cvmx_nand_low_level_read(int chip,
 	if (cvmx_unlikely(cvmx_nand_flags & CVMX_NAND_INITIALIZE_FLAGS_DEBUG))
 		__cvmx_nand_hex_dump(buffer_address, bytes);
 
+	/* Make sure NDF is really done */
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_NDF_ST_REG,
+				  cvmx_ndf_st_reg_t,  exe_idle, ==, 1,
+				  NAND_TIMEOUT_USECS_READ)) {
+		WATCHDOG_RESET();
+		status = CVMX_NAND_TIMEOUT;
+		goto error;
+	}
+
+	
+	
 	__cvmx_nand_select(nand_selected);
 	CVMX_NAND_RETURN(bytes);
 
@@ -1689,6 +1719,8 @@ cvmx_nand_status_t cvmx_nand_page_write(int chip, uint64_t nand_address,
 	 */
 	buffer_length &= ~0x7;
 
+	__cvmx_nand_setup_dma(chip, 1, buffer_address, buffer_length);
+
 	/* Build the command and address cycles */
 	status = __cvmx_nand_build_pre_cmd(chip, NAND_COMMAND_PROGRAM,
 					   __cvmx_nand_get_address_cycles(chip),
@@ -1717,8 +1749,6 @@ cvmx_nand_status_t cvmx_nand_page_write(int chip, uint64_t nand_address,
 	if (status)
 		goto done;
 
-	__cvmx_nand_setup_dma(chip, 1, buffer_address, buffer_length);
-
 	/* WAIT for R_B to signal program is complete  */
 	status = __wait_for_busy_done(chip);
 	if (status)
@@ -1737,6 +1767,17 @@ cvmx_nand_status_t cvmx_nand_page_write(int chip, uint64_t nand_address,
 		status = CVMX_NAND_TIMEOUT;
 		goto done;
 	}
+		
+	/* Data transfer is done but NDF is not, it is waiting for R/B# */
+	WATCHDOG_RESET();
+	if (CVMX_WAIT_FOR_FIELD64(CVMX_NDF_ST_REG,
+				  cvmx_ndf_st_reg_t,  exe_idle, ==, 1,
+				  NAND_TIMEOUT_USECS_WRITE)) {
+		WATCHDOG_RESET();
+		status = CVMX_NAND_TIMEOUT;
+		goto done;
+	}
+	
 done:
 	__cvmx_nand_select(nand_selected);
 	CVMX_NAND_RETURN(status);
-- 
2.6.2

