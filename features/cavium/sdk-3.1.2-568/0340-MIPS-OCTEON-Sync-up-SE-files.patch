From 214e15c24afb1334b66ba395d373ce1346e25f8f Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 17 Oct 2013 18:21:07 -0700
Subject: [PATCH 340/974] MIPS: OCTEON: Sync up SE files

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../cavium-octeon/executive/cvmx-error-trees.c     |   24 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |   83 +-
 arch/mips/include/asm/octeon/cvmx-ase-defs.h       |    5 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |    2 +-
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h       |   42 +-
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |   71 +-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  249 ++--
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       |  438 ++++++-
 arch/mips/include/asm/octeon/cvmx-ila-defs.h       |  115 +-
 arch/mips/include/asm/octeon/cvmx-ilk-defs.h       |  100 +-
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |   80 +-
 arch/mips/include/asm/octeon/cvmx-lapx-defs.h      |   64 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      |   62 +-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |   61 +-
 arch/mips/include/asm/octeon/cvmx-mixx-defs.h      |  164 ++-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |    8 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |   18 +-
 arch/mips/include/asm/octeon/cvmx-osm-defs.h       |   23 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |   55 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |  155 ++-
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |  279 +++--
 arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h     |  156 +--
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      |  514 ++++-----
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  330 +++++-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 1215 +++++++++++---------
 arch/mips/include/asm/octeon/cvmx-pow-defs.h       |   96 +-
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |   59 +-
 28 files changed, 2828 insertions(+), 1646 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-error-trees.c b/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
index d3e44da..831e8fe 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
@@ -4093,17 +4093,6 @@ static struct cvmx_error_muxchild error_tree_cn70xx =
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
-				{1, 19 /* nand */, (struct cvmx_error_muxchild[]){
-					{CVMX_ADD_IO_SEG(0x0001070001000020ull) /* CVMX_NDF_INT */, CVMX_ADD_IO_SEG(0x0001070001000028ull) /* CVMX_NDF_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "NDF_INT[WDOG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "NDF_INT[SM_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "NDF_INT[ECC_1BIT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "NDF_INT[ECC_MULT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "NDF_INT[OVRF]"},
-							{0}},
-						NULL /*cvmx_error_childbit*/
-					},
-					{0}}},
 				{1, 29 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
 							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
@@ -4307,7 +4296,7 @@ static struct cvmx_error_muxchild error_tree_cn70xx =
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
-					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
+					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
 							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
 							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
 							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
@@ -4455,17 +4444,6 @@ static struct cvmx_error_muxchild error_tree_cn70xx =
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
-					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "PCSXX_INT_REG(1)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "PCSXX_INT_REG(1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSXX_INT_REG(1)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSXX_INT_REG(1)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSXX_INT_REG(1)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSXX_INT_REG(1)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "PCSXX_INT_REG(1)[DBG_SYNC]"},
-							{0}},
-						NULL /*cvmx_error_childbit*/
-					},
 					{0}}},
 				{1, 34 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 593d3ca..68e8a52 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 89072 $<hr>
+ * <hr>$Revision: 89436 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -644,14 +644,9 @@ retry:
 	/* Disable the peer to peer forwarding register. This must be setup
 	   by the OS after it enumerates the bus and assigns addresses to the
 	   PCIe busses */
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX) ||
-	    OCTEON_IS_MODEL(OCTEON_CN66XX) ||
-	    OCTEON_IS_MODEL(OCTEON_CN68XX) ||
-	    OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-		for (i = 0; i < 4; i++) {
-			cvmx_write_csr(CVMX_PESCX_P2P_BARX_START(i, pcie_port), -1);
-			cvmx_write_csr(CVMX_PESCX_P2P_BARX_END(i, pcie_port), -1);
-		}
+	for (i = 0; i < 4; i++) {
+		cvmx_write_csr(CVMX_PESCX_P2P_BARX_START(i, pcie_port), -1);
+		cvmx_write_csr(CVMX_PESCX_P2P_BARX_END(i, pcie_port), -1);
 	}
 
 	/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
@@ -965,8 +960,17 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 
 	mio_rst_ctl.u64 = cvmx_read_csr(rst_ctl_reg);
 	ep_mode = ((OCTEON_IS_MODEL(OCTEON_CN61XX) ||
-		    OCTEON_IS_MODEL(OCTEON_CNF71XX)) ?
-		(mio_rst_ctl.s.prtmode != 1) : (!mio_rst_ctl.s.host_mode));
+		    OCTEON_IS_MODEL(OCTEON_CNF71XX))
+		? (mio_rst_ctl.s.prtmode != 1) : (!mio_rst_ctl.s.host_mode));
+
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX) && pcie_port) {
+		cvmx_pemx_cfg_t pemx_cfg;
+		pemx_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(0));
+		if ((pemx_cfg.s.md & 3) == 2) {
+			cvmx_dprintf("PCIe: Port %d in 1x4 mode.\n", pcie_port);
+			return -1;
+		}
+	}
 	if (ep_mode) {
 		cvmx_dprintf("PCIe: Port %d in endpoint mode.\n", pcie_port);
 		return -1;
@@ -1187,7 +1191,10 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		__cvmx_increment_ba(&mem_access_subid);
 	}
 
-	if (!OCTEON_IS_MODEL(OCTEON_CN61XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN66XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN68XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 		/* Disable the peer to peer forwarding register. This must be setup
 		   by the OS after it enumerates the bus and assigns addresses to the
 		   PCIe busses */
@@ -1508,6 +1515,8 @@ void cvmx_pcie_cfgx_write(int pcie_port, uint32_t cfg_offset, uint32_t val)
 	}
 }
 
+extern int cvmx_pcie_is_host_mode(int pcie_port);
+
 /**
  * Initialize a PCIe port for use in target(EP) mode.
  *
@@ -1517,25 +1526,8 @@ void cvmx_pcie_cfgx_write(int pcie_port, uint32_t cfg_offset, uint32_t val)
  */
 int cvmx_pcie_ep_initialize(int pcie_port)
 {
-	if (octeon_has_feature(OCTEON_FEATURE_NPEI)) {
-		cvmx_npei_ctl_status_t npei_ctl_status;
-		npei_ctl_status.u64 = cvmx_read_csr(CVMX_PEXP_NPEI_CTL_STATUS);
-		if (npei_ctl_status.s.host_mode)
-			return -1;
-	} else {
-		cvmx_mio_rst_ctlx_t mio_rst_ctl;
-		int ep_mode;
-		uint64_t mio_rst_reg;
-
-		if (OCTEON_IS_OCTEON3())
-			mio_rst_reg = CVMX_RST_CTLX(pcie_port);
-		else
-			mio_rst_reg = CVMX_MIO_RST_CTLX(pcie_port);
-		mio_rst_ctl.u64 = cvmx_read_csr(mio_rst_reg);
-		ep_mode = (OCTEON_IS_MODEL(OCTEON_CN61XX) ? (mio_rst_ctl.s.prtmode != 0) : mio_rst_ctl.s.host_mode);
-		if (ep_mode)
-			return -1;
-	}
+	if (!cvmx_pcie_is_host_mode(pcie_port))
+		return -1;
 
 	/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be programmed */
 	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_0)) {
@@ -1715,3 +1707,32 @@ void cvmx_pcie_wait_for_pending(int pcie_port)
 		}
 	}
 }
+
+/**
+ * Returns if a PCIe port is in host or target mode.
+ *
+ * @param pcie_port PCIe port number (PEM number)
+ *
+ * @return 0 if PCIe port is in target mode, !0 if in host mode.
+ */
+int cvmx_pcie_is_host_mode(int pcie_port)
+{
+	if (OCTEON_IS_OCTEON3()) {
+		cvmx_rst_ctlx_t rst_ctl;
+		rst_ctl.u64 = cvmx_read_csr(CVMX_RST_CTLX(pcie_port));
+		return !!rst_ctl.s.host_mode;
+	} else if (octeon_has_feature(OCTEON_FEATURE_NPEI)) {
+		cvmx_npei_ctl_status_t npei_ctl_status;
+		npei_ctl_status.u64 = cvmx_read_csr(CVMX_PEXP_NPEI_CTL_STATUS);
+		return !!npei_ctl_status.s.host_mode;
+	} else {
+		cvmx_mio_rst_ctlx_t mio_rst_ctl;
+
+		mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(pcie_port));
+		if (OCTEON_IS_MODEL(OCTEON_CN61XX) ||
+		    OCTEON_IS_MODEL(OCTEON_CNF71XX))
+			return mio_rst_ctl.s.prtmode != 0;
+		else
+			return !!mio_rst_ctl.s.host_mode;
+	}
+}
diff --git a/arch/mips/include/asm/octeon/cvmx-ase-defs.h b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
index 9d078ae..5111139 100644
--- a/arch/mips/include/asm/octeon/cvmx-ase-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
@@ -857,9 +857,8 @@ union cvmx_ase_lip_config {
 	struct cvmx_ase_lip_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drop_xoff_en                 : 1;  /**< If enabled, the LIP pays attention to the LAP's DROP_XOFF indication and may drop the
-                                                         indicated lookup request packets. If disabled, the LIP ignores DROP_XOFF and does not drop
-                                                         packets. */
+	uint64_t drop_xoff_en                 : 1;  /**< This feature should remain disabled.
+                                                         INTERNAL: Keep disabled, bug 18665. */
 	uint64_t gen_xon_en                   : 1;  /**< If enabled, the LIP generates XON indication to the LAP when lookup requests are
                                                          backpressured. If disabled, the LIP does not assert XON. */
 	uint64_t reserved_1_1                 : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index d9d460b..af45ce9 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -7233,7 +7233,7 @@ union cvmx_bgxx_spu_dbg_control {
                                                          40GBASE-R), this field specifies the expected alignment marker receive period per lane,
                                                          i.e. the expected number of received 66b non-marker blocks between consecutive markers on
                                                          the same lane. The default value corresponds to a period of 16363 blocks (exclusive) as
-                                                         specified in 802.3ba-2010. */
+                                                         specified in 802.3ba-2010. Must be greater than 64. */
 #else
 	uint64_t marker_rxp                   : 15;
 	uint64_t reserved_15_15               : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index 73f35f3..7a99cc6 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -916,6 +916,17 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 #endif
 #define CVMX_CIU_PP_RST (CVMX_ADD_IO_SEG(0x0001070000000700ull))
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_CIU_PP_RST_PENDING CVMX_CIU_PP_RST_PENDING_FUNC()
+static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_CIU_PP_RST_PENDING not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070000000740ull);
+}
+#else
+#define CVMX_CIU_PP_RST_PENDING (CVMX_ADD_IO_SEG(0x0001070000000740ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_CIU_QLM0 CVMX_CIU_QLM0_FUNC()
 static inline uint64_t CVMX_CIU_QLM0_FUNC(void)
 {
@@ -12550,7 +12561,12 @@ typedef union cvmx_ciu_pp_pokex cvmx_ciu_pp_pokex_t;
  *
  * Contains the reset control for each PP.  Value of '1' will hold a PP in reset, '0' will
  * release.
- * Resets to all 1's when PCI boot is enabled, 0xe otherwise.
+ * Resets to all 1's when REMOTE_BOOT is enabled, 0xe otherwise.  Writes to this register should
+ * occur
+ * only if the CIU_PP_RST_PENDING register is cleared.
+ * On pass 2, RST_PP_POWER register can be statically set and writes to this register will
+ * automatically enable/disable power
+ * saving when RST_PP_POWER[GATE] is enabled.
  */
 union cvmx_ciu_pp_rst {
 	uint64_t u64;
@@ -12664,6 +12680,30 @@ union cvmx_ciu_pp_rst {
 typedef union cvmx_ciu_pp_rst cvmx_ciu_pp_rst_t;
 
 /**
+ * cvmx_ciu_pp_rst_pending
+ *
+ * This register contains the reset status for each core. A 1 indicated the core is waiting to
+ * change it's reset state.
+ * (Pass 2) Normally a reset change occurs immediately but if RST_PP_POWER[GATE] bit is set and
+ * the core is released from reset
+ * a delay of 64K core clocks per PP will occur to satisify power management.
+ */
+union cvmx_ciu_pp_rst_pending {
+	uint64_t u64;
+	struct cvmx_ciu_pp_rst_pending_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t pend                         : 48; /**< Core waiting on reset to deassert complete.  This register always returns zero on 70xx Pass 1. */
+#else
+	uint64_t pend                         : 48;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_ciu_pp_rst_pending_s      cn70xx;
+};
+typedef union cvmx_ciu_pp_rst_pending cvmx_ciu_pp_rst_pending_t;
+
+/**
  * cvmx_ciu_qlm0
  *
  * Notes:
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index 9fa5b4b..e5a3b59 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -218,17 +218,6 @@ static inline uint64_t CVMX_CIU3_INTR_SLOWDOWN_FUNC(void)
 #define CVMX_CIU3_INTR_SLOWDOWN (CVMX_ADD_IO_SEG(0x0001010000000240ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_CIU3_INT_DBG_SEL CVMX_CIU3_INT_DBG_SEL_FUNC()
-static inline uint64_t CVMX_CIU3_INT_DBG_SEL_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_CIU3_INT_DBG_SEL not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001010000000200ull);
-}
-#else
-#define CVMX_CIU3_INT_DBG_SEL (CVMX_ADD_IO_SEG(0x0001010000000200ull))
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_CIU3_ISCMEM_BASE CVMX_CIU3_ISCMEM_BASE_FUNC()
 static inline uint64_t CVMX_CIU3_ISCMEM_BASE_FUNC(void)
 {
@@ -368,11 +357,22 @@ union cvmx_ciu3_bist {
 	uint64_t u64;
 	struct cvmx_ciu3_bist_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_7_63                : 57;
-	uint64_t bist                         : 7;  /**< BIST results. Hardware sets a bit for each memory that fails BIST. */
-#else
-	uint64_t bist                         : 7;
-	uint64_t reserved_7_63                : 57;
+	uint64_t reserved_11_63               : 53;
+	uint64_t bist                         : 11; /**< BIST results. Hardware sets a bit for each memory that fails BIST. INTERNAL:
+                                                         <10>= ncbo_crd_fif_mem0.
+                                                         <9> = ciu_nbt_sso_req_ram.
+                                                         <8> = ciu_nbt_rsp_ram.
+                                                         <7> = ciu_sso_output_fifo_mem.
+                                                         <6> = ciu_isc_ram2.
+                                                         <5> = ciu_isc_ram1.
+                                                         <4> = ciu_isc_ram0.
+                                                         <3> = ciu_sist_ram.
+                                                         <2> = ciu_idt_ram.
+                                                         <1> = csr req_mem.
+                                                         <0> = ciu3_wdg_ctl_mem. */
+#else
+	uint64_t bist                         : 11;
+	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
 	struct cvmx_ciu3_bist_s               cn78xx;
@@ -627,37 +627,6 @@ union cvmx_ciu3_idtx_ppx {
 typedef union cvmx_ciu3_idtx_ppx cvmx_ciu3_idtx_ppx_t;
 
 /**
- * cvmx_ciu3_int_dbg_sel
- */
-union cvmx_ciu3_int_dbg_sel {
-	uint64_t u64;
-	struct cvmx_ciu3_int_dbg_sel_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_19_63               : 45;
-	uint64_t sel                          : 3;  /**< Selects if all or the specific interrupt is presented on the debug port.
-                                                         0x0 = erst_n
-                                                         0x1 = start_bist
-                                                         0x2 = toggle at coprocessor clock/2 frequency
-                                                         0x3 = All core interrupt bits are ORed together
-                                                         0x4 = Only the selected virtual core/IRQ is selected */
-	uint64_t reserved_10_15               : 6;
-	uint64_t irq                          : 2;  /**< Which IRQ to select: 0x0=IRQ2, 0x1=IRQ3, 0x2=IRQ4. */
-	uint64_t reserved_6_7                 : 2;
-	uint64_t pp                           : 6;  /**< Which core to select. */
-#else
-	uint64_t pp                           : 6;
-	uint64_t reserved_6_7                 : 2;
-	uint64_t irq                          : 2;
-	uint64_t reserved_10_15               : 6;
-	uint64_t sel                          : 3;
-	uint64_t reserved_19_63               : 45;
-#endif
-	} s;
-	struct cvmx_ciu3_int_dbg_sel_s        cn78xx;
-};
-typedef union cvmx_ciu3_int_dbg_sel cvmx_ciu3_int_dbg_sel_t;
-
-/**
  * cvmx_ciu3_intr_ram_ecc_ctl
  */
 union cvmx_ciu3_intr_ram_ecc_ctl {
@@ -749,12 +718,12 @@ union cvmx_ciu3_intr_slowdown {
 	uint64_t ctl                          : 3;  /**< Slow down CIU interrupt walker processing time. IRQ2/3/4 for all cores are sent to the
                                                          core (MRC) in a serial bus to reduce global routing. There is no backpressure mechanism
                                                          designed for this scheme. It will only be a problem when SCLK is faster; this Control will
-                                                         process 1 interrupt in 2^CTL SCLK cycles. With different a setting, clock rate ratio can
+                                                         process 1 interrupt in 4*2^CTL SCLK cycles. With different a setting, clock rate ratio can
                                                          handle:
                                                          SLOWDOWN sclk_freq/aclk_freq ratio
-                                                         0 3
-                                                         1 6
-                                                         n 3*2n */
+                                                         0 4
+                                                         1 8
+                                                         n 4*2^n */
 #else
 	uint64_t ctl                          : 3;
 	uint64_t reserved_3_63                : 61;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index a989e68..3441908 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -3289,7 +3289,7 @@ union cvmx_fpa_poolx_op_pc {
 	uint64_t u64;
 	struct cvmx_fpa_poolx_op_pc_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of allocations or returns performed to this poolFPA_POOL(0..63)_STACK_BASE. */
+	uint64_t count                        : 64; /**< Number of allocations or returns performed to this pool, including those that fail due to RED. */
 #else
 	uint64_t count                        : 64;
 #endif
@@ -3718,7 +3718,9 @@ union cvmx_fpa_sft_rst {
 	uint64_t busy                         : 1;  /**< When 1, FPA is busy completing reset. No access except the reading of this bit should
                                                          occur to the FPA until this is clear. */
 	uint64_t reserved_1_62                : 62;
-	uint64_t rst                          : 1;  /**< Reset. When set to 1 by software, FPA gets a short reset pulse (three cycles in duration). */
+	uint64_t rst                          : 1;  /**< Reset. When set to 1 by software, FPA gets a short reset pulse (three cycles in duration).
+                                                         Following a write to this register and prior to performing another FPA operation, software
+                                                         must write SSO_BIST_STATUS0 (or any register on the same IOI bus as FPA) and read it back. */
 #else
 	uint64_t rst                          : 1;
 	uint64_t reserved_1_62                : 62;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 13089cd..c2e533b 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -2523,70 +2523,70 @@ union cvmx_gserx_lanex_px_mode_0 {
                                                          0x2 = ~15dB of peaking at 5.5 GHz
                                                          0x3 = ~20dB of peaking at 6 GHz (Maximum bandwidth).
                                                          Recommended settings:
-                                                         25G_REFCLK100: 0x0
-                                                         5G_REFCLK100: 0x0
-                                                         8G_REFCLK100: 0x3
-                                                         125G_REFCLK15625_KX: 0x0
-                                                         3125G_REFCLK15625_XAUI: 0x0
-                                                         103215G_REFCLK15625_KR: 0x3
-                                                         125G_REFCLK15625_SGMII: 0x0
-                                                         5G_REFCLK15625_QSGMII: 0x0
-                                                         625G_REFCLK15625_RXAUI: 0x0
-                                                         25G_REFCLK125: 0x0
-                                                         5G_REFCLK125: 0x0
-                                                         8G_REFCLK125: 0x3 */
+                                                         R_25G_REFCLK100: 0x0
+                                                         R_5G_REFCLK100: 0x0
+                                                         R_8G_REFCLK100: 0x3
+                                                         R_125G_REFCLK15625_KX: 0x0
+                                                         R_3125G_REFCLK15625_XAUI: 0x0
+                                                         R_103215G_REFCLK15625_KR: 0x3
+                                                         R_125G_REFCLK15625_SGMII: 0x0
+                                                         R_5G_REFCLK15625_QSGMII: 0x0
+                                                         R_625G_REFCLK15625_RXAUI: 0x0
+                                                         R_25G_REFCLK125: 0x0
+                                                         R_5G_REFCLK125: 0x0
+                                                         R_8G_REFCLK125: 0x3 */
 	uint64_t pcie                         : 1;  /**< Selects between RX terminations.
                                                          - 0: Differential termination
                                                          - 1: Termination between pad and SDS_VDDS.
                                                           Recommended settings:
-                                                          25G_REFCLK100: 0x1
-                                                          5G_REFCLK100: 0x1
-                                                          8G_REFCLK100: 0x0
-                                                          125G_REFCLK15625_KX: 0x0
-                                                          3125G_REFCLK15625_XAUI: 0x0
-                                                          103215G_REFCLK15625_KR: 0x0
-                                                          125G_REFCLK15625_SGMII: 0x0
-                                                          5G_REFCLK15625_QSGMII: 0x0
-                                                          625G_REFCLK15625_RXAUI: 0x0
-                                                          25G_REFCLK125: 0x1
-                                                          5G_REFCLK125: 0x1
-                                                          8G_REFCLK125: 0x0 */
+                                                          R_25G_REFCLK100: 0x1
+                                                          R_5G_REFCLK100: 0x1
+                                                          R_8G_REFCLK100: 0x0
+                                                          R_125G_REFCLK15625_KX: 0x0
+                                                          R_3125G_REFCLK15625_XAUI: 0x0
+                                                          R_103215G_REFCLK15625_KR: 0x0
+                                                          R_125G_REFCLK15625_SGMII: 0x0
+                                                          R_5G_REFCLK15625_QSGMII: 0x0
+                                                          R_625G_REFCLK15625_RXAUI: 0x0
+                                                          R_25G_REFCLK125: 0x1
+                                                          R_5G_REFCLK125: 0x1
+                                                          R_8G_REFCLK125: 0x0 */
 	uint64_t tx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate. Encoding is:
                                                          0x0 = full data rate.
                                                          0x1 = 1/2 data rate.
                                                          0x2 = 1/4 data rate.
                                                          0x3 = 1/8 data rate.
                                                          Recommended settings:
-                                                         25G_REFCLK100: 0x1
-                                                         5G_REFCLK100: 0x0
-                                                         8G_REFCLK100: 0x0
-                                                         125G_REFCLK15625_KX: 0x2
-                                                         3125G_REFCLK15625_XAUI: 0x1
-                                                         103215G_REFCLK15625_KR: 0x0
-                                                         125G_REFCLK15625_SGMII: 0x2
-                                                         5G_REFCLK15625_QSGMII: 0x0
-                                                         625G_REFCLK15625_RXAUI: 0x0
-                                                         25G_REFCLK125: 0x1
-                                                         5G_REFCLK125: 0x0
-                                                         8G_REFCLK125: 0x0 */
+                                                         R_25G_REFCLK100: 0x1
+                                                         R_5G_REFCLK100: 0x0
+                                                         R_8G_REFCLK100: 0x0
+                                                         R_125G_REFCLK15625_KX: 0x2
+                                                         R_3125G_REFCLK15625_XAUI: 0x1
+                                                         R_103215G_REFCLK15625_KR: 0x0
+                                                         R_125G_REFCLK15625_SGMII: 0x2
+                                                         R_5G_REFCLK15625_QSGMII: 0x0
+                                                         R_625G_REFCLK15625_RXAUI: 0x0
+                                                         R_25G_REFCLK125: 0x1
+                                                         R_5G_REFCLK125: 0x0
+                                                         R_8G_REFCLK125: 0x0 */
 	uint64_t rx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate. Encoding is:
                                                          0x0 = full data rate
                                                          0x1 = 1/2 data rate
                                                          0x2 = 1/4 data rate
                                                          0x3 = 1/8 data rate
                                                          Recommended settings:
-                                                         25G_REFCLK100: 0x1
-                                                         5G_REFCLK100: 0x0
-                                                         8G_REFCLK100: 0x0
-                                                         125G_REFCLK15625_KX: 0x2
-                                                         3125G_REFCLK15625_XAUI: 0x1
-                                                         103215G_REFCLK15625_KR: 0x0
-                                                         125G_REFCLK15625_SGMII: 0x2
-                                                         5G_REFCLK15625_QSGMII: 0x0
-                                                         625G_REFCLK15625_RXAUI: 0x0
-                                                         25G_REFCLK125: 0x1
-                                                         5G_REFCLK125: 0x0
-                                                         8G_REFCLK125: 0x0 */
+                                                         R_25G_REFCLK100: 0x1
+                                                         R_5G_REFCLK100: 0x0
+                                                         R_8G_REFCLK100: 0x0
+                                                         R_125G_REFCLK15625_KX: 0x2
+                                                         R_3125G_REFCLK15625_XAUI: 0x1
+                                                         R_103215G_REFCLK15625_KR: 0x0
+                                                         R_125G_REFCLK15625_SGMII: 0x2
+                                                         R_5G_REFCLK15625_QSGMII: 0x0
+                                                         R_625G_REFCLK15625_RXAUI: 0x0
+                                                         R_25G_REFCLK125: 0x1
+                                                         R_5G_REFCLK125: 0x0
+                                                         R_8G_REFCLK125: 0x0 */
 	uint64_t srate                        : 3;  /**< Sample rate, used to generate strobe to effectively divide the clock down to a slower
                                                          rate. Encoding is:
                                                          0x0 = Full rate
@@ -2641,31 +2641,31 @@ union cvmx_gserx_lanex_px_mode_1 {
                                                          0 = Adaptive DFE (5 Gbps and higher)
                                                          1 = Manual DFE, fixed tap (3.125 Gbps and lower). */
 	uint64_t cdr_fgain                    : 4;  /**< CDR frequency gain. Values at reset:
-                                                         25G_REFCLK100: 0xA
-                                                         5G_REFCLK100: 0xA
-                                                         8G_REFCLK100: 0xB
-                                                         125G_REFCLK15625_KX: 0xC
-                                                         3125G_REFCLK15625_XAUI: 0xC
-                                                         103215G_REFCLK15625_KR: 0xA
-                                                         125G_REFCLK15625_SGMII: 0xC
-                                                         5G_REFCLK15625_QSGMII: 0xC
-                                                         625G_REFCLK15625_RXAUI: 0xA
-                                                         25G_REFCLK125: 0xA
-                                                         5G_REFCLK125: 0xA
-                                                         8G_REFCLK125: 0xB */
+                                                         R_25G_REFCLK100: 0xA
+                                                         R_5G_REFCLK100: 0xA
+                                                         R_8G_REFCLK100: 0xB
+                                                         R_125G_REFCLK15625_KX: 0xC
+                                                         R_3125G_REFCLK15625_XAUI: 0xC
+                                                         R_103215G_REFCLK15625_KR: 0xA
+                                                         R_125G_REFCLK15625_SGMII: 0xC
+                                                         R_5G_REFCLK15625_QSGMII: 0xC
+                                                         R_625G_REFCLK15625_RXAUI: 0xA
+                                                         R_25G_REFCLK125: 0xA
+                                                         R_5G_REFCLK125: 0xA
+                                                         R_8G_REFCLK125: 0xB */
 	uint64_t ph_acc_adj                   : 10; /**< Phase accumulator adjust. Values at reset:
-                                                         25G_REFCLK100: 0x14
-                                                         5G_REFCLK100: 0x14
-                                                         8G_REFCLK100: 0x23
-                                                         125G_REFCLK15625_KX: 0x1E
-                                                         3125G_REFCLK15625_XAUI: 0x1E
-                                                         103215G_REFCLK15625_KR: 0xF
-                                                         125G_REFCLK15625_SGMII: 0x1E
-                                                         5G_REFCLK15625_QSGMII: 0x1E
-                                                         625G_REFCLK15625_RXAUI: 0x14
-                                                         25G_REFCLK125: 0x14
-                                                         5G_REFCLK125: 0x14
-                                                         8G_REFCLK125: 0x23 */
+                                                         R_25G_REFCLK100: 0x14
+                                                         R_5G_REFCLK100: 0x14
+                                                         R_8G_REFCLK100: 0x23
+                                                         R_125G_REFCLK15625_KX: 0x1E
+                                                         R_3125G_REFCLK15625_XAUI: 0x1E
+                                                         R_103215G_REFCLK15625_KR: 0xF
+                                                         R_125G_REFCLK15625_SGMII: 0x1E
+                                                         R_5G_REFCLK15625_QSGMII: 0x1E
+                                                         R_625G_REFCLK15625_RXAUI: 0x14
+                                                         R_25G_REFCLK125: 0x14
+                                                         R_5G_REFCLK125: 0x14
+                                                         R_8G_REFCLK125: 0x23 */
 #else
 	uint64_t ph_acc_adj                   : 10;
 	uint64_t cdr_fgain                    : 4;
@@ -3135,21 +3135,21 @@ union cvmx_gserx_lane_mode {
 	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), used to index into the PHY
                                                          table to select electrical specs and link rate. Note that the PHY table can be modified
                                                          such that any supported link rate can be derived regardless of the configured LMODE.
-                                                         0x0: 25G_REFCLK100
-                                                         0x1: 5G_REFCLK100
-                                                         0x2: 8G_REFCLK100
-                                                         0x3: 125G_REFCLK15625_KX
-                                                         0x4: 3125G_REFCLK15625_XAUI
-                                                         0x5: 103215G_REFCLK15625_KR
-                                                         0x6: 125G_REFCLK15625_SGMII
-                                                         0x7: 5G_REFCLK15625_QSGMII
-                                                         0x8: 625G_REFCLK15625_RXAUI
-                                                         0x9: 25G_REFCLK125
-                                                         0xA: 5G_REFCLK125
-                                                         0xB: 8G_REFCLK125
+                                                         0x0: R_25G_REFCLK100
+                                                         0x1: R_5G_REFCLK100
+                                                         0x2: R_8G_REFCLK100
+                                                         0x3: R_125G_REFCLK15625_KX
+                                                         0x4: R_3125G_REFCLK15625_XAUI
+                                                         0x5: R_103215G_REFCLK15625_KR
+                                                         0x6: R_125G_REFCLK15625_SGMII
+                                                         0x7: R_5G_REFCLK15625_QSGMII
+                                                         0x8: R_625G_REFCLK15625_RXAUI
+                                                         0x9: R_25G_REFCLK125
+                                                         0xA: R_5G_REFCLK125
+                                                         0xB: R_8G_REFCLK125
                                                          0xC - 0xF: reserved
                                                          This register is not used for PCIE configurations. For non-OCI links, this registers
-                                                         defaults to 625G_REFCLK15625_RXAUI. For OCI links, the value is mapped at reset from the
+                                                         defaults to R_625G_REFCLK15625_RXAUI. For OCI links, the value is mapped at reset from the
                                                          GSER_SPD and the appropriate table updates are performed so the rate is obtained for the
                                                          particular reference clock.
                                                          It is recommended that the PHY be in reset when reconfiguring the LMODE
@@ -3359,18 +3359,18 @@ union cvmx_gserx_pcie_pipe_port_sel {
 	struct cvmx_gserx_pcie_pipe_port_sel_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t cfg_pem1_dlm2                : 1;  /**< The PIPE/PHY configuration for PEM1 when in 4-Pipe Mode.
-                                                          Used as status for determining which DLM PEM1 is tied to.
+	uint64_t cfg_pem1_dlm2                : 1;  /**< The PIPE (Pipe1 or Pipe2) and PHY (DLM1 or DLM2) configuration for PEM1
+                                                          when in 4-Pipe Mode.
                                                           This bit should not be set in Single Pipe or 2-Pipe Mode.
-                                                         - 0: PEM1 is tied to DLM1.  This is 3x1 PCIe mode when all 4 PIPES are enabled.
-                                                         - 1: PEM1 is tied to DLM2.  This is 2x1 PCIe mode with SATA */
+                                                         - 0: PEM1 is tied to Pipe1/DLM1.  This is 3x1 PCIe mode when all 4 PIPES are enabled.
+                                                         - 1: PEM1 is tied to Pipe2/DLM2.  This is 2x1 PCIe mode with SATA */
 	uint64_t pipe_port_sel                : 2;  /**< PIPE enable request.  Change only when phy_reset is asserted.
                                                          - 00: Disables all PIPEs
-                                                         - 01: Single Pipe Mode. Enables PIPE0 only.
+                                                         - 01: Single Pipe Mode. Enables PIPE0 (PEM0) only.
                                                              This is 1x4 PCIe mode.
-                                                         - 10: 2-Pipe Mode.  Enables PIPEs 0 and 1.
+                                                         - 10: 2-Pipe Mode.  Enables PIPEs 0 (PEM0) and 1 (PEM1).
                                                              This is 2x2 PCIe mode or 1x2 PCIe mode with SATA.
-                                                         - 11: 4-Pipe Mode. Enables PIPEs 0, 1, 2, and 3.
+                                                         - 11: 4-Pipe Mode. Enables PIPEs 0 (PEM0), 1, 2 (PEM1), and 3 (PEM2).
                                                              This is 2x1 PCIe mode with SATA or 3x1 PCIe mode. */
 #else
 	uint64_t pipe_port_sel                : 2;
@@ -3393,10 +3393,15 @@ union cvmx_gserx_pcie_pipe_rst {
 	struct cvmx_gserx_pcie_pipe_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t pipe3_rst                    : 1;  /**< Pipe 3 Reset.  Setting this bit will put Pipe 3 into reset. */
-	uint64_t pipe2_rst                    : 1;  /**< Pipe 2 Reset.  Setting this bit will put Pipe 2 into reset. */
-	uint64_t pipe1_rst                    : 1;  /**< Pipe 1 Reset.  Setting this bit will put Pipe 1 into reset. */
-	uint64_t pipe0_rst                    : 1;  /**< Pipe 0 Reset.  Setting this bit will put Pipe 0 into reset. */
+	uint64_t pipe3_rst                    : 1;  /**< Pipe 3 Reset.  Setting this bit will put Pipe 3 into reset.
+                                                         PEM2 is always tied to Pipe 3. */
+	uint64_t pipe2_rst                    : 1;  /**< Pipe 2 Reset.  Setting this bit will put Pipe 2 into reset.
+                                                         PEM1 is tied to Pipe 2 in 3x1 PCIe mode (GSER_PCIE_PIPE_PORT_SEL.PIPE_PORT_SEL
+                                                         is set to 4-pipe mode, and GSER_PCIE_PIPE_PORT_SEL.CFG_PEM1_DLM2 is also set). */
+	uint64_t pipe1_rst                    : 1;  /**< Pipe 1 Reset.  Setting this bit will put Pipe 1 into reset.
+                                                         PEM1 is tied to Pipe 1 in 2x2 PCIe or 2x1 PCIe with SATA modes. */
+	uint64_t pipe0_rst                    : 1;  /**< Pipe 0 Reset.  Setting this bit will put Pipe 0 into reset.
+                                                         PEM0 is always tied to Pipe 0. */
 #else
 	uint64_t pipe0_rst                    : 1;
 	uint64_t pipe1_rst                    : 1;
@@ -3422,20 +3427,23 @@ union cvmx_gserx_pcie_pipe_rst_sts {
 	uint64_t reserved_4_63                : 60;
 	uint64_t pipe3_rst                    : 1;  /**< Reflects the current state of the pipe3_rst_n which includes
                                                          the rst__pem2_pcs_rst_n term from the reset controller.  Note that
-                                                         when PIPE3_RST is asserted, no Pipe clocks are generated to PEM3 and
-                                                         any RSL reads to the application side registers will time out. */
+                                                         when PIPE3_RST is asserted (active low), no Pipe clocks are generated
+                                                         to PEM3 and any RSL reads to the application side registers will time out. */
 	uint64_t pipe2_rst                    : 1;  /**< Reflects the current state of the pipe2_rst_n which includes
                                                          the rst__pem2_pcs_rst_n term from the reset controller.  Note that
-                                                         when PIPE2_RST is asserted, no Pipe clocks are generated to PEM1 and
-                                                         any RSL reads to the application side registers will time out. */
+                                                         when PIPE2_RST is asserted (active low) and PEM1 is being used in
+                                                         3x1 PCIe mode (4-Pipe Mode with CFG_PEM1_DLM2 set), no Pipe clocks
+                                                         are generated to PEM1 and any RSL reads to the application side
+                                                         registers will time out. */
 	uint64_t pipe1_rst                    : 1;  /**< Reflects the current state of the pipe1_rst_n which includes
                                                          the rst__pem1_pcs_rst_n term from the reset controller.  Note that
-                                                         when PIPE1_RST is asserted, no Pipe clocks are generated to PEM1 and
-                                                         any RSL reads to the application side registers will time out. */
+                                                         when PIPE1_RST is asserted (active low) and PEM1 is being used in
+                                                         2x2 PCIe or 2x1 PCIe with SATA, no Pipe clocks are generated to PEM1
+                                                         and any RSL reads to the application side registers will time out. */
 	uint64_t pipe0_rst                    : 1;  /**< Reflects the current state of the pipe0_rst_n which includes
                                                          the rst__pem0_pcs_rst_n term from the reset controller.  Note that
-                                                         when PIPE0_RST is asserted, no Pipe clocks are generated to PEM0 and
-                                                         any RSL reads to the application side registers will time out. */
+                                                         when PIPE0_RST is asserted (active low), no Pipe clocks are generated
+                                                         to PEM0 and any RSL reads to the application side registers will time out. */
 #else
 	uint64_t pipe0_rst                    : 1;
 	uint64_t pipe1_rst                    : 1;
@@ -4005,8 +4013,7 @@ union cvmx_gserx_pll_px_mode_0 {
                                                          1.25G: 0x28
                                                          2.5G: 0x5
                                                          3.125G: 0x24
-                                                         5.0G: 0xA (100 MHz REFCLK)
-                                                         5.0G: 0x5 (156.25 MHz REFCLK)
+                                                         5.0G: 0xA
                                                          6.25G: 0xA
                                                          8.0G: 0xA
                                                          10.3215G: 0x24 */
@@ -4697,21 +4704,21 @@ union cvmx_gserx_spd {
                                                          settings of the specific lane mode (LMODE) table entry to derive the correct link rate.
                                                          For non-OCI links, this field is not used.
                                                          config  refclk      link rate       LMODE
-                                                         0x0:    100Mhz      1.25Gbps        125G_REFCLK15625_KX
-                                                         0x1:    100Mhz      2.5Gbps         25G_REFCLK100
-                                                         0x2:    100Mhz      5Gbps           5G_REFCLK100
-                                                         0x3:    100Mhz      8Gbps           8G_REFCLK100
-                                                         0x4:    125Mhz      1.25Gbps        125G_REFCLK15625_KX
-                                                         0x5:    125Mhz      2.5Gbps         25G_REFCLK125
-                                                         0x6:    125Mhz      3.125Gbps       3125G_REFCLK15625_XAUI
-                                                         0x7:    125Mhz      5Gbps           5G_REFCLK125
-                                                         0x8:    125Mhz      6.25Gbps        625G_REFCLK15625_RXAUI
-                                                         0x9:    125Mhz      8Gbps           8G_REFCLK125
-                                                         0xA:    156.25Mhz   2.5Gbps         25G_REFCLK100
-                                                         0xB:    156.25Mhz   3.125Gbps       3125G_REFCLK15625_XAUI
-                                                         0xC:    156.25Mhz   5Gbps           5G_REFCLK125
-                                                         0xD:    156.25Mhz   6.25Gbps        625G_REFCLK15625_RXAUI
-                                                         0xE:    126.25Mhz   10.3125Gbps     103215G_REFCLK15625_KR
+                                                         0x0:    100Mhz      1.25Gbps        R_125G_REFCLK15625_KX
+                                                         0x1:    100Mhz      2.5Gbps         R_25G_REFCLK100
+                                                         0x2:    100Mhz      5Gbps           R_5G_REFCLK100
+                                                         0x3:    100Mhz      8Gbps           R_8G_REFCLK100
+                                                         0x4:    125Mhz      1.25Gbps        R_125G_REFCLK15625_KX
+                                                         0x5:    125Mhz      2.5Gbps         R_25G_REFCLK125
+                                                         0x6:    125Mhz      3.125Gbps       R_3125G_REFCLK15625_XAUI
+                                                         0x7:    125Mhz      5Gbps           R_5G_REFCLK125
+                                                         0x8:    125Mhz      6.25Gbps        R_625G_REFCLK15625_RXAUI
+                                                         0x9:    125Mhz      8Gbps           R_8G_REFCLK125
+                                                         0xA:    156.25Mhz   2.5Gbps         R_25G_REFCLK100
+                                                         0xB:    156.25Mhz   3.125Gbps       R_3125G_REFCLK15625_XAUI
+                                                         0xC:    156.25Mhz   5Gbps           R_5G_REFCLK125
+                                                         0xD:    156.25Mhz   6.25Gbps        R_625G_REFCLK15625_RXAUI
+                                                         0xE:    126.25Mhz   10.3125Gbps     R_103215G_REFCLK15625_KR
                                                          0xF:    SW_MODE
                                                          Note that a value of 0xF is called SW_MODE. The OCI link does not come up configured.
                                                          Software can come up and configure the interface at a later time. */
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index befa49b..b802478 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -174,6 +174,105 @@ static inline uint64_t CVMX_HNA_HPU_EIR_FUNC(void)
 #define CVMX_HNA_HPU_EIR (CVMX_ADD_IO_SEG(0x0001180047000018ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC0_CNT CVMX_HNA_PFC0_CNT_FUNC()
+static inline uint64_t CVMX_HNA_PFC0_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC0_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000090ull);
+}
+#else
+#define CVMX_HNA_PFC0_CNT (CVMX_ADD_IO_SEG(0x0001180047000090ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC0_CTL CVMX_HNA_PFC0_CTL_FUNC()
+static inline uint64_t CVMX_HNA_PFC0_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC0_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000088ull);
+}
+#else
+#define CVMX_HNA_PFC0_CTL (CVMX_ADD_IO_SEG(0x0001180047000088ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC1_CNT CVMX_HNA_PFC1_CNT_FUNC()
+static inline uint64_t CVMX_HNA_PFC1_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC1_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800470000A0ull);
+}
+#else
+#define CVMX_HNA_PFC1_CNT (CVMX_ADD_IO_SEG(0x00011800470000A0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC1_CTL CVMX_HNA_PFC1_CTL_FUNC()
+static inline uint64_t CVMX_HNA_PFC1_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC1_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000098ull);
+}
+#else
+#define CVMX_HNA_PFC1_CTL (CVMX_ADD_IO_SEG(0x0001180047000098ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC2_CNT CVMX_HNA_PFC2_CNT_FUNC()
+static inline uint64_t CVMX_HNA_PFC2_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC2_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800470000B0ull);
+}
+#else
+#define CVMX_HNA_PFC2_CNT (CVMX_ADD_IO_SEG(0x00011800470000B0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC2_CTL CVMX_HNA_PFC2_CTL_FUNC()
+static inline uint64_t CVMX_HNA_PFC2_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC2_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800470000A8ull);
+}
+#else
+#define CVMX_HNA_PFC2_CTL (CVMX_ADD_IO_SEG(0x00011800470000A8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC3_CNT CVMX_HNA_PFC3_CNT_FUNC()
+static inline uint64_t CVMX_HNA_PFC3_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC3_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800470000C0ull);
+}
+#else
+#define CVMX_HNA_PFC3_CNT (CVMX_ADD_IO_SEG(0x00011800470000C0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC3_CTL CVMX_HNA_PFC3_CTL_FUNC()
+static inline uint64_t CVMX_HNA_PFC3_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC3_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800470000B8ull);
+}
+#else
+#define CVMX_HNA_PFC3_CTL (CVMX_ADD_IO_SEG(0x00011800470000B8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_PFC_GCTL CVMX_HNA_PFC_GCTL_FUNC()
+static inline uint64_t CVMX_HNA_PFC_GCTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_PFC_GCTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000080ull);
+}
+#else
+#define CVMX_HNA_PFC_GCTL (CVMX_ADD_IO_SEG(0x0001180047000080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_HNA_SBD_DBG0 CVMX_HNA_SBD_DBG0_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG0_FUNC(void)
 {
@@ -270,10 +369,10 @@ union cvmx_hna_bist1 {
 	struct cvmx_hna_bist1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t hnc1                         : 1;  /**< "SC#1 Bist Results for cumulative HNC1 RAMs
+	uint64_t hnc1                         : 1;  /**< "SC1 Bist Results for cumulative HNC1 RAMs
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD" */
-	uint64_t hnc0                         : 1;  /**< "SC#0 Bist Results for cumulative HNC0 RAMs
+	uint64_t hnc0                         : 1;  /**< "SC0 Bist Results for cumulative HNC0 RAMs
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD" */
 	uint64_t mrp1                         : 1;  /**< Bist Results for DSM-DLC:MRP1 RAM
@@ -303,7 +402,7 @@ typedef union cvmx_hna_bist1 cvmx_hna_bist1_t;
 /**
  * cvmx_hna_config
  *
- * Description: This register specifies the HNA HPU programmable controls.
+ * This register specifies the HNA HPU programmable controls.
  *
  */
 union cvmx_hna_config {
@@ -342,14 +441,14 @@ union cvmx_hna_config {
                                                          This field specifies the low watermark for the run stack. Valid Range: [0..15]
                                                          Once the run stack goes below the low water mark, HNA will fill entries from the
                                                          global run stack head to the local run stack tail.
-                                                         The granularity of this field is represented as \#of 128B cachelines.
+                                                         The granularity of this field is represented as number of 128B cachelines.
                                                          NOTE: This field can only be changed at initialization/power on time before
                                                          the HNA is fed instructions." */
 	uint64_t rnstk_hwm                    : 4;  /**< "RNSTK High Water Mark
                                                          This field specifies the hi watermark for the run stack. Valid Range: [0..15]
                                                          Once the local run stack level goes above the hi water mark, the HNA will spill
                                                          entries from the local run stack tail to the global run stack head (in DDR memory).
-                                                         The granularity of this field is represented as \#of 128B cachelines.
+                                                         The granularity of this field is represented as number of 128B cachelines.
                                                          NOTE: This field can only be changed at initialization/power on time before
                                                          the HNA is fed instructions." */
 	uint64_t reserved_9_11                : 3;
@@ -364,10 +463,10 @@ union cvmx_hna_config {
                                                          contain '1' will be disallowed during a write and will always
                                                          be read as '1'. */
 	uint64_t hpu_clcrip                   : 3;  /**< "HPU Cluster Cripple
-                                                         Encoding which represents \#of HPUs to cripple for each
+                                                         Encoding which represents number of HPUs to cripple for each
                                                          cluster. Typically HPU_CLCRIP=0 which enables all HPUs
                                                          within each cluster. However, when the HNA performance
-                                                         counters are used, SW may want to limit the \#of HPUs
+                                                         counters are used, SW may want to limit the number of HPUs
                                                          per cluster available, as there are only 4 parallel
                                                          performance counters.
                                                          HPU_CLCRIP | \#HPUs crippled(per cluster)
@@ -386,7 +485,7 @@ union cvmx_hna_config {
                                                          HPU#s [8:0] are available.
                                                          IMPNOTE: The encodings are done in such a way as to later
                                                          be used with fuses (for future revisions which will disable
-                                                         some \#of HPUs). Blowing a fuse has the effect that there will
+                                                         some number of HPUs). Blowing a fuse has the effect that there will
                                                          always be fewer HPUs available. [ie: we never want a customer
                                                          to blow additional fuses to get more HPUs].
                                                          SWNOTE: The MIO_FUS___HNA_NUMHPU_CRIPPLE[2:0] fuse bits will
@@ -427,7 +526,7 @@ typedef union cvmx_hna_config cvmx_hna_config_t;
 /**
  * cvmx_hna_control
  *
- * Description: This register specifies the HNA CTL/HNC programmable controls.
+ * This register specifies the HNA CTL/HNC programmable controls.
  *
  */
 union cvmx_hna_control {
@@ -553,7 +652,7 @@ union cvmx_hna_difctl {
                                                          When clear, the HW will issue regular load towards cache which will cause
                                                          the line to be written back before being replaced. */
 	uint64_t reserved_9_11                : 3;
-	uint64_t size                         : 9;  /**< "Represents the \# of 64B instructions contained
+	uint64_t size                         : 9;  /**< "Represents the number of 64B instructions contained
                                                          within each HNA instruction chunk. At Power-on,
                                                          SW will seed the SIZE register with a fixed
                                                          chunk-size. (Must be at least 3)
@@ -627,7 +726,7 @@ typedef union cvmx_hna_difrdptr cvmx_hna_difrdptr_t;
 /**
  * cvmx_hna_error
  *
- * Description: This register contains error status information.
+ * This register contains error status information.
  *
  */
 union cvmx_hna_error {
@@ -719,7 +818,7 @@ typedef union cvmx_hna_error cvmx_hna_error_t;
 /**
  * cvmx_hna_hpu_csr
  *
- * "Description: To read one of the HPU internal CSRs for debug (ie: HPU_STATUS, DBG_CURSTK,
+ * "To read one of the HPU internal CSRs for debug (ie: HPU_STATUS, DBG_CURSTK,
  * DBG_GENERAL),
  * first a CSR WRITE of the HNA_HPU_DBG is done to specify the HPU CSR#, cluster#=CLID and
  * HPU#=HPUID,
@@ -742,7 +841,7 @@ typedef union cvmx_hna_hpu_csr cvmx_hna_hpu_csr_t;
 /**
  * cvmx_hna_hpu_dbg
  *
- * "Description: This register specifies the HPU CSR#, cluster#=CLID and HPU#=HPUID used during a
+ * "This register specifies the HPU CSR#, cluster#=CLID and HPU#=HPUID used during a
  * a CSR READ of the HNA_HPU_CSR register."
  */
 union cvmx_hna_hpu_dbg {
@@ -770,7 +869,7 @@ typedef union cvmx_hna_hpu_dbg cvmx_hna_hpu_dbg_t;
 /**
  * cvmx_hna_hpu_eir
  *
- * "Description: Used by SW to force Parity or ECC errors on some internal HPU data structures.
+ * "Used by SW to force Parity or ECC errors on some internal HPU data structures.
  * A CSR WRITE of this register will force either a Parity or ECC error on the next access
  * at cluster#=CLID, HPU#=HPUID."
  */
@@ -811,12 +910,296 @@ union cvmx_hna_hpu_eir {
 typedef union cvmx_hna_hpu_eir cvmx_hna_hpu_eir_t;
 
 /**
+ * cvmx_hna_pfc0_cnt
+ */
+union cvmx_hna_pfc0_cnt {
+	uint64_t u64;
+	struct cvmx_hna_pfc0_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pfcnt                        : 64; /**< "HNA Performance Counter 0.
+                                                         When HNA_PFC_GCTL[CNT0ENA]=1, the event selected
+                                                         by HNA_PFC0_CTL[EVSEL] is counted.
+                                                         See also HNA_PFC_GCTL[CNT0WCLR] and HNA_PFC_GCTL
+                                                         [CNT0RCLR] for special clear count cases available
+                                                         for SW data collection." */
+#else
+	uint64_t pfcnt                        : 64;
+#endif
+	} s;
+	struct cvmx_hna_pfc0_cnt_s            cn78xx;
+};
+typedef union cvmx_hna_pfc0_cnt cvmx_hna_pfc0_cnt_t;
+
+/**
+ * cvmx_hna_pfc0_ctl
+ */
+union cvmx_hna_pfc0_ctl {
+	uint64_t u64;
+	struct cvmx_hna_pfc0_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t evsel                        : 6;  /**< Performance Counter#0 Event Selector (64 total) */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t clhpu                        : 4;  /**< "Performance Counter 0 Cluster HPU Selector.
+                                                         When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU), this field
+                                                         is used to select/monitor the cluster's HPU# for all events
+                                                         associated with Performance Counter#0." */
+	uint64_t clnum                        : 2;  /**< "Performance Counter 0 Cluster Selector.
+                                                         When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU), this field
+                                                         is used to select/monitor the cluster# for all events
+                                                         associated with Performance Counter#0." */
+#else
+	uint64_t clnum                        : 2;
+	uint64_t clhpu                        : 4;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t evsel                        : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_hna_pfc0_ctl_s            cn78xx;
+};
+typedef union cvmx_hna_pfc0_ctl cvmx_hna_pfc0_ctl_t;
+
+/**
+ * cvmx_hna_pfc1_cnt
+ */
+union cvmx_hna_pfc1_cnt {
+	uint64_t u64;
+	struct cvmx_hna_pfc1_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pfcnt                        : 64; /**< "HNA Performance Counter 1.
+                                                         When HNA_PFC_GCTL[CNT1ENA]=1, the event selected
+                                                         by HNA_PFC1_CTL[EVSEL] is counted.
+                                                         See also HNA_PFC_GCTL[CNT1WCLR] and HNA_PFC_GCTL
+                                                         [CNT1RCLR] for special clear count cases available
+                                                         for SW data collection." */
+#else
+	uint64_t pfcnt                        : 64;
+#endif
+	} s;
+	struct cvmx_hna_pfc1_cnt_s            cn78xx;
+};
+typedef union cvmx_hna_pfc1_cnt cvmx_hna_pfc1_cnt_t;
+
+/**
+ * cvmx_hna_pfc1_ctl
+ */
+union cvmx_hna_pfc1_ctl {
+	uint64_t u64;
+	struct cvmx_hna_pfc1_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t evsel                        : 6;  /**< Performance Counter#1 Event Selector (64 total) */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t clhpu                        : 4;  /**< "Performance Counter 1 Cluster HPU Selector.
+                                                         When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU), this field
+                                                         is used to select/monitor the cluster's HPU# for all events
+                                                         associated with Performance Counter#1." */
+	uint64_t clnum                        : 2;  /**< "Performance Counter 1 Cluster Selector.
+                                                         When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU), this field
+                                                         is used to select/monitor the cluster# for all events
+                                                         associated with Performance Counter#1." */
+#else
+	uint64_t clnum                        : 2;
+	uint64_t clhpu                        : 4;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t evsel                        : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_hna_pfc1_ctl_s            cn78xx;
+};
+typedef union cvmx_hna_pfc1_ctl cvmx_hna_pfc1_ctl_t;
+
+/**
+ * cvmx_hna_pfc2_cnt
+ */
+union cvmx_hna_pfc2_cnt {
+	uint64_t u64;
+	struct cvmx_hna_pfc2_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pfcnt                        : 64; /**< "HNA Performance Counter 2.
+                                                         When HNA_PFC_GCTL[CNT2ENA]=1, the event selected
+                                                         by HNA_PFC2_CTL[EVSEL] is counted.
+                                                         See also HNA_PFC_GCTL[CNT2WCLR] and HNA_PFC_GCTL
+                                                         [CNT2RCLR] for special clear count cases available
+                                                         for SW data collection." */
+#else
+	uint64_t pfcnt                        : 64;
+#endif
+	} s;
+	struct cvmx_hna_pfc2_cnt_s            cn78xx;
+};
+typedef union cvmx_hna_pfc2_cnt cvmx_hna_pfc2_cnt_t;
+
+/**
+ * cvmx_hna_pfc2_ctl
+ */
+union cvmx_hna_pfc2_ctl {
+	uint64_t u64;
+	struct cvmx_hna_pfc2_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t evsel                        : 6;  /**< Performance Counter#2 Event Selector (64 total) */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t clhpu                        : 4;  /**< "Performance Counter#2 Cluster HPU Selector.
+                                                         When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU), this field
+                                                         is used to select/monitor the cluster's HPU# for all events
+                                                         associated with Performance Counter#2." */
+	uint64_t clnum                        : 2;  /**< "Performance Counter#2 Cluster Selector.
+                                                         When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU), this field
+                                                         is used to select/monitor the cluster# for all events
+                                                         associated with Performance Counter#2." */
+#else
+	uint64_t clnum                        : 2;
+	uint64_t clhpu                        : 4;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t evsel                        : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_hna_pfc2_ctl_s            cn78xx;
+};
+typedef union cvmx_hna_pfc2_ctl cvmx_hna_pfc2_ctl_t;
+
+/**
+ * cvmx_hna_pfc3_cnt
+ */
+union cvmx_hna_pfc3_cnt {
+	uint64_t u64;
+	struct cvmx_hna_pfc3_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pfcnt                        : 64; /**< "HNA Performance Counter 3.
+                                                         When HNA_PFC_GCTL[CNT3ENA]=1, the event selected
+                                                         by HNA_PFC3_CTL[EVSEL] is counted.
+                                                         See also HNA_PFC_GCTL[CNT3WCLR] and HNA_PFC_GCTL
+                                                         [CNT3RCLR] for special clear count cases available
+                                                         for SW data collection." */
+#else
+	uint64_t pfcnt                        : 64;
+#endif
+	} s;
+	struct cvmx_hna_pfc3_cnt_s            cn78xx;
+};
+typedef union cvmx_hna_pfc3_cnt cvmx_hna_pfc3_cnt_t;
+
+/**
+ * cvmx_hna_pfc3_ctl
+ */
+union cvmx_hna_pfc3_ctl {
+	uint64_t u64;
+	struct cvmx_hna_pfc3_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t evsel                        : 6;  /**< Performance Counter 3 Event Selector (64 total) */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t clhpu                        : 4;  /**< "Performance Counter 3 Cluster HPU Selector.
+                                                         When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU), this field
+                                                         is used to select/monitor the cluster's HPU# for all events
+                                                         associated with Performance Counter#3." */
+	uint64_t clnum                        : 2;  /**< "Performance Counter 3 Cluster Selector.
+                                                         When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU), this field
+                                                         is used to select/monitor the cluster# for all events
+                                                         associated with Performance Counter 3." */
+#else
+	uint64_t clnum                        : 2;
+	uint64_t clhpu                        : 4;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t evsel                        : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_hna_pfc3_ctl_s            cn78xx;
+};
+typedef union cvmx_hna_pfc3_ctl cvmx_hna_pfc3_ctl_t;
+
+/**
+ * cvmx_hna_pfc_gctl
+ *
+ * Global control across all performance counters.
+ *
+ */
+union cvmx_hna_pfc_gctl {
+	uint64_t u64;
+	struct cvmx_hna_pfc_gctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t cnt3rclr                     : 1;  /**< "Performance Counter 3 Read Clear.
+                                                         If this bit is set, CSR reads to the HNA_PFC3_CNT
+                                                         will clear the count value. This allows SW to maintain
+                                                         'cumulative' counters to avoid HW wraparound." */
+	uint64_t cnt2rclr                     : 1;  /**< "Performance Counter 2 Read Clear.
+                                                         If this bit is set, CSR reads to the HNA_PFC2_CNT
+                                                         will clear the count value. This allows SW to maintain
+                                                         'cumulative' counters to avoid HW wraparound." */
+	uint64_t cnt1rclr                     : 1;  /**< "Performance Counter 1 Read Clear.
+                                                         If this bit is set, CSR reads to the HNA_PFC1_CNT
+                                                         will clear the count value. This allows SW to maintain
+                                                         'cumulative' counters to avoid HW wraparound." */
+	uint64_t cnt0rclr                     : 1;  /**< "Performance Counter 0 Read Clear.
+                                                         If this bit is set, CSR reads to the HNA_PFC0_CNT
+                                                         will clear the count value. This allows SW to maintain
+                                                         'cumulative' counters to avoid HW wraparound." */
+	uint64_t cnt3wclr                     : 1;  /**< "Performance Counter 3 Write Clear.
+                                                         If this bit is set, CSR writes to the HNA_PFC3_CNT
+                                                         will clear the count value.
+                                                         If this bit is clear, CSR writes to the HNA_PFC3_CNT
+                                                         will continue the count from the written value." */
+	uint64_t cnt2wclr                     : 1;  /**< "Performance Counter 2 Write Clear.
+                                                         If this bit is set, CSR writes to the HNA_PFC2_CNT
+                                                         will clear the count value.
+                                                         If this bit is clear, CSR writes to the HNA_PFC2_CNT
+                                                         will continue the count from the written value." */
+	uint64_t cnt1wclr                     : 1;  /**< "Performance Counter 1 Write Clear.
+                                                         If this bit is set, CSR writes to the HNA_PFC1_CNT
+                                                         will clear the count value.
+                                                         If this bit is clear, CSR writes to the HNA_PFC1_CNT
+                                                         will continue the count from the written value." */
+	uint64_t cnt0wclr                     : 1;  /**< "Performance Counter 0 Write Clear.
+                                                         If this bit is set, CSR writes to the HNA_PFC0_CNT
+                                                         will clear the count value.
+                                                         If this bit is clear, CSR writes to the HNA_PFC0_CNT
+                                                         will continue the count from the written value." */
+	uint64_t cnt3ena                      : 1;  /**< "Performance Counter 3 Enable.
+                                                         When this bit is set, the performance counter \#3
+                                                         is enabled." */
+	uint64_t cnt2ena                      : 1;  /**< "Performance Counter 2 Enable.
+                                                         When this bit is set, the performance counter \#2
+                                                         is enabled." */
+	uint64_t cnt1ena                      : 1;  /**< "Performance Counter 1 Enable.
+                                                         When this bit is set, the performance counter \#1
+                                                         is enabled." */
+	uint64_t cnt0ena                      : 1;  /**< "Performance Counter 0 Enable.
+                                                         When this bit is set, the performance counter \#0
+                                                         is enabled." */
+#else
+	uint64_t cnt0ena                      : 1;
+	uint64_t cnt1ena                      : 1;
+	uint64_t cnt2ena                      : 1;
+	uint64_t cnt3ena                      : 1;
+	uint64_t cnt0wclr                     : 1;
+	uint64_t cnt1wclr                     : 1;
+	uint64_t cnt2wclr                     : 1;
+	uint64_t cnt3wclr                     : 1;
+	uint64_t cnt0rclr                     : 1;
+	uint64_t cnt1rclr                     : 1;
+	uint64_t cnt2rclr                     : 1;
+	uint64_t cnt3rclr                     : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_hna_pfc_gctl_s            cn78xx;
+};
+typedef union cvmx_hna_pfc_gctl cvmx_hna_pfc_gctl_t;
+
+/**
  * cvmx_hna_sbd_dbg0
  *
- * Description: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
+ * When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
  * are locked down. Otherwise, the contents of this register are the 'active' contents of the
  * HNA Scoreboard at the time of the CSR read.
- * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * INTERNAL: VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the
+ * behavioral
  * model) on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
  * assigned an instruction.
  */
@@ -824,7 +1207,7 @@ union cvmx_hna_sbd_dbg0 {
 	uint64_t u64;
 	struct cvmx_hna_sbd_dbg0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd                          : 64; /**< "HNA ScoreBoard \#0 Data
+	uint64_t sbd                          : 64; /**< "HNA ScoreBoard 0 Data.
                                                          [63:38]   (26) rptr[28:3]: Result Base Pointer (QW-aligned)
                                                          [37:22]   (16) Cumulative Result Write Counter (for HDR write)
                                                          [21]       (1) Waiting for GRdRsp EOT
@@ -858,10 +1241,11 @@ typedef union cvmx_hna_sbd_dbg0 cvmx_hna_sbd_dbg0_t;
 /**
  * cvmx_hna_sbd_dbg1
  *
- * Description: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
+ * When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
  * are locked down. Otherwise, the contents of this register are the 'active' contents of the
  * HNA Scoreboard at the time of the CSR read.
- * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * INTERNAL: VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the
+ * behavioral
  * model) on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
  * assigned an instruction.
  */
@@ -869,7 +1253,7 @@ union cvmx_hna_sbd_dbg1 {
 	uint64_t u64;
 	struct cvmx_hna_sbd_dbg1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd                          : 64; /**< "HNA ScoreBoard \#1 Data
+	uint64_t sbd                          : 64; /**< "HNA ScoreBoard 1 Data.
                                                          [63:56]   (8) UNUSED
                                                          [55:16]  (40) Packet Data Pointer
                                                          [15:0]   (16) Packet Data Counter" */
@@ -884,10 +1268,11 @@ typedef union cvmx_hna_sbd_dbg1 cvmx_hna_sbd_dbg1_t;
 /**
  * cvmx_hna_sbd_dbg2
  *
- * Description: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
+ * When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
  * are locked down. Otherwise, the contents of this register are the 'active' contents of the
  * HNA Scoreboard at the time of the CSR read.
- * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * INTERNAL: VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the
+ * behavioral
  * model) on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
  * assigned an instruction.
  */
@@ -895,7 +1280,7 @@ union cvmx_hna_sbd_dbg2 {
 	uint64_t u64;
 	struct cvmx_hna_sbd_dbg2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd                          : 64; /**< "HNA ScoreBoard \#2 Data
+	uint64_t sbd                          : 64; /**< "HNA ScoreBoard 2 Data.
                                                          [63:45] (19) UNUSED
                                                          [44:42]  (3) Instruction Type
                                                          [41:5]  (37) rwptr[39:3]: Result Write Pointer
@@ -911,10 +1296,11 @@ typedef union cvmx_hna_sbd_dbg2 cvmx_hna_sbd_dbg2_t;
 /**
  * cvmx_hna_sbd_dbg3
  *
- * Description: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
+ * When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
  * are locked down. Otherwise, the contents of this register are the 'active' contents of the
  * HNA Scoreboard at the time of the CSR read.
- * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * INTERNAL: VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the
+ * behavioral
  * model) on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
  * assigned an instruction.
  */
@@ -922,7 +1308,7 @@ union cvmx_hna_sbd_dbg3 {
 	uint64_t u64;
 	struct cvmx_hna_sbd_dbg3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd                          : 64; /**< "HNA ScoreBoard \#3 Data
+	uint64_t sbd                          : 64; /**< "HNA ScoreBoard 3 Data.
                                                          [63:52] (11) rptr[39:29]: Result Base Pointer (QW-aligned)
                                                          [52:16] (37) glptr[39:3]: Gather List Pointer
                                                          [15:0]  (16) glcnt Gather List Counter" */
diff --git a/arch/mips/include/asm/octeon/cvmx-ila-defs.h b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
index a60919f..efed1f5 100644
--- a/arch/mips/include/asm/octeon/cvmx-ila-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
@@ -78,34 +78,34 @@ static inline uint64_t CVMX_ILA_GBL_CFG_FUNC(void)
 static inline uint64_t CVMX_ILA_LNEX_TRN_CTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_LNEX_TRN_CTL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800170380F0ull) + ((offset) & 15) * 1024;
+	return CVMX_ADD_IO_SEG(0x00011800170380F0ull) + ((offset) & 7) * 1024;
 }
 #else
-#define CVMX_ILA_LNEX_TRN_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800170380F0ull) + ((offset) & 15) * 1024)
+#define CVMX_ILA_LNEX_TRN_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800170380F0ull) + ((offset) & 7) * 1024)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ILA_LNEX_TRN_LD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_LNEX_TRN_LD(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800170380E0ull) + ((offset) & 15) * 1024;
+	return CVMX_ADD_IO_SEG(0x00011800170380E0ull) + ((offset) & 7) * 1024;
 }
 #else
-#define CVMX_ILA_LNEX_TRN_LD(offset) (CVMX_ADD_IO_SEG(0x00011800170380E0ull) + ((offset) & 15) * 1024)
+#define CVMX_ILA_LNEX_TRN_LD(offset) (CVMX_ADD_IO_SEG(0x00011800170380E0ull) + ((offset) & 7) * 1024)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ILA_LNEX_TRN_LP(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_LNEX_TRN_LP(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800170380E8ull) + ((offset) & 15) * 1024;
+	return CVMX_ADD_IO_SEG(0x00011800170380E8ull) + ((offset) & 7) * 1024;
 }
 #else
-#define CVMX_ILA_LNEX_TRN_LP(offset) (CVMX_ADD_IO_SEG(0x00011800170380E8ull) + ((offset) & 15) * 1024)
+#define CVMX_ILA_LNEX_TRN_LP(offset) (CVMX_ADD_IO_SEG(0x00011800170380E8ull) + ((offset) & 7) * 1024)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_ILA_LNE_DBG CVMX_ILA_LNE_DBG_FUNC()
@@ -350,6 +350,17 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT1(unsigned long offset)
 #define CVMX_ILA_RX_LNEX_STAT1(offset) (CVMX_ADD_IO_SEG(0x0001180017038020ull) + ((offset) & 7) * 1024)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_ILA_RX_LNEX_STAT10(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_ILA_RX_LNEX_STAT10(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180017038068ull) + ((offset) & 7) * 1024;
+}
+#else
+#define CVMX_ILA_RX_LNEX_STAT10(offset) (CVMX_ADD_IO_SEG(0x0001180017038068ull) + ((offset) & 7) * 1024)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT2(unsigned long offset)
 {
 	if (!(
@@ -743,7 +754,7 @@ union cvmx_ila_rxx_byte_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t rx_bytes                     : 40; /**< Indicates the number of bytes received per channel. Wraps on overflow. On overflow, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t rx_bytes                     : 40;
 	uint64_t reserved_40_63               : 24;
@@ -919,7 +930,7 @@ union cvmx_ila_rxx_pkt_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t rx_pkt                       : 34; /**< Indicates the number of packets received per channel. Wraps on overflow. On overflow, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t rx_pkt                       : 34;
 	uint64_t reserved_34_63               : 30;
@@ -939,7 +950,7 @@ union cvmx_ila_rxx_stat0 {
 	uint64_t reserved_33_63               : 31;
 	uint64_t crc24_match_cnt              : 33; /**< Indicates the number of CRC24 matches received. Wraps on overflow if
                                                          ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc24_match_cnt              : 33;
 	uint64_t reserved_33_63               : 31;
@@ -959,7 +970,7 @@ union cvmx_ila_rxx_stat1 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t crc24_err_cnt                : 18; /**< Indicates the number of bursts with a detected CRC error. Wraps on overflow if
                                                          ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc24_err_cnt                : 18;
 	uint64_t reserved_18_63               : 46;
@@ -979,11 +990,11 @@ union cvmx_ila_rxx_stat2 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t brst_not_full_cnt            : 16; /**< Indicates the number of bursts received that terminated without an EOP and contained fewer
                                                          than BurstMax words. Wraps on overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_28_31               : 4;
 	uint64_t brst_cnt                     : 28; /**< Indicates the number of bursts correctly received (i.e. good CRC24, not in violation of
                                                          BurstMax or BurstShort). Wraps on overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_cnt                     : 28;
 	uint64_t reserved_28_31               : 4;
@@ -1005,7 +1016,7 @@ union cvmx_ila_rxx_stat3 {
 	uint64_t reserved_16_63               : 48;
 	uint64_t brst_max_err_cnt             : 16; /**< Indicates the number of bursts received longer than the BurstMax parameter. Wraps on
                                                          overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate,
-                                                         sets ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_max_err_cnt             : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1025,7 +1036,7 @@ union cvmx_ila_rxx_stat4 {
 	uint64_t reserved_16_63               : 48;
 	uint64_t brst_shrt_err_cnt            : 16; /**< Indicates the number of bursts received that violate the BurstShort parameter. Wraps on
                                                          overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate,
-                                                         sets ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_shrt_err_cnt            : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1045,7 +1056,7 @@ union cvmx_ila_rxx_stat5 {
 	uint64_t reserved_23_63               : 41;
 	uint64_t align_cnt                    : 23; /**< Indicates the number of alignment sequences received (i.e. those that do not violate the
                                                          current alignment). Wraps on overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t align_cnt                    : 23;
 	uint64_t reserved_23_63               : 41;
@@ -1065,7 +1076,7 @@ union cvmx_ila_rxx_stat6 {
 	uint64_t reserved_16_63               : 48;
 	uint64_t align_err_cnt                : 16; /**< Indicates the number of alignment sequences received in error (i.e. those that violate the
                                                          current alignment). Wraps on overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t align_err_cnt                : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1085,7 +1096,7 @@ union cvmx_ila_rxx_stat7 {
 	uint64_t reserved_16_63               : 48;
 	uint64_t bad_64b67b_cnt               : 16; /**< Indicates the number of bad 64B/67B code words. Wraps on overflow if
                                                          ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bad_64b67b_cnt               : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1223,7 +1234,7 @@ union cvmx_ila_rx_lnex_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t ser_lock_loss_cnt            : 18; /**< Indicates the number of times the lane lost clock-data-recovery. On overflow, saturates
-                                                         and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t ser_lock_loss_cnt            : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1242,7 +1253,7 @@ union cvmx_ila_rx_lnex_stat1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bdry_sync_loss_cnt           : 18; /**< Indicates the number of times a lane lost word-boundary synchronization. On overflow,
-                                                         saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bdry_sync_loss_cnt           : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1253,6 +1264,30 @@ union cvmx_ila_rx_lnex_stat1 {
 typedef union cvmx_ila_rx_lnex_stat1 cvmx_ila_rx_lnex_stat1_t;
 
 /**
+ * cvmx_ila_rx_lne#_stat10
+ */
+union cvmx_ila_rx_lnex_stat10 {
+	uint64_t u64;
+	struct cvmx_ila_rx_lnex_stat10_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_43_63               : 21;
+	uint64_t prbs_bad                     : 11; /**< Indicates the number of training frames with bad PRBS. On overflow, saturates and sets
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+	uint64_t reserved_11_31               : 21;
+	uint64_t prbs_good                    : 11; /**< Indicates the number of training frames with correct PRBS. On overflow, saturates and sets
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+#else
+	uint64_t prbs_good                    : 11;
+	uint64_t reserved_11_31               : 21;
+	uint64_t prbs_bad                     : 11;
+	uint64_t reserved_43_63               : 21;
+#endif
+	} s;
+	struct cvmx_ila_rx_lnex_stat10_s      cn78xx;
+};
+typedef union cvmx_ila_rx_lnex_stat10 cvmx_ila_rx_lnex_stat10_t;
+
+/**
  * cvmx_ila_rx_lne#_stat2
  */
 union cvmx_ila_rx_lnex_stat2 {
@@ -1261,10 +1296,10 @@ union cvmx_ila_rx_lnex_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t syncw_good_cnt               : 18; /**< Indicates the number of good synchronization words. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_18_31               : 14;
 	uint64_t syncw_bad_cnt                : 18; /**< Indicates the number of bad synchronization words. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t syncw_bad_cnt                : 18;
 	uint64_t reserved_18_31               : 14;
@@ -1285,7 +1320,7 @@ union cvmx_ila_rx_lnex_stat3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bad_64b67b_cnt               : 18; /**< Indicates the number of bad 64B/67B words, meaning bit <65> or bit <64> has been
-                                                         corrupted. On overflow, saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         corrupted. On overflow, saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bad_64b67b_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1304,10 +1339,10 @@ union cvmx_ila_rx_lnex_stat4 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_59_63               : 5;
 	uint64_t cntl_word_cnt                : 27; /**< Indicates the number of control words received. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t data_word_cnt                : 27; /**< Indicates the number of data words received. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t data_word_cnt                : 27;
 	uint64_t reserved_27_31               : 5;
@@ -1328,7 +1363,7 @@ union cvmx_ila_rx_lnex_stat5 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t unkwn_word_cnt               : 18; /**< Indicates the number of unknown control words. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t unkwn_word_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1348,7 +1383,7 @@ union cvmx_ila_rx_lnex_stat6 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t scrm_sync_loss_cnt           : 18; /**< Indicates the number of times scrambler synchronization was lost (due to either four
                                                          consecutive bad sync words or three consecutive scrambler-state mismatches). On overflow,
-                                                         saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t scrm_sync_loss_cnt           : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1367,7 +1402,7 @@ union cvmx_ila_rx_lnex_stat7 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t scrm_match_cnt               : 18; /**< Indicates the number of scrambler-state matches received. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t scrm_match_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1386,7 +1421,7 @@ union cvmx_ila_rx_lnex_stat8 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t skipw_good_cnt               : 18; /**< Indicates the number of good skip words. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t skipw_good_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1405,10 +1440,10 @@ union cvmx_ila_rx_lnex_stat9 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t crc32_err_cnt                : 18; /**< Indicates the number of errors in the lane CRC. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t crc32_match_cnt              : 27; /**< Indicates the number of CRC32 matches received. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc32_match_cnt              : 27;
 	uint64_t reserved_27_31               : 5;
@@ -1465,7 +1500,7 @@ union cvmx_ila_txx_byte_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t tx_bytes                     : 40; /**< Number of bytes transmitted per channel. Wraps on overflow. On overflow, sets
-                                                         ILA_TX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_TX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t tx_bytes                     : 40;
 	uint64_t reserved_40_63               : 24;
@@ -1544,12 +1579,12 @@ union cvmx_ila_txx_cfg1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
 	uint64_t txf_byp_dis                  : 1;  /**< TX-FIFO bypass disable. */
-	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. SER_LIMIT must be
-                                                         set as follows:
-                                                         SER_LIMIT >= (((17 + NUM_LANES) * (BAUD/SCLK/20) + 4) * 20
+	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. If 0x0, hardware
+                                                         will compute it. Otherwise, SER_LIMIT must be set as follows:
+                                                         SER_LIMIT >= 148 + (BAUD / SCLK) * (12 + NUM_LANES)
                                                          For instance, for SCLK=1.1GHz,BAUD=10.3125,NUM_LANES=8:
-                                                         SER_LIMIT >= (((17 + 8) * (10.3125/1.1/20) + 4) * 20
-                                                         SER_LIMIT >= 314 */
+                                                         SER_LIMIT >= 148 + (10.3125 / 1.1 * (12+ 8))
+                                                         SER_LIMIT >= 336 */
 	uint64_t pkt_busy                     : 1;  /**< TX-link is transmitting data. */
 	uint64_t reserved_26_31               : 6;
 	uint64_t skip_cnt                     : 4;  /**< Number of skip words to insert after the scrambler state. */
@@ -1682,7 +1717,7 @@ union cvmx_ila_txx_pkt_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
 	uint64_t tx_pkt                       : 28; /**< Number of packets transmitted per channel. Wraps on overflow. On overflow, sets
-                                                         ILA_TX(0)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILA_TX(0)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t tx_pkt                       : 28;
 	uint64_t reserved_28_63               : 36;
diff --git a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
index b20a7c2..57a70899 100644
--- a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
@@ -622,6 +622,17 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT1(unsigned long offset)
 #define CVMX_ILK_RX_LNEX_STAT1(offset) (CVMX_ADD_IO_SEG(0x0001180014038020ull) + ((offset) & 15) * 1024)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_ILK_RX_LNEX_STAT10(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
+		cvmx_warn("CVMX_ILK_RX_LNEX_STAT10(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180014038068ull) + ((offset) & 15) * 1024;
+}
+#else
+#define CVMX_ILK_RX_LNEX_STAT10(offset) (CVMX_ADD_IO_SEG(0x0001180014038068ull) + ((offset) & 15) * 1024)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_ILK_RX_LNEX_STAT2(unsigned long offset)
 {
 	if (!(
@@ -1830,7 +1841,7 @@ union cvmx_ilk_rxx_byte_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t rx_bytes                     : 40; /**< Number of bytes received per channel. Wraps on overflow. On overflow, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t rx_bytes                     : 40;
 	uint64_t reserved_40_63               : 24;
@@ -2934,7 +2945,7 @@ union cvmx_ilk_rxx_pkt_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t rx_pkt                       : 34; /**< Number of packets received per channel. Wraps on overflow. On overflow, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t rx_pkt                       : 34;
 	uint64_t reserved_34_63               : 30;
@@ -2990,7 +3001,7 @@ union cvmx_ilk_rxx_stat0 {
 	uint64_t reserved_35_63               : 29;
 	uint64_t crc24_match_cnt              : 35; /**< Indicates the number of CRC24 matches received. Wraps on overflow if
                                                          ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc24_match_cnt              : 35;
 	uint64_t reserved_35_63               : 29;
@@ -3030,7 +3041,7 @@ union cvmx_ilk_rxx_stat1 {
 	uint64_t reserved_20_63               : 44;
 	uint64_t crc24_err_cnt                : 20; /**< Indicates the number of bursts with a detected CRC error. Wraps on overflow if
                                                          ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc24_err_cnt                : 20;
 	uint64_t reserved_20_63               : 44;
@@ -3061,11 +3072,11 @@ union cvmx_ilk_rxx_stat2 {
 	uint64_t reserved_50_63               : 14;
 	uint64_t brst_not_full_cnt            : 18; /**< Indicates the number of bursts received that terminated without an EOP and contained fewer
                                                          than BurstMax words. Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_30_31               : 2;
 	uint64_t brst_cnt                     : 30; /**< Indicates the number of bursts correctly received. (i.e. good CRC24, not in violation of
                                                          BurstMax or BurstShort). Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1.
-                                                         Otherwise, saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         Otherwise, saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_cnt                     : 30;
 	uint64_t reserved_30_31               : 2;
@@ -3119,7 +3130,7 @@ union cvmx_ilk_rxx_stat3 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t brst_max_err_cnt             : 18; /**< Indicates the number of bursts received longer than the BurstMax parameter. Wraps on
                                                          overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On
-                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_max_err_cnt             : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3149,7 +3160,7 @@ union cvmx_ilk_rxx_stat4 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t brst_shrt_err_cnt            : 18; /**< Indicates the number of bursts received that violate the BurstShort parameter. Wraps on
                                                          overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On
-                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_shrt_err_cnt            : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3181,7 +3192,7 @@ union cvmx_ilk_rxx_stat5 {
 	uint64_t reserved_25_63               : 39;
 	uint64_t align_cnt                    : 25; /**< Indicates the number of alignment sequences received (i.e. those that do not violate the
                                                          current alignment). Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t align_cnt                    : 25;
 	uint64_t reserved_25_63               : 39;
@@ -3223,7 +3234,7 @@ union cvmx_ilk_rxx_stat6 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t align_err_cnt                : 18; /**< Indicates the number of alignment sequences received in error (i.e. those that violate the
                                                          current alignment). Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t align_err_cnt                : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3255,7 +3266,7 @@ union cvmx_ilk_rxx_stat7 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t bad_64b67b_cnt               : 18; /**< Indicates the number of bad 64B/67B code words.Wraps on overflow if
                                                          ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bad_64b67b_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3286,10 +3297,10 @@ union cvmx_ilk_rxx_stat8 {
 	uint64_t reserved_32_63               : 32;
 	uint64_t pkt_drop_rid_cnt             : 16; /**< Indicates the number of packets dropped due to the lack of reassembly IDs or because
                                                          ILK_RX(0..1)_CFG1[PKT_ENA] = 0. Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1.
-                                                         Otherwise, saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         Otherwise, saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 	uint64_t pkt_drop_rxf_cnt             : 16; /**< Indicates the number of packets dropped due to RX_FIFO_CNT >= RX_FIFO_MAX. Wraps on
                                                          overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1.Otherwise, saturates. On
-                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t pkt_drop_rxf_cnt             : 16;
 	uint64_t pkt_drop_rid_cnt             : 16;
@@ -3545,7 +3556,7 @@ union cvmx_ilk_rx_lnex_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t ser_lock_loss_cnt            : 18; /**< Indicates the number of times the lane lost clock-data-recovery. On overflow, saturates
-                                                         and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t ser_lock_loss_cnt            : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3566,7 +3577,7 @@ union cvmx_ilk_rx_lnex_stat1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bdry_sync_loss_cnt           : 18; /**< Indicates the number of times a lane lost word-boundary synchronization. On overflow,
-                                                         saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bdry_sync_loss_cnt           : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3579,6 +3590,30 @@ union cvmx_ilk_rx_lnex_stat1 {
 typedef union cvmx_ilk_rx_lnex_stat1 cvmx_ilk_rx_lnex_stat1_t;
 
 /**
+ * cvmx_ilk_rx_lne#_stat10
+ */
+union cvmx_ilk_rx_lnex_stat10 {
+	uint64_t u64;
+	struct cvmx_ilk_rx_lnex_stat10_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_43_63               : 21;
+	uint64_t prbs_bad                     : 11; /**< Indicates the number of training frames with bad PRBS. On overflow, saturates and sets
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+	uint64_t reserved_11_31               : 21;
+	uint64_t prbs_good                    : 11; /**< Indicates the number of training frames with correct PRBS. On overflow, saturates and sets
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+#else
+	uint64_t prbs_good                    : 11;
+	uint64_t reserved_11_31               : 21;
+	uint64_t prbs_bad                     : 11;
+	uint64_t reserved_43_63               : 21;
+#endif
+	} s;
+	struct cvmx_ilk_rx_lnex_stat10_s      cn78xx;
+};
+typedef union cvmx_ilk_rx_lnex_stat10 cvmx_ilk_rx_lnex_stat10_t;
+
+/**
  * cvmx_ilk_rx_lne#_stat2
  */
 union cvmx_ilk_rx_lnex_stat2 {
@@ -3587,10 +3622,10 @@ union cvmx_ilk_rx_lnex_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t syncw_good_cnt               : 18; /**< Indicates the number of good synchronization words. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_18_31               : 14;
 	uint64_t syncw_bad_cnt                : 18; /**< Indicates the number of bad synchronization words. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t syncw_bad_cnt                : 18;
 	uint64_t reserved_18_31               : 14;
@@ -3613,7 +3648,7 @@ union cvmx_ilk_rx_lnex_stat3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bad_64b67b_cnt               : 18; /**< Indicates the number of bad 64B/67B words, meaning bit <65> or bit <64> has been
-                                                         corrupted. On overflow, saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         corrupted. On overflow, saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bad_64b67b_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3634,10 +3669,10 @@ union cvmx_ilk_rx_lnex_stat4 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_59_63               : 5;
 	uint64_t cntl_word_cnt                : 27; /**< Indicates the number of control words received. SOn overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t data_word_cnt                : 27; /**< Indicates the number of data words received. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t data_word_cnt                : 27;
 	uint64_t reserved_27_31               : 5;
@@ -3660,7 +3695,7 @@ union cvmx_ilk_rx_lnex_stat5 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t unkwn_word_cnt               : 18; /**< Indicates the number of unknown control words.On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t unkwn_word_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3682,7 +3717,7 @@ union cvmx_ilk_rx_lnex_stat6 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t scrm_sync_loss_cnt           : 18; /**< Indicates the number of times scrambler synchronization was lost (due to either four
                                                          consecutive bad sync words or three consecutive scrambler-state mismatches). On overflow,
-                                                         saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t scrm_sync_loss_cnt           : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3703,7 +3738,7 @@ union cvmx_ilk_rx_lnex_stat7 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t scrm_match_cnt               : 18; /**< Indicates the number of scrambler-state matches received. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t scrm_match_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3724,7 +3759,7 @@ union cvmx_ilk_rx_lnex_stat8 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t skipw_good_cnt               : 18; /**< Indicates the number of good skip words. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t skipw_good_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3745,10 +3780,10 @@ union cvmx_ilk_rx_lnex_stat9 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t crc32_err_cnt                : 18; /**< Indicates the number of errors in the lane CRC. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t crc32_match_cnt              : 27; /**< Indicates the number of CRC32 matches received. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc32_match_cnt              : 27;
 	uint64_t reserved_27_31               : 5;
@@ -3913,7 +3948,7 @@ union cvmx_ilk_txx_byte_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t tx_bytes                     : 40; /**< Number of bytes transmitted per channel. Wraps on overflow. On overflow, sets
-                                                         ILK_TX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_TX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t tx_bytes                     : 40;
 	uint64_t reserved_40_63               : 24;
@@ -4147,11 +4182,12 @@ union cvmx_ilk_txx_cfg1 {
                                                          enhancement. When non-zero, must satisfy:
                                                          (BRST_SHRT*8) <= (BRST_MIN*32) <= (BRST_MAX*64)/2. */
 	uint64_t reserved_43_47               : 5;
-	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes.
-                                                         SER_LIMIT >= (((17 + NUM_LANES) * (BAUD/SCLK/20)) + 4) * 20.
+	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. If 0x0, hardware
+                                                         will compute it. Otherwise, SER_LIMIT must be set as follows:
+                                                         SER_LIMIT >= 148 + (BAUD / SCLK) * (12 + (NUM_LANES/2))
                                                          For instance, for sclk=1.1GHz,BAUD=10.3125,NUM_LANES=16 :
-                                                         SER_LIMIT >= (((17+16)*(10.3125/1.1/20))+4)*20
-                                                         SER_LIMIT >= 390 */
+                                                         SER_LIMIT >= 148 + (10.3125 / 1.1 * (12 + (12/2))
+                                                         SER_LIMIT >= 317 */
 	uint64_t pkt_busy                     : 1;  /**< Packet busy. When set to 1, indicates the TX-link is transmitting data. */
 	uint64_t pipe_crd_dis                 : 1;  /**< Disable channel credits. Should be set to 1 when PKO is configured to ignore channel credits. */
 	uint64_t ptp_delay                    : 5;  /**< Reserved. */
@@ -4884,7 +4920,7 @@ union cvmx_ilk_txx_pkt_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t tx_pkt                       : 34; /**< Number of packets transmitted per channel. Wraps on overflow. On overflow, sets
-                                                         ILK_TX(0..1)_INT[STAT_CNT_OVFL]=1. */
+                                                         ILK_TX(0..1)_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t tx_pkt                       : 34;
 	uint64_t reserved_34_63               : 30;
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 0c1ebbf..cc005b1 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -2295,7 +2295,12 @@ union cvmx_l2c_cbcx_dll {
 	uint64_t u64;
 	struct cvmx_l2c_cbcx_dll_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_16_63               : 48;
+	uint64_t reserved_36_63               : 28;
+	uint64_t pd_pos_rclk_refclk           : 1;  /**< Phase detector output. */
+	uint64_t pdl_rclk_refclk              : 1;  /**< Phase detector output. */
+	uint64_t pdr_rclk_refclk              : 1;  /**< Phase detector output. */
+	uint64_t clk_invert                   : 1;  /**< Clock invert. */
+	uint64_t dly_elem_enable              : 16; /**< Delay element enable. */
 	uint64_t dll_setting                  : 12; /**< DLL setting. */
 	uint64_t dll_state                    : 3;  /**< DLL state. */
 	uint64_t dll_lock                     : 1;  /**< DLL locked. */
@@ -2303,7 +2308,12 @@ union cvmx_l2c_cbcx_dll {
 	uint64_t dll_lock                     : 1;
 	uint64_t dll_state                    : 3;
 	uint64_t dll_setting                  : 12;
-	uint64_t reserved_16_63               : 48;
+	uint64_t dly_elem_enable              : 16;
+	uint64_t clk_invert                   : 1;
+	uint64_t pdr_rclk_refclk              : 1;
+	uint64_t pdl_rclk_refclk              : 1;
+	uint64_t pd_pos_rclk_refclk           : 1;
+	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
 	struct cvmx_l2c_cbcx_dll_s            cn78xx;
@@ -3077,7 +3087,7 @@ typedef union cvmx_l2c_cfg cvmx_l2c_cfg_t;
  *  1   18   0     RO     CP0 Root.WatchLo0                         RW
  *  1   19   0     RO     CP0 Root.WatchHi0                         RW
  *  1   22   0     RO     CP0 Root.MultiCoreDebug                   RW
- *  1   22   1            CP0 Root.VoltageMonitor                   RW
+ *  1   22   1            CP0 Root.ImplDebug                        R0
  *  1   22   2     RO     CP0 Root.CvmCountOffset                   RW
  *  1   23   0     RO     CP0 Root.Debug                            RW
  *  1   23   6     RO     CP0 Root.Debug2                           RO
@@ -3706,7 +3716,8 @@ union cvmx_l2c_ctl {
                                                          For optimal performance set to
                                                          10 * (DDR-clock period/core-clock period) - 1.
                                                          To disable set to 0. All other values are reserved. */
-	uint64_t reserved_3_5                 : 3;
+	uint64_t reserved_4_5                 : 2;
+	uint64_t disldwb                      : 1;  /**< Suppresses the DWB functionality of any received LDWB, effectively turning them into LDTs. */
 	uint64_t dissblkdty                   : 1;  /**< Disable bandwidth optimization between L2 and LMC and MOB which only transfers modified
                                                          sub-blocks when possible. NOTE: in an OCI system all nodes must use the same setting of
                                                          DISSBLKDTY or operation is undefined. FIXME: should reset to 0, once verif supports it. */
@@ -3716,7 +3727,8 @@ union cvmx_l2c_ctl {
 	uint64_t disidxalias                  : 1;
 	uint64_t disecc                       : 1;
 	uint64_t dissblkdty                   : 1;
-	uint64_t reserved_3_5                 : 3;
+	uint64_t disldwb                      : 1;
+	uint64_t reserved_4_5                 : 2;
 	uint64_t rdf_cnt                      : 8;
 	uint64_t xmc_arb_mode                 : 1;
 	uint64_t rsp_arb_mode                 : 1;
@@ -4384,8 +4396,7 @@ union cvmx_l2c_ecc_ctl {
 	uint64_t u64;
 	struct cvmx_l2c_ecc_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_14_63               : 50;
-	uint64_t xmdmskflip                   : 2;  /**< Generate an ECC error in the XMD MSK. */
+	uint64_t reserved_12_63               : 52;
 	uint64_t mibflip                      : 2;  /**< Generate an ECC error in the MIB. See note above. */
 	uint64_t l2dflip                      : 2;  /**< Generate an ECC error in the L2D. See note above. */
 	uint64_t l2tflip                      : 2;  /**< Generate an ECC error in the L2T. */
@@ -4399,8 +4410,7 @@ union cvmx_l2c_ecc_ctl {
 	uint64_t l2tflip                      : 2;
 	uint64_t l2dflip                      : 2;
 	uint64_t mibflip                      : 2;
-	uint64_t xmdmskflip                   : 2;
-	uint64_t reserved_14_63               : 50;
+	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
 	struct cvmx_l2c_ecc_ctl_cn70xx {
@@ -5950,7 +5960,20 @@ union cvmx_l2c_oci_ctl {
 	uint64_t u64;
 	struct cvmx_l2c_oci_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_7_63                : 57;
+	uint64_t reserved_17_63               : 47;
+	uint64_t shtoioen                     : 1;  /**< When set, any PP issues any of an IO load, acking store, IOBDMA, LMTDMA, acking IOBADDR,
+                                                         or acking LMTST to a node that doesn't exist (existence defined by the ENAOCI bits),
+                                                         then the hardware sets the SHTO CSR field. */
+	uint64_t shtoen                       : 3;  /**< When set, if the corresponding OCI link is down, the hardware sets the SHTO CSR field. */
+	uint64_t shto                         : 1;  /**< Use short timeout intervals. When set, PP will use SDIDTTO for both DID and commit counter
+                                                         timeouts, rather than DIDTTO/DIDTTO2. Similarly, L2C will use short instead of long
+                                                         timeout (FIXME -  more info needed) */
+	uint64_t inv_mode                     : 2;  /**< Describes how aggressive to be when waiting for local invalidates before sending OCI
+                                                         responses which act like commits at the remote. 0 - conservative mode, waits until all
+                                                         local invalidates have been sent by their respective CBCs to the PPs. 1 - moderate mode,
+                                                         waits until all local invalidates have been sent to their respective CBCs, but not
+                                                         necessarily actually sent to the PPs themselves. 2 - aggressive mode, does not wait for
+                                                         local invalidates to begin their processing. */
 	uint64_t cas_fdx                      : 1;  /**< When set, L2 STC/CAS operations performed at the home will immediately bring the block
                                                          exclusive into the home. Default operation is to first request the block shared and only
                                                          invalidate the remote if the compare succeeds. */
@@ -5968,16 +5991,21 @@ union cvmx_l2c_oci_ctl {
 	uint64_t gksegnode                    : 2;  /**< Initialized to the OCX_COM_NODE[ID] value on reset, which will equal the OCI_NODE_ID pins
                                                          on a cold reset, but could be something else on a chip warm or soft reset; writable by
                                                          software. */
-	uint64_t enaoci                       : 1;  /**< Enable OCI processing. When set, perform OCI processing. When clear, OCI references cause
+	uint64_t enaoci                       : 4;  /**< Enable OCI processing (one per node_id). When set, perform OCI processing. When clear, OCI
+                                                         references cause
                                                          RDDISOCI/WRDISOCI interrupts (NYI). */
 #else
-	uint64_t enaoci                       : 1;
+	uint64_t enaoci                       : 4;
 	uint64_t gksegnode                    : 2;
 	uint64_t iofrcl                       : 1;
 	uint64_t lock_local                   : 1;
 	uint64_t rldd_psha                    : 1;
 	uint64_t cas_fdx                      : 1;
-	uint64_t reserved_7_63                : 57;
+	uint64_t inv_mode                     : 2;
+	uint64_t shto                         : 1;
+	uint64_t shtoen                       : 3;
+	uint64_t shtoioen                     : 1;
+	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
 	struct cvmx_l2c_oci_ctl_s             cn78xx;
@@ -6885,6 +6913,29 @@ union cvmx_l2c_tadx_dll {
 	uint64_t u64;
 	struct cvmx_l2c_tadx_dll_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t pd_pos_rclk_refclk           : 1;  /**< Phase detector output. */
+	uint64_t pdl_rclk_refclk              : 1;  /**< Phase detector output. */
+	uint64_t pdr_rclk_refclk              : 1;  /**< Phase detector output. */
+	uint64_t clk_invert                   : 1;  /**< Clock invert. */
+	uint64_t dly_elem_enable              : 16; /**< Delay element enable. */
+	uint64_t dll_setting                  : 12; /**< DLL setting. */
+	uint64_t dll_state                    : 3;  /**< DLL state. */
+	uint64_t dll_lock                     : 1;  /**< DLL locked. */
+#else
+	uint64_t dll_lock                     : 1;
+	uint64_t dll_state                    : 3;
+	uint64_t dll_setting                  : 12;
+	uint64_t dly_elem_enable              : 16;
+	uint64_t clk_invert                   : 1;
+	uint64_t pdr_rclk_refclk              : 1;
+	uint64_t pdl_rclk_refclk              : 1;
+	uint64_t pd_pos_rclk_refclk           : 1;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_l2c_tadx_dll_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t dll_setting                  : 12; /**< DLL setting. */
 	uint64_t dll_state                    : 3;  /**< DLL state. */
@@ -6895,8 +6946,7 @@ union cvmx_l2c_tadx_dll {
 	uint64_t dll_setting                  : 12;
 	uint64_t reserved_16_63               : 48;
 #endif
-	} s;
-	struct cvmx_l2c_tadx_dll_s            cn70xx;
+	} cn70xx;
 	struct cvmx_l2c_tadx_dll_s            cn78xx;
 };
 typedef union cvmx_l2c_tadx_dll cvmx_l2c_tadx_dll_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
index 7a81981..d3e35ff 100644
--- a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
@@ -363,11 +363,11 @@ union cvmx_lapx_edat_err_st {
 	struct cvmx_lapx_edat_err_st_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_24_63               : 40;
-	uint64_t fsyn                         : 8;  /**< Syndrome of last Expected Mask Ram ECC error. Latched when LAP0/1_GEN_INT[EDAT_SBE] or
+	uint64_t fsyn                         : 8;  /**< Syndrome of last Expected Mask Ram ECC error. Latched when LAP(0..1)_GEN_INT[EDAT_SBE] or
                                                          [EDAT_DBE] set */
 	uint64_t reserved_4_15                : 12;
 	uint64_t fadr                         : 4;  /**< Address of last Expected Mask Ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[EDAT_SBE] or [EDAT_DBE] set. */
+                                                         LAP(0..1)_GEN_INT[EDAT_SBE] or [EDAT_DBE] set. */
 #else
 	uint64_t fadr                         : 4;
 	uint64_t reserved_4_15                : 12;
@@ -388,10 +388,10 @@ union cvmx_lapx_emsk_err_st {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_24_63               : 40;
 	uint64_t fsyn                         : 8;  /**< Syndrome of last Expected Data Ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[EMSK_SBE] or [EMSK_DBE] set */
+                                                         LAP(0..1)_GEN_INT[EMSK_SBE] or [EMSK_DBE] set */
 	uint64_t reserved_4_15                : 12;
 	uint64_t fadr                         : 4;  /**< Address of last Expected Data Ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[EMSK_SBE] or [EMSK_DBE] set. */
+                                                         LAP(0..1)_GEN_INT[EMSK_SBE] or [EMSK_DBE] set. */
 #else
 	uint64_t fadr                         : 4;
 	uint64_t reserved_4_15                : 12;
@@ -462,7 +462,7 @@ union cvmx_lapx_expx_data {
 	struct cvmx_lapx_expx_data_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t data                         : 64; /**< Data value expected. The packet must have bits matching this value if the corresponding
-                                                         bits in LAP0/1_EXP(0..15)_VALID are set. */
+                                                         bits in LAP(0..1)_EXP(0..15)_VALID are set. */
 #else
 	uint64_t data                         : 64;
 #endif
@@ -482,12 +482,12 @@ union cvmx_lapx_expx_valid {
 	struct cvmx_lapx_expx_valid_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t valid                        : 64; /**< Valid mask. Each bit corresponds to a bit in
-                                                         LAP0/1_EXP(0..15)_VALID:
+                                                         LAP(0..1)_EXP(0..15)_VALID:
                                                          0 = Corresponding bit is a don't care.
                                                          1 = Corresponding bit compared against
-                                                         LAP0/1_EXP(0..15)_VALID.
+                                                         LAP(0..1)_EXP(0..15)_VALID.
                                                          Note that some response bits indicated by LAP_CTL_RTN_S are for Interlaken control, and
-                                                         thus should always be zero (don't care) in LAP0/1_EXP_VALID(0). */
+                                                         thus should always be zero (don't care) in LAP(0..1)_EXP_VALID(0). */
 #else
 	uint64_t valid                        : 64;
 #endif
@@ -544,25 +544,25 @@ union cvmx_lapx_gen_int {
 	uint64_t nbr_sbe                      : 1;  /**< An ECC correctable error has occurred in the NBR RAM. Throws
                                                          LAP_INTSN_E::LAP(0..1)_GEN_NBR_SBE. */
 	uint64_t edat_dbe                     : 1;  /**< An ECC uncorrectable error has occurred in the EDAT RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_EDAT_DBE. See also LAP0/1_EDAT_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_EDAT_DBE. See also LAP(0..1)_EDAT_ERR_ST. */
 	uint64_t edat_sbe                     : 1;  /**< An ECC correctable error has occurred in the EDAT RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_EDAT_SBE. See also LAP0/1_EDAT_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_EDAT_SBE. See also LAP(0..1)_EDAT_ERR_ST. */
 	uint64_t emsk_dbe                     : 1;  /**< An ECC uncorrectable error has occurred in the EMSK RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_EMSK_DBE. See also LAP0/1_EMSK_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_EMSK_DBE. See also LAP(0..1)_EMSK_ERR_ST. */
 	uint64_t emsk_sbe                     : 1;  /**< An ECC correctable error has occurred in the EMSK RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_EMSK_SBE. See also LAP0/1_EMSK_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_EMSK_SBE. See also LAP(0..1)_EMSK_ERR_ST. */
 	uint64_t nxt_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the NXT RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_NXT_DBE. See also LAP0/1_NXT_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_NXT_DBE. See also LAP(0..1)_NXT_ERR_ST. */
 	uint64_t nxt_sbe                      : 1;  /**< An ECC correctable error has occurred in the NXT RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_NXT_SBE. See also LAP0/1_NXT_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_NXT_SBE. See also LAP(0..1)_NXT_ERR_ST. */
 	uint64_t sta_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the STA RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_STA_DBE. See also LAP0/1_STA_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_STA_DBE. See also LAP(0..1)_STA_ERR_ST. */
 	uint64_t sta_sbe                      : 1;  /**< An ECC correctable error has occurred in the STA RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_STA_SBE. See also LAP0/1_STA_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_STA_SBE. See also LAP(0..1)_STA_ERR_ST. */
 	uint64_t lab_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the LAB RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_LAB_DBE. See also LAP0/1_LAB_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_LAB_DBE. See also LAP(0..1)_LAB_ERR_ST. */
 	uint64_t lab_sbe                      : 1;  /**< An ECC correctable error has occurred in the LAB RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_LAB_SBE. See also LAP0/1_LAB_ERR_ST. */
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_LAB_SBE. See also LAP(0..1)_LAB_ERR_ST. */
 	uint64_t reserved_4_5                 : 2;
 	uint64_t timeout                      : 1;  /**< Indication timer transitioned an LAB to error state. This interrupt will typically be
                                                          masked off, as error delivery can be in-band. Throws LAP_INTSN_E::LAP(0..1)_GEN_TIMEOUT. */
@@ -570,8 +570,9 @@ union cvmx_lapx_gen_int {
                                                          exception queue for new packets. Throws LAP_INTSN_E::LAP(0..1)_GEN_NEW_EXC. */
 	uint64_t lost_exc                     : 1;  /**< Error indicating exception packet received with no LABs available on the exception queue;
                                                          the exception packet was dropped. Throws LAP_INTSN_E::LAP(0..1)_GEN_LOST_EXC. */
-	uint64_t labs_out                     : 1;  /**< Error indicating did push with no free LABs available, or LAP0/1_QUE(0..2)_CFG[MAX_LABS]
-                                                         was exceeded. Throws LAP_INTSN_E::LAP(0..1)_GEN_LABS_OUT. */
+	uint64_t labs_out                     : 1;  /**< Error indicating did push with no free LABs available, or
+                                                         LAP(0..1)_QUE(0..2)_CFG[MAX_LABS] was exceeded. Throws
+                                                         LAP_INTSN_E::LAP(0..1)_GEN_LABS_OUT. */
 #else
 	uint64_t labs_out                     : 1;
 	uint64_t lost_exc                     : 1;
@@ -636,7 +637,7 @@ typedef union cvmx_lapx_labx_state cvmx_lapx_labx_state_t;
  * cvmx_lap#_lab_data#
  *
  * "This register reads raw data from the LABs. The address is calculated from (LAB#  *
- * words_per_lab_from_table_in_LAP0/1_CFG[LAB_SIZE] + offset_in_LAB) * 8."
+ * words_per_lab_from_table_in_LAP(0..1)_CFG[LAB_SIZE] + offset_in_LAB) * 8."
  */
 union cvmx_lapx_lab_datax {
 	uint64_t u64;
@@ -660,10 +661,10 @@ union cvmx_lapx_lab_err_st {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_26_63               : 38;
 	uint64_t fsyn                         : 10; /**< Syndrome of last LAB data ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[LAB_SBE] or [LAB_DBE] set */
+                                                         LAP(0..1)_GEN_INT[LAB_SBE] or [LAB_DBE] set */
 	uint64_t reserved_10_15               : 6;
 	uint64_t fadr                         : 10; /**< Address of last LAB data ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[LAB_SBE] or [LAB_DBE] set. */
+                                                         LAP(0..1)_GEN_INT[LAB_SBE] or [LAB_DBE] set. */
 #else
 	uint64_t fadr                         : 10;
 	uint64_t reserved_10_15               : 6;
@@ -684,10 +685,10 @@ union cvmx_lapx_nxt_err_st {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_21_63               : 43;
 	uint64_t fsyn                         : 5;  /**< Syndrome of last Next Pointer Ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[NXT_SBE] or [NXT_DBE] set */
+                                                         LAP(0..1)_GEN_INT[NXT_SBE] or [NXT_DBE] set */
 	uint64_t reserved_8_15                : 8;
 	uint64_t fadr                         : 8;  /**< Address of last Next Pointer Ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[NXT_SBE] or [NXT_DBE] set. */
+                                                         LAP(0..1)_GEN_INT[NXT_SBE] or [NXT_DBE] set. */
 #else
 	uint64_t fadr                         : 8;
 	uint64_t reserved_8_15                : 8;
@@ -708,9 +709,10 @@ union cvmx_lapx_quex_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t max_labs                     : 9;  /**< Maximum number of LABS allowed to be assigned to this queue; compared against
-                                                         LAP0/1_QUE(0..2)_STATE[LABS_RX] + LAP0/1_QUE(0..2)_STATE[LABS_PROC] to generate errors.
-                                                         The total across all queues' [MAX_LABS] may be over-provisioned, in which case the global
-                                                         LAP0/1_SFT_RSTLAP0/1_CFG[LAB_SIZE] number of LABs will throttle the transaction count. */
+                                                         LAP(0..1)_QUE(0..2)_STATE[LABS_RX] + LAP(0..1)_QUE(0..2)_STATE[LABS_PROC] to generate
+                                                         errors. The total across all queues' [MAX_LABS] may be over-provisioned, in which case the
+                                                         global LAP(0..1)_SFT_RSTLAP(0..1)_CFG[LAB_SIZE] number of LABs will throttle the
+                                                         transaction count. */
 #else
 	uint64_t max_labs                     : 9;
 	uint64_t reserved_9_63                : 55;
@@ -818,10 +820,10 @@ union cvmx_lapx_sta_err_st {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_23_63               : 41;
 	uint64_t fsyn                         : 7;  /**< Syndrome of last LAB state ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[STA_SBE] or [STA_DBE] set */
+                                                         LAP(0..1)_GEN_INT[STA_SBE] or [STA_DBE] set */
 	uint64_t reserved_8_15                : 8;
 	uint64_t fadr                         : 8;  /**< Address of last LAB state ram ECC error. Latched when
-                                                         LAP0/1_GEN_INT[STA_SBE] or [STA_DBE] set. */
+                                                         LAP(0..1)_GEN_INT[STA_SBE] or [STA_DBE] set. */
 #else
 	uint64_t fadr                         : 8;
 	uint64_t reserved_8_15                : 8;
@@ -851,7 +853,7 @@ union cvmx_lapx_timeout {
 	uint64_t reserved_12_15               : 4;
 	uint64_t resp                         : 12; /**< Timeout waiting for a response in number of sclks minus one divided by 256. After between
                                                          one and two times this interval an in-flight LAB will be considered lost and marked as
-                                                         RECEIVED with error. RESP must be set to >= (2 * LAP0/1_TIMEOUT[IOBDMA] + 1).
+                                                         RECEIVED with error. RESP must be set to >= (2 * LAP(0..1)_TIMEOUT[IOBDMA] + 1).
                                                          0x0 = Timeout between 256 and 511 cycles
                                                          0x1 = Timeout between 512 and 1023 cycles
                                                          0x2 = Timeout between 768 and 1535 cycles
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index 12bc845..3ce2632 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -5432,7 +5432,7 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t reserved_18_26               : 9;
 	uint64_t diffamp                      : 4;  /**< PLL diffamp input transconductance */
 	uint64_t cps                          : 3;  /**< PLL charge-pump current */
-	uint64_t cpb                          : 3;  /**< PLL charge-pump current */
+	uint64_t reserved_8_10                : 3;
 	uint64_t reset_n                      : 1;  /**< PLL reset */
 	uint64_t clkf                         : 7;  /**< Multiply reference by CLKF
                                                          32 <= CLKF <= 64
@@ -5441,7 +5441,7 @@ union cvmx_lmcx_ddr_pll_ctl {
 #else
 	uint64_t clkf                         : 7;
 	uint64_t reset_n                      : 1;
-	uint64_t cpb                          : 3;
+	uint64_t reserved_8_10                : 3;
 	uint64_t cps                          : 3;
 	uint64_t diffamp                      : 4;
 	uint64_t reserved_18_26               : 9;
@@ -5609,14 +5609,16 @@ union cvmx_lmcx_ddr_pll_ctl {
                                                          0xE = divide LMC PLL by TBD.
                                                          0xF = divide LMC PLL by TBD.
                                                          DDR_PS_EN is not used when DDR_DIV_RESET = 1 */
-	uint64_t reserved_8_17                : 10;
+	uint64_t reserved_9_17                : 9;
+	uint64_t clkf_ext                     : 1;  /**< A 1-bit extension to the CLKF register to support for DDR4-2666. */
 	uint64_t reset_n                      : 1;  /**< PLL reset */
 	uint64_t clkf                         : 7;  /**< Multiply reference by CLKF. 32 <= CLKF <= 64. LMC PLL frequency = 50 * CLKF. min = 1.6
                                                          GHz, max = 3.2 GHz. */
 #else
 	uint64_t clkf                         : 7;
 	uint64_t reset_n                      : 1;
-	uint64_t reserved_8_17                : 10;
+	uint64_t clkf_ext                     : 1;
+	uint64_t reserved_9_17                : 9;
 	uint64_t ddr_ps_en                    : 4;
 	uint64_t ddr_div_reset                : 1;
 	uint64_t jtg_test_mode                : 1;
@@ -8807,29 +8809,30 @@ typedef union cvmx_lmcx_read_level_rankx cvmx_lmcx_read_level_rankx_t;
  * cvmx_lmc#_reset_ctl
  *
  * "Specify the RSL base addresses for the block.
- * &quot;DDR3RST DDR3 DRAM parts have a RESET# pin that wasn't present in DDR2 parts. The DDR3RST
- * CSR field controls the assertion of the 7xxx pin that attaches to RESET#. When DDR3RST is set,
- * 6xxx asserts RESET#. When DDR3RST is clear, 6xxx de-asserts RESET#. DDR3RST is set on a cold
- * reset. Warm and soft chip resets do not affect the DDR3RST value. Outside of cold reset, only
- * software CSR writes change the DDR3RST value. DDR3PWARM Enables preserve mode during a warm
- * reset. When set, the DDR3 controller hardware automatically puts the attached DDR3 DRAM parts
- * into self refresh (see LMC*CONFIG[SEQ_SEL] below) at the beginning of a warm reset sequence,
- * provided that the DDR3 controller is up. When clear, the DDR3 controller hardware does not put
- * the attached DDR3 DRAM parts into self-refresh during a warm reset sequence. DDR3PWARM is
- * cleared on a cold reset. Warm and soft chip resets do not affect the DDR3PWARM value. Outside
- * of cold reset, only software CSR writes change the DDR3PWARM value. Note that if a warm reset
- * follows a soft reset, DDR3PWARM has no effect, as the DDR3 controller is no longer up after
- * any cold/warm/soft reset sequence. DDR3PSOFT Enables preserve mode during a soft reset. When
- * set, the DDR3 controller hardware automatically puts the attached DDR3 DRAM parts into self
- * refresh (see LMC*CONFIG[SEQ_SEL] below) at the beginning of a soft reset sequence, provided
- * that the DDR3 controller is up. When clear, the DDR3 controller hardware does not put the
- * attached DDR3 DRAM parts into self-refresh during a soft reset sequence. DDR3PSOFT is cleared
- * on a cold reset. Warm and soft chip resets do not affect the DDR3PSOFT value. Outside of cold
- * reset, only software CSR writes change the DDR3PSOFT value. DDR3PSV May be useful for system
- * software to determine when the DDR3 contents have been preserved. Cleared by hardware during a
- * cold reset. Never cleared by hardware during a warm/soft reset. Set by hardware during a
- * warm/soft reset if the hardware automatically put the DDR3 DRAM into self-refresh during the
- * reset sequence. Can also be written by software (to any value).&quot;"
+ * INTERNAL: DDR3RST DDR3 DRAM parts have a RESET# pin that wasn't present in DDR2 parts. The
+ * DDR3RST CSR field controls the assertion of the 7xxx pin that attaches to RESET#. When DDR3RST
+ * is set, 6xxx asserts RESET#. When DDR3RST is clear, 6xxx de-asserts RESET#. DDR3RST is set on
+ * a cold reset. Warm and soft chip resets do not affect the DDR3RST value. Outside of cold
+ * reset, only software CSR writes change the DDR3RST value. DDR3PWARM Enables preserve mode
+ * during a warm reset. When set, the DDR3 controller hardware automatically puts the attached
+ * DDR3 DRAM parts into self refresh (see LMC*CONFIG[SEQ_SEL] below) at the beginning of a warm
+ * reset sequence, provided that the DDR3 controller is up. When clear, the DDR3 controller
+ * hardware does not put the attached DDR3 DRAM parts into self-refresh during a warm reset
+ * sequence. DDR3PWARM is cleared on a cold reset. Warm and soft chip resets do not affect the
+ * DDR3PWARM value. Outside of cold reset, only software CSR writes change the DDR3PWARM value.
+ * Note that if a warm reset follows a soft reset, DDR3PWARM has no effect, as the DDR3
+ * controller is no longer up after any cold/warm/soft reset sequence. DDR3PSOFT Enables preserve
+ * mode during a soft reset. When set, the DDR3 controller hardware automatically puts the
+ * attached DDR3 DRAM parts into self refresh (see LMC*CONFIG[SEQ_SEL] below) at the beginning of
+ * a soft reset sequence, provided that the DDR3 controller is up. When clear, the DDR3
+ * controller hardware does not put the attached DDR3 DRAM parts into self-refresh during a soft
+ * reset sequence. DDR3PSOFT is cleared on a cold reset. Warm and soft chip resets do not affect
+ * the DDR3PSOFT value. Outside of cold reset, only software CSR writes change the DDR3PSOFT
+ * value. DDR3PSV May be useful for system software to determine when the DDR3 contents have been
+ * preserved. Cleared by hardware during a cold reset. Never cleared by hardware during a
+ * warm/soft reset. Set by hardware during a warm/soft reset if the hardware automatically put
+ * the DDR3 DRAM into self-refresh during the reset sequence. Can also be written by software (to
+ * any value)."
  */
 union cvmx_lmcx_reset_ctl {
 	uint64_t u64;
@@ -9446,7 +9449,8 @@ union cvmx_lmcx_seq_ctl {
                                                          DRAM). DDR*_DIMM*_CKE* signals are activated (if not already active). RDIMM register
                                                          control words 0-15 are written to LMC(0..3)_CONFIG[RANKMASK]-selected RDIMMs when
                                                          LMC(0..3)_CONTROL[RDIMM_ENA] = 1 and corresponding LMC(0..3)_DIMM_CTL[DIMM*_WMASK] bits
-                                                         are set. (Refer to LMC(0..3)_DIMM0/1_PARAMS and LMC(0..3)_DIMM_CTL descriptions for more
+                                                         are set. (Refer to LMC(0..3)_DIMM(0..1)_PARAMS and LMC(0..3)_DIMM_CTL descriptions for
+                                                         more
                                                          details.)
                                                          The DRAM registers MR0, MR1, MR2, and MR3 are written in the selected ranks.
                                                          0x1 = Read-leveling:
@@ -9470,7 +9474,7 @@ union cvmx_lmcx_seq_ctl {
                                                          DRAM). In DDR3 mode, RDIMM register control words 0-15 are written to
                                                          LMC(0..3)_CONFIG[RANKMASK]-selected RDIMMs when LMC(0..3)_CONTROL[RDIMM_ENA] = 1 and
                                                          corresponding LMC(0..3)_DIMM_CTL[DIMM*_WMASK] bits are set. (Refer to
-                                                         LMC(0..3)_DIMM0/1_PARAMS and LMC(0..3)_DIMM_CTL descriptions for more details.) */
+                                                         LMC(0..3)_DIMM(0..1)_PARAMS and LMC(0..3)_DIMM_CTL descriptions for more details.) */
 	uint64_t init_start                   : 1;  /**< A 0->1 transition starts the DDR memory sequence that is selected by SEQ_SEL. This
                                                          register is a one-shot and clears itself each time it is set. */
 #else
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index eae4d32..10e915b 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -8777,10 +8777,11 @@ typedef union cvmx_mio_twsx_twsi_sw cvmx_mio_twsx_twsi_sw_t;
  * cvmx_mio_uart#_dlh
  *
  * The 8-bit divisor latch high register in conjunction with the 8-bit divisor latch low
- * (MIO_UART0/1_DLL) register form a 16-bit, read/write, Divisor Latch register that contains the
- * baud-rate divisor for the UART. It is accessed by first setting MIO_UART0/1_LCR[DLAB] (bit 7)
- * (refer to MIO UART Line Control Register). The output baud rate is equal to the coprocessor-
- * clock frequency divided by sixteen times the value of the baud-rate divisor, as follows:
+ * (MIO_UART(0..1)_DLL) register form a 16-bit, read/write, Divisor Latch register that contains
+ * the baud-rate divisor for the UART. It is accessed by first setting MIO_UART(0..1)_LCR[DLAB]
+ * (bit 7) (refer to MIO UART Line Control Register). The output baud rate is equal to the
+ * coprocessor-clock frequency divided by sixteen times the value of the baud-rate divisor, as
+ * follows:
  * baud rate = coprocessor-clock frequency / (16 * divisor).
  * Note that once both divisor latch registers are set, at least eight coprocessor-clock cycles
  * should be allowed to pass before transmitting or receiving data.
@@ -8824,10 +8825,11 @@ typedef cvmx_mio_uartx_dlh_t cvmx_uart_dlh_t;
  * cvmx_mio_uart#_dll
  *
  * The 8-bit divisor latch high register in conjunction with the 8-bit divisor latch low
- * (MIO_UART0/1_DLL) register form a 16-bit, read/write, Divisor Latch register that contains the
- * baud-rate divisor for the UART. It is accessed by first setting MIO_UART0/1_LCR[DLAB] (bit 7)
- * (refer to MIO UART Line Control Register). The output baud rate is equal to the coprocessor-
- * clock frequency divided by sixteen times the value of the baud-rate divisor, as follows:
+ * (MIO_UART(0..1)_DLL) register form a 16-bit, read/write, Divisor Latch register that contains
+ * the baud-rate divisor for the UART. It is accessed by first setting MIO_UART(0..1)_LCR[DLAB]
+ * (bit 7) (refer to MIO UART Line Control Register). The output baud rate is equal to the
+ * coprocessor-clock frequency divided by sixteen times the value of the baud-rate divisor, as
+ * follows:
  * baud rate = coprocessor-clock frequency / (16 * divisor).
  * Note that once both divisor latch registers are set, at least eight coprocessor-clock cycles
  * should be allowed to pass before transmitting or receiving data.
@@ -8872,10 +8874,10 @@ typedef cvmx_mio_uartx_dll_t cvmx_uart_dll_t;
  *
  * The FIFO access register is used to enable a FIFO-access mode for testing, so that the receive
  * FIFO can be written by software and the transmit FIFO can be read by software when the FIFOs
- * are enabled. When FIFOs are not enabled it allows the MIO_UART0/1_RBR to be written by
- * software and the MIO_UART0/1_THR to be read by software. Note, that when the FIFO-access mode
- * is enabled/disabled, the control portion of the receive FIFO and transmit FIFO is reset and
- * the FIFOs are treated as empty.
+ * are enabled. When FIFOs are not enabled it allows the MIO_UART(0..1)_RBR to be written by
+ * software and the MIO_UART(0..1)_THR to be read by software. Note, that when the FIFO-access
+ * mode is enabled/disabled, the control portion of the receive FIFO and transmit FIFO is reset
+ * and the FIFOs are treated as empty.
  */
 union cvmx_mio_uartx_far {
 	uint64_t u64;
@@ -9328,7 +9330,7 @@ typedef cvmx_mio_uartx_msr_t cvmx_uart_msr_t;
  *
  * The receive buffer register is a read-only register that contains the data byte received on
  * the serial input port (SIN). The data in this register is valid only if the
- * MIO_UART0/1_LSR[DR] bit is set (
+ * MIO_UART(0..1)_LSR[DR] bit is set (
  */
 union cvmx_mio_uartx_rbr {
 	uint64_t u64;
@@ -9410,7 +9412,7 @@ typedef cvmx_mio_uartx_rfl_t cvmx_uart_rfl_t;
  * cvmx_mio_uart#_rfw
  *
  * The receive FIFO write register is only valid when FIFO-access mode is enabled (i.e.
- * MIO_UART0/1_FAR[FAR] = 1).
+ * MIO_UART(0..1)_FAR[FAR] = 1).
  */
 union cvmx_mio_uartx_rfw {
 	uint64_t u64;
@@ -9455,8 +9457,8 @@ typedef cvmx_mio_uartx_rfw_t cvmx_uart_rfw_t;
  * cvmx_mio_uart#_sbcr
  *
  * The shadow break control register is a shadow register for the
- * MIO_UART0/1_LCR[BRK] bit that can be used to remove the burden of having to perform a read-
- * modify-write on MIO_UART0/1_LCR.
+ * MIO_UART(0..1)_LCR[BRK] bit that can be used to remove the burden of having to perform a read-
+ * modify-write on MIO_UART(0..1)_LCR.
  */
 union cvmx_mio_uartx_sbcr {
 	uint64_t u64;
@@ -9537,9 +9539,10 @@ typedef cvmx_mio_uartx_scr_t cvmx_uart_scr_t;
 /**
  * cvmx_mio_uart#_sfe
  *
- * The shadow FIFO enable register is a shadow register for MIO_UART0/1_FCR[EN] that can be used
- * to remove the burden of having to store the previously written value to MIO_UART0/1_FCR in
- * memory and having to mask this value so that only the FIFO enable bit gets updated.
+ * The shadow FIFO enable register is a shadow register for MIO_UART(0..1)_FCR[EN] that can be
+ * used to remove the burden of having to store the previously written value to
+ * MIO_UART(0..1)_FCR in memory and having to mask this value so that only the FIFO enable bit
+ * gets updated.
  */
 union cvmx_mio_uartx_sfe {
 	uint64_t u64;
@@ -9625,8 +9628,8 @@ typedef cvmx_mio_uartx_srr_t cvmx_uart_srr_t;
  * cvmx_mio_uart#_srt
  *
  * The shadow RX trigger register is a shadow register for the RX trigger bits
- * (MIO_UART0/1_FCR[RXTRIG]) that can be used to remove the burden of having to store the
- * previously written value to MIO_UART0/1_FCR in memory and having to mask this value so that
+ * (MIO_UART(0..1)_FCR[RXTRIG]) that can be used to remove the burden of having to store the
+ * previously written value to MIO_UART(0..1)_FCR in memory and having to mask this value so that
  * only the RX trigger bits get updated.
  */
 union cvmx_mio_uartx_srt {
@@ -9668,8 +9671,8 @@ typedef cvmx_mio_uartx_srt_t cvmx_uart_srt_t;
  * cvmx_mio_uart#_srts
  *
  * The shadow request to send register is a shadow register for the
- * MIO_UART0/1_MCR[RTS] bit that can be used to remove the burden of having to perform a read-
- * modify-write on MIO_UART0/1_MCR.
+ * MIO_UART(0..1)_MCR[RTS] bit that can be used to remove the burden of having to perform a read-
+ * modify-write on MIO_UART(0..1)_MCR.
  */
 union cvmx_mio_uartx_srts {
 	uint64_t u64;
@@ -9710,8 +9713,8 @@ typedef cvmx_mio_uartx_srts_t cvmx_uart_srts_t;
  * cvmx_mio_uart#_stt
  *
  * The shadow TX trigger register is a shadow register for the TX trigger bits
- * (MIO_UART0/1_FCR[TXTRIG]) that can be used to remove the burden of having to store the
- * previously written value to MIO_UART0/1_FCR in memory and having to mask this value so that
+ * (MIO_UART(0..1)_FCR[TXTRIG]) that can be used to remove the burden of having to store the
+ * previously written value to MIO_UART(0..1)_FCR in memory and having to mask this value so that
  * only the TX trigger bits get updated.
  */
 union cvmx_mio_uartx_stt {
@@ -9794,7 +9797,7 @@ typedef cvmx_mio_uartx_tfl_t cvmx_uart_tfl_t;
  * cvmx_mio_uart#_tfr
  *
  * The transmit FIFO read register is only valid when FIFO-access mode is enabled (i.e.
- * MIO_UART0/1_FAR[FAR] = 1).
+ * MIO_UART(0..1)_FAR[FAR] = 1).
  */
 union cvmx_mio_uartx_tfr {
 	uint64_t u64;
@@ -9835,8 +9838,8 @@ typedef cvmx_mio_uartx_tfr_t cvmx_uart_tfr_t;
  * cvmx_mio_uart#_thr
  *
  * The transmit holding register is a write-only register that contains data to be transmitted on
- * the serial output port (UART0/1_SOUT). Data can be written to MIO_UART0/1_THR any time that
- * MIO_UART0/1_LSR[THRE] = 1.
+ * the serial output port (UART0/1_SOUT). Data can be written to MIO_UART(0..1)_THR any time that
+ * MIO_UART(0..1)_LSR[THRE] = 1.
  */
 union cvmx_mio_uartx_thr {
 	uint64_t u64;
@@ -9877,7 +9880,7 @@ typedef cvmx_mio_uartx_thr_t cvmx_uart_thr_t;
  * cvmx_mio_uart#_usr
  *
  * The receive FIFO write register is only valid when FIFO-access mode is enabled (i.e.
- * MIO_UART0/1_FAR[FAR] = 1).
+ * MIO_UART(0..1)_FAR[FAR] = 1).
  */
 union cvmx_mio_uartx_usr {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
index 9ab137d..07a6fee 100644
--- a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
@@ -378,9 +378,9 @@ union cvmx_mixx_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t ts_thresh                    : 4;  /**< TimeStamp interrupt threshold. When the number of pending Timestamp interrupts
-                                                         (MIX0/1_TSCTL[TSCNT] is greater than
-                                                         MIX0/1_CTL[TS_THRESH], then a programmable TimeStamp interrupt is issued (see
-                                                         MIX0/1_INTR[TS], MIX0/1_INTENA[TSENA]).
+                                                         (MIX(0..1)_TSCTL[TSCNT] is greater than
+                                                         MIX(0..1)_CTL[TS_THRESH], then a programmable TimeStamp interrupt is issued (see
+                                                         MIX(0..1)_INTR[TS].
                                                          For CN78XX, since the implementation only supports four outstanding timestamp interrupts,
                                                          this field should only be programmed from [0..3]. */
 	uint64_t crc_strip                    : 1;  /**< Hardware CRC strip enable. When enabled, the last 4 bytes (CRC) of the ingress packet are
@@ -398,15 +398,15 @@ union cvmx_mixx_ctl {
                                                          reset.
                                                          During a soft reset, CSR accesses are not effected. However, the values of the fields are
                                                          affected by soft reset (except
-                                                         MIX0/1_CTL[RESET] itself).
+                                                         MIX(0..1)_CTL[RESET] itself).
                                                          After power-on, the MIX-BGX are held in reset until RESET is written to 0. Software must
-                                                         also perform a MIX0/1_CTL CSR read after this write to ensure the soft reset de-assertion
-                                                         has had sufficient time to propagate to all MIO-MIX internal logic before any subsequent
-                                                         MIX CSR accesses are issued.
+                                                         also perform a MIX(0..1)_CTL CSR read after this write to ensure the soft reset de-
+                                                         assertion has had sufficient time to propagate to all MIO-MIX internal logic before any
+                                                         subsequent MIX CSR accesses are issued.
                                                          The intended 'soft reset' sequence is:
                                                          Write EN = 0 (to prevent any NEW transactions from being started)
                                                          Wait for BUSY = 0 (to indicate that all in-flight transactions have completed)
-                                                         Write RESET = 1, followed by a MIX0/1_CTL register read and wait for the result.
+                                                         Write RESET = 1, followed by a MIX(0..1)_CTL register read and wait for the result.
                                                          Re-initialize the MIX just as would be done for a hard reset.
                                                          Once the MIX has been soft-reset, please refer to MIX Bring-up Sequence, MIX Bring-up
                                                          Sequence to complete the MIX re-initialization sequence.
@@ -730,9 +730,7 @@ union cvmx_mixx_irhwm {
                                                          enough so that packets are not dropped by CN78XX. */
 	uint64_t irhwm                        : 20; /**< I-Ring entry high-watermark threshold. Used to determine when the number of inbound
                                                          packets in system memory
-                                                         (MIX0/1_IRCNT[IRCNT]) exceeds this IRHWM threshold.
-                                                         The power-on value of the CIU_INTx_EN*[RGMII] interrupt enable bits is 0 and must be
-                                                         enabled to allow interrupts to be reported. */
+                                                         (MIX(0..1)_IRCNT[IRCNT]) exceeds this IRHWM threshold. */
 #else
 	uint64_t irhwm                        : 20;
 	uint64_t ibplwm                       : 20;
@@ -850,7 +848,7 @@ union cvmx_mixx_iring2 {
 	uint64_t itlptr                       : 20; /**< The inbound ring (I-Ring) tail pointer selects the I-Ring entry that the hardware will
                                                          process next. After the hardware completes receiving an inbound packet, it increments the
                                                          I-Ring tail pointer.
-                                                         The I-Ring tail pointer hardware increment is always modulo MIX0/1_IRING2[ISIZE].
+                                                         The I-Ring tail pointer hardware increment is always modulo MIX(0..1)_IRING2[ISIZE].
                                                          This field is read-only to software. */
 	uint64_t reserved_20_31               : 12;
 	uint64_t idbell                       : 20; /**< Represents the cumulative total of pending inbound ring (I-Ring) buffer entries. Each
@@ -861,7 +859,7 @@ union cvmx_mixx_iring2 {
                                                          inbound ring.' When the MIX hardware receives the doorbell ring, it advances the doorbell
                                                          count for the I-Ring.
                                                          Software must never cause the doorbell count for the I-Ring to exceed the size of
-                                                         MIX0/1_IRING1[ISIZE]. A read of the CSR indicates the current doorbell count. */
+                                                         MIX(0..1)_IRING1[ISIZE]. A read of the CSR indicates the current doorbell count. */
 #else
 	uint64_t idbell                       : 20;
 	uint64_t reserved_20_31               : 12;
@@ -895,71 +893,58 @@ union cvmx_mixx_isr {
 	struct cvmx_mixx_isr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t ts                           : 1;  /**< Timestamp interrupt. Throws MIX_INTSN_E::MIX(0..1)_INT_TS. When the number of pending
-                                                         timestamp interrupts (MIX0/1_TSCTL[TSCNT]) is greater than the timestamp interrupt
-                                                         threshold (MIX0/1_CTL[TS_THRESH]) value, this interrupt bit is set.
-                                                         If both the global interrupt mask bits (CIU_INTx[RGMII]) and this local interrupt mask bit
-                                                         is set, than an interrupt is reported for an Outbound Ring with Timestamp event. (See
-                                                         MIX0/1_INTENA[TSENA]). */
+	uint64_t ts                           : 1;  /**< Timestamp interrupt. Throws MIX_INTSN_E:MIX(0..1)_INT_TS. This bit is set and the
+                                                         interrupt generated when the number of pending timestamp interrupts
+                                                         (MIX(0..1)_TSCTL[TSCNT]) is greater than the timestamp interrupt threshold
+                                                         (MIX(0..1)_CTL[TS_THRESH]) value. */
 	uint64_t orun                         : 1;  /**< O-ring packet count underflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_ORUN. If
-                                                         software writes a larger value than what is currently in the MIX0/1_ORCNT[ORCNT], then
+                                                         software writes a larger value than what is currently in the MIX(0..1)_ORCNT[ORCNT], then
                                                          hardware reports the underflow condition.
-                                                         The MIX0/1_ORCNT[IOCNT] will clamp to zero.
+                                                         The MIX(0..1)_ORCNT[IOCNT] will clamp to zero.
                                                          If an ORUN underflow condition is detected, the integrity of the MIX hardware state has
                                                          been compromised. To recover, Software must issue a software reset sequence. (See
-                                                         MIX0/1_CTL[RESET.] */
+                                                         MIX(0..1)_CTL[RESET.] */
 	uint64_t irun                         : 1;  /**< I-ring packet count underflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_IRUN. If
-                                                         software writes a larger value than what is currently in the MIX0/1_IRCNT[IRCNT], then
+                                                         software writes a larger value than what is currently in the MIX(0..1)_IRCNT[IRCNT], then
                                                          hardware reports the underflow condition.
-                                                         The MIX0/1_IRCNT[IRCNT] will clamp to zero.
+                                                         The MIX(0..1)_IRCNT[IRCNT] will clamp to zero.
                                                          If an IRUN underflow condition is detected, the integrity of the MIX hardware state has
                                                          been compromised. To recover, software must issue a software reset sequence. (See
-                                                         MIX0/1_CTL[RESET]). */
+                                                         MIX(0..1)_CTL[RESET]). */
 	uint64_t data_drp                     : 1;  /**< Data was dropped due to RX FIFO full. Throws MIX_INTSN_E::MIX(0..1)_INT_DATA_DRP. If this
-                                                         does occur, the DATA_DRP is set and the CIU_INTx_SUM0/4[RGMII] bit is set.
-                                                         If both the global interrupt mask bits (CIU_INTx[RGMII]) and the local interrupt mask
-                                                         bit(DATA_DRPENA) is set, than an interrupt is reported for this event. */
+                                                         event does occur, DATA_DRP is set and the interrupt is generated. */
 	uint64_t irthresh                     : 1;  /**< Inbound ring packet threshold exceeded. Throws MIX_INTSN_E::MIX(0..1)_INT_IRTHRESH. When
                                                          the pending number of inbound packets in system memory (IRCNT) has exceeded a programmable
-                                                         threshold (IRHWM), this bit is set. If this does occur, the IRTHRESH is set and the
-                                                         CIU_INTx_SUM0/4[RGMII] bit is set if ((MIX_ISR & MIX_INTENA) != 0)).
-                                                         If both the global interrupt mask bits (CIU_INTx[RGMII]) and the local interrupt mask bit
-                                                         (ITHENA) is set, than an interrupt is reported for this event. */
+                                                         threshold (IRHWM), this bit is set and the interrupt is generated. */
 	uint64_t orthresh                     : 1;  /**< Outbound ring packet threshold exceeded. Throws MIX_INTSN_E::MIX(0..1)_INT_ORTHRESH. When
                                                          the pending number of outbound packets in system memory (ORCNT) has exceeded a
-                                                         programmable threshold (ORHWM), this bit is set. If this does occur, the ORTHRESH is set
-                                                         and the CIU_INTx_SUM0/4[RGMII] bit is set if ((MIX_ISR & MIX_INTENA) != 0)).
-                                                         If both the global interrupt mask bits (CIU_INTx[RGMII]) and the local interrupt mask bit
-                                                         (OTHENA) is set, than an interrupt is reported for this event. */
+                                                         programmable threshold (ORHWM), this bit is set and the interrupt is generated. */
 	uint64_t idblovf                      : 1;  /**< "Inbound doorbell (IDBELL) overflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_IDBLOVF.
-                                                         If software attempts to write to the MIX0/1_IRING2[IDBELL] with a value greater than the
-                                                         remaining number of I-Ring buffer entries
-                                                         (MIX0/1_REMCNT[IREMCNT]), then the following occurs:
-                                                         The MIX0/1_IRING2[IDBELL] write is IGNORED
-                                                         The ODBLOVF is set and the CIU_INTx_SUM0/4[RGMII] bits are set if ((MIX0/1_ISR &
-                                                         MIX0/1_INTENA) != 0)).
-                                                         If both the global interrupt mask bits (CIU_INTx[RGMII]) and the local interrupt mask bit
-                                                         (IVFENA) is set, an interrupt is reported for this event.
+                                                         If software attempts to write to the MIX(0..1)_IRING2[IDBELL] with a value greater than
+                                                         the remaining number of I-Ring buffer entries
+                                                         (MIX(0..1)_REMCNT[IREMCNT]), then the following occurs:
+                                                         The MIX(0..1)_IRING2[IDBELL] write is IGNORED
+                                                         The ODBLOVF is set and an interrupt is generated.
                                                          Software should keep track of the \# of I-Ring entries in use (i.e. the cumulative number
                                                          of IDBELL write operations), and ensure that future IDBELL write operations don't exceed
-                                                         the size of the I-Ring Buffer (MIX0/1_IRING2[ISIZE]). Software must reclaim I-Ring entries
-                                                         by keeping track of the number of IRing entries, and writing to the MIX0/1_IRCNT[IRCNT].
-                                                         The MIX0/1_IRCNT[IRCNT] register represents the total number of packets (not IRing
+                                                         the size of the I-Ring Buffer (MIX(0..1)_IRING2[ISIZE]). Software must reclaim I-Ring
+                                                         entries by keeping track of the number of IRing entries, and writing to the
+                                                         MIX(0..1)_IRCNT[IRCNT].
+                                                         The MIX(0..1)_IRCNT[IRCNT] register represents the total number of packets (not IRing
                                                          entries) and software must further keep track of the number of I-Ring entries associated
                                                          with each packet as they are processed.
                                                          There is no recovery from an IDBLOVF Interrupt. If it occurs, it is an indication that
                                                          software has overwritten the I-Ring buffer, and the only recourse is a hardware reset." */
 	uint64_t odblovf                      : 1;  /**< Outbound doorbell (ODBELL) overflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_ODBLOVF.
-                                                         If software attempts to write to MIX0/1_ORING2[ODBELL] with a value greater than the
+                                                         If software attempts to write to MIX(0..1)_ORING2[ODBELL] with a value greater than the
                                                          remaining number of O-Ring buffer entries
-                                                         (MIX0/1_REMCNT[OREMCNT]), then the following occurs:
-                                                         The MIX0/1_ORING2[ODBELL] write operation is IGNORED
-                                                         ODBLOVF is set and the CIU_INTx_SUM0/4[RGMII] bits are set if ((MIX0/1_ISR &
-                                                         MIX0/1_INTENA) != 0)).
+                                                         (MIX(0..1)_REMCNT[OREMCNT]), then the following occurs:
+                                                         The MIX(0..1)_IRING2[ODBELL] write operation is IGNORED
+                                                         ODBLOVF is set and the interrupt is generated.
                                                          Software should keep track of the number of I-Ring entries in use (i.e. the cumulative
                                                          number of ODBELL write operations), and ensure that future ODBELL write operations don't
-                                                         exceed the size of the O-Ring buffer (MIX0/1_ORING2[OSIZE]). Software must reclaim O-Ring
-                                                         entries by writing to MIX0/1_ORCNT[ORCNT].
+                                                         exceed the size of the O-Ring buffer (MIX(0..1)_ORING2[OSIZE]). Software must reclaim
+                                                         O-Ring entries by writing to MIX(0..1)_ORCNT[ORCNT].
                                                          There is no recovery from an ODBLOVF Interrupt. If it occurs, it is an indication that
                                                          software has overwritten the O-Ring buffer, and the only recourse is a hardware reset. */
 #else
@@ -1106,8 +1091,8 @@ union cvmx_mixx_orcnt {
                                                          Reading ORCNT returns the current count.
                                                          Writing ORCNT decrements the count by the value written.
                                                          This register is used to generate interrupts to alert software of pending outbound MIX
-                                                         packets that have been removed from system memory. (See MIX0/1_ISR[ORTHRESH] description
-                                                         for more details.)
+                                                         packets that have been removed from system memory. (See MIX(0..1)_ISR[ORTHRESH]
+                                                         description for more details.)
                                                          For outbound packets, the number of O-Ring Packets is equal to the number of O-Ring
                                                          Entries. */
 #else
@@ -1141,10 +1126,8 @@ union cvmx_mixx_orhwm {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t orhwm                        : 20; /**< O-Ring entry high-watermark threshold. Used to determine when the number of outbound
-                                                         packets in system memory that can be reclaimed (MIX0/1_ORCNT[ORCNT]) exceeds this ORHWM
-                                                         threshold.
-                                                         The power-on value of the CIU_INTx_EN*[RGMII] interrupt enable bits is 0 and must be
-                                                         enabled to allow interrupts to be reported. */
+                                                         packets in system memory that can be reclaimed (MIX(0..1)_ORCNT[ORCNT]) exceeds this ORHWM
+                                                         threshold. */
 #else
 	uint64_t orhwm                        : 20;
 	uint64_t reserved_20_63               : 44;
@@ -1261,7 +1244,7 @@ union cvmx_mixx_oring2 {
 	uint64_t otlptr                       : 20; /**< The outbound ring tail pointer selects the O-Ring entry that the hardware will process
                                                          next. After the hardware completes sending an outbound packet, it increments the O-Ring
                                                          tail pointer.
-                                                         The O-Ring tail pointer hardware increment is always modulo MIX0/1_ORING2[OSIZE].
+                                                         The O-Ring tail pointer hardware increment is always modulo MIX(0..1)_ORING2[OSIZE].
                                                          This field is read-only to software. */
 	uint64_t reserved_20_31               : 12;
 	uint64_t odbell                       : 20; /**< Represents the cumulative total of pending outbound ring (O-Ring) buffer entries. Each
@@ -1272,7 +1255,7 @@ union cvmx_mixx_oring2 {
                                                          count of the newly inserted entries.' When the MIX hardware receives the doorbell ring, it
                                                          increments the current doorbell count by the CSR write value.
                                                          Software must never cause the doorbell count for the O-Ring to exceed the size of
-                                                         MIX0/1_ORING1[OSIZE]. A read of the CSR indicates the current doorbell count. */
+                                                         MIX(0..1)_ORING1[OSIZE]. A read of the CSR indicates the current doorbell count. */
 #else
 	uint64_t odbell                       : 20;
 	uint64_t reserved_20_31               : 12;
@@ -1307,19 +1290,19 @@ union cvmx_mixx_remcnt {
 	uint64_t reserved_52_63               : 12;
 	uint64_t iremcnt                      : 20; /**< Remaining I-Ring buffer count. Reflects the number of unused/remaining I-Ring entries that
                                                          hardware currently detects in the I-Ring buffer. Hardware uses this value to detect I-Ring
-                                                         doorbell overflows. (See MIX0/1_ISR[IDBLOVF].)
-                                                         When software writes the MIX0/1_IRING1[ISIZE], IREMCNT is loaded with the
-                                                         MIX0/1_IRING2[ISIZE] value. (Note: ISIZE should only be written at power-on, when it is
+                                                         doorbell overflows. (See MIX(0..1)_ISR[IDBLOVF].)
+                                                         When software writes the MIX(0..1)_IRING1[ISIZE], IREMCNT is loaded with the
+                                                         MIX(0..1)_IRING2[ISIZE] value. (Note: ISIZE should only be written at power-on, when it is
                                                          known that there are no I-Ring entries currently in use by hardware.) When software writes
                                                          to the IDBELL register, the IREMCNT is decremented by the CSR write value. When hardware
                                                          issues an I-Ring write request (onto the IOI), REMCNT is incremented by 1. */
 	uint64_t reserved_20_31               : 12;
 	uint64_t oremcnt                      : 20; /**< Remaining O-Ring buffer count. Reflects the number of unused/remaining O-Ring entries that
                                                          hardware currently detects in the O-Ring buffer. Hardware uses this value to detect O-Ring
-                                                         doorbell overflows. (See MIX0/1_ISR[ODBLOVF].)
-                                                         When software writes the MIX0/1_IRING1[OSIZE], OREMCNT is loaded with the
-                                                         MIX0/1_ORING2[OSIZE] value. (Note: [OSIZE] should only be written at power-on, when it is
-                                                         known that no O-Ring entries are currently in use by hardware.) When software writes to
+                                                         doorbell overflows. (See MIX(0..1)_ISR[ODBLOVF].)
+                                                         When software writes the MIX(0..1)_ORING1[OSIZE], OREMCNT is loaded with the
+                                                         MIX(0..1)_ORING2[OSIZE] value. (Note: [OSIZE] should only be written at power-on, when it
+                                                         is known that no O-Ring entries are currently in use by hardware.) When software writes to
                                                          the ODBELL register, OREMCNT is decremented by the CSR write value. When software writes
                                                          to OREMCNT, it is decremented by the CSR write value. */
 #else
@@ -1350,14 +1333,14 @@ typedef union cvmx_mixx_remcnt cvmx_mixx_remcnt_t;
  * to determine the number pending timestamp interrupts ([TSCNT]), the number outstanding
  * timestamp requests in flight ([TSTOT]), and the number of available timestamp entries (TSAVL)
  * in the timestamp FIFO.
- * Writing to this register advances the MIX0/1_TSTAMP FIFO head pointer by 1 and decrements the
- * [TSCNT, TSTOT] pending counts by 1. For example, if software reads [TSCNT] = 2 (two pending
- * timestamp interrupts), it would immediately issue this sequence:
- * a MIX0/1_TSTAMP[TSTAMP] read operation followed by MIX0/1_TSCTL write operation (i.e. it gets
- * the timestamp value, pops the timestamp FIFO, and decrements pending counts by 1).
- * a MIX0/1_TSTAMP[TSTAMP] read operation followed by MIX0/1_TSCTL write operation.
- * Note for Software: A MIX0/1_TSCTL write operation is ignored when
- * MIX0/1_TSCTL[TSCNT] = 0 (i.e., TimeStamp FIFO empty).
+ * Writing to this register advances the MIX(0..1)_TSTAMP FIFO head pointer by 1 and decrements
+ * the [TSCNT, TSTOT] pending counts by 1. For example, if software reads [TSCNT] = 2 (two
+ * pending timestamp interrupts), it would immediately issue this sequence:
+ * a MIX(0..1)_TSTAMP[TSTAMP] read operation followed by MIX(0..1)_TSCTL write operation (i.e. it
+ * gets the timestamp value, pops the timestamp FIFO, and decrements pending counts by 1).
+ * a MIX(0..1)_TSTAMP[TSTAMP] read operation followed by MIX(0..1)_TSCTL write operation.
+ * Note for Software: A MIX(0..1)_TSCTL write operation is ignored when
+ * MIX(0..1)_TSCTL[TSCNT] = 0 (i.e., TimeStamp FIFO empty).
  */
 union cvmx_mixx_tsctl {
 	uint64_t u64;
@@ -1407,26 +1390,25 @@ union cvmx_mixx_tstamp {
                                                          sent to the BGX. Later the BGX sends sample strobe(s) to capture a global 64-bit timestamp
                                                          value, followed by a 'commit' strobe which writes the last sampled value into the outbound
                                                          timestamp FIFO (max depth = 4) and increments
-                                                         MIX0/1_TSCTL[TSCNT] to indicate the total number of pending timestamp interrupts.
-                                                         If the number of pending timestamp interrupts (MIX0/1_TSCTL[TSCNT]) is greater than the
-                                                         MIX0/1_CTL[TS_THRESH] value, then a programmable interrupt is also triggered (see
-                                                         MIX0/1_ISR[TS] and
-                                                         MIX0/1_INTENA[TSENA]).
-                                                         Software then reads MIX0/1_TSTAMP[TSTAMP], and must then write MIX0/1_TSCTL, which will
-                                                         decrement MIX0/1_TSCTL[TSCNT] to indicate that a single timestamp interrupt has been
-                                                         serviced.
+                                                         MIX(0..1)_TSCTL[TSCNT] to indicate the total number of pending timestamp interrupts.
+                                                         If the number of pending timestamp interrupts (MIX(0..1)_TSCTL[TSCNT]) is greater than the
+                                                         MIX(0..1)_CTL[TS_THRESH] value, then a programmable interrupt is also triggered (see
+                                                         MIX(0..1)_ISR[TS].
+                                                         Software then reads MIX(0..1)_TSTAMP[TSTAMP], and must then write MIX(0..1)_TSCTL, which
+                                                         will decrement MIX(0..1)_TSCTL[TSCNT] to indicate that a single timestamp interrupt has
+                                                         been serviced.
                                                          The MIO-MIX hardware tracks up to MAX = 4 outstanding timestamped outbound packets at a
                                                          time. All subsequent O-RING entries with SOP-TSTAMP will be stalled until software can
                                                          service the 4 outstanding interrupts. Software can read
-                                                         MIX0/1_TSCTL to determine the number of pending timestamp interrupts (TSCNT), plus the
+                                                         MIX(0..1)_TSCTL to determine the number of pending timestamp interrupts (TSCNT), plus the
                                                          number of outstanding timestamp requests in flight (TSTOT), as well as the number of
                                                          available timestamp entries (TSAVL).
                                                          A MIX_TSTAMP read when
-                                                         MIX_TSCTL[TSCNT] = 0 will result in a return value of all zeroes. Software should only
-                                                         read this register when
-                                                         MIX0/1_ISR[TS] = 1 (or when MIX0/1_TSCTL[TSCNT] != 0) to retrieve the timestamp value
-                                                         recorded by hardware. If software reads the TSTAMP when hardware has not recorded a valid
-                                                         timestamp, then an all zeroes value is returned. */
+                                                         MIX(0..1)_TSCTL[TSCNT] = 0 will result in a return value of all zeroes. Software should
+                                                         only read this register when
+                                                         MIX(0..1)_ISR[TS] = 1 (or when MIX(0..1)_TSCTL[TSCNT] != 0) to retrieve the timestamp
+                                                         value recorded by hardware. If software reads the TSTAMP when hardware has not recorded a
+                                                         valid timestamp, then an all zeroes value is returned. */
 #else
 	uint64_t tstamp                       : 64;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index e087985..ff2d96c 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -568,8 +568,9 @@ union cvmx_oclax_fifo_limit {
 	struct cvmx_oclax_fifo_limit_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t overfull                     : 16; /**< Stop level. When OCLA(0..4)_FIFO_DEPTH > OVERFULL, stop capturing and set
-                                                         OCLA(0..4)_STATE_INT[OVERFULL]. This should be set to just less than the FIFO size when
-                                                         using DDR capture to insure that overflow can be detected. */
+                                                         OCLA(0..4)_STATE_INT[OVERFULL]. This should be set to no more than
+                                                         OCLA(0..4)_CONST[DAT_SIZE] minus 26 when using DDR capture to insure that overflow can be
+                                                         detected. */
 	uint64_t ddr                          : 16; /**< DDR level. When OCLA(0..4)_FIFO_DEPTH > DDR, FIFO entries will be removed, packed into a
                                                          cache line, and overflowed to DDR/L2. All-ones disables overflow to DDR/L2. If non-zero
                                                          must be at least 28. */
@@ -617,7 +618,8 @@ union cvmx_oclax_fifo_trig {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t limit                        : 16; /**< Post-trigger number of entries to collect before stopping collection. If zero, collection
-                                                         will never stop, which may be desirable when overflowing to DDR/L2. */
+                                                         will never stop, which may be desirable when overflowing to DDR/L2. Must be <
+                                                         OCLA(0..4)_CONST[DAT_SIZE] - 5. */
 	uint64_t cnt                          : 16; /**< Number of entries collected since trigger. Cleared when OCLA(0..4)_STATE_INT[TRIG] clear. */
 #else
 	uint64_t cnt                          : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 2c4e11a..f3b26d3 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -1063,20 +1063,18 @@ union cvmx_ocx_com_node {
 	uint64_t fixed                        : 1;  /**< ID Valid associated with the chip. This register is used by the link initialization
                                                          software to help assign IDs and is transmitted over OCI. The FIXED field set during a cold
                                                          reset to the value of the OCI_FIXED_ID pin. The value is also be readable in the
-                                                         OCX_LNE(0..23)_STS_MSG[TX_META_DAT[2]] for each lane.  The FIXED pin of the link partner
-                                                         can
-                                                         be examined by locally reading the OCX_LNE(0..23)_STS_MSG[RX_META_DAT[2]] on each valid
-                                                         lane
-                                                         or remotely reading the OCX_COM_NODE[FIXED] on the link partner. */
+                                                         OCX_LNE(0..23)_STS_MSG[TX_META_DAT[2]] for each lane.
+                                                         The FIXED field of the link partner can be examined by locally reading the
+                                                         OCX_LNE(0..23)_STS_MSG[RX_META_DAT[2]] on each valid lane or remotely reading the
+                                                         OCX_COM_NODE[FIXED] on the link partner. */
 	uint64_t id                           : 2;  /**< Node ID associated with the chip. This register is used by the rest of the chip to
                                                          determine what traffic is transmitted over OCI. The value should not match the
                                                          OCX_COM_LINK(0..2)_CTL[ID] of any active link. The ID field is set during a cold reset to
                                                          the value of the OCI_NODE_ID pins. The value is also be readable in the
-                                                         OCX_LNE(0..23)_STS_MSG[TX_META_DAT[1:0]] for each lane.  The FIXED pin of the link partner
-                                                         can
-                                                         be examined by locally reading the OCX_LNE(0..23)_STS_MSG[RX_META_DAT[1:0]] on each valid
-                                                         lane
-                                                         or remotely reading the OCX_COM_NODE[ID] on the link partner. */
+                                                         OCX_LNE(0..23)_STS_MSG[TX_META_DAT[1:0]] for each lane.
+                                                         The ID field of the link partner can be examined by locally reading the
+                                                         OCX_LNE(0..23)_STS_MSG[RX_META_DAT[1:0]] on each valid lane or remotely reading the
+                                                         OCX_COM_NODE[ID] on the link partner. */
 #else
 	uint64_t id                           : 2;
 	uint64_t fixed                        : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-osm-defs.h b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
index 9191ff0..bb4c364 100644
--- a/arch/mips/include/asm/octeon/cvmx-osm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
@@ -138,18 +138,21 @@ union cvmx_osm_ase_rate_limit_ctrl {
 	struct cvmx_osm_ase_rate_limit_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t rwc_rate_limit               : 1;  /**< To support ASE running at SCLK/2, OSM can rate-limit responses sent back to ASE. Each
-                                                         request is assigned to either phase 0 or phase 1. When set, OSM does not send back-to-back
+	uint64_t rwc_rate_limit               : 1;  /**< Reserved. INTERNAL: Must be enabled when ASE is running at SCLK/2. If ASE is running at
+                                                         SCLK/1, this should be disabled for best performance. Mechanism: Each request is assigned
+                                                         to either phase 0 or phase 1. When feature is enabled, OSM does not send back-to-back
                                                          responses for requests on the RWC ports with the same phase. Instead, a idle cycle is
                                                          inserted between the responses. This enable applies to RWC ports. */
-	uint64_t bwc_rate_limit               : 1;  /**< To support ASE running at SCLK/2, OSM can rate-limit responses sent back to ASE. Each
-                                                         request is assigned to either phase 0 or phase 1. When set, OSM does not send back-to-back
-                                                         responses for requests on the BWC port with the same phase. Instead a idle cycle is
-                                                         inserted between the responses. */
-	uint64_t twc_rate_limit               : 1;  /**< To support ASE running at SCLK/2, OSM can rate-limit responses sent back to ASE. Each
-                                                         request is assigned to either phase 0 or phase 1. When set, OSM does not send back-to-back
-                                                         responses for requests on the TWC port with the same phase. Instead a idle cycle is
-                                                         inserted between the responses. */
+	uint64_t bwc_rate_limit               : 1;  /**< Reserved. INTERNAL: Must be enabled when ASE is running at SCLK/2. If ASE is running at
+                                                         SCLK/1, this should be disabled for best performance. Mechanism: Each request is assigned
+                                                         to either phase 0 or phase 1. When feature is enabled, OSM does not send back-to-back
+                                                         responses for requests on the RWC ports with the same phase. Instead, a idle cycle is
+                                                         inserted between the responses. This enable applies to BWC ports. */
+	uint64_t twc_rate_limit               : 1;  /**< Reserved. INTERNAL: Must be enabled when ASE is running at SCLK/2. If ASE is running at
+                                                         SCLK/1, this should be disabled for best performance. Mechanism: Each request is assigned
+                                                         to either phase 0 or phase 1. When feature is enabled, OSM does not send back-to-back
+                                                         responses for requests on the RWC ports with the same phase. Instead, a idle cycle is
+                                                         inserted between the responses. This enable applies to TWC ports. */
 #else
 	uint64_t twc_rate_limit               : 1;
 	uint64_t bwc_rate_limit               : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index a76d87b..fbdbbaf 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -1269,12 +1269,13 @@ union cvmx_pcieepvfx_cfg031 {
                                                          The default value is the value you specify during hardware
                                                          configuration (x1, x4, x8, or x16) */
 	uint32_t mls                          : 4;  /**< "Maximum Link Speed
-                                                         The reset value of this field is controled by a value sent from
-                                                         the input pin qlm#_cfg[1].
-                                                         qlm#_cfg[1]   RST_VALUE   NOTE
-                                                         ?             0001b       2.5 GHz supported
-                                                         ?             0010b       5.0 GHz and 2.5 GHz supported
-                                                         ?             0100b       8.0 Ghz, 5.0 GHz and 2.5 GHz supported
+                                                         The reset value of this field is controlled by the value read from
+                                                         the PEM csr PEM(0..3)_CFG.MD.
+                                                         PEM(0..2)_CFG.MD  RST_VALUE   NOTE
+                                                         00                0001b       2.5 GHz supported
+                                                         01                0010b       5.0 GHz and 2.5 GHz supported
+                                                         10                0011b       8.0 Ghz, 5.0 GHz and 2.5 GHz supported
+                                                         11                0011b       8.0 Ghz, 5.0 GHz and 2.5 GHz supported (RC Mode)
                                                          This field is writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 #else
@@ -1499,14 +1500,15 @@ union cvmx_pcieepvfx_cfg039 {
                                                          Bit definitions are:
                                                          Bit 1 2.5 GT/s
                                                          Bit 2 5.0 GT/s
-                                                         Bit 3 8.0 GT/s (Not Supported)
+                                                         Bit 3 8.0 GT/s
                                                          Bits 7:4 reserved
-                                                         The reset value of this field is controled by a value sent from
-                                                         the lsb of the MIO_QLM#_SPD register
-                                                         qlm#_spd[0]   RST_VALUE   NOTE
-                                                         ?             0001b       2.5 GHz supported
-                                                         ?             0011b       5.0 GHz and 2.5 GHz supported
-                                                         ?             0111b       8.0 GHz, 5.0 GHz and 2.5 GHz supported" */
+                                                         The reset value of this field is controlled by a value read from
+                                                         the PEM csr PEM(0..3)_CFG.MD.
+                                                         PEM(0..3)_CFG.MD   RST_VALUE   NOTE
+                                                         00                 0001b       2.5 GHz supported
+                                                         01                 0011b       5.0 GHz and 2.5 GHz supported
+                                                         10                 0111b       8.0 GHz, 5.0 GHz and 2.5 GHz supported
+                                                         11                 0111b       8.0 Ghz, 5.0 GHz and 2.5 GHz supported (RC Mode)" */
 	uint32_t reserved_0_0                 : 1;
 #else
 	uint32_t reserved_0_0                 : 1;
@@ -1590,15 +1592,22 @@ union cvmx_pcieepvfx_cfg040 {
                                                          the upstream component in its training sequences:
                                                          - 0001: 2.5Gb/s Target Link Speed
                                                          - 0010: 5Gb/s Target Link Speed
-                                                         - 0100: 8Gb/s Target Link Speed
+                                                         - 0100: 8Gb/s Target Link Speed (Not Supported)
                                                          All other encodings are reserved.
+                                                         If a value is written to this field that does not correspond to
+                                                         a speed included in the Supported Link Speeds field, the
+                                                         result is undefined.
+                                                         For both Upstream and Downstream ports, this field is
+                                                         used to set the target compliance mode speed when
+                                                         software is using the Enter Compliance bit to force a link
                                                          into compliance mode.
-                                                         The reset value of this field is controled by a value sent from
-                                                         the lsb of the MIO_QLM#_SPD register
-                                                         qlm#_spd[0]   RST_VALUE   NOTE
-                                                         ?             0001b       2.5 GHz supported
-                                                         ?             0010b       5.0 GHz and 2.5 GHz supported
-                                                         ?             0100b       8.0 GHz, 5.0 GHz and 2.5 GHz supported" */
+                                                         The reset value of this field is controlled by the value read from
+                                                         the PEM csr PEM(0..3)_CFG.MD.
+                                                         PEM(0..2)_CFG.MD  RST_VALUE   NOTE
+                                                         00                0001b       2.5 GHz supported
+                                                         01                0010b       5.0 GHz and 2.5 GHz supported
+                                                         10                0011b       8.0 GHz, 5.0 GHz and 2.5 GHz supported
+                                                         11                0011b       8.0 Ghz, 5.0 GHz and 2.5 GHz supported (RC Mode)" */
 #else
 	uint32_t tls                          : 4;
 	uint32_t ec                           : 1;
@@ -2127,7 +2136,8 @@ union cvmx_pcieepvfx_cfg452 {
                                                          the PCIe core can negotiate a smaller link width, so all
                                                          of x8, x4, x2, and x1 are supported when LME=0xF,
                                                          for example.) */
-	uint32_t reserved_8_15                : 8;
+	uint32_t reserved_12_15               : 4;
+	uint32_t link_rate                    : 4;  /**< Reserved. */
 	uint32_t flm                          : 1;  /**< Fast Link Mode
                                                          Sets all internal timers to fast mode for simulation purposes.
                                                          If during an eeprom load, the first word loaded is 0xffffffff,
@@ -2161,7 +2171,8 @@ union cvmx_pcieepvfx_cfg452 {
 	uint32_t dllle                        : 1;
 	uint32_t reserved_6_6                 : 1;
 	uint32_t flm                          : 1;
-	uint32_t reserved_8_15                : 8;
+	uint32_t link_rate                    : 4;
+	uint32_t reserved_12_15               : 4;
 	uint32_t lme                          : 6;
 	uint32_t reserved_22_31               : 10;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index 677028c..624cb7d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -9499,6 +9499,78 @@ union cvmx_pcieepx_cfg452 {
                                                           of lanes in use by the PCIe. LME sets the max number of lanes
                                                           in the PCIe core that COULD be used. As per the PCIe specs,
                                                           the PCIe core can negotiate a smaller link width) */
+	uint32_t reserved_12_15               : 4;
+	uint32_t link_rate                    : 4;  /**< Reserved. */
+	uint32_t flm                          : 1;  /**< Fast Link Mode
+                                                         Sets all internal timers to fast mode for simulation purposes.
+                                                         If during an eeprom load, the first word loaded is 0xffffffff,
+                                                         then the EEPROM load will be terminated and this bit will be set. */
+	uint32_t reserved_6_6                 : 1;
+	uint32_t dllle                        : 1;  /**< DLL Link Enable
+                                                         Enables Link initialization. If DLL Link Enable = 0, the PCI
+                                                         Express bus does not transmit InitFC DLLPs and does not
+                                                         establish a Link. */
+	uint32_t reserved_4_4                 : 1;
+	uint32_t ra                           : 1;  /**< Reset Assert
+                                                         Triggers a recovery and forces the LTSSM to the Hot Reset
+                                                         state (downstream port only). */
+	uint32_t le                           : 1;  /**< Loopback Enable
+                                                         Initiate loopback mode as a master. On a 0->1 transition,
+                                                         the PCIe core sends TS ordered sets with the loopback bit set
+                                                         to cause the link partner to enter into loopback mode as a
+                                                         slave. Normal transmission is not possible when LE=1. To exit
+                                                         loopback mode, take the link through a reset sequence. */
+	uint32_t sd                           : 1;  /**< Scramble Disable
+                                                         Turns off data scrambling. */
+	uint32_t omr                          : 1;  /**< Other Message Request
+                                                         When software writes a `1' to this bit, the PCI Express bus
+                                                         transmits the Message contained in the Other Message register. */
+#else
+	uint32_t omr                          : 1;
+	uint32_t sd                           : 1;
+	uint32_t le                           : 1;
+	uint32_t ra                           : 1;
+	uint32_t reserved_4_4                 : 1;
+	uint32_t dllle                        : 1;
+	uint32_t reserved_6_6                 : 1;
+	uint32_t flm                          : 1;
+	uint32_t link_rate                    : 4;
+	uint32_t reserved_12_15               : 4;
+	uint32_t lme                          : 6;
+	uint32_t reserved_22_24               : 3;
+	uint32_t eccrc                        : 1;
+	uint32_t reserved_26_31               : 6;
+#endif
+	} s;
+	struct cvmx_pcieepx_cfg452_cn52xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_26_31               : 6;
+	uint32_t eccrc                        : 1;  /**< Enable Corrupted CRC
+                                                         Causes corrupt LCRC for TLPs when set,
+                                                         using the pattern contained in the Other Message register.
+                                                         This is a test feature, not to be used in normal operation. */
+	uint32_t reserved_22_24               : 3;
+	uint32_t lme                          : 6;  /**< Link Mode Enable
+                                                         o 000001: x1
+                                                         o 000011: x2
+                                                         o 000111: x4
+                                                         o 001111: x8  (not supported)
+                                                         o 011111: x16 (not supported)
+                                                         o 111111: x32 (not supported)
+                                                         This field indicates the MAXIMUM number of lanes supported
+                                                         by the PCIe port. It is set to 0x7 or 0x3 depending
+                                                         on the value of the QLM_CFG bits (0x7 when QLM_CFG == 0x3
+                                                         otherwise 0x3). The value can be set less than 0x7 or 0x3
+                                                         to limit the number of lanes the PCIe will attempt to use.
+                                                         If the value of 0x7 or 0x3 set by the HW is not desired,
+                                                         this field can be programmed to a smaller value (i.e. EEPROM)
+                                                         See also MLW.
+                                                         (Note: The value of this field does NOT indicate the number
+                                                          of lanes in use by the PCIe. LME sets the max number of lanes
+                                                          in the PCIe core that COULD be used. As per the PCIe specs,
+                                                          the PCIe core can negotiate a smaller link width, so all
+                                                          of x4, x2, and x1 are supported when LME=0x7,
+                                                          for example.) */
 	uint32_t reserved_8_15                : 8;
 	uint32_t flm                          : 1;  /**< Fast Link Mode
                                                          Sets all internal timers to fast mode for simulation purposes.
@@ -9539,11 +9611,10 @@ union cvmx_pcieepx_cfg452 {
 	uint32_t eccrc                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} s;
-	struct cvmx_pcieepx_cfg452_s          cn52xx;
-	struct cvmx_pcieepx_cfg452_s          cn52xxp1;
-	struct cvmx_pcieepx_cfg452_s          cn56xx;
-	struct cvmx_pcieepx_cfg452_s          cn56xxp1;
+	} cn52xx;
+	struct cvmx_pcieepx_cfg452_cn52xx     cn52xxp1;
+	struct cvmx_pcieepx_cfg452_cn52xx     cn56xx;
+	struct cvmx_pcieepx_cfg452_cn52xx     cn56xxp1;
 	struct cvmx_pcieepx_cfg452_cn61xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_22_31               : 10;
@@ -9605,13 +9676,75 @@ union cvmx_pcieepx_cfg452 {
 	uint32_t reserved_22_31               : 10;
 #endif
 	} cn61xx;
-	struct cvmx_pcieepx_cfg452_s          cn63xx;
-	struct cvmx_pcieepx_cfg452_s          cn63xxp1;
+	struct cvmx_pcieepx_cfg452_cn52xx     cn63xx;
+	struct cvmx_pcieepx_cfg452_cn52xx     cn63xxp1;
 	struct cvmx_pcieepx_cfg452_cn61xx     cn66xx;
 	struct cvmx_pcieepx_cfg452_cn61xx     cn68xx;
 	struct cvmx_pcieepx_cfg452_cn61xx     cn68xxp1;
-	struct cvmx_pcieepx_cfg452_cn61xx     cn70xx;
-	struct cvmx_pcieepx_cfg452_cn61xx     cn78xx;
+	struct cvmx_pcieepx_cfg452_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_22_31               : 10;
+	uint32_t lme                          : 6;  /**< Link Mode Enable
+                                                         o 000001: x1
+                                                         o 000011: x2
+                                                         o 000111: x4
+                                                         o 001111: x8  (not supported)
+                                                         o 011111: x16 (not supported)
+                                                         o 111111: x32 (not supported)
+                                                         This field indicates the MAXIMUM number of lanes supported
+                                                         by the PCIe port. The value can be set less than 0x7
+                                                         to limit the number of lanes the PCIe will attempt to use.
+                                                         If the value of 0x7 set by the HW is not desired,
+                                                         this field can be programmed to a smaller value (i.e. EEPROM)
+                                                         See also MLW.
+                                                         (Note: The value of this field does NOT indicate the number
+                                                         of lanes in use by the PCIe. LME sets the max number of lanes
+                                                         in the PCIe core that COULD be used. As per the PCIe specs,
+                                                         the PCIe core can negotiate a smaller link width, so all
+                                                         of x4, x2, and x1 are supported when LME=0x7,
+                                                         for example.) */
+	uint32_t reserved_12_15               : 4;
+	uint32_t link_rate                    : 4;  /**< Reserved. */
+	uint32_t flm                          : 1;  /**< Fast Link Mode
+                                                         Sets all internal timers to fast mode for simulation purposes.
+                                                         If during an eeprom load, the first word loaded is 0xffffffff,
+                                                         then the EEPROM load will be terminated and this bit will be set. */
+	uint32_t reserved_6_6                 : 1;
+	uint32_t dllle                        : 1;  /**< DLL Link Enable
+                                                         Enables Link initialization. If DLL Link Enable = 0, the PCI
+                                                         Express bus does not transmit InitFC DLLPs and does not
+                                                         establish a Link. */
+	uint32_t reserved_4_4                 : 1;
+	uint32_t ra                           : 1;  /**< Reset Assert
+                                                         Triggers a recovery and forces the LTSSM to the Hot Reset
+                                                         state (downstream port only). */
+	uint32_t le                           : 1;  /**< Loopback Enable
+                                                         Initiate loopback mode as a master. On a 0->1 transition,
+                                                         the PCIe core sends TS ordered sets with the loopback bit set
+                                                         to cause the link partner to enter into loopback mode as a
+                                                         slave. Normal transmission is not possible when LE=1. To exit
+                                                         loopback mode, take the link through a reset sequence. */
+	uint32_t sd                           : 1;  /**< Scramble Disable
+                                                         Turns off data scrambling. */
+	uint32_t omr                          : 1;  /**< Other Message Request
+                                                         When software writes a `1' to this bit, the PCI Express bus
+                                                         transmits the Message contained in the Other Message register. */
+#else
+	uint32_t omr                          : 1;
+	uint32_t sd                           : 1;
+	uint32_t le                           : 1;
+	uint32_t ra                           : 1;
+	uint32_t reserved_4_4                 : 1;
+	uint32_t dllle                        : 1;
+	uint32_t reserved_6_6                 : 1;
+	uint32_t flm                          : 1;
+	uint32_t link_rate                    : 4;
+	uint32_t reserved_12_15               : 4;
+	uint32_t lme                          : 6;
+	uint32_t reserved_22_31               : 10;
+#endif
+	} cn70xx;
+	struct cvmx_pcieepx_cfg452_cn70xx     cn78xx;
 	struct cvmx_pcieepx_cfg452_cn61xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg452 cvmx_pcieepx_cfg452_t;
@@ -10817,9 +10950,9 @@ union cvmx_pcieepx_cfg558 {
 	struct cvmx_pcieepx_cfg558_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t ple                          : 1;  /**< Pipe Loopback Enable */
-	uint32_t reserved_0_30                : 31;
+	uint32_t rxstatus                     : 31; /**< Reserved. */
 #else
-	uint32_t reserved_0_30                : 31;
+	uint32_t rxstatus                     : 31;
 	uint32_t ple                          : 1;
 #endif
 	} s;
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index 603d1be..89a7667 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -6714,9 +6714,7 @@ union cvmx_pciercx_cfg067 {
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbes                        : 1;  /**< Unsupported TLP Prefix Blocked Error Severity */
 	uint32_t uatombs                      : 1;  /**< Unsupported AtomicOp Egress Blocked Severity */
-	uint32_t reserved_23_23               : 1;
-	uint32_t ucies                        : 1;  /**< Uncorrectable Internal Error Severity */
-	uint32_t reserved_21_21               : 1;
+	uint32_t reserved_21_23               : 3;
 	uint32_t ures                         : 1;  /**< Unsupported Request Error Severity */
 	uint32_t ecrces                       : 1;  /**< ECRC Error Severity */
 	uint32_t mtlps                        : 1;  /**< Malformed TLP Severity */
@@ -6744,9 +6742,7 @@ union cvmx_pciercx_cfg067 {
 	uint32_t mtlps                        : 1;
 	uint32_t ecrces                       : 1;
 	uint32_t ures                         : 1;
-	uint32_t reserved_21_21               : 1;
-	uint32_t ucies                        : 1;
-	uint32_t reserved_23_23               : 1;
+	uint32_t reserved_21_23               : 3;
 	uint32_t uatombs                      : 1;
 	uint32_t tpbes                        : 1;
 	uint32_t reserved_26_31               : 6;
@@ -6876,7 +6872,7 @@ union cvmx_pciercx_cfg067 {
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbes                        : 1;  /**< Unsupported TLP Prefix Blocked Error Severity */
 	uint32_t uatombs                      : 1;  /**< Unsupported AtomicOp Egress Blocked Severity */
-	uint32_t reserved_21_23               : 3;
+	uint32_t unsuperr                     : 3;  /**< Reserved. */
 	uint32_t ures                         : 1;  /**< Unsupported Request Error Severity */
 	uint32_t ecrces                       : 1;  /**< ECRC Error Severity */
 	uint32_t mtlps                        : 1;  /**< Malformed TLP Severity */
@@ -6904,7 +6900,7 @@ union cvmx_pciercx_cfg067 {
 	uint32_t mtlps                        : 1;
 	uint32_t ecrces                       : 1;
 	uint32_t ures                         : 1;
-	uint32_t reserved_21_23               : 3;
+	uint32_t unsuperr                     : 3;
 	uint32_t uatombs                      : 1;
 	uint32_t tpbes                        : 1;
 	uint32_t reserved_26_31               : 6;
@@ -7442,41 +7438,45 @@ union cvmx_pciercx_cfg089 {
 	struct cvmx_pciercx_cfg089_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l1drph                       : 3;  /**< "Lane 1 Upstream Component Receiver Preset Hint
+	uint32_t l1urph                       : 3;  /**< "Lane 1 Upstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l1dtp                        : 4;  /**< "Lane 1 Upstream Component Transmitter Preset
+	uint32_t l1utp                        : 4;  /**< "Lane 1 Upstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_23_23               : 1;
-	uint32_t l1urph                       : 3;  /**< "Lane 1 Downstream Component Receiver Preset Hint
+	uint32_t l1drph                       : 3;  /**< "Lane 1 Downstream Component Receiver Preset Hint
+                                                         Writable through PEM#_CFG_WR.
+                                                         However, the application must not change this field." */
+	uint32_t l1ddtp                       : 4;  /**< "Lane 1 Downstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t reserved_15_19               : 5;
-	uint32_t l0drph                       : 3;  /**< "Lane 0 Upstream Component Receiver Preset Hint
+	uint32_t reserved_15_15               : 1;
+	uint32_t l0urph                       : 3;  /**< "Lane 0 Upstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l0dtp                        : 4;  /**< "Lane 0 Upstream Component Transmitter Preset
+	uint32_t l0utp                        : 4;  /**< "Lane 0 Upstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t l0urph                       : 3;  /**< "Lane 0 Downstream Component Receiver Preset Hint
+	uint32_t l0drph                       : 3;  /**< "Lane 0 Downstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l0utp                        : 4;  /**< "Lane 0 Downstream Component Transmitter Preset
+	uint32_t l0dtp                        : 4;  /**< "Lane 0 Downstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 #else
-	uint32_t l0utp                        : 4;
-	uint32_t l0urph                       : 3;
-	uint32_t reserved_7_7                 : 1;
 	uint32_t l0dtp                        : 4;
 	uint32_t l0drph                       : 3;
-	uint32_t reserved_15_19               : 5;
-	uint32_t l1urph                       : 3;
-	uint32_t reserved_23_23               : 1;
-	uint32_t l1dtp                        : 4;
+	uint32_t reserved_7_7                 : 1;
+	uint32_t l0utp                        : 4;
+	uint32_t l0urph                       : 3;
+	uint32_t reserved_15_15               : 1;
+	uint32_t l1ddtp                       : 4;
 	uint32_t l1drph                       : 3;
+	uint32_t reserved_23_23               : 1;
+	uint32_t l1utp                        : 4;
+	uint32_t l1urph                       : 3;
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
@@ -7496,45 +7496,45 @@ union cvmx_pciercx_cfg090 {
 	struct cvmx_pciercx_cfg090_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l3drph                       : 3;  /**< "Lane 3 Upstream Component Receiver Preset Hint
+	uint32_t l3urph                       : 3;  /**< "Lane 3 Upstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l3dtp                        : 4;  /**< "Lane 3 Upstream Component Transmitter Preset
+	uint32_t l3utp                        : 4;  /**< "Lane 3 Upstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_23_23               : 1;
-	uint32_t l3urph                       : 3;  /**< "Lane 3 Downstream Component Receiver Preset Hint
+	uint32_t l3drph                       : 3;  /**< "Lane 3 Downstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l3utp                        : 4;  /**< "Lane 3 Downstream Component Transmitter Preset
+	uint32_t l3dtp                        : 4;  /**< "Lane 3 Downstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_15_15               : 1;
-	uint32_t l2drph                       : 3;  /**< "Lane 2 Upstream Component Receiver Preset Hint
+	uint32_t l2urph                       : 3;  /**< "Lane 2 Upstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l2dtp                        : 4;  /**< "Lane 2 Upstream Component Transmitter Preset
+	uint32_t l2utp                        : 4;  /**< "Lane 2 Upstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t l2urph                       : 3;  /**< "Lane 2 Downstream Component Receiver Preset Hint
+	uint32_t l2drph                       : 3;  /**< "Lane 2 Downstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l2utp                        : 4;  /**< "Lane 2 Downstream Component Transmitter Preset
+	uint32_t l2dtp                        : 4;  /**< "Lane 2 Downstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 #else
-	uint32_t l2utp                        : 4;
-	uint32_t l2urph                       : 3;
-	uint32_t reserved_7_7                 : 1;
 	uint32_t l2dtp                        : 4;
 	uint32_t l2drph                       : 3;
+	uint32_t reserved_7_7                 : 1;
+	uint32_t l2utp                        : 4;
+	uint32_t l2urph                       : 3;
 	uint32_t reserved_15_15               : 1;
-	uint32_t l3utp                        : 4;
-	uint32_t l3urph                       : 3;
-	uint32_t reserved_23_23               : 1;
 	uint32_t l3dtp                        : 4;
 	uint32_t l3drph                       : 3;
+	uint32_t reserved_23_23               : 1;
+	uint32_t l3utp                        : 4;
+	uint32_t l3urph                       : 3;
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
@@ -7554,45 +7554,45 @@ union cvmx_pciercx_cfg091 {
 	struct cvmx_pciercx_cfg091_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l5drph                       : 3;  /**< "Lane 5 Upstream Component Receiver Preset Hint
+	uint32_t l5urph                       : 3;  /**< "Lane 5 Upstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l5dtp                        : 4;  /**< "Lane 5 Upstream Component Transmitter Preset
+	uint32_t l5utp                        : 4;  /**< "Lane 5 Upstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_23_23               : 1;
-	uint32_t l5urph                       : 3;  /**< "Lane 5 Downstream Component Receiver Preset Hint
+	uint32_t l5drph                       : 3;  /**< "Lane 5 Downstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l5utp                        : 4;  /**< "Lane 5 Downstream Component Transmitter Preset
+	uint32_t l5dtp                        : 4;  /**< "Lane 5 Downstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_15_15               : 1;
-	uint32_t l4drph                       : 3;  /**< "Lane 4 Upstream Component Receiver Preset Hint
+	uint32_t l4urph                       : 3;  /**< "Lane 4 Upstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l4dtp                        : 4;  /**< "Lane 4 Upstream Component Transmitter Preset
+	uint32_t l4utp                        : 4;  /**< "Lane 4 Upstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t l4urph                       : 3;  /**< "Lane 4 Downstream Component Receiver Preset Hint
+	uint32_t l4drph                       : 3;  /**< "Lane 4 Downstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l4utp                        : 4;  /**< "Lane 4 Downstream Component Transmitter Preset
+	uint32_t l4dtp                        : 4;  /**< "Lane 4 Downstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 #else
-	uint32_t l4utp                        : 4;
-	uint32_t l4urph                       : 3;
-	uint32_t reserved_7_7                 : 1;
 	uint32_t l4dtp                        : 4;
 	uint32_t l4drph                       : 3;
+	uint32_t reserved_7_7                 : 1;
+	uint32_t l4utp                        : 4;
+	uint32_t l4urph                       : 3;
 	uint32_t reserved_15_15               : 1;
-	uint32_t l5utp                        : 4;
-	uint32_t l5urph                       : 3;
-	uint32_t reserved_23_23               : 1;
 	uint32_t l5dtp                        : 4;
 	uint32_t l5drph                       : 3;
+	uint32_t reserved_23_23               : 1;
+	uint32_t l5utp                        : 4;
+	uint32_t l5urph                       : 3;
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
@@ -7612,45 +7612,45 @@ union cvmx_pciercx_cfg092 {
 	struct cvmx_pciercx_cfg092_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
-	uint32_t l7drph                       : 3;  /**< "Lane 7 Upstream Component Receiver Preset Hint
+	uint32_t l7urph                       : 3;  /**< "Lane 7 Upstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l7dtp                        : 4;  /**< "Lane 7 Upstream Component Transmitter Preset
+	uint32_t l7utp                        : 4;  /**< "Lane 7 Upstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_23_23               : 1;
-	uint32_t l7urph                       : 3;  /**< "Lane 7 Downstream Component Receiver Preset Hint
+	uint32_t l7drph                       : 3;  /**< "Lane 7 Downstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l7utp                        : 4;  /**< "Lane 7 Downstream Component Transmitter Preset
+	uint32_t l7dtp                        : 4;  /**< "Lane 7 Downstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_15_15               : 1;
-	uint32_t l6drph                       : 3;  /**< "Lane 6 Upstream Component Receiver Preset Hint
+	uint32_t l6urph                       : 3;  /**< "Lane 6 Upstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l6dtp                        : 4;  /**< "Lane 6 Upstream Component Transmitter Preset
+	uint32_t l6utp                        : 4;  /**< "Lane 6 Upstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t l6urph                       : 3;  /**< "Lane 6 Downstream Component Receiver Preset Hint
+	uint32_t l6drph                       : 3;  /**< "Lane 6 Downstream Component Receiver Preset Hint
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
-	uint32_t l6utp                        : 4;  /**< "Lane 6 Downstream Component Transmitter Preset
+	uint32_t l6dtp                        : 4;  /**< "Lane 6 Downstream Component Transmitter Preset
                                                          Writable through PEM#_CFG_WR.
                                                          However, the application must not change this field." */
 #else
-	uint32_t l6utp                        : 4;
-	uint32_t l6urph                       : 3;
-	uint32_t reserved_7_7                 : 1;
 	uint32_t l6dtp                        : 4;
 	uint32_t l6drph                       : 3;
+	uint32_t reserved_7_7                 : 1;
+	uint32_t l6utp                        : 4;
+	uint32_t l6urph                       : 3;
 	uint32_t reserved_15_15               : 1;
-	uint32_t l7utp                        : 4;
-	uint32_t l7urph                       : 3;
-	uint32_t reserved_23_23               : 1;
 	uint32_t l7dtp                        : 4;
 	uint32_t l7drph                       : 3;
+	uint32_t reserved_23_23               : 1;
+	uint32_t l7utp                        : 4;
+	uint32_t l7urph                       : 3;
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
@@ -8072,6 +8072,75 @@ union cvmx_pciercx_cfg452 {
                                                           in the PCIe core that COULD be used. As per the PCIe specs,
                                                           the PCIe core can negotiate a smaller link width, so
                                                           x1 is also supported when LME=0x3, for example.) */
+	uint32_t reserved_12_15               : 4;
+	uint32_t link_rate                    : 4;  /**< Reserved. */
+	uint32_t flm                          : 1;  /**< Fast Link Mode
+                                                         Sets all internal timers to fast mode for simulation purposes. */
+	uint32_t reserved_6_6                 : 1;
+	uint32_t dllle                        : 1;  /**< DLL Link Enable
+                                                         Enables Link initialization. If DLL Link Enable = 0, the PCI
+                                                         Express bus does not transmit InitFC DLLPs and does not
+                                                         establish a Link. */
+	uint32_t reserved_4_4                 : 1;
+	uint32_t ra                           : 1;  /**< Reset Assert
+                                                         Triggers a recovery and forces the LTSSM to the Hot Reset
+                                                         state (downstream port only). */
+	uint32_t le                           : 1;  /**< Loopback Enable
+                                                         Initiate loopback mode as a master. On a 0->1 transition,
+                                                         the PCIe core sends TS ordered sets with the loopback bit set
+                                                         to cause the link partner to enter into loopback mode as a
+                                                         slave. Normal transmission is not possible when LE=1. To exit
+                                                         loopback mode, take the link through a reset sequence. */
+	uint32_t sd                           : 1;  /**< Scramble Disable
+                                                         Turns off data scrambling. */
+	uint32_t omr                          : 1;  /**< Other Message Request
+                                                         When software writes a `1' to this bit, the PCI Express bus
+                                                         transmits the Message contained in the Other Message register. */
+#else
+	uint32_t omr                          : 1;
+	uint32_t sd                           : 1;
+	uint32_t le                           : 1;
+	uint32_t ra                           : 1;
+	uint32_t reserved_4_4                 : 1;
+	uint32_t dllle                        : 1;
+	uint32_t reserved_6_6                 : 1;
+	uint32_t flm                          : 1;
+	uint32_t link_rate                    : 4;
+	uint32_t reserved_12_15               : 4;
+	uint32_t lme                          : 6;
+	uint32_t reserved_22_24               : 3;
+	uint32_t eccrc                        : 1;
+	uint32_t reserved_26_31               : 6;
+#endif
+	} s;
+	struct cvmx_pciercx_cfg452_cn52xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_26_31               : 6;
+	uint32_t eccrc                        : 1;  /**< Enable Corrupted CRC
+                                                         Causes corrupt LCRC for TLPs when set,
+                                                         using the pattern contained in the Other Message register.
+                                                         This is a test feature, not to be used in normal operation. */
+	uint32_t reserved_22_24               : 3;
+	uint32_t lme                          : 6;  /**< Link Mode Enable
+                                                         o 000001: x1
+                                                         o 000011: x2
+                                                         o 000111: x4
+                                                         o 001111: x8 (not supported)
+                                                         o 011111: x16 (not supported)
+                                                         o 111111: x32 (not supported)
+                                                         This field indicates the MAXIMUM number of lanes supported
+                                                         by the PCIe port. It is normally set to 0x7 or 0x3 depending
+                                                         on the value of the QLM_CFG bits (0x7 when QLM_CFG == 0x3
+                                                         otherwise 0x3). The value can be set less than 0x7 or 0x3
+                                                         to limit the number of lanes the PCIe will attempt to use.
+                                                         The programming of this field needs to be done by SW BEFORE
+                                                         enabling the link. See also MLW.
+                                                         (Note: The value of this field does NOT indicate the number
+                                                          of lanes in use by the PCIe. LME sets the max number of lanes
+                                                          in the PCIe core that COULD be used. As per the PCIe specs,
+                                                          the PCIe core can negotiate a smaller link width, so all
+                                                          of x4, x2, and x1 are supported when LME=0x7,
+                                                          for example.) */
 	uint32_t reserved_8_15                : 8;
 	uint32_t flm                          : 1;  /**< Fast Link Mode
                                                          Sets all internal timers to fast mode for simulation purposes. */
@@ -8110,11 +8179,10 @@ union cvmx_pciercx_cfg452 {
 	uint32_t eccrc                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} s;
-	struct cvmx_pciercx_cfg452_s          cn52xx;
-	struct cvmx_pciercx_cfg452_s          cn52xxp1;
-	struct cvmx_pciercx_cfg452_s          cn56xx;
-	struct cvmx_pciercx_cfg452_s          cn56xxp1;
+	} cn52xx;
+	struct cvmx_pciercx_cfg452_cn52xx     cn52xxp1;
+	struct cvmx_pciercx_cfg452_cn52xx     cn56xx;
+	struct cvmx_pciercx_cfg452_cn52xx     cn56xxp1;
 	struct cvmx_pciercx_cfg452_cn61xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_22_31               : 10;
@@ -8173,13 +8241,72 @@ union cvmx_pciercx_cfg452 {
 	uint32_t reserved_22_31               : 10;
 #endif
 	} cn61xx;
-	struct cvmx_pciercx_cfg452_s          cn63xx;
-	struct cvmx_pciercx_cfg452_s          cn63xxp1;
+	struct cvmx_pciercx_cfg452_cn52xx     cn63xx;
+	struct cvmx_pciercx_cfg452_cn52xx     cn63xxp1;
 	struct cvmx_pciercx_cfg452_cn61xx     cn66xx;
 	struct cvmx_pciercx_cfg452_cn61xx     cn68xx;
 	struct cvmx_pciercx_cfg452_cn61xx     cn68xxp1;
-	struct cvmx_pciercx_cfg452_cn61xx     cn70xx;
-	struct cvmx_pciercx_cfg452_cn61xx     cn78xx;
+	struct cvmx_pciercx_cfg452_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_22_31               : 10;
+	uint32_t lme                          : 6;  /**< Link Mode Enable
+                                                         o 000001: x1
+                                                         o 000011: x2
+                                                         o 000111: x4
+                                                         o 001111: x8  (not supported)
+                                                         o 011111: x16 (not supported)
+                                                         o 111111: x32 (not supported)
+                                                         This field indicates the MAXIMUM number of lanes supported
+                                                         by the PCIe port. The value can be set less than 0x7
+                                                         to limit the number of lanes the PCIe will attempt to use.
+                                                         The programming of this field needs to be done by SW BEFORE
+                                                         enabling the link. See also MLW.
+                                                         (Note: The value of this field does NOT indicate the number
+                                                         of lanes in use by the PCIe. LME sets the max number of lanes
+                                                         in the PCIe core that COULD be used. As per the PCIe specs,
+                                                         the PCIe core can negotiate a smaller link width, so all
+                                                         of x4, x2, and x1 are supported when LME=0x7,
+                                                         for example.) */
+	uint32_t reserved_12_15               : 4;
+	uint32_t link_rate                    : 4;  /**< Reserved. */
+	uint32_t flm                          : 1;  /**< Fast Link Mode
+                                                         Sets all internal timers to fast mode for simulation purposes. */
+	uint32_t reserved_6_6                 : 1;
+	uint32_t dllle                        : 1;  /**< DLL Link Enable
+                                                         Enables Link initialization. If DLL Link Enable = 0, the PCI
+                                                         Express bus does not transmit InitFC DLLPs and does not
+                                                         establish a Link. */
+	uint32_t reserved_4_4                 : 1;
+	uint32_t ra                           : 1;  /**< Reset Assert
+                                                         Triggers a recovery and forces the LTSSM to the Hot Reset
+                                                         state (downstream port only). */
+	uint32_t le                           : 1;  /**< Loopback Enable
+                                                         Initiate loopback mode as a master. On a 0->1 transition,
+                                                         the PCIe core sends TS ordered sets with the loopback bit set
+                                                         to cause the link partner to enter into loopback mode as a
+                                                         slave. Normal transmission is not possible when LE=1. To exit
+                                                         loopback mode, take the link through a reset sequence. */
+	uint32_t sd                           : 1;  /**< Scramble Disable
+                                                         Turns off data scrambling. */
+	uint32_t omr                          : 1;  /**< Other Message Request
+                                                         When software writes a `1' to this bit, the PCI Express bus
+                                                         transmits the Message contained in the Other Message register. */
+#else
+	uint32_t omr                          : 1;
+	uint32_t sd                           : 1;
+	uint32_t le                           : 1;
+	uint32_t ra                           : 1;
+	uint32_t reserved_4_4                 : 1;
+	uint32_t dllle                        : 1;
+	uint32_t reserved_6_6                 : 1;
+	uint32_t flm                          : 1;
+	uint32_t link_rate                    : 4;
+	uint32_t reserved_12_15               : 4;
+	uint32_t lme                          : 6;
+	uint32_t reserved_22_31               : 10;
+#endif
+	} cn70xx;
+	struct cvmx_pciercx_cfg452_cn70xx     cn78xx;
 	struct cvmx_pciercx_cfg452_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg452 cvmx_pciercx_cfg452_t;
@@ -9384,9 +9511,9 @@ union cvmx_pciercx_cfg558 {
 	struct cvmx_pciercx_cfg558_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t ple                          : 1;  /**< Pipe Loopback Enable */
-	uint32_t reserved_0_30                : 31;
+	uint32_t rxstatus                     : 31; /**< Reserved. */
 #else
-	uint32_t reserved_0_30                : 31;
+	uint32_t rxstatus                     : 31;
 	uint32_t ple                          : 1;
 #endif
 	} s;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
index 1ff32eb..d880b3d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
@@ -57,12 +57,12 @@ static inline uint64_t CVMX_PCSXX_10GBX_STATUS_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -74,17 +74,17 @@ static inline uint64_t CVMX_PCSXX_10GBX_STATUS_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_10GBX_STATUS_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_10GBX_STATUS_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000828ull) + (block_id) * 0x8000000ull;
@@ -99,12 +99,12 @@ static inline uint64_t CVMX_PCSXX_BIST_STATUS_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -116,17 +116,17 @@ static inline uint64_t CVMX_PCSXX_BIST_STATUS_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_BIST_STATUS_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_BIST_STATUS_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000870ull) + (block_id) * 0x8000000ull;
@@ -141,12 +141,12 @@ static inline uint64_t CVMX_PCSXX_BIT_LOCK_STATUS_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -158,17 +158,17 @@ static inline uint64_t CVMX_PCSXX_BIT_LOCK_STATUS_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_BIT_LOCK_STATUS_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_BIT_LOCK_STATUS_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000850ull) + (block_id) * 0x8000000ull;
@@ -183,12 +183,12 @@ static inline uint64_t CVMX_PCSXX_CONTROL1_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -200,17 +200,17 @@ static inline uint64_t CVMX_PCSXX_CONTROL1_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_CONTROL1_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_CONTROL1_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000800ull) + (block_id) * 0x8000000ull;
@@ -225,12 +225,12 @@ static inline uint64_t CVMX_PCSXX_CONTROL2_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -242,17 +242,17 @@ static inline uint64_t CVMX_PCSXX_CONTROL2_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_CONTROL2_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_CONTROL2_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000818ull) + (block_id) * 0x8000000ull;
@@ -267,12 +267,12 @@ static inline uint64_t CVMX_PCSXX_INT_EN_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -284,17 +284,17 @@ static inline uint64_t CVMX_PCSXX_INT_EN_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_INT_EN_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_INT_EN_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000860ull) + (block_id) * 0x8000000ull;
@@ -309,12 +309,12 @@ static inline uint64_t CVMX_PCSXX_INT_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -326,17 +326,17 @@ static inline uint64_t CVMX_PCSXX_INT_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_INT_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_INT_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000858ull) + (block_id) * 0x8000000ull;
@@ -351,12 +351,12 @@ static inline uint64_t CVMX_PCSXX_LOG_ANL_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -368,17 +368,17 @@ static inline uint64_t CVMX_PCSXX_LOG_ANL_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_LOG_ANL_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_LOG_ANL_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000868ull) + (block_id) * 0x8000000ull;
@@ -393,12 +393,12 @@ static inline uint64_t CVMX_PCSXX_MISC_CTL_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -410,17 +410,17 @@ static inline uint64_t CVMX_PCSXX_MISC_CTL_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_MISC_CTL_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_MISC_CTL_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000848ull) + (block_id) * 0x8000000ull;
@@ -435,12 +435,12 @@ static inline uint64_t CVMX_PCSXX_RX_SYNC_STATES_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -452,17 +452,17 @@ static inline uint64_t CVMX_PCSXX_RX_SYNC_STATES_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_RX_SYNC_STATES_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_RX_SYNC_STATES_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000838ull) + (block_id) * 0x8000000ull;
@@ -476,24 +476,24 @@ static inline uint64_t CVMX_PCSXX_RX_SYNC_STATES_REG(unsigned long block_id)
 static inline uint64_t CVMX_PCSXX_SERDES_CRDT_CNT_REG(unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_PCSXX_SERDES_CRDT_CNT_REG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000880ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000880ull);
 }
 #else
-#define CVMX_PCSXX_SERDES_CRDT_CNT_REG(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000880ull) + ((block_id) & 1) * 0x8000000ull)
+#define CVMX_PCSXX_SERDES_CRDT_CNT_REG(block_id) (CVMX_ADD_IO_SEG(0x00011800B0000880ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCSXX_SPD_ABIL_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -505,17 +505,17 @@ static inline uint64_t CVMX_PCSXX_SPD_ABIL_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_SPD_ABIL_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_SPD_ABIL_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000810ull) + (block_id) * 0x8000000ull;
@@ -530,12 +530,12 @@ static inline uint64_t CVMX_PCSXX_STATUS1_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -547,17 +547,17 @@ static inline uint64_t CVMX_PCSXX_STATUS1_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_STATUS1_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_STATUS1_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000808ull) + (block_id) * 0x8000000ull;
@@ -572,12 +572,12 @@ static inline uint64_t CVMX_PCSXX_STATUS2_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -589,17 +589,17 @@ static inline uint64_t CVMX_PCSXX_STATUS2_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_STATUS2_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_STATUS2_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000820ull) + (block_id) * 0x8000000ull;
@@ -614,12 +614,12 @@ static inline uint64_t CVMX_PCSXX_TX_RX_POLARITY_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -631,17 +631,17 @@ static inline uint64_t CVMX_PCSXX_TX_RX_POLARITY_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_TX_RX_POLARITY_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_TX_RX_POLARITY_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000840ull) + (block_id) * 0x8000000ull;
@@ -656,12 +656,12 @@ static inline uint64_t CVMX_PCSXX_TX_RX_STATES_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((block_id) & 1) * 0x8000000ull;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
@@ -673,17 +673,17 @@ static inline uint64_t CVMX_PCSXX_TX_RX_STATES_REG(unsigned long block_id)
 			break;
 	}
 	cvmx_warn("CVMX_PCSXX_TX_RX_STATES_REG (block_id = %lu) not supported on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((block_id) & 1) * 0x8000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + ((block_id) & 0) * 0x8000000ull;
 }
 #else
 static inline uint64_t CVMX_PCSXX_TX_RX_STATES_REG(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (block_id) * 0x8000000ull;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800B0000830ull) + (block_id) * 0x8000000ull;
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index cece806..d013afd 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -408,7 +408,6 @@ static inline uint64_t CVMX_PEMX_DBG_INFO_EN(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_DBG_INFO_EN(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((block_id) & 3) * 0x1000000ull;
@@ -545,10 +544,6 @@ static inline uint64_t CVMX_PEMX_INT_ENB(unsigned long block_id)
 			if ((block_id <= 2))
 				return CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((block_id) & 3) * 0x1000000ull;
-			break;
 	}
 	cvmx_warn("CVMX_PEMX_INT_ENB (block_id = %lu) not supported on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((block_id) & 1) * 0x1000000ull;
@@ -565,8 +560,6 @@ static inline uint64_t CVMX_PEMX_INT_ENB(unsigned long block_id)
 			return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000430ull) + (block_id) * 0x1000000ull;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000430ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + (block_id) * 0x1000000ull;
 }
@@ -587,10 +580,6 @@ static inline uint64_t CVMX_PEMX_INT_ENB_INT(unsigned long block_id)
 			if ((block_id <= 2))
 				return CVMX_ADD_IO_SEG(0x00011800C0000438ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000438ull) + ((block_id) & 3) * 0x1000000ull;
-			break;
 	}
 	cvmx_warn("CVMX_PEMX_INT_ENB_INT (block_id = %lu) not supported on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((block_id) & 1) * 0x1000000ull;
@@ -607,8 +596,6 @@ static inline uint64_t CVMX_PEMX_INT_ENB_INT(unsigned long block_id)
 			return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000438ull) + (block_id) * 0x1000000ull;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000438ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + (block_id) * 0x1000000ull;
 }
@@ -1434,7 +1421,7 @@ union cvmx_pemx_ctl_status {
                                                          most significant Header Queue Buffer ram block
                                                          to force a parity error when it is later read. */
 	uint64_t inv_rpar                     : 1;  /**< Invert the generated parity to be written into the
-                                                         most significant Retry Buffer ram block to force
+                                                         tmost significant Retry Buffer ram block to force
                                                          a parity error when it is later read. */
 	uint64_t auto_sd                      : 1;  /**< Link Hardware Autonomous Speed Disable. */
 	uint64_t dnum                         : 5;  /**< Primary bus device number. */
@@ -1554,7 +1541,68 @@ union cvmx_pemx_ctl_status {
 	struct cvmx_pemx_ctl_status_cn61xx    cn68xx;
 	struct cvmx_pemx_ctl_status_cn61xx    cn68xxp1;
 	struct cvmx_pemx_ctl_status_s         cn70xx;
-	struct cvmx_pemx_ctl_status_s         cn78xx;
+	struct cvmx_pemx_ctl_status_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_51_63               : 13;
+	uint64_t inv_dpar                     : 1;  /**< Invert the generated parity to be written into the
+                                                         the most significant Data Queue Buffer ram block
+                                                         to force a parity error when it is later read. */
+	uint64_t reserved_48_49               : 2;
+	uint64_t auto_sd                      : 1;  /**< Link Hardware Autonomous Speed Disable. */
+	uint64_t dnum                         : 5;  /**< Primary bus device number. */
+	uint64_t pbus                         : 8;  /**< Primary bus number. */
+	uint64_t reserved_32_33               : 2;
+	uint64_t cfg_rtry                     : 16; /**< The time x 0x10000 in core clocks to wait for a
+                                                         CPL to a CFG RD that does not carry a Retry Status.
+                                                         Until such time that the timeout occurs and Retry
+                                                         Status is received for a CFG RD, the Read CFG Read
+                                                         will be resent. A value of 0 disables retries and
+                                                         treats a CPL Retry as a CPL UR.
+                                                         When enabled only one CFG RD may be issued until
+                                                         either successful completion or CPL UR. */
+	uint64_t reserved_12_15               : 4;
+	uint64_t pm_xtoff                     : 1;  /**< When WRITTEN with a '1' a single cycle pulse is
+                                                         to the PCIe core pm_xmt_turnoff port. RC mode. */
+	uint64_t pm_xpme                      : 1;  /**< When WRITTEN with a '1' a single cycle pulse is
+                                                         to the PCIe core pm_xmt_pme port. EP mode. */
+	uint64_t ob_p_cmd                     : 1;  /**< When WRITTEN with a '1' a single cycle pulse is
+                                                         to the PCIe core outband_pwrup_cmd port. EP mode. */
+	uint64_t reserved_7_8                 : 2;
+	uint64_t nf_ecrc                      : 1;  /**< Do not forward peer-to-peer ECRC TLPs. */
+	uint64_t dly_one                      : 1;  /**< When set the output client state machines will
+                                                         wait one cycle before starting a new TLP out. */
+	uint64_t lnk_enb                      : 1;  /**< When set '1' the link is enabled when '0' the
+                                                         link is disabled. This bit only is active when in
+                                                         RC mode. */
+	uint64_t ro_ctlp                      : 1;  /**< When set '1' C-TLPs that have the RO bit set will
+                                                         not wait for P-TLPs that normaly would be sent
+                                                         first. */
+	uint64_t fast_lm                      : 1;  /**< When '1' forces fast link mode. */
+	uint64_t inv_ecrc                     : 1;  /**< When '1' causes the LSB of the ECRC to be inverted. */
+	uint64_t inv_lcrc                     : 1;  /**< When '1' causes the LSB of the LCRC to be inverted. */
+#else
+	uint64_t inv_lcrc                     : 1;
+	uint64_t inv_ecrc                     : 1;
+	uint64_t fast_lm                      : 1;
+	uint64_t ro_ctlp                      : 1;
+	uint64_t lnk_enb                      : 1;
+	uint64_t dly_one                      : 1;
+	uint64_t nf_ecrc                      : 1;
+	uint64_t reserved_7_8                 : 2;
+	uint64_t ob_p_cmd                     : 1;
+	uint64_t pm_xpme                      : 1;
+	uint64_t pm_xtoff                     : 1;
+	uint64_t reserved_12_15               : 4;
+	uint64_t cfg_rtry                     : 16;
+	uint64_t reserved_32_33               : 2;
+	uint64_t pbus                         : 8;
+	uint64_t dnum                         : 5;
+	uint64_t auto_sd                      : 1;
+	uint64_t reserved_48_49               : 2;
+	uint64_t inv_dpar                     : 1;
+	uint64_t reserved_51_63               : 13;
+#endif
+	} cn78xx;
 	struct cvmx_pemx_ctl_status_cn61xx    cnf71xx;
 };
 typedef union cvmx_pemx_ctl_status cvmx_pemx_ctl_status_t;
@@ -1599,8 +1647,13 @@ union cvmx_pemx_dbg_info {
 	uint64_t u64;
 	struct cvmx_pemx_dbg_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_53_63               : 11;
-	uint64_t lofp                         : 1;  /**< Lack of Forward Progress at TLP FIFOs timeout occured. */
+	uint64_t reserved_58_63               : 6;
+	uint64_t qhdr_b1_dbe                  : 1;  /**< Detected a Core Header Queue Bank1 double bit error */
+	uint64_t qhdr_b1_sbe                  : 1;  /**< Detected a Core Header Queue Bank1 single bit error */
+	uint64_t qhdr_b0_dbe                  : 1;  /**< Detected a Core Header Queue Bank0 double bit error */
+	uint64_t qhdr_b0_sbe                  : 1;  /**< Detected a Core Header Queue Bank0 single bit error */
+	uint64_t rtry_dbe                     : 1;  /**< Detected a Core Retry RAM double bit error */
+	uint64_t rtry_sbe                     : 1;  /**< Detected a Core Retry RAM single bit error */
 	uint64_t reserved_50_51               : 2;
 	uint64_t c_d1_dbe                     : 1;  /**< Detected a TLP CPL Fifo data1 double bit error */
 	uint64_t c_d1_sbe                     : 1;  /**< Detected a TLP CPL Fifo data1 single bit error */
@@ -1609,7 +1662,7 @@ union cvmx_pemx_dbg_info {
 	uint64_t reserved_34_45               : 12;
 	uint64_t datq_pe                      : 1;  /**< Detected a Data Queue RAM parity error */
 	uint64_t hdrq_pe                      : 1;  /**< Detected a Header Queue RAM parity error */
-	uint64_t rtry_pe                      : 1;  /**< Detected a Retry RAM parity error */
+	uint64_t reserved_31_31               : 1;
 	uint64_t ecrc_e                       : 1;  /**< Received a ECRC error.
                                                          radm_ecrc_err */
 	uint64_t rawwpp                       : 1;  /**< Received a write with poisoned payload
@@ -1717,7 +1770,7 @@ union cvmx_pemx_dbg_info {
 	uint64_t racpp                        : 1;
 	uint64_t rawwpp                       : 1;
 	uint64_t ecrc_e                       : 1;
-	uint64_t rtry_pe                      : 1;
+	uint64_t reserved_31_31               : 1;
 	uint64_t hdrq_pe                      : 1;
 	uint64_t datq_pe                      : 1;
 	uint64_t reserved_34_45               : 12;
@@ -1726,8 +1779,13 @@ union cvmx_pemx_dbg_info {
 	uint64_t c_d1_sbe                     : 1;
 	uint64_t c_d1_dbe                     : 1;
 	uint64_t reserved_50_51               : 2;
-	uint64_t lofp                         : 1;
-	uint64_t reserved_53_63               : 11;
+	uint64_t rtry_sbe                     : 1;
+	uint64_t rtry_dbe                     : 1;
+	uint64_t qhdr_b0_sbe                  : 1;
+	uint64_t qhdr_b0_dbe                  : 1;
+	uint64_t qhdr_b1_sbe                  : 1;
+	uint64_t qhdr_b1_dbe                  : 1;
+	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
 	struct cvmx_pemx_dbg_info_cn61xx {
@@ -1996,8 +2054,13 @@ union cvmx_pemx_dbg_info {
 	} cn70xx;
 	struct cvmx_pemx_dbg_info_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_53_63               : 11;
-	uint64_t lofp                         : 1;  /**< Lack of Forward Progress at TLP FIFOs timeout occured. */
+	uint64_t reserved_58_63               : 6;
+	uint64_t qhdr_b1_dbe                  : 1;  /**< Detected a Core Header Queue Bank1 double bit error */
+	uint64_t qhdr_b1_sbe                  : 1;  /**< Detected a Core Header Queue Bank1 single bit error */
+	uint64_t qhdr_b0_dbe                  : 1;  /**< Detected a Core Header Queue Bank0 double bit error */
+	uint64_t qhdr_b0_sbe                  : 1;  /**< Detected a Core Header Queue Bank0 single bit error */
+	uint64_t rtry_dbe                     : 1;  /**< Detected a Core Retry RAM double bit error */
+	uint64_t rtry_sbe                     : 1;  /**< Detected a Core Retry RAM single bit error */
 	uint64_t c_c_dbe                      : 1;  /**< Detected a TLP CPL Fifo ctrl double bit error */
 	uint64_t c_c_sbe                      : 1;  /**< Detected a TLP CPL Fifo ctrl single bit error */
 	uint64_t c_d1_dbe                     : 1;  /**< Detected a TLP CPL Fifo data1 double bit error */
@@ -2017,8 +2080,8 @@ union cvmx_pemx_dbg_info {
 	uint64_t p_d0_dbe                     : 1;  /**< Detected a TLP Posted Fifo data0 double bit error */
 	uint64_t p_d0_sbe                     : 1;  /**< Detected a TLP Posted Fifo data0 single bit error */
 	uint64_t datq_pe                      : 1;  /**< Detected a Data Queue RAM parity error */
-	uint64_t hdrq_pe                      : 1;  /**< Detected a Header Queue RAM parity error */
-	uint64_t rtry_pe                      : 1;  /**< Detected a Retry RAM parity error */
+	uint64_t reserved_32_32               : 1;
+	uint64_t lofp                         : 1;  /**< Lack of Forward Progress at TLP FIFOs timeout occured. */
 	uint64_t ecrc_e                       : 1;  /**< Received a ECRC error.
                                                          radm_ecrc_err */
 	uint64_t rawwpp                       : 1;  /**< Received a write with poisoned payload
@@ -2129,8 +2192,8 @@ union cvmx_pemx_dbg_info {
 	uint64_t racpp                        : 1;
 	uint64_t rawwpp                       : 1;
 	uint64_t ecrc_e                       : 1;
-	uint64_t rtry_pe                      : 1;
-	uint64_t hdrq_pe                      : 1;
+	uint64_t lofp                         : 1;
+	uint64_t reserved_32_32               : 1;
 	uint64_t datq_pe                      : 1;
 	uint64_t p_d0_sbe                     : 1;
 	uint64_t p_d0_dbe                     : 1;
@@ -2150,8 +2213,13 @@ union cvmx_pemx_dbg_info {
 	uint64_t c_d1_dbe                     : 1;
 	uint64_t c_c_sbe                      : 1;
 	uint64_t c_c_dbe                      : 1;
-	uint64_t lofp                         : 1;
-	uint64_t reserved_53_63               : 11;
+	uint64_t rtry_sbe                     : 1;
+	uint64_t rtry_dbe                     : 1;
+	uint64_t qhdr_b0_sbe                  : 1;
+	uint64_t qhdr_b0_dbe                  : 1;
+	uint64_t qhdr_b1_sbe                  : 1;
+	uint64_t qhdr_b1_dbe                  : 1;
+	uint64_t reserved_58_63               : 6;
 #endif
 	} cn78xx;
 	struct cvmx_pemx_dbg_info_cn61xx      cnf71xx;
@@ -2168,167 +2236,6 @@ union cvmx_pemx_dbg_info_en {
 	uint64_t u64;
 	struct cvmx_pemx_dbg_info_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_53_63               : 11;
-	uint64_t lofp_en                      : 1;  /**< Allows PEM_DBG_INFO[52] to generate an interrupt. */
-	uint64_t tpcdbe2                      : 1;  /**< Allows PEM_DBG_INFO[51] to generate an interrupt. */
-	uint64_t reserved_49_50               : 2;
-	uint64_t tpcsbe2                      : 1;  /**< Allows PEM_DBG_INFO[48] to generate an interrupt. */
-	uint64_t reserved_35_47               : 13;
-	uint64_t tpfsbe0                      : 1;  /**< Allows PEM_DBG_INFO[34] to generate an interrupt. */
-	uint64_t datq_pe                      : 1;  /**< Allows PEM_DBG_INFO[33] to generate an interrupt. */
-	uint64_t hdrq_pe                      : 1;  /**< Allows PEM_DBG_INFO[32] to generate an interrupt. */
-	uint64_t rtry_pe                      : 1;  /**< Allows PEM_DBG_INFO[31] to generate an interrupt. */
-	uint64_t ecrc_e                       : 1;  /**< Allows PEM_DBG_INFO[30] to generate an interrupt. */
-	uint64_t rawwpp                       : 1;  /**< Allows PEM_DBG_INFO[29] to generate an interrupt. */
-	uint64_t racpp                        : 1;  /**< Allows PEM_DBG_INFO[28] to generate an interrupt. */
-	uint64_t ramtlp                       : 1;  /**< Allows PEM_DBG_INFO[27] to generate an interrupt. */
-	uint64_t rarwdns                      : 1;  /**< Allows PEM_DBG_INFO[26] to generate an interrupt. */
-	uint64_t caar                         : 1;  /**< Allows PEM_DBG_INFO[25] to generate an interrupt. */
-	uint64_t racca                        : 1;  /**< Allows PEM_DBG_INFO[24] to generate an interrupt. */
-	uint64_t racur                        : 1;  /**< Allows PEM_DBG_INFO[23] to generate an interrupt. */
-	uint64_t rauc                         : 1;  /**< Allows PEM_DBG_INFO[22] to generate an interrupt. */
-	uint64_t rqo                          : 1;  /**< Allows PEM_DBG_INFO[21] to generate an interrupt. */
-	uint64_t fcuv                         : 1;  /**< Allows PEM_DBG_INFO[20] to generate an interrupt. */
-	uint64_t rpe                          : 1;  /**< Allows PEM_DBG_INFO[19] to generate an interrupt. */
-	uint64_t fcpvwt                       : 1;  /**< Allows PEM_DBG_INFO[18] to generate an interrupt. */
-	uint64_t dpeoosd                      : 1;  /**< Allows PEM_DBG_INFO[17] to generate an interrupt. */
-	uint64_t rtwdle                       : 1;  /**< Allows PEM_DBG_INFO[16] to generate an interrupt. */
-	uint64_t rdwdle                       : 1;  /**< Allows PEM_DBG_INFO[15] to generate an interrupt. */
-	uint64_t mre                          : 1;  /**< Allows PEM_DBG_INFO[14] to generate an interrupt. */
-	uint64_t rte                          : 1;  /**< Allows PEM_DBG_INFO[13] to generate an interrupt. */
-	uint64_t acto                         : 1;  /**< Allows PEM_DBG_INFO[12] to generate an interrupt. */
-	uint64_t rvdm                         : 1;  /**< Allows PEM_DBG_INFO[11] to generate an interrupt. */
-	uint64_t rumep                        : 1;  /**< Allows PEM_DBG_INFO[10] to generate an interrupt. */
-	uint64_t rptamrc                      : 1;  /**< Allows PEM_DBG_INFO[9] to generate an interrupt. */
-	uint64_t rpmerc                       : 1;  /**< Allows PEM_DBG_INFO[8] to generate an interrupt. */
-	uint64_t rfemrc                       : 1;  /**< Allows PEM_DBG_INFO[7] to generate an interrupt. */
-	uint64_t rnfemrc                      : 1;  /**< Allows PEM_DBG_INFO[6] to generate an interrupt. */
-	uint64_t rcemrc                       : 1;  /**< Allows PEM_DBG_INFO[5] to generate an interrupt. */
-	uint64_t rpoison                      : 1;  /**< Allows PEM_DBG_INFO[4] to generate an interrupt. */
-	uint64_t recrce                       : 1;  /**< Allows PEM_DBG_INFO[3] to generate an interrupt. */
-	uint64_t rtlplle                      : 1;  /**< Allows PEM_DBG_INFO[2] to generate an interrupt. */
-	uint64_t rtlpmal                      : 1;  /**< Allows PEM_DBG_INFO[1] to generate an interrupt. */
-	uint64_t spoison                      : 1;  /**< Allows PEM_DBG_INFO[0] to generate an interrupt. */
-#else
-	uint64_t spoison                      : 1;
-	uint64_t rtlpmal                      : 1;
-	uint64_t rtlplle                      : 1;
-	uint64_t recrce                       : 1;
-	uint64_t rpoison                      : 1;
-	uint64_t rcemrc                       : 1;
-	uint64_t rnfemrc                      : 1;
-	uint64_t rfemrc                       : 1;
-	uint64_t rpmerc                       : 1;
-	uint64_t rptamrc                      : 1;
-	uint64_t rumep                        : 1;
-	uint64_t rvdm                         : 1;
-	uint64_t acto                         : 1;
-	uint64_t rte                          : 1;
-	uint64_t mre                          : 1;
-	uint64_t rdwdle                       : 1;
-	uint64_t rtwdle                       : 1;
-	uint64_t dpeoosd                      : 1;
-	uint64_t fcpvwt                       : 1;
-	uint64_t rpe                          : 1;
-	uint64_t fcuv                         : 1;
-	uint64_t rqo                          : 1;
-	uint64_t rauc                         : 1;
-	uint64_t racur                        : 1;
-	uint64_t racca                        : 1;
-	uint64_t caar                         : 1;
-	uint64_t rarwdns                      : 1;
-	uint64_t ramtlp                       : 1;
-	uint64_t racpp                        : 1;
-	uint64_t rawwpp                       : 1;
-	uint64_t ecrc_e                       : 1;
-	uint64_t rtry_pe                      : 1;
-	uint64_t hdrq_pe                      : 1;
-	uint64_t datq_pe                      : 1;
-	uint64_t tpfsbe0                      : 1;
-	uint64_t reserved_35_47               : 13;
-	uint64_t tpcsbe2                      : 1;
-	uint64_t reserved_49_50               : 2;
-	uint64_t tpcdbe2                      : 1;
-	uint64_t lofp_en                      : 1;
-	uint64_t reserved_53_63               : 11;
-#endif
-	} s;
-	struct cvmx_pemx_dbg_info_en_cn61xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_31_63               : 33;
-	uint64_t ecrc_e                       : 1;  /**< Allows PEM_DBG_INFO[30] to generate an interrupt. */
-	uint64_t rawwpp                       : 1;  /**< Allows PEM_DBG_INFO[29] to generate an interrupt. */
-	uint64_t racpp                        : 1;  /**< Allows PEM_DBG_INFO[28] to generate an interrupt. */
-	uint64_t ramtlp                       : 1;  /**< Allows PEM_DBG_INFO[27] to generate an interrupt. */
-	uint64_t rarwdns                      : 1;  /**< Allows PEM_DBG_INFO[26] to generate an interrupt. */
-	uint64_t caar                         : 1;  /**< Allows PEM_DBG_INFO[25] to generate an interrupt. */
-	uint64_t racca                        : 1;  /**< Allows PEM_DBG_INFO[24] to generate an interrupt. */
-	uint64_t racur                        : 1;  /**< Allows PEM_DBG_INFO[23] to generate an interrupt. */
-	uint64_t rauc                         : 1;  /**< Allows PEM_DBG_INFO[22] to generate an interrupt. */
-	uint64_t rqo                          : 1;  /**< Allows PEM_DBG_INFO[21] to generate an interrupt. */
-	uint64_t fcuv                         : 1;  /**< Allows PEM_DBG_INFO[20] to generate an interrupt. */
-	uint64_t rpe                          : 1;  /**< Allows PEM_DBG_INFO[19] to generate an interrupt. */
-	uint64_t fcpvwt                       : 1;  /**< Allows PEM_DBG_INFO[18] to generate an interrupt. */
-	uint64_t dpeoosd                      : 1;  /**< Allows PEM_DBG_INFO[17] to generate an interrupt. */
-	uint64_t rtwdle                       : 1;  /**< Allows PEM_DBG_INFO[16] to generate an interrupt. */
-	uint64_t rdwdle                       : 1;  /**< Allows PEM_DBG_INFO[15] to generate an interrupt. */
-	uint64_t mre                          : 1;  /**< Allows PEM_DBG_INFO[14] to generate an interrupt. */
-	uint64_t rte                          : 1;  /**< Allows PEM_DBG_INFO[13] to generate an interrupt. */
-	uint64_t acto                         : 1;  /**< Allows PEM_DBG_INFO[12] to generate an interrupt. */
-	uint64_t rvdm                         : 1;  /**< Allows PEM_DBG_INFO[11] to generate an interrupt. */
-	uint64_t rumep                        : 1;  /**< Allows PEM_DBG_INFO[10] to generate an interrupt. */
-	uint64_t rptamrc                      : 1;  /**< Allows PEM_DBG_INFO[9] to generate an interrupt. */
-	uint64_t rpmerc                       : 1;  /**< Allows PEM_DBG_INFO[8] to generate an interrupt. */
-	uint64_t rfemrc                       : 1;  /**< Allows PEM_DBG_INFO[7] to generate an interrupt. */
-	uint64_t rnfemrc                      : 1;  /**< Allows PEM_DBG_INFO[6] to generate an interrupt. */
-	uint64_t rcemrc                       : 1;  /**< Allows PEM_DBG_INFO[5] to generate an interrupt. */
-	uint64_t rpoison                      : 1;  /**< Allows PEM_DBG_INFO[4] to generate an interrupt. */
-	uint64_t recrce                       : 1;  /**< Allows PEM_DBG_INFO[3] to generate an interrupt. */
-	uint64_t rtlplle                      : 1;  /**< Allows PEM_DBG_INFO[2] to generate an interrupt. */
-	uint64_t rtlpmal                      : 1;  /**< Allows PEM_DBG_INFO[1] to generate an interrupt. */
-	uint64_t spoison                      : 1;  /**< Allows PEM_DBG_INFO[0] to generate an interrupt. */
-#else
-	uint64_t spoison                      : 1;
-	uint64_t rtlpmal                      : 1;
-	uint64_t rtlplle                      : 1;
-	uint64_t recrce                       : 1;
-	uint64_t rpoison                      : 1;
-	uint64_t rcemrc                       : 1;
-	uint64_t rnfemrc                      : 1;
-	uint64_t rfemrc                       : 1;
-	uint64_t rpmerc                       : 1;
-	uint64_t rptamrc                      : 1;
-	uint64_t rumep                        : 1;
-	uint64_t rvdm                         : 1;
-	uint64_t acto                         : 1;
-	uint64_t rte                          : 1;
-	uint64_t mre                          : 1;
-	uint64_t rdwdle                       : 1;
-	uint64_t rtwdle                       : 1;
-	uint64_t dpeoosd                      : 1;
-	uint64_t fcpvwt                       : 1;
-	uint64_t rpe                          : 1;
-	uint64_t fcuv                         : 1;
-	uint64_t rqo                          : 1;
-	uint64_t rauc                         : 1;
-	uint64_t racur                        : 1;
-	uint64_t racca                        : 1;
-	uint64_t caar                         : 1;
-	uint64_t rarwdns                      : 1;
-	uint64_t ramtlp                       : 1;
-	uint64_t racpp                        : 1;
-	uint64_t rawwpp                       : 1;
-	uint64_t ecrc_e                       : 1;
-	uint64_t reserved_31_63               : 33;
-#endif
-	} cn61xx;
-	struct cvmx_pemx_dbg_info_en_cn61xx   cn63xx;
-	struct cvmx_pemx_dbg_info_en_cn61xx   cn63xxp1;
-	struct cvmx_pemx_dbg_info_en_cn61xx   cn66xx;
-	struct cvmx_pemx_dbg_info_en_cn61xx   cn68xx;
-	struct cvmx_pemx_dbg_info_en_cn61xx   cn68xxp1;
-	struct cvmx_pemx_dbg_info_en_cn70xx {
-#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_46_63               : 18;
 	uint64_t tpcdbe1                      : 1;  /**< Allows PEM_DBG_INFO[45] to generate an interrupt. */
 	uint64_t tpcsbe1                      : 1;  /**< Allows PEM_DBG_INFO[44] to generate an interrupt. */
@@ -2425,32 +2332,10 @@ union cvmx_pemx_dbg_info_en {
 	uint64_t tpcdbe1                      : 1;
 	uint64_t reserved_46_63               : 18;
 #endif
-	} cn70xx;
-	struct cvmx_pemx_dbg_info_en_cn78xx {
+	} s;
+	struct cvmx_pemx_dbg_info_en_cn61xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_53_63               : 11;
-	uint64_t lofp_en                      : 1;  /**< Allows PEM_DBG_INFO[52] to generate an interrupt. */
-	uint64_t tpcdbe2                      : 1;  /**< Allows PEM_DBG_INFO[51] to generate an interrupt. */
-	uint64_t tpcdbe1                      : 1;  /**< Allows PEM_DBG_INFO[50] to generate an interrupt. */
-	uint64_t tpcdbe0                      : 1;  /**< Allows PEM_DBG_INFO[49] to generate an interrupt. */
-	uint64_t tpcsbe2                      : 1;  /**< Allows PEM_DBG_INFO[48] to generate an interrupt. */
-	uint64_t tpcsbe1                      : 1;  /**< Allows PEM_DBG_INFO[47] to generate an interrupt. */
-	uint64_t tpcsbe0                      : 1;  /**< Allows PEM_DBG_INFO[46] to generate an interrupt. */
-	uint64_t tnfdbe2                      : 1;  /**< Allows PEM_DBG_INFO[45] to generate an interrupt. */
-	uint64_t tnfdbe1                      : 1;  /**< Allows PEM_DBG_INFO[44] to generate an interrupt. */
-	uint64_t tnfdbe0                      : 1;  /**< Allows PEM_DBG_INFO[43] to generate an interrupt. */
-	uint64_t tnfsbe2                      : 1;  /**< Allows PEM_DBG_INFO[42] to generate an interrupt. */
-	uint64_t tnfsbe1                      : 1;  /**< Allows PEM_DBG_INFO[41] to generate an interrupt. */
-	uint64_t tnfsbe0                      : 1;  /**< Allows PEM_DBG_INFO[40] to generate an interrupt. */
-	uint64_t tpfdbe2                      : 1;  /**< Allows PEM_DBG_INFO[39] to generate an interrupt. */
-	uint64_t tpfdbe1                      : 1;  /**< Allows PEM_DBG_INFO[38] to generate an interrupt. */
-	uint64_t tpfdbe0                      : 1;  /**< Allows PEM_DBG_INFO[37] to generate an interrupt. */
-	uint64_t tpfsbe2                      : 1;  /**< Allows PEM_DBG_INFO[36] to generate an interrupt. */
-	uint64_t tpfsbe1                      : 1;  /**< Allows PEM_DBG_INFO[35] to generate an interrupt. */
-	uint64_t tpfsbe0                      : 1;  /**< Allows PEM_DBG_INFO[34] to generate an interrupt. */
-	uint64_t datq_pe                      : 1;  /**< Allows PEM_DBG_INFO[33] to generate an interrupt. */
-	uint64_t hdrq_pe                      : 1;  /**< Allows PEM_DBG_INFO[32] to generate an interrupt. */
-	uint64_t rtry_pe                      : 1;  /**< Allows PEM_DBG_INFO[31] to generate an interrupt. */
+	uint64_t reserved_31_63               : 33;
 	uint64_t ecrc_e                       : 1;  /**< Allows PEM_DBG_INFO[30] to generate an interrupt. */
 	uint64_t rawwpp                       : 1;  /**< Allows PEM_DBG_INFO[29] to generate an interrupt. */
 	uint64_t racpp                        : 1;  /**< Allows PEM_DBG_INFO[28] to generate an interrupt. */
@@ -2514,31 +2399,15 @@ union cvmx_pemx_dbg_info_en {
 	uint64_t racpp                        : 1;
 	uint64_t rawwpp                       : 1;
 	uint64_t ecrc_e                       : 1;
-	uint64_t rtry_pe                      : 1;
-	uint64_t hdrq_pe                      : 1;
-	uint64_t datq_pe                      : 1;
-	uint64_t tpfsbe0                      : 1;
-	uint64_t tpfsbe1                      : 1;
-	uint64_t tpfsbe2                      : 1;
-	uint64_t tpfdbe0                      : 1;
-	uint64_t tpfdbe1                      : 1;
-	uint64_t tpfdbe2                      : 1;
-	uint64_t tnfsbe0                      : 1;
-	uint64_t tnfsbe1                      : 1;
-	uint64_t tnfsbe2                      : 1;
-	uint64_t tnfdbe0                      : 1;
-	uint64_t tnfdbe1                      : 1;
-	uint64_t tnfdbe2                      : 1;
-	uint64_t tpcsbe0                      : 1;
-	uint64_t tpcsbe1                      : 1;
-	uint64_t tpcsbe2                      : 1;
-	uint64_t tpcdbe0                      : 1;
-	uint64_t tpcdbe1                      : 1;
-	uint64_t tpcdbe2                      : 1;
-	uint64_t lofp_en                      : 1;
-	uint64_t reserved_53_63               : 11;
+	uint64_t reserved_31_63               : 33;
 #endif
-	} cn78xx;
+	} cn61xx;
+	struct cvmx_pemx_dbg_info_en_cn61xx   cn63xx;
+	struct cvmx_pemx_dbg_info_en_cn61xx   cn63xxp1;
+	struct cvmx_pemx_dbg_info_en_cn61xx   cn66xx;
+	struct cvmx_pemx_dbg_info_en_cn61xx   cn68xx;
+	struct cvmx_pemx_dbg_info_en_cn61xx   cn68xxp1;
+	struct cvmx_pemx_dbg_info_en_s        cn70xx;
 	struct cvmx_pemx_dbg_info_en_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_dbg_info_en cvmx_pemx_dbg_info_en_t;
@@ -2602,7 +2471,11 @@ union cvmx_pemx_ecc_ena {
 	uint64_t u64;
 	struct cvmx_pemx_ecc_ena_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_9_63                : 55;
+	uint64_t reserved_35_63               : 29;
+	uint64_t qhdr_b1_ena                  : 1;  /**< ECC enable for Core's Q HDR Bank1 RAM */
+	uint64_t qhdr_b0_ena                  : 1;  /**< ECC enable for Core's Q HDR Bank0 RAM */
+	uint64_t rtry_ena                     : 1;  /**< ECC enable for Core's RETRY RAM */
+	uint64_t reserved_9_31                : 23;
 	uint64_t c_c_ena                      : 1;  /**< ECC enable for TLP CPL ctl Fifo */
 	uint64_t c_d1_ena                     : 1;  /**< ECC enable for TLP CPL data1 Fifo */
 	uint64_t c_d0_ena                     : 1;  /**< ECC enable for TLP CPL data0 Fifo */
@@ -2612,7 +2485,11 @@ union cvmx_pemx_ecc_ena {
 	uint64_t c_d0_ena                     : 1;
 	uint64_t c_d1_ena                     : 1;
 	uint64_t c_c_ena                      : 1;
-	uint64_t reserved_9_63                : 55;
+	uint64_t reserved_9_31                : 23;
+	uint64_t rtry_ena                     : 1;
+	uint64_t qhdr_b0_ena                  : 1;
+	uint64_t qhdr_b1_ena                  : 1;
+	uint64_t reserved_35_63               : 29;
 #endif
 	} s;
 	struct cvmx_pemx_ecc_ena_cn70xx {
@@ -2636,7 +2513,11 @@ union cvmx_pemx_ecc_ena {
 	} cn70xx;
 	struct cvmx_pemx_ecc_ena_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_9_63                : 55;
+	uint64_t reserved_35_63               : 29;
+	uint64_t qhdr_b1_ena                  : 1;  /**< ECC enable for Core's Q HDR Bank1 RAM */
+	uint64_t qhdr_b0_ena                  : 1;  /**< ECC enable for Core's Q HDR Bank0 RAM */
+	uint64_t rtry_ena                     : 1;  /**< ECC enable for Core's RETRY RAM */
+	uint64_t reserved_9_31                : 23;
 	uint64_t c_c_ena                      : 1;  /**< ECC enable for TLP CPL ctl Fifo */
 	uint64_t c_d1_ena                     : 1;  /**< ECC enable for TLP CPL data1 Fifo */
 	uint64_t c_d0_ena                     : 1;  /**< ECC enable for TLP CPL data0 Fifo */
@@ -2656,7 +2537,11 @@ union cvmx_pemx_ecc_ena {
 	uint64_t c_d0_ena                     : 1;
 	uint64_t c_d1_ena                     : 1;
 	uint64_t c_c_ena                      : 1;
-	uint64_t reserved_9_63                : 55;
+	uint64_t reserved_9_31                : 23;
+	uint64_t rtry_ena                     : 1;
+	uint64_t qhdr_b0_ena                  : 1;
+	uint64_t qhdr_b1_ena                  : 1;
+	uint64_t reserved_35_63               : 29;
 #endif
 	} cn78xx;
 };
@@ -2672,7 +2557,11 @@ union cvmx_pemx_ecc_synd_ctrl {
 	uint64_t u64;
 	struct cvmx_pemx_ecc_synd_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_18_63               : 46;
+	uint64_t reserved_38_63               : 26;
+	uint64_t qhdr_b1_syn                  : 2;  /**< Syndrome Flip bits for Core's Q HDR Bank1 RAM */
+	uint64_t qhdr_b0_syn                  : 2;  /**< Syndrome Flip bits for Core's Q HDR Bank0 RAM */
+	uint64_t rtry_syn                     : 2;  /**< Syndrome Flip bits for Core's RETRY RAM */
+	uint64_t reserved_18_31               : 14;
 	uint64_t c_c_syn                      : 2;  /**< Syndrome Flip bits for TLP CPL ctl Fifo */
 	uint64_t c_d1_syn                     : 2;  /**< Syndrome Flip bits for TLP CPL data1 Fifo */
 	uint64_t c_d0_syn                     : 2;  /**< Syndrome Flip bits for TLP CPL data0 Fifo */
@@ -2682,7 +2571,11 @@ union cvmx_pemx_ecc_synd_ctrl {
 	uint64_t c_d0_syn                     : 2;
 	uint64_t c_d1_syn                     : 2;
 	uint64_t c_c_syn                      : 2;
-	uint64_t reserved_18_63               : 46;
+	uint64_t reserved_18_31               : 14;
+	uint64_t rtry_syn                     : 2;
+	uint64_t qhdr_b0_syn                  : 2;
+	uint64_t qhdr_b1_syn                  : 2;
+	uint64_t reserved_38_63               : 26;
 #endif
 	} s;
 	struct cvmx_pemx_ecc_synd_ctrl_cn70xx {
@@ -2706,7 +2599,11 @@ union cvmx_pemx_ecc_synd_ctrl {
 	} cn70xx;
 	struct cvmx_pemx_ecc_synd_ctrl_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_18_63               : 46;
+	uint64_t reserved_38_63               : 26;
+	uint64_t qhdr_b1_syn                  : 2;  /**< Syndrome Flip bits for Core's Q HDR Bank1 RAM */
+	uint64_t qhdr_b0_syn                  : 2;  /**< Syndrome Flip bits for Core's Q HDR Bank0 RAM */
+	uint64_t rtry_syn                     : 2;  /**< Syndrome Flip bits for Core's RETRY RAM */
+	uint64_t reserved_18_31               : 14;
 	uint64_t c_c_syn                      : 2;  /**< Syndrome Flip bits for TLP CPL ctl Fifo */
 	uint64_t c_d1_syn                     : 2;  /**< Syndrome Flip bits for TLP CPL data1 Fifo */
 	uint64_t c_d0_syn                     : 2;  /**< Syndrome Flip bits for TLP CPL data0 Fifo */
@@ -2726,7 +2623,11 @@ union cvmx_pemx_ecc_synd_ctrl {
 	uint64_t c_d0_syn                     : 2;
 	uint64_t c_d1_syn                     : 2;
 	uint64_t c_c_syn                      : 2;
-	uint64_t reserved_18_63               : 46;
+	uint64_t reserved_18_31               : 14;
+	uint64_t rtry_syn                     : 2;
+	uint64_t qhdr_b0_syn                  : 2;
+	uint64_t qhdr_b1_syn                  : 2;
+	uint64_t reserved_38_63               : 26;
 #endif
 	} cn78xx;
 };
@@ -2834,7 +2735,6 @@ union cvmx_pemx_int_enb {
 	struct cvmx_pemx_int_enb_s            cn68xx;
 	struct cvmx_pemx_int_enb_s            cn68xxp1;
 	struct cvmx_pemx_int_enb_s            cn70xx;
-	struct cvmx_pemx_int_enb_s            cn78xx;
 	struct cvmx_pemx_int_enb_s            cnf71xx;
 };
 typedef union cvmx_pemx_int_enb cvmx_pemx_int_enb_t;
@@ -2903,7 +2803,6 @@ union cvmx_pemx_int_enb_int {
 	struct cvmx_pemx_int_enb_int_s        cn68xx;
 	struct cvmx_pemx_int_enb_int_s        cn68xxp1;
 	struct cvmx_pemx_int_enb_int_s        cn70xx;
-	struct cvmx_pemx_int_enb_int_s        cn78xx;
 	struct cvmx_pemx_int_enb_int_s        cnf71xx;
 };
 typedef union cvmx_pemx_int_enb_int cvmx_pemx_int_enb_int_t;
@@ -2918,6 +2817,57 @@ union cvmx_pemx_int_sum {
 	uint64_t u64;
 	struct cvmx_pemx_int_sum_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. */
+	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. */
+	uint64_t intb                         : 1;  /**< The PCIe controller received an INTB. */
+	uint64_t inta                         : 1;  /**< The PCIe controller received an INTA. */
+	uint64_t reserved_14_59               : 46;
+	uint64_t crs_dr                       : 1;  /**< Had a CRS Timeout when Retries were disabled. */
+	uint64_t crs_er                       : 1;  /**< Had a CRS Timeout when Retries were enabled. */
+	uint64_t rdlk                         : 1;  /**< Received Read Lock TLP. */
+	uint64_t exc                          : 1;  /**< Set when the PEM_DBG_INFO register has a bit
+                                                         set and its cooresponding PEM_DBG_INFO_EN bit
+                                                         is set. */
+	uint64_t un_bx                        : 1;  /**< Received N-TLP for an unknown Bar. */
+	uint64_t un_b2                        : 1;  /**< Received N-TLP for Bar2 when bar2 is disabled. */
+	uint64_t un_b1                        : 1;  /**< Received N-TLP for Bar1 when bar1 index valid
+                                                         is not set. */
+	uint64_t up_bx                        : 1;  /**< Received P-TLP for an unknown Bar. */
+	uint64_t up_b2                        : 1;  /**< Received P-TLP for Bar2 when bar2 is disabeld. */
+	uint64_t up_b1                        : 1;  /**< Received P-TLP for Bar1 when bar1 index valid
+                                                         is not set. */
+	uint64_t pmem                         : 1;  /**< Recived PME MSG.
+                                                         (radm_pm_pme) */
+	uint64_t pmei                         : 1;  /**< PME Interrupt.
+                                                         (cfg_pme_int) */
+	uint64_t se                           : 1;  /**< System Error, RC Mode Only.
+                                                         (cfg_sys_err_rc) */
+	uint64_t aeri                         : 1;  /**< Advanced Error Reporting Interrupt, RC Mode Only.
+                                                         (cfg_aer_rc_err_int). */
+#else
+	uint64_t aeri                         : 1;
+	uint64_t se                           : 1;
+	uint64_t pmei                         : 1;
+	uint64_t pmem                         : 1;
+	uint64_t up_b1                        : 1;
+	uint64_t up_b2                        : 1;
+	uint64_t up_bx                        : 1;
+	uint64_t un_b1                        : 1;
+	uint64_t un_b2                        : 1;
+	uint64_t un_bx                        : 1;
+	uint64_t exc                          : 1;
+	uint64_t rdlk                         : 1;
+	uint64_t crs_er                       : 1;
+	uint64_t crs_dr                       : 1;
+	uint64_t reserved_14_59               : 46;
+	uint64_t inta                         : 1;
+	uint64_t intb                         : 1;
+	uint64_t intc                         : 1;
+	uint64_t intd                         : 1;
+#endif
+	} s;
+	struct cvmx_pemx_int_sum_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
 	uint64_t crs_dr                       : 1;  /**< Had a CRS Timeout when Retries were disabled. */
 	uint64_t crs_er                       : 1;  /**< Had a CRS Timeout when Retries were enabled. */
@@ -2958,16 +2908,62 @@ union cvmx_pemx_int_sum {
 	uint64_t crs_dr                       : 1;
 	uint64_t reserved_14_63               : 50;
 #endif
-	} s;
-	struct cvmx_pemx_int_sum_s            cn61xx;
-	struct cvmx_pemx_int_sum_s            cn63xx;
-	struct cvmx_pemx_int_sum_s            cn63xxp1;
-	struct cvmx_pemx_int_sum_s            cn66xx;
-	struct cvmx_pemx_int_sum_s            cn68xx;
-	struct cvmx_pemx_int_sum_s            cn68xxp1;
-	struct cvmx_pemx_int_sum_s            cn70xx;
-	struct cvmx_pemx_int_sum_s            cn78xx;
-	struct cvmx_pemx_int_sum_s            cnf71xx;
+	} cn61xx;
+	struct cvmx_pemx_int_sum_cn61xx       cn63xx;
+	struct cvmx_pemx_int_sum_cn61xx       cn63xxp1;
+	struct cvmx_pemx_int_sum_cn61xx       cn66xx;
+	struct cvmx_pemx_int_sum_cn61xx       cn68xx;
+	struct cvmx_pemx_int_sum_cn61xx       cn68xxp1;
+	struct cvmx_pemx_int_sum_cn61xx       cn70xx;
+	struct cvmx_pemx_int_sum_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. */
+	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. */
+	uint64_t intb                         : 1;  /**< The PCIe controller received an INTB. */
+	uint64_t inta                         : 1;  /**< The PCIe controller received an INTA. */
+	uint64_t reserved_14_59               : 46;
+	uint64_t crs_dr                       : 1;  /**< Had a CRS Timeout when Retries were disabled. */
+	uint64_t crs_er                       : 1;  /**< Had a CRS Timeout when Retries were enabled. */
+	uint64_t rdlk                         : 1;  /**< Received Read Lock TLP. */
+	uint64_t reserved_10_10               : 1;
+	uint64_t un_bx                        : 1;  /**< Received N-TLP for an unknown Bar. */
+	uint64_t un_b2                        : 1;  /**< Received N-TLP for Bar2 when bar2 is disabled. */
+	uint64_t un_b1                        : 1;  /**< Received N-TLP for Bar1 when bar1 index valid
+                                                         is not set. */
+	uint64_t up_bx                        : 1;  /**< Received P-TLP for an unknown Bar. */
+	uint64_t up_b2                        : 1;  /**< Received P-TLP for Bar2 when bar2 is disabeld. */
+	uint64_t up_b1                        : 1;  /**< Received P-TLP for Bar1 when bar1 index valid
+                                                         is not set. */
+	uint64_t reserved_3_3                 : 1;
+	uint64_t pmei                         : 1;  /**< PME Interrupt.
+                                                         (cfg_pme_int) */
+	uint64_t se                           : 1;  /**< System Error, RC DEode Only.
+                                                         (cfg_sys_err_rc) */
+	uint64_t aeri                         : 1;  /**< Advanced Error Reporting Interrupt, RC Mode Only.
+                                                         (cfg_aer_rc_err_int). */
+#else
+	uint64_t aeri                         : 1;
+	uint64_t se                           : 1;
+	uint64_t pmei                         : 1;
+	uint64_t reserved_3_3                 : 1;
+	uint64_t up_b1                        : 1;
+	uint64_t up_b2                        : 1;
+	uint64_t up_bx                        : 1;
+	uint64_t un_b1                        : 1;
+	uint64_t un_b2                        : 1;
+	uint64_t un_bx                        : 1;
+	uint64_t reserved_10_10               : 1;
+	uint64_t rdlk                         : 1;
+	uint64_t crs_er                       : 1;
+	uint64_t crs_dr                       : 1;
+	uint64_t reserved_14_59               : 46;
+	uint64_t inta                         : 1;
+	uint64_t intb                         : 1;
+	uint64_t intc                         : 1;
+	uint64_t intd                         : 1;
+#endif
+	} cn78xx;
+	struct cvmx_pemx_int_sum_cn61xx       cnf71xx;
 };
 typedef union cvmx_pemx_int_sum cvmx_pemx_int_sum_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 77eba7e..dcdef0e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -53,6 +53,39 @@
 #define __CVMX_PKI_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_ACTIVE0 CVMX_PKI_ACTIVE0_FUNC()
+static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKI_ACTIVE0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000220ull);
+}
+#else
+#define CVMX_PKI_ACTIVE0 (CVMX_ADD_IO_SEG(0x0001180044000220ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_ACTIVE1 CVMX_PKI_ACTIVE1_FUNC()
+static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKI_ACTIVE1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000230ull);
+}
+#else
+#define CVMX_PKI_ACTIVE1 (CVMX_ADD_IO_SEG(0x0001180044000230ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_ACTIVE2 CVMX_PKI_ACTIVE2_FUNC()
+static inline uint64_t CVMX_PKI_ACTIVE2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKI_ACTIVE2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000240ull);
+}
+#else
+#define CVMX_PKI_ACTIVE2 (CVMX_ADD_IO_SEG(0x0001180044000240ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 {
 	if (!(
@@ -482,6 +515,28 @@ static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 #define CVMX_PKI_PCAM_RESULT (CVMX_ADD_IO_SEG(0x0001180044000510ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PFE_DIAG CVMX_PKI_PFE_DIAG_FUNC()
+static inline uint64_t CVMX_PKI_PFE_DIAG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKI_PFE_DIAG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000560ull);
+}
+#else
+#define CVMX_PKI_PFE_DIAG (CVMX_ADD_IO_SEG(0x0001180044000560ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PIX_DIAG CVMX_PKI_PIX_DIAG_FUNC()
+static inline uint64_t CVMX_PKI_PIX_DIAG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKI_PIX_DIAG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000580ull);
+}
+#else
+#define CVMX_PKI_PIX_DIAG (CVMX_ADD_IO_SEG(0x0001180044000580ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_PKINDX_ICGSEL(unsigned long offset)
 {
 	if (!(
@@ -965,6 +1020,77 @@ static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 #else
 #define CVMX_PKI_TAG_SECRET (CVMX_ADD_IO_SEG(0x0001180044000430ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_X2P_REQ_OFL CVMX_PKI_X2P_REQ_OFL_FUNC()
+static inline uint64_t CVMX_PKI_X2P_REQ_OFL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKI_X2P_REQ_OFL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000038ull);
+}
+#else
+#define CVMX_PKI_X2P_REQ_OFL (CVMX_ADD_IO_SEG(0x0001180044000038ull))
+#endif
+
+/**
+ * cvmx_pki_active0
+ */
+union cvmx_pki_active0 {
+	uint64_t u64;
+	struct cvmx_pki_active0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t pfe_active                   : 1;  /**< PFE active. For internal use; software should use PKI_SFT_RST[ACTIVE]. */
+#else
+	uint64_t pfe_active                   : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_pki_active0_s             cn78xx;
+};
+typedef union cvmx_pki_active0 cvmx_pki_active0_t;
+
+/**
+ * cvmx_pki_active1
+ */
+union cvmx_pki_active1 {
+	uint64_t u64;
+	struct cvmx_pki_active1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t fpc_active                   : 1;  /**< PBE FPC and FPA bus active. For internal use; software should use PKI_SFT_RST[ACTIVE]. */
+	uint64_t iobp_active                  : 1;  /**< PBE PMW and IOBP bus active. For internal use; software should use PKI_SFT_RST[ACTIVE]. */
+	uint64_t sws_active                   : 1;  /**< PBE SWS active. For internal use; software should use PKI_SFT_RST[ACTIVE]. */
+	uint64_t pbtag_active                 : 1;  /**< PBE pbtags active. For internal use; software should use PKI_SFT_RST[ACTIVE]. */
+#else
+	uint64_t pbtag_active                 : 1;
+	uint64_t sws_active                   : 1;
+	uint64_t iobp_active                  : 1;
+	uint64_t fpc_active                   : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_pki_active1_s             cn78xx;
+};
+typedef union cvmx_pki_active1 cvmx_pki_active1_t;
+
+/**
+ * cvmx_pki_active2
+ */
+union cvmx_pki_active2 {
+	uint64_t u64;
+	struct cvmx_pki_active2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t pix_active                   : 5;  /**< PIX control and ICG active. For internal use; software should use PKI_SFT_RST[ACTIVE]. */
+#else
+	uint64_t pix_active                   : 5;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_pki_active2_s             cn78xx;
+};
+typedef union cvmx_pki_active2 cvmx_pki_active2_t;
 
 /**
  * cvmx_pki_aura#_cfg
@@ -1074,9 +1200,16 @@ union cvmx_pki_bist_status2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t bist                         : 25; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
-                                                         register collects status for PKI_PIX.
+                                                         register collects status for PKI_PIX (verif/vkits/pki/pki_mem_info_table.sv).
                                                          - 24: IMEM
-                                                         23..16: IPEC IPEs
+                                                         - 23: IPEC3 / IPEs 10 .. 19 (RegFile + DMEM)
+                                                         - 22: IPEC3 / IPEs  0 ..  9 (RegFile + DMEM)
+                                                         - 21: IPEC2 / IPEs 10 .. 19 (RegFile + DMEM)
+                                                         - 20: IPEC2 / IPEs  0 ..  9 (RegFile + DMEM)
+                                                         - 19: IPEC1 / IPEs 10 .. 19 (RegFile + DMEM)
+                                                         - 18: IPEC1 / IPEs  0 ..  9 (RegFile + DMEM)
+                                                         - 17: IPEC0 / IPEs 10 .. 19 (RegFile + DMEM)
+                                                         - 16: IPEC0 / IPEs  0 ..  9 (RegFile + DMEM)
                                                          15..12: IPEC SMEM
                                                          11..8: IPEC PCAM ECC
                                                          7..4: IPEC PCAM RES
@@ -1125,10 +1258,7 @@ union cvmx_pki_buf_ctl {
                                                          1 = Wait until buffers become available, only dropping packets if buffering ahead of PKI
                                                          fills. This may lead to head-of-line blocking of packets on other Auras. */
 	uint64_t fpa_cac_dis                  : 1;  /**< When set, disable caching any FPA buffers, and immediately return any cached buffers to the FPA. */
-	uint64_t reserved_7_8                 : 2;
-	uint64_t pki_full                     : 1;  /**< PKI full. When this bit is set to 1, the PKI drives the PKI_BUFF_FULL line to the IOB
-                                                         arbiter, telling it to not give grants to IOI devices sending packet data; when it is
-                                                         clear to 0, the PKI acts normally. */
+	uint64_t reserved_6_8                 : 3;
 	uint64_t pkt_off                      : 1;  /**< Packet buffer off. When this bit is set to 1, the PKI does not buffer the received packet
                                                          data; when it is clear to 0, the PKI works normally, buffering the received packet data. */
 	uint64_t reserved_3_4                 : 2;
@@ -1148,8 +1278,7 @@ union cvmx_pki_buf_ctl {
 	uint64_t pbp_en                       : 1;
 	uint64_t reserved_3_4                 : 2;
 	uint64_t pkt_off                      : 1;
-	uint64_t pki_full                     : 1;
-	uint64_t reserved_7_8                 : 2;
+	uint64_t reserved_6_8                 : 3;
 	uint64_t fpa_cac_dis                  : 1;
 	uint64_t fpa_wait                     : 1;
 	uint64_t reserved_11_63               : 53;
@@ -1267,7 +1396,10 @@ union cvmx_pki_clx_int {
 	uint64_t u64;
 	struct cvmx_pki_clx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_5_63                : 59;
+	uint64_t trapz                        : 1;  /**< PCAM sequencer trapz interrupt. Throws PKI_INTSN_E::PKI_CL(0..3)_INT_TRAPZ. INTERNAL:
+                                                         Caused by TRAP sequence state, may indicate PKI enabled without proper sequencer code
+                                                         loaded in PKI_IMEM(0..2047). */
 	uint64_t iptint                       : 1;  /**< PCAM sequencer debug interrupt. Throws PKI_INTSN_E::PKI_CL(0..3)_INT_IPTINT. INTERNAL:
                                                          Caused by TRAP or INTR sequence state. */
 	uint64_t sched_conf                   : 1;  /**< PCAM/SMEM internal port conflict. Internal error, should not occur. Throws
@@ -1280,7 +1412,8 @@ union cvmx_pki_clx_int {
 	uint64_t pcam_conf                    : 2;
 	uint64_t sched_conf                   : 1;
 	uint64_t iptint                       : 1;
-	uint64_t reserved_4_63                : 60;
+	uint64_t trapz                        : 1;
+	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
 	struct cvmx_pki_clx_int_s             cn78xx;
@@ -1341,8 +1474,8 @@ union cvmx_pki_clx_pcamx_actionx {
 	uint64_t setty                        : 5;  /**< Set pointer type. If non-zero, indicates the layer type to be set as described under
                                                          PKI_PCAM_TERM_E. Values are enumerated in PKI_LTYPE_E. Must be zero for invalid entries. */
 	uint64_t advance                      : 8;  /**< Relative number of bytes to advance scan pointer when entry matches. See Parser Skip and
-                                                         Advancing. Must be zero for invalid entries and for TERMs that do not allow an advance as
-                                                         specified in the PKI_PCAM_TERM_E table. */
+                                                         Advancing. Must be even. Must be zero for invalid entries and for TERMs that do not allow
+                                                         an advance as specified in the PKI_PCAM_TERM_E table. */
 #else
 	uint64_t advance                      : 8;
 	uint64_t setty                        : 5;
@@ -1432,7 +1565,12 @@ union cvmx_pki_clx_pkindx_cfg {
 	uint64_t u64;
 	struct cvmx_pki_clx_pkindx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_7_63                : 57;
+	uint64_t reserved_8_63                : 56;
+	uint64_t fcs_pres                     : 1;  /**< FCS present.
+                                                         0 = FCS not present. FCS may not be checked nor stripped.
+                                                         1 = FCS present; the last four bytes of the packet are part of the FCS and may not be
+                                                         considered part of a IP, TCP or other header for length error checks.
+                                                         PKI_CL(0..3)_STYLE(0..63)_CFG[FCS_CHK or FCS_STRIP] may optionally be set. */
 	uint64_t mpls_en                      : 1;  /**< Enable MPLS parsing.
                                                          0 = Any MPLS labels are ignored, but may be handled by custom Ethertype PCAM matchers.
                                                          1 = MPLS label stacks are parsed and skipped over. PKI_GBL_PEN[MPLS_PEN] must be set. */
@@ -1465,7 +1603,8 @@ union cvmx_pki_clx_pkindx_cfg {
 	uint64_t lg_custom                    : 1;
 	uint64_t inst_hdr                     : 1;
 	uint64_t mpls_en                      : 1;
-	uint64_t reserved_7_63                : 57;
+	uint64_t fcs_pres                     : 1;
+	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
 	struct cvmx_pki_clx_pkindx_cfg_s      cn78xx;
@@ -1550,13 +1689,14 @@ union cvmx_pki_clx_pkindx_skip {
 	struct cvmx_pki_clx_pkindx_skip_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t fcs_skip                     : 8;  /**< Skip amount from front of packet to first byte covered by FCS start. If PTP_MODE, the
-                                                         8-byte timestamp is prepended to the packet, and FCS_SKIP must be at least 8. */
+	uint64_t fcs_skip                     : 8;  /**< Skip amount from front of packet to first byte covered by FCS start. The skip must be
+                                                         even. If PTP_MODE, the 8-byte timestamp is prepended to the packet, and FCS_SKIP must be
+                                                         at least 8. */
 	uint64_t inst_skip                    : 8;  /**< Skip amount from front of packet to begin parsing at. If
                                                          PKI_CL(0..3)_PKIND(0..63)_CFG[INST_HDR] is set, points at the first byte of the
-                                                         instruction header. If INST_HDR is clear, points at the first byte to begin parsing at. If
-                                                         PTP_MODE, the 8-byte timestamp is prepended to the packet, and INST_SKIP must be at least
-                                                         8. */
+                                                         instruction header. If INST_HDR is clear, points at the first byte to begin parsing at.
+                                                         The skip must be even. If PTP_MODE, the 8-byte timestamp is prepended to the packet, and
+                                                         INST_SKIP must be at least 8. */
 #else
 	uint64_t inst_skip                    : 8;
 	uint64_t fcs_skip                     : 8;
@@ -1733,17 +1873,18 @@ union cvmx_pki_clx_stylex_cfg {
 	uint64_t minerr_en                    : 1;  /**< Min frame error check enable. This check is typically not enabled for incoming packets on
                                                          the DPI ports. */
 	uint64_t qpg_dis_grptag               : 1;  /**< Disable computing group using WQE[TAG]. */
-	uint64_t fcs_strip                    : 1;  /**< Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes. */
-	uint64_t fcs_chk                      : 1;  /**< FCS Checking enabled. */
+	uint64_t fcs_strip                    : 1;  /**< Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes.
+                                                         PKI_CL(0..3)_PKIND(0..63)_CFG[FCS_PRES] must be set. */
+	uint64_t fcs_chk                      : 1;  /**< FCS checking enabled. PKI_CL(0..3)_PKIND(0..63)_CFG[FCS_PRES] must be set. */
 	uint64_t rawdrp                       : 1;  /**< Allow RAW packet drop.
                                                          0 = Never drop packets with WQE[RAW] set.
-                                                         1 = Allow the PKI to drop RAW packets based on QoS. */
+                                                         1 = Allow the PKI to drop RAW packets based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP]. */
 	uint64_t drop                         : 1;  /**< Force packet dropping.
-                                                         0 = Drop packet based on QoS.
+                                                         0 = Drop packet based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP].
                                                          1 = Always drop the packet. Overrides NODROP, RAWDRP. */
 	uint64_t nodrop                       : 1;  /**< Disable QoS packet drop.
-                                                         0 = Allowed to drop packet based on QoS.
-                                                         1 = Never drop the packet based on QoS. Overrides RAWDRP. */
+                                                         0 = Allowed to drop packet based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP].
+                                                         1 = Never drop the packet. Overrides RAWDRP. */
 	uint64_t qpg_dis_padd                 : 1;  /**< Disable computing port adder by QPG algorithm. */
 	uint64_t qpg_dis_grp                  : 1;  /**< Disable computing group by QPG algorithm. */
 	uint64_t qpg_dis_aura                 : 1;  /**< Disable computing aura by QPG algorithm. */
@@ -2210,7 +2351,9 @@ union cvmx_pki_gen_int {
 	uint64_t u64;
 	struct cvmx_pki_gen_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_7_63                : 57;
+	uint64_t reserved_8_63                : 56;
+	uint64_t x2p_req_ofl                  : 1;  /**< Set when a device attempts to have more than the allocated requests outstanding to PKI.
+                                                         Throws PKI_INTSN_E::PKI_GEN_X2P_REQ_OFL. */
 	uint64_t drp_noavail                  : 1;  /**< Set when packet dropped due to no FPA pointers available for the aura the packet
                                                          requested. Throws PKI_INTSN_E::PKI_GEN_DRP_NOAVAIL. */
 	uint64_t dat                          : 1;  /**< Set when data arrives before a SOP for the same reasm-id for a packet. The first detected
@@ -2224,12 +2367,15 @@ union cvmx_pki_gen_int {
                                                          detected error associated with bits [DAT,EOP,SOP] of this register is only set here. A new
                                                          bit can be set when the previous reported bit is cleared. Also see PKI_PKT_ERR. Throws
                                                          PKI_INTSN_E::PKI_GEN_SOP. */
-	uint64_t bckprs                       : 1;  /**< PKI asserted backpressure. PKI can assert backpressure to the receive logic when the to-do
-                                                         list exceeds a high-water mark. When this occurs, PKI can raise an interrupt to software.
-                                                         Throws PKI_INTSN_E::PKI_GEN_BCKPRS. */
-	uint64_t crcerr                       : 1;  /**< PKI calculated bad CRC. PKI can compute CRC in two places. Each RGMII port computes its
-                                                         own CRC, but PKI can provide an additional check. If PKI computes a bad CRC, PKI raises an
-                                                         interrupt. Throws PKI_INTSN_E::PKI_GEN_CRCERR. */
+	uint64_t bckprs                       : 1;  /**< PKI asserted backpressure. Set when PKI was unable to accept the next valid data from
+                                                         BGX/DPI/ILK etc. over X2P due to all internal resources being used up, and PKI will
+                                                         backpressure X2P. Throws PKI_INTSN_E::PKI_GEN_BCKPRS. */
+	uint64_t crcerr                       : 1;  /**< PKI calculated bad CRC. If the packet arrived via a BGX interface, the packet had an FCS
+                                                         error. If the packet arrived via PKO internal loopback, the packet had one or more parity
+                                                         errors. Not applicable when the packet arrived via the DPI interface. For ILK interfaces,
+                                                         the following ILK errors can cause packets to terminate with this error code:
+                                                         SERDES_LOCK_LOSS, BDRY_SYNC_LOSS, SCRM_SYNC_LOSS, LANE_ALIGN_FAIL, DESKEW_FIFO_OVFL,
+                                                         CRC24_ERR, UKWN_CNTL_WORD, and BAD_64B67B. Throws PKI_INTSN_E::PKI_GEN_CRCERR. */
 	uint64_t pktdrp                       : 1;  /**< Packet dropped due to QOS. If the QOS algorithm decides to drop a packet, PKI asserts this
                                                          interrupt. Throws PKI_INTSN_E::PKI_GEN_PKTDRP. */
 #else
@@ -2240,7 +2386,8 @@ union cvmx_pki_gen_int {
 	uint64_t eop                          : 1;
 	uint64_t dat                          : 1;
 	uint64_t drp_noavail                  : 1;
-	uint64_t reserved_7_63                : 57;
+	uint64_t x2p_req_ofl                  : 1;
+	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
 	struct cvmx_pki_gen_int_s             cn78xx;
@@ -2264,8 +2411,8 @@ union cvmx_pki_icgx_cfg {
                                                          packet processing, other values will decrease performance. */
 	uint64_t reserved_36_47               : 12;
 	uint64_t clusters                     : 4;  /**< Bit-mask of clusters in this cluster group. A given cluster can only be enabled in a
-                                                         single cluster group. A value of 0 disables the cluster group, all packets to this group
-                                                         will be dropped. IGC(0)'s entry resets to 0xF, all other entries to 0x0. */
+                                                         single cluster group. Behavior is undefined for an ICG which receives traffic with a
+                                                         [CLUSTERS] of 0x0. IGC(0)'s entry resets to 0xF, all other entries to 0x0. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t release_rqd                  : 1;  /**< Release required. For diagnostic use only. INTERNAL:
                                                          0 = Release of r64 to r95 will occur immediately, no release microop is needed.
@@ -2344,8 +2491,8 @@ typedef union cvmx_pki_ltypex_map cvmx_pki_ltypex_map_t;
 /**
  * cvmx_pki_pcam_lookup
  *
- * For diagnostic use only, perform a PCAM lookup against the provided cluster and PCAM and load
- * results into PKI_PCAM_RESULT.
+ * For diagnostic use only, perform a PCAM lookup against the provided cluster and PCAM instance
+ * and loads results into PKI_PCAM_RESULT.
  */
 union cvmx_pki_pcam_lookup {
 	uint64_t u64;
@@ -2379,22 +2526,30 @@ union cvmx_pki_pcam_result {
 	uint64_t u64;
 	struct cvmx_pki_pcam_result_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_32_63               : 32;
+	uint64_t reserved_41_63               : 23;
+	uint64_t match                        : 1;  /**< Resulting match. */
+	uint64_t entry                        : 8;  /**< Resulting matching entry number, unpredictable unless [MATCH] set. */
 	uint64_t result                       : 32; /**< Resulting data from matching line's PKI_CL(0..3)_PCAM(0..1)_ACTION(0..191), or zero if no match. */
 #else
 	uint64_t result                       : 32;
-	uint64_t reserved_32_63               : 32;
+	uint64_t entry                        : 8;
+	uint64_t match                        : 1;
+	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
 	struct cvmx_pki_pcam_result_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t conflict                     : 1;  /**< Conflict. The lookup resulted in multiple entries matching PKI_PCAM_LOOKUP[DATA] and
-                                                         [TERM], or zero if no match. */
-	uint64_t reserved_32_62               : 31;
+	uint64_t conflict                     : 1;  /**< Conflict. The lookup resulted in multiple entries matching PKI_PCAM_LOOKUP[DATA], [TERM]
+                                                         and [STYLE], or zero if no match. */
+	uint64_t reserved_41_62               : 22;
+	uint64_t match                        : 1;  /**< Resulting match. */
+	uint64_t entry                        : 8;  /**< Resulting matching entry number, unpredictable unless [MATCH] set. */
 	uint64_t result                       : 32; /**< Resulting data from matching line's PKI_CL(0..3)_PCAM(0..1)_ACTION(0..191), or zero if no match. */
 #else
 	uint64_t result                       : 32;
-	uint64_t reserved_32_62               : 31;
+	uint64_t entry                        : 8;
+	uint64_t match                        : 1;
+	uint64_t reserved_41_62               : 22;
 	uint64_t conflict                     : 1;
 #endif
 	} cn78xx;
@@ -2402,6 +2557,42 @@ union cvmx_pki_pcam_result {
 typedef union cvmx_pki_pcam_result cvmx_pki_pcam_result_t;
 
 /**
+ * cvmx_pki_pfe_diag
+ */
+union cvmx_pki_pfe_diag {
+	uint64_t u64;
+	struct cvmx_pki_pfe_diag_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t bad_rid                      : 1;  /**< Asserted when PFE sees and drops an X2P transaction with a RID > 95. */
+#else
+	uint64_t bad_rid                      : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_pki_pfe_diag_s            cn78xx;
+};
+typedef union cvmx_pki_pfe_diag cvmx_pki_pfe_diag_t;
+
+/**
+ * cvmx_pki_pix_diag
+ */
+union cvmx_pki_pix_diag {
+	uint64_t u64;
+	struct cvmx_pki_pix_diag_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t nosched                      : 4;  /**< Asserted when PFE requests an ICG with no enabled CLUSTERS. */
+#else
+	uint64_t nosched                      : 4;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_pki_pix_diag_s            cn78xx;
+};
+typedef union cvmx_pki_pix_diag cvmx_pki_pix_diag_t;
+
+/**
  * cvmx_pki_pkind#_icgsel
  */
 union cvmx_pki_pkindx_icgsel {
@@ -2602,21 +2793,28 @@ typedef union cvmx_pki_req_wgt cvmx_pki_req_wgt_t;
 
 /**
  * cvmx_pki_sft_rst
- *
- * Allows soft reset.
- *
  */
 union cvmx_pki_sft_rst {
 	uint64_t u64;
 	struct cvmx_pki_sft_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t busy                         : 1;  /**< When 1, PKI is busy completing reset. No access except the reading of this bit should
-                                                         occur to the PKI until this is clear. */
-	uint64_t reserved_1_62                : 62;
-	uint64_t rst                          : 1;  /**< Reset. When set to 1 by software, PKI gets a short reset pulse (three cycles in duration). */
+	uint64_t busy                         : 1;  /**< When set, PKI is busy completing reset. No access except the reading of this bit should
+                                                         occur to the PKI until this is clear. INTERNAL: The BUSY bit for this implementation is a
+                                                         placeholder and is not required to be implemented in HW. The soft reset pulse is short
+                                                         enough that we can guarantee that reset will complete below a subsequent RSL reference can
+                                                         be made. It is still useful for this bit to exist in case that property every changes and
+                                                         the reset requires a longer duration. For this implementation, SW will check the bit which
+                                                         will always report not BUSY allowing SW to proceed with its flow. */
+	uint64_t reserved_33_62               : 30;
+	uint64_t active                       : 1;  /**< When set, PKI is actively processing packet traffic. It is recommenced that software wait
+                                                         until ACTIVE is clear before setting RST. INTERNAL: ACTIVE is an OR of PKI_ACTIVE0..2. */
+	uint64_t reserved_1_31                : 31;
+	uint64_t rst                          : 1;  /**< Reset. When set to 1 by software, PKI will produce an internal reset pulse. */
 #else
 	uint64_t rst                          : 1;
-	uint64_t reserved_1_62                : 62;
+	uint64_t reserved_1_31                : 31;
+	uint64_t active                       : 1;
+	uint64_t reserved_33_62               : 30;
 	uint64_t busy                         : 1;
 #endif
 	} s;
@@ -2831,8 +3029,8 @@ union cvmx_pki_statx_stat12 {
 	struct cvmx_pki_statx_stat12_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t l2err                        : 48; /**< Number of packets with receive errors (WQE[ERRLEV]==RE or L2) not covered by more specific
-                                                         length or FCS statistic error registers. */
+	uint64_t l2err                        : 48; /**< Number of non-dropped packets with receive errors (WQE[ERRLEV]==RE or L2) not covered by
+                                                         more specific length or FCS statistic error registers. */
 #else
 	uint64_t l2err                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2850,7 +3048,8 @@ union cvmx_pki_statx_stat13 {
 	struct cvmx_pki_statx_stat13_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t spec                         : 48; /**< Number of packets with special handling. For profiling and diagnostic use only.
+	uint64_t spec                         : 48; /**< Number of packets, dropped or non-dropped, with special handling. For profiling and
+                                                         diagnostic use only.
                                                          INTERNAL: Counts packets completing IPE processing with WQE[SH] set. */
 #else
 	uint64_t spec                         : 48;
@@ -3151,13 +3350,13 @@ union cvmx_pki_stylex_buf {
 	uint64_t first_skip                   : 6;  /**< The number of eight-byte words from the top of the first MBUF that the PKI stores the next
                                                          pointer. If [DIS_WQ_DAT]=1, any value is legal. If [DIS_WQ_DAT]=0, legal values must
                                                          satisfy:
-                                                         FIRST_SKIP + 18 <= PKI_STYLE(0..63)_BUF[MB_SIZE]
+                                                         FIRST_SKIP <= PKI_STYLE(0..63)_BUF[MB_SIZE] - 18.
                                                          FIRST_SKIP must be at least 0x4, but 0x5 is recommended minimum. 0x4 will drop WQE WORD4,
                                                          for use in backward compatible applications.
                                                          WQE_SKIP * (128/8) + 4 <= FIRST_SKIP, to insure the minimum of four work-queue entry words
                                                          will fit within FIRST_SKIP. */
 	uint64_t later_skip                   : 6;  /**< The number of eight-byte words from the top of any MBUF that is not the first MBUF that
-                                                         PKI writes the next-pointer to. Legal values are 0 to PKI_STYLE(0..63)_BUF[MB_SIZE] - 16. */
+                                                         PKI writes the next-pointer to. Legal values are 0 to PKI_STYLE(0..63)_BUF[MB_SIZE] - 18. */
 	uint64_t opc_mode                     : 2;  /**< Select the style of write to the L2C.
                                                          0 = all packet data and next-buffer pointers are written through to memory.
                                                          1 = all packet data and next-buffer pointers are written into the cache.
@@ -3365,4 +3564,23 @@ union cvmx_pki_tag_secret {
 };
 typedef union cvmx_pki_tag_secret cvmx_pki_tag_secret_t;
 
+/**
+ * cvmx_pki_x2p_req_ofl
+ */
+union cvmx_pki_x2p_req_ofl {
+	uint64_t u64;
+	struct cvmx_pki_x2p_req_ofl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t x2p_did                      : 4;  /**< When PKI_GEN_INT[X2P_REQ_OFL] is set, this field latches the X2P device id number which
+                                                         attempted to overflow the allowed outstanding requests to PKI. */
+#else
+	uint64_t x2p_did                      : 4;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_pki_x2p_req_ofl_s         cn78xx;
+};
+typedef union cvmx_pki_x2p_req_ofl cvmx_pki_x2p_req_ofl_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index fe18f76..22c7fa1 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -1675,6 +1675,17 @@ static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 #define CVMX_PKO_PDM_CFG_DBG (CVMX_ADD_IO_SEG(0x0001540000800FF8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PDM_CP_DBG CVMX_PKO_PDM_CP_DBG_FUNC()
+static inline uint64_t CVMX_PKO_PDM_CP_DBG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PDM_CP_DBG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000800190ull);
+}
+#else
+#define CVMX_PKO_PDM_CP_DBG (CVMX_ADD_IO_SEG(0x0001540000800190ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 {
 	if (!(
@@ -1785,6 +1796,17 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRD_DBG (CVMX_ADD_IO_SEG(0x0001540000800090ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PDM_ISRD_DBG_DQ CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC()
+static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG_DQ not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000800290ull);
+}
+#else
+#define CVMX_PKO_PDM_ISRD_DBG_DQ (CVMX_ADD_IO_SEG(0x0001540000800290ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PDM_ISRM_DBG CVMX_PKO_PDM_ISRM_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 {
@@ -1796,6 +1818,17 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG (CVMX_ADD_IO_SEG(0x0001540000800098ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PDM_ISRM_DBG_DQ CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC()
+static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG_DQ not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000800298ull);
+}
+#else
+#define CVMX_PKO_PDM_ISRM_DBG_DQ (CVMX_ADD_IO_SEG(0x0001540000800298ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PDM_MEM_ADDR CVMX_PKO_PDM_MEM_ADDR_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 {
@@ -2899,11 +2932,11 @@ union cvmx_pko_dpfi_flush {
 	struct cvmx_pko_dpfi_flush_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t flush_en                     : 1;  /**< Pointer cache flush enable. When set to 1 this flag commands the DPFI logic to flush all
+	uint64_t flush_en                     : 1;  /**< Pointer cache flush enable. When set, this flag commands the DPFI logic to flush all
                                                          valid pointers from the pointer cache and return them to the FPA. The flush operation is
-                                                         complete when the CACHE_FLUSHED flag in the PKO_DFPI_STATUS register is set. Clearing the
-                                                         FLUSH_EN flag results in the DPFI reloading its pointer cache. This flush mechanism should
-                                                         only be enabled when the PKO is quiescent and all DQs have been closed. */
+                                                         complete when the CACHE_FLUSHED flag in PKO_DPFI_STATUS is set. Clearing the FLUSH_EN flag
+                                                         results in the DPFI reloading its pointer cache. This flush mechanism should only be
+                                                         enabled when the PKO is quiescent and all DQs have been closed. */
 #else
 	uint64_t flush_en                     : 1;
 	uint64_t reserved_1_63                : 63;
@@ -2943,30 +2976,19 @@ union cvmx_pko_dpfi_status {
 	uint64_t ptr_cnt                      : 32; /**< The number of pointers currently in use for storing descriptors
                                                          and meta-packets plus those available in the DPFI pointer cache. */
 	uint64_t reserved_13_31               : 19;
-	uint64_t isrd_ptr1_rtn_full           : 1;  /**< 1 = ISRD pointer return register 1 contains a valid pointer
-                                                         0 = ISRD pointer return register 1 is empty */
-	uint64_t isrd_ptr0_rtn_full           : 1;  /**< 1 = ISRD pointer return register 0 contains a valid pointer
-                                                         0 = ISRD pointer return register 0 is empty */
-	uint64_t isrm_ptr1_rtn_full           : 1;  /**< 1 = ISRM pointer return register 1 contains a valid pointer
-                                                         0 = ISRM pointer return register 1 is empty */
-	uint64_t isrm_ptr0_rtn_full           : 1;  /**< 1 = ISRM pointer return register 0 contains a valid pointer
-                                                         0 = ISRM pointer return register 0 is empty */
-	uint64_t isrd_ptr1_val                : 1;  /**< 1 = ISRD pointer register 1 contains a valid pointer
-                                                         0 = ISRD pointer register 1 is empty */
-	uint64_t isrd_ptr0_val                : 1;  /**< 1 = ISRD pointer register 0 contains a valid pointer
-                                                         0 = ISRD pointer register 0 is empty */
-	uint64_t isrm_ptr1_val                : 1;  /**< 1 = ISRM pointer register 1 contains a valid pointer
-                                                         0 = ISRM pointer register 1 is empty */
-	uint64_t isrm_ptr0_val                : 1;  /**< 1 = ISRM pointer register 0 contains a valid pointer
-                                                         0 = ISRM pointer register 0 is empty */
-	uint64_t ptr_req_pend                 : 1;  /**< 1 = DPFI has pointer requests to FPA pending
-                                                         0 = DPFI has no pointer requests to FPA pending */
-	uint64_t ptr_rtn_pend                 : 1;  /**< 1 = DPFI has pointer returns to FPA pending
-                                                         0 = DPFI has no pointer returns to FPA pending */
-	uint64_t fpa_empty                    : 1;  /**< 1 = FPA responded to pointer request with 'no pointers available'.
+	uint64_t isrd_ptr1_rtn_full           : 1;  /**< ISRD pointer return register 1 contains a valid pointer. */
+	uint64_t isrd_ptr0_rtn_full           : 1;  /**< ISRD pointer return register 0 contains a valid pointer. */
+	uint64_t isrm_ptr1_rtn_full           : 1;  /**< ISRM pointer return register 1 contains a valid pointer. */
+	uint64_t isrm_ptr0_rtn_full           : 1;  /**< ISRM pointer return register 0 contains a valid pointer. */
+	uint64_t isrd_ptr1_val                : 1;  /**< ISRD pointer register 1 contains a valid pointer. */
+	uint64_t isrd_ptr0_val                : 1;  /**< ISRD pointer register 0 contains a valid pointer. */
+	uint64_t isrm_ptr1_val                : 1;  /**< ISRM pointer register 1 contains a valid pointer. */
+	uint64_t isrm_ptr0_val                : 1;  /**< ISRM pointer register 0 contains a valid pointer. */
+	uint64_t ptr_req_pend                 : 1;  /**< DPFI has pointer requests to FPA pending. */
+	uint64_t ptr_rtn_pend                 : 1;  /**< DPFI has pointer returns to FPA pending. */
+	uint64_t fpa_empty                    : 1;  /**< 1 = FPA responded to pointer request with 'no pointers available.'
                                                          0 = FPA is providing pointers when requested. */
-	uint64_t dpfi_empty                   : 1;  /**< 1 = DPFI pointer cache is empty.
-                                                         0 = DPFI pointer cache is not empty. */
+	uint64_t dpfi_empty                   : 1;  /**< DPFI pointer cache is empty. */
 	uint64_t cache_flushed                : 1;  /**< 1 = Cache flush has completed. PKO_DPFI_STATUS[PTR_CNT] will read zero if all
                                                              outstanding pointers have been returned to the FPA.
                                                          0 = Cache flush not enabled or in-progress. */
@@ -3126,23 +3148,23 @@ union cvmx_pko_dqx_pick {
 	uint64_t u64;
 	struct cvmx_pko_dqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq                           : 10; /**< Descriptor Queue. Index of originating descriptor queue. */
+	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
 	uint64_t color                        : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[COLOR]. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this
                                                          result is connected in a flow that extends through the child result, this is the
                                                          index of that child result. */
-	uint64_t bubble                       : 1;  /**< This meta-packet is a fake passed forward after a prune. */
-	uint64_t p_con                        : 1;  /**< Parent Connected Flag. This pick has more picks in front of it. */
-	uint64_t c_con                        : 1;  /**< Child Connected Flag. This pick has more picks behind it. */
+	uint64_t bubble                       : 1;  /**< This metapacket is a fake passed forward after a prune. */
+	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
+	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First Packet Descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't Send. Set when metapacket is not to be sent. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ(0..511)_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR Disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR Disable. Committed shaper disabled. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
 	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet Length. The packet length in bytes. */
+	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -3246,13 +3268,12 @@ union cvmx_pko_dqx_schedule {
 	struct cvmx_pko_dqx_schedule_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's
-                                                         scheduling algorithm. When this SQ is not used, we recommend
-                                                         PRIO be zero. The legal PRIO values are 0-9 when the SQ is used.
-                                                         In addition to priority, PRIO determines whether the SQ is a static
-                                                         queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
-                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this
-                                                         is a round-robin child queue into the shaper at the next level. */
+	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's scheduling
+                                                         algorithm. When this SQ is not used, we recommend setting PRIO to zero. The legal PRIO
+                                                         values are 0-9 when the SQ is used. In addition to priority, PRIO determines whether the
+                                                         SQ is a static queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
+                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
+                                                         the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned integer). */
 #else
 	uint64_t rr_quantum                   : 24;
@@ -3272,8 +3293,8 @@ union cvmx_pko_dqx_shape {
 	struct cvmx_pko_dqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t length_disable               : 1;  /**< Length Disable. Disables the use of packet lengths in shaping calculations such that
-                                                         only the value of the ADJUST field described below is used. */
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
+                                                         the value of PKO_L5_SQ(0..1023)_SHAPE[ADJUST]. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -3330,14 +3351,13 @@ union cvmx_pko_dqx_sw_xoff {
 	struct cvmx_pko_dqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< DRAIN_IRQ. Enables an interrupt that will fire when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "DRAIN_NULL_LINK. Conditions the drain path to drain through the null link (i.e. link \#
-                                                         28).
-                                                         As such, channel credits, HW_XOFF and shaping will be disabled on the draining path until
-                                                         the path has drained." */
-	uint64_t drain                        : 1;  /**< DRAIN. This control activates a drain path through the PSE that starts at this node and
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
+	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
+                                                         \#28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
+                                                         until the path has drained." */
+	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ describe above. */
+                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is de-asserted.
                                                          NOTE: The associated PKO_L1_SQ(0..31)_TOPOLOGY[LINK] must be configured before using this
                                                          register field. Writing to this register field before the associated
@@ -3402,9 +3422,7 @@ union cvmx_pko_dqx_wm_ctl {
 	struct cvmx_pko_dqx_wm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t enable                       : 1;  /**< Watermark enable.
-                                                         0 = Disabled
-                                                         1 = Enable */
+	uint64_t enable                       : 1;  /**< Watermark enable. */
 	uint64_t kind                         : 1;  /**< Watermark kind. The watermark logic can use a byte count or packet count.
                                                          0 = Byte count
                                                          1 = Packet count */
@@ -3513,10 +3531,10 @@ union cvmx_pko_formatx_ctl {
 	uint64_t reserved_28_63               : 36;
 	uint64_t ip4_ck                       : 1;  /**< IPv4 header checksum recalculate */
 	uint64_t offset                       : 11; /**< Bits to add to PKO_SEND_EXT[MARKPTR]*8 to determine where to start marking. */
-	uint64_t y_mask                       : 4;  /**< Yellow mark mask. Corresponding bits in packet's data will be cleared when marking packet yellow */
-	uint64_t y_val                        : 4;  /**< Yellow mark value. Corresponding bits in packet's data will be set when marking packet yellow */
-	uint64_t r_mask                       : 4;  /**< Red mark mask. Corresponding bits in packet's data will be cleared when marking packet red */
-	uint64_t r_val                        : 4;  /**< Red mark value. Corresponding bits in packet's data will be set when marking packet red */
+	uint64_t y_mask                       : 4;  /**< Yellow mark mask. Corresponding bits in packet's data are cleared when marking packet yellow. */
+	uint64_t y_val                        : 4;  /**< Yellow mark value. Corresponding bits in packet's data are set when marking packet yellow. */
+	uint64_t r_mask                       : 4;  /**< Red mark mask. Corresponding bits in packet's data are cleared when marking packet red. */
+	uint64_t r_val                        : 4;  /**< Red mark value. Corresponding bits in packet's data are set when marking packet red. */
 #else
 	uint64_t r_val                        : 4;
 	uint64_t r_mask                       : 4;
@@ -3608,8 +3626,8 @@ union cvmx_pko_l1_sqx_green {
 	struct cvmx_pko_l1_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
-	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
                                                          scheduling queue are active. For internal use only. */
 	uint64_t reserved_19_19               : 1;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
@@ -3711,23 +3729,23 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t u64;
 	struct cvmx_pko_l1_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq                           : 10; /**< Descriptor Queue. Index of originating descriptor queue. */
+	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
 	uint64_t color                        : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[COLOR]. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this
                                                          result is connected in a flow that extends through the child result, this is the
                                                          index of that child result. */
-	uint64_t bubble                       : 1;  /**< This meta-packet is a fake passed forward after a prune. */
-	uint64_t p_con                        : 1;  /**< Parent Connected Flag. This pick has more picks in front of it. */
-	uint64_t c_con                        : 1;  /**< Child Connected Flag. This pick has more picks behind it. */
+	uint64_t bubble                       : 1;  /**< This metapacket is a fake passed forward after a prune. */
+	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
+	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First Packet Descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't Send. Set when metapacket is not to be sent. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ(0..511)_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR Disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR Disable. Committed shaper disabled. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
 	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet Length. The packet length in bytes. */
+	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -3897,14 +3915,13 @@ union cvmx_pko_l1_sqx_sw_xoff {
 	struct cvmx_pko_l1_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< DRAIN_IRQ. Enables an interrupt that will fire when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "DRAIN_NULL_LINK. Conditions the drain path to drain through the null link (i.e. link \#
-                                                         28).
-                                                         As such, channel credits, HW_XOFF and shaping will be disabled on the draining path until
-                                                         the path has drained." */
-	uint64_t drain                        : 1;  /**< DRAIN. This control activates a drain path through the PSE that starts at this node and
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
+	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
+                                                         \#28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
+                                                         until the path has drained." */
+	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ describe above. */
+                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is de-asserted.
                                                          NOTE: The associated PKO_L1_SQ(0..31)_TOPOLOGY[LINK] must be configured before using this
                                                          register field. Writing to this register field before the associated
@@ -4103,8 +4120,8 @@ union cvmx_pko_l2_sqx_green {
 	struct cvmx_pko_l2_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
-	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
                                                          scheduling queue are active. For internal use only. */
 	uint64_t reserved_19_19               : 1;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
@@ -4131,23 +4148,23 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t u64;
 	struct cvmx_pko_l2_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq                           : 10; /**< Descriptor Queue. Index of originating descriptor queue. */
+	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
 	uint64_t color                        : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[COLOR]. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this
                                                          result is connected in a flow that extends through the child result, this is the
                                                          index of that child result. */
-	uint64_t bubble                       : 1;  /**< This meta-packet is a fake passed forward after a prune. */
-	uint64_t p_con                        : 1;  /**< Parent Connected Flag. This pick has more picks in front of it. */
-	uint64_t c_con                        : 1;  /**< Child Connected Flag. This pick has more picks behind it. */
+	uint64_t bubble                       : 1;  /**< This metapacket is a fake passed forward after a prune. */
+	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
+	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First Packet Descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't Send. Set when metapacket is not to be sent. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ(0..511)_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR Disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR Disable. Committed shaper disabled. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
 	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet Length. The packet length in bytes. */
+	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -4273,13 +4290,12 @@ union cvmx_pko_l2_sqx_schedule {
 	struct cvmx_pko_l2_sqx_schedule_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's
-                                                         scheduling algorithm. When this SQ is not used, we recommend
-                                                         PRIO be zero. The legal PRIO values are 0-9 when the SQ is used.
-                                                         In addition to priority, PRIO determines whether the SQ is a static
-                                                         queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
-                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this
-                                                         is a round-robin child queue into the shaper at the next level. */
+	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's scheduling
+                                                         algorithm. When this SQ is not used, we recommend setting PRIO to zero. The legal PRIO
+                                                         values are 0-9 when the SQ is used. In addition to priority, PRIO determines whether the
+                                                         SQ is a static queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
+                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
+                                                         the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned integer). */
 #else
 	uint64_t rr_quantum                   : 24;
@@ -4300,17 +4316,17 @@ union cvmx_pko_l2_sqx_shape {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
-                                                         the value of the ADJUST field described below is used. */
+                                                         the value of PKO_L2_SQ(0..511)_SHAPE[ADJUST]. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
                                                          transitions when set. */
 	uint64_t red_algo                     : 2;  /**< Shaper red state algorithm.
                                                          0 = Stall packets while in RED state until YELLOW or GREEN state is reached (aka never
-                                                         send RED packets)
-                                                         1 = Send packets while in RED state
-                                                         2 = Same as 0 above (stall)
-                                                         3 = Discard packets while in RED state (red packets are converted to drop packets) */
+                                                         send RED packets).
+                                                         1 = Send packets while in RED state.
+                                                         2 = Same as 0 above (stall).
+                                                         3 = Discard packets while in RED state (red packets are converted to drop packets). */
 	uint64_t adjust                       : 9;  /**< Shaping calculation adjustment. This 9-bit signed values allows +/- 256 bytes to be added
                                                          to the packet length for the shaping calculations. */
 #else
@@ -4363,14 +4379,13 @@ union cvmx_pko_l2_sqx_sw_xoff {
 	struct cvmx_pko_l2_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< DRAIN_IRQ. Enables an interrupt that will fire when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "DRAIN_NULL_LINK. Conditions the drain path to drain through the null link (i.e. link \#
-                                                         28).
-                                                         As such, channel credits, HW_XOFF and shaping will be disabled on the draining path until
-                                                         the path has drained." */
-	uint64_t drain                        : 1;  /**< DRAIN. This control activates a drain path through the PSE that starts at this node and
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
+	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
+                                                         \#28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
+                                                         until the path has drained." */
+	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ describe above. */
+                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is de-asserted.
                                                          NOTE: The associated PKO_L1_SQ(0..31)_TOPOLOGY[LINK] must be configured before using this
                                                          register field. Writing to this register field before the associated
@@ -4398,12 +4413,11 @@ union cvmx_pko_l2_sqx_topology {
 	uint64_t reserved_41_63               : 23;
 	uint64_t prio_anchor                  : 9;  /**< See PKO_L1_SQ(0..31)_TOPOLOGY[PRIO_ANCHOR]. */
 	uint64_t reserved_21_31               : 11;
-	uint64_t parent                       : 5;  /**< Parent queue index. The index of the shaping element at the next lower
-                                                         hierachical level that accepts *this* shaping element's outputs.
-                                                         Refer to the PKO_*_SQn_TOPOLOGY[PRIO_ANCHOR,RR_PRIO] descriptions
-                                                         for constraints on which child queues can attach to which shapers
-                                                         at the next lower level. When this shaper is unused, we recommend
-                                                         PARENT be zero. */
+	uint64_t parent                       : 5;  /**< Parent queue index. The index of the shaping element at the next lower hierarchical level
+                                                         that accepts this shaping element's outputs. Refer to the
+                                                         PKO_*_SQn_TOPOLOGY[PRIO_ANCHOR,RR_PRIO] descriptions for constraints on which child queues
+                                                         can attach to which shapers at the next lower level. When this shaper is unused, we
+                                                         recommend that PARENT be zero. */
 	uint64_t reserved_5_15                : 11;
 	uint64_t rr_prio                      : 4;  /**< See PKO_L1_SQ(0..31)_TOPOLOGY[RR_PRIO]. */
 	uint64_t reserved_0_0                 : 1;
@@ -4484,13 +4498,12 @@ union cvmx_pko_l3_l2_sqx_channel {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
 	uint64_t cc_channel                   : 12; /**< Channel ID. */
-	uint64_t cc_word_cnt                  : 20; /**< Channel credit word count.
-                                                         This value, plus 1 MTU, represents the maximum outstanding word count (words are 16 bytes)
-                                                         for this channel.
-                                                         Note that this 20-bit field represents a signed value that decrements towards zero as
-                                                         credits are used. Packets are not allowed to flow when the count is less than zero. As
-                                                         such, the most significant bit should normally be programmed as zero (positive count).
-                                                         This gives a maximum value for this field of 2^18 - 1. */
+	uint64_t cc_word_cnt                  : 20; /**< Channel credit word count. This value, plus 1 MTU, represents the maximum outstanding word
+                                                         count for this channel. (Words are 16 bytes.) Note that this 20-bit field represents a
+                                                         signed value that decrements towards zero as credits are used. Packets are not allowed to
+                                                         flow when the count is less than zero. As such, the most significant bit should normally
+                                                         be programmed as zero (positive count). This gives a maximum value for this field of 2^18
+                                                         - 1. */
 	uint64_t cc_packet_cnt                : 10; /**< Channel credit packet count. This value, plus 1, represents the maximum outstanding packet
                                                          count for this channel.
                                                          Note that this 10-bit field represents a signed value that decrements towards zero as
@@ -4498,8 +4511,8 @@ union cvmx_pko_l3_l2_sqx_channel {
                                                          such the most significant bit should normally be programmed as zero (positive count). This
                                                          gives a maximum value for this field of 2^9 - 1. */
 	uint64_t cc_enable                    : 1;  /**< Channel credit enable. Enables CC_WORD_CNT and CC_PACKET_CNT credit processing. */
-	uint64_t hw_xoff                      : 1;  /**< Hardware XOFF status. The status of hardware XON/XOFF. This is write-able to get around
-                                                         LUT issues and for reconfiguration. */
+	uint64_t hw_xoff                      : 1;  /**< Hardware XOFF status. The status of hardware XON/XOFF. This is writable to get around LUT
+                                                         issues and for reconfiguration. */
 #else
 	uint64_t hw_xoff                      : 1;
 	uint64_t cc_enable                    : 1;
@@ -4554,8 +4567,8 @@ union cvmx_pko_l3_sqx_green {
 	struct cvmx_pko_l3_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
-	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
                                                          scheduling queue are active. For internal use only. */
 	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
 	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
@@ -4578,23 +4591,23 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t u64;
 	struct cvmx_pko_l3_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq                           : 10; /**< Descriptor Queue. Index of originating descriptor queue. */
+	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
 	uint64_t color                        : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[COLOR]. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this
                                                          result is connected in a flow that extends through the child result, this is the
                                                          index of that child result. */
-	uint64_t bubble                       : 1;  /**< This meta-packet is a fake passed forward after a prune. */
-	uint64_t p_con                        : 1;  /**< Parent Connected Flag. This pick has more picks in front of it. */
-	uint64_t c_con                        : 1;  /**< Child Connected Flag. This pick has more picks behind it. */
+	uint64_t bubble                       : 1;  /**< This metapacket is a fake passed forward after a prune. */
+	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
+	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First Packet Descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't Send. Set when metapacket is not to be sent. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ(0..511)_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR Disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR Disable. Committed shaper disabled. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
 	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet Length. The packet length in bytes. */
+	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -4718,13 +4731,12 @@ union cvmx_pko_l3_sqx_schedule {
 	struct cvmx_pko_l3_sqx_schedule_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's
-                                                         scheduling algorithm. When this SQ is not used, we recommend
-                                                         PRIO be zero. The legal PRIO values are 0-9 when the SQ is used.
-                                                         In addition to priority, PRIO determines whether the SQ is a static
-                                                         queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
-                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this
-                                                         is a round-robin child queue into the shaper at the next level. */
+	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's scheduling
+                                                         algorithm. When this SQ is not used, we recommend setting PRIO to zero. The legal PRIO
+                                                         values are 0-9 when the SQ is used. In addition to priority, PRIO determines whether the
+                                                         SQ is a static queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
+                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
+                                                         the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned integer). */
 #else
 	uint64_t rr_quantum                   : 24;
@@ -4745,7 +4757,7 @@ union cvmx_pko_l3_sqx_shape {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
-                                                         the value of the ADJUST field described below is used. */
+                                                         the value of the ADJUST field is used. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -4802,14 +4814,13 @@ union cvmx_pko_l3_sqx_sw_xoff {
 	struct cvmx_pko_l3_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< DRAIN_IRQ. Enables an interrupt that will fire when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "DRAIN_NULL_LINK. Conditions the drain path to drain through the null link (i.e. link \#
-                                                         28).
-                                                         As such, channel credits, HW_XOFF and shaping will be disabled on the draining path until
-                                                         the path has drained." */
-	uint64_t drain                        : 1;  /**< DRAIN. This control activates a drain path through the PSE that starts at this node and
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
+	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
+                                                         \#28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
+                                                         until the path has drained." */
+	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ describe above. */
+                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is de-asserted.
                                                          NOTE: The associated PKO_L1_SQ(0..31)_TOPOLOGY[LINK] must be configured before using this
                                                          register field. Writing to this register field before the associated
@@ -4948,8 +4959,8 @@ union cvmx_pko_l4_sqx_green {
 	struct cvmx_pko_l4_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
-	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
                                                          scheduling queue are active. For internal use only. */
 	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
 	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
@@ -4972,23 +4983,23 @@ union cvmx_pko_l4_sqx_pick {
 	uint64_t u64;
 	struct cvmx_pko_l4_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq                           : 10; /**< Descriptor Queue. Index of originating descriptor queue. */
+	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
 	uint64_t color                        : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[COLOR]. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this
                                                          result is connected in a flow that extends through the child result, this is the
                                                          index of that child result. */
-	uint64_t bubble                       : 1;  /**< This meta-packet is a fake passed forward after a prune. */
-	uint64_t p_con                        : 1;  /**< Parent Connected Flag. This pick has more picks in front of it. */
-	uint64_t c_con                        : 1;  /**< Child Connected Flag. This pick has more picks behind it. */
+	uint64_t bubble                       : 1;  /**< This metapacket is a fake passed forward after a prune. */
+	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
+	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First Packet Descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't Send. Set when metapacket is not to be sent. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ(0..511)_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR Disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR Disable. Committed shaper disabled. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
 	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet Length. The packet length in bytes. */
+	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -5112,13 +5123,12 @@ union cvmx_pko_l4_sqx_schedule {
 	struct cvmx_pko_l4_sqx_schedule_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's
-                                                         scheduling algorithm. When this SQ is not used, we recommend
-                                                         PRIO be zero. The legal PRIO values are 0-9 when the SQ is used.
-                                                         In addition to priority, PRIO determines whether the SQ is a static
-                                                         queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
-                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this
-                                                         is a round-robin child queue into the shaper at the next level. */
+	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's scheduling
+                                                         algorithm. When this SQ is not used, we recommend setting PRIO to zero. The legal PRIO
+                                                         values are 0-9 when the SQ is used. In addition to priority, PRIO determines whether the
+                                                         SQ is a static queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
+                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
+                                                         the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned integer). */
 #else
 	uint64_t rr_quantum                   : 24;
@@ -5139,7 +5149,7 @@ union cvmx_pko_l4_sqx_shape {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
-                                                         the value of the ADJUST field described below is used. */
+                                                         the value of the ADJUST field is used. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -5196,14 +5206,13 @@ union cvmx_pko_l4_sqx_sw_xoff {
 	struct cvmx_pko_l4_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< DRAIN_IRQ. Enables an interrupt that will fire when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "DRAIN_NULL_LINK. Conditions the drain path to drain through the null link (i.e. link \#
-                                                         28).
-                                                         As such, channel credits, HW_XOFF and shaping will be disabled on the draining path until
-                                                         the path has drained." */
-	uint64_t drain                        : 1;  /**< DRAIN. This control activates a drain path through the PSE that starts at this node and
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
+	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
+                                                         \#28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
+                                                         until the path has drained." */
+	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ describe above. */
+                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is de-asserted.
                                                          NOTE: The associated PKO_L1_SQ(0..31)_TOPOLOGY[LINK] must be configured before using this
                                                          register field. Writing to this register field before the associated
@@ -5342,8 +5351,8 @@ union cvmx_pko_l5_sqx_green {
 	struct cvmx_pko_l5_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
-	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
                                                          scheduling queue are active. For internal use only. */
 	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
 	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
@@ -5366,23 +5375,23 @@ union cvmx_pko_l5_sqx_pick {
 	uint64_t u64;
 	struct cvmx_pko_l5_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq                           : 10; /**< Descriptor Queue. Index of originating descriptor queue. */
+	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
 	uint64_t color                        : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[COLOR]. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this
                                                          result is connected in a flow that extends through the child result, this is the
                                                          index of that child result. */
-	uint64_t bubble                       : 1;  /**< This meta-packet is a fake passed forward after a prune. */
-	uint64_t p_con                        : 1;  /**< Parent Connected Flag. This pick has more picks in front of it. */
-	uint64_t c_con                        : 1;  /**< Child Connected Flag. This pick has more picks behind it. */
+	uint64_t bubble                       : 1;  /**< This metapacket is a fake passed forward after a prune. */
+	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
+	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
 	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First Packet Descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't Send. Set when metapacket is not to be sent. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ(0..511)_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR Disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR Disable. Committed shaper disabled. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
 	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ(0..511)_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet Length. The packet length in bytes. */
+	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -5506,13 +5515,12 @@ union cvmx_pko_l5_sqx_schedule {
 	struct cvmx_pko_l5_sqx_schedule_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's
-                                                         scheduling algorithm. When this SQ is not used, we recommend
-                                                         PRIO be zero. The legal PRIO values are 0-9 when the SQ is used.
-                                                         In addition to priority, PRIO determines whether the SQ is a static
-                                                         queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
-                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this
-                                                         is a round-robin child queue into the shaper at the next level. */
+	uint64_t prio                         : 4;  /**< Priority. The priority used for this SQ in the (lower-level) parent's scheduling
+                                                         algorithm. When this SQ is not used, we recommend setting PRIO to zero. The legal PRIO
+                                                         values are 0-9 when the SQ is used. In addition to priority, PRIO determines whether the
+                                                         SQ is a static queue or not: If PRIO equals PKO_*_SQn_TOPOLOGY[RR_PRIO], where
+                                                         PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
+                                                         the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned integer). */
 #else
 	uint64_t rr_quantum                   : 24;
@@ -5532,8 +5540,8 @@ union cvmx_pko_l5_sqx_shape {
 	struct cvmx_pko_l5_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t length_disable               : 1;  /**< Length Disable. Disables the use of packet lengths in shaping calculations such that
-                                                         only the value of the ADJUST field described below is used. */
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
+                                                         the value of PKO_L5_SQ(0..1023)_SHAPE[ADJUST]. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -5590,14 +5598,13 @@ union cvmx_pko_l5_sqx_sw_xoff {
 	struct cvmx_pko_l5_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< DRAIN_IRQ. Enables an interrupt that will fire when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "DRAIN_NULL_LINK. Conditions the drain path to drain through the null link (i.e. link \#
-                                                         28).
-                                                         As such, channel credits, HW_XOFF and shaping will be disabled on the draining path until
-                                                         the path has drained." */
-	uint64_t drain                        : 1;  /**< DRAIN. This control activates a drain path through the PSE that starts at this node and
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
+	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
+                                                         \#28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
+                                                         until the path has drained." */
+	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ describe above. */
+                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is de-asserted.
                                                          NOTE: The associated PKO_L1_SQ(0..31)_TOPOLOGY[LINK] must be configured before using this
                                                          register field. Writing to this register field before the associated
@@ -5785,8 +5792,8 @@ union cvmx_pko_lut_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t lut_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_LUT_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_LUT_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_LUT_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_LUT_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
@@ -5828,8 +5835,8 @@ union cvmx_pko_lut_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t lut_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_LUT_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_LUT_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_LUT_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_LUT_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
@@ -5853,8 +5860,9 @@ union cvmx_pko_macx_cfg {
 	uint64_t reserved_17_63               : 47;
 	uint64_t min_pad_ena                  : 1;  /**< Minimum padding is enabled for this MAC/FIFO */
 	uint64_t fcs_ena                      : 1;  /**< Enable outside FCS for this MAC/FIFO */
-	uint64_t fcs_sop_off                  : 8;  /**< Offset from SOP for beginning of outside FCS calculation */
-	uint64_t skid_max_cnt                 : 2;  /**< Maximum number of SKID credits. 0x0 = 16, 0x1 = 32, 0x2 = 64. */
+	uint64_t fcs_sop_off                  : 8;  /**< FCS start of packet offset.  For this MAC, the number of bytes in the front
+                                                         of each packet to exclude from FCS. */
+	uint64_t skid_max_cnt                 : 2;  /**< Maximum number of SKID credits. 0x0 = 16; 0x1 = 32; 0x2 = 64. */
 	uint64_t fifo_num                     : 5;  /**< The PEB TX FIFO number assigned to the given MAC. A value of 0x1F means unassigned. Unused
                                                          MACs must be assigned a FIFO_NUM = 0x1F. For each active MAC, a unique FIFO_NUM must be
                                                          assigned. Legal values depend on the values in PKO_PTGF(0..7)_CFG[SIZE]. Assigning the
@@ -7950,6 +7958,9 @@ typedef union cvmx_pko_mem_throttle_pipe cvmx_pko_mem_throttle_pipe_t;
 
 /**
  * cvmx_pko_ncb_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_ncb_bist_status {
 	uint64_t u64;
@@ -8054,8 +8065,8 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ncb_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_NCB_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_NCB_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
@@ -8117,8 +8128,8 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ncb_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_NCB_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_NCB_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
@@ -8193,7 +8204,7 @@ union cvmx_pko_ncb_tx_err_word {
 	struct cvmx_pko_ncb_tx_err_word_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t err_word                     : 64; /**< PKO NCB error word (first word of erroneous transaction).
-                                                         Note: this is only the 64-bit data word; the NCB info that goes with it is in
+                                                         Note: This is only the 64-bit data word; the NCB info that goes with it is in
                                                          PKO_NCB_TX_ERR_INFO. */
 #else
 	uint64_t err_word                     : 64;
@@ -8205,6 +8216,9 @@ typedef union cvmx_pko_ncb_tx_err_word cvmx_pko_ncb_tx_err_word_t;
 
 /**
  * cvmx_pko_pdm_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_pdm_bist_status {
 	uint64_t u64;
@@ -8278,26 +8292,30 @@ union cvmx_pko_pdm_cfg {
 	uint64_t u64;
 	struct cvmx_pko_pdm_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_11_63               : 53;
-	uint64_t dis_flsh_cache               : 1;  /**< Set to disable the flush buffer's cache. This will make all fills require full memory
-                                                         latency. For diagnostic use only. */
-	uint64_t pko_pad_minlen               : 7;  /**< Minimum frame padding min length. When */
+	uint64_t reserved_13_63               : 51;
+	uint64_t dis_lpd_w2r_fill             : 1;  /**< Set to disable the write to read fill caused by LPD in the PDM. If disabled, must wait for
+                                                         FPD bit from PEB, which is a performance penalty when the time is large for the PEB
+                                                         request to make it back to PDM. For diagnostic use only. */
+	uint64_t en_fr_w2r_ptr_swp            : 1;  /**< Set to enable pointer swap on a fill response when we go in-sync (only one cacheline in
+                                                         DQ).
+                                                         For diagnostic use only. */
+	uint64_t dis_flsh_cache               : 1;  /**< Set to disable the flush buffer's cache. This makes all fills require full memory latency.
+                                                         For diagnostic use only. */
+	uint64_t pko_pad_minlen               : 7;  /**< Minimum frame padding min length. */
 	uint64_t diag_mode                    : 1;  /**< Set to enable read/write to memories in PDM through CSR interface.  For diagnostic use only. */
 	uint64_t alloc_lds                    : 1;  /**< Allocate LDS. This signal prevents the loads to IOBP from being allocated in on-chip cache
-                                                         (LDWB vs. LDD). Two modes as follows:
-                                                         0 = No allocate (LDWB)
-                                                         1 = Allocate (LDD) */
+                                                         (LDWB vs. LDD). Two modes as follows: 0 = No allocate (LDWB); 1 = Allocate (LDD). */
 	uint64_t alloc_sts                    : 1;  /**< Allocate STS. This signal prevents the stores to NCB from being allocated in on-chip cache
-                                                         (STF vs. STT). Two modes as follows:
-                                                         0 = No allocate (STT)
-                                                         1 = Allocate (STF) */
+                                                         (STF vs. STT). Two modes as follows: 0 = No allocate (STT); 1 = Allocate (STF). */
 #else
 	uint64_t alloc_sts                    : 1;
 	uint64_t alloc_lds                    : 1;
 	uint64_t diag_mode                    : 1;
 	uint64_t pko_pad_minlen               : 7;
 	uint64_t dis_flsh_cache               : 1;
-	uint64_t reserved_11_63               : 53;
+	uint64_t en_fr_w2r_ptr_swp            : 1;
+	uint64_t dis_lpd_w2r_fill             : 1;
+	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
 	struct cvmx_pko_pdm_cfg_s             cn78xx;
@@ -8313,8 +8331,8 @@ union cvmx_pko_pdm_cfg_dbg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t cp_stall_thrshld             : 32; /**< Program this register to the 32-bit number of cycles to test for the PDM(CP) stalled on
-                                                         inputs going into the ISR's. PKO_PDM_STS[CP_STALL_THRSHLD_HIT] indicates the threshold has
-                                                         been hit. INTERNAL: Do not list field in HRM. For lab debug only; will likely disapear in
+                                                         inputs going into the ISRs. PKO_PDM_STS[CP_STALL_THRSHLD_HIT] indicates the threshold has
+                                                         been hit. INTERNAL: Do not list field in HRM. For lab debug only; will likely disappear in
                                                          pass 2. */
 #else
 	uint64_t cp_stall_thrshld             : 32;
@@ -8326,6 +8344,33 @@ union cvmx_pko_pdm_cfg_dbg {
 typedef union cvmx_pko_pdm_cfg_dbg cvmx_pko_pdm_cfg_dbg_t;
 
 /**
+ * cvmx_pko_pdm_cp_dbg
+ */
+union cvmx_pko_pdm_cp_dbg {
+	uint64_t u64;
+	struct cvmx_pko_pdm_cp_dbg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t stateless_fif_cnt            : 6;  /**< Stateless fifo count. */
+	uint64_t reserved_5_9                 : 5;
+	uint64_t op_fif_not_full              : 5;  /**< Output fifo not full signals. The order of the bits is:
+                                                         - 4: ISR CMD FIFO not full
+                                                         - 3: DESC DAT FIFO HIGH not full
+                                                         - 2: DESC DAT FIFO LOW not full
+                                                         - 1: MP DAT FIFO not full
+                                                         - 0: PSE CMD RESP FIFO has credit */
+#else
+	uint64_t op_fif_not_full              : 5;
+	uint64_t reserved_5_9                 : 5;
+	uint64_t stateless_fif_cnt            : 6;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_pko_pdm_cp_dbg_s          cn78xx;
+};
+typedef union cvmx_pko_pdm_cp_dbg cvmx_pko_pdm_cp_dbg_t;
+
+/**
  * cvmx_pko_pdm_dq#_minpad
  */
 union cvmx_pko_pdm_dqx_minpad {
@@ -8333,12 +8378,11 @@ union cvmx_pko_pdm_dqx_minpad {
 	struct cvmx_pko_pdm_dqx_minpad_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t minpad                       : 1;  /**< MINPAD setting per DQ. Each DQ has a seperate CSR address, and bit 0 of the
-                                                         data read/write value will be the MINPAD bit.
-                                                         When MINPAD is set, the send-packet header will have the total field adjusted by MINLEN
-                                                         (PKO_PDM_CFG.PKO_PAD_MINLEN) as follows:
-                                                           if( MINPAD )
-                                                               if( send_hdr.total < MINLEN ) send_hdr.total = MINLEN */
+	uint64_t minpad                       : 1;  /**< MINPAD setting per DQ. Each DQ has a separate CSR address; and bit 0 of the data
+                                                         read/write value is the MINPAD bit. When MINPAD is set, the send-packet header has the
+                                                         total field adjusted by MINLEN (PKO_PDM_CFG.PKO_PAD_MINLEN) as follows:
+                                                         if (MINPAD)
+                                                         if (send_hdr.total < MINLEN) send_hdr.total = MINLEN */
 #else
 	uint64_t minpad                       : 1;
 	uint64_t reserved_1_63                : 63;
@@ -8355,21 +8399,30 @@ union cvmx_pko_pdm_drpbuf_dbg {
 	uint64_t u64;
 	struct cvmx_pko_pdm_drpbuf_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_19_63               : 45;
-	uint64_t cur_state                    : 3;  /**< This is current state from the pbuf controller. */
-	uint64_t track_rd_cnt                 : 6;  /**< This is the track read count value. */
-	uint64_t track_wr_cnt                 : 6;  /**< This is the track write count value. */
-	uint64_t mem_en                       : 4;  /**< These are the memory write/chip enable signals. The order of the bits is:
-                                                         - 3: low wen
-                                                         - 2: low cen
-                                                         - 1: high wen
-                                                         - 0: high cen */
+	uint64_t reserved_43_63               : 21;
+	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
+	uint64_t load_val                     : 1;  /**< Load valid signal. */
+	uint64_t rdy                          : 1;  /**< Ready signal. */
+	uint64_t cur_state                    : 3;  /**< Current state from the pbuf controller. */
+	uint64_t reserved_33_36               : 4;
+	uint64_t track_rd_cnt                 : 6;  /**< Track read count value. */
+	uint64_t track_wr_cnt                 : 6;  /**< Track write count value. */
+	uint64_t reserved_17_20               : 4;
+	uint64_t mem_addr                     : 13; /**< Memory address for pbuf ram. */
+	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
+                                                         - 3: low wen; 2: low cen; 1: high wen; 0: high cen. */
 #else
 	uint64_t mem_en                       : 4;
+	uint64_t mem_addr                     : 13;
+	uint64_t reserved_17_20               : 4;
 	uint64_t track_wr_cnt                 : 6;
 	uint64_t track_rd_cnt                 : 6;
+	uint64_t reserved_33_36               : 4;
 	uint64_t cur_state                    : 3;
-	uint64_t reserved_19_63               : 45;
+	uint64_t rdy                          : 1;
+	uint64_t load_val                     : 1;
+	uint64_t sel_nxt_ptr                  : 1;
+	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
 	struct cvmx_pko_pdm_drpbuf_dbg_s      cn78xx;
@@ -8383,21 +8436,30 @@ union cvmx_pko_pdm_dwpbuf_dbg {
 	uint64_t u64;
 	struct cvmx_pko_pdm_dwpbuf_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_19_63               : 45;
-	uint64_t cur_state                    : 3;  /**< This is current state from the pbuf controller. */
-	uint64_t track_rd_cnt                 : 6;  /**< This is the track read count value. */
-	uint64_t track_wr_cnt                 : 6;  /**< This is the track write count value. */
-	uint64_t mem_en                       : 4;  /**< These are the memory write/chip enable signals. The order of the bits is:
-                                                         - 3: low wen
-                                                         - 2: low cen
-                                                         - 1: high wen
-                                                         - 0: high cen */
+	uint64_t reserved_43_63               : 21;
+	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
+	uint64_t load_val                     : 1;  /**< Load valid signal. */
+	uint64_t rdy                          : 1;  /**< Ready signal. */
+	uint64_t cur_state                    : 3;  /**< Current state from the pbuf controller. */
+	uint64_t reserved_33_36               : 4;
+	uint64_t track_rd_cnt                 : 6;  /**< Track read count value. */
+	uint64_t track_wr_cnt                 : 6;  /**< Track write count value. */
+	uint64_t reserved_17_20               : 4;
+	uint64_t mem_addr                     : 13; /**< Memory address for pbuf ram. */
+	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
+                                                         - 3: low wen; 2: low cen; 1: high wen; 0: high cen. */
 #else
 	uint64_t mem_en                       : 4;
+	uint64_t mem_addr                     : 13;
+	uint64_t reserved_17_20               : 4;
 	uint64_t track_wr_cnt                 : 6;
 	uint64_t track_rd_cnt                 : 6;
+	uint64_t reserved_33_36               : 4;
 	uint64_t cur_state                    : 3;
-	uint64_t reserved_19_63               : 45;
+	uint64_t rdy                          : 1;
+	uint64_t load_val                     : 1;
+	uint64_t sel_nxt_ptr                  : 1;
+	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
 	struct cvmx_pko_pdm_dwpbuf_dbg_s      cn78xx;
@@ -8636,8 +8698,8 @@ union cvmx_pko_pdm_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pdm_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PDM_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PDM_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PDM_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PDM_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi
@@ -8784,8 +8846,8 @@ union cvmx_pko_pdm_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pdm_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PDM_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PDM_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PDM_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PDM_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi
@@ -8829,8 +8891,8 @@ union cvmx_pko_pdm_isrd_dbg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
 	uint64_t in_arb_reqs                  : 8;  /**< Input arbitration request signals. The order of the bits is:
-                                                         - 43: Fill Response - normal path request
-                                                         - 42: Fill Response - flushb path request
+                                                         - 43: Fill response - normal path request
+                                                         - 42: Fill response - flushb path request
                                                          - 41: CP queue-open request
                                                          - 40: CP queue-closed request
                                                          - 39: CP queue-query request
@@ -8838,50 +8900,49 @@ union cvmx_pko_pdm_isrd_dbg {
                                                          - 37: PEB fill request
                                                          - 36: PEB read request */
 	uint64_t in_arb_gnts                  : 7;  /**< Input arbitration grant signals. The order of the bits is:
-                                                         - 35: Fill Response grant
+                                                         - 35: Fill response grant
                                                          - 34: CP - queue-open grant
                                                          - 33: CP - queue-close grant
                                                          - 32: CP - queue-query grant
                                                          - 31: CP - send-packet grant
-                                                         - 30: PEB Fill grant
-                                                         - 29: PEB Read grant */
+                                                         - 30: PEB fill grant
+                                                         - 29: PEB read grant */
 	uint64_t cmt_arb_reqs                 : 7;  /**< Commit arbitration request signals. The order of the bits is:
-                                                         - 28: Fill Response grant
+                                                         - 28: Fill response grant
                                                          - 27: CP - queue-open grant
                                                          - 26: CP - queue-close grant
                                                          - 25: CP - queue-query grant
                                                          - 24: CP - send-packet grant
-                                                         - 23: PEB Fill grant
-                                                         - 22: PEB Read grant */
+                                                         - 23: PEB fill grant
+                                                         - 22: PEB read grant */
 	uint64_t cmt_arb_gnts                 : 7;  /**< Commit arbitration grant signals. The order of the bits is:
-                                                         - 21: Fill Response grant
+                                                         - 21: Fill response grant
                                                          - 20: CP - queue-open grant
                                                          - 19: CP - queue-close grant
                                                          - 18: CP - queue-query grant
                                                          - 17: CP - send-packet grant
-                                                         - 16: PEB Fill grant
-                                                         - 15: PEB Read grant */
+                                                         - 16: PEB fill grant
+                                                         - 15: PEB read grant */
 	uint64_t in_use                       : 4;  /**< In use signals indicate the execution units are in use. The order of the bits is:
                                                          - 14: PEB fill unit
                                                          - 13: PEB read unit
                                                          - 12: CP unit
-                                                         - 11: Fill Response unit */
+                                                         - 11: Fill response unit */
 	uint64_t has_cred                     : 4;  /**< Has credit signals indicate there is sufficient credit to commit. The order of the bits
-                                                         is:
-                                                           - 10: Flush Buffer has credit
-                                                          - 9: Fill Buffer has credit
-                                                          - 8: DW command output fifo has credit
-                                                          - 7: DR command output fifo has credit */
+                                                          is:
+                                                          - 10: Flush buffer has credit
+                                                         - 9: Fill buffer has credit
+                                                         - 8: DW command output FIFO has credit
+                                                         - 7: DR command output FIFO has credit */
 	uint64_t val_exec                     : 7;  /**< Valid bits for the execution units; means the unit can commit if it gets the grant of the
-                                                         commit arb and other conditions are met.
-                                                         The order of the bits is :
-                                                          - 6: fill response unit
-                                                          - 5: CP unit - queue-open
-                                                          - 4: CP unit - queue-close
-                                                          - 3: CP unit - queue-probe
-                                                          - 2: CP unit - send-packet
-                                                          - 1: PEB Fill unit
-                                                          - 0: PEB Read unit */
+                                                          commit arb and other conditions are met. The order of the bits is:
+                                                         - 6: Fill response unit
+                                                         - 5: CP unit - queue-open
+                                                         - 4: CP unit - queue-close
+                                                         - 3: CP unit - queue-probe
+                                                         - 2: CP unit - send-packet
+                                                         - 1: PEB fill unit
+                                                         - 0: PEB read unit */
 #else
 	uint64_t val_exec                     : 7;
 	uint64_t has_cred                     : 4;
@@ -8898,6 +8959,36 @@ union cvmx_pko_pdm_isrd_dbg {
 typedef union cvmx_pko_pdm_isrd_dbg cvmx_pko_pdm_isrd_dbg_t;
 
 /**
+ * cvmx_pko_pdm_isrd_dbg_dq
+ */
+union cvmx_pko_pdm_isrd_dbg_dq {
+	uint64_t u64;
+	struct cvmx_pko_pdm_isrd_dbg_dq_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_46_63               : 18;
+	uint64_t pebrd_sic_dq                 : 10; /**< CP SIC's DQ number. */
+	uint64_t reserved_34_35               : 2;
+	uint64_t pebfill_sic_dq               : 10; /**< CP SIC's DQ number. */
+	uint64_t reserved_22_23               : 2;
+	uint64_t fr_sic_dq                    : 10; /**< CP SIC's DQ number. */
+	uint64_t reserved_10_11               : 2;
+	uint64_t cp_sic_dq                    : 10; /**< CP SIC's DQ number. */
+#else
+	uint64_t cp_sic_dq                    : 10;
+	uint64_t reserved_10_11               : 2;
+	uint64_t fr_sic_dq                    : 10;
+	uint64_t reserved_22_23               : 2;
+	uint64_t pebfill_sic_dq               : 10;
+	uint64_t reserved_34_35               : 2;
+	uint64_t pebrd_sic_dq                 : 10;
+	uint64_t reserved_46_63               : 18;
+#endif
+	} s;
+	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn78xx;
+};
+typedef union cvmx_pko_pdm_isrd_dbg_dq cvmx_pko_pdm_isrd_dbg_dq_t;
+
+/**
  * cvmx_pko_pdm_isrm_dbg
  */
 union cvmx_pko_pdm_isrm_dbg {
@@ -8906,7 +8997,7 @@ union cvmx_pko_pdm_isrm_dbg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t in_arb_reqs                  : 7;  /**< Input arbitration request signals. The order of the bits is:
-                                                         - 33: PSE ack
+                                                         - 33: PSE ACK
                                                          - 32: Fill Response - normal path request
                                                          - 31: Fill Response - flushb path request
                                                          - 30: CP queue-open
@@ -8914,41 +9005,40 @@ union cvmx_pko_pdm_isrm_dbg {
                                                          - 28: CP queue-query
                                                          - 27: CP send-packet */
 	uint64_t in_arb_gnts                  : 6;  /**< Input arbitration grant signals. The order of the bits is:
-                                                         - 26: PSE ack
+                                                         - 26: PSE ACK
                                                          - 25: Fill Response
                                                          - 24: CP - queue-open
                                                          - 23: CP - queue-close
                                                          - 22: CP - queue-query
                                                          - 21: CP - send-packet */
 	uint64_t cmt_arb_reqs                 : 6;  /**< Commit arbitration request signals. The order of the bits is:
-                                                         - 20: PSE ack
+                                                         - 20: PSE ACK
                                                          - 19: Fill Response
                                                          - 18: CP - queue-open
                                                          - 17: CP - queue-close
                                                          - 16: CP - queue-query
                                                          - 15: CP - send-packet */
 	uint64_t cmt_arb_gnts                 : 6;  /**< Commit arbitration grant signals. The order of the bits is:
-                                                          - 14: PSE ack
+                                                          - 14: PSE ACK
                                                           - 13: Fill Response
                                                           - 12: CP - queue-open
                                                           - 11: CP - queue-close
                                                           - 10: CP - queue-query
                                                          - 9: CP - send-packet */
 	uint64_t in_use                       : 3;  /**< In use signals indicate the execution units are in use. The order of the bits is:
-                                                         - 8: (PSE) ack unit
-                                                         - 7: Fill Response unit
+                                                         - 8: (PSE) ACK unit
+                                                         - 7: Fill response unit
                                                          - 6: CP unit */
 	uint64_t has_cred                     : 3;  /**< Has credit signals indicate there is sufficient credit to commit. The order of the bits
-                                                         is:
-                                                          - 5: Flush Buffer has credit
-                                                          - 4: Fill Buffer has credit
-                                                          - 3: MWP command output fifo has credit */
+                                                          is:
+                                                         - 5: Flush buffer has credit
+                                                         - 4: Fill buffer has credit
+                                                         - 3: MWP command output FIFO has credit */
 	uint64_t val_exec                     : 3;  /**< Valid bits for the execution units; means the unit can commit if it gets the grant of the
-                                                         commit arb and other conditions are met.
-                                                         The order of the bits is :
-                                                          - 2: (PSE) ack unit
-                                                          - 1: Fill response unit
-                                                          - 0: CP unit - ALL */
+                                                          commit arb and other conditions are met. The order of the bits is:
+                                                         - 2: (PSE) ACK unit
+                                                         - 1: Fill response unit
+                                                         - 0: CP unit - ALL */
 #else
 	uint64_t val_exec                     : 3;
 	uint64_t has_cred                     : 3;
@@ -8965,6 +9055,32 @@ union cvmx_pko_pdm_isrm_dbg {
 typedef union cvmx_pko_pdm_isrm_dbg cvmx_pko_pdm_isrm_dbg_t;
 
 /**
+ * cvmx_pko_pdm_isrm_dbg_dq
+ */
+union cvmx_pko_pdm_isrm_dbg_dq {
+	uint64_t u64;
+	struct cvmx_pko_pdm_isrm_dbg_dq_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_34_63               : 30;
+	uint64_t ack_sic_dq                   : 10; /**< CP SIC's DQ number. */
+	uint64_t reserved_22_23               : 2;
+	uint64_t fr_sic_dq                    : 10; /**< CP SIC's DQ number. */
+	uint64_t reserved_10_11               : 2;
+	uint64_t cp_sic_dq                    : 10; /**< CP SIC's DQ number. */
+#else
+	uint64_t cp_sic_dq                    : 10;
+	uint64_t reserved_10_11               : 2;
+	uint64_t fr_sic_dq                    : 10;
+	uint64_t reserved_22_23               : 2;
+	uint64_t ack_sic_dq                   : 10;
+	uint64_t reserved_34_63               : 30;
+#endif
+	} s;
+	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn78xx;
+};
+typedef union cvmx_pko_pdm_isrm_dbg_dq cvmx_pko_pdm_isrm_dbg_dq_t;
+
+/**
  * cvmx_pko_pdm_mem_addr
  */
 union cvmx_pko_pdm_mem_addr {
@@ -8972,12 +9088,13 @@ union cvmx_pko_pdm_mem_addr {
 	struct cvmx_pko_pdm_mem_addr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t memsel                       : 3;  /**< Memory select. Selects the RAM to read or write to.
-                                                         0 = Invalid, 1 = ISRM states, 2 = ISRDstates, 3 = DWPBUF,
-                                                         4 = DRPBUF, 5 = MWPBUF */
+                                                         0 = Invalid, 1 = ISRM states, 2 = ISRD states, 3 = DWPBUF, 4 = DRPBUF, 5 = MWPBUF */
 	uint64_t reserved_17_60               : 44;
 	uint64_t memaddr                      : 14; /**< Memory address for the RAM. */
 	uint64_t reserved_2_2                 : 1;
-	uint64_t membanksel                   : 2;  /**< Memory bank select. Selects the bank to write to. */
+	uint64_t membanksel                   : 2;  /**< Memory bank select. Selects the bank to write to. Note that bit 0 is the only bit used in
+                                                         the PBUF's because there are only 2 banks per each PBUF. In the ISRM bank sel 3 is
+                                                         illegal. */
 #else
 	uint64_t membanksel                   : 2;
 	uint64_t reserved_2_2                 : 1;
@@ -8997,7 +9114,9 @@ union cvmx_pko_pdm_mem_data {
 	uint64_t u64;
 	struct cvmx_pko_pdm_mem_data_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t data                         : 64; /**< Raw data to write into the memory, or the raw data read out from the memory. */
+	uint64_t data                         : 64; /**< Raw data to write into the memory, or the raw data read out from the memory.
+                                                         Note that the ISR RAMs are only 57 bits wide, so [56:0] are the only bits that can be read
+                                                         or written to them. The PBUFs are 64 bits wide. */
 #else
 	uint64_t data                         : 64;
 #endif
@@ -9034,7 +9153,7 @@ union cvmx_pko_pdm_mem_rw_sts {
 	struct cvmx_pko_pdm_mem_rw_sts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t readdone                     : 1;  /**< This will be set to 1 when the read is complete and the data is valid in the data register. */
+	uint64_t readdone                     : 1;  /**< This bit is set to 1 when the read is complete and the data is valid in the data register. */
 #else
 	uint64_t readdone                     : 1;
 	uint64_t reserved_1_63                : 63;
@@ -9051,21 +9170,30 @@ union cvmx_pko_pdm_mwpbuf_dbg {
 	uint64_t u64;
 	struct cvmx_pko_pdm_mwpbuf_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_19_63               : 45;
-	uint64_t cur_state                    : 3;  /**< This is current state from the pbuf controller. */
-	uint64_t track_rd_cnt                 : 6;  /**< This is the track read count value. */
-	uint64_t track_wr_cnt                 : 6;  /**< This is the track write count value. */
-	uint64_t mem_en                       : 4;  /**< These are the memory write/chip enable signals. The order of the bits is:
-                                                         - 3: low wen
-                                                         - 2: low cen
-                                                         - 1: high wen
-                                                         - 0: high cen */
+	uint64_t reserved_43_63               : 21;
+	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
+	uint64_t load_val                     : 1;  /**< Load valid signal. */
+	uint64_t rdy                          : 1;  /**< Ready signal. */
+	uint64_t cur_state                    : 3;  /**< Current state from the pbuf controller. */
+	uint64_t reserved_33_36               : 4;
+	uint64_t track_rd_cnt                 : 6;  /**< Track read count value. */
+	uint64_t track_wr_cnt                 : 6;  /**< Track write count value. */
+	uint64_t reserved_17_20               : 4;
+	uint64_t mem_addr                     : 13; /**< Memory address for pbuf ram. */
+	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
+                                                         - 3: low wen; 2: low cen; 1: high wen; 0: high cen. */
 #else
 	uint64_t mem_en                       : 4;
+	uint64_t mem_addr                     : 13;
+	uint64_t reserved_17_20               : 4;
 	uint64_t track_wr_cnt                 : 6;
 	uint64_t track_rd_cnt                 : 6;
+	uint64_t reserved_33_36               : 4;
 	uint64_t cur_state                    : 3;
-	uint64_t reserved_19_63               : 45;
+	uint64_t rdy                          : 1;
+	uint64_t load_val                     : 1;
+	uint64_t sel_nxt_ptr                  : 1;
+	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
 	struct cvmx_pko_pdm_mwpbuf_dbg_s      cn78xx;
@@ -9080,71 +9208,63 @@ union cvmx_pko_pdm_sts {
 	struct cvmx_pko_pdm_sts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_38_63               : 26;
-	uint64_t cp_stalled_thrshld_hit       : 1;  /**< This register will be set to 1 if the PDM stalls the inputs for more than
+	uint64_t cp_stalled_thrshld_hit       : 1;  /**< This register is set to 1 if the PDM stalls the inputs for more than
                                                          PKO_PDM_CFG_DBG[CP_STALL_THRSHLD]. INTERNAL: Do not list field in HRM. For lab debug only;
                                                          will likely disapear in pass 2. */
 	uint64_t reserved_35_36               : 2;
-	uint64_t mwpbuf_data_val_err          : 1;  /**< Recieved signal that MWPBUF had data valid error. Throws
+	uint64_t mwpbuf_data_val_err          : 1;  /**< Received signal that MWPBUF had data valid error. Throws
                                                          PKO_INTSN_E::PKO_MWPBUF_DATA_VAL_ERR. */
-	uint64_t drpbuf_data_val_err          : 1;  /**< Recieved signal that DRPBUF had data valid error. Throws
+	uint64_t drpbuf_data_val_err          : 1;  /**< Received signal that DRPBUF had data valid error. Throws
                                                          PKO_INTSN_E::PKO_DRPBUF_DATA_VAL_ERR. */
-	uint64_t dwpbuf_data_val_err          : 1;  /**< Recieved signal that DWPBUF had data valid error. Throws
+	uint64_t dwpbuf_data_val_err          : 1;  /**< Received signal that DWPBUF had data valid error. Throws
                                                          PKO_INTSN_E::PKO_DWPBUF_DATA_VAL_ERR. */
 	uint64_t reserved_30_31               : 2;
-	uint64_t qcmd_iobx_err_sts            : 4;  /**< When PKO_PDM_STS[QCMD_IOBX_ERR] is set, the queue command response's status field
-                                                         for the response causing the error. Note that if multiple errors occur only the first
-                                                         error status will be captured here until PKO_PDM_STS[QCMD_IOBX_ERR] is cleared.
-                                                         Enumerated by PKO_DQSTATUS_E. */
-	uint64_t qcmd_iobx_err                : 1;  /**< Queue command IOBDMA/IOBLD error status occured in PKO/PDM. PKO_PDM_STS[QCMD_IOBX_ERR_STS]
-                                                         contains the status code.
-                                                         Note that this bit and interrupt will not go off for the FPA being out of
-                                                         pointers (PKO_FPA_NO_PTRS is bit 4 in this CSR).
-                                                         Throws PKO_INTSN_E::PKO_QCMD_IOBX_ERR. */
-	uint64_t sendpkt_lmtdma_err_sts       : 4;  /**< This is the status field of the command response on the LMTDMA failure indicated by
-                                                         PKO_PDM_STS[SENDPKT_LMTDMA_ERR] bits being asserted.
-                                                         Note that if multiple errors occur only the first error status will be captured here until
-                                                         PKO_PDM_STS[SENDPKT_LMTDMA_ERR] is cleared.
+	uint64_t qcmd_iobx_err_sts            : 4;  /**< When PKO_PDM_STS[QCMD_IOBX_ERR] is set, this contains the queue command response's status
+                                                         field for the response causing the error. Note that if multiple errors occur, only the
+                                                         first error status is captured here until PKO_PDM_STS[QCMD_IOBX_ERR] is cleared.
                                                          Enumerated by PKO_DQSTATUS_E. */
-	uint64_t sendpkt_lmtdma_err           : 1;  /**< Send-packet of type LMTDMA error status occured in PKO/PDM.
-                                                         PKO_PDM_STS[SENDPKT_LMTDMA_ERR_STS] contains the status code.
-                                                         Note that this bit and interrupt will not go off for the FPA being out of
-                                                         pointers (PKO_FPA_NO_PTRS is bit 4 in this CSR).
-                                                         Throws PKO_INTSN_E::PKO_SENDPKT_LMTDMA_ERR. */
-	uint64_t sendpkt_lmtst_err_sts        : 4;  /**< This is the status field of the command response on the LMTST failure indicated by
+	uint64_t qcmd_iobx_err                : 1;  /**< Queue command IOBDMA/IOBLD error status occurred in PKO/PDM.
+                                                         PKO_PDM_STS[QCMD_IOBX_ERR_STS] contains the status code. Note that FPA being out of
+                                                         pointers does not set this bit. (See PKO_FPA_NO_PTRS). Throws
+                                                         PKO_INTSN_E::PKO_QCMD_IOBX_ERR. */
+	uint64_t sendpkt_lmtdma_err_sts       : 4;  /**< Status field of the command response on the LMTDMA failure indicated by
+                                                         PKO_PDM_STS[SENDPKT_LMTDMA_ERR] bits being asserted. Note that if multiple errors occur,
+                                                         only the first error status is captured here until PKO_PDM_STS[SENDPKT_LMTDMA_ERR] is
+                                                         cleared. Enumerated by PKO_DQSTATUS_E. */
+	uint64_t sendpkt_lmtdma_err           : 1;  /**< Send-packet of type LMTDMA error status occurred in PKO/PDM.
+                                                         PKO_PDM_STS[SENDPKT_LMTDMA_ERR_STS] contains the status code. Note that FPA being out of
+                                                         pointers does not set this bit. (See PKO_FPA_NO_PTRS). Throws
+                                                         PKO_INTSN_E::PKO_SENDPKT_LMTDMA_ERR. */
+	uint64_t sendpkt_lmtst_err_sts        : 4;  /**< Status field of the command response on the LMTST failure indicated by
                                                          PKO_PDM_STS[SENDPKT_LMTST_ERR] bits being asserted.
                                                          Note that if multiple errors occur only the first error status will be captured here until
                                                          PKO_PDM_STS[SENDPKT_LMTST_ERR] is cleared.
                                                          Enumerated by PKO_DQSTATUS_E. */
-	uint64_t sendpkt_lmtst_err            : 1;  /**< Send-packet of type LMTST error status occured in PKO/PDM.
-                                                         PKO_PDM_STS[SENDPKT_LMTST_ERR_STS] contains the status code.
-                                                         Note that this bit and interrupt will not go off for the FPA being out of
-                                                         pointers (PKO_FPA_NO_PTRS is bit 4 in this CSR).
-                                                         Throws PKO_INTSN_E::PKO_SENDPKT_LMTST_ERR. */
+	uint64_t sendpkt_lmtst_err            : 1;  /**< Send-packet of type LMTST error status occurred in PKO/PDM.
+                                                         PKO_PDM_STS[SENDPKT_LMTST_ERR_STS] contains the status code. Note that FPA being out of
+                                                         pointers does not set this bit. (See PKO_FPA_NO_PTRS). Throws
+                                                         PKO_INTSN_E::PKO_SENDPKT_LMTST_ERR. */
 	uint64_t fpa_no_ptrs                  : 1;  /**< FPA signalled PKO that FPA can not allocate pointers. This is a fatal error.
                                                          Throws PKO_INTSN_E::PKO_FPA_NO_PTRS. */
 	uint64_t reserved_12_13               : 2;
 	uint64_t cp_sendpkt_err_no_drp_code   : 2;  /**< This field stores the error code for illegally constructed send-packets that did not drop.
-                                                         Note that if multiple errors occur only the first error code will be captured here until
-                                                         PKO_PDM_STS[CP_SENDPKT_ERR_NO_DRP] is cleared.
-                                                         Codes:
-                                                           2'b00: NO ERROR CODE
-                                                           2'b01: SEND_JUMP not at end of descriptor. */
-	uint64_t cp_sendpkt_err_no_drp        : 1;  /**< PKO/PDM/CP did not drop a send-packet, but it violates rules below.
-                                                         1) SEND_JUMP not at end of descriptor.
-                                                         The error code is captured in PKO_PDM_STS[CP_SENDPKT_ERR_NO_DRP_CODE].
-                                                         Throws PKO_INTSN_E::PKO_CP_SENDPKT_ERR_NO_DRP. */
+                                                         Note that if multiple errors occur, only the first error code is captured here until
+                                                         PKO_PDM_STS[CP_SENDPKT_ERR_NO_DRP] is cleared. Codes:
+                                                         2'b00: NO ERROR CODE
+                                                         2'b01: SEND_JUMP not at end of descriptor. */
+	uint64_t cp_sendpkt_err_no_drp        : 1;  /**< PKO/PDM/CP did not drop a send-packet; however, the SEND_JUMP command is not at end of the
+                                                         descriptor. The error code is captured in PKO_PDM_STS[CP_SENDPKT_ERR_NO_DRP_CODE]. Throws
+                                                         PKO_INTSN_E::PKO_CP_SENDPKT_ERR_NO_DRP. */
 	uint64_t reserved_7_8                 : 2;
-	uint64_t cp_sendpkt_err_drop_code     : 3;  /**< This field stores the error code for illegally constructed send-packet drops.
-                                                         Note that if multiple errors occur only the first error code will be captured here until
-                                                         PKO_PDM_STS[CP_SENDPKT_ERR_DROP] is cleared.
-                                                         PKO_CPSENDDROP_E enumerates the codes and conditions. */
-	uint64_t cp_sendpkt_err_drop          : 1;  /**< Dropped a send-packet in PDM/CP due to rule violation.
-                                                         The error code is captured in PKO_PDM_STS[CP_SENDPKT_ERR_DROP_CODE].
-                                                         Throws PKO_INTSN_E::PKO_CP_SENDPKT_ERR_DROP. */
+	uint64_t cp_sendpkt_err_drop_code     : 3;  /**< This field stores the error code for illegally constructed send-packet drops. Note that if
+                                                         multiple errors occur, only the first error code is captured here until
+                                                         PKO_PDM_STS[CP_SENDPKT_ERR_DROP] is cleared. PKO_CPSENDDROP_E enumerates the codes and
+                                                         conditions. */
+	uint64_t cp_sendpkt_err_drop          : 1;  /**< Dropped a send-packet in PDM/CP due to a rule violation. The error code is captured in
+                                                         PKO_PDM_STS[CP_SENDPKT_ERR_DROP_CODE]. Throws PKO_INTSN_E::PKO_CP_SENDPKT_ERR_DROP. */
 	uint64_t reserved_1_2                 : 2;
-	uint64_t desc_crc_err                 : 1;  /**< CRC error occurred in a descriptor. (State may have been corrupted).
-                                                         INTERNAL: Note that this is a pass 2 feature.
-                                                         Throws PKO_INTSN_E::PKO_DESC_CRC_ERR. */
+	uint64_t desc_crc_err                 : 1;  /**< CRC error occurred in a descriptor. (State may have been corrupted.) INTERNAL: Note that
+                                                         this is a pass 2 feature. Throws PKO_INTSN_E::PKO_DESC_CRC_ERR. */
 #else
 	uint64_t desc_crc_err                 : 1;
 	uint64_t reserved_1_2                 : 2;
@@ -9176,6 +9296,9 @@ typedef union cvmx_pko_pdm_sts cvmx_pko_pdm_sts_t;
 
 /**
  * cvmx_pko_peb_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_peb_bist_status {
 	uint64_t u64;
@@ -9207,7 +9330,7 @@ union cvmx_pko_peb_bist_status {
 	uint64_t send_mem_fifo                : 1;  /**< SEND_MEM_FIFO RAM BIST status. */
 	uint64_t pkt_mrk_ram                  : 1;  /**< PKT_MRK RAM BIST status. */
 	uint64_t peb_st_inf_ram               : 1;  /**< PEB_ST_INF RAM BIST status. */
-	uint64_t peb_sm_jmp_ram               : 1;  /**< PEB_SM_JMP RAM BIST status. 0 = BIST passed; 1 = BIST failed. */
+	uint64_t peb_sm_jmp_ram               : 1;  /**< PEB_SM_JMP RAM BIST status. */
 #else
 	uint64_t peb_sm_jmp_ram               : 1;
 	uint64_t peb_st_inf_ram               : 1;
@@ -9474,8 +9597,8 @@ union cvmx_pko_peb_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t peb_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PEB_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PEB_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PEB_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PEB_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i
@@ -9622,8 +9745,8 @@ union cvmx_pko_peb_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t peb_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PEB_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PEB_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PEB_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PEB_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i
@@ -9666,8 +9789,8 @@ union cvmx_pko_peb_err_int {
 	struct cvmx_pko_peb_err_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t peb_macx_cfg_wr_err          : 1;  /**< Asserted when SW writes a FIFO number to PKO_MACx_CFG when that FIFO is already assigned.
-                                                         Throws PKO_INTSN_E::PEB_MACX_CFG_WR_ERR. */
+	uint64_t peb_macx_cfg_wr_err          : 1;  /**< Asserted when software writes a FIFO number to PKO_MACx_CFG when that FIFO is already
+                                                         assigned. Throws PKO_INTSN_E::PEB_MACX_CFG_WR_ERR. */
 	uint64_t peb_max_link_err             : 1;  /**< Asserted when 200 LINK segments have been followed.  Indicates likelihood of infinite
                                                          loop.  Throws PKO_INTSN_E::PEB_MAX_LINK_ERR. */
 	uint64_t peb_subd_size_err            : 1;  /**< Asserted when a SEND_LINK/GATHER/IMM/JUMP subD has size=0.  Throws
@@ -9677,11 +9800,11 @@ union cvmx_pko_peb_err_int {
 	uint64_t peb_trunc_err                : 1;  /**< Asserted when a PD has truncated data.  Throws PKO_INTSN_E::PEB_TRUNC_ERR. */
 	uint64_t peb_pad_err                  : 1;  /**< Asserted when a PD has data padded to it (SEND_HDR[TOTAL] < sum(SEND_DATA[size])).  Throws
                                                          PKO_INTSN_E::PEB_PAD_ERR. */
-	uint64_t peb_pse_fifo_err             : 1;  /**< Asserted when PSE sends PD information for a non-configured FIFO.  Throws
+	uint64_t peb_pse_fifo_err             : 1;  /**< Asserted when PSE sends PD information for a nonconfigured FIFO. Throws
                                                          PKO_INTSN_E::PEB_PSE_FIFO_ERR. */
 	uint64_t peb_fcs_sop_err              : 1;  /**< Asserted when FCS SOP value greater than packet size detected.  Throws
                                                          PKO_INTSN_E::PEB_FCS_SOP_ERR. */
-	uint64_t peb_jump_def_err             : 1;  /**< Asserted when JUMP sub-descriptor is not last in a PD.  Throws
+	uint64_t peb_jump_def_err             : 1;  /**< Asserted when JUMP subdescriptor is not last in a PD. Throws
                                                          PKO_INTSN_E::PEB_JUMP_DEF_ERR. */
 	uint64_t peb_ext_hdr_def_err          : 1;  /**< Asserted when EXT_HDR is not the second sub-descriptor in a PD.  Throws
                                                          PKO_INTSN_E::PEB_EXT_HDR_DEF_ERR. */
@@ -9711,9 +9834,9 @@ union cvmx_pko_peb_ext_hdr_def_err_info {
 	struct cvmx_pko_peb_ext_hdr_def_err_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
-	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_EXT_HDR_DEF_ERR] is set */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_EXT_HDR_DEF_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_EXT_HDR_DEF_ERR */
+	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_EXT_HDR_DEF_ERR] is set. */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_EXT_HDR_DEF_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_EXT_HDR_DEF_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -9734,8 +9857,8 @@ union cvmx_pko_peb_fcs_sop_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_FCS_SOP_ERR] is set. */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_FCS_SOP_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_FCS_SOP_ERR */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_FCS_SOP_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_FCS_SOP_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -9756,8 +9879,8 @@ union cvmx_pko_peb_jump_def_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_JUMP_DEF_ERR] is set. */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_JUMP_DEF_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_JUMP_DEF_ERR */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_JUMP_DEF_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_JUMP_DEF_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -9778,7 +9901,7 @@ union cvmx_pko_peb_macx_cfg_wr_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_MACX_CFG_WR_ERR] is set. */
-	uint64_t mac                          : 7;  /**< MAC number associated with the captured PEB_MACX_CFG_WR_ERR */
+	uint64_t mac                          : 7;  /**< MAC number associated with the captured PEB_MACX_CFG_WR_ERR. */
 #else
 	uint64_t mac                          : 7;
 	uint64_t val                          : 1;
@@ -9798,8 +9921,8 @@ union cvmx_pko_peb_max_link_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_MAX_LINK_ERR] is set. */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_MAX_LINK_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_MAX_LINK_ERR */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_MAX_LINK_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_MAX_LINK_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -9820,8 +9943,8 @@ union cvmx_pko_peb_pad_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_PAD_ERR] is set. */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_PAD_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_PAD_ERR */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_PAD_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_PAD_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -9842,8 +9965,8 @@ union cvmx_pko_peb_pse_fifo_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_PSE_FIFO_ERR] is set. */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_PSE_FIFO_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_PSE_FIFO_ERR */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_PSE_FIFO_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_PSE_FIFO_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -9864,8 +9987,8 @@ union cvmx_pko_peb_subd_addr_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_SUBD_ADDR_ERR] is set. */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_SUBD_ADDR_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_SUBD_ADDR_ERR */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_SUBD_ADDR_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_SUBD_ADDR_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -9886,8 +10009,8 @@ union cvmx_pko_peb_subd_size_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_SUBD_SIZE_ERR] is set. */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_SUBD_SIZE_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_SUBD_SIZE_ERR */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_SUBD_SIZE_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_SUBD_SIZE_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -9908,8 +10031,8 @@ union cvmx_pko_peb_trunc_err_info {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_TRUNC_ERR] is set. */
-	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_TRUNC_ERR */
-	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_TRUNC_ERR */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_TRUNC_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_TRUNC_ERR. */
 #else
 	uint64_t chan                         : 12;
 	uint64_t fifo                         : 7;
@@ -10009,21 +10132,24 @@ typedef union cvmx_pko_pqb_debug cvmx_pko_pqb_debug_t;
 
 /**
  * cvmx_pko_pse_dq_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_pse_dq_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
-	uint64_t wt_sram                      : 1;  /**< Work Table */
-	uint64_t rt7_sram                     : 1;  /**< Result Table 7 - DQ FIFO[1023:896] */
-	uint64_t rt6_sram                     : 1;  /**< Result Table 6 - DQ FIFO[895:768] */
-	uint64_t rt5_sram                     : 1;  /**< Result Table 5 - DQ FIFO[767:640] */
-	uint64_t rt4_sram                     : 1;  /**< Result Table 4 - DQ FIFO[639:512] */
-	uint64_t rt3_sram                     : 1;  /**< Result Table 3 - DQ FIFO[511:384] */
-	uint64_t rt2_sram                     : 1;  /**< Result Table 2 - DQ FIFO[383:256] */
-	uint64_t rt1_sram                     : 1;  /**< Result Table 1 - DQ FIFO[255:128] */
-	uint64_t rt0_sram                     : 1;  /**< Result Table 0 - DQ FIFO[127:0] */
+	uint64_t wt_sram                      : 1;  /**< Work table. */
+	uint64_t rt7_sram                     : 1;  /**< Result table 7 - DQ FIFO[1023:896]. */
+	uint64_t rt6_sram                     : 1;  /**< Result table 6 - DQ FIFO[895:768]. */
+	uint64_t rt5_sram                     : 1;  /**< Result table 5 - DQ FIFO[767:640]. */
+	uint64_t rt4_sram                     : 1;  /**< Result table 4 - DQ FIFO[639:512]. */
+	uint64_t rt3_sram                     : 1;  /**< Result table 3 - DQ FIFO[511:384]. */
+	uint64_t rt2_sram                     : 1;  /**< Result table 2 - DQ FIFO[383:256]. */
+	uint64_t rt1_sram                     : 1;  /**< Result table 1 - DQ FIFO[255:128]. */
+	uint64_t rt0_sram                     : 1;  /**< Result table 0 - DQ FIFO[127:0]. */
 #else
 	uint64_t rt0_sram                     : 1;
 	uint64_t rt1_sram                     : 1;
@@ -10153,8 +10279,8 @@ union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_dq_dbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_DQ_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_DQ_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_DQ_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_DQ_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_dq.wt_sram
@@ -10236,8 +10362,8 @@ union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_dq_sbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_DQ_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_DQ_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_DQ_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_DQ_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_dq.wt_sram
@@ -10261,27 +10387,30 @@ typedef union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_
 
 /**
  * cvmx_pko_pse_pq_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_pse_pq_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_pq_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t tp_sram                      : 1;  /**< Topology Parent - pko_pse_pq_srf32x5e */
-	uint64_t irq_fifo_sram                : 1;  /**< Interrupt Message FIFO - pko_pse_pq_srf1024x10e */
-	uint64_t wmd_sram                     : 1;  /**< Dynamic Watermark State - pko_pse_wmd_srf1024x49e */
-	uint64_t wms_sram                     : 1;  /**< Static Watermark Configuration - pko_pse_wms_srf1024x50e */
-	uint64_t cxd_sram                     : 1;  /**< Dynamic Channel State - pko_pse_cxd_srf32x31e */
-	uint64_t dqd_sram                     : 1;  /**< DQ Dropped Stats - pko_pse_stats_srf1024x88 */
-	uint64_t dqs_sram                     : 1;  /**< DQ Sent Stats - pko_pse_stats_srf1024x88 */
-	uint64_t pqd_sram                     : 1;  /**< PQ Dropped Stats - pko_pse_stats_srf32x88 */
-	uint64_t pqr_sram                     : 1;  /**< PQ Read Stats - pko_pse_stats_srf32x88 */
-	uint64_t pqy_sram                     : 1;  /**< PQ Yellow Stats - pko_pse_stats_srf32x88 */
-	uint64_t pqg_sram                     : 1;  /**< PQ Green Stats - pko_pse_stats_srf32x88 */
-	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State - pko_pse_std_srf32x105e */
-	uint64_t st_sram                      : 1;  /**< Static Shaping Configuration - pko_pse_sts_srf32x74e */
+	uint64_t tp_sram                      : 1;  /**< Topology parent - pko_pse_pq_srf32x5e */
+	uint64_t irq_fifo_sram                : 1;  /**< Interrupt message FIFO - pko_pse_pq_srf1024x10e */
+	uint64_t wmd_sram                     : 1;  /**< Dynamic watermark state - pko_pse_wmd_srf1024x49e */
+	uint64_t wms_sram                     : 1;  /**< Static watermark configuration - pko_pse_wms_srf1024x50e */
+	uint64_t cxd_sram                     : 1;  /**< Dynamic channel state - pko_pse_cxd_srf32x31e */
+	uint64_t dqd_sram                     : 1;  /**< DQ dropped stats - pko_pse_stats_srf1024x88 */
+	uint64_t dqs_sram                     : 1;  /**< DQ sent stats - pko_pse_stats_srf1024x88 */
+	uint64_t pqd_sram                     : 1;  /**< PQ dropped stats - pko_pse_stats_srf32x88 */
+	uint64_t pqr_sram                     : 1;  /**< PQ read stats - pko_pse_stats_srf32x88 */
+	uint64_t pqy_sram                     : 1;  /**< PQ yellow stats - pko_pse_stats_srf32x88 */
+	uint64_t pqg_sram                     : 1;  /**< PQ green stats - pko_pse_stats_srf32x88 */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state - pko_pse_std_srf32x105e */
+	uint64_t st_sram                      : 1;  /**< Static shaping configuration - pko_pse_sts_srf32x74e */
 	uint64_t reserved_1_1                 : 1;
-	uint64_t cxs_sram                     : 1;  /**< Static Channel Credit Configuration - pko_pse_cx0_srf32x6e */
+	uint64_t cxs_sram                     : 1;  /**< Static channel credit configuration - pko_pse_cx0_srf32x6e */
 #else
 	uint64_t cxs_sram                     : 1;
 	uint64_t reserved_1_1                 : 1;
@@ -10409,8 +10538,8 @@ union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_pq_dbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_PQ_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_PQ_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_PQ_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_PQ_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram
@@ -10487,8 +10616,8 @@ union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_pq_sbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_PQ_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_PQ_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_PQ_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_PQ_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram
@@ -10511,33 +10640,36 @@ typedef union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_
 
 /**
  * cvmx_pko_pse_sq1_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_pse_sq1_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq1_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t sc_sram                      : 1;  /**< SQ[5:1] Scheduling Configuration */
+	uint64_t sc_sram                      : 1;  /**< SQ[5:1] scheduling configuration */
 	uint64_t pc_sram                      : 1;  /**< SQ[1] physical channel - pko_pse_pc_srf32x12e */
 	uint64_t xon_sram                     : 1;  /**< XON SRAM */
-	uint64_t cc_sram                      : 1;  /**< SQ[1] Channel Credit OK State Array */
+	uint64_t cc_sram                      : 1;  /**< SQ[1] channel credit OK state array */
 	uint64_t vc1_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
 	uint64_t vc0_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
 	uint64_t reserved_21_22               : 2;
-	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
-	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
 	uint64_t xo_sram                      : 1;  /**< XOFF SRAM */
-	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t rt_sram                      : 1;  /**< Result table */
 	uint64_t reserved_9_16                : 8;
-	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
-	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
-	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
-	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
-	uint64_t cxd_sram                     : 1;  /**< SQ[1] Dynamic Channel Credit State */
-	uint64_t cxs_sram                     : 1;  /**< SQ[1] Static Channel Credit Configuration */
-	uint64_t nt_sram                      : 1;  /**< SQ[5:1] "Next" Pointer Table */
-	uint64_t pt_sram                      : 1;  /**< SQ[5:1] "Previous" Pointer Table */
-	uint64_t wt_sram                      : 1;  /**< SQ[5:1] Work Table */
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM */
+	uint64_t cxd_sram                     : 1;  /**< SQ[1] dynamic channel credit state */
+	uint64_t cxs_sram                     : 1;  /**< SQ[1] static channel credit configuration */
+	uint64_t nt_sram                      : 1;  /**< SQ[5:1] next pointer table */
+	uint64_t pt_sram                      : 1;  /**< SQ[5:1] previous pointer table */
+	uint64_t wt_sram                      : 1;  /**< SQ[5:1] work table */
 #else
 	uint64_t wt_sram                      : 1;
 	uint64_t pt_sram                      : 1;
@@ -10751,8 +10883,8 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq1_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ1_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ1_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ1_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ1_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxs_sram
@@ -10879,8 +11011,8 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq1_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ1_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ1_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ1_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ1_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxs_sram
@@ -10913,27 +11045,30 @@ typedef union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq1_ecc_sbe_sts_cmb
 
 /**
  * cvmx_pko_pse_sq2_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_pse_sq2_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq2_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t sc_sram                      : 1;  /**< Scheduling Configuration */
+	uint64_t sc_sram                      : 1;  /**< Scheduling configuration. */
 	uint64_t reserved_21_27               : 7;
-	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
-	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] topology parent configuration. */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration. */
 	uint64_t reserved_18_18               : 1;
-	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t rt_sram                      : 1;  /**< Result table. */
 	uint64_t reserved_9_16                : 8;
-	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
-	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
-	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
-	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 1 command FIFO SRAM. */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration. */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM. */
 	uint64_t reserved_3_4                 : 2;
-	uint64_t nt_sram                      : 1;  /**< Next Pointer Table */
-	uint64_t pt_sram                      : 1;  /**< Previous Pointer Table */
-	uint64_t wt_sram                      : 1;  /**< Work Table */
+	uint64_t nt_sram                      : 1;  /**< Next pointer table. */
+	uint64_t pt_sram                      : 1;  /**< Previous pointer table. */
+	uint64_t wt_sram                      : 1;  /**< Work table. */
 #else
 	uint64_t wt_sram                      : 1;
 	uint64_t pt_sram                      : 1;
@@ -11101,8 +11236,8 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq2_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ2_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ2_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ2_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ2_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.sq1.nt_sram
@@ -11204,8 +11339,8 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq2_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ2_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ2_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ2_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ2_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.sq1.nt_sram
@@ -11233,33 +11368,36 @@ typedef union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq2_ecc_sbe_sts_cmb
 
 /**
  * cvmx_pko_pse_sq3_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_pse_sq3_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq3_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t sc_sram                      : 1;  /**< Scheduling Configuration */
+	uint64_t sc_sram                      : 1;  /**< Scheduling configuration */
 	uint64_t reserved_23_27               : 5;
-	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
-	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
-	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
-	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] topology parent configuration */
+	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] topology parent configuration */
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
 	uint64_t reserved_18_18               : 1;
-	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t rt_sram                      : 1;  /**< Result table */
 	uint64_t reserved_15_16               : 2;
-	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 3 command FIFO SRAM */
+	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] time wheel 3 command FIFO SRAM */
 	uint64_t reserved_12_13               : 2;
-	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 2 command FIFO SRAM */
+	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] time wheel 2 command FIFO SRAM */
 	uint64_t reserved_9_10                : 2;
-	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
-	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
-	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
-	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM */
 	uint64_t reserved_3_4                 : 2;
-	uint64_t nt_sram                      : 1;  /**< Next Pointer Table */
-	uint64_t pt_sram                      : 1;  /**< Previous Pointer Table */
-	uint64_t wt_sram                      : 1;  /**< Work Table */
+	uint64_t nt_sram                      : 1;  /**< Next pointer table */
+	uint64_t pt_sram                      : 1;  /**< Previous pointer table */
+	uint64_t wt_sram                      : 1;  /**< Work table */
 #else
 	uint64_t wt_sram                      : 1;
 	uint64_t pt_sram                      : 1;
@@ -11497,8 +11635,8 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq3_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ3_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ3_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ3_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ3_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram
@@ -11640,8 +11778,8 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq3_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ3_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ3_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ3_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ3_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram
@@ -11677,33 +11815,36 @@ typedef union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq3_ecc_sbe_sts_cmb
 
 /**
  * cvmx_pko_pse_sq4_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_pse_sq4_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq4_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t sc_sram                      : 1;  /**< Scheduling Configuration */
+	uint64_t sc_sram                      : 1;  /**< Scheduling configuration */
 	uint64_t reserved_23_27               : 5;
-	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
-	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
-	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
-	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] topology parent configuration */
+	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] topology parent configuration */
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
 	uint64_t reserved_18_18               : 1;
 	uint64_t rt_sram                      : 1;  /**< Result Table */
 	uint64_t reserved_15_16               : 2;
-	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 3 command FIFO SRAM */
+	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] time wheel 3 command FIFO SRAM */
 	uint64_t reserved_12_13               : 2;
-	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 2 command FIFO SRAM */
+	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] time wheel 2 command FIFO SRAM. */
 	uint64_t reserved_9_10                : 2;
-	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
-	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
-	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
-	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 1 command FIFO SRAM. */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state. */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration. */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM. */
 	uint64_t reserved_3_4                 : 2;
-	uint64_t nt_sram                      : 1;  /**< Next Pointer Table */
-	uint64_t pt_sram                      : 1;  /**< Previous Pointer Table */
-	uint64_t wt_sram                      : 1;  /**< Work Table */
+	uint64_t nt_sram                      : 1;  /**< Next pointer table. */
+	uint64_t pt_sram                      : 1;  /**< Previous pointer table. */
+	uint64_t wt_sram                      : 1;  /**< Work table. */
 #else
 	uint64_t wt_sram                      : 1;
 	uint64_t pt_sram                      : 1;
@@ -11941,8 +12082,8 @@ union cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq4_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ4_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ4_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ4_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ4_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram
@@ -12084,8 +12225,8 @@ union cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq4_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ4_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ4_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ4_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ4_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram
@@ -12121,33 +12262,36 @@ typedef union cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq4_ecc_sbe_sts_cmb
 
 /**
  * cvmx_pko_pse_sq5_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
  */
 union cvmx_pko_pse_sq5_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq5_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t sc_sram                      : 1;  /**< Scheduling Configuration */
+	uint64_t sc_sram                      : 1;  /**< Scheduling configuration. */
 	uint64_t reserved_23_27               : 5;
-	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
-	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
-	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
-	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] topology parent configuration. */
+	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] topology parent configuration. */
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] topology parent configuration. */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration. */
 	uint64_t reserved_18_18               : 1;
-	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t rt_sram                      : 1;  /**< Result table. */
 	uint64_t reserved_15_16               : 2;
-	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 3 command FIFO SRAM */
+	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] time wheel 3 command FIFO SRAM. */
 	uint64_t reserved_12_13               : 2;
-	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 2 command FIFO SRAM */
+	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] time wheel 2 command FIFO SRAM. */
 	uint64_t reserved_9_10                : 2;
-	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
-	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
-	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
-	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 1 command FIFO SRAM. */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state. */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration. */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM. */
 	uint64_t reserved_3_4                 : 2;
-	uint64_t nt_sram                      : 1;  /**< Next Pointer Table */
-	uint64_t pt_sram                      : 1;  /**< Previous Pointer Table */
-	uint64_t wt_sram                      : 1;  /**< Work Table */
+	uint64_t nt_sram                      : 1;  /**< Next pointer table. */
+	uint64_t pt_sram                      : 1;  /**< Previous pointer table. */
+	uint64_t wt_sram                      : 1;  /**< Work table. */
 #else
 	uint64_t wt_sram                      : 1;
 	uint64_t pt_sram                      : 1;
@@ -12385,8 +12529,8 @@ union cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq5_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ5_ECC_DBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ5_ECC_DBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ5_ECC_DBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ5_DBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram
@@ -12528,8 +12672,8 @@ union cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0 {
 	struct cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t pse_sq5_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ5_ECC_SBE_STS.
-                                                         To clear this bit, must clear bits in PKO_PSE_SQ5_ECC_SBE_STS.
-                                                         When this bit is set the corresponding interrupt is set.
+                                                         To clear this bit, software must clear bits in PKO_PSE_SQ5_ECC_SBE_STS.
+                                                         When this bit is set, the corresponding interrupt is set.
                                                          Throws PKO_INTSN_E::PKO_PSE_SQ5_SBE_CMB0.
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram
@@ -12571,12 +12715,12 @@ union cvmx_pko_ptfx_status {
 	struct cvmx_pko_ptfx_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
-	uint64_t total_in_flight_cnt          : 8;  /**< This field returns the total number of packets currently in-flight within PEB.  Useful
-                                                         both for reconfiguration (able to disable a FIFO when it is empty) and debugging */
-	uint64_t in_flight_cnt                : 7;  /**< This field returns the number of packets currently in-flight within PEB for this link.
-                                                         Useful both for reconfiguration (able to disable a FIFO when it is empty) and debugging */
-	uint64_t mac_num                      : 5;  /**< The MAC assigned to the given PKO TX FIFO. A value of 0x1F means unassigned. These
-                                                         registers values are derived automatically by the hardware from the
+	uint64_t total_in_flight_cnt          : 8;  /**< Total number of packets currently in-flight within PEB.  Useful
+                                                         both for reconfiguration (able to disable a FIFO when it is empty) and debugging. */
+	uint64_t in_flight_cnt                : 7;  /**< Number of packets currently in-flight within PEB for this link.
+                                                         Useful both for reconfiguration (able to disable a FIFO when it is empty) and debugging. */
+	uint64_t mac_num                      : 5;  /**< MAC assigned to the given PKO TX FIFO. A value of 0x1F means unassigned. These
+                                                         register values are derived automatically by the hardware from the
                                                          PKO_MAC(0..27)_CFG[FIFO_NUM] settings. */
 #else
 	uint64_t mac_num                      : 5;
@@ -12622,13 +12766,13 @@ union cvmx_pko_ptgfx_cfg {
 	struct cvmx_pko_ptgfx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t reset                        : 1;  /**< This bit will reset the address pointers for the FIFOs in this group.  This should
-                                                         only be performed when a PTGF is empty and the SIZE field is to be being changed. */
-	uint64_t rate                         : 3;  /**< Each PTGF can support up to 100Gbs. The total aggregate rate across all FIFOs
-                                                         (including the NULL) should NEVER exceed 250Gbs.
-                                                         This field represents the rate for each active FIFO in PEB, thus the calculation
-                                                         for throughput is a function of the SIZE field below and if the FIFO is assigned
-                                                         to a MAC in PKO_MACx_CFG.
+	uint64_t reset                        : 1;  /**< This bit resets the address pointers for the FIFOs in this group. This should only be
+                                                         performed when a PTGF is empty and the SIZE field is to be being changed. */
+	uint64_t rate                         : 3;  /**< Each PTGF can support up to 100Gbs. The total aggregate rate across all FIFOs (including
+                                                         the NULL) should never exceed 250Gbs.
+                                                         This field represents the rate for each active FIFO in PEB; thus the calculation for
+                                                         throughput is a function of the SIZE field and whether or not the FIFO is assigned to a
+                                                         MAC in PKO_MACx_CFG.
                                                          RATE: Throughput
                                                          ----------------
                                                          - 000:    6.25Gbs
@@ -12637,9 +12781,9 @@ union cvmx_pko_ptgfx_cfg {
                                                          - 011:   50   Gbs
                                                          - 100:  100   Gbs
                                                          Note: 101-111 are illegal RATE values and should not be used. */
-	uint64_t size                         : 3;  /**< "The PKO supports up to 29 independent TX FIFOs where 0-27 are physical and 28 is
-                                                         virtual. The FIFOs are grouped into 8 sets of four contiguously numbered queues
-                                                         where each FIFO has a base storage amount of 2.5K bytes of buffering.
+	uint64_t size                         : 3;  /**< "PKO supports up to 29 independent TX FIFOs where 0-27 are physical and 28 is virtual. The
+                                                         FIFOs are grouped into 8 sets of four contiguously numbered queues where each FIFO has a
+                                                         base storage amount of 2.5K bytes of buffering.
                                                          PKO_PTGF(0)_CFG -> FIFO#  0-3
                                                          PKO_PTGF(1)_CFG -> FIFO#  4-7
                                                          PKO_PTGF(2)_CFG -> FIFO#  8-11
@@ -12660,19 +12804,17 @@ union cvmx_pko_ptgfx_cfg {
                                                          011 :     5.0k    0.0k    5.0k    0.0k
                                                          100 :    10.0k    0.0k    0.0k    0.0k
                                                          Note: 101-111 are illegal SIZE values and should not be used.
-                                                         Note that when a FIFO is set to a size of 0K bytes that FIFO_NUM is no longer legal and
-                                                         cannot be assigned to an active MAC. For example, for the set of FIFOs 8-11, if the
-                                                         PKO_PTGF(2)_CFG.SIZE = 3'b100 then FIFO_NUMs 9, 10 and 11 are no longer valid. Only
-                                                         FIFO_NUM = 8 is available from this set for assignment to a MAC because all of the
-                                                         10 Kbytes of buffering was configured to FIFO#8.
+                                                         Note that when a FIFO is set to a size of 0K bytes, FIFO_NUM is no longer legal and cannot
+                                                         be assigned to an active MAC. For example, for the set of FIFOs 8-11, if the
+                                                         PKO_PTGF(2)_CFG[SIZE] = 3'b100, then FIFO_NUMs 9, 10 and 11 are no longer valid. Only
+                                                         FIFO_NUM = 8 is available from this set for assignment to a MAC because all of the 10
+                                                         Kbytes of buffering was configured to FIFO#8.
                                                          FIFO_NUM = 28 is a virtual FIFO and is used exclusively to indicate the NULL FIFO. Packets
-                                                         targeting the NULL FIFO are dropped by the PKO and their buffers returned to the FPA. The
-                                                         SIZE field for PKO_PTGF(7) should always be set to zero"
-                                                         Modifications to this field require two writes.  The first write must assert
-                                                         PKO_PTGFx_CFG[RESET]
-                                                         to reset the address pointers for the FIFOS in this group.  The second write clears the
-                                                         RESET
-                                                         bit as well as configures the new SIZE values." */
+                                                         targeting the NULL FIFO are dropped by PKO and their buffers returned to the FPA. The SIZE
+                                                         field for PKO_PTGF(7) should always be set to zero.
+                                                         Modifications to this field require two writes. The first write must assert
+                                                         PKO_PTGFx_CFG[RESET] to reset the address pointers for the FIFOS in this group. The second
+                                                         write clears the RESET bit as well as configures the new SIZE values." */
 #else
 	uint64_t size                         : 3;
 	uint64_t rate                         : 3;
@@ -14331,8 +14473,7 @@ union cvmx_pko_status {
 	uint64_t csi_rdy                      : 1;  /**< PKO CSI block ready for configuration. */
 	uint64_t reserved_5_15                : 11;
 	uint64_t ncb_bist_status              : 1;  /**< PKO NCB block BIST status. 0 = BIST passed; 1 = BIST failed. */
-	uint64_t c2qlut_bist_status           : 1;  /**< PKO C2QLUT block BIST status. 0 = BIST passed;
-                                                         1 = BIST failed. */
+	uint64_t c2qlut_bist_status           : 1;  /**< PKO C2QLUT block BIST status. 0 = BIST passed; 1 = BIST failed. */
 	uint64_t pdm_bist_status              : 1;  /**< PKO PDM block BIST status. 0 = BIST passed; 1 = BIST failed. */
 	uint64_t peb_bist_status              : 1;  /**< PKO PEB block BIST status. 0 = BIST passed; 1 = BIST failed. */
 	uint64_t pse_bist_status              : 1;  /**< PKO PSE block BIST status. 0 = BIST passed; 1 = BIST failed. */
diff --git a/arch/mips/include/asm/octeon/cvmx-pow-defs.h b/arch/mips/include/asm/octeon/cvmx-pow-defs.h
index 664c9c6..7617fea 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow-defs.h
@@ -710,22 +710,29 @@ typedef union cvmx_pow_ds_pc cvmx_pow_ds_pc_t;
  *
  * Contains the single and double error bits and the corresponding interrupt enables for the ECC-
  * protected POW index memory.  Also contains the syndrome value in the event of an ECC error.
- * Also contains the remote pointer error bit and interrupt enable.  RPE is set when the POW detected
- * corruption on one or more of the input queue lists in L2/DRAM (POW's local copy of the tail pointer
+ * Also contains the remote pointer error bit and interrupt enable.  RPE is set when the POW
+ * detected
+ * corruption on one or more of the input queue lists in L2/DRAM (POW's local copy of the tail
+ * pointer
  * for the L2/DRAM input queue did not match the last entry on the the list).   This is caused by
- * L2/DRAM corruption, and is generally a fatal error because it likely caused POW to load bad work
+ * L2/DRAM corruption, and is generally a fatal error because it likely caused POW to load bad
+ * work
  * queue entries.
  * This register also contains the illegal operation error bits and the corresponding interrupt
  * enables as follows:
  *  <0> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL_NULL state
  *  <1> Received SWTAG/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL state
- *  <2> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/GET_WORK from PP with pending tag switch to ORDERED or ATOMIC
+ *  <2> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/GET_WORK from PP with pending tag switch to ORDERED
+ * or ATOMIC
  *  <3> Received SWTAG/SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL_NULL
  *  <4> Received SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL
- *  <5> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with GET_WORK pending
- *  <6> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with NULL_RD pending
+ *  <5> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with
+ * GET_WORK pending
+ *  <6> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with NULL_RD
+ * pending
  *  <7> Received CLR_NSCHED from PP with SWTAG_DESCH/DESCH/CLR_NSCHED pending
- *  <8> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with CLR_NSCHED pending
+ *  <8> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with
+ * CLR_NSCHED pending
  *  <9> Received illegal opcode
  * <10> Received ADD_WORK with tag specified as NULL_NULL
  * <11> Received DBG load from PP with DBG load pending
@@ -883,7 +890,8 @@ typedef union cvmx_pow_iq_com_cnt cvmx_pow_iq_com_cnt_t;
 /**
  * cvmx_pow_iq_int
  *
- * "Contains the bits (1 per QOS level) that can trigger the input queue interrupt.  An IQ_INT bit
+ * "Contains the bits (1 per QOS level) that can trigger the input queue interrupt.  An IQ_INT
+ * bit
  * will be set if POW_IQ_CNT#QOS# changes and the resulting value is equal to POW_IQ_THR#QOS#."
  */
 union cvmx_pow_iq_int {
@@ -1043,26 +1051,37 @@ typedef union cvmx_pow_nos_cnt cvmx_pow_nos_cnt_t;
  * cvmx_pow_nw_tim
  *
  * Sets the minimum period for a new work request timeout.  Period is specified in n-1 notation
- * where the increment value is 1024 clock cycles.  Thus, a value of 0x0 in this register translates
- * to 1024 cycles, 0x1 translates to 2048 cycles, 0x2 translates to 3072 cycles, etc...  Note: the
- * maximum period for a new work request timeout is 2 times the minimum period.  Note: the new work
+ * where the increment value is 1024 clock cycles.  Thus, a value of 0x0 in this register
+ * translates
+ * to 1024 cycles, 0x1 translates to 2048 cycles, 0x2 translates to 3072 cycles, etc...  Note:
+ * the
+ * maximum period for a new work request timeout is 2 times the minimum period.  Note: the new
+ * work
  * request timeout counter is reset when this register is written.
  * There are two new work request timeout cases:
  * - WAIT bit clear.  The new work request can timeout if the timer expires before the pre-fetch
  *   engine has reached the end of all work queues.  This can occur if the executable work queue
- *   entry is deep in the queue and the pre-fetch engine is subject to many resets (i.e. high switch,
- *   de-schedule, or new work load from other PP's).  Thus, it is possible for a PP to receive a work
+ *   entry is deep in the queue and the pre-fetch engine is subject to many resets (i.e. high
+ * switch,
+ *   de-schedule, or new work load from other PP's).  Thus, it is possible for a PP to receive a
+ * work
  *   response with the NO_WORK bit set even though there was at least one executable entry in the
- *   work queues.  The other (and typical) scenario for receiving a NO_WORK response with the WAIT
- *   bit clear is that the pre-fetch engine has reached the end of all work queues without finding
+ *   work queues.  The other (and typical) scenario for receiving a NO_WORK response with the
+ * WAIT
+ *   bit clear is that the pre-fetch engine has reached the end of all work queues without
+ * finding
  *   executable work.
  * - WAIT bit set.  The new work request can timeout if the timer expires before the pre-fetch
- *   engine has found executable work.  In this case, the only scenario where the PP will receive a
- *   work response with the NO_WORK bit set is if the timer expires.  Note: it is still possible for
- *   a PP to receive a NO_WORK response even though there was at least one executable entry in the
+ *   engine has found executable work.  In this case, the only scenario where the PP will receive
+ * a
+ *   work response with the NO_WORK bit set is if the timer expires.  Note: it is still possible
+ * for
+ *   a PP to receive a NO_WORK response even though there was at least one executable entry in
+ * the
  *   work queues.
  * In either case, it's important to note that switches and de-schedules are higher priority
- * operations that can cause the pre-fetch engine to reset.  Thus in a system with many switches or
+ * operations that can cause the pre-fetch engine to reset.  Thus in a system with many switches
+ * or
  * de-schedules occuring, it's possible for the new work timer to expire (resulting in NO_WORK
  * responses) before the pre-fetch engine is able to get very deep into the work queues.
  */
@@ -1136,11 +1155,14 @@ typedef union cvmx_pow_pf_rst_msk cvmx_pow_pf_rst_msk_t;
  *
  * Selects which group(s) a PP belongs to.  A '1' in any bit position sets the PP's membership in
  * the corresponding group.  A value of 0x0 will prevent the PP from receiving new work.  Note:
- * disabled or non-existent PP's should have this field set to 0xffff (the reset value) in order to
+ * disabled or non-existent PP's should have this field set to 0xffff (the reset value) in order
+ * to
  * maximize POW performance.
- * Also contains the QOS level priorities for each PP.  0x0 is highest priority, and 0x7 the lowest.
+ * Also contains the QOS level priorities for each PP.  0x0 is highest priority, and 0x7 the
+ * lowest.
  * Setting the priority to 0xf will prevent that PP from receiving work from that QOS level.
- * Priority values 0x8 through 0xe are reserved and should not be used.  For a given PP, priorities
+ * Priority values 0x8 through 0xe are reserved and should not be used.  For a given PP,
+ * priorities
  * should begin at 0x0 and remain contiguous throughout the range.
  */
 union cvmx_pow_pp_grp_mskx {
@@ -1201,12 +1223,17 @@ typedef union cvmx_pow_pp_grp_mskx cvmx_pow_pp_grp_mskx_t;
 /**
  * cvmx_pow_qos_rnd#
  *
- * Contains the round definitions for issuing new work.  Each round consists of 8 bits with each bit
+ * Contains the round definitions for issuing new work.  Each round consists of 8 bits with each
+ * bit
  * corresponding to a QOS level.  There are 4 rounds contained in each register for a total of 32
- * rounds.  The issue logic traverses through the rounds sequentially (lowest round to highest round)
- * in an attempt to find new work for each PP.  Within each round, the issue logic traverses through
- * the QOS levels sequentially (highest QOS to lowest QOS) skipping over each QOS level with a clear
- * bit in the round mask.  Note: setting a QOS level to all zeroes in all issue round registers will
+ * rounds.  The issue logic traverses through the rounds sequentially (lowest round to highest
+ * round)
+ * in an attempt to find new work for each PP.  Within each round, the issue logic traverses
+ * through
+ * the QOS levels sequentially (highest QOS to lowest QOS) skipping over each QOS level with a
+ * clear
+ * bit in the round mask.  Note: setting a QOS level to all zeroes in all issue round registers
+ * will
  * prevent work from being issued from that QOS level.
  */
 union cvmx_pow_qos_rndx {
@@ -1249,10 +1276,13 @@ typedef union cvmx_pow_qos_rndx cvmx_pow_qos_rndx_t;
 /**
  * cvmx_pow_qos_thr#
  *
- * Contains the thresholds for allocating POW internal storage buffers.  If the number of remaining
- * free buffers drops below the minimum threshold (MIN_THR) or the number of allocated buffers for
+ * Contains the thresholds for allocating POW internal storage buffers.  If the number of
+ * remaining
+ * free buffers drops below the minimum threshold (MIN_THR) or the number of allocated buffers
+ * for
  * this QOS level rises above the maximum threshold (MAX_THR), future incoming work queue entries
- * will be buffered externally rather than internally.  This register also contains a read-only count
+ * will be buffered externally rather than internally.  This register also contains a read-only
+ * count
  * of the current number of free buffers (FREE_CNT), the number of internal buffers currently
  * allocated to this QOS level (BUF_CNT), and the total number of buffers on the de-schedule list
  * (DES_CNT) (which is not the same as the total number of de-scheduled buffers).
@@ -1741,7 +1771,8 @@ typedef union cvmx_pow_wq_int_cntx cvmx_pow_wq_int_cntx_t;
 /**
  * cvmx_pow_wq_int_pc
  *
- * Contains the threshold value for the work queue interrupt periodic counter and also a read-only
+ * Contains the threshold value for the work queue interrupt periodic counter and also a read-
+ * only
  * copy of the periodic counter.  For more information regarding this register, see the interrupt
  * section.
  */
@@ -1788,7 +1819,8 @@ typedef union cvmx_pow_wq_int_pc cvmx_pow_wq_int_pc_t;
  * Contains the thresholds for enabling and setting work queue interrupts.  For more information
  * regarding this register, see the interrupt section.
  * Note: Up to 4 of the POW's internal storage buffers can be allocated for hardware use and are
- * therefore not available for incoming work queue entries.  Additionally, any PP that is not in the
+ * therefore not available for incoming work queue entries.  Additionally, any PP that is not in
+ * the
  * NULL_NULL state consumes a buffer.  Thus in a 4 PP system, it is not advisable to set either
  * IQ_THR or DS_THR to greater than 512 - 4 - 4 = 504.  Doing so may prevent the interrupt from
  * ever triggering.
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index c1a61ce..7778474 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -2024,7 +2024,9 @@ union cvmx_sso_err0 {
 	uint64_t fff_sbe                      : 1;  /**< Single-bit error for  RAM. Throws SSO_INTSN_E::SSO_ERR0_FFF_SBE. */
 	uint64_t wes_dbe                      : 1;  /**< Double-bit error for WES RAM. Throws SSO_INTSN_E::SSO_ERR0_WES_DBE. */
 	uint64_t wes_sbe                      : 1;  /**< Single-bit error for WES RAM. Throws SSO_INTSN_E::SSO_ERR0_WES_SBE. */
-	uint64_t reserved_5_31                : 27;
+	uint64_t reserved_6_31                : 26;
+	uint64_t addwq_dropped                : 1;  /**< Add work dropped due to wrong command/DID requested. Throws
+                                                         SSO_INTSN_E::SSO_ERR0_ADD_WQDROPPED. */
 	uint64_t awempty                      : 1;  /**< Received add work with tag specified as EMPTY. Throws SSO_INTSN_E::SSO_ERR0_AWEMPTY. */
 	uint64_t grpdis                       : 1;  /**< Add work to disabled group. An ADDWQ was received and dropped to a group with
                                                          SSO_GRP(0..255)_IAQ_THR[RSVD_THR] = 0. Throws SSO_INTSN_E::SSO_ERR0_GRPDIS. */
@@ -2039,7 +2041,8 @@ union cvmx_sso_err0 {
 	uint64_t bfp                          : 1;
 	uint64_t grpdis                       : 1;
 	uint64_t awempty                      : 1;
-	uint64_t reserved_5_31                : 27;
+	uint64_t addwq_dropped                : 1;
+	uint64_t reserved_6_31                : 26;
 	uint64_t wes_sbe                      : 1;
 	uint64_t wes_dbe                      : 1;
 	uint64_t fff_sbe                      : 1;
@@ -2729,14 +2732,9 @@ union cvmx_sso_gwe_cfg {
 	uint64_t gwe_rfpgw_dis                : 1;  /**< Disable periodic restart of GWE for pending get_work */
 	uint64_t odu_prf_dis                  : 1;  /**< Disable ODU-initiated prefetches of WQEs into L2C
                                                          For diagnostic use only. */
-	uint64_t odu_bmp_dis                  : 1;  /**< Disable ODU bumps.
-                                                         If SSO_PP_STRICT is true, could
-                                                         prevent forward progress under some circumstances.
-                                                         For diagnostic use only. */
-	uint64_t reserved_0_7                 : 8;
+	uint64_t reserved_0_8                 : 9;
 #else
-	uint64_t reserved_0_7                 : 8;
-	uint64_t odu_bmp_dis                  : 1;
+	uint64_t reserved_0_8                 : 9;
 	uint64_t odu_prf_dis                  : 1;
 	uint64_t gwe_rfpgw_dis                : 1;
 	uint64_t odu_ffpgw_dis                : 1;
@@ -2799,13 +2797,15 @@ union cvmx_sso_gwe_cfg {
 	} cn68xxp1;
 	struct cvmx_sso_gwe_cfg_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_8_63                : 56;
+	uint64_t reserved_9_63                : 55;
+	uint64_t dis_wgt_credit               : 1;  /**< Disable group weight credits. When set, groups have infinite weight credit. */
 	uint64_t ws_retries                   : 8;  /**< Work slot retries. When a given work-slot performs this number of retries without
                                                          successfully finding work then NO_WORK will be returned. Zero disables the retry counter.
                                                          Values 1, 2, 3 are reserved. */
 #else
 	uint64_t ws_retries                   : 8;
-	uint64_t reserved_8_63                : 56;
+	uint64_t dis_wgt_credit               : 1;
+	uint64_t reserved_9_63                : 55;
 #endif
 	} cn78xx;
 };
@@ -2912,13 +2912,16 @@ union cvmx_sso_ientx_links {
 	struct cvmx_sso_ientx_links_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t prev_index                   : 12; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list. */
-	uint64_t reserved_12_15               : 4;
+	uint64_t prev_index                   : 12; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
+                                                         or the head of a conflicted tag chain. */
+	uint64_t reserved_13_15               : 3;
+	uint64_t next_index_vld               : 1;  /**< The NEXT_INDEX is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
 	uint64_t next_index                   : 12; /**< The next entry in the tag chain or conflicted tag chain. Unpredictable if the entry is at
                                                          the tail of the list. */
 #else
 	uint64_t next_index                   : 12;
-	uint64_t reserved_12_15               : 4;
+	uint64_t next_index_vld               : 1;
+	uint64_t reserved_13_15               : 3;
 	uint64_t prev_index                   : 12;
 	uint64_t reserved_28_63               : 36;
 #endif
@@ -3991,8 +3994,8 @@ union cvmx_sso_sl_ppx_links {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t tailc                        : 1;  /**< Set when this SSO entry is the tail of the conflicted tail chain, and so there are no
                                                          additional conflicts on this tag chain. */
-	uint64_t reserved_61_62               : 2;
-	uint64_t index                        : 13; /**< The SSO entry attached to the core. */
+	uint64_t reserved_60_62               : 3;
+	uint64_t index                        : 12; /**< The SSO entry attached to the core. */
 	uint64_t reserved_38_47               : 10;
 	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). The
                                                          upper two bits are hardcoded to the node number. */
@@ -4001,20 +4004,19 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t reserved_25_25               : 1;
 	uint64_t revlink_index                : 12; /**< Prior SSO entry in the tag list when HEAD==0 and TT is not UNTAGGED nor EMPTY, otherwise
                                                          unpredictable. */
-	uint64_t reserved_11_12               : 2;
-	uint64_t link_index                   : 11; /**< Next SSO entry in the tag list when TAIL==0 and TT is not UNTAGGED nor EMPTY, otherwise
-                                                         unpredictable. */
+	uint64_t link_index_vld               : 1;  /**< LINK_INDEX is valid when TAIL==1 and TT is ATOMIC, otherwise unpredictable. */
+	uint64_t link_index                   : 12; /**< Next SSO entry in the tag list when TAILC==0 and TT is ATOMIC, otherwise unpredictable. */
 #else
-	uint64_t link_index                   : 11;
-	uint64_t reserved_11_12               : 2;
+	uint64_t link_index                   : 12;
+	uint64_t link_index_vld               : 1;
 	uint64_t revlink_index                : 12;
 	uint64_t reserved_25_25               : 1;
 	uint64_t tail                         : 1;
 	uint64_t head                         : 1;
 	uint64_t grp                          : 10;
 	uint64_t reserved_38_47               : 10;
-	uint64_t index                        : 13;
-	uint64_t reserved_61_62               : 2;
+	uint64_t index                        : 12;
+	uint64_t reserved_60_62               : 3;
 	uint64_t tailc                        : 1;
 #endif
 	} s;
@@ -4642,7 +4644,8 @@ union cvmx_sso_ws_cfg {
 	struct cvmx_sso_ws_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_56_63               : 8;
-	uint64_t ocla_bp                      : 8;  /**< Enable OCLA backpressure stalls. For diagnostic use only. INTERNAL:
+	uint64_t ocla_bp                      : 8;  /**< Enable OCLA backpressure stalls. For diagnostic use only.
+                                                         INTERNAL:
                                                          <55> NCBB input fifo stall (ncbo.)
                                                          <54> Work-slot response. (arbrsp.)
                                                          <53> Work-slot switching of descheduled work entries. (arbx.)
@@ -4651,13 +4654,17 @@ union cvmx_sso_ws_cfg {
                                                          <50> Work-slot CAM access. (arbc.)
                                                          <49> Work-slot RAM access. (arbr.)
                                                          <48> Work-slot pushes to AQ, CQ, DQ. (arbq.) */
-	uint64_t reserved_2_47                : 46;
+	uint64_t reserved_4_47                : 44;
+	uint64_t arbc_step_en                 : 1;  /**< Enable single-stepping WS CAM arbiter, twice per 16 clocks. For diagnostic use only. */
+	uint64_t ncbo_step_en                 : 1;  /**< Enable single-stepping commands from NCBO, once per 32 clocks. For diagnostic use only. */
 	uint64_t soc_ccam_dis                 : 1;  /**< Disable power saving SOC conditional CAM. */
 	uint64_t sso_cclk_dis                 : 1;  /**< Disable power saving SSO conditional clocking, */
 #else
 	uint64_t sso_cclk_dis                 : 1;
 	uint64_t soc_ccam_dis                 : 1;
-	uint64_t reserved_2_47                : 46;
+	uint64_t ncbo_step_en                 : 1;
+	uint64_t arbc_step_en                 : 1;
+	uint64_t reserved_4_47                : 44;
 	uint64_t ocla_bp                      : 8;
 	uint64_t reserved_56_63               : 8;
 #endif
-- 
2.6.2

