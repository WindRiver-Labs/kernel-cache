From bffaab666df2f225dd7921ec0fa937453bd19b1c Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Sat, 7 Sep 2013 10:29:21 -0700
Subject: [PATCH 327/974] MIPS: OCTEON: Sync up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-agl.c |   27 +-
 .../cavium-octeon/executive/cvmx-helper-sgmii.c    |   15 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |   17 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |    2 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |   51 +-
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       |   63 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     | 1347 ++++----
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       |  875 +++---
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |  312 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      |  223 +-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  105 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |  335 +-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 3307 ++++++++++++++++----
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |   14 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       |   39 +-
 15 files changed, 4788 insertions(+), 1944 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c b/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
index a56fc07..0dc4ddd 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
@@ -100,7 +100,7 @@ int __cvmx_helper_agl_probe(int interface)
 {
 	int port = cvmx_helper_agl_get_port(interface);
 	union cvmx_agl_gmx_bist gmx_bist;
-	union cvmx_agl_gmx_prtx_cfg gmx_prtx_cfg;	
+	union cvmx_agl_gmx_prtx_cfg gmx_prtx_cfg;
 	union cvmx_agl_prtx_ctl agl_prtx_ctl;
 	uint64_t clock_scale;
 	int result;
@@ -120,7 +120,7 @@ int __cvmx_helper_agl_probe(int interface)
         gmx_prtx_cfg.s.en = 0;
 	cvmx_write_csr(CVMX_AGL_GMX_PRTX_CFG(port), gmx_prtx_cfg.u64);
 
-	/* Set the rgx_ref_clk MUX with AGL_PRTx_CTL[REFCLK_SEL]. Default value 
+	/* Set the rgx_ref_clk MUX with AGL_PRTx_CTL[REFCLK_SEL]. Default value
 	   is 0 (RGMII REFCLK). Recommended to use RGMII RXC(1) or sclk/4 (2)
 	   to save cost.
 	 */
@@ -138,10 +138,13 @@ int __cvmx_helper_agl_probe(int interface)
 	agl_prtx_ctl.s.clktx_byp = 0;
 
 
-	if (OCTEON_IS_OCTEON3()) {
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
 		agl_prtx_ctl.s.refclk_sel = 0;
-		agl_prtx_ctl.s.clkrx_set = 0x0;
-		agl_prtx_ctl.s.clkrx_byp = 1;
+		agl_prtx_ctl.s.clkrx_set =
+			cvmx_helper_get_agl_rx_clock_skew(interface, port);
+		agl_prtx_ctl.s.clkrx_byp =
+			cvmx_helper_get_agl_rx_clock_delay_bypass(interface,
+								  port);
 	}
 	cvmx_write_csr(CVMX_AGL_PRTX_CTL(port), agl_prtx_ctl.u64);
 	/* Force write out before wait */
@@ -196,6 +199,7 @@ int __cvmx_helper_agl_enable(int interface)
 	int port = cvmx_helper_agl_get_port(interface);
 	union cvmx_pko_mem_port_ptrs pko_mem_port_ptrs;
 	union cvmx_pko_reg_read_idx read_idx;
+	int do_link_set = 1;
 	int i;
 
 	/* Setup PKO for AGL interface. Back pressure is not supported. */
@@ -215,7 +219,18 @@ int __cvmx_helper_agl_enable(int interface)
 	}
 
 	cvmx_agl_enable(port);
-	cvmx_agl_link_set(port, cvmx_agl_link_get(port), 1);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	/*
+	 * Linux kernel driver will call ....link_set with the
+	 * proper link state. In the simulator there is no
+	 * link state polling and hence it is set from
+	 * here.
+	 */
+	if (!(cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM))
+		do_link_set = 0;
+#endif
+	if (do_link_set)
+		cvmx_agl_link_set(port, cvmx_agl_link_get(port), 1);
 
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
index 6692113..dac8e71 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
@@ -43,7 +43,7 @@
  * Functions for SGMII initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 87025 $<hr>
+ * <hr>$Revision: 89030 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -632,6 +632,9 @@ cvmx_helper_link_info_t __cvmx_helper_sgmii_link_get(int ipd_port)
 		speed = cvmx_qlm_get_gbaud_mhz(qlm) * 8 / 10;
 	} else if (OCTEON_IS_MODEL(OCTEON_CNF71XX)) {
 		speed = cvmx_qlm_get_gbaud_mhz(0) * 8 / 10;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+		speed = cvmx_qlm_get_gbaud_mhz(0) * 8 / 10;
+		speed >>= 2;
 	}
 
 	pcsx_mrx_control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
@@ -804,16 +807,12 @@ int __cvmx_helper_bgx_sgmii_enable(int interface)
 	/* Configure the bgx mac */
 	bgx_init(interface, CVMX_HELPER_INTERFACE_MODE_SGMII);
 
-	/*
-	 * Must hardcode the port kind here until the pko initializion is
-	 * complete. This must be removed once the pko initialization is
-	 * working. TODO
-	 */
-	pknd = 10 + (num_ports * interface);
+	/* Setup pkind */
 	for (i = 0; i < num_ports; i++) {
+		pknd = cvmx_helper_get_pknd(interface, i);
 		bgx_cmr_rx_id_map.u64 = 0;
 		bgx_cmr_rx_id_map.s.rid = 2 + i;
-		bgx_cmr_rx_id_map.s.pknd = pknd + i;
+		bgx_cmr_rx_id_map.s.pknd = pknd;
 		cvmx_write_csr(CVMX_BGXX_CMRX_RX_ID_MAP(i, interface),
 			       bgx_cmr_rx_id_map.u64);
 	}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 38d8010..593d3ca 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 88618 $<hr>
+ * <hr>$Revision: 89072 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -644,9 +644,14 @@ retry:
 	/* Disable the peer to peer forwarding register. This must be setup
 	   by the OS after it enumerates the bus and assigns addresses to the
 	   PCIe busses */
-	for (i = 0; i < 4; i++) {
-		cvmx_write_csr(CVMX_PESCX_P2P_BARX_START(i, pcie_port), -1);
-		cvmx_write_csr(CVMX_PESCX_P2P_BARX_END(i, pcie_port), -1);
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN66XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN68XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		for (i = 0; i < 4; i++) {
+			cvmx_write_csr(CVMX_PESCX_P2P_BARX_START(i, pcie_port), -1);
+			cvmx_write_csr(CVMX_PESCX_P2P_BARX_END(i, pcie_port), -1);
+		}
 	}
 
 	/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
@@ -1187,8 +1192,8 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		   by the OS after it enumerates the bus and assigns addresses to the
 		   PCIe busses */
 		for (i = 0; i < 4; i++) {
-			cvmx_write_csr(CVMX_PEMX_P2P_BARX_START(i, pcie_port), -1);
-			cvmx_write_csr(CVMX_PEMX_P2P_BARX_END(i, pcie_port), -1);
+			cvmx_write_csr(CVMX_PEMX_P2P_BARX_START(pcie_port, i), -1);
+			cvmx_write_csr(CVMX_PEMX_P2P_BARX_END(pcie_port, i), -1);
 		}
 	}
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index f178f8f..111b532 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 88712 $<hr>
+ * <hr>$Revision: 88975 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 7f8fc30..d9d460b 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -2031,9 +2031,10 @@ union cvmx_bgxx_cmrx_int {
 	struct cvmx_bgxx_cmrx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t pko_nxc                      : 1;  /**< TX channel out-of-range from PKO interface */
+	uint64_t pko_nxc                      : 1;  /**< TX channel out-of-range from PKO interface. Assigned to the LMAC ID based on the lower 2
+                                                         bits of the offending channel */
 	uint64_t overflw                      : 1;  /**< RX overflow. */
-	uint64_t pause_drp                    : 1;  /**< RX PAUSE packet was dropped due to full RXB FIFO or during per lmac reset. */
+	uint64_t pause_drp                    : 1;  /**< RX PAUSE packet was dropped due to full RXB FIFO or during partner reset. */
 #else
 	uint64_t pause_drp                    : 1;
 	uint64_t overflw                      : 1;
@@ -2284,7 +2285,7 @@ union cvmx_bgxx_cmrx_rx_pause_drop_time {
 	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t pause_time                   : 16; /**< Time extracted from the dropped PAUSE packet dropped due to RXB FIFO full or during per lmac reset */
+	uint64_t pause_time                   : 16; /**< Time extracted from the dropped PAUSE packet dropped due to RXB FIFO full or during partner reset */
 #else
 	uint64_t pause_time                   : 16;
 	uint64_t reserved_16_63               : 48;
@@ -2346,7 +2347,9 @@ typedef union cvmx_bgxx_cmrx_rx_stat1 cvmx_bgxx_cmrx_rx_stat1_t;
  *
  * These registers provide a count of all packets received that were recognized as flow-control
  * or PAUSE packets. PAUSE packets with any kind of error are counted in BGX*_CMR*_RX_STAT8
- * (error stats register). Pause packets can be optionally dropped or forwarded based on
+ * (error stats register) and does not include those reported in BGX(0..5)_CMR(0..3)_RX_STAT6
+ * nor BGX(0..5)_CMR(0..3)_RX_STAT4.
+ * Pause packets can be optionally dropped or forwarded based on
  * BGX_SMU_RX_FRM_CTL[CTL_DRP]. This count increments regardless of whether the packet is
  * dropped. PAUSE packets are never counted in BGX*_CMR*_RX_STAT0.
  */
@@ -2393,7 +2396,8 @@ typedef union cvmx_bgxx_cmrx_rx_stat3 cvmx_bgxx_cmrx_rx_stat3_t;
  *
  * These registers provide a count of all packets received that were dropped by the DMAC filter.
  * Packets that match the DMAC are dropped and counted here regardless of whether they were ERR
- * packets. These packets are never counted in BGX*_CMR*_RX_STAT0. Eight-byte packets as the
+ * packets, but does not include those reported in BGX(0..5)_CMR(0..3)_RX_STAT6.
+ * These packets are never counted in BGX*_CMR*_RX_STAT0. Eight-byte packets as the
  * result of truncation or other means are not be dropped by CN78XX and will never appear in this
  * count.
  */
@@ -2486,6 +2490,19 @@ typedef union cvmx_bgxx_cmrx_rx_stat7 cvmx_bgxx_cmrx_rx_stat7_t;
  *
  * These registers provide a count of all packets received with some error that were not dropped
  * either due to the DMAC filter or lack of room in the receive FIFO.
+ * This does not include packets which were counted in
+ * BGX(0..5)_CMR(0..3)_RX_STAT2, BGX(0..5)_CMR(0..3)_RX_STAT4 nor
+ * BGX(0..5)_CMR(0..3)_RX_STAT6 nor BGX(0..5)_CMR(0..3)_RX_STAT8.
+ * Which statistics are updated on errors and drops are shown below:
+ * if dropped [
+ *   if !errored STAT8
+ *   if overflow STAT6
+ *   else if dmac drop STAT4
+ *   else if filter drop STAT2
+ * ] else [
+ *   if errored STAT2
+ *   else STAT8
+ * ]
  */
 union cvmx_bgxx_cmrx_rx_stat8 {
 	uint64_t u64;
@@ -3492,7 +3509,7 @@ typedef union cvmx_bgxx_gmp_gmi_prtx_cfg cvmx_bgxx_gmp_gmi_prtx_cfg_t;
  * cvmx_bgx#_gmp_gmi_rx#_decision
  *
  * Notes:
- * As each byte in a packet is received by GMX, the L2 byte count is compared
+ * As each byte in a packet is received by GMI, the L2 byte count is compared
  * against the BGX_GMP_GMI_RX_DECISION[CNT].  The L2 byte count is the number of bytes
  * from the beginning of the L2 header (DMAC).  In normal operation, the L2
  * header begins after the PREAMBLE+SFD (BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK]=1) and any
@@ -3608,7 +3625,7 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
                                                          of the PREAMBLE. PRE_CHK must be set to enable this and all PREAMBLE features.
                                                          SGMII at 10/100Mbs only. */
 	uint64_t reserved_7_8                 : 2;
-	uint64_t pre_free                     : 1;  /**< When set, PREAMBLE checking is less strict. GMX will begin the frame at the first SFD.
+	uint64_t pre_free                     : 1;  /**< When set, PREAMBLE checking is less strict. GMI will begin the frame at the first SFD.
                                                          PRE_CHK must be set to enable this and all PREAMBLE features. SGMII/1000Base-X only. */
 	uint64_t ctl_smac                     : 1;  /**< Control PAUSE frames can match station SMAC. */
 	uint64_t ctl_mcst                     : 1;  /**< Control PAUSE frames can match globally assign multicast address. */
@@ -3625,7 +3642,7 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
                                                          against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                          of the L2 header for DMAC and Control frame recognition. */
 	uint64_t pre_chk                      : 1;  /**< Check the preamble for correctness. This port is configured to send a valid 802.3 PREAMBLE
-                                                         to begin every frame. GMX checks that a valid PREAMBLE is received (based on PRE_FREE).
+                                                         to begin every frame. GMI checks that a valid PREAMBLE is received (based on PRE_FREE).
                                                          When a problem does occur within the PREAMBLE sequence, the frame is marked as bad and not
                                                          sent into the core. The BGX(0..5)_SMU(0..3)_RX_INT[PCTERR] interrupt is also raised.
                                                          When BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] is set, PRE_CHK must be 0. If PTP_MODE = 1 and
@@ -3687,7 +3704,7 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_ifg cvmx_bgxx_gmp_gmi_rxx_ifg_t;
  * as either MINERR o r CAREXT errors.
  * (4) JABBER An RX Jabber error indicates that a packet was received which
  * is longer than the maximum allowed packet as defined by the
- * system.  GMX will truncate the packet at the JABBER count.
+ * system.  GMI will truncate the packet at the JABBER count.
  * Failure to do so could lead to system instabilty.
  * (5) NIBERR This error is illegal at 1000Mbs speeds
  * (BGX_GMP_GMI_RX_PRT_CFG[SPEED]==0) and will never assert.
@@ -3714,10 +3731,10 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_ifg cvmx_bgxx_gmp_gmi_rxx_ifg_t;
  * (B) PCTERR checks that the frame begins with a valid PREAMBLE sequence.
  * Does not check the number of PREAMBLE cycles.
  * (C) OVRERR
- * OVRERR is an architectural assertion check internal to GMX to
+ * OVRERR is an architectural assertion check internal to GMI to
  * make sure no assumption was violated.  In a correctly operating
  * system, this interrupt can never fire.
- * GMX has an internal arbiter which selects which of 4 ports to
+ * GMI has an internal arbiter which selects which of 4 ports to
  * buffer in the main RX FIFO.  If we normally buffer 8 bytes,
  * then each port will typically push a tick every 8 cycles if
  * the packet interface is going as fast as possible.  If there
@@ -3748,7 +3765,7 @@ union cvmx_bgxx_gmp_gmi_rxx_int {
 	uint64_t fcserr                       : 1;  /**< FCS/CRC error. Frame was received with FCS/CRC error */
 	uint64_t jabber                       : 1;  /**< System-length error: frame was received with length > sys_length.
                                                          An RX Jabber error indicates that a packet was received which is longer than the maximum
-                                                         allowed packet as defined by the system. GMX truncates the packet at the JABBER count.
+                                                         allowed packet as defined by the system. GMI truncates the packet at the JABBER count.
                                                          Failure to do so could lead to system instability. */
 	uint64_t carext                       : 1;  /**< Carrier extend error
                                                          (SGMII/1000Base-X only) */
@@ -3786,7 +3803,7 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_int cvmx_bgxx_gmp_gmi_rxx_int_t;
  * defined as...
  * max_sized_packet = BGX_GMP_GMI_RX_JABBER[CNT]+((BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK] &
  * !BGX_GMP_GMI_RX_FRM_CTL[PRE_STRP])*8)
- * BGX_GMP_GMI_RX_JABBER = The max size packet after which GMX will truncate
+ * BGX_GMP_GMI_RX_JABBER = The max size packet after which GMI will truncate
  */
 union cvmx_bgxx_gmp_gmi_rxx_jabber {
 	uint64_t u64;
@@ -4560,8 +4577,8 @@ union cvmx_bgxx_gmp_pcs_miscx_ctl {
 	uint64_t reserved_13_63               : 51;
 	uint64_t sgmii                        : 1;  /**< SGMII mode. 1 = SGMII or 1000BASE-X mode selected, 0 = other mode selected. See
                                                          GSERx_LANE_MODE[LMODE]. */
-	uint64_t gmxeno                       : 1;  /**< GMX enable override. When set, forces GMX to appear disabled. The enable/disable status of
-                                                         GMX is checked only at SOP of every packet. */
+	uint64_t gmxeno                       : 1;  /**< GMI enable override. When set, forces GMI to appear disabled. The enable/disable status of
+                                                         GMI is checked only at SOP of every packet. */
 	uint64_t loopbck2                     : 1;  /**< Sets external loopback mode to return RX data back out via the TX data path. 0 = No
                                                          loopback, 1 = Loopback.
                                                          LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
@@ -6153,7 +6170,9 @@ union cvmx_bgxx_spux_br_pmd_control {
 	uint64_t reserved_2_63                : 62;
 	uint64_t train_en                     : 1;  /**< BASE-R training enable */
 	uint64_t train_restart                : 1;  /**< BASE-R training restart. Writing a 1 to this bit restarts the training process if the
-                                                         TRAIN_EN bit in this register is also set. This is a self-clearing bit. */
+                                                         TRAIN_EN bit in this register is also set. This is a self-clearing bit. Software should
+                                                         wait a minimum of 1.7ms after BGX(0..5)_SPU(0..3)_INT[TRAINING_FAILURE] is set before
+                                                         restarting the training process. */
 #else
 	uint64_t train_restart                : 1;
 	uint64_t train_en                     : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index cc9957f9..f6ee9f7 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -350,7 +350,7 @@ static inline uint64_t CVMX_DPI_INFO_REG_FUNC(void)
 #define CVMX_DPI_INT_EN CVMX_DPI_INT_EN_FUNC()
 static inline uint64_t CVMX_DPI_INT_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_INT_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000010ull);
 }
@@ -599,6 +599,17 @@ union cvmx_dpi_bist_status {
 	uint64_t u64;
 	struct cvmx_dpi_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_51_63               : 13;
+	uint64_t bist                         : 51; /**< BIST Results.
+                                                         HW sets a bit in BIST for for memory that fails
+                                                         BIST. */
+#else
+	uint64_t bist                         : 51;
+	uint64_t reserved_51_63               : 13;
+#endif
+	} s;
+	struct cvmx_dpi_bist_status_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_47_63               : 17;
 	uint64_t bist                         : 47; /**< BIST Results.
                                                          HW sets a bit in BIST for for memory that fails
@@ -607,8 +618,7 @@ union cvmx_dpi_bist_status {
 	uint64_t bist                         : 47;
 	uint64_t reserved_47_63               : 17;
 #endif
-	} s;
-	struct cvmx_dpi_bist_status_s         cn61xx;
+	} cn61xx;
 	struct cvmx_dpi_bist_status_cn63xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_45_63               : 19;
@@ -631,12 +641,12 @@ union cvmx_dpi_bist_status {
 	uint64_t reserved_37_63               : 27;
 #endif
 	} cn63xxp1;
-	struct cvmx_dpi_bist_status_s         cn66xx;
+	struct cvmx_dpi_bist_status_cn61xx    cn66xx;
 	struct cvmx_dpi_bist_status_cn63xx    cn68xx;
 	struct cvmx_dpi_bist_status_cn63xx    cn68xxp1;
-	struct cvmx_dpi_bist_status_s         cn70xx;
-	struct cvmx_dpi_bist_status_cn63xx    cn78xx;
-	struct cvmx_dpi_bist_status_s         cnf71xx;
+	struct cvmx_dpi_bist_status_cn61xx    cn70xx;
+	struct cvmx_dpi_bist_status_s         cn78xx;
+	struct cvmx_dpi_bist_status_cn61xx    cnf71xx;
 };
 typedef union cvmx_dpi_bist_status cvmx_dpi_bist_status_t;
 
@@ -1596,17 +1606,21 @@ union cvmx_dpi_ecc_ctl {
 	uint64_t u64;
 	struct cvmx_dpi_ecc_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_48_63               : 16;
-	uint64_t ram_cdis                     : 16; /**< RDB RAM ECC correction disable. Each bit corresponds to a different RAM. */
-	uint64_t ram_flip1                    : 16; /**< Flip syndrome bits on write. Flip syndrome bits <1> on writes to the corresponding RDB ram
+	uint64_t reserved_33_63               : 31;
+	uint64_t ram_cdis                     : 1;  /**< RDB RAM ECC correction disable. Each bit corresponds to a different RAM. */
+	uint64_t reserved_17_31               : 15;
+	uint64_t ram_flip1                    : 1;  /**< Flip syndrome bits on write. Flip syndrome bits <1> on writes to the corresponding RDB ram
                                                          to test single-bit or double-bit error handling. */
-	uint64_t ram_flip0                    : 16; /**< Flip syndrome bits on write. Flip syndrome bits <0> on writes to the corresponding RDB ram
+	uint64_t reserved_1_15                : 15;
+	uint64_t ram_flip0                    : 1;  /**< Flip syndrome bits on write. Flip syndrome bits <0> on writes to the corresponding RDB ram
                                                          to test single-bit or double-bit error handling. */
 #else
-	uint64_t ram_flip0                    : 16;
-	uint64_t ram_flip1                    : 16;
-	uint64_t ram_cdis                     : 16;
-	uint64_t reserved_48_63               : 16;
+	uint64_t ram_flip0                    : 1;
+	uint64_t reserved_1_15                : 15;
+	uint64_t ram_flip1                    : 1;
+	uint64_t reserved_17_31               : 15;
+	uint64_t ram_cdis                     : 1;
+	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
 	struct cvmx_dpi_ecc_ctl_s             cn78xx;
@@ -1623,17 +1637,17 @@ union cvmx_dpi_ecc_int {
 	uint64_t u64;
 	struct cvmx_dpi_ecc_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_63_63               : 1;
-	uint64_t ram_dbe                      : 31; /**< Set when a double-bit error is detected in the corresponding ram. Throws
-                                                         DPI_INTSN_E::DPI_ERR_RAM_DBE. */
-	uint64_t reserved_31_31               : 1;
-	uint64_t ram_sbe                      : 31; /**< Set when a single-bit error is detected in the corresponding ram. Throws
+	uint64_t reserved_47_63               : 17;
+	uint64_t ram_sbe                      : 15; /**< Set when a single-bit error is detected in the corresponding ram. Throws
                                                          DPI_INTSN_E::DPI_ERR_RAM_SBE. */
+	uint64_t reserved_15_31               : 17;
+	uint64_t ram_dbe                      : 15; /**< Set when a double-bit error is detected in the corresponding ram. Throws
+                                                         DPI_INTSN_E::DPI_ERR_RAM_DBE. */
 #else
-	uint64_t ram_sbe                      : 31;
-	uint64_t reserved_31_31               : 1;
-	uint64_t ram_dbe                      : 31;
-	uint64_t reserved_63_63               : 1;
+	uint64_t ram_dbe                      : 15;
+	uint64_t reserved_15_31               : 17;
+	uint64_t ram_sbe                      : 15;
+	uint64_t reserved_47_63               : 17;
 #endif
 	} s;
 	struct cvmx_dpi_ecc_int_s             cn78xx;
@@ -1859,7 +1873,6 @@ union cvmx_dpi_int_en {
 	struct cvmx_dpi_int_en_cn63xx         cn68xx;
 	struct cvmx_dpi_int_en_cn63xx         cn68xxp1;
 	struct cvmx_dpi_int_en_s              cn70xx;
-	struct cvmx_dpi_int_en_s              cn78xx;
 	struct cvmx_dpi_int_en_s              cnf71xx;
 };
 typedef union cvmx_dpi_int_en cvmx_dpi_int_en_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 498f4f5..13089cd 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -570,6 +570,28 @@ static inline uint64_t CVMX_GSERX_LANEX_PX_MODE_1(unsigned long a, unsigned long
 #define CVMX_GSERX_LANEX_PX_MODE_1(a, b, c) (CVMX_ADD_IO_SEG(0x00011800904E0048ull) + ((a) << 24) + ((b) << 20) + ((c) << 5))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_CTLE_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440058ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_CTLE_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440058ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_PRECORR_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -603,6 +625,17 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(unsigned long offset, u
 #define CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440250ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_CTRL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440200ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_VMA_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440200ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_VMA_COARSE_CTRL_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -636,6 +669,39 @@ static inline uint64_t CVMX_GSERX_LANEX_VMA_COARSE_CTRL_2(unsigned long offset,
 #define CVMX_GSERX_LANEX_VMA_COARSE_CTRL_2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_VMA_FINE_CTRL_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_VMA_FINE_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_VMA_FINE_CTRL_0(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_VMA_FINE_CTRL_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_VMA_FINE_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_VMA_FINE_CTRL_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_VMA_FINE_CTRL_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_VMA_FINE_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_VMA_FINE_CTRL_2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long block_id)
 {
 	if (!(
@@ -1304,20 +1370,14 @@ union cvmx_gserx_ana_atest {
 	struct cvmx_gserx_ana_atest_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t ana_dac_b                    : 7;  /**< Used to control the B-side DAC input to the analog test block.
-                                                         Note that the QLM0 register is tied to the analog
-                                                         test block, for non-OCI links.
-                                                         Note that the OCI0 register is tied to the analog
-                                                         test block, for OCI links.
-                                                         The other QLM GSER_ANA_DAC_B registers are unused.
-                                                         It is not expected that software will need to use this register. */
-	uint64_t ana_dac_a                    : 5;  /**< Used to control A-side DAC input to the analog test block.
-                                                         Note that the QLM0 register is tied to the analog
-                                                         test block, for non-OCI links.
-                                                         Note that the OCI0 register is tied to the analog
-                                                         test block, for OCI links.
-                                                         The other QLM GSER_ANA_DAC_A registers are unused.
-                                                         It is not expected that software will need to use this register. */
+	uint64_t ana_dac_b                    : 7;  /**< Used to control the B-side DAC input to the analog test block. Note that the QLM4 register
+                                                         is tied to the analog test block, for non-OCI links. Note that the OCI4 register is tied
+                                                         to the analog test block, for OCI links. The other QLM GSER_ANA_DAC_B registers are
+                                                         unused. For diagnostic use only. */
+	uint64_t ana_dac_a                    : 5;  /**< Used to control A-side DAC input to the analog test block. Note that the QLM4 register is
+                                                         tied to the analog test block, for non-OCI links. Note that the OCI4 register is tied to
+                                                         the analog test block, for OCI links. The other QLM GSER_ANA_DAC_A registers are unused.
+                                                         For diagnostic use only. */
 #else
 	uint64_t ana_dac_a                    : 5;
 	uint64_t ana_dac_b                    : 7;
@@ -1336,13 +1396,10 @@ union cvmx_gserx_ana_sel {
 	struct cvmx_gserx_ana_sel_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
-	uint64_t ana_sel                      : 9;  /**< Used to control the adr_global input to the analog test block.
-                                                         Note that the QLM0 register is tied to the analog
-                                                         test block, for non-OCI links.
-                                                         Note that the QLM8 register is tied to the analog
-                                                         test block, for OCI links.
-                                                         The other QLM GSER_ANA_SEL registers are unused.
-                                                         It is not expected that software will need to use this register. */
+	uint64_t ana_sel                      : 9;  /**< Used to control the adr_global input to the analog test block. Note that the QLM0 register
+                                                         is tied to the analog test block, for non-OCI links. Note that the QLM8 register is tied
+                                                         to the analog test block, for OCI links. The other QLM GSER_ANA_SEL registers are unused.
+                                                         For diagnostic use only. */
 #else
 	uint64_t ana_sel                      : 9;
 	uint64_t reserved_9_63                : 55;
@@ -1360,27 +1417,22 @@ union cvmx_gserx_br_rxx_ctl {
 	struct cvmx_gserx_br_rxx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t rxt_swm                      : 1;  /**< Set when RX Base-R Link Training is to be performed under software control.
-                                                         It is not expected that Link Training will need to be performed under
-                                                         software control. */
-	uint64_t rxt_preset                   : 1;  /**< For all link training, this bit determines how to configure the Preset bit
-                                                         in the Coeffient Update Message that is sent to the far end transmitter.
-                                                         When set, a one time request is made that the coefficients be set to a state where
-                                                         equalization is turned off.
-                                                         To perform a preset, set this bit prior to link training. link training needs to
-                                                         be disabled to complete the request and get the rxtrain state machine back to IDLE.
-                                                         Note that it is illegal to set both the preset and initialize bits at the same time.
-                                                         It is not expected that software will need to set this bit. */
-	uint64_t rxt_initialize               : 1;  /**< For all link training, this bit determines how to configure the Initialize bit
-                                                         in the Coeffient Update Message that is sent to the far end transmitter.
-                                                         of RX training.
-                                                         When set, a request is made that the coefficients be set to its INITIALIZE state.
-                                                         To perform a initialize prior to link training, set this bit prior to perfomorming
-                                                         link training.
-                                                         Note that it is illegal to set both the preset and initialize bits at the same time.
-                                                         Since the far end transmitter is required to be initialized prior to starting link
-                                                         training,
-                                                         it is not expected that software will need to set this bit. */
+	uint64_t rxt_swm                      : 1;  /**< Set when RX Base-R Link Training is to be performed under software control. For diagnostic
+                                                         use only. */
+	uint64_t rxt_preset                   : 1;  /**< For all link training, this bit determines how to configure the preset bit in the
+                                                         coefficient update message that is sent to the far end transmitter. When set, a one time
+                                                         request is made that the coefficients be set to a state where equalization is turned off.
+                                                         To perform a preset, set this bit prior to link training. link training needs to be
+                                                         disabled to complete the request and get the rxtrain state machine back to IDLE. Note that
+                                                         it is illegal to set both the preset and initialize bits at the same time. For diagnostic
+                                                         use only. */
+	uint64_t rxt_initialize               : 1;  /**< For all link training, this bit determines how to configure the initialize bit in the
+                                                         coefficient update message that is sent to the far end transmitter of RX training. When
+                                                         set, a request is made that the coefficients be set to its INITIALIZE state. To perform a
+                                                         initialize prior to link training, set this bit prior to performing link training. Note
+                                                         that it is illegal to set both the preset and initialize bits at the same time. Since the
+                                                         far end transmitter is required to be initialized prior to starting link training, it is
+                                                         not expected that software will need to set this bit. For diagnostic use only. */
 #else
 	uint64_t rxt_initialize               : 1;
 	uint64_t rxt_preset                   : 1;
@@ -1401,10 +1453,8 @@ union cvmx_gserx_br_rxx_cu {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t rxt_cu                       : 9;  /**< When RX Base-R Link Training is being performed under software control,
-                                                         (GSER_BR_RX(0..3)_CTL.RXT_SWM is set), this is the Coefficient Update Message
-                                                         to send to the MAC (BGX/OCI).
-                                                         It is not expected that software will need to perform link training under
-                                                         software control. */
+                                                         (GSER(0..13)_BR_RX(0..3)_CTL[RXT_SWM] is set), this is the coefficient update message to
+                                                         send to the MAC (BGX/OCI). For diagnostic use only. */
 #else
 	uint64_t rxt_cu                       : 9;
 	uint64_t reserved_9_63                : 55;
@@ -1417,11 +1467,10 @@ typedef union cvmx_gserx_br_rxx_cu cvmx_gserx_br_rxx_cu_t;
 /**
  * cvmx_gser#_br_rx#_eer
  *
- * GSER SW Base-R RX Link Training Equalization Evaluation Request (EER)
- * A write to RXT_EER will initiate a  Equalization Request to the RAW PCS.
- * A read of this register will return the Equalization Status Message and a valid
- * bit indicating it was updated.
- * It is not expected that software will need to perform EER requests during link training.
+ * GSER software Base-R RX Link Training equalization evaluation request (EER). A write to
+ * RXT_EER initiates a equalization request to the RAW PCS. A read of this register returns the
+ * equalization status message and a valid bit indicating it was updated. These registers are for
+ * diagnostic use only.
  */
 union cvmx_gserx_br_rxx_eer {
 	uint64_t u64;
@@ -1429,20 +1478,25 @@ union cvmx_gserx_br_rxx_eer {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t rxt_eer                      : 1;  /**< When RX Base-R Link Training is being performed under software control,
-                                                         (GSER_BR_RX(0..3)_CTL.RXT_SWM is set), writing this is the bit will initiate
-                                                         a Equalization Request to the RAW PCS. Reading this bit always returns a
-                                                         zero. */
-	uint64_t rxt_esv                      : 1;  /**< When performing a Equalization Request (RXT_EER), this bit will set
-                                                         indicating that the Equalization Status (RXT_ESM) is valid. When issueing
-                                                         a RXT_EER request, it is expected that RXT_ESV will get written to zero
-                                                         so that a valid RXT_ESM can be determined. */
-	uint64_t rxt_esm                      : 14; /**< When performing a Equalization Request (RXT_EER),
-                                                         this is the Equalization Status Message from the RAW PCS.
-                                                         It is valid with RXT_ESV is set.
-                                                         <13:6>: Figure of merit.
-                                                         <5:4>:  RX recommended TXPOST direction change.
-                                                         <3:2>:  RX recommended TXMAIN direction change.
-                                                         <1:0>:  RX recommended TXPRE direction change. */
+                                                         (GSER(0..13)_BR_RX(0..3)_CTL[RXT_SWM] is set), writing this bit initiates an equalization
+                                                         request to the RAW PCS. Reading this bit always returns a zero. */
+	uint64_t rxt_esv                      : 1;  /**< When performing an equalization request (RXT_EER), this bit, when set, indicates that the
+                                                         Equalization Status (RXT_ESM) is valid. When issuing a RXT_EER request, it is expected
+                                                         that RXT_ESV will get written to zero so that a valid RXT_ESM can be determined. */
+	uint64_t rxt_esm                      : 14; /**< When performing a equalization request (RXT_EER), this is the equalization status message
+                                                         from the RAW PCS. It is valid with RXT_ESV is set.
+                                                         <13:6>: Figure of merit. An 8-bit output from the PHY indicating the quality of the
+                                                         received data eye. A higher value indicates better link equalization, with 8'd0 indicating
+                                                         worst equalization setting and 8'd255 indicating the best equalization setting.
+                                                         <5:4>: RX recommended TXPOST direction change.
+                                                         <3:2>: RX recommended TXMAIN direction change.
+                                                         <1:0>: RX recommended TXPRE direction change.
+                                                         Recommended direction change outputs from the PHY for the link partner transmitter
+                                                         coefficients.
+                                                         0x0 = Hold.
+                                                         0x1 = Increment.
+                                                         0x2 = Decrement.
+                                                         0x3 = Hold. */
 #else
 	uint64_t rxt_esm                      : 14;
 	uint64_t rxt_esv                      : 1;
@@ -1463,10 +1517,8 @@ union cvmx_gserx_br_rxx_sr {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
 	uint64_t rxt_sr                       : 6;  /**< When RX Base-R Link Training is being performed under software control,
-                                                         (GSER_BR_RX(0..3)_CTL.RXT_SWM is set), this is the Status Report Message
-                                                         from the Link Partner.
-                                                         It is not expected that software will need to perform link training under
-                                                         software control. */
+                                                         (GSER(0..13)_BR_RX(0..3)_CTL[RXT_SWM] is set), this is the status report message from the
+                                                         link partner. For diagnostic use only. */
 #else
 	uint64_t rxt_sr                       : 6;
 	uint64_t reserved_6_63                : 58;
@@ -1484,9 +1536,8 @@ union cvmx_gserx_br_txx_ctl {
 	struct cvmx_gserx_br_txx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t txt_swm                      : 1;  /**< Set when TX Base-R Link Training is to be performed under software control.
-                                                         It is not expected that Link Training will need to be performed under
-                                                         software control. */
+	uint64_t txt_swm                      : 1;  /**< Set when TX Base-R Link Training is to be performed under software control. For diagnostic
+                                                         use only. */
 #else
 	uint64_t txt_swm                      : 1;
 	uint64_t reserved_1_63                : 63;
@@ -1505,10 +1556,8 @@ union cvmx_gserx_br_txx_cu {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t txt_cu                       : 9;  /**< When TX Base-R Link Training is being performed under software control,
-                                                         (GSER_BR_TX(0..3)_CTL.TXT_SWM is set), this is the Coefficient Update Message
-                                                         from the Link Partner.
-                                                         It is not expected that software will need to perform link training under
-                                                         software control. */
+                                                         (GSER(0..13)_BR_TX(0..3)_CTL[TXT_SWM] is set), this is the coefficient update message from
+                                                         the link partner. For diagnostic use only. */
 #else
 	uint64_t txt_cu                       : 9;
 	uint64_t reserved_9_63                : 55;
@@ -1527,13 +1576,12 @@ union cvmx_gserx_br_txx_cur {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
 	uint64_t txt_cur                      : 14; /**< When TX Base-R Link Training is being performed under software control,
-                                                         (GSER_BR_TX(0..3)_CTL.TXT_SWM is set), this is the Coefficient Update
-                                                         to be written to the PHY.
-                                                         bits 13:9: TX_POST[4:0]
-                                                         bits 8:4:  TX_SWING[4:0]
-                                                         bits 3:0:  TX_PRE[4:0]
-                                                         It is not expected that software will need to perform link training under
-                                                         software control. */
+                                                         (GSER_BR_TX(0..3)_CTL.TXT_SWM is set), this is the Coefficient Update to be written to the
+                                                         PHY.
+                                                         Bits 13:9: TX_POST<4:0>
+                                                         Bits 8:4: TX_SWING<4:0>
+                                                         Bits 3:0: TX_PRE<4:0>
+                                                         For diagnostic use only. */
 #else
 	uint64_t txt_cur                      : 14;
 	uint64_t reserved_14_63               : 50;
@@ -1552,12 +1600,9 @@ union cvmx_gserx_br_txx_sr {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
 	uint64_t txt_sr                       : 6;  /**< When TX Base-R Link Training is being performed under software control,
-                                                         (GSER_BR_TX(0..3)_CTL.TXT_SWM is set), this is the Status Report (SR)
-                                                         Message to be sent to the link partner. Writing this register will cause
-                                                         a new SR message to be sent to the Mac (BGX/OCI) to be forwarded
-                                                         to the link partner.
-                                                         It is not expected that software will need to perform link training under
-                                                         software control. */
+                                                         (GSER(0..13)_BR_TX(0..3)_CTL[TXT_SWM] is set), this is the status report (SR) message to
+                                                         be sent to the link partner. Writing this register causes a new SR message to be sent to
+                                                         the MAC (BGX/OCI) to be forwarded to the link partner. For diagnostic use only. */
 #else
 	uint64_t txt_sr                       : 6;
 	uint64_t reserved_6_63                : 58;
@@ -1575,24 +1620,18 @@ union cvmx_gserx_cfg {
 	struct cvmx_gserx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t bgx_quad                     : 1;  /**< For non-OCI links, indicates the BGX is in quad
-                                                         aggregation mode when GSER_CFG.BGX is also set.
-                                                         A single controller is used for all 4 lanes.
-                                                         For OCI links this bit has no meaning. */
-	uint64_t bgx_dual                     : 1;  /**< For non-OCI links, indicates the BGX is
-                                                         in dual aggregation mode when GSER_CFG.BGX is also set.
-                                                         A single controller is used for lanes 0 & 1 and
-                                                         another controller is used for lanes 2 & 3.
-                                                         For OCI links this bit has no meaning. */
-	uint64_t bgx                          : 1;  /**< For non-OCI links, indicates the GSER is configured for BGX mode.
-                                                         Only one of the BGX, ILA, or PCIE modes can be set at any one time.
-                                                         For OCI links this bit has no meaning. */
-	uint64_t ila                          : 1;  /**< For non-OCI links, indicates the GSER is configured for ILK/ILA mode.
-                                                         Only one of the BGX, ILA, or PCIE modes can be set at any one time.
-                                                         For OCI links, this bit has no meaning. */
-	uint64_t pcie                         : 1;  /**< For non-OCI links, indicates the GSER is configured for PCIE mode.
-                                                         Only one of the BGX, ILA, or PCIE modes can be set at any one time.
-                                                         For OCI links this bit has no meaning. */
+	uint64_t bgx_quad                     : 1;  /**< For non-OCI links, indicates the BGX is in quad aggregation mode when GSER(0..13)_CFG[BGX]
+                                                         is also set. A single controller is used for all four lanes. For OCI links, this bit has
+                                                         no meaning. */
+	uint64_t bgx_dual                     : 1;  /**< For non-OCI links, indicates the BGX is in dual aggregation mode when GSER(0..13)_CFG[BGX]
+                                                         is also set. A single controller is used for lanes 0 and 1 and another controller is used
+                                                         for lanes 2 and 3. For OCI links, this bit has no meaning. */
+	uint64_t bgx                          : 1;  /**< For non-OCI links, indicates the GSER is configured for BGX mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For OCI links, this bit has no meaning. */
+	uint64_t ila                          : 1;  /**< For non-OCI links, indicates the GSER is configured for ILK/ILA mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For OCI links, this bit has no meaning. */
+	uint64_t pcie                         : 1;  /**< For non-OCI links, indicates the GSER is configured for PCIE mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For OCI links, this bit has no meaning. */
 #else
 	uint64_t pcie                         : 1;
 	uint64_t ila                          : 1;
@@ -1614,10 +1653,8 @@ union cvmx_gserx_dbg {
 	struct cvmx_gserx_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t rxqtm_on                     : 1;  /**< For non BGX/ILK configurations, setting this bit will
-                                                         enable the RX FIFOs. This allows recieved data to become
-                                                         visible to the RSL debug port.  It is not expected that
-                                                         SW will need to use this register. */
+	uint64_t rxqtm_on                     : 1;  /**< For non BGX/ILK configurations, setting this bit enables the RX FIFOs. This allows
+                                                         received data to become visible to the RSL debug port. For diagnostic use only. */
 #else
 	uint64_t rxqtm_on                     : 1;
 	uint64_t reserved_1_63                : 63;
@@ -1887,7 +1924,7 @@ union cvmx_gserx_dlmx_ref_ssp_en {
 	struct cvmx_gserx_dlmx_ref_ssp_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ref_ssp_en                   : 1;  /**< This signal should always be set. */
+	uint64_t ref_ssp_en                   : 1;  /**< Enables the PHY's internal reference clock. */
 #else
 	uint64_t ref_ssp_en                   : 1;
 	uint64_t reserved_1_63                : 63;
@@ -2472,10 +2509,8 @@ typedef union cvmx_gserx_iddq_mode cvmx_gserx_iddq_mode_t;
 /**
  * cvmx_gser#_lane#_p#_mode_0
  *
- * RAW PCS Per Lane Global Settings Mode 0 Register
- * Per Lane registers are specific to a paticular lane.
- * The Protocol selects the specific protocol register as
- * enumerated by GSER_LMODE_E.
+ * These are the RAW PCS per-lane global settings mode 0 registers. The Protocol selects the
+ * specific protocol register as enumerated by GSER_LMODE_E.
  */
 union cvmx_gserx_lanex_px_mode_0 {
 	uint64_t u64;
@@ -2483,92 +2518,92 @@ union cvmx_gserx_lanex_px_mode_0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
 	uint64_t ctle                         : 2;  /**< Continuous time linear equalizer pole configuration.
-                                                         0x0: ~5dB of peaking at 4 Ghz (Minimum bandwidth).
-                                                         0x1: ~10dB of peaking at 5 Ghz
-                                                         0x2: ~15dB of peaking at 5.5 Ghz
-                                                         0x3: ~20dB of peaking at 6 Ghz (Maximum bandwidth).
-                                                         Recommended Settings:
-                                                           25G_REFCLK100:                0x0
-                                                           5G_REFCLK100:                 0x0
-                                                           8G_REFCLK100:                 0x3
-                                                           125G_REFCLK15625_KX:          0x0
-                                                           3125G_REFCLK15625_XAUI:       0x0
-                                                           103215G_REFCLK15625_KR:       0x3
-                                                           125G_REFCLK15625_SGMII:       0x0
-                                                           5G_REFCLK15625_QSGMII:        0x0
-                                                           625G_REFCLK15625_RXAUI:       0x0
-                                                           25G_REFCLK125:                0x0
-                                                           5G_REFCLK125:                 0x0
-                                                           8G_REFCLK125:                 0x3 */
+                                                         0x0 = ~5dB of peaking at 4 GHz (Minimum bandwidth).
+                                                         0x1 =~10dB of peaking at 5 GHz
+                                                         0x2 = ~15dB of peaking at 5.5 GHz
+                                                         0x3 = ~20dB of peaking at 6 GHz (Maximum bandwidth).
+                                                         Recommended settings:
+                                                         25G_REFCLK100: 0x0
+                                                         5G_REFCLK100: 0x0
+                                                         8G_REFCLK100: 0x3
+                                                         125G_REFCLK15625_KX: 0x0
+                                                         3125G_REFCLK15625_XAUI: 0x0
+                                                         103215G_REFCLK15625_KR: 0x3
+                                                         125G_REFCLK15625_SGMII: 0x0
+                                                         5G_REFCLK15625_QSGMII: 0x0
+                                                         625G_REFCLK15625_RXAUI: 0x0
+                                                         25G_REFCLK125: 0x0
+                                                         5G_REFCLK125: 0x0
+                                                         8G_REFCLK125: 0x3 */
 	uint64_t pcie                         : 1;  /**< Selects between RX terminations.
                                                          - 0: Differential termination
-                                                         - 1: Termination between pad and sds_vdds.
-                                                          Recommended Settings:
-                                                            25G_REFCLK100:                0x1
-                                                            5G_REFCLK100:                 0x1
-                                                            8G_REFCLK100:                 0x0
-                                                            125G_REFCLK15625_KX:          0x0
-                                                            3125G_REFCLK15625_XAUI:       0x0
-                                                            103215G_REFCLK15625_KR:       0x0
-                                                            125G_REFCLK15625_SGMII:       0x0
-                                                            5G_REFCLK15625_QSGMII:        0x0
-                                                            625G_REFCLK15625_RXAUI:       0x0
-                                                            25G_REFCLK125:                0x1
-                                                            5G_REFCLK125:                 0x1
-                                                            8G_REFCLK125:                 0x0 */
-	uint64_t tx_ldiv                      : 2;  /**< Configues clock divider used to determine the receive rate. Encoding is:
-                                                         0x0: full data rate
-                                                         0x1: 1/2 data rate
-                                                         0x2: 1/4 data rate
-                                                         0x3: 1/8 data rate
-                                                         Recommended Settings:
-                                                           25G_REFCLK100:                0x1
-                                                           5G_REFCLK100:                 0x0
-                                                           8G_REFCLK100:                 0x0
-                                                           125G_REFCLK15625_KX:          0x2
-                                                           3125G_REFCLK15625_XAUI:       0x1
-                                                           103215G_REFCLK15625_KR:       0x0
-                                                           125G_REFCLK15625_SGMII:       0x2
-                                                           5G_REFCLK15625_QSGMII:        0x0
-                                                           625G_REFCLK15625_RXAUI:       0x0
-                                                           25G_REFCLK125:                0x1
-                                                           5G_REFCLK125:                 0x0
-                                                           8G_REFCLK125:                 0x0 */
-	uint64_t rx_ldiv                      : 2;  /**< Configues clock divider used to determine the receive rate. Encoding is:
-                                                         0x0: full data rate
-                                                         0x1: 1/2 data rate
-                                                         0x2: 1/4 data rate
-                                                         0x3: 1/8 data rate
-                                                         Recommended Settings:
-                                                           25G_REFCLK100:                0x1
-                                                           5G_REFCLK100:                 0x0
-                                                           8G_REFCLK100:                 0x0
-                                                           125G_REFCLK15625_KX:          0x2
-                                                           3125G_REFCLK15625_XAUI:       0x1
-                                                           103215G_REFCLK15625_KR:       0x0
-                                                           125G_REFCLK15625_SGMII:       0x2
-                                                           5G_REFCLK15625_QSGMII:        0x0
-                                                           625G_REFCLK15625_RXAUI:       0x0
-                                                           25G_REFCLK125:                0x1
-                                                           5G_REFCLK125:                 0x0
-                                                           8G_REFCLK125:                 0x0 */
-	uint64_t srate                        : 3;  /**< Sample Rate, Used to generate strobe to effectively divide the clock down
-                                                         to a slower rate.  Encoding is:
-                                                           0x0: full rate
-                                                           0x1: 1/2 data rate
-                                                           0x2: 1/4 data rate
-                                                           0x3: 1/8 data rate
-                                                           0x4: 1/16 data rate
-                                                           else = Reserved.
+                                                         - 1: Termination between pad and SDS_VDDS.
+                                                          Recommended settings:
+                                                          25G_REFCLK100: 0x1
+                                                          5G_REFCLK100: 0x1
+                                                          8G_REFCLK100: 0x0
+                                                          125G_REFCLK15625_KX: 0x0
+                                                          3125G_REFCLK15625_XAUI: 0x0
+                                                          103215G_REFCLK15625_KR: 0x0
+                                                          125G_REFCLK15625_SGMII: 0x0
+                                                          5G_REFCLK15625_QSGMII: 0x0
+                                                          625G_REFCLK15625_RXAUI: 0x0
+                                                          25G_REFCLK125: 0x1
+                                                          5G_REFCLK125: 0x1
+                                                          8G_REFCLK125: 0x0 */
+	uint64_t tx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate. Encoding is:
+                                                         0x0 = full data rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate.
+                                                         Recommended settings:
+                                                         25G_REFCLK100: 0x1
+                                                         5G_REFCLK100: 0x0
+                                                         8G_REFCLK100: 0x0
+                                                         125G_REFCLK15625_KX: 0x2
+                                                         3125G_REFCLK15625_XAUI: 0x1
+                                                         103215G_REFCLK15625_KR: 0x0
+                                                         125G_REFCLK15625_SGMII: 0x2
+                                                         5G_REFCLK15625_QSGMII: 0x0
+                                                         625G_REFCLK15625_RXAUI: 0x0
+                                                         25G_REFCLK125: 0x1
+                                                         5G_REFCLK125: 0x0
+                                                         8G_REFCLK125: 0x0 */
+	uint64_t rx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate. Encoding is:
+                                                         0x0 = full data rate
+                                                         0x1 = 1/2 data rate
+                                                         0x2 = 1/4 data rate
+                                                         0x3 = 1/8 data rate
+                                                         Recommended settings:
+                                                         25G_REFCLK100: 0x1
+                                                         5G_REFCLK100: 0x0
+                                                         8G_REFCLK100: 0x0
+                                                         125G_REFCLK15625_KX: 0x2
+                                                         3125G_REFCLK15625_XAUI: 0x1
+                                                         103215G_REFCLK15625_KR: 0x0
+                                                         125G_REFCLK15625_SGMII: 0x2
+                                                         5G_REFCLK15625_QSGMII: 0x0
+                                                         625G_REFCLK15625_RXAUI: 0x0
+                                                         25G_REFCLK125: 0x1
+                                                         5G_REFCLK125: 0x0
+                                                         8G_REFCLK125: 0x0 */
+	uint64_t srate                        : 3;  /**< Sample rate, used to generate strobe to effectively divide the clock down to a slower
+                                                         rate. Encoding is:
+                                                         0x0 = Full rate
+                                                         0x1 = 1/2 data rate
+                                                         0x2 = 1/4 data rate
+                                                         0x3 = 1/8 data rate
+                                                         0x4 = 1/16 data rate
+                                                         else = Reserved.
                                                          This field should always be set to zero (full rate). */
 	uint64_t reserved_4_4                 : 1;
-	uint64_t tx_mode                      : 2;  /**< TX Data Width:
-                                                         0x0 = 8-bit  raw data (not supported).
+	uint64_t tx_mode                      : 2;  /**< TX data width:
+                                                         0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
                                                          0x2 = 16-bit raw data (not supported).
                                                          0x3 = 20-bit raw data. */
-	uint64_t rx_mode                      : 2;  /**< RX Data Width:
-                                                         0x0 = 8-bit  raw data (not supported).
+	uint64_t rx_mode                      : 2;  /**< RX data width:
+                                                         0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
                                                          0x2 = 16-bit raw data (not supported).
                                                          0x3 = 20-bit raw data. */
@@ -2591,53 +2626,51 @@ typedef union cvmx_gserx_lanex_px_mode_0 cvmx_gserx_lanex_px_mode_0_t;
 /**
  * cvmx_gser#_lane#_p#_mode_1
  *
- * Per Lane registers are specific to a paticular lane.
- * The Protocol selects the specific protocol register as
- * enumerated by GSER_LMODE_E.
+ * The Protocol selects the specific protocol register as enumerated by GSER_LMODE_E.
+ *
  */
 union cvmx_gserx_lanex_px_mode_1 {
 	uint64_t u64;
 	struct cvmx_gserx_lanex_px_mode_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t vma_kr_sel                   : 1;  /**< Values at reset:
-                                                         1 = Enabled.  Fine step adaptation selected (10.3125Gbps rate).
-                                                         0 = Disabled.  Coarse step adaptation selected (rates lower than 10.3125Gbps). */
-	uint64_t vma_mm                       : 1;  /**< Manual DFE verses Adaptive DFE mode.
-                                                         Recommended Settings:
-                                                         0 = Adaptive DFE (5Gbps and higher)
-                                                         1 = Manual DFE, fixed tap (3.125Gbps and lower). */
+	uint64_t vma_fine_cfg_sel             : 1;  /**< Values at reset:
+                                                         1 = Enabled. Fine step adaptation selected (10.3125 Gbps rate).
+                                                         0 = Disabled. Coarse step adaptation selected (rates lower than 10.3125 Gbps). */
+	uint64_t vma_mm                       : 1;  /**< Manual DFE verses adaptive DFE mode. Recommended settings:
+                                                         0 = Adaptive DFE (5 Gbps and higher)
+                                                         1 = Manual DFE, fixed tap (3.125 Gbps and lower). */
 	uint64_t cdr_fgain                    : 4;  /**< CDR frequency gain. Values at reset:
-                                                         25G_REFCLK100:                0xa
-                                                         5G_REFCLK100:                 0xa
-                                                         8G_REFCLK100:                 0xb
-                                                         125G_REFCLK15625_KX:          0xc
-                                                         3125G_REFCLK15625_XAUI:       0xc
-                                                         103215G_REFCLK15625_KR:       0xa
-                                                         125G_REFCLK15625_SGMII:       0xc
-                                                         5G_REFCLK15625_QSGMII:        0xc
-                                                         625G_REFCLK15625_RXAUI:       0xa
-                                                         25G_REFCLK125:                0xa
-                                                         5G_REFCLK125:                 0xa
-                                                         8G_REFCLK125:                 0xb */
+                                                         25G_REFCLK100: 0xA
+                                                         5G_REFCLK100: 0xA
+                                                         8G_REFCLK100: 0xB
+                                                         125G_REFCLK15625_KX: 0xC
+                                                         3125G_REFCLK15625_XAUI: 0xC
+                                                         103215G_REFCLK15625_KR: 0xA
+                                                         125G_REFCLK15625_SGMII: 0xC
+                                                         5G_REFCLK15625_QSGMII: 0xC
+                                                         625G_REFCLK15625_RXAUI: 0xA
+                                                         25G_REFCLK125: 0xA
+                                                         5G_REFCLK125: 0xA
+                                                         8G_REFCLK125: 0xB */
 	uint64_t ph_acc_adj                   : 10; /**< Phase accumulator adjust. Values at reset:
-                                                         25G_REFCLK100:                0x14
-                                                         5G_REFCLK100:                 0x14
-                                                         8G_REFCLK100:                 0x23
-                                                         125G_REFCLK15625_KX:          0x1e
-                                                         3125G_REFCLK15625_XAUI:       0x1e
-                                                         103215G_REFCLK15625_KR:       0xf
-                                                         125G_REFCLK15625_SGMII:       0x1e
-                                                         5G_REFCLK15625_QSGMII:        0x1e
-                                                         625G_REFCLK15625_RXAUI:       0x14
-                                                         25G_REFCLK125:                0x14
-                                                         5G_REFCLK125:                 0x14
-                                                         8G_REFCLK125:                 0x23 */
+                                                         25G_REFCLK100: 0x14
+                                                         5G_REFCLK100: 0x14
+                                                         8G_REFCLK100: 0x23
+                                                         125G_REFCLK15625_KX: 0x1E
+                                                         3125G_REFCLK15625_XAUI: 0x1E
+                                                         103215G_REFCLK15625_KR: 0xF
+                                                         125G_REFCLK15625_SGMII: 0x1E
+                                                         5G_REFCLK15625_QSGMII: 0x1E
+                                                         625G_REFCLK15625_RXAUI: 0x14
+                                                         25G_REFCLK125: 0x14
+                                                         5G_REFCLK125: 0x14
+                                                         8G_REFCLK125: 0x23 */
 #else
 	uint64_t ph_acc_adj                   : 10;
 	uint64_t cdr_fgain                    : 4;
 	uint64_t vma_mm                       : 1;
-	uint64_t vma_kr_sel                   : 1;
+	uint64_t vma_fine_cfg_sel             : 1;
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
@@ -2646,26 +2679,103 @@ union cvmx_gserx_lanex_px_mode_1 {
 typedef union cvmx_gserx_lanex_px_mode_1 cvmx_gserx_lanex_px_mode_1_t;
 
 /**
- * cvmx_gser#_lane#_rx_valbbd_ctrl_0
+ * cvmx_gser#_lane#_rx_ctle_ctrl
+ *
+ * These are the RAW PCS per-lane RX CTLE control registers.
+ *
+ */
+union cvmx_gserx_lanex_rx_ctle_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_ctle_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_rx_ctle_bias_ctrl    : 2;  /**< CTLE bias trim bits.
+                                                         - 00: -10%
+                                                         - 01:   0%
+                                                         - 10: +5%
+                                                         - 11: +10%. */
+	uint64_t pcs_sds_rx_ctle_zero         : 4;  /**< Equalizer peaking control. */
+	uint64_t rx_ctle_pole_ovrrd_en        : 1;  /**< Equalizer pole adjustment override enable. */
+	uint64_t rx_ctle_pole_ovrrd_val       : 4;  /**< Equalizer pole adjustment override value.
+                                                         RX pre-correlation sample counter control
+                                                         bit 3: Optimize CTLE during training.
+                                                         bit 2: Turn off DFE1 for edge samplers.
+                                                         bits 1:0:
+                                                         - 00: ~ 5dB of peaking at 4.0 GHz.
+                                                         - 01: ~10dB of peaking at 5.0 GHz.
+                                                         - 10: ~15dB of peaking at 5.5 GHz.
+                                                         - 11: ~20dB of peaking at 6.0 GHz. */
+	uint64_t pcs_sds_rx_ctle_pole_max     : 2;  /**< Maximum pole value (for VMA adaption, not applicable in manual mode). */
+	uint64_t pcs_sds_rx_ctle_pole_min     : 2;  /**< Minimum pole value (for VMA adaption, not applicable in manual mode). */
+	uint64_t pcs_sds_rx_ctle_pole_step    : 1;  /**< Step pole value (for VMA adaption, not applicable in manual mode). */
+#else
+	uint64_t pcs_sds_rx_ctle_pole_step    : 1;
+	uint64_t pcs_sds_rx_ctle_pole_min     : 2;
+	uint64_t pcs_sds_rx_ctle_pole_max     : 2;
+	uint64_t rx_ctle_pole_ovrrd_val       : 4;
+	uint64_t rx_ctle_pole_ovrrd_en        : 1;
+	uint64_t pcs_sds_rx_ctle_zero         : 4;
+	uint64_t pcs_sds_rx_ctle_bias_ctrl    : 2;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_ctle_ctrl cvmx_gserx_lanex_rx_ctle_ctrl_t;
+
+/**
+ * cvmx_gser#_lane#_rx_precorr_ctrl
  *
- * RAW PCS Per Lane Coarse Adaptive Equalizer Control 0 Register
- * Per Lane registers are specific to a paticular lane.
+ * These are the RAW PCS per-lane RX precorrelation control registers. These registers are for
+ * diagnostic use only.
+ */
+union cvmx_gserx_lanex_rx_precorr_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_precorr_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t rx_precorr_disable           : 1;  /**< Disable RX precorrelation calculation. */
+	uint64_t rx_precorr_en_ovrrd_en       : 1;  /**< Override enable for RX precorrelation calculation enable. */
+	uint64_t rx_precorr_en_ovrrd_val      : 1;  /**< Override value for RX precorrelation calculation enable. */
+	uint64_t pcs_sds_rx_precorr_scnt_ctrl : 2;  /**< RX pre-correlation sample counter control.
+                                                         - 00: load max sample counter with 12'1FF.
+                                                         - 01: load max sample counter with 12'3FF.
+                                                         - 10: load max sample counter with 12'7FF.
+                                                         - 11: load max sample counter with 12'FFF. */
+#else
+	uint64_t pcs_sds_rx_precorr_scnt_ctrl : 2;
+	uint64_t rx_precorr_en_ovrrd_val      : 1;
+	uint64_t rx_precorr_en_ovrrd_en       : 1;
+	uint64_t rx_precorr_disable           : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_precorr_ctrl cvmx_gserx_lanex_rx_precorr_ctrl_t;
+
+/**
+ * cvmx_gser#_lane#_rx_valbbd_ctrl_0
  */
 union cvmx_gserx_lanex_rx_valbbd_ctrl_0 {
 	uint64_t u64;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t agc_gain                     : 2;  /**< AGC Gain. */
-	uint64_t dfe_gain                     : 2;  /**< DFE Gain. */
-	uint64_t dfe_c5_mval                  : 4;  /**< DFE Tap5 Manual Value when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
-	uint64_t dfe_c5_msgn                  : 1;  /**< DFE Tap5 Manual Sign when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
-	uint64_t dfe_c4_mval                  : 4;  /**< DFE Tap4 Manual Value when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
-	uint64_t dfe_c4_msgn                  : 1;  /**< DFE Tap4 Manual Sign when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
+	uint64_t agc_gain                     : 2;  /**< AGC gain. */
+	uint64_t dfe_gain                     : 2;  /**< DFE gain. */
+	uint64_t dfe_c5_mval                  : 4;  /**< DFE Tap5 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c5_msgn                  : 1;  /**< DFE Tap5 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c4_mval                  : 4;  /**< DFE Tap4 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c4_msgn                  : 1;  /**< DFE Tap4 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
 #else
 	uint64_t dfe_c4_msgn                  : 1;
 	uint64_t dfe_c4_mval                  : 4;
@@ -2682,33 +2792,34 @@ typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_0 cvmx_gserx_lanex_rx_valbbd_ctrl_
 
 /**
  * cvmx_gser#_lane#_rx_valbbd_ctrl_1
- *
- * RAW PCS Per Lane Coarse Adaptive Equalizer Control 1 Register
- * Per Lane registers are specific to a paticular lane.
  */
 union cvmx_gserx_lanex_rx_valbbd_ctrl_1 {
 	uint64_t u64;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t dfe_c3_mval                  : 4;  /**< DFE Tap3 Manual Value when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
-	uint64_t dfe_c3_msgn                  : 1;  /**< DFE Tap3 Manual Sign when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
-	uint64_t dfe_c2_mval                  : 4;  /**< DFE Tap2 Manual Value when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
-	uint64_t dfe_c2_msgn                  : 1;  /**< DFE Tap2 Manual Sign when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
-	uint64_t dfe_c1_mval                  : 4;  /**< DFE Tap1 Manual Value when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set.
-                                                         Recommended Settings:
-                                                           For the following modes; 5G_REFCLK100, 5G_REFCLK15625_QSGMII, and
-                                                           5G_REFCLK125, it is recommended that DFE_C1_MVAL be set to zero
-                                                           after setting GSER_LANE_MODE_1.VMA_MM and also after updating
-                                                           the GSER_LANE_RX_VALBBD_CTRL_2 register.
-                                                           In all other modes this register can be ignored. */
-	uint64_t dfe_c1_msgn                  : 1;  /**< DFE Tap1 Manual Sign when GSER_LANE_RX_VALBBD_CTRL_2.DFE_OVRD_EN
-                                                         and GSER_LANE_RX_VALBBD_CTRL_2.DFE_C5_OVRD_VAL are both set. */
+	uint64_t dfe_c3_mval                  : 4;  /**< DFE Tap3 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c3_msgn                  : 1;  /**< DFE Tap3 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c2_mval                  : 4;  /**< DFE Tap2 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c2_msgn                  : 1;  /**< DFE Tap2 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c1_mval                  : 4;  /**< DFE Tap1 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. Recommended settings: For the following modes:
+                                                         5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that DFE_C1_MVAL
+                                                         be set to zero after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM] and also after
+                                                         updating the GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2 register. In all other modes this
+                                                         register can be ignored. */
+	uint64_t dfe_c1_msgn                  : 1;  /**< DFE Tap1 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
+                                                         [DFE_C5_OVRD_VAL] are both set. */
 #else
 	uint64_t dfe_c1_msgn                  : 1;
 	uint64_t dfe_c1_mval                  : 4;
@@ -2725,55 +2836,38 @@ typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_1 cvmx_gserx_lanex_rx_valbbd_ctrl_
 
 /**
  * cvmx_gser#_lane#_rx_valbbd_ctrl_2
- *
- * RAW PCS Per Lane Equalizer Control 2 Register
- * Per Lane registers are specific to a paticular lane.
  */
 union cvmx_gserx_lanex_rx_valbbd_ctrl_2 {
 	uint64_t u64;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
-	uint64_t dfe_ovrd_en                  : 1;  /**< Overide enable for DFE tap controls.
-                                                         When asserted, the register bits in the GSER_LANE_RX_VALBBD_CTRL_1
-                                                         and GSER_LANE_RX_VALBBD_CTRL_1 registers are used for controlling
-                                                         the DFE tap manual mode, instead the manual mode signal indexed by
-                                                         the GSER_LANE_MODE.LMODE.
-                                                         Recommended Settings:
-                                                           For the following modes; 5G_REFCLK100, 5G_REFCLK15625_QSGMII, and
-                                                           5G_REFCLK125, it is recommended that DFE tap controls be put in
-                                                           manual mode by setting this bit.  In all other modes this register
-                                                           can be ignored. */
-	uint64_t dfe_c5_ovrd_val              : 1;  /**< Overide value for DFE Tap5 Manual Enable.
-                                                         Recommended Settings:
-                                                           For the following modes; 5G_REFCLK100, 5G_REFCLK15625_QSGMII, and
-                                                           5G_REFCLK125, it is recommended that the DFE Tap5 Manual Enable be
-                                                           set after setting GSER_LANE_MODE_1.VMA_MM.
-                                                           In all other modes this register can be ignored. */
-	uint64_t dfe_c4_ovrd_val              : 1;  /**< Overide value for DFE Tap4 Manual Enable.
-                                                         Recommended Settings:
-                                                           For the following modes; 5G_REFCLK100, 5G_REFCLK15625_QSGMII, and
-                                                           5G_REFCLK125, it is recommended that the DFE Tap4 Manual Enable be
-                                                           set after setting GSER_LANE_MODE_1.VMA_MM.
-                                                           In all other modes this register can be ignored. */
-	uint64_t dfe_c3_ovrd_val              : 1;  /**< Overide value for DFE Tap3 Manual Enable.
-                                                         Recommended Settings:
-                                                           For the following modes; 5G_REFCLK100, 5G_REFCLK15625_QSGMII, and
-                                                           5G_REFCLK125, it is recommended that the DFE Tap3 Manual Enable be
-                                                           set after setting GSER_LANE_MODE_1.VMA_MM.
-                                                           In all other modes this register can be ignored. */
-	uint64_t dfe_c2_ovrd_val              : 1;  /**< Overide value for DFE Tap2 Manual Enable.
-                                                         Recommended Settings:
-                                                           For the following modes; 5G_REFCLK100, 5G_REFCLK15625_QSGMII, and
-                                                           5G_REFCLK125, it is recommended that the DFE Tap2 Manual Enable be
-                                                           set after setting GSER_LANE_MODE_1.VMA_MM.
-                                                           In all other modes this register can be ignored. */
-	uint64_t dfe_c1_ovrd_val              : 1;  /**< Overide value for DFE Tap1 Manual Enable.
-                                                         Recommended Settings:
-                                                           For the following modes; 5G_REFCLK100, 5G_REFCLK15625_QSGMII, and
-                                                           5G_REFCLK125, it is recommended that the DFE Tap1 Manual Enable be
-                                                           set after setting GSER_LANE_MODE_1.VMA_MM.
-                                                           In all other modes this register can be ignored. */
+	uint64_t dfe_ovrd_en                  : 1;  /**< Override enable for DFE tap controls. When asserted, the register bits in
+                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_0 and GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_1 are
+                                                         used for controlling the DFE tap manual mode, instead the manual mode signal indexed by
+                                                         GSER(0..13)_LANE_MODE[LMODE]. Recommended settings: For the following modes: 5G_REFCLK100,
+                                                         5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that DFE tap controls be put in
+                                                         manual mode by setting this bit. In all other modes this register can be ignored. */
+	uint64_t dfe_c5_ovrd_val              : 1;  /**< Override value for DFE Tap5 manual enable. Recommended settings: For the following modes;
+                                                         5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap5
+                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         other modes this register can be ignored. */
+	uint64_t dfe_c4_ovrd_val              : 1;  /**< Override value for DFE Tap4 manual enable. Recommended settings: For the following modes:
+                                                         5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap4
+                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         other modes this register can be ignored. */
+	uint64_t dfe_c3_ovrd_val              : 1;  /**< Override value for DFE Tap3 manual enable. Recommended settings: For the following modes;
+                                                         5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap3
+                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         other modes this register can be ignored. */
+	uint64_t dfe_c2_ovrd_val              : 1;  /**< Override value for DFE Tap2 manual enable. Recommended settings: For the following modes;
+                                                         5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap2
+                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         other modes this register can be ignored. */
+	uint64_t dfe_c1_ovrd_val              : 1;  /**< Override value for DFE Tap1 manual enable. Recommended settings: For the following modes;
+                                                         5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap1
+                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         other modes this register can be ignored. */
 #else
 	uint64_t dfe_c1_ovrd_val              : 1;
 	uint64_t dfe_c2_ovrd_val              : 1;
@@ -2789,24 +2883,60 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_2 {
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_2 cvmx_gserx_lanex_rx_valbbd_ctrl_2_t;
 
 /**
+ * cvmx_gser#_lane#_rx_vma_ctrl
+ *
+ * These are the RAW PCS per-lane RX VMA control registers. These registers are for diagnostic
+ * use only.
+ */
+union cvmx_gserx_lanex_rx_vma_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_vma_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t vma_fine_cfg_sel_ovrrd_en    : 1;  /**< Enable override of VMA fine configuration selection. */
+	uint64_t vma_fine_cfg_sel_ovrrd_val   : 1;  /**< Override value of VMA fine configuration selection.
+                                                         - 0: Coarse mode.
+                                                         - 1: Fine mode. */
+	uint64_t rx_fom_div_delta             : 1;  /**< TX figure of merit delta division-mode enable. */
+	uint64_t rx_vna_ctrl_18_16            : 3;  /**< RX VMA loop control. */
+	uint64_t rx_vna_ctrl_9_0              : 10; /**< RX VMA loop control.
+                                                         bits 9:8: Parameter settling wait time.
+                                                         bit 7: Limit CTLE peak to max value.
+                                                         bit 6: Long reach enabled.
+                                                         bit 5: Short reach enabled.
+                                                         bit 4: Training done override enable.
+                                                         bit 3: Training done override value.
+                                                         bits 2:0: VMA clock modulation. */
+#else
+	uint64_t rx_vna_ctrl_9_0              : 10;
+	uint64_t rx_vna_ctrl_18_16            : 3;
+	uint64_t rx_fom_div_delta             : 1;
+	uint64_t vma_fine_cfg_sel_ovrrd_val   : 1;
+	uint64_t vma_fine_cfg_sel_ovrrd_en    : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_vma_ctrl cvmx_gserx_lanex_rx_vma_ctrl_t;
+
+/**
  * cvmx_gser#_lane#_vma_coarse_ctrl_0
  *
- * RAW PCS Per Lane Coarse VMA Control Configuration 0 Register
- * Per Lane registers are specific to a paticular lane.
- * It is not expected that software will need to access this register.
+ * These registers are for diagnostic use only.
+ *
  */
 union cvmx_gserx_lanex_vma_coarse_ctrl_0 {
 	uint64_t u64;
 	struct cvmx_gserx_lanex_vma_coarse_ctrl_0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t iq_max                       : 4;  /**< Slice DLL IQ Maximum Value in VMA Coarse Mode. */
-	uint64_t iq_min                       : 4;  /**< Slice DLL IQ Minimum Value in VMA Coarse Mode. */
-	uint64_t iq_step                      : 2;  /**< Slice DLL IQ step size in VMA Coarse Mode. */
-	uint64_t window_wait                  : 3;  /**< Adaptation window wait setting in VMA Coarse Mode. */
-	uint64_t lms_wait                     : 3;  /**< LMS wait time setting used to control the number
-                                                         of samples taken during the collection of
-                                                         statistics in VMA Coarse Mode. */
+	uint64_t iq_max                       : 4;  /**< Slice DLL IQ maximum value in VMA coarse mode. */
+	uint64_t iq_min                       : 4;  /**< Slice DLL IQ minimum value in VMA coarse mode. */
+	uint64_t iq_step                      : 2;  /**< Slice DLL IQ step size in VMA coarse mode. */
+	uint64_t window_wait                  : 3;  /**< Adaptation window wait setting in VMA coarse mode. */
+	uint64_t lms_wait                     : 3;  /**< LMS wait time setting used to control the number of samples taken during the collection of
+                                                         statistics in VMA coarse mode. */
 #else
 	uint64_t lms_wait                     : 3;
 	uint64_t window_wait                  : 3;
@@ -2823,18 +2953,17 @@ typedef union cvmx_gserx_lanex_vma_coarse_ctrl_0 cvmx_gserx_lanex_vma_coarse_ctr
 /**
  * cvmx_gser#_lane#_vma_coarse_ctrl_1
  *
- * RAW PCS Per Lane Coarse VMA Control Configuration 1 Register
- * Per Lane registers are specific to a paticular lane.
- * It is not expected that software will need to access this register.
+ * These registers are for diagnostic use only.
+ *
  */
 union cvmx_gserx_lanex_vma_coarse_ctrl_1 {
 	uint64_t u64;
 	struct cvmx_gserx_lanex_vma_coarse_ctrl_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t ctle_pmax                    : 4;  /**< RX CTLE peak maximum value in VMA Coarse Mode. */
-	uint64_t ctle_pmin                    : 4;  /**< RX CTLE peak minimum value in VMA Coarse Mode */
-	uint64_t ctle_pstep                   : 2;  /**< CTLE peak step size in VMA Coarse Mode. */
+	uint64_t ctle_pmax                    : 4;  /**< RX CTLE peak maximum value in VMA coarse mode. */
+	uint64_t ctle_pmin                    : 4;  /**< RX CTLE peak minimum value in VMA coarse mode. */
+	uint64_t ctle_pstep                   : 2;  /**< CTLE peak step size in VMA coarse mode. */
 #else
 	uint64_t ctle_pstep                   : 2;
 	uint64_t ctle_pmin                    : 4;
@@ -2849,17 +2978,17 @@ typedef union cvmx_gserx_lanex_vma_coarse_ctrl_1 cvmx_gserx_lanex_vma_coarse_ctr
 /**
  * cvmx_gser#_lane#_vma_coarse_ctrl_2
  *
- * Per Lane registers are specific to a paticular lane.
- * It is not expected that software will need to access this register.
+ * These registers are for diagnostic use only.
+ *
  */
 union cvmx_gserx_lanex_vma_coarse_ctrl_2 {
 	uint64_t u64;
 	struct cvmx_gserx_lanex_vma_coarse_ctrl_2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t pctle_gmax                   : 4;  /**< RX PRE-CTLE gain maximum value in VMA Coarse Mode. */
-	uint64_t pctle_gmin                   : 4;  /**< RX PRE-CTLE gain minimum value in VMA Coarse Mode. */
-	uint64_t pctle_gstep                  : 2;  /**< CTLE PRE-peak gain step size in VMA Coarse Mode */
+	uint64_t pctle_gmax                   : 4;  /**< RX PRE-CTLE gain maximum value in VMA coarse mode. */
+	uint64_t pctle_gmin                   : 4;  /**< RX PRE-CTLE gain minimum value in VMA coarse mode. */
+	uint64_t pctle_gstep                  : 2;  /**< CTLE PRE-peak gain step size in VMA coarse mode. */
 #else
 	uint64_t pctle_gstep                  : 2;
 	uint64_t pctle_gmin                   : 4;
@@ -2872,6 +3001,107 @@ union cvmx_gserx_lanex_vma_coarse_ctrl_2 {
 typedef union cvmx_gserx_lanex_vma_coarse_ctrl_2 cvmx_gserx_lanex_vma_coarse_ctrl_2_t;
 
 /**
+ * cvmx_gser#_lane#_vma_fine_ctrl_0
+ *
+ * These registers are for diagnostic use only.
+ *
+ */
+union cvmx_gserx_lanex_vma_fine_ctrl_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_vma_fine_ctrl_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t rx_sdll_iq_max_fine          : 4;  /**< RX Slice DLL IQ maximum value in VMA Fine mode (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_FINE_CFG_SEL]=1 and
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+	uint64_t rx_sdll_iq_min_fine          : 4;  /**< RX slice DLL IQ minimum value in VMA fine mode (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_FINE_CFG_SEL]=1 and
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+	uint64_t rx_sdll_iq_step_fine         : 2;  /**< RX Slice DLL IQ step size in VMA Fine mode (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_FINE_CFG_SEL]=1 and
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+	uint64_t vma_window_wait_fine         : 3;  /**< Adaptation window wait setting (in VMA fine mode); used to control the number of samples
+                                                         taken during the collection of statistics (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
+                                                         [VMA_FINE_CFG_SEL]=1 and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+	uint64_t lms_wait_time_fine           : 3;  /**< LMS wait time setting (in VMA fine mode); used to control the number of samples taken
+                                                         during the collection of statistics (valid when GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
+                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+#else
+	uint64_t lms_wait_time_fine           : 3;
+	uint64_t vma_window_wait_fine         : 3;
+	uint64_t rx_sdll_iq_step_fine         : 2;
+	uint64_t rx_sdll_iq_min_fine          : 4;
+	uint64_t rx_sdll_iq_max_fine          : 4;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_vma_fine_ctrl_0_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_vma_fine_ctrl_0 cvmx_gserx_lanex_vma_fine_ctrl_0_t;
+
+/**
+ * cvmx_gser#_lane#_vma_fine_ctrl_1
+ *
+ * These registers are for diagnostic use only.
+ *
+ */
+union cvmx_gserx_lanex_vma_fine_ctrl_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_vma_fine_ctrl_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t rx_ctle_peak_max_fine        : 4;  /**< RX CTLE peak maximum value in VMA fine mode (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
+                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+	uint64_t rx_ctle_peak_min_fine        : 4;  /**< RX CTLE peak minimum value in VMA fine mode (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
+                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+	uint64_t rx_ctle_peak_step_fine       : 2;  /**< RX CTLE Peak step size in VMA Fine mode (valid when GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
+                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+#else
+	uint64_t rx_ctle_peak_step_fine       : 2;
+	uint64_t rx_ctle_peak_min_fine        : 4;
+	uint64_t rx_ctle_peak_max_fine        : 4;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_vma_fine_ctrl_1_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_vma_fine_ctrl_1 cvmx_gserx_lanex_vma_fine_ctrl_1_t;
+
+/**
+ * cvmx_gser#_lane#_vma_fine_ctrl_2
+ *
+ * These registers are for diagnostic use only.
+ *
+ */
+union cvmx_gserx_lanex_vma_fine_ctrl_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_vma_fine_ctrl_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t rx_prectle_peak_max_fine     : 4;  /**< RX PRE-CTLE peak maximum value in VMA fine mode (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
+                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+	uint64_t rx_prectle_peak_min_fine     : 4;  /**< RX PRE-CTLE peak minimum value in VMA fine mode (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
+                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+	uint64_t rx_prectle_peak_step_fine    : 2;  /**< RX PRE-CTLE peak step size in VMA fine mode (valid when
+                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
+                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+#else
+	uint64_t rx_prectle_peak_step_fine    : 2;
+	uint64_t rx_prectle_peak_min_fine     : 4;
+	uint64_t rx_prectle_peak_max_fine     : 4;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_vma_fine_ctrl_2_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_vma_fine_ctrl_2 cvmx_gserx_lanex_vma_fine_ctrl_2_t;
+
+/**
  * cvmx_gser#_lane_lpbken
  */
 union cvmx_gserx_lane_lpbken {
@@ -2879,9 +3109,8 @@ union cvmx_gserx_lane_lpbken {
 	struct cvmx_gserx_lane_lpbken_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE mode (including all OCI links).
-                                                         When asserted in P0 state, allows per lane Tx-to-Rx serial
-                                                         loopback activation.
+	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE mode (including all OCI links). When asserted in P0 state,
+                                                         allows per lane TX-to-RX serial loopback activation.
                                                          <3>: Lane 3
                                                          <2>: Lane 2
                                                          <1>: Lane 1
@@ -2903,40 +3132,38 @@ union cvmx_gserx_lane_mode {
 	struct cvmx_gserx_lane_mode_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         used to index into the PHY table to select electricals and link rate.
-                                                         Note that the PHY table can be modified such that any supported link rate
-                                                         can be derived regardless of the configured LMODE.
-                                                         0x0:   25G_REFCLK100
-                                                         0x1:   5G_REFCLK100
-                                                         0x2:   8G_REFCLK100
-                                                         0x3:   125G_REFCLK15625_KX
-                                                         0x4:   3125G_REFCLK15625_XAUI
-                                                         0x5:   103215G_REFCLK15625_KR
-                                                         0x6:   125G_REFCLK15625_SGMII
-                                                         0x7:   5G_REFCLK15625_QSGMII
-                                                         0x8:   625G_REFCLK15625_RXAUI
-                                                         0x9:   25G_REFCLK125
-                                                         0xa:   5G_REFCLK125
-                                                         0xb:   8G_REFCLK125
-                                                         0xc - 0xf: reserved
-                                                         This register is not used for PCIE configurations.
-                                                         For non-OCI links, this registers defaults to 625G_REFCLK15625_RXAUI.
-                                                         For OCI links, the value is mapped at reset from the GSER_SPD and the
-                                                         appropriate table updates are performed so the rate is obtained for the
-                                                         paticular reference clock.
+	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), used to index into the PHY
+                                                         table to select electrical specs and link rate. Note that the PHY table can be modified
+                                                         such that any supported link rate can be derived regardless of the configured LMODE.
+                                                         0x0: 25G_REFCLK100
+                                                         0x1: 5G_REFCLK100
+                                                         0x2: 8G_REFCLK100
+                                                         0x3: 125G_REFCLK15625_KX
+                                                         0x4: 3125G_REFCLK15625_XAUI
+                                                         0x5: 103215G_REFCLK15625_KR
+                                                         0x6: 125G_REFCLK15625_SGMII
+                                                         0x7: 5G_REFCLK15625_QSGMII
+                                                         0x8: 625G_REFCLK15625_RXAUI
+                                                         0x9: 25G_REFCLK125
+                                                         0xA: 5G_REFCLK125
+                                                         0xB: 8G_REFCLK125
+                                                         0xC - 0xF: reserved
+                                                         This register is not used for PCIE configurations. For non-OCI links, this registers
+                                                         defaults to 625G_REFCLK15625_RXAUI. For OCI links, the value is mapped at reset from the
+                                                         GSER_SPD and the appropriate table updates are performed so the rate is obtained for the
+                                                         particular reference clock.
                                                          It is recommended that the PHY be in reset when reconfiguring the LMODE
-                                                         (GSER_PHY_CTL.PHY_RESET is set).  If the LMODE is modified when the PHY
-                                                         is out of reset, the GSER_RXTX_STAT.LMC can be used to determine when the
-                                                         PHY has transitioned to the new setting.
-                                                         Once the LMODE has been configured, and the PHY is out of reset, the table
-                                                         entries for the selected LMODE must be updated to reflect the reference
-                                                         clock speed.  Refer to the register description and index into the table
-                                                         using the rate and reference speed to obtain the recommended values.
-                                                          - 1: Write the GSER_PLL_P(0..11)_MODE_0 register
-                                                          - 2: Write the GSER_PLL_P(0..11)_MODE_1 register
-                                                          - 3: Write the GSER_LANE_P(0..11)_MODE_0 register
-                                                          - 4: Write the GSER_LANE_P(0..11)_MODE_1 register */
+                                                         (GSER(0..13)_PHY_CTL[PHY_RESET] is set). If the LMODE is modified when the PHY is out of
+                                                         reset, the GSER(0..13)_RXTX_STAT[LMC] can be used to determine when the PHY has
+                                                         transitioned to the new setting.
+                                                         Once the LMODE has been configured, and the PHY is out of reset, the table entries for the
+                                                         selected LMODE must be updated to reflect the reference clock speed. Refer to the register
+                                                         description and index into the table using the rate and reference speed to obtain the
+                                                         recommended values.
+                                                         Write GSER(0..13)_PLL_P(0..11)_MODE_0.
+                                                         Write GSER(0..13)_PLL_P(0..11)_MODE_1.
+                                                         Write GSER(0..13)_LANE(0..3)_P(0..11)_MODE_0.
+                                                         Write GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1. */
 #else
 	uint64_t lmode                        : 4;
 	uint64_t reserved_4_63                : 60;
@@ -2954,12 +3181,12 @@ union cvmx_gserx_lane_poff {
 	struct cvmx_gserx_lane_poff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t lpoff                        : 4;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         allows for per lane power down.
+	uint64_t lpoff                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), allows for per lane power
+                                                         down.
                                                          <3>: Lane 3
                                                          <2>: Lane 2
                                                          <1>: Lane 1
-                                                         <0>: Lane 0. */
+                                                         <0>: Lane 0 */
 #else
 	uint64_t lpoff                        : 4;
 	uint64_t reserved_4_63                : 60;
@@ -2976,21 +3203,15 @@ union cvmx_gserx_lane_srst {
 	uint64_t u64;
 	struct cvmx_gserx_lane_srst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
-	uint64_t lsrst                        : 4;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         resets specific lane (equivalent to the P2 power state) after
-                                                         any pending requests (power state change, rate change) are complete.
-                                                         <3>: Lane 3
-                                                         <2>: Lane 2
-                                                         <1>: Lane 1
-                                                         <0>: Lane 0
-                                                         The lane remains in reset state while this signal is asserted.
-                                                         When the signal deasserts, the lane exits the reset state and
-                                                         the PHY returns to the power state the PHY was in prior.
-                                                         It is not expected that SW will need to use this register. */
+	uint64_t reserved_1_63                : 63;
+	uint64_t lsrst                        : 1;  /**< For links that are not in PCIE mode (including all OCI links), resets all 4 lanes
+                                                         (equivalent to the P2 power state) after any pending requests (power state change, rate
+                                                         change) are complete. The lanes remain in reset state while this signal is asserted. When
+                                                         the signal deasserts, the lanes exit the reset state and the PHY returns to the power
+                                                         state the PHY was in prior. For diagnostic use only. */
 #else
-	uint64_t lsrst                        : 4;
-	uint64_t reserved_4_63                : 60;
+	uint64_t lsrst                        : 1;
+	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
 	struct cvmx_gserx_lane_srst_s         cn78xx;
@@ -3700,7 +3921,7 @@ typedef union cvmx_gserx_phyx_lane1_txdebug cvmx_gserx_phyx_lane1_txdebug_t;
 /**
  * cvmx_gser#_phy_ctl
  *
- * General PHY/PLL control of the RAW PCS.
+ * This register contains general PHY/PLL control of the RAW PCS.
  *
  */
 union cvmx_gserx_phy_ctl {
@@ -3708,12 +3929,11 @@ union cvmx_gserx_phy_ctl {
 	struct cvmx_gserx_phy_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t phy_reset                    : 1;  /**< When asserted, the PHY is held in reset. This bit is initialized
-                                                         as follows:
-                                                           0 (not reset): bootable PCIe, or OCI when GSER_SPD.SPD
-                                                                          comes up in a bootable mode.
-                                                           1 (reset):     non-bootable PCIe, BGX/ILK, or OCI when GSER_SPD.SPD
-                                                                          comes up in SW_MODE. */
+	uint64_t phy_reset                    : 1;  /**< When asserted, the PHY is held in reset. This bit is initialized as follows:
+                                                         0 (not reset): Bootable PCIe, or OCI when GSER(0..13)_SPD[SPD] comes up in a bootable
+                                                         mode.
+                                                         1 (reset): Non-bootable PCIe, BGX/ILK, or OCI when GSER(0..13)_SPD[SPD] comes up in
+                                                         SW_MODE. */
 	uint64_t phy_pd                       : 1;  /**< When asserted, the PHY is powered down. */
 #else
 	uint64_t phy_pd                       : 1;
@@ -3733,9 +3953,8 @@ union cvmx_gserx_pipe_lpbk {
 	struct cvmx_gserx_pipe_lpbk_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t pcie_lpbk                    : 1;  /**< For links that are in PCIE mode, places the PHY in Serial
-                                                         Loopback mode, where the tx_n/p data are looped back to the
-                                                         rx_n/p. */
+	uint64_t pcie_lpbk                    : 1;  /**< For links that are in PCIE mode, places the PHY in serial loopback mode, where the
+                                                         QLMn_TXN/QLMn_TXP data are looped back to the QLMn_RXN/QLMn_RXP. */
 #else
 	uint64_t pcie_lpbk                    : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3748,21 +3967,18 @@ typedef union cvmx_gserx_pipe_lpbk cvmx_gserx_pipe_lpbk_t;
 /**
  * cvmx_gser#_pll_p#_mode_0
  *
- * RAW PCS PLL Global Settings Mode 0 Register
- * Global registers are shared across the entire PCS
- * The Protocol selects the specific protocol register as
- * enumerated by GSER_LMODE_E.
+ * These are the RAW PCS PLL global settings mode 0 registers. Global registers are shared across
+ * the entire PCS. The Protocol selects the specific protocol register as enumerated by
+ * GSER_LMODE_E.
  */
 union cvmx_gserx_pll_px_mode_0 {
 	uint64_t u64;
 	struct cvmx_gserx_pll_px_mode_0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t pll_icp                      : 4;  /**< PLL Charge pump enable.
-                                                         This field must be set appropriately if running a GSER_LANE_MODE.LMODE
-                                                         with a non-default reference clock.  A "NS" indicates that the rate
-                                                         is not supported at the specified reference clock.
-                                                         Recommended Settings:
+	uint64_t pll_icp                      : 4;  /**< PLL charge pump enable. This field must be set appropriately if running a
+                                                         GSER(0..13)_LANE_MODE[LMODE] with a non-default reference clock. A 'NS' indicates that the
+                                                         rate is not supported at the specified reference clock. Recommended settings:
                                                                          100Mhz          125Mhz          156.25Mhz
                                                          1.25G:          0x1             0x1             0x1
                                                          2.5G:           0x4             0x3             0x3
@@ -3771,32 +3987,29 @@ union cvmx_gserx_pll_px_mode_0 {
                                                          6.25G:          NS              0x1             0x1
                                                          8.0G:           0x3             0x2             NS
                                                          10.3215G:       NS              NS              0x1 */
-	uint64_t pll_rloop                    : 3;  /**< Loop resistor tuning.
-                                                         This field must be set appropriately if running a GSER_LANE_MODE.LMODE with
-                                                         a non-default reference clock.  A "NS" indicates that the rate
-                                                         is not supported at the specified reference clock.
-                                                         Recommended Settings:
-                                                         1.25G:          0x3
-                                                         2.5G:           0x3
-                                                         3.125G:         0x3
-                                                         5.0G:           0x3
-                                                         6.25G:          0x3
-                                                         8.0G:           0x5
-                                                         10.3215G:       0x5 */
-	uint64_t pll_pcs_div                  : 9;  /**< The divider that generates pcs_mac_tx_clk. The frequency
-                                                         of the clock is (pll_frequency / PLL_PCS_DIV).
-                                                         This field must be set appropriately if running a GSER_LANE_MODE.LMODE with
-                                                         a non-default reference clock or doesn't default to a 20-bit RX/TX data path.
-                                                         A "NS" indicates that the rate is not supported at the specified reference clock.
-                                                         Recommended Settings:
-                                                         1.25G:          0x28
-                                                         2.5G:           0x5
-                                                         3.125G:         0x24
-                                                         5.0G:           0xa (100 Mhz REFCLK)
-                                                         5.0G:           0x5 (156.25 Mhz REFCLK)
-                                                         6.25G:          0xa
-                                                         8.0G:           0xa
-                                                         10.3215G:       0x24 */
+	uint64_t pll_rloop                    : 3;  /**< Loop resistor tuning. This field must be set appropriately if running a
+                                                         GSER(0..13)_LANE_MODE[LMODE] with a non-default reference clock. A 'NS' indicates that the
+                                                         rate is not supported at the specified reference clock. Recommended settings:
+                                                         1.25G: 0x3
+                                                         2.5G: 0x3
+                                                         3.125G: 0x3
+                                                         5.0G: 0x3
+                                                         6.25G: 0x3
+                                                         8.0G: 0x5
+                                                         10.3215G: 0x5 */
+	uint64_t pll_pcs_div                  : 9;  /**< The divider that generates PCS_MAC_TX_CLK. The frequency of the clock is (pll_frequency /
+                                                         PLL_PCS_DIV). This field must be set appropriately if running a
+                                                         GSER(0..13)_LANE_MODE[LMODE] with a non-default reference clock or doesn't default to a
+                                                         20-bit RX/TX data path. A 'NS' indicates that the rate is not supported at the specified
+                                                         reference clock. Recommended settings:
+                                                         1.25G: 0x28
+                                                         2.5G: 0x5
+                                                         3.125G: 0x24
+                                                         5.0G: 0xA (100 MHz REFCLK)
+                                                         5.0G: 0x5 (156.25 MHz REFCLK)
+                                                         6.25G: 0xA
+                                                         8.0G: 0xA
+                                                         10.3215G: 0x24 */
 #else
 	uint64_t pll_pcs_div                  : 9;
 	uint64_t pll_rloop                    : 3;
@@ -3811,20 +4024,18 @@ typedef union cvmx_gserx_pll_px_mode_0 cvmx_gserx_pll_px_mode_0_t;
 /**
  * cvmx_gser#_pll_p#_mode_1
  *
- * Global registers are shared across the entire PCS
- * The Protocol selects the specific protocol register as
- * enumerated by GSER_LMODE_E.
+ * Global registers are shared across the entire PCS. The Protocol selects the specific protocol
+ * register as enumerated by GSER_LMODE_E.
  */
 union cvmx_gserx_pll_px_mode_1 {
 	uint64_t u64;
 	struct cvmx_gserx_pll_px_mode_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t pll_16p5en                   : 1;  /**< Enable for the div 16.5 divided down clock.
-                                                         This field must be set appropriately if running a GSER_LANE_MODE.LMODE with
-                                                         a non-default reference clock.  A "NS" indicates that the rate
-                                                         is not supported at the specified reference clock.
-                                                         Recommended Settings:
+	uint64_t pll_16p5en                   : 1;  /**< Enable for the DIV 16.5 divided down clock. This field must be set appropriately if
+                                                         running a GSER(0..13)_LANE_MODE[LMODE] with a non-default reference clock. A 'NS'
+                                                         indicates that the rate is not supported at the specified reference clock. Recommended
+                                                         settings:
                                                                          100Mhz          125Mhz          156.25Mhz
                                                          1.25G:          0x1             0x1             0x1
                                                          2.5G:           0x0             0x0             0x0
@@ -3833,11 +4044,9 @@ union cvmx_gserx_pll_px_mode_1 {
                                                          6.25G:          NS              0x0             0x0
                                                          8.0G:           0x0             0x0             NS
                                                          10.3215G:       NS              NS              0x1 */
-	uint64_t pll_cpadj                    : 2;  /**< PLL Charge adjust.
-                                                         This field must be set appropriately if running a GSER_LANE_MODE.LMODE with
-                                                         a non-default reference clock.  A "NS" indicates that the rate
-                                                         is not supported at the specified reference clock.
-                                                         Recommended Settings:
+	uint64_t pll_cpadj                    : 2;  /**< PLL charge adjust. This field must be set appropriately if running a
+                                                         GSER(0..13)_LANE_MODE[LMODE] with a non-default reference clock. A 'NS' indicates that the
+                                                         rate is not supported at the specified reference clock. Recommended settings:
                                                                          100Mhz          125Mhz          156.25Mhz
                                                          1.25G:          0x2             0x2             0x3
                                                          2.5G:           0x2             0x1             0x2
@@ -3846,21 +4055,16 @@ union cvmx_gserx_pll_px_mode_1 {
                                                          6.25G:          NS              0x2             0x2
                                                          8.0G:           0x2             0x1             NS
                                                          10.3215G:       NS              NS              0x2 */
-	uint64_t pll_pcie3en                  : 1;  /**< Enable PCIE3 Mode.
-                                                         Recommended Settings:
-                                                          - 0: = any rate other than 8Gbps.
-                                                          - 1: = rate is equal to 8Gbps. */
-	uint64_t pll_opr                      : 1;  /**< Pll Op Range
-                                                         - 0: Use Ring Oscillator VCO
-                                                         - 1: Use LC-tank VCO
-                                                          Recommended Settings:
-                                                           - 0: = rates 6.25Gbps and lower.
-                                                           - 1: = rates 8Gbps and higher. */
-	uint64_t pll_div                      : 9;  /**< PLL divider in feedback path which sets the PLL frequency.
-                                                         This field must be set appropriately if running a GSER_LANE_MODE.LMODE with
-                                                         a non-default reference clock.  A "NS" indicates that the rate
-                                                         is not supported at the specified reference clock.
-                                                         Recommended Settings:
+	uint64_t pll_pcie3en                  : 1;  /**< Enable PCIE3 mode. Recommended settings:
+                                                         0 = Any rate other than 8 Gbps.
+                                                         1 = Rate is equal to 8 Gbps. */
+	uint64_t pll_opr                      : 1;  /**< PLL op range:
+                                                         0 = Use Ring Oscillator VCO. Recommended for rates 6.25 Gbps and lower.
+                                                         1 = Use LC-tank VCO. Recommended for rates 8 Gbps and higher. */
+	uint64_t pll_div                      : 9;  /**< PLL divider in feedback path which sets the PLL frequency. This field must be set
+                                                         appropriately if running a GSER(0..13)_LANE_MODE[LMODE] with a non-default reference
+                                                         clock. A 'NS' indicates that the rate is not supported at the specified reference clock.
+                                                         Recommended settings:
                                                                          100Mhz          125Mhz          156.25Mhz
                                                          1.25G:          0x19            0x14            0x10
                                                          2.5G:           0x19            0x14            0x10
@@ -3890,7 +4094,7 @@ union cvmx_gserx_pll_stat {
 	struct cvmx_gserx_pll_stat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t pll_lock                     : 1;  /**< When set, inidcates that the PHY PLL is locked. */
+	uint64_t pll_lock                     : 1;  /**< When set, indicates that the PHY PLL is locked. */
 #else
 	uint64_t pll_lock                     : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3908,11 +4112,9 @@ union cvmx_gserx_qlm_stat {
 	struct cvmx_gserx_qlm_stat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t rst_rdy                      : 1;  /**< When asserted, the QLM is configured (CSR_GSER_CAV_CFG)
-                                                         and the PLLs are stable. The GSER is ready to accept
-                                                         tx traffic from the MAC. */
-	uint64_t dcok                         : 1;  /**< When asserted, there is a PLL reference clock indicating there
-                                                         is power to the QLM. */
+	uint64_t rst_rdy                      : 1;  /**< When asserted, the QLM is configured (CSR_GSER_CAV_CFG) and the PLLs are stable. The GSER
+                                                         is ready to accept TX traffic from the MAC. */
+	uint64_t dcok                         : 1;  /**< When asserted, there is a PLL reference clock indicating there is power to the QLM. */
 #else
 	uint64_t dcok                         : 1;
 	uint64_t rst_rdy                      : 1;
@@ -3925,21 +4127,24 @@ typedef union cvmx_gserx_qlm_stat cvmx_gserx_qlm_stat_t;
 
 /**
  * cvmx_gser#_refclk_sel
+ *
+ * This register selects the reference clock.
+ *
  */
 union cvmx_gserx_refclk_sel {
 	uint64_t u64;
 	struct cvmx_gserx_refclk_sel_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t pcie_refclk125               : 1;  /**< For bootable PCIe links, this is loaded with the pi_pcieN_ref_spd pin
-                                                         at cold reset and indicates a 125 Mhz Reference clock.  It is not
-                                                         used for non-PCIe links. */
-	uint64_t com_clk_sel                  : 1;  /**< When set, the reference clock is sourced from the external clock mux.
-                                                         For bootable PCIe links, this bit is loaded with the
-                                                         pi_pcieN_com0_clk_en pin at cold reset. */
-	uint64_t use_com1                     : 1;  /**< For non-OCI links, this bit controls the external mux select.
-                                                         When set, qlmc_refclkn/p_1 are selected as the reference clock
-                                                         When clear, qlmc_refclkn/p_0 are selected as the reference clock. */
+	uint64_t pcie_refclk125               : 1;  /**< For bootable PCIe links, this is loaded with
+                                                         PCIE0/2_REFCLK_125 at cold reset and indicates a 125 MHz reference clock when set. For
+                                                         non-bootable PCIe links, this bit is set to zero at cold reset and indicates a 100 MHz
+                                                         reference clock. It is not used for non-PCIe links. */
+	uint64_t com_clk_sel                  : 1;  /**< When set, the reference clock is sourced from the external clock mux. For bootable PCIe
+                                                         links, this bit is loaded with the PCIEn_COM0_CLK_EN pin at cold reset. */
+	uint64_t use_com1                     : 1;  /**< For non-OCI links, this bit controls the external mux select. When set, QLMC_REF_CLK1_N/P
+                                                         are selected as the reference clock. When clear, QLMC_REF_CLK0_N/P are selected as the
+                                                         reference clock. */
 #else
 	uint64_t use_com1                     : 1;
 	uint64_t com_clk_sel                  : 1;
@@ -3959,14 +4164,12 @@ union cvmx_gserx_rx_coast {
 	struct cvmx_gserx_rx_coast_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t coast                        : 4;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         Control signals to freeze the frequency of the per lane CDR in the PHY.
-                                                         The COAST signals are only valid in P0 state, come up asserted and are
-                                                         deasserted in hardware after detecting the electrical idle exit
-                                                         (GSER_RX_EIE_DETSTS.EIESTS).  Once the COAST signal deasserts, the CDR
-                                                         will be allowed to lock.  In BGX mode, the BGX Mac can also control the COAST
-                                                         inputs to the PHY to allow Auto-Negotiation for backplane Ethernet.
-                                                         It is not expected that SW will need to use this register.
+	uint64_t coast                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), control signals to freeze
+                                                         the frequency of the per lane CDR in the PHY. The COAST signals are only valid in P0
+                                                         state, come up asserted and are deasserted in hardware after detecting the electrical idle
+                                                         exit (GSER(0..13)_RX_EIE_DETSTS[EIESTS]). Once the COAST signal deasserts, the CDR is
+                                                         allowed to lock. In BGX mode, the BGX MAC can also control the COAST inputs to the PHY to
+                                                         allow Auto-Negotiation for backplane Ethernet. For diagnostic use only.
                                                          <3>: Lane 3
                                                          <2>: Lane 2
                                                          <1>: Lane 1
@@ -3988,11 +4191,10 @@ union cvmx_gserx_rx_eie_deten {
 	struct cvmx_gserx_rx_eie_deten_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t eiede                        : 4;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         these bits enable per lane Electrical Idle Exit (EIE) detection.
-                                                         When EIE is detected, GSER_RX_EIE_DETSTS.EIELTCH is asserted.
-                                                         EIEDE defaults to the enabled state.  Once EIE has been detected,
-                                                         EIEDE must be disabled, and then enabled again to perform another
+	uint64_t eiede                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), these bits enable per lane
+                                                         electrical idle exit (EIE) detection. When EIE is detected,
+                                                         GSER(0..13)_RX_EIE_DETSTS[EIELTCH] is asserted. EIEDE defaults to the enabled state. Once
+                                                         EIE has been detected, EIEDE must be disabled, and then enabled again to perform another
                                                          EIE detection.
                                                          <3>: Lane 3
                                                          <2>: Lane 2
@@ -4015,30 +4217,29 @@ union cvmx_gserx_rx_eie_detsts {
 	struct cvmx_gserx_rx_eie_detsts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t cdrlock                      : 4;  /**< After an electrical idle exit condition (EIE) has been dectected, the CDR
-                                                         needs 10000 UI to lock.  During this time, there may be RX bit errors.
-                                                         These bits will set when the CDR is guaranteed to be locked.  Note that
-                                                         link training can't start until the lane CDRLOCK is set.  SW can use CDRLOCK
-                                                         to determine when to expect error free Rx data.
+	uint64_t cdrlock                      : 4;  /**< After an electrical idle exit condition (EIE) has been detected, the CDR needs 10000 UI to
+                                                         lock. During this time, there may be RX bit errors. These bits will set when the CDR is
+                                                         guaranteed to be locked. Note that link training can't start until the lane CDRLOCK is
+                                                         set. Software can use CDRLOCK to determine when to expect error free RX data.
                                                          <11>: Lane 3
                                                          <10>: Lane 2
-                                                         <9>:  Lane 1
-                                                         <8>:  Lane 0 */
-	uint64_t eiests                       : 4;  /**< When electrical idle exit detection is enabled (GSER_RX_EIE_DETEN.EIEDE is
-                                                         asserted), indicates that an electrical idle exit condition (EIE) was
-                                                         detected. For higher data rates, the received data needs to have sufficient
-                                                         low frequency content (for example, IDLE symbols) for data transitions to be
-                                                         detected and for EIESTS to stay set accordingly. Under most conditions, EIESTS
-                                                         will stay asserted until GSER_RX_EIE_DETEN.EIEDE is deasserted.
+                                                         <9>: Lane 1
+                                                         <8>: Lane 0 */
+	uint64_t eiests                       : 4;  /**< When electrical idle exit detection is enabled (GSER(0..13)_RX_EIE_DETEN[EIEDE] is
+                                                         asserted), indicates that an electrical idle exit condition (EIE) was detected. For higher
+                                                         data rates, the received data needs to have sufficient low frequency content (for example,
+                                                         IDLE symbols) for data transitions to be detected and for EIESTS to stay set accordingly.
+                                                         Under most conditions, EIESTS
+                                                         will stay asserted until GSER(0..13)_RX_EIE_DETEN[EIEDE] is deasserted.
                                                          <7>: Lane 3
                                                          <6>: Lane 2
                                                          <5>: Lane 1
                                                          <4>: Lane 0 */
-	uint64_t eieltch                      : 4;  /**< When electrical idle exit detection is enabled (GSER_RX_EIE_DETEN.EIEDE is
-                                                         asserted), indicates that an electrical idle exit condition (EIE) was
-                                                         detected.  Once a EIE condition has been detected, the per lane EIELTCH will
-                                                         stay set until GSER_RX_EIE_DETEN.EIEDE is deasserted.  Note that there may
-                                                         be RX bit errors until CDRLOCK is set.
+	uint64_t eieltch                      : 4;  /**< When electrical idle exit detection is enabled (GSER(0..13)_RX_EIE_DETEN[EIEDE] is
+                                                         asserted), indicates that an electrical idle exit condition (EIE) was detected. Once a EIE
+                                                         condition has been detected, the per-lane EIELTCH will stay set until
+                                                         GSER_RX_EIE_DETEN.EIEDE is deasserted. Note that there may be RX bit errors until CDRLOCK
+                                                         is set.
                                                          <3>: Lane 3
                                                          <2>: Lane 2
                                                          <1>: Lane 1
@@ -4062,23 +4263,22 @@ union cvmx_gserx_rx_eie_filter {
 	struct cvmx_gserx_rx_eie_filter_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t eii_filt                     : 16; /**< The GSER uses Electrical Idle Inference to determine when a RX lane
-                                                         has reentered Electrical IDLE (EI).  The PHY Electrical IDLE Exit
-                                                         detection supports a minimum pulse width of 400ps, therefore configurations
-                                                         that run faster than 2.5G can indicate EI when the serial lines are still
-                                                         driven.  For rates faster than 2.5G, it takes 16000 UI of consecutive
-                                                         deasserted GSER_RX_EIE_DETSTS.EIESTS for the GSER to infer EI and begin
-                                                         invalidating RX data. In the event of electrical IDLE inference, the
-                                                         following happens:
-                                                           - GSER_RX_EIE_DETSTS.CDRLOCK[LANE] is zeroed
-                                                           - GSER_RX_EIE_DETSTS.EIELTCH[LANE] is zeroed
-                                                           - GSER_RX_EIE_DETSTS.EIESTS[LANE] is zeroed
-                                                           - GSER_RX_COAST.COAST[LANE] is asserted to prevent the CDR from trying to
-                                                             lock on the incoming data stream.
-                                                           - The lane incoming RX data is invalidated.
-                                                         Writing this register to a non-zero value will cause the Electrical
-                                                         Idle Inference to use the EII_FILT count instead of the default settings.
-                                                         Each EII_FILT count represents 20ns of incremental EI Inference Time. */
+	uint64_t eii_filt                     : 16; /**< The GSER uses electrical idle inference to determine when a RX lane has reentered
+                                                         electrical IDLE (EI). The PHY electrical IDLE exit detection supports a minimum pulse
+                                                         width of 400ps, therefore configurations that run faster than 2.5G can indicate EI when
+                                                         the serial lines are still driven. For rates faster than 2.5G, it takes 16000 UI of
+                                                         consecutive deasserted GSER(0..13)_RX_EIE_DETSTS[EIESTS] for the GSER to infer EI and
+                                                         begin invalidating RX data. In the event of electrical IDLE inference, the following
+                                                         happens:
+                                                         GSER(0..13)_RX_EIE_DETSTS[CDRLOCK]<lane> is zeroed
+                                                         GSER(0..13)_RX_EIE_DETSTS[EIELTCH]<lane> is zeroed
+                                                         GSER(0..13)_RX_EIE_DETSTS[EIESTS]<lane> is zeroed
+                                                         GSER(0..13)_RX_COAST[COAST]<lane> is asserted to prevent the CDR from trying to lock on
+                                                         the incoming data stream.
+                                                         The lane incoming RX data is invalidated.
+                                                         Writing this register to a non-zero value causes the electrical idle inference to use the
+                                                         EII_FILT count instead of the default settings. Each EII_FILT count represents 20 ns of
+                                                         incremental EI inference time. */
 #else
 	uint64_t eii_filt                     : 16;
 	uint64_t reserved_16_63               : 48;
@@ -4096,9 +4296,9 @@ union cvmx_gserx_rx_polarity {
 	struct cvmx_gserx_rx_polarity_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t rx_inv                       : 4;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         control signal to invert the polarity of received data.  When
-                                                         asserted, the polarity of the received data is inverted.
+	uint64_t rx_inv                       : 4;  /**< For links that are not in PCIE mode (including all OCI links), control signal to invert
+                                                         the polarity of received data. When asserted, the polarity of the received data is
+                                                         inverted.
                                                          <3>: Lane 3
                                                          <2>: Lane 2
                                                          <1>: Lane 1
@@ -4120,19 +4320,14 @@ union cvmx_gserx_rx_pstate {
 	struct cvmx_gserx_rx_pstate_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t rxpstate                     : 3;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         allows RX lane power state control. It is not expected that
-                                                         SW will need to use this register.
-                                                          0x0 = P0.  Active State.
-                                                                     All internal clocks in the PHY are operational, the only
-                                                                     state where the PHY transmits and receives link data.
-                                                          0x1 = P0s. Standby State.
-                                                                     The Rx link is disabled.
-                                                          0x2 = P1.  Low Power State:
-                                                                     Selected internal clocks in the PHY are turned off.
-                                                          0x3 = P2.  Power Down State.
-                                                                     All clocks in the PHY are turned off.
-                                                          else = Reserved. */
+	uint64_t rxpstate                     : 3;  /**< For links that are not in PCIE mode (including all OCI links), allows RX lane power state
+                                                         control. For diagnostic use only.
+                                                         0x0 = P0. Active state. All internal clocks in the PHY are operational, the only state
+                                                         where the PHY transmits and receives link data.
+                                                         0x1 = P0s. Standby state. The RX link is disabled.
+                                                         0x2 = P1. low power state. Selected internal clocks in the PHY are turned off.
+                                                         0x3 = P2. Power down state. All clocks in the PHY are turned off.
+                                                         else = Reserved. */
 #else
 	uint64_t rxpstate                     : 3;
 	uint64_t reserved_3_63                : 61;
@@ -4150,23 +4345,16 @@ union cvmx_gserx_rxtx_stat {
 	struct cvmx_gserx_rxtx_stat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t lmc                          : 1;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         this bit is set when a write is performed to that changes the
-                                                         value of the GSER_LANE_MODE register when the PHY is out of reset.
-                                                         This bit is clear when the PHY acknowledges the change for all
-                                                         4 lanes. */
-	uint64_t tpsc                         : 1;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         this bit is set when a write is performed to that changes the
-                                                         value of the GSER_TX_PSTATE register when the PHY is out of reset
-                                                         This bit is clear when the PHY acknowledges the change for all
-                                                         4 lanes.
-                                                         It is not expected that software will need to change the PSTATE. */
-	uint64_t rpsc                         : 1;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         this bit is set when a write is performed to that changes the
-                                                         value to the GSER_RX_PSTATE register.
-                                                         This bit is clear when the PHY acknowledges the change for all
-                                                         4 lanes.
-                                                         It is not expected that software will need to change the PSTATE. */
+	uint64_t lmc                          : 1;  /**< For links that are not in PCIE mode (including all OCI links), this bit is set when a
+                                                         write is performed to that changes the value of GSER(0..13)_LANE_MODE when the PHY is out
+                                                         of reset. This bit is clear when the PHY acknowledges the change for all 4 lanes. */
+	uint64_t tpsc                         : 1;  /**< For links that are not in PCIE mode (including all OCI links), this bit is set when a
+                                                         write is performed to that changes the value of GSER(0..13)_TX_PSTATE when the PHY is out
+                                                         of reset. This bit is clear when the PHY acknowledges the change for all 4 lanes. For
+                                                         diagnostic use only. */
+	uint64_t rpsc                         : 1;  /**< For links that are not in PCIE mode (including all OCI links), this bit is set when a
+                                                         write is performed to that changes the value to GSER(0..13)_RX_PSTATE. This bit is clear
+                                                         when the PHY acknowledges the change for all 4 lanes. For diagnostic use only. */
 #else
 	uint64_t rpsc                         : 1;
 	uint64_t tpsc                         : 1;
@@ -4502,13 +4690,11 @@ union cvmx_gserx_spd {
 	struct cvmx_gserx_spd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t spd                          : 4;  /**< For OCI links, these bits are loaded at cold reset from the
-                                                         pi_oci_spd[3:0] pins and configure the GSER to a rate/reference
-                                                         clock.  This field can be reconfigured and the new
-                                                         GSER_LANE_MODE.LMODE clock will take affect on the next warm reset.
-                                                         For SPD settings that configure a non-default reference clock,
-                                                         hardware will update the PLL settings of the specific lane mode
-                                                         (LMODE) table entry to derive the correct link rate.
+	uint64_t spd                          : 4;  /**< For OCI links, these bits are loaded at cold reset from the OCI_SPD<3:0> pins and
+                                                         configure the GSER to a rate/reference clock. This field can be reconfigured and the new
+                                                         GSER(0..13)_LANE_MODE[LMODE] clock takes affect on the next warm reset.
+                                                         For SPD settings that configure a non-default reference clock, hardware updates the PLL
+                                                         settings of the specific lane mode (LMODE) table entry to derive the correct link rate.
                                                          For non-OCI links, this field is not used.
                                                          config  refclk      link rate       LMODE
                                                          0x0:    100Mhz      1.25Gbps        125G_REFCLK15625_KX
@@ -4521,15 +4707,14 @@ union cvmx_gserx_spd {
                                                          0x7:    125Mhz      5Gbps           5G_REFCLK125
                                                          0x8:    125Mhz      6.25Gbps        625G_REFCLK15625_RXAUI
                                                          0x9:    125Mhz      8Gbps           8G_REFCLK125
-                                                         0xa:    156.25Mhz   2.5Gbps         25G_REFCLK100
-                                                         0xb:    156.25Mhz   3.125Gbps       3125G_REFCLK15625_XAUI
-                                                         0xc:    156.25Mhz   5Gbps           5G_REFCLK125
-                                                         0xd:    156.25Mhz   6.25Gbps        625G_REFCLK15625_RXAUI
-                                                         0xe:    126.25Mhz   10.3125Gbps     103215G_REFCLK15625_KR
-                                                         0xf:
-                                                         Note that a value of 0xf is called SW_MODE.  The OCI link does not
-                                                         come up configured.  SW can come up and configure the interface at
-                                                         a later time. */
+                                                         0xA:    156.25Mhz   2.5Gbps         25G_REFCLK100
+                                                         0xB:    156.25Mhz   3.125Gbps       3125G_REFCLK15625_XAUI
+                                                         0xC:    156.25Mhz   5Gbps           5G_REFCLK125
+                                                         0xD:    156.25Mhz   6.25Gbps        625G_REFCLK15625_RXAUI
+                                                         0xE:    126.25Mhz   10.3125Gbps     103215G_REFCLK15625_KR
+                                                         0xF:    SW_MODE
+                                                         Note that a value of 0xF is called SW_MODE. The OCI link does not come up configured.
+                                                         Software can come up and configure the interface at a later time. */
 #else
 	uint64_t spd                          : 4;
 	uint64_t reserved_4_63                : 60;
@@ -4547,9 +4732,8 @@ union cvmx_gserx_srst {
 	struct cvmx_gserx_srst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t srst                         : 1;  /**< When asserted, resets all per lane state in the GSER
-                                                         with the exception of the PHY.  It is not expected that
-                                                         SW will need to use this register. */
+	uint64_t srst                         : 1;  /**< When asserted, resets all per-lane state in the GSER with the exception of the PHY and the
+                                                         GSER_CFG. For diagnostic use only. */
 #else
 	uint64_t srst                         : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4567,19 +4751,14 @@ union cvmx_gserx_tx_pstate {
 	struct cvmx_gserx_tx_pstate_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t txpstate                     : 3;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         allows TX lane power state control. It is not expected that
-                                                         SW will need to use this register.
-                                                          0x0 = P0.  Active State.
-                                                                     All internal clocks in the PHY are operational, the only
-                                                                     state where the PHY transmits and receives link data.
-                                                          0x1 = P0s. Standby State.
-                                                                     The Tx link is disabled.
-                                                          0x2 = P1.  Low Power State:
-                                                                     Selected internal clocks in the PHY are turned off.
-                                                          0x3 = P2.  Power Down.
-                                                                     All clocks in the PHY are turned off.
-                                                          else = Reserved. */
+	uint64_t txpstate                     : 3;  /**< For links that are not in PCIE mode (including all OCI links), allows TX lane power state
+                                                         control. For diagnostic use only.
+                                                         0x0 = P0. Active state. All internal clocks in the PHY are operational, the only state
+                                                         where the PHY transmits and receives link data.
+                                                         0x1 = P0s. Standby state. The TX link is disabled.
+                                                         0x2 = P1. Low power state: Selected internal clocks in the PHY are turned off.
+                                                         0x3 = P2. Power down. All clocks in the PHY are turned off.
+                                                         else = Reserved. */
 #else
 	uint64_t txpstate                     : 3;
 	uint64_t reserved_3_63                : 61;
@@ -4597,8 +4776,8 @@ union cvmx_gserx_tx_vboost {
 	struct cvmx_gserx_tx_vboost_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t vboost                       : 4;  /**< For links that are not in PCIE mode (including all OCI links),
-                                                         boosts the TX Vswing from vdd to 1.0 Vppd.
+	uint64_t vboost                       : 4;  /**< For links that are not in PCIE mode (including all OCI links), boosts the TX Vswing from
+                                                         VDD to 1.0 VPPD.
                                                          <3>: Lane 3
                                                          <2>: Lane 2
                                                          <1>: Lane 1
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index 74cb6c3..befa49b 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -108,152 +108,151 @@ static inline uint64_t CVMX_HNA_DBELL_FUNC(void)
 #define CVMX_HNA_DBELL (CVMX_ADD_IO_SEG(0x0001470000000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_DEBUG0 CVMX_HNA_DEBUG0_FUNC()
-static inline uint64_t CVMX_HNA_DEBUG0_FUNC(void)
+#define CVMX_HNA_DIFCTL CVMX_HNA_DIFCTL_FUNC()
+static inline uint64_t CVMX_HNA_DIFCTL_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_DEBUG0 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001180047000040ull);
+		cvmx_warn("CVMX_HNA_DIFCTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001470600000000ull);
 }
 #else
-#define CVMX_HNA_DEBUG0 (CVMX_ADD_IO_SEG(0x0001180047000040ull))
+#define CVMX_HNA_DIFCTL (CVMX_ADD_IO_SEG(0x0001470600000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_DEBUG1 CVMX_HNA_DEBUG1_FUNC()
-static inline uint64_t CVMX_HNA_DEBUG1_FUNC(void)
+#define CVMX_HNA_DIFRDPTR CVMX_HNA_DIFRDPTR_FUNC()
+static inline uint64_t CVMX_HNA_DIFRDPTR_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_DEBUG1 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001180047000048ull);
+		cvmx_warn("CVMX_HNA_DIFRDPTR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001470200000000ull);
 }
 #else
-#define CVMX_HNA_DEBUG1 (CVMX_ADD_IO_SEG(0x0001180047000048ull))
+#define CVMX_HNA_DIFRDPTR (CVMX_ADD_IO_SEG(0x0001470200000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_DEBUG2 CVMX_HNA_DEBUG2_FUNC()
-static inline uint64_t CVMX_HNA_DEBUG2_FUNC(void)
+#define CVMX_HNA_ERROR CVMX_HNA_ERROR_FUNC()
+static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_DEBUG2 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001180047000050ull);
+		cvmx_warn("CVMX_HNA_ERROR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000028ull);
 }
 #else
-#define CVMX_HNA_DEBUG2 (CVMX_ADD_IO_SEG(0x0001180047000050ull))
+#define CVMX_HNA_ERROR (CVMX_ADD_IO_SEG(0x0001180047000028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_DEBUG3 CVMX_HNA_DEBUG3_FUNC()
-static inline uint64_t CVMX_HNA_DEBUG3_FUNC(void)
+#define CVMX_HNA_HPU_CSR CVMX_HNA_HPU_CSR_FUNC()
+static inline uint64_t CVMX_HNA_HPU_CSR_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_DEBUG3 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001180047000058ull);
+		cvmx_warn("CVMX_HNA_HPU_CSR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000010ull);
 }
 #else
-#define CVMX_HNA_DEBUG3 (CVMX_ADD_IO_SEG(0x0001180047000058ull))
+#define CVMX_HNA_HPU_CSR (CVMX_ADD_IO_SEG(0x0001180047000010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_DIFCTL CVMX_HNA_DIFCTL_FUNC()
-static inline uint64_t CVMX_HNA_DIFCTL_FUNC(void)
+#define CVMX_HNA_HPU_DBG CVMX_HNA_HPU_DBG_FUNC()
+static inline uint64_t CVMX_HNA_HPU_DBG_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_DIFCTL not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001470600000000ull);
+		cvmx_warn("CVMX_HNA_HPU_DBG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000008ull);
 }
 #else
-#define CVMX_HNA_DIFCTL (CVMX_ADD_IO_SEG(0x0001470600000000ull))
+#define CVMX_HNA_HPU_DBG (CVMX_ADD_IO_SEG(0x0001180047000008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_DIFRDPTR CVMX_HNA_DIFRDPTR_FUNC()
-static inline uint64_t CVMX_HNA_DIFRDPTR_FUNC(void)
+#define CVMX_HNA_HPU_EIR CVMX_HNA_HPU_EIR_FUNC()
+static inline uint64_t CVMX_HNA_HPU_EIR_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_DIFRDPTR not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001470200000000ull);
+		cvmx_warn("CVMX_HNA_HPU_EIR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000018ull);
 }
 #else
-#define CVMX_HNA_DIFRDPTR (CVMX_ADD_IO_SEG(0x0001470200000000ull))
+#define CVMX_HNA_HPU_EIR (CVMX_ADD_IO_SEG(0x0001180047000018ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_DTCFADR CVMX_HNA_DTCFADR_FUNC()
-static inline uint64_t CVMX_HNA_DTCFADR_FUNC(void)
+#define CVMX_HNA_SBD_DBG0 CVMX_HNA_SBD_DBG0_FUNC()
+static inline uint64_t CVMX_HNA_SBD_DBG0_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_DTCFADR not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001180047000060ull);
+		cvmx_warn("CVMX_HNA_SBD_DBG0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000040ull);
 }
 #else
-#define CVMX_HNA_DTCFADR (CVMX_ADD_IO_SEG(0x0001180047000060ull))
+#define CVMX_HNA_SBD_DBG0 (CVMX_ADD_IO_SEG(0x0001180047000040ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_ERROR CVMX_HNA_ERROR_FUNC()
-static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
+#define CVMX_HNA_SBD_DBG1 CVMX_HNA_SBD_DBG1_FUNC()
+static inline uint64_t CVMX_HNA_SBD_DBG1_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_ERROR not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001180047000028ull);
+		cvmx_warn("CVMX_HNA_SBD_DBG1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000048ull);
 }
 #else
-#define CVMX_HNA_ERROR (CVMX_ADD_IO_SEG(0x0001180047000028ull))
+#define CVMX_HNA_SBD_DBG1 (CVMX_ADD_IO_SEG(0x0001180047000048ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_SBD_DBG2 CVMX_HNA_SBD_DBG2_FUNC()
+static inline uint64_t CVMX_HNA_SBD_DBG2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_SBD_DBG2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000050ull);
+}
+#else
+#define CVMX_HNA_SBD_DBG2 (CVMX_ADD_IO_SEG(0x0001180047000050ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_HNA_SBD_DBG3 CVMX_HNA_SBD_DBG3_FUNC()
+static inline uint64_t CVMX_HNA_SBD_DBG3_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_HNA_SBD_DBG3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180047000058ull);
+}
+#else
+#define CVMX_HNA_SBD_DBG3 (CVMX_ADD_IO_SEG(0x0001180047000058ull))
 #endif
 
 /**
  * cvmx_hna_bist0
+ *
+ * Description:
+ *
  */
 union cvmx_hna_bist0 {
 	uint64_t u64;
 	struct cvmx_hna_bist0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_30_63               : 34;
-	uint64_t mrp                          : 2;  /**< Bist Results for MRP RAM(s) (per-DLC)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t gfb                          : 4;  /**< Bist Results for GFB RAM(s) (per-cluster)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t stx3                         : 2;  /**< Bist Results for STX3 RAM(s)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t stx2                         : 2;  /**< Bist Results for STX2 RAM(s)
+	uint64_t reserved_60_63               : 4;
+	uint64_t hpc3                         : 12; /**< Bist Results for HPC3 RAM(s) (per-HPU)
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD */
-	uint64_t stx1                         : 2;  /**< Bist Results for STX1 RAM(s)
+	uint64_t reserved_44_47               : 4;
+	uint64_t hpc2                         : 12; /**< Bist Results for HPC2 RAM(s) (per-HPU)
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD */
-	uint64_t stx                          : 2;  /**< Bist Results for STX0 RAM(s)
+	uint64_t reserved_28_31               : 4;
+	uint64_t hpc1                         : 12; /**< Bist Results for HPC1 RAM(s) (per-HPU)
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD */
-	uint64_t dtx3                         : 2;  /**< Bist Results for DTX3 RAM(s)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t dtx2                         : 2;  /**< Bist Results for DTX2 RAM(s)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t dtx1                         : 2;  /**< Bist Results for DTX1 RAM(s)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t dtx                          : 2;  /**< Bist Results for DTX0 RAM(s)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t rdf                          : 4;  /**< Bist Results for RWB RAM(s) (per-cluster)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t pdb                          : 4;  /**< Bist Results for PDB RAM(s) (per-cluster)
+	uint64_t reserved_12_15               : 4;
+	uint64_t hpc0                         : 12; /**< Bist Results for HPC0 RAM(s) (per-HPU)
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD */
 #else
-	uint64_t pdb                          : 4;
-	uint64_t rdf                          : 4;
-	uint64_t dtx                          : 2;
-	uint64_t dtx1                         : 2;
-	uint64_t dtx2                         : 2;
-	uint64_t dtx3                         : 2;
-	uint64_t stx                          : 2;
-	uint64_t stx1                         : 2;
-	uint64_t stx2                         : 2;
-	uint64_t stx3                         : 2;
-	uint64_t gfb                          : 4;
-	uint64_t mrp                          : 2;
-	uint64_t reserved_30_63               : 34;
+	uint64_t hpc0                         : 12;
+	uint64_t reserved_12_15               : 4;
+	uint64_t hpc1                         : 12;
+	uint64_t reserved_28_31               : 4;
+	uint64_t hpc2                         : 12;
+	uint64_t reserved_44_47               : 4;
+	uint64_t hpc3                         : 12;
+	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
 	struct cvmx_hna_bist0_s               cn78xx;
@@ -262,98 +261,39 @@ typedef union cvmx_hna_bist0 cvmx_hna_bist0_t;
 
 /**
  * cvmx_hna_bist1
+ *
+ * Description:
+ *
  */
 union cvmx_hna_bist1 {
 	uint64_t u64;
 	struct cvmx_hna_bist1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_24_63               : 40;
-	uint64_t dc3ram3                      : 1;  /**< "Cluster#3 Bist Results for RAM3 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t dc3ram2                      : 1;  /**< "Cluster#3 Bist Results for RAM2 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t dc3ram1                      : 1;  /**< "Cluster#3 Bist Results for RAM1 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t dlc1ram                      : 1;  /**< DLC1 Bist Results
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t dlc0ram                      : 1;  /**< DLC0 Bist Results
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t dc2ram3                      : 1;  /**< "Cluster#2 Bist Results for RAM3 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t dc2ram2                      : 1;  /**< "Cluster#2 Bist Results for RAM2 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t dc2ram1                      : 1;  /**< "Cluster#2 Bist Results for RAM1 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t dc1ram3                      : 1;  /**< "Cluster#1 Bist Results for RAM3 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t dc1ram2                      : 1;  /**< "Cluster#1 Bist Results for RAM2 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t dc1ram1                      : 1;  /**< "Cluster#1 Bist Results for RAM1 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t ram3                         : 1;  /**< "Cluster#0 Bist Results for RAM3 RAM
+	uint64_t reserved_7_63                : 57;
+	uint64_t hnc1                         : 1;  /**< "SC#1 Bist Results for cumulative HNC1 RAMs
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD" */
-	uint64_t ram2                         : 1;  /**< "Cluster#0 Bist Results for RAM2 RAM
+	uint64_t hnc0                         : 1;  /**< "SC#0 Bist Results for cumulative HNC0 RAMs
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD" */
-	uint64_t ram1                         : 1;  /**< "Cluster#0 Bist Results for RAM1 RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD" */
-	uint64_t crq                          : 1;  /**< Bist Results for CRQ RAM
+	uint64_t mrp1                         : 1;  /**< Bist Results for DSM-DLC:MRP1 RAM
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD */
-	uint64_t gutv                         : 1;  /**< Bist Results for GUTV RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t gutp                         : 4;  /**< Bist Results for GUTP RAMs (per-cluster)
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t ncd                          : 1;  /**< Bist Results for NCD RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
-	uint64_t gif                          : 1;  /**< Bist Results for GIF RAM
+	uint64_t mrp0                         : 1;  /**< Bist Results for DSM-DLC:MRP0 RAM
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD */
+	uint64_t reserved_1_2                 : 2;
 	uint64_t gib                          : 1;  /**< Bist Results for GIB RAM
                                                          - 0: GOOD (or bist in progress/never run)
                                                          - 1: BAD */
-	uint64_t gfu                          : 1;  /**< Bist Results for GFU RAM
-                                                         - 0: GOOD (or bist in progress/never run)
-                                                         - 1: BAD */
 #else
-	uint64_t gfu                          : 1;
 	uint64_t gib                          : 1;
-	uint64_t gif                          : 1;
-	uint64_t ncd                          : 1;
-	uint64_t gutp                         : 4;
-	uint64_t gutv                         : 1;
-	uint64_t crq                          : 1;
-	uint64_t ram1                         : 1;
-	uint64_t ram2                         : 1;
-	uint64_t ram3                         : 1;
-	uint64_t dc1ram1                      : 1;
-	uint64_t dc1ram2                      : 1;
-	uint64_t dc1ram3                      : 1;
-	uint64_t dc2ram1                      : 1;
-	uint64_t dc2ram2                      : 1;
-	uint64_t dc2ram3                      : 1;
-	uint64_t dlc0ram                      : 1;
-	uint64_t dlc1ram                      : 1;
-	uint64_t dc3ram1                      : 1;
-	uint64_t dc3ram2                      : 1;
-	uint64_t dc3ram3                      : 1;
-	uint64_t reserved_24_63               : 40;
+	uint64_t reserved_1_2                 : 2;
+	uint64_t mrp0                         : 1;
+	uint64_t mrp1                         : 1;
+	uint64_t hnc0                         : 1;
+	uint64_t hnc1                         : 1;
+	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
 	struct cvmx_hna_bist1_s               cn78xx;
@@ -363,26 +303,59 @@ typedef union cvmx_hna_bist1 cvmx_hna_bist1_t;
 /**
  * cvmx_hna_config
  *
- * Specify the RSL base addresses for the block
- * HNA_CONFIG = HNA Configuration Register
+ * Description: This register specifies the HNA HPU programmable controls.
+ *
  */
 union cvmx_hna_config {
 	uint64_t u64;
 	struct cvmx_hna_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_9_63                : 55;
-	uint64_t repl_ena                     : 1;  /**< Replication Mode Enable
-                                                         This is used by the memory controller to support graph
-                                                         data in multiple ports (or port sets), so that the least full
-                                                         port can be selected to minimize latency effects.
-                                                         SWNOTE: Using this mode requires the HNA SW compiler and HNA
-                                                         driver to be aware of the address replication changes.
-                                                         This involves changes to the LOAD/GWALK HNA instruction format
-                                                         (see: IWORD0.REPL), as well as changes to node arc and metadata
-                                                         definitions which now support an additional REPL field.
-                                                         When clear, replication mode is disabled, and HNA will interpret
-                                                         HNA instructions and node-arc formats which DO NOT have
-                                                         address replication information. */
+	uint64_t reserved_25_63               : 39;
+	uint64_t stk_ll_dis                   : 1;  /**< Stack Linked-List Disable.
+                                                         When set, the linked-list mechanism for run stack
+                                                         and save stack structures will be disabled.  In this mode,
+                                                         the linked-list chunk boundary checking is not done, and
+                                                         therefore the previous/next pointers are non-existent.  The
+                                                         stacks are effectively in an infinite linear buffer, bounded
+                                                         only by the maximum sizes provided in the instruction
+                                                         (IWORD3[RUNSTACKSZ] and IWORD6[SVSTACKSZ]).  There is no
+                                                         space reserved for the previous and next pointers, and
+                                                         [STK_CHKSZ] will be ignored.
+                                                         When the STK_LL_DIS is cleared, the stack linked-list mechanism
+                                                         will operate as per spec. */
+	uint64_t reserved_23_23               : 1;
+	uint64_t stk_chksz                    : 3;  /**< Stack Chunk Size
+                                                          This encoded value specifies the chunk size for both the RNSTK/SVSTK data structures.
+                                                          The RNSTK/SVSTK use a doubly linked list where EACH Chunk's first two 64bit
+                                                          entries contain the PREVIOUS and NEXT chunk pointers.
+                                                         - 0: 32 entries or 256 bytes
+                                                         - 1: 64 entries or 512 Bytes
+                                                         - 2: 128 entries or 1K bytes
+                                                         - 3: 256 entries or 2K bytes    <= DEFAULT power on
+                                                         - 4: 512 entries or 4K bytes
+                                                         - 5: 1024 entries or 8K bytes
+                                                         - 6: 2048 entries or 16K bytes
+                                                         - 7: 4096 entries or 32K bytes
+                                                          NOTE: This field can only be changed at initialization/power on time before
+                                                          the HNA is fed instructions. */
+	uint64_t rnstk_lwm                    : 4;  /**< "RNSTK Low Water Mark
+                                                         This field specifies the low watermark for the run stack. Valid Range: [0..15]
+                                                         Once the run stack goes below the low water mark, HNA will fill entries from the
+                                                         global run stack head to the local run stack tail.
+                                                         The granularity of this field is represented as \#of 128B cachelines.
+                                                         NOTE: This field can only be changed at initialization/power on time before
+                                                         the HNA is fed instructions." */
+	uint64_t rnstk_hwm                    : 4;  /**< "RNSTK High Water Mark
+                                                         This field specifies the hi watermark for the run stack. Valid Range: [0..15]
+                                                         Once the local run stack level goes above the hi water mark, the HNA will spill
+                                                         entries from the local run stack tail to the global run stack head (in DDR memory).
+                                                         The granularity of this field is represented as \#of 128B cachelines.
+                                                         NOTE: This field can only be changed at initialization/power on time before
+                                                         the HNA is fed instructions." */
+	uint64_t reserved_9_11                : 3;
+	uint64_t ecccordis                    : 1;  /**< ECC Correction Disable
+                                                         When set, all HNA ECC protected data structures will disable their ECC correction
+                                                         logic. When clear (default) ECC correction is always enabled. */
 	uint64_t clmskcrip                    : 4;  /**< Cluster Cripple Mask
                                                          A one in each bit of the mask represents which HPC cluster to
                                                          cripple. o78 HNA has 4 clusters, where all CLMSKCRIP mask bits are used.
@@ -390,7 +363,8 @@ union cvmx_hna_config {
                                                          be forced into this register at reset. Any fuse bits that
                                                          contain '1' will be disallowed during a write and will always
                                                          be read as '1'. */
-	uint64_t hpu_clcrip                   : 3;  /**< "Encoding which represents \#of HPUs to cripple for each
+	uint64_t hpu_clcrip                   : 3;  /**< "HPU Cluster Cripple
+                                                         Encoding which represents \#of HPUs to cripple for each
                                                          cluster. Typically HPU_CLCRIP=0 which enables all HPUs
                                                          within each cluster. However, when the HNA performance
                                                          counters are used, SW may want to limit the \#of HPUs
@@ -398,18 +372,18 @@ union cvmx_hna_config {
                                                          performance counters.
                                                          HPU_CLCRIP | \#HPUs crippled(per cluster)
                                                          -----------+-----------------------------
-                                                         0          |  0      HPU[11:0]:ON
-                                                         1          |  6      HPU[11:6]:OFF  /HPU[5:0]:ON
-                                                         2          |  3      HPU[11:9]:OFF  /HPU[8:0]:ON
-                                                         3          |  9      HPU[11:3]:OFF  /HPU[2:0]:ON
-                                                         4          |  1      HPU[11]:OFF    /HPU[10:0]:ON
-                                                         5          |  8      HPU[11:4]:OFF  /HPU[3:0]:ON
-                                                         6          |  4      HPU[11:8]:OFF  /HPU[7:0]:ON
-                                                         7          |  11     HPU[11:1]:OFF  /HPU[0]:ON
+                                                            0       |  0      HPU[9:0]:ON                   All engines enabled
+                                                            1       |  1      HPU[9]:OFF    /HPU[8:0]:ON    (n-1) engines enabled
+                                                            2       |  3      HPU[9:7]:OFF  /HPU[6:0]:ON    (n-3) engines enabled
+                                                            3       |  4      HPU[9:6]:OFF  /HPU[5:0]:ON    (n-4) engines enabled
+                                                            4       |  5      HPU[9:5]:OFF  /HPU[4:0]:ON    (n-5) engines enabled
+                                                            5       |  6      HPU[9:4]:OFF  /HPU[3:0]:ON    (n-6) engines enabled
+                                                            6       |  8      HPU[9:2]:OFF  /HPU[1:0]:ON    (n-8) engines enabled
+                                                            7       |  9      HPU[9:1]:OFF  /HPU[0]:ON      (n-9) single engine enabled
                                                          NOTE: Higher numbered HPUs are crippled first. For instance,
-                                                         on o78 (with 12 HPUs/cluster), if HPU_CLCRIP=1(1/2), then
-                                                         HPU#s [15:8] within the cluster are crippled and only
-                                                         HPU#s [7:0] are available.
+                                                         on o78 (with 10 HPUs/cluster), if HPU_CLCRIP=0x1, then
+                                                         HPU#s [9] within the cluster are crippled and only
+                                                         HPU#s [8:0] are available.
                                                          IMPNOTE: The encodings are done in such a way as to later
                                                          be used with fuses (for future revisions which will disable
                                                          some \#of HPUs). Blowing a fuse has the effect that there will
@@ -436,8 +410,14 @@ union cvmx_hna_config {
 	uint64_t hpuclkdis                    : 1;
 	uint64_t hpu_clcrip                   : 3;
 	uint64_t clmskcrip                    : 4;
-	uint64_t repl_ena                     : 1;
-	uint64_t reserved_9_63                : 55;
+	uint64_t ecccordis                    : 1;
+	uint64_t reserved_9_11                : 3;
+	uint64_t rnstk_hwm                    : 4;
+	uint64_t rnstk_lwm                    : 4;
+	uint64_t stk_chksz                    : 3;
+	uint64_t reserved_23_23               : 1;
+	uint64_t stk_ll_dis                   : 1;
+	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
 	struct cvmx_hna_config_s              cn78xx;
@@ -446,12 +426,20 @@ typedef union cvmx_hna_config cvmx_hna_config_t;
 
 /**
  * cvmx_hna_control
+ *
+ * Description: This register specifies the HNA CTL/HNC programmable controls.
+ *
  */
 union cvmx_hna_control {
 	uint64_t u64;
 	struct cvmx_hna_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_12_63               : 52;
+	uint64_t reserved_13_63               : 51;
+	uint64_t frcperr                      : 1;  /**< Force Parity Error during CLOAD (HNC-write)
+                                                         When SET, a parity error is forced during the HNC CLOAD
+                                                         instruction. SW can force a single line in the HNC to contain
+                                                         a parity error by setting this bit and performance a CLOAD
+                                                         for a single line (DLEN=32), then clearing the bit. */
 	uint64_t sbdnum                       : 6;  /**< "SBD Debug Entry#
                                                          INTERNAL:
                                                          HNA Scoreboard debug control
@@ -468,11 +456,11 @@ union cvmx_hna_control {
                                                          from that instant in time. */
 	uint64_t reserved_3_4                 : 2;
 	uint64_t pmode                        : 1;  /**< NCB-NRP Arbiter Mode
-                                                         (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR
+                                                         (0=Fixed Priority [LP=DFF,HP=RGF]/1=RR
                                                          NOTE: This should only be written to a different value
                                                          during power-on SW initialization. */
 	uint64_t qmode                        : 1;  /**< NCB-NRQ Arbiter Mode
-                                                         (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR
+                                                         (0=Fixed Priority [LP=NPF,IRF,WRF,PRF,RSRF,HP=SLL]/1=RR
                                                          NOTE: This should only be written to a different value
                                                          during power-on SW initialization. */
 	uint64_t imode                        : 1;  /**< NCB-Inbound Arbiter
@@ -486,7 +474,8 @@ union cvmx_hna_control {
 	uint64_t reserved_3_4                 : 2;
 	uint64_t sbdlck                       : 1;
 	uint64_t sbdnum                       : 6;
-	uint64_t reserved_12_63               : 52;
+	uint64_t frcperr                      : 1;
+	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
 	struct cvmx_hna_control_s             cn78xx;
@@ -496,10 +485,11 @@ typedef union cvmx_hna_control cvmx_hna_control_t;
 /**
  * cvmx_hna_dbell
  *
+ * Description:
  * NOTE: To write to the HNA_DBELL register, a device would issue an IOBST directed at the HNA
- * with addr[34:33]=2'b00.
+ * with addr[34:32] = 0x0 or 0x1.
  * To read the HNA_DBELL register, a device would issue an IOBLD64 directed at the HNA with
- * addr[34:33]=2'b00.
+ * addr[34:32] = 0x0 or 0x1.
  * NOTE: If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks disabled), reads/writes to the HNA_DBELL
  * register do not take effect.
  * NOTE: If FUSE[TBD]="HNA HPU disable" is blown, reads/writes to the HNA_DBELL register do not
@@ -515,7 +505,7 @@ union cvmx_hna_dbell {
                                                          into the HNA Instruction FIFO (DIF) in main memory.
                                                          Each HNA instruction contains a fixed size 64B
                                                          instruction word which is executed by the HNA HW.
-                                                         The DBL register can hold up to 1M-1 (2^20-1)
+                                                         The DBELL field can hold up to 1M-1 (2^20-1)
                                                          pending HNA instruction requests.
                                                          During a read (by SW), the 'most recent' contents
                                                          of the HNA_DBELL register are returned at the time
@@ -532,154 +522,13 @@ union cvmx_hna_dbell {
 typedef union cvmx_hna_dbell cvmx_hna_dbell_t;
 
 /**
- * cvmx_hna_debug0
- *
- * "INTERNAL: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
- * are locked down.
- * Otherwise, the contents of this register are the 'active' contents of the HNA Scoreboard at
- * the time of the
- * CSR read.
- * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
- * model)
- * on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
- * assigned an
- * instruction."
- */
-union cvmx_hna_debug0 {
-	uint64_t u64;
-	struct cvmx_hna_debug0_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd0                         : 64; /**< "HNA ScoreBoard \#0 Data
-                                                         (HNA Scoreboard Debug)
-                                                         [63:38]   (26) rptr[28:3]: Result Base Pointer (QW-aligned)
-                                                         [37:22]   (16) Cumulative Result Write Counter (for HDR write)
-                                                         [21]       (1) Waiting for GRdRsp EOT
-                                                         [20]       (1) Waiting for GRdReq Issue (to NRQ)
-                                                         [19]       (1) GLPTR/GLCNT Valid
-                                                         [18]       (1) Completion Mark Detected
-                                                         [17:15]    (3) Completion Code [0=PDGONE/1=PERR/2=RFULL/3=TERM]
-                                                         [14]       (1) Completion Detected
-                                                         [13]       (1) Waiting for HDR RWrCmtRsp
-                                                         [12]       (1) Waiting for LAST RESULT RWrCmtRsp
-                                                         [11]       (1) Waiting for HDR RWrReq
-                                                         [10]        (1) Waiting for RWrReq
-                                                         [9]        (1) Waiting for WQWrReq issue
-                                                         [8]        (1) Waiting for PRdRsp EOT
-                                                         [7]        (1) Waiting for PRdReq Issue (to NRQ)
-                                                         [6]        (1) Packet Data Valid
-                                                         [5]        (1) WQVLD
-                                                         [4]        (1) WQ Done Point (either WQWrReq issued (for WQPTR<>0) OR HDR RWrCmtRsp)
-                                                         [3]        (1) Resultant write STF/P Mode
-                                                         [2]        (1) Packet Data LDT mode
-                                                         [1]        (1) Gather Mode
-                                                         [0]        (1) Valid" */
-#else
-	uint64_t sbd0                         : 64;
-#endif
-	} s;
-	struct cvmx_hna_debug0_s              cn78xx;
-};
-typedef union cvmx_hna_debug0 cvmx_hna_debug0_t;
-
-/**
- * cvmx_hna_debug1
- *
- * "INTERNAL: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
- * are locked down.
- * Otherwise, the contents of this register are the 'active' contents of the HNA Scoreboard at
- * the time of the
- * CSR read.
- * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
- * model)
- * on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
- * assigned an
- * instruction."
- */
-union cvmx_hna_debug1 {
-	uint64_t u64;
-	struct cvmx_hna_debug1_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd1                         : 64; /**< "HNA ScoreBoard \#1 Data
-                                                         HNA Scoreboard Debug Data
-                                                         [63:56]   (8) UNUSED
-                                                         [55:16]  (40) Packet Data Pointer
-                                                         [15:0]   (16) Packet Data Counter" */
-#else
-	uint64_t sbd1                         : 64;
-#endif
-	} s;
-	struct cvmx_hna_debug1_s              cn78xx;
-};
-typedef union cvmx_hna_debug1 cvmx_hna_debug1_t;
-
-/**
- * cvmx_hna_debug2
- *
- * When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
- * are locked down.
- * Otherwise, the contents of this register are the 'active' contents of the HNA Scoreboard at
- * the time of the
- * CSR read.
- * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
- * model)
- * on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
- * assigned an
- * instruction.
- */
-union cvmx_hna_debug2 {
-	uint64_t u64;
-	struct cvmx_hna_debug2_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd2                         : 64; /**< "HNA ScoreBoard \#2 Data
-                                                         [63:45] (19) UNUSED
-                                                         [44:42]  (3) Instruction Type
-                                                         [41:5]  (37) rwptr[39:3]: Result Write Pointer
-                                                         [4:0]    (5) prwcnt[4:0]: Pending Result Write Counter" */
-#else
-	uint64_t sbd2                         : 64;
-#endif
-	} s;
-	struct cvmx_hna_debug2_s              cn78xx;
-};
-typedef union cvmx_hna_debug2 cvmx_hna_debug2_t;
-
-/**
- * cvmx_hna_debug3
- *
- * When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
- * are locked down.
- * Otherwise, the contents of this register are the 'active' contents of the HNA Scoreboard at
- * the time of the
- * CSR read.
- * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
- * model)
- * on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
- * assigned an
- * instruction.
- */
-union cvmx_hna_debug3 {
-	uint64_t u64;
-	struct cvmx_hna_debug3_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd3                         : 64; /**< "HNA ScoreBoard \#3 Data
-                                                         [63:52] (11) rptr[39:29]: Result Base Pointer (QW-aligned)
-                                                         [52:16] (37) glptr[39:3]: Gather List Pointer
-                                                         [15:0]  (16) glcnt Gather List Counter" */
-#else
-	uint64_t sbd3                         : 64;
-#endif
-	} s;
-	struct cvmx_hna_debug3_s              cn78xx;
-};
-typedef union cvmx_hna_debug3 cvmx_hna_debug3_t;
-
-/**
  * cvmx_hna_difctl
  *
+ * Description:
  * NOTE: To write to the HNA_DIFCTL register, a device would issue an IOBST directed at the HNA
- * with addr[34:32]=3'b110.
+ * with addr[34:32]=0x6.
  * To read the HNA_DIFCTL register, a device would issue an IOBLD64 directed at the HNA with
- * addr[34:32]=3'b110.
+ * addr[34:32]=0x6.
  * NOTE: This register is intended to ONLY be written once (at power-up). Any future writes could
  * cause the HNA and FPA HW to become unpredictable.
  * NOTE: If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks disabled), reads/writes to the HNA_DIFCTL
@@ -696,31 +545,7 @@ union cvmx_hna_difctl {
                                                          when the HNA instruction chunk is recycled back
                                                          to the Free Page List maintained by the FPA HW
                                                          (once the HNA instruction has been issued). */
-	uint64_t msegbase                     : 6;  /**< Memory Segmentation Base Address
-                                                         For debug purposes, backdoor accesses to the HNA
-                                                         memory are supported via NCB-Direct CSR accesses to
-                                                         the HNA Memory REGION(if addr[34:32]=5. However due
-                                                         to the existing NCB address decoding scheme, the
-                                                         address only offers a 4GB extent into the HNA memory
-                                                         REGION. Therefore, the MSEGBASE CSR field provides
-                                                         the additional upper memory address bits to allow access
-                                                         to the full extent of memory (128GB MAX).
-                                                         For HNA Memory REGION read NCB-Direct CSR accesses, the
-                                                         38bit L2/DRAM memory byte address is generated as follows:
-                                                         memaddr[37:0] = [HNA_DIFCTL[MSEGBASE],ncb_addr[31:3],3'b0]
-                                                         NOTE: See the upper 6bits of the memory address are sourced
-                                                         from HNA_DIFCTL[MSEGBASE] CSR field. The lower 4GB address
-                                                         offset is directly referenced using the NCB address bits during
-                                                         the reference itself.
-                                                         NOTE: The HNA_DIFCTL[MSEGBASE] is shared amongst all references.
-                                                         As such, if multiple PPs are accessing different segments in memory,
-                                                         their must be a SW mutual exclusive lock during each HNA Memory
-                                                         REGION access to avoid collisions between PPs using the same MSEGBASE
-                                                         CSR field.
-                                                         NOTE: See also HNA_ERROR[HNANXM] programmable interrupt which is
-                                                         flagged if SW tries to access non-existent memory space (address hole
-                                                         or upper unused region of 38bit address space). */
-	uint64_t reserved_13_19               : 7;
+	uint64_t reserved_13_25               : 13;
 	uint64_t ldwb                         : 1;  /**< Load Don't Write Back.
                                                          When set, the HW will issue LDWB command towards the cache when
                                                          fetching last word of instructions, as a result the line will not be written back when
@@ -746,8 +571,7 @@ union cvmx_hna_difctl {
 	uint64_t size                         : 9;
 	uint64_t reserved_9_11                : 3;
 	uint64_t ldwb                         : 1;
-	uint64_t reserved_13_19               : 7;
-	uint64_t msegbase                     : 6;
+	uint64_t reserved_13_25               : 13;
 	uint64_t aura                         : 16;
 	uint64_t reserved_42_63               : 22;
 #endif
@@ -759,10 +583,11 @@ typedef union cvmx_hna_difctl cvmx_hna_difctl_t;
 /**
  * cvmx_hna_difrdptr
  *
+ * Description:
  * NOTE: To write to the HNA_DIFRDPTR register, a device would issue an IOBST directed at the HNA
- * with addr[34:33]=2'b01.
+ * with addr[34:32] = 0x2 or 0x3.
  * To read the HNA_DIFRDPTR register, a device would issue an IOBLD64 directed at the HNA with
- * addr[34:33]=2'b01.
+ * addr[34:32] = 0x2 or 0x3.
  * NOTE: If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks disabled), reads/writes to the HNA_DIFRDPTR
  * register do not take effect.
  * NOTE: If FUSE[TBD]="HNA HPU disable" is blown, reads/writes to the HNA_DIFRDPTR register do
@@ -772,13 +597,13 @@ union cvmx_hna_difrdptr {
 	uint64_t u64;
 	struct cvmx_hna_difrdptr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_40_63               : 24;
-	uint64_t rdptr                        : 35; /**< Represents the 64B-aligned address of the current
+	uint64_t reserved_42_63               : 22;
+	uint64_t rdptr                        : 36; /**< Represents the 64B-aligned address of the current
                                                          instruction in the HNA Instruction FIFO in main
                                                          memory. The RDPTR must be seeded by software at
                                                          boot time, and is then maintained thereafter
                                                          by HNA HW.
-                                                         During the seed write (by SW), RDPTR[6:5]=0,
+                                                         During the seed write (by SW), RDPTR[6]=0,
                                                          since HNA instruction chunks must be 128B aligned.
                                                          During a read (by SW), the 'most recent' contents
                                                          of the RDPTR register are returned at the time
@@ -788,11 +613,11 @@ union cvmx_hna_difrdptr {
                                                          its guaranteed that no new DoorBell register
                                                          writes have occurred and the DoorBell register is
                                                          read as zero). */
-	uint64_t reserved_0_4                 : 5;
+	uint64_t reserved_0_5                 : 6;
 #else
-	uint64_t reserved_0_4                 : 5;
-	uint64_t rdptr                        : 35;
-	uint64_t reserved_40_63               : 24;
+	uint64_t reserved_0_5                 : 6;
+	uint64_t rdptr                        : 36;
+	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
 	struct cvmx_hna_difrdptr_s            cn78xx;
@@ -800,56 +625,10 @@ union cvmx_hna_difrdptr {
 typedef union cvmx_hna_difrdptr cvmx_hna_difrdptr_t;
 
 /**
- * cvmx_hna_dtcfadr
- *
- * "HNA Node Cache Failing Address/Control Error Capture information.
- * This register contains useful information to help in isolating a Node Cache RAM failure.
- * NOTE: The first detected PERR failure is captured in HNA_DTCFADR (locked down), until the
- * corresponding PERR Interrupt is cleared by writing one (W1C). (see: HNA_ERR[DC0PERR[2:0]]).
- * NOTE: In the rare event that multiple parity errors are detected in the same cycle from
- * multiple
- * clusters, the FADR register will be locked down for the least signicant cluster \# (0->3)."
- */
-union cvmx_hna_dtcfadr {
-	uint64_t u64;
-	struct cvmx_hna_dtcfadr_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_44_63               : 20;
-	uint64_t ram3fadr                     : 12; /**< HNA RAM3 Failing Address
-                                                         If HNA_ERR[DC0PERR<2>]=1, this field indicates the
-                                                         failing RAM3 Address. The failing address is locked
-                                                         down until the DC0PERR<2> W1C occurs.
-                                                         NOTE: If multiple DC0PERR<0>=1 errors are detected,
-                                                         then the lsb cluster error information is captured. */
-	uint64_t reserved_25_31               : 7;
-	uint64_t ram2fadr                     : 9;  /**< HNA RAM2 Failing Address
-                                                         If HNA_ERR[DC0PERR<1>]=1, this field indicates the
-                                                         failing RAM2 Address. The failing address is locked
-                                                         down until the DC0PERR<1> W1C occurs.
-                                                         NOTE: If multiple DC0PERR<0>=1 errors are detected,
-                                                         then the lsb cluster error information is captured. */
-	uint64_t reserved_14_15               : 2;
-	uint64_t ram1fadr                     : 14; /**< HNA RAM1 Failing Address
-                                                         If HNA_ERR[DC0PERR<0>]=1, this field indicates the
-                                                         failing RAM1 Address. The failing address is locked
-                                                         down until the DC0PERR<0> W1C occurs.
-                                                         NOTE: If multiple DC0PERR<0>=1 errors are detected,
-                                                         then the lsb cluster error information is captured. */
-#else
-	uint64_t ram1fadr                     : 14;
-	uint64_t reserved_14_15               : 2;
-	uint64_t ram2fadr                     : 9;
-	uint64_t reserved_25_31               : 7;
-	uint64_t ram3fadr                     : 12;
-	uint64_t reserved_44_63               : 20;
-#endif
-	} s;
-	struct cvmx_hna_dtcfadr_s             cn78xx;
-};
-typedef union cvmx_hna_dtcfadr cvmx_hna_dtcfadr_t;
-
-/**
  * cvmx_hna_error
+ *
+ * Description: This register contains error status information.
+ *
  */
 union cvmx_hna_error {
 	uint64_t u64;
@@ -883,7 +662,6 @@ union cvmx_hna_error {
                                                          L2/DRAM address space                     Physical DDR3 SDRAM Address space
                                                          (40bit address)                           (38bit address)
                                                          +-----------+ 0x0040.0FFF.FFFF
-
                                                          |   DR1     |                            +-----------+ 0x003F.FFFF.FFFF
                                                          |           | (256GB-256MB)
                                                          |           |                     =>     |   DR1
@@ -904,37 +682,14 @@ union cvmx_hna_error {
                                                          Memory REGION, then the CSR read response data is forced to
                                                          128'hBADE_FEED_DEAD_BEEF_FACE_CAFE_BEAD_C0DE. (NOTE: the QW
                                                          being accessed, either the upper or lower QW will be returned). */
-	uint64_t cndrd                        : 1;  /**< If Any of the cluster's detected a Parity error on RAM1
-                                                         this additional bit further specifies that the
-                                                         RAM1 parity error was detected during a CND-RD
-                                                         (Cache Node Metadata Read).
-                                                         INTERNAL: For CNDRD Parity Error, the previous CNA arc fetch
-                                                         information is written to RWORD1+ as follows:
-                                                         RWORD1+[NTYPE]=MNODE
-                                                         RWORD1+[NDNID]=cna.ndnid
-                                                         RWORD1+[NHMSK]=cna.hmsk
-                                                         RWORD1+[NNPTR]=cna.nnptr[13:0]
-                                                         NOTE: This bit is set if ANY node cluster's RAM1 accesses
-                                                         detect a CNDRD error. */
-	uint64_t reserved_15_15               : 1;
+	uint64_t reserved_15_16               : 2;
 	uint64_t dlc1_ovferr                  : 1;  /**< DLC1 Fifo Overflow Error Detected
                                                          This condition should NEVER architecturally occur, and
                                                          is here in case HW credit/debit scheme is not working. */
 	uint64_t dlc0_ovferr                  : 1;  /**< DLC0 Fifo Overflow Error Detected
                                                          This condition should NEVER architecturally occur, and
                                                          is here in case HW credit/debit scheme is not working. */
-	uint64_t dc3perr                      : 3;  /**< "Cluster#3 RAM[3:1] Parity Error Detected
-                                                         See also HNA_DTCFADR register which contains the
-                                                         failing addresses for the internal node cache RAMs." */
-	uint64_t dc2perr                      : 3;  /**< "Cluster#2 RAM[3:1] Parity Error Detected
-                                                         See also HNA_DTCFADR register which contains the
-                                                         failing addresses for the internal node cache RAMs." */
-	uint64_t dc1perr                      : 3;  /**< "Cluster#1 RAM[3:1] Parity Error Detected
-                                                         See also HNA_DTCFADR register which contains the
-                                                         failing addresses for the internal node cache RAMs." */
-	uint64_t dc0perr                      : 3;  /**< "Cluster#0 RAM[3:1] Parity Error Detected
-                                                         See also HNA_DTCFADR register which contains the
-                                                         failing addresses for the internal node cache RAMs." */
+	uint64_t reserved_1_12                : 12;
 	uint64_t dblovf                       : 1;  /**< Doorbell Overflow detected - Status bit
                                                          When set, the 20b accumulated doorbell register
                                                          had overflowed (SW wrote too many doorbell requests).
@@ -947,14 +702,10 @@ union cvmx_hna_error {
                                                          Throws HNA_INTSN_E::HNA_ERROR_DBLOVF. */
 #else
 	uint64_t dblovf                       : 1;
-	uint64_t dc0perr                      : 3;
-	uint64_t dc1perr                      : 3;
-	uint64_t dc2perr                      : 3;
-	uint64_t dc3perr                      : 3;
+	uint64_t reserved_1_12                : 12;
 	uint64_t dlc0_ovferr                  : 1;
 	uint64_t dlc1_ovferr                  : 1;
-	uint64_t reserved_15_15               : 1;
-	uint64_t cndrd                        : 1;
+	uint64_t reserved_15_16               : 2;
 	uint64_t hnanxm                       : 1;
 	uint64_t replerr                      : 1;
 	uint64_t osmerr                       : 1;
@@ -965,4 +716,222 @@ union cvmx_hna_error {
 };
 typedef union cvmx_hna_error cvmx_hna_error_t;
 
+/**
+ * cvmx_hna_hpu_csr
+ *
+ * "Description: To read one of the HPU internal CSRs for debug (ie: HPU_STATUS, DBG_CURSTK,
+ * DBG_GENERAL),
+ * first a CSR WRITE of the HNA_HPU_DBG is done to specify the HPU CSR#, cluster#=CLID and
+ * HPU#=HPUID,
+ * which is followed by a CSR READ of the HPA_HPU_CSR which returns the contents of the specified
+ * HPU CSR."
+ */
+union cvmx_hna_hpu_csr {
+	uint64_t u64;
+	struct cvmx_hna_hpu_csr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t csrdat                       : 64; /**< HPU CSR contents specified by the HNA_HPU_DBG CSR. */
+#else
+	uint64_t csrdat                       : 64;
+#endif
+	} s;
+	struct cvmx_hna_hpu_csr_s             cn78xx;
+};
+typedef union cvmx_hna_hpu_csr cvmx_hna_hpu_csr_t;
+
+/**
+ * cvmx_hna_hpu_dbg
+ *
+ * "Description: This register specifies the HPU CSR#, cluster#=CLID and HPU#=HPUID used during a
+ * a CSR READ of the HNA_HPU_CSR register."
+ */
+union cvmx_hna_hpu_dbg {
+	uint64_t u64;
+	struct cvmx_hna_hpu_dbg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t csrnum                       : 2;  /**< "HPU CSR#
+                                                         - 0: HPU_STATUS
+                                                         - 1: DBG_CURSTK
+                                                         - 2: DBG_GENERAL" */
+	uint64_t clid                         : 2;  /**< HPC Cluster# Valid Range=[0..3] */
+	uint64_t hpuid                        : 4;  /**< HPU Engine ID# Valid Range=[0..11] */
+#else
+	uint64_t hpuid                        : 4;
+	uint64_t clid                         : 2;
+	uint64_t csrnum                       : 2;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_hna_hpu_dbg_s             cn78xx;
+};
+typedef union cvmx_hna_hpu_dbg cvmx_hna_hpu_dbg_t;
+
+/**
+ * cvmx_hna_hpu_eir
+ *
+ * "Description: Used by SW to force Parity or ECC errors on some internal HPU data structures.
+ * A CSR WRITE of this register will force either a Parity or ECC error on the next access
+ * at cluster#=CLID, HPU#=HPUID."
+ */
+union cvmx_hna_hpu_eir {
+	uint64_t u64;
+	struct cvmx_hna_hpu_eir_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t wrdone                       : 1;  /**< When the HNA_HPU_EIR register is written, this bit will
+                                                         be cleared by HW. When the targeted HPU has received
+                                                         the error injection command (ie: error injection armed),
+                                                         the WRDONE bit will be SET.
+                                                         SW will first write the HNA_HPU_EIR register, then do a
+                                                         polling read of the WRDONE bit (until it becomes 1),
+                                                         before issueing an HNA instruction to the targeted HPU
+                                                         which will inject the intended error type for a single
+                                                         occurrence (one-shot). */
+	uint64_t pdperr                       : 1;  /**< Packet Data buffer Parity error
+                                                         Forces parity error on next Packet data buffer read. */
+	uint64_t svflipsyn                    : 2;  /**< Save stack flip syndrome control.
+                                                         Forces 1-bit/2-bit errors on next save stack read. */
+	uint64_t rsflipsyn                    : 2;  /**< Run stack flip syndrome control.
+                                                         Forces 1-bit/2-bit errors on next run stack read. */
+	uint64_t clid                         : 2;  /**< HPC Cluster# Valid Range=[0..3] */
+	uint64_t hpuid                        : 4;  /**< HPU Engine ID# Valid Range=[0..11] */
+#else
+	uint64_t hpuid                        : 4;
+	uint64_t clid                         : 2;
+	uint64_t rsflipsyn                    : 2;
+	uint64_t svflipsyn                    : 2;
+	uint64_t pdperr                       : 1;
+	uint64_t wrdone                       : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_hna_hpu_eir_s             cn78xx;
+};
+typedef union cvmx_hna_hpu_eir cvmx_hna_hpu_eir_t;
+
+/**
+ * cvmx_hna_sbd_dbg0
+ *
+ * Description: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
+ * are locked down. Otherwise, the contents of this register are the 'active' contents of the
+ * HNA Scoreboard at the time of the CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * model) on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
+ * assigned an instruction.
+ */
+union cvmx_hna_sbd_dbg0 {
+	uint64_t u64;
+	struct cvmx_hna_sbd_dbg0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd                          : 64; /**< "HNA ScoreBoard \#0 Data
+                                                         [63:38]   (26) rptr[28:3]: Result Base Pointer (QW-aligned)
+                                                         [37:22]   (16) Cumulative Result Write Counter (for HDR write)
+                                                         [21]       (1) Waiting for GRdRsp EOT
+                                                         [20]       (1) Waiting for GRdReq Issue (to NRQ)
+                                                         [19]       (1) GLPTR/GLCNT Valid
+                                                         [18]       (1) Completion Mark Detected
+                                                         [17:15]    (3) Completion Code [0=PDGONE/1=PERR/2=RFULL/3=TERM]
+                                                         [14]       (1) Completion Detected
+                                                         [13]       (1) Waiting for HDR RWrCmtRsp
+                                                         [12]       (1) Waiting for LAST RESULT RWrCmtRsp
+                                                         [11]       (1) Waiting for HDR RWrReq
+                                                         [10]        (1) Waiting for RWrReq
+                                                         [9]        (1) Waiting for WQWrReq issue
+                                                         [8]        (1) Waiting for PRdRsp EOT
+                                                         [7]        (1) Waiting for PRdReq Issue (to NRQ)
+                                                         [6]        (1) Packet Data Valid
+                                                         [5]        (1) WQVLD
+                                                         [4]        (1) WQ Done Point (either WQWrReq issued (for WQPTR<>0) OR HDR RWrCmtRsp)
+                                                         [3]        (1) Resultant write STF/P Mode
+                                                         [2]        (1) Packet Data LDT mode
+                                                         [1]        (1) Gather Mode
+                                                         [0]        (1) Valid" */
+#else
+	uint64_t sbd                          : 64;
+#endif
+	} s;
+	struct cvmx_hna_sbd_dbg0_s            cn78xx;
+};
+typedef union cvmx_hna_sbd_dbg0 cvmx_hna_sbd_dbg0_t;
+
+/**
+ * cvmx_hna_sbd_dbg1
+ *
+ * Description: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
+ * are locked down. Otherwise, the contents of this register are the 'active' contents of the
+ * HNA Scoreboard at the time of the CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * model) on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
+ * assigned an instruction.
+ */
+union cvmx_hna_sbd_dbg1 {
+	uint64_t u64;
+	struct cvmx_hna_sbd_dbg1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd                          : 64; /**< "HNA ScoreBoard \#1 Data
+                                                         [63:56]   (8) UNUSED
+                                                         [55:16]  (40) Packet Data Pointer
+                                                         [15:0]   (16) Packet Data Counter" */
+#else
+	uint64_t sbd                          : 64;
+#endif
+	} s;
+	struct cvmx_hna_sbd_dbg1_s            cn78xx;
+};
+typedef union cvmx_hna_sbd_dbg1 cvmx_hna_sbd_dbg1_t;
+
+/**
+ * cvmx_hna_sbd_dbg2
+ *
+ * Description: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
+ * are locked down. Otherwise, the contents of this register are the 'active' contents of the
+ * HNA Scoreboard at the time of the CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * model) on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
+ * assigned an instruction.
+ */
+union cvmx_hna_sbd_dbg2 {
+	uint64_t u64;
+	struct cvmx_hna_sbd_dbg2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd                          : 64; /**< "HNA ScoreBoard \#2 Data
+                                                         [63:45] (19) UNUSED
+                                                         [44:42]  (3) Instruction Type
+                                                         [41:5]  (37) rwptr[39:3]: Result Write Pointer
+                                                         [4:0]    (5) prwcnt[4:0]: Pending Result Write Counter" */
+#else
+	uint64_t sbd                          : 64;
+#endif
+	} s;
+	struct cvmx_hna_sbd_dbg2_s            cn78xx;
+};
+typedef union cvmx_hna_sbd_dbg2 cvmx_hna_sbd_dbg2_t;
+
+/**
+ * cvmx_hna_sbd_dbg3
+ *
+ * Description: When the HNA_CONTROL[SBDLCK] bit is written '1', the contents of this register
+ * are locked down. Otherwise, the contents of this register are the 'active' contents of the
+ * HNA Scoreboard at the time of the CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * model) on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
+ * assigned an instruction.
+ */
+union cvmx_hna_sbd_dbg3 {
+	uint64_t u64;
+	struct cvmx_hna_sbd_dbg3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd                          : 64; /**< "HNA ScoreBoard \#3 Data
+                                                         [63:52] (11) rptr[39:29]: Result Base Pointer (QW-aligned)
+                                                         [52:16] (37) glptr[39:3]: Gather List Pointer
+                                                         [15:0]  (16) glcnt Gather List Counter" */
+#else
+	uint64_t sbd                          : 64;
+#endif
+	} s;
+	struct cvmx_hna_sbd_dbg3_s            cn78xx;
+};
+typedef union cvmx_hna_sbd_dbg3 cvmx_hna_sbd_dbg3_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index ee35010..0c1ebbf 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -165,6 +165,17 @@ static inline uint64_t CVMX_L2C_CBCX_BIST_STATUS(unsigned long block_id)
 #define CVMX_L2C_CBCX_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180080E007F8ull) + ((block_id) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_L2C_CBCX_DLL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_L2C_CBCX_DLL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180080E00018ull) + ((block_id) & 3) * 0x40000ull;
+}
+#else
+#define CVMX_L2C_CBCX_DLL(block_id) (CVMX_ADD_IO_SEG(0x0001180080E00018ull) + ((block_id) & 3) * 0x40000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_L2C_CBCX_INT(unsigned long block_id)
 {
 	if (!(
@@ -189,6 +200,17 @@ static inline uint64_t CVMX_L2C_CBCX_IOCERR(unsigned long block_id)
 #define CVMX_L2C_CBCX_IOCERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080E007E8ull) + ((block_id) & 3) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((block_id >= 2) && (block_id <= 3))))))
+		cvmx_warn("CVMX_L2C_CBCX_MIBERR(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((block_id) & 3) * 0x40000ull - 262144*2;
+}
+#else
+#define CVMX_L2C_CBCX_MIBERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((block_id) & 3) * 0x40000ull - 262144*2)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_L2C_CBCX_RSDERR(unsigned long block_id)
 {
 	if (!(
@@ -913,12 +935,13 @@ static inline uint64_t CVMX_L2C_SPAR4_FUNC(void)
 static inline uint64_t CVMX_L2C_TADX_DLL(unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_DLL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180080A00018ull);
+	return CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id) & 7) * 0x40000ull;
 }
 #else
-#define CVMX_L2C_TADX_DLL(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00018ull))
+#define CVMX_L2C_TADX_DLL(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_L2C_TADX_ECC0(unsigned long block_id)
@@ -2236,6 +2259,19 @@ union cvmx_l2c_cbcx_bist_status {
 	uint64_t u64;
 	struct cvmx_l2c_cbcx_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_39_63               : 25;
+	uint64_t mibfl                        : 5;  /**< BIST failure status for various MIB memories. ([XMD, IPM, IRM, MXD, MXN]) */
+	uint64_t ioccmdfl                     : 2;  /**< BIST failure status for IOCCMD0-1. */
+	uint64_t rsdfl                        : 32; /**< BIST failure status for RSDQW0-31. */
+#else
+	uint64_t rsdfl                        : 32;
+	uint64_t ioccmdfl                     : 2;
+	uint64_t mibfl                        : 5;
+	uint64_t reserved_39_63               : 25;
+#endif
+	} s;
+	struct cvmx_l2c_cbcx_bist_status_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t ioccmdfl                     : 2;  /**< BIST failure status for IOCCMD0-1. */
 	uint64_t rsdfl                        : 32; /**< BIST failure status for RSDQW0-31. */
@@ -2244,13 +2280,37 @@ union cvmx_l2c_cbcx_bist_status {
 	uint64_t ioccmdfl                     : 2;
 	uint64_t reserved_34_63               : 30;
 #endif
-	} s;
-	struct cvmx_l2c_cbcx_bist_status_s    cn70xx;
+	} cn70xx;
 	struct cvmx_l2c_cbcx_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_cbcx_bist_status cvmx_l2c_cbcx_bist_status_t;
 
 /**
+ * cvmx_l2c_cbc#_dll
+ *
+ * Register for DLL observability
+ *
+ */
+union cvmx_l2c_cbcx_dll {
+	uint64_t u64;
+	struct cvmx_l2c_cbcx_dll_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t dll_setting                  : 12; /**< DLL setting. */
+	uint64_t dll_state                    : 3;  /**< DLL state. */
+	uint64_t dll_lock                     : 1;  /**< DLL locked. */
+#else
+	uint64_t dll_lock                     : 1;
+	uint64_t dll_state                    : 3;
+	uint64_t dll_setting                  : 12;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_l2c_cbcx_dll_s            cn78xx;
+};
+typedef union cvmx_l2c_cbcx_dll cvmx_l2c_cbcx_dll_t;
+
+/**
  * cvmx_l2c_cbc#_int
  *
  * This register is for CBC-based interrupts.
@@ -2260,6 +2320,25 @@ union cvmx_l2c_cbcx_int {
 	uint64_t u64;
 	struct cvmx_l2c_cbcx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_6_63                : 58;
+	uint64_t mibdbe                       : 1;  /**< MIB double-bit error occurred. See L2C_CBC(2..3)_MIBERR for logged information. */
+	uint64_t mibsbe                       : 1;  /**< MIB double-bit error occurred. See L2C_CBC(2..3)_MIBERR for logged information. */
+	uint64_t ioccmddbe                    : 1;  /**< IOCCMD double-bit error occurred. See L2C_CBC(0..3)_IOCERR for logged information. */
+	uint64_t ioccmdsbe                    : 1;  /**< IOCCMD single-bit error occurred. See L2C_CBC(0..3)_IOCERR for logged information. */
+	uint64_t rsddbe                       : 1;  /**< RSD double-bit error occurred. See L2C_CBC(0..3)_RSDERR for logged information. */
+	uint64_t rsdsbe                       : 1;  /**< RSD single-bit error occurred. See L2C_CBC(0..3)_RSDERR for logged information. */
+#else
+	uint64_t rsdsbe                       : 1;
+	uint64_t rsddbe                       : 1;
+	uint64_t ioccmdsbe                    : 1;
+	uint64_t ioccmddbe                    : 1;
+	uint64_t mibsbe                       : 1;
+	uint64_t mibdbe                       : 1;
+	uint64_t reserved_6_63                : 58;
+#endif
+	} s;
+	struct cvmx_l2c_cbcx_int_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t ioccmddbe                    : 1;  /**< IOCCMD double-bit error occurred. See L2C_CBC(0..3)_IOCERR for logged information. */
 	uint64_t ioccmdsbe                    : 1;  /**< IOCCMD single-bit error occurred. See L2C_CBC(0..3)_IOCERR for logged information. */
@@ -2272,8 +2351,7 @@ union cvmx_l2c_cbcx_int {
 	uint64_t ioccmddbe                    : 1;
 	uint64_t reserved_4_63                : 60;
 #endif
-	} s;
-	struct cvmx_l2c_cbcx_int_s            cn70xx;
+	} cn70xx;
 	struct cvmx_l2c_cbcx_int_s            cn78xx;
 };
 typedef union cvmx_l2c_cbcx_int cvmx_l2c_cbcx_int_t;
@@ -2313,6 +2391,45 @@ union cvmx_l2c_cbcx_iocerr {
 typedef union cvmx_l2c_cbcx_iocerr cvmx_l2c_cbcx_iocerr_t;
 
 /**
+ * cvmx_l2c_cbc#_miberr
+ *
+ * This register records error information for all CBC MIB errors.
+ * An error locks the INDEX, and SYN fields and set the bit corresponding to the error received.
+ * MIBDBE errors take priority and overwrite an earlier logged MIBSBE error. Only one of
+ * MIBSBE/MIBDBE is set at any given time and serves to document which error the INDEX/SYN is
+ * associated with.
+ * The syndrome is recorded for DBE errors, though the utility of the value is not clear.
+ */
+union cvmx_l2c_cbcx_miberr {
+	uint64_t u64;
+	struct cvmx_l2c_cbcx_miberr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t mibdbe                       : 1;  /**< INDEX/SYN corresponds to a double-bit MIB ECC error. */
+	uint64_t mibsbe                       : 1;  /**< INDEX/SYN corresponds to a single-bit MIB ECC error. */
+	uint64_t reserved_40_61               : 22;
+	uint64_t syn                          : 8;  /**< Error syndrome. */
+	uint64_t reserved_3_31                : 29;
+	uint64_t memid                        : 2;  /**< Indicates the memory that had the error.
+                                                         0x0 = Error from MXB_VC_MRN, MXB_VC_MFN, MXB_VC_MPN VCs.
+                                                         0x1 = Error from MXB_VC_MRD, MXB_VC_MPD VCs.
+                                                         0x2 = Error from MXB_VC_IRM VC.
+                                                         0x3 = Error from MXB_VC_IPM VC. */
+	uint64_t mibnum                       : 1;  /**< Indicates the CBC that had the error. */
+#else
+	uint64_t mibnum                       : 1;
+	uint64_t memid                        : 2;
+	uint64_t reserved_3_31                : 29;
+	uint64_t syn                          : 8;
+	uint64_t reserved_40_61               : 22;
+	uint64_t mibsbe                       : 1;
+	uint64_t mibdbe                       : 1;
+#endif
+	} s;
+	struct cvmx_l2c_cbcx_miberr_s         cn78xx;
+};
+typedef union cvmx_l2c_cbcx_miberr cvmx_l2c_cbcx_miberr_t;
+
+/**
  * cvmx_l2c_cbc#_rsderr
  *
  * This register records error information for all CBC RSD errors.
@@ -3252,17 +3369,13 @@ union cvmx_l2c_ctl {
 	uint64_t xmc_arb_mode                 : 1;  /**< Arbitration mode for XMC QOS queues
                                                          == 0, fully determined through QOS
                                                          == 1, QOS0 highest priority, QOS1-3 use normal mode */
-	uint64_t reserved_6_13                : 8;
-	uint64_t vab_thresh                   : 4;  /**< VAB Threshold
-                                                         When the number of valid VABs exceeds this number the
-                                                         L2C increases the priority of all writes in the LMC. */
+	uint64_t reserved_2_13                : 12;
 	uint64_t disecc                       : 1;  /**< Tag and Data ECC Disable */
 	uint64_t disidxalias                  : 1;  /**< Index Alias Disable */
 #else
 	uint64_t disidxalias                  : 1;
 	uint64_t disecc                       : 1;
-	uint64_t vab_thresh                   : 4;
-	uint64_t reserved_6_13                : 8;
+	uint64_t reserved_2_13                : 12;
 	uint64_t xmc_arb_mode                 : 1;
 	uint64_t rsp_arb_mode                 : 1;
 	uint64_t maxlfb                       : 4;
@@ -3574,7 +3687,48 @@ union cvmx_l2c_ctl {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} cn70xx;
-	struct cvmx_l2c_ctl_cn70xx            cn78xx;
+	struct cvmx_l2c_ctl_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t ocla_qos                     : 3;  /**< QOS level for the transactions from OCLA to L2C. */
+	uint64_t reserved_28_28               : 1;
+	uint64_t disstgl2i                    : 1;  /**< Disable STGL2Is from changing the tags. */
+	uint64_t reserved_25_26               : 2;
+	uint64_t discclk                      : 1;  /**< Disable conditional clocking in L2C PNR blocks. */
+	uint64_t reserved_16_23               : 8;
+	uint64_t rsp_arb_mode                 : 1;  /**< Arbitration mode for RSC/RSD bus. 0 = round-robin; 1 = static priority.
+                                                         1. IOR data
+                                                         2. STIN/FILLs
+                                                         3. STDN/SCDN/SCFL */
+	uint64_t xmc_arb_mode                 : 1;  /**< Arbitration mode for ADD bus QOS queues. 0 = fully determined through QOS, 1 = QOS0
+                                                         highest priority; QOS 1-7 use normal mode. */
+	uint64_t rdf_cnt                      : 8;  /**< Defines the sample point of the LMC response data in the DDR-clock/core-clock crossing.
+                                                         For optimal performance set to
+                                                         10 * (DDR-clock period/core-clock period) - 1.
+                                                         To disable set to 0. All other values are reserved. */
+	uint64_t reserved_3_5                 : 3;
+	uint64_t dissblkdty                   : 1;  /**< Disable bandwidth optimization between L2 and LMC and MOB which only transfers modified
+                                                         sub-blocks when possible. NOTE: in an OCI system all nodes must use the same setting of
+                                                         DISSBLKDTY or operation is undefined. FIXME: should reset to 0, once verif supports it. */
+	uint64_t disecc                       : 1;  /**< Tag and data ECC disable. */
+	uint64_t disidxalias                  : 1;  /**< Index alias disable. */
+#else
+	uint64_t disidxalias                  : 1;
+	uint64_t disecc                       : 1;
+	uint64_t dissblkdty                   : 1;
+	uint64_t reserved_3_5                 : 3;
+	uint64_t rdf_cnt                      : 8;
+	uint64_t xmc_arb_mode                 : 1;
+	uint64_t rsp_arb_mode                 : 1;
+	uint64_t reserved_16_23               : 8;
+	uint64_t discclk                      : 1;
+	uint64_t reserved_25_26               : 2;
+	uint64_t disstgl2i                    : 1;
+	uint64_t reserved_28_28               : 1;
+	uint64_t ocla_qos                     : 3;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} cn78xx;
 	struct cvmx_l2c_ctl_cn61xx            cnf71xx;
 };
 typedef union cvmx_l2c_ctl cvmx_l2c_ctl_t;
@@ -4230,6 +4384,27 @@ union cvmx_l2c_ecc_ctl {
 	uint64_t u64;
 	struct cvmx_l2c_ecc_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t xmdmskflip                   : 2;  /**< Generate an ECC error in the XMD MSK. */
+	uint64_t mibflip                      : 2;  /**< Generate an ECC error in the MIB. See note above. */
+	uint64_t l2dflip                      : 2;  /**< Generate an ECC error in the L2D. See note above. */
+	uint64_t l2tflip                      : 2;  /**< Generate an ECC error in the L2T. */
+	uint64_t rdfflip                      : 2;  /**< Generate an ECC error in RDF memory. */
+	uint64_t xmdflip                      : 2;  /**< Generate an ECC error in all corresponding CBC XMD memories. */
+	uint64_t ioccmdflip                   : 2;  /**< Generate an ECC error in all corresponding IOCCMD memories. */
+#else
+	uint64_t ioccmdflip                   : 2;
+	uint64_t xmdflip                      : 2;
+	uint64_t rdfflip                      : 2;
+	uint64_t l2tflip                      : 2;
+	uint64_t l2dflip                      : 2;
+	uint64_t mibflip                      : 2;
+	uint64_t xmdmskflip                   : 2;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_l2c_ecc_ctl_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t l2dflip                      : 2;  /**< Generate an ECC error in the L2D. See note above. */
 	uint64_t l2tflip                      : 2;  /**< Generate an ECC error in the L2T. */
@@ -4244,8 +4419,7 @@ union cvmx_l2c_ecc_ctl {
 	uint64_t l2dflip                      : 2;
 	uint64_t reserved_10_63               : 54;
 #endif
-	} s;
-	struct cvmx_l2c_ecc_ctl_s             cn70xx;
+	} cn70xx;
 	struct cvmx_l2c_ecc_ctl_s             cn78xx;
 };
 typedef union cvmx_l2c_ecc_ctl cvmx_l2c_ecc_ctl_t;
@@ -5776,7 +5950,18 @@ union cvmx_l2c_oci_ctl {
 	uint64_t u64;
 	struct cvmx_l2c_oci_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_7_63                : 57;
+	uint64_t cas_fdx                      : 1;  /**< When set, L2 STC/CAS operations performed at the home will immediately bring the block
+                                                         exclusive into the home. Default operation is to first request the block shared and only
+                                                         invalidate the remote if the compare succeeds. */
+	uint64_t rldd_psha                    : 1;  /**< When set, RLDD will be assumed to return a shared response (PSHA). Default operation will
+                                                         assume an exclusive response (PEMD). Note that an incorrect assumption only causes an
+                                                         extra tag write to be done upon receiving the response. */
+	uint64_t lock_local                   : 1;  /**< When set, L2 atomic operations (excluding CAS/STC) to remote addresses which miss at the
+                                                         requester will be performed locally on the requesting node. Default operation will instead
+                                                         send the atomic request to be performed on the home node. Note that CAS/STC operations
+                                                         which miss at the requester will always be performed at the home node regardless of this
+                                                         setting. */
 	uint64_t iofrcl                       : 1;  /**< When set, L2C services all I/O read and write operations on the local node, regardless of
                                                          the value of the node ID bits in the physical address. During normal operation this bit is
                                                          expected to be 0. */
@@ -5789,7 +5974,10 @@ union cvmx_l2c_oci_ctl {
 	uint64_t enaoci                       : 1;
 	uint64_t gksegnode                    : 2;
 	uint64_t iofrcl                       : 1;
-	uint64_t reserved_4_63                : 60;
+	uint64_t lock_local                   : 1;
+	uint64_t rldd_psha                    : 1;
+	uint64_t cas_fdx                      : 1;
+	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
 	struct cvmx_l2c_oci_ctl_s             cn78xx;
@@ -6700,7 +6888,7 @@ union cvmx_l2c_tadx_dll {
 	uint64_t reserved_16_63               : 48;
 	uint64_t dll_setting                  : 12; /**< DLL setting. */
 	uint64_t dll_state                    : 3;  /**< DLL state. */
-	uint64_t dll_lock                     : 1;  /**< ==1, DLL is locked. */
+	uint64_t dll_lock                     : 1;  /**< DLL locked. */
 #else
 	uint64_t dll_lock                     : 1;
 	uint64_t dll_state                    : 3;
@@ -6709,6 +6897,7 @@ union cvmx_l2c_tadx_dll {
 #endif
 	} s;
 	struct cvmx_l2c_tadx_dll_s            cn70xx;
+	struct cvmx_l2c_tadx_dll_s            cn78xx;
 };
 typedef union cvmx_l2c_tadx_dll cvmx_l2c_tadx_dll_t;
 
@@ -6807,6 +6996,34 @@ union cvmx_l2c_tadx_err {
 	uint64_t bigwr                        : 1;  /**< Logged information is for a BIGWR error. */
 	uint64_t holerd                       : 1;  /**< Logged information is for a HOLERD error. */
 	uint64_t holewr                       : 1;  /**< Logged information is for a HOLEWR error. */
+	uint64_t reserved_59_59               : 1;
+	uint64_t cmd                          : 8;  /**< XMC command of request causing error. FIXME, needs better description for OCI */
+	uint64_t source                       : 7;  /**< XMC 'source' of request causing error. If SOURCE<6>==0, SOURCE<5:0> = PPID else
+                                                         SOURCE<3:0> is BUSID of IOB which made the request. */
+	uint64_t node                         : 4;  /**< OCI Node of XMC request causing error. For BIG* errors NODE will always be the node
+                                                         logging the error (BIG* errors are logged at the home node). For HOLE* errors, NODE could
+                                                         be any OCI node in the system (HOLE* errors are logged at the requester node). */
+	uint64_t addr                         : 40; /**< XMC address causing the error. This field is the physical address after hole removal and
+                                                         index aliasing (if enabled). (The hole is between DR0 and DR1. Remove the hole by
+                                                         subtracting 256MB from all L2/DRAM physical addresses >= 512 MB.) */
+#else
+	uint64_t addr                         : 40;
+	uint64_t node                         : 4;
+	uint64_t source                       : 7;
+	uint64_t cmd                          : 8;
+	uint64_t reserved_59_59               : 1;
+	uint64_t holewr                       : 1;
+	uint64_t holerd                       : 1;
+	uint64_t bigwr                        : 1;
+	uint64_t bigrd                        : 1;
+#endif
+	} s;
+	struct cvmx_l2c_tadx_err_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t bigrd                        : 1;  /**< Logged information is for a BIGRD error. */
+	uint64_t bigwr                        : 1;  /**< Logged information is for a BIGWR error. */
+	uint64_t holerd                       : 1;  /**< Logged information is for a HOLERD error. */
+	uint64_t holewr                       : 1;  /**< Logged information is for a HOLEWR error. */
 	uint64_t reserved_58_59               : 2;
 	uint64_t cmd                          : 7;  /**< XMC command of request causing error. */
 	uint64_t source                       : 7;  /**< XMC 'source' of request causing error. If SOURCE<6>==0, SOURCE<5:0> = PPID else
@@ -6828,8 +7045,7 @@ union cvmx_l2c_tadx_err {
 	uint64_t bigwr                        : 1;
 	uint64_t bigrd                        : 1;
 #endif
-	} s;
-	struct cvmx_l2c_tadx_err_s            cn70xx;
+	} cn70xx;
 	struct cvmx_l2c_tadx_err_s            cn78xx;
 };
 typedef union cvmx_l2c_tadx_err cvmx_l2c_tadx_err_t;
@@ -7333,26 +7549,12 @@ union cvmx_l2c_tadx_tag {
 	uint64_t u64;
 	struct cvmx_l2c_tadx_tag_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. INTERNAL: 70xx does not implement true sub-block dirty bits,
-                                                         therefore when L2C_TAD_TAG is written, it is set to all ones if DIRTY is 1, or all zeroes
-                                                         if DIRTY is zero. LTGL2I will always result in similar legal values being loaded. */
-	uint64_t reserved_57_59               : 3;
-	uint64_t businfo                      : 9;  /**< The bus information bits */
-	uint64_t reserved_47_47               : 1;
-	uint64_t ecc                          : 7;  /**< The tag ECC */
-	uint64_t reserved_3_39                : 37;
-	uint64_t valid                        : 1;  /**< The valid bit */
-	uint64_t dirty                        : 1;  /**< The dirty bit */
+	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits.  Ignored/loaded with 0 for RTG accesses. */
+	uint64_t reserved_1_59                : 59;
 	uint64_t lock                         : 1;  /**< The lock bit */
 #else
 	uint64_t lock                         : 1;
-	uint64_t dirty                        : 1;
-	uint64_t valid                        : 1;
-	uint64_t reserved_3_39                : 37;
-	uint64_t ecc                          : 7;
-	uint64_t reserved_47_47               : 1;
-	uint64_t businfo                      : 9;
-	uint64_t reserved_57_59               : 3;
+	uint64_t reserved_1_59                : 59;
 	uint64_t sblkdty                      : 4;
 #endif
 	} s;
@@ -7421,32 +7623,32 @@ union cvmx_l2c_tadx_tag {
 	} cn70xx;
 	struct cvmx_l2c_tadx_tag_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. INTERNAL: 70xx does not implement true sub-block dirty bits,
-                                                         therefore when L2C_TAD_TAG is written, it is set to all ones if DIRTY is 1, or all zeroes
-                                                         if DIRTY is zero. LTGL2I will always result in similar legal values being loaded. */
-	uint64_t reserved_57_59               : 3;
-	uint64_t businfo                      : 9;  /**< The bus information bits */
-	uint64_t reserved_47_47               : 1;
-	uint64_t ecc                          : 7;  /**< The tag ECC. This field is undefined if L2C_CTL[DISECC] is not 1 when the LTGL2I reads the tags. */
-	uint64_t tag                          : 20; /**< The tag. The tag is the corresponding bits from the L2C+LMC internal L2/DRAM byte address. */
+	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits.  Ignored/loaded with 0 for RTG accesses. */
+	uint64_t reserved_58_59               : 2;
+	uint64_t businfo                      : 9;  /**< The bus information bits.  Ignored/loaded with 0 for RTG accesses. */
+	uint64_t ecc                          : 7;  /**< The tag ECC. This field is undefined if L2C_CTL[DISECC] is not 1 when the LTGL2I reads the
+                                                         tags. */
+	uint64_t tag                          : 22; /**< The tag. TAG[39:20] is the corresponding bits from the L2C+LMC internal L2/DRAM byte
+                                                         address. TAG[41:40] is the OCI node of the address. The RTG must always have the
+                                                         TAG[41:40] == to
+                                                         the current node or operation is undefined. */
 	uint64_t reserved_4_19                : 16;
 	uint64_t used                         : 1;  /**< The LRU use bit. If setting the LOCK bit, the USE bit should also be set or the operation
-                                                         is undefined. */
-	uint64_t valid                        : 1;  /**< The valid bit */
-	uint64_t dirty                        : 1;  /**< The dirty bit */
+                                                         is undefined.  Ignored/loaded with 0 for RTG accesses. */
+	uint64_t ts                           : 2;  /**< The TAG state. 0 - Invalid; 1 - Shared; 2 - Exclusive. Note that a local address will
+                                                         never have the value of 2 (Exclusive) as that state is encoded as Shared in the TAG and
+                                                         Invalid in the RTG. */
 	uint64_t lock                         : 1;  /**< The lock bit. If setting the LOCK bit, the USE bit should also be set or the operation is
-                                                         undefined. */
+                                                         undefined.  Ignored/loaded with 0 for RTG accesses. */
 #else
 	uint64_t lock                         : 1;
-	uint64_t dirty                        : 1;
-	uint64_t valid                        : 1;
+	uint64_t ts                           : 2;
 	uint64_t used                         : 1;
 	uint64_t reserved_4_19                : 16;
-	uint64_t tag                          : 20;
+	uint64_t tag                          : 22;
 	uint64_t ecc                          : 7;
-	uint64_t reserved_47_47               : 1;
 	uint64_t businfo                      : 9;
-	uint64_t reserved_57_59               : 3;
+	uint64_t reserved_58_59               : 2;
 	uint64_t sblkdty                      : 4;
 #endif
 	} cn78xx;
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index 2d99b4b..12bc845 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -600,6 +600,17 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long block_id)
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_ECC_PARITY_TEST(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_ECC_PARITY_TEST(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000108ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_ECC_PARITY_TEST(block_id) (CVMX_ADD_IO_SEG(0x0001180088000108ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
@@ -1938,7 +1949,19 @@ union cvmx_lmcx_char_mask4 {
 	uint64_t u64;
 	struct cvmx_lmcx_char_mask4_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_45_63               : 19;
+	uint64_t ref_pin_on_mask              : 9;  /**< INTERNAL: This mask is applied to the REF_PIN_ON signals that go to
+                                                         the PHY, so that each byte lane can selectively turn off or on the signals
+                                                         once the master signals is enabled.  Using the symbol R, the mask looks
+                                                         like this:
+                                                         RRRRRRRRR
+                                                         876543210 */
+	uint64_t dac_on_mask                  : 9;  /**< INTERNAL: This mask is applied to the DAC_ON signals that go to
+                                                         the PHY, so that each byte lane can selectively turn off or on the signals
+                                                         once the master signals are enabled.  Using the symbols D  for DAC_ON,
+                                                         the mask looks like this:
+                                                         DDDDDDDDD
+                                                         876543210 */
+	uint64_t reserved_45_45               : 1;
 	uint64_t dbi_mask                     : 9;  /**< Mask for DBI/DQS<1>. */
 	uint64_t par_mask                     : 1;  /**< Mask for PAR. */
 	uint64_t act_n_mask                   : 1;  /**< Mask for ACT_N. */
@@ -1970,7 +1993,9 @@ union cvmx_lmcx_char_mask4 {
 	uint64_t act_n_mask                   : 1;
 	uint64_t par_mask                     : 1;
 	uint64_t dbi_mask                     : 9;
-	uint64_t reserved_45_63               : 19;
+	uint64_t reserved_45_45               : 1;
+	uint64_t dac_on_mask                  : 9;
+	uint64_t ref_pin_on_mask              : 9;
 #endif
 	} s;
 	struct cvmx_lmcx_char_mask4_cn61xx {
@@ -2007,7 +2032,43 @@ union cvmx_lmcx_char_mask4 {
 	struct cvmx_lmcx_char_mask4_cn61xx    cn66xx;
 	struct cvmx_lmcx_char_mask4_cn61xx    cn68xx;
 	struct cvmx_lmcx_char_mask4_cn61xx    cn68xxp1;
-	struct cvmx_lmcx_char_mask4_s         cn70xx;
+	struct cvmx_lmcx_char_mask4_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_45_63               : 19;
+	uint64_t dbi_mask                     : 9;  /**< Mask for DBI/DQS<1>. */
+	uint64_t par_mask                     : 1;  /**< Mask for PAR. */
+	uint64_t act_n_mask                   : 1;  /**< Mask for ACT_N. */
+	uint64_t a17_mask                     : 1;  /**< Mask for A17. */
+	uint64_t reset_n_mask                 : 1;  /**< Mask for RESET_L. */
+	uint64_t a_mask                       : 16; /**< Mask for A<15:0>. */
+	uint64_t ba_mask                      : 3;  /**< Mask for BA<2:0>. */
+	uint64_t we_n_mask                    : 1;  /**< Mask for WE_N. */
+	uint64_t cas_n_mask                   : 1;  /**< Mask for CAS_N. */
+	uint64_t ras_n_mask                   : 1;  /**< Mask for RAS_N. */
+	uint64_t odt1_mask                    : 2;  /**< Mask for ODT1. */
+	uint64_t odt0_mask                    : 2;  /**< Mask for ODT0. */
+	uint64_t cs1_n_mask                   : 2;  /**< Mask for CS1_N. */
+	uint64_t cs0_n_mask                   : 2;  /**< Mask for CS0_N. */
+	uint64_t cke_mask                     : 2;  /**< Mask for CKE*. */
+#else
+	uint64_t cke_mask                     : 2;
+	uint64_t cs0_n_mask                   : 2;
+	uint64_t cs1_n_mask                   : 2;
+	uint64_t odt0_mask                    : 2;
+	uint64_t odt1_mask                    : 2;
+	uint64_t ras_n_mask                   : 1;
+	uint64_t cas_n_mask                   : 1;
+	uint64_t we_n_mask                    : 1;
+	uint64_t ba_mask                      : 3;
+	uint64_t a_mask                       : 16;
+	uint64_t reset_n_mask                 : 1;
+	uint64_t a17_mask                     : 1;
+	uint64_t act_n_mask                   : 1;
+	uint64_t par_mask                     : 1;
+	uint64_t dbi_mask                     : 9;
+	uint64_t reserved_45_63               : 19;
+#endif
+	} cn70xx;
 	struct cvmx_lmcx_char_mask4_s         cn78xx;
 	struct cvmx_lmcx_char_mask4_cn61xx    cnf71xx;
 };
@@ -5362,7 +5423,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_ddr_pll_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_31_63               : 33;
+	uint64_t reserved_32_63               : 32;
+	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
 	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC(0..3)_DDR_PLL_CTL[DDR4_MODE]. */
 	uint64_t ddr4_mode                    : 1;  /**< DDR4 mode select: 1 = DDR4, 0 = DDR3. */
 	uint64_t pll_fbslip                   : 1;  /**< PLL FBSLIP indication. */
@@ -5387,7 +5449,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t pll_fbslip                   : 1;
 	uint64_t ddr4_mode                    : 1;
 	uint64_t phy_dcok                     : 1;
-	uint64_t reserved_31_63               : 33;
+	uint64_t dclk_invert                  : 1;
+	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
 	struct cvmx_lmcx_ddr_pll_ctl_cn61xx {
@@ -5510,7 +5573,63 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} cn70xx;
-	struct cvmx_lmcx_ddr_pll_ctl_cn70xx   cn78xx;
+	struct cvmx_lmcx_ddr_pll_ctl_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
+	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC(0..3)_DDR_PLL_CTL[DDR4_MODE]. */
+	uint64_t ddr4_mode                    : 1;  /**< DDR4 mode select: 1 = DDR4, 0 = DDR3. */
+	uint64_t pll_fbslip                   : 1;  /**< PLL FBSLIP indication. */
+	uint64_t pll_lock                     : 1;  /**< PLL LOCK indication. */
+	uint64_t pll_rfslip                   : 1;  /**< PLL RFSLIP indication. */
+	uint64_t clkr                         : 2;  /**< PLL post-divider control. */
+	uint64_t jtg_test_mode                : 1;  /**< Reserved; must be zero. INTERNAL: JTAG test mode. Clock alignment between DCLK & REFCLK as
+                                                         well as FCLK & REFCLK can only be performed after the ddr_pll_divider_reset is deasserted.
+                                                         SW need to wait at least 10 reference clock cycles after deasserting pll_divider_reset
+                                                         before asserting LMC(0..3)_DDR_PLL_CTL[JTG_TEST_MODE]. During alignment (which can take up
+                                                         to 160 microseconds) DCLK and FCLK can exhibit some high-frequency pulses. Therefore, all
+                                                         bring up activities in that clock domain need to be delayed (when the chip operates in
+                                                         jtg_test_mode) by about 160 microseconds to ensure that lock is achieved. */
+	uint64_t ddr_div_reset                : 1;  /**< DDR postscalar divider reset. */
+	uint64_t ddr_ps_en                    : 4;  /**< DDR postscalar divide ratio. Determines the LMC CK speed.
+                                                         0x0 = divide LMC PLL by TBD.
+                                                         0x1 = divide LMC PLL by TBD.
+                                                         0x2 = divide LMC PLL by TBD.
+                                                         0x3 = divide LMC PLL by TBD.
+                                                         0x4 = divide LMC PLL by TBD.
+                                                         0x5 = divide LMC PLL by TBD.
+                                                         0x6 = divide LMC PLL by TBD.
+                                                         0x7 = divide LMC PLL by TBD.
+                                                         0x8 = divide LMC PLL by TBD.
+                                                         0x9 = divide LMC PLL by TBD.
+                                                         0xA = divide LMC PLL by TBD.
+                                                         0xB = divide LMC PLL by TBD.
+                                                         0xC = divide LMC PLL by TBD.
+                                                         0xD = divide LMC PLL by TBD.
+                                                         0xE = divide LMC PLL by TBD.
+                                                         0xF = divide LMC PLL by TBD.
+                                                         DDR_PS_EN is not used when DDR_DIV_RESET = 1 */
+	uint64_t reserved_8_17                : 10;
+	uint64_t reset_n                      : 1;  /**< PLL reset */
+	uint64_t clkf                         : 7;  /**< Multiply reference by CLKF. 32 <= CLKF <= 64. LMC PLL frequency = 50 * CLKF. min = 1.6
+                                                         GHz, max = 3.2 GHz. */
+#else
+	uint64_t clkf                         : 7;
+	uint64_t reset_n                      : 1;
+	uint64_t reserved_8_17                : 10;
+	uint64_t ddr_ps_en                    : 4;
+	uint64_t ddr_div_reset                : 1;
+	uint64_t jtg_test_mode                : 1;
+	uint64_t clkr                         : 2;
+	uint64_t pll_rfslip                   : 1;
+	uint64_t pll_lock                     : 1;
+	uint64_t pll_fbslip                   : 1;
+	uint64_t ddr4_mode                    : 1;
+	uint64_t phy_dcok                     : 1;
+	uint64_t dclk_invert                  : 1;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} cn78xx;
 	struct cvmx_lmcx_ddr_pll_ctl_cn61xx   cnf71xx;
 };
 typedef union cvmx_lmcx_ddr_pll_ctl cvmx_lmcx_ddr_pll_ctl_t;
@@ -6213,6 +6332,42 @@ union cvmx_lmcx_dual_memcfg {
 typedef union cvmx_lmcx_dual_memcfg cvmx_lmcx_dual_memcfg_t;
 
 /**
+ * cvmx_lmc#_ecc_parity_test
+ *
+ * This register has bits to control the ECC and CA Parity errors creation during test modes.
+ * ECC error is generated by enabling the CA_PARITY_CORRUPT_ENA bit of this register and
+ * selecting any ECC_CORRUPT_IDX index of the dataword from the cacheline to be
+ * corrupted. User can select which bit of the 128-bits dataword to corrupt by asserting
+ * any of the CHAR_MASK0 and CHAR_MASK2 bits. (CHAR_MASK0 and CHAR_MASK2 corresponds to the
+ * lower and upper 64-bit signal that can corrupt any individual bit of the data).
+ *
+ * CA Parity error is generated by enabling CA_PARITY_CORRUPT_ENA bit of this register and
+ * selecting the DDR command that the parity is to be corrupted with through CA_PARITY_SEL.
+ */
+union cvmx_lmcx_ecc_parity_test {
+	uint64_t u64;
+	struct cvmx_lmcx_ecc_parity_test_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t ecc_corrupt_ena              : 1;  /**< enables the ECC data corruption. */
+	uint64_t ecc_corrupt_idx              : 3;  /**< selects the cacheline index that the dataword is to be corrupted with */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t ca_parity_corrupt_ena        : 1;  /**< enables the CA Parity bit corruption. */
+	uint64_t ca_parity_sel                : 5;  /**< selects the type of DDR command to corrupt the parity bit. */
+#else
+	uint64_t ca_parity_sel                : 5;
+	uint64_t ca_parity_corrupt_ena        : 1;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t ecc_corrupt_idx              : 3;
+	uint64_t ecc_corrupt_ena              : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_lmcx_ecc_parity_test_s    cn78xx;
+};
+typedef union cvmx_lmcx_ecc_parity_test cvmx_lmcx_ecc_parity_test_t;
+
+/**
  * cvmx_lmc#_ecc_synd
  *
  * LMC_ECC_SYND = MRD ECC Syndromes
@@ -6284,7 +6439,32 @@ union cvmx_lmcx_ext_config {
 	uint64_t u64;
 	struct cvmx_lmcx_ext_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_29_63               : 35;
+	uint64_t reserved_46_63               : 18;
+	uint64_t error_alert_n_sample         : 1;  /**< Read to get a sample of the DRAM error_alert_n pin. */
+	uint64_t ea_int_polarity              : 1;  /**< Set to invert error_alert_n interrupt polarity.  When clear, interrupt will be signaled
+                                                         on the rising edge of error_alert_n.  When set, interrupt will be signeld on the falling
+                                                         edge of error_alert_n. */
+	uint64_t reserved_43_43               : 1;
+	uint64_t par_addr_mask                : 3;  /**< Mask applied to parity for address bits 14, 13, and 12.  Clear to exclude these
+                                                         address bits from the parity calculation, necessary if the DRAM device does not
+                                                         have these pins. */
+	uint64_t reserved_38_39               : 2;
+	uint64_t mrs_cmd_override             : 1;  /**< Set to override behavior of MRS and RCS DRAM operations. */
+	uint64_t mrs_cmd_select               : 1;  /**< When LMC(0..3)_EXT_CONFIG[MRS_CMD_OVERRIDE] is set, use this bit to select which
+                                                         style of operation for MRS and RCW commands.  If clear, select operation where
+                                                         signals other than CS are active before and after the CS_N active cycle.  When set,
+                                                         select operation where the other command signals (RAS_N,CAS_N,WE_n,ADDR,etc) all are
+                                                         active only during the cycle where the CS_N is also active. */
+	uint64_t reserved_33_35               : 3;
+	uint64_t invert_data                  : 1;  /**< Set this bit to cause all data to be inverted before writing or reading to/from
+                                                         DRAM - this effectively uses the scramble logic to instead invert all the data,
+                                                         so this bit must not be set if data scrambling is enabled.  May be useful if
+                                                         data inversion will result in lower power. */
+	uint64_t reserved_30_31               : 2;
+	uint64_t cmd_rti                      : 1;  /**< Set this bit to change the behavior of the LMC to return to a completely
+                                                         idle command (no CS active, no command pins active, and address/ba/bg all low)
+                                                         on the interface after an active command, rather than only forcing the CS
+                                                         inactive between commands. */
 	uint64_t cal_ena                      : 1;  /**< Set to cause LMC to operate in CAL mode.  DRAM mode registers must first be
                                                          programmed into CAL mode, then set CAL_ENABLE. */
 	uint64_t reserved_27_27               : 1;
@@ -6331,7 +6511,18 @@ union cvmx_lmcx_ext_config {
 	uint64_t par_include_a17              : 1;
 	uint64_t reserved_27_27               : 1;
 	uint64_t cal_ena                      : 1;
-	uint64_t reserved_29_63               : 35;
+	uint64_t cmd_rti                      : 1;
+	uint64_t reserved_30_31               : 2;
+	uint64_t invert_data                  : 1;
+	uint64_t reserved_33_35               : 3;
+	uint64_t mrs_cmd_select               : 1;
+	uint64_t mrs_cmd_override             : 1;
+	uint64_t reserved_38_39               : 2;
+	uint64_t par_addr_mask                : 3;
+	uint64_t reserved_43_43               : 1;
+	uint64_t ea_int_polarity              : 1;
+	uint64_t error_alert_n_sample         : 1;
+	uint64_t reserved_46_63               : 18;
 #endif
 	} s;
 	struct cvmx_lmcx_ext_config_cn70xx {
@@ -7788,7 +7979,9 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_mr_mpr_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_53_63               : 11;
+	uint64_t reserved_57_63               : 7;
+	uint64_t mr_wr_bg1                    : 1;  /**< BG1 part of address select for MRS in DDR4 mode. */
+	uint64_t reserved_53_55               : 3;
 	uint64_t mr_wr_use_default_value      : 1;  /**< When set, write the value to the MR that is computed from the value set in various CSR
                                                          fields that would be used during initialization, rather that using the value in the
                                                          LMC(0..3)_MR_MPR_CTL[MR_WR_ADDR] CSR field.  Useful to re-write the same value or
@@ -7827,7 +8020,9 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t mpr_byte_select              : 4;
 	uint64_t mpr_whole_byte_enable        : 1;
 	uint64_t mr_wr_use_default_value      : 1;
-	uint64_t reserved_53_63               : 11;
+	uint64_t reserved_53_55               : 3;
+	uint64_t mr_wr_bg1                    : 1;
+	uint64_t reserved_57_63               : 7;
 #endif
 	} s;
 	struct cvmx_lmcx_mr_mpr_ctl_cn70xx {
@@ -8122,10 +8317,10 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. INTERNAL: Write 1 to start deskew data read operation, will automatically clear
                                                          to 0. Write to 1 will also clear the complete bit. */
 	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. INTERNAL: Adjust clock toggle rate for reading deskew debug information:
-                                                         0 = Deskew read clock toggles every 1 DCLK
-                                                         1 = Deskew read clock toggles every 2 DCLKs
-                                                         2 = Deskew read clock toggles every 3 DCLKs
-                                                         3 = Deskew read clock toggles every 4 DCLKs */
+                                                         0 = Deskew read clock toggles every 4 DCLK
+                                                         1 = Deskew read clock toggles every 8 DCLKs
+                                                         2 = Deskew read clock toggles every 12 DCLKs
+                                                         3 = Deskew read clock toggles every 16 DCLKs */
 	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
                                                          DDR PHY. */
 	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 415e06f..eae4d32 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -497,7 +497,7 @@ static inline uint64_t CVMX_MIO_FUS_DAT4_FUNC(void)
 #define CVMX_MIO_FUS_EMA CVMX_MIO_FUS_EMA_FUNC()
 static inline uint64_t CVMX_MIO_FUS_EMA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_EMA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001550ull);
 }
@@ -4597,11 +4597,12 @@ union cvmx_mio_fus_dat3 {
 	uint64_t u64;
 	struct cvmx_mio_fus_dat3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_58_63               : 6;
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - DFA information (DTE) */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - DFA information (Cluster mask) */
-	uint64_t reserved_38_40               : 3;
+	uint64_t reserved_40_40               : 1;
+	uint64_t ema                          : 2;  /**< Fuse information - EMA */
 	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown */
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown */
 	uint64_t pll_half_dis                 : 1;  /**< Fuse information - RCLK PLL control */
@@ -4614,9 +4615,9 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore */
 	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable */
 	uint64_t nodfa_dte                    : 1;  /**< Fuse information - DFA Disable (DTE) */
-	uint64_t icache                       : 24; /**< Fuse information - ICACHE Hard Repair Data */
+	uint64_t reserved_0_23                : 24;
 #else
-	uint64_t icache                       : 24;
+	uint64_t reserved_0_23                : 24;
 	uint64_t nodfa_dte                    : 1;
 	uint64_t nozip                        : 1;
 	uint64_t efus_ign                     : 1;
@@ -4628,11 +4629,12 @@ union cvmx_mio_fus_dat3 {
 	uint64_t pll_half_dis                 : 1;
 	uint64_t efus_lck_man                 : 1;
 	uint64_t efus_lck_rsv                 : 1;
-	uint64_t reserved_38_40               : 3;
+	uint64_t ema                          : 2;
+	uint64_t reserved_40_40               : 1;
 	uint64_t dfa_info_clm                 : 4;
 	uint64_t dfa_info_dte                 : 3;
 	uint64_t pll_ctl                      : 10;
-	uint64_t reserved_58_63               : 6;
+	uint64_t ema0                         : 6;
 #endif
 	} s;
 	struct cvmx_mio_fus_dat3_cn30xx {
@@ -4802,7 +4804,7 @@ union cvmx_mio_fus_dat3 {
 	struct cvmx_mio_fus_dat3_cn61xx       cn68xxp1;
 	struct cvmx_mio_fus_dat3_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ema                          : 6;  /**< Fuse information - EMA. */
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
@@ -4811,11 +4813,11 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
 	uint64_t pll_half_dis                 : 1;  /**< Fuse information - Coprocessor-clock PLL control. */
 	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C cripple:
-                                                         0x0 = 16-way, 2MB cache
-                                                         0x1 = 12-way, 1.5MB cache
-                                                         0x2 = 8-way, 1MB cache
-                                                         0x3 = 4-way, 512KB cache
-                                                         0x4-0x7 = reserved */
+                                                         0 -- full cache (4-way 512KB)
+                                                         1 -- 3/4 ways   (3-way 384KB)
+                                                         2 -- 1/2 ways   (2-way 256KB)
+                                                         3 -- 1/4 ways   (1-way 128KB)
+                                                         4-7 -- illegal */
 	uint64_t reserved_31_31               : 1;
 	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information */
 	uint64_t bar2_en                      : 1;  /**< Fuse information - BAR2 present (when blown `1') */
@@ -4823,9 +4825,11 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore */
 	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable */
 	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE) */
-	uint64_t reserved_0_23                : 24;
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. */
+	uint64_t reserved_0_17                : 18;
 #else
-	uint64_t reserved_0_23                : 24;
+	uint64_t reserved_0_17                : 18;
+	uint64_t ema1                         : 6;
 	uint64_t nodfa_dte                    : 1;
 	uint64_t nozip                        : 1;
 	uint64_t efus_ign                     : 1;
@@ -4841,10 +4845,61 @@ union cvmx_mio_fus_dat3 {
 	uint64_t dfa_info_clm                 : 4;
 	uint64_t dfa_info_dte                 : 3;
 	uint64_t pll_ctl                      : 10;
-	uint64_t ema                          : 6;
+	uint64_t ema0                         : 6;
 #endif
 	} cn70xx;
-	struct cvmx_mio_fus_dat3_cn70xx       cn78xx;
+	struct cvmx_mio_fus_dat3_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
+	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
+	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
+	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
+	uint64_t reserved_38_40               : 3;
+	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t pll_half_dis                 : 1;  /**< Fuse information - Coprocessor-clock PLL control. */
+	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C cripple:
+                                                         0x0 = Full cache (16-way, 16 MB)
+                                                         0x1 = 3/4 ways (12-way, 12 MB)
+                                                         0x2 = 1/2 ways (8-way, 8 MB)
+                                                         0x3 = 1/4 ways (4-way, 4MB)
+                                                         0x4-0x7 = Reserved */
+	uint64_t reserved_31_31               : 1;
+	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information */
+	uint64_t bar2_en                      : 1;  /**< Fuse information - BAR2 present (when blown `1') */
+	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown */
+	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore */
+	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable */
+	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE) */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. */
+	uint64_t nohna_dte                    : 1;  /**< Fuse information - HNA disable (DTE). */
+	uint64_t hna_info_dte                 : 3;  /**< Fuse information - HNA information (DTE). */
+	uint64_t hna_info_clm                 : 4;  /**< Fuse information - HNA information (cluster mask). */
+	uint64_t reserved_0_9                 : 10;
+#else
+	uint64_t reserved_0_9                 : 10;
+	uint64_t hna_info_clm                 : 4;
+	uint64_t hna_info_dte                 : 3;
+	uint64_t nohna_dte                    : 1;
+	uint64_t ema1                         : 6;
+	uint64_t nodfa_dte                    : 1;
+	uint64_t nozip                        : 1;
+	uint64_t efus_ign                     : 1;
+	uint64_t efus_lck                     : 1;
+	uint64_t bar2_en                      : 1;
+	uint64_t zip_info                     : 2;
+	uint64_t reserved_31_31               : 1;
+	uint64_t l2c_crip                     : 3;
+	uint64_t pll_half_dis                 : 1;
+	uint64_t efus_lck_man                 : 1;
+	uint64_t efus_lck_rsv                 : 1;
+	uint64_t reserved_38_40               : 3;
+	uint64_t dfa_info_clm                 : 4;
+	uint64_t dfa_info_dte                 : 3;
+	uint64_t pll_ctl                      : 10;
+	uint64_t ema0                         : 6;
+#endif
+	} cn78xx;
 	struct cvmx_mio_fus_dat3_cn61xx       cnf71xx;
 };
 typedef union cvmx_mio_fus_dat3 cvmx_mio_fus_dat3_t;
@@ -4857,14 +4912,14 @@ union cvmx_mio_fus_dat4 {
 	struct cvmx_mio_fus_dat4_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_52_63               : 12;
-	uint64_t east_rclk_byp_select         : 1;  /**< N/A */
+	uint64_t east_rclk_byp_select         : 1;  /**< Reserved. */
 	uint64_t east_rclk_byp_setting        : 12; /**< Reserved. */
 	uint64_t cmb_rclk_byp_select          : 1;  /**< Reserved. */
 	uint64_t cmb_rclk_byp_setting         : 12; /**< Reserved. */
 	uint64_t pp_rclk_byp_select           : 1;  /**< Reserved. */
 	uint64_t pp_rclk_byp_setting          : 12; /**< Reserved. */
-	uint64_t tad_rclk_byp_select          : 1;  /**< N/A */
-	uint64_t tad_rclk_byp_setting         : 12; /**< N/A */
+	uint64_t tad_rclk_byp_select          : 1;  /**< Reserved. */
+	uint64_t tad_rclk_byp_setting         : 12; /**< Reserved. */
 #else
 	uint64_t tad_rclk_byp_setting         : 12;
 	uint64_t tad_rclk_byp_select          : 1;
@@ -4924,16 +4979,6 @@ union cvmx_mio_fus_ema {
 	struct cvmx_mio_fus_ema_s             cn66xx;
 	struct cvmx_mio_fus_ema_s             cn68xx;
 	struct cvmx_mio_fus_ema_s             cn68xxp1;
-	struct cvmx_mio_fus_ema_cn70xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_3_63                : 61;
-	uint64_t ema                          : 3;  /**< Reserved. */
-#else
-	uint64_t ema                          : 3;
-	uint64_t reserved_3_63                : 61;
-#endif
-	} cn70xx;
-	struct cvmx_mio_fus_ema_cn70xx        cn78xx;
 	struct cvmx_mio_fus_ema_s             cnf71xx;
 };
 typedef union cvmx_mio_fus_ema cvmx_mio_fus_ema_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 814fd74..2c4e11a 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -53,6 +53,17 @@
 #define __CVMX_OCX_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_OCX_COM_BIST_STATUS CVMX_OCX_COM_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_OCX_COM_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_OCX_COM_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800110000F0ull);
+}
+#else
+#define CVMX_OCX_COM_BIST_STATUS (CVMX_ADD_IO_SEG(0x00011800110000F0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OCX_COM_DUAL_SORT CVMX_OCX_COM_DUAL_SORT_FUNC()
 static inline uint64_t CVMX_OCX_COM_DUAL_SORT_FUNC(void)
 {
@@ -130,6 +141,50 @@ static inline uint64_t CVMX_OCX_DLLX_STATUS(unsigned long offset)
 #define CVMX_OCX_DLLX_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180011000080ull) + ((offset) & 1) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCX_FRCX_STAT0(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_OCX_FRCX_STAT0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118001100FA00ull) + ((offset) & 7) * 8;
+}
+#else
+#define CVMX_OCX_FRCX_STAT0(offset) (CVMX_ADD_IO_SEG(0x000118001100FA00ull) + ((offset) & 7) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCX_FRCX_STAT1(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_OCX_FRCX_STAT1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118001100FA80ull) + ((offset) & 7) * 8;
+}
+#else
+#define CVMX_OCX_FRCX_STAT1(offset) (CVMX_ADD_IO_SEG(0x000118001100FA80ull) + ((offset) & 7) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCX_FRCX_STAT2(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_OCX_FRCX_STAT2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118001100FB00ull) + ((offset) & 7) * 8;
+}
+#else
+#define CVMX_OCX_FRCX_STAT2(offset) (CVMX_ADD_IO_SEG(0x000118001100FB00ull) + ((offset) & 7) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCX_FRCX_STAT3(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_OCX_FRCX_STAT3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x000118001100FB80ull) + ((offset) & 7) * 8;
+}
+#else
+#define CVMX_OCX_FRCX_STAT3(offset) (CVMX_ADD_IO_SEG(0x000118001100FB80ull) + ((offset) & 7) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCX_LNEX_BAD_CNT(unsigned long offset)
 {
 	if (!(
@@ -317,6 +372,28 @@ static inline uint64_t CVMX_OCX_LNEX_STAT12(unsigned long offset)
 #define CVMX_OCX_LNEX_STAT12(offset) (CVMX_ADD_IO_SEG(0x00011800110080A0ull) + ((offset) & 31) * 256)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCX_LNEX_STAT13(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
+		cvmx_warn("CVMX_OCX_LNEX_STAT13(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800110080A8ull) + ((offset) & 31) * 256;
+}
+#else
+#define CVMX_OCX_LNEX_STAT13(offset) (CVMX_ADD_IO_SEG(0x00011800110080A8ull) + ((offset) & 31) * 256)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCX_LNEX_STAT14(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
+		cvmx_warn("CVMX_OCX_LNEX_STAT14(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800110080B0ull) + ((offset) & 31) * 256;
+}
+#else
+#define CVMX_OCX_LNEX_STAT14(offset) (CVMX_ADD_IO_SEG(0x00011800110080B0ull) + ((offset) & 31) * 256)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCX_LNEX_STATUS(unsigned long offset)
 {
 	if (!(
@@ -504,6 +581,17 @@ static inline uint64_t CVMX_OCX_RLKX_MCD_CTL(unsigned long offset)
 #define CVMX_OCX_RLKX_MCD_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180011018020ull) + ((offset) & 3) * 8192)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCX_TLKX_BIST_STATUS(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
+		cvmx_warn("CVMX_OCX_TLKX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180011010008ull) + ((offset) & 3) * 8192;
+}
+#else
+#define CVMX_OCX_TLKX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x0001180011010008ull) + ((offset) & 3) * 8192)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCX_TLKX_ECC_CTL(unsigned long offset)
 {
 	if (!(
@@ -747,6 +835,45 @@ static inline uint64_t CVMX_OCX_WIN_WR_DATA_FUNC(void)
 #endif
 
 /**
+ * cvmx_ocx_com_bist_status
+ *
+ * Contains Status from last Memory BIST for all RX FIFO Memories.  BIST status for TX FIFO
+ * Memories
+ * and REPLAY Memories are organized by link and are located in OCX_TLK(0..2)_BIST_STATUS.
+ */
+union cvmx_ocx_com_bist_status {
+	uint64_t u64;
+	struct cvmx_ocx_com_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t status                       : 36; /**< 35:34 - Link 2 VC4/VC2      RX FIFOs
+                                                         - 33:32 - Link 2 VC10/VC8/VC6 RX FIFOs
+                                                         - 31:30 - Link 1 VC4/VC2      RX FIFOs
+                                                         - 29:28 - Link 1 VC10/VC8/VC6 RX FIFOs
+                                                         - 27:26 - Link 0 VC4/VC2      RX FIFOs
+                                                         - 25:24 - Link 0 VC10/VC8/VC6 RX FIFOs
+                                                         - 23:22 - Link 2 VC12         RX FIFOs
+                                                         - 21:20 - Link 2 VC1/VC0      RX FIFOs
+                                                         - 19:18 - Link 2 VC5/VC3      RX FIFOs
+                                                         - 17:16 - Link 2 VC11/VC9/VC7 RX FIFOs
+                                                         - 15:14 - Link 1 VC12         RX FIFOs
+                                                         - 13:12 - Link 1 VC1/VC0      RX FIFOs
+                                                         - 11:10 - Link 1 VC5/VC3      RX FIFOs
+                                                         - 9: 8 - Link 1 VC11/VC9/VC7 RX FIFOs
+                                                         - 7: 6 - Link 0 VC12         RX FIFOs
+                                                         - 5: 4 - Link 0 VC1/VC0      RX FIFOs
+                                                         - 3: 2 - Link 0 VC5/VC3      RX FIFOs
+                                                         - 1: 0 - Link 0 VC11/VC9/VC7 RX FIFOs */
+#else
+	uint64_t status                       : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_ocx_com_bist_status_s     cn78xx;
+};
+typedef union cvmx_ocx_com_bist_status cvmx_ocx_com_bist_status_t;
+
+/**
  * cvmx_ocx_com_dual_sort
  */
 union cvmx_ocx_com_dual_sort {
@@ -775,12 +902,20 @@ union cvmx_ocx_com_int {
 	struct cvmx_ocx_com_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_55_63               : 9;
-	uint64_t io_badid                     : 1;  /**< I/O request or response cannot be send because Node ID is invalid. Transaction has been dropped. */
-	uint64_t mem_badid                    : 1;  /**< Memory request or response cannot be send because Node ID is invalid. Transaction has been dropped. */
-	uint64_t copr_badid                   : 1;  /**< Scheduler add work or buffer pool return cannot be sent because Node ID is invalid.
-                                                         Transaction has been dropped. */
+	uint64_t io_badid                     : 1;  /**< I/O request or response cannot be sent because a link was not found with a packet Node ID
+                                                         matching the OCX_COM_LINK(0..2)_CTL[ID]
+                                                         with OCX_COM_LINK(0..2)_CTL[VALID] bit set. Transaction has been dropped. */
+	uint64_t mem_badid                    : 1;  /**< Memory request or response cannot be send because a link was not found with a packet Node
+                                                         ID matching the OCX_COM_LINK(0..2)_CTL[ID]
+                                                         with OCX_COM_LINK(0..2)_CTL[VALID] bit set. Transaction has been dropped. */
+	uint64_t copr_badid                   : 1;  /**< Scheduler add work or buffer pool return cannot be sent because a link was not found with
+                                                         a Node ID matching the
+                                                         OCX_COM_LINK(0..2)_CTL[ID] with OCX_COM_LINK(0..2)_CTL[VALID] bit set.  Transaction has
+                                                         been dropped. */
 	uint64_t win_req_badid                : 1;  /**< Window request specified in SLI_WIN_RD_ADDR, SLI_WIN_WR_ADDR, OCX_WIN_CMD or OCX_PP_CMD
-                                                         cannot be sent because Node ID is invalid. Transaction has been dropped. */
+                                                         cannot be sent because a link was not found with a request Node ID matching the
+                                                         OCX_COM_LINK(0..2)_CTL[ID]
+                                                         with OCX_COM_LINK(0..2)_CTL[VALID] bit set.  Transaction has been dropped. */
 	uint64_t win_req_tout                 : 1;  /**< Window or core request was dropped because it could not be send during the period
                                                          specified by OCX_WIN_TIMER. */
 	uint64_t win_req_xmit                 : 1;  /**< Window request specified in SLI_WIN_RD_ADDR, SLI_WIN_WR_ADDR, OCX_WIN_CMD or OCX_PP_CMD
@@ -827,7 +962,8 @@ union cvmx_ocx_com_linkx_ctl {
                                                          reinitialized. Cleared by software once pending link traffic is removed. (See
                                                          OCX_TLK[0..2]_FIFO[0..13]_CNT.) */
 	uint64_t up                           : 1;  /**< Link is operating normally. */
-	uint64_t valid                        : 1;  /**< Link has valid lanes and is exchanging information. */
+	uint64_t valid                        : 1;  /**< Link has valid lanes and is exchanging information.  This bit will never be set if
+                                                         OCX_LNK(0..2)_CFG[QLM_SELECT] is zero. */
 	uint64_t id                           : 2;  /**< This ID is used to sort traffic by link. If more than one link has the same value, the
                                                          OCX_COM_DUAL_SORT[SORT] field and traffic VC are used to choose a link. This field is only
                                                          reset during a cold reset to an arbitrary value to avoid conflicts with the
@@ -989,6 +1125,80 @@ union cvmx_ocx_dllx_status {
 typedef union cvmx_ocx_dllx_status cvmx_ocx_dllx_status_t;
 
 /**
+ * cvmx_ocx_frc#_stat0
+ */
+union cvmx_ocx_frcx_stat0 {
+	uint64_t u64;
+	struct cvmx_ocx_frcx_stat0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_21_63               : 43;
+	uint64_t align_cnt                    : 21; /**< Indicates the number of alignment sequences received (i.e. those that do not violate the
+                                                         current alignment). */
+#else
+	uint64_t align_cnt                    : 21;
+	uint64_t reserved_21_63               : 43;
+#endif
+	} s;
+	struct cvmx_ocx_frcx_stat0_s          cn78xx;
+};
+typedef union cvmx_ocx_frcx_stat0 cvmx_ocx_frcx_stat0_t;
+
+/**
+ * cvmx_ocx_frc#_stat1
+ */
+union cvmx_ocx_frcx_stat1 {
+	uint64_t u64;
+	struct cvmx_ocx_frcx_stat1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_21_63               : 43;
+	uint64_t align_err_cnt                : 21; /**< Indicates the number of alignment sequences received in error (i.e. those that violate the
+                                                         current alignment). */
+#else
+	uint64_t align_err_cnt                : 21;
+	uint64_t reserved_21_63               : 43;
+#endif
+	} s;
+	struct cvmx_ocx_frcx_stat1_s          cn78xx;
+};
+typedef union cvmx_ocx_frcx_stat1 cvmx_ocx_frcx_stat1_t;
+
+/**
+ * cvmx_ocx_frc#_stat2
+ */
+union cvmx_ocx_frcx_stat2 {
+	uint64_t u64;
+	struct cvmx_ocx_frcx_stat2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_21_63               : 43;
+	uint64_t align_done                   : 21; /**< Indicates the number of attempt at alignment that succeeded. */
+#else
+	uint64_t align_done                   : 21;
+	uint64_t reserved_21_63               : 43;
+#endif
+	} s;
+	struct cvmx_ocx_frcx_stat2_s          cn78xx;
+};
+typedef union cvmx_ocx_frcx_stat2 cvmx_ocx_frcx_stat2_t;
+
+/**
+ * cvmx_ocx_frc#_stat3
+ */
+union cvmx_ocx_frcx_stat3 {
+	uint64_t u64;
+	struct cvmx_ocx_frcx_stat3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_21_63               : 43;
+	uint64_t align_fail                   : 21; /**< Indicates the number of attempt at alignment that failed. */
+#else
+	uint64_t align_fail                   : 21;
+	uint64_t reserved_21_63               : 43;
+#endif
+	} s;
+	struct cvmx_ocx_frcx_stat3_s          cn78xx;
+};
+typedef union cvmx_ocx_frcx_stat3 cvmx_ocx_frcx_stat3_t;
+
+/**
  * cvmx_ocx_lne#_bad_cnt
  */
 union cvmx_ocx_lnex_bad_cnt {
@@ -1363,19 +1573,57 @@ union cvmx_ocx_lnex_stat12 {
 typedef union cvmx_ocx_lnex_stat12 cvmx_ocx_lnex_stat12_t;
 
 /**
+ * cvmx_ocx_lne#_stat13
+ */
+union cvmx_ocx_lnex_stat13 {
+	uint64_t u64;
+	struct cvmx_ocx_lnex_stat13_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t trn_bad_cnt                  : 16; /**< N/A */
+#else
+	uint64_t trn_bad_cnt                  : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_ocx_lnex_stat13_s         cn78xx;
+};
+typedef union cvmx_ocx_lnex_stat13 cvmx_ocx_lnex_stat13_t;
+
+/**
+ * cvmx_ocx_lne#_stat14
+ */
+union cvmx_ocx_lnex_stat14 {
+	uint64_t u64;
+	struct cvmx_ocx_lnex_stat14_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t trn_prbs_bad_cnt             : 16; /**< N/A */
+#else
+	uint64_t trn_prbs_bad_cnt             : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_ocx_lnex_stat14_s         cn78xx;
+};
+typedef union cvmx_ocx_lnex_stat14 cvmx_ocx_lnex_stat14_t;
+
+/**
  * cvmx_ocx_lne#_status
  */
 union cvmx_ocx_lnex_status {
 	uint64_t u64;
 	struct cvmx_ocx_lnex_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_2_63                : 62;
+	uint64_t reserved_3_63                : 61;
+	uint64_t rx_trn_val                   : 1;  /**< The control channel of a link training was recieved without any errors. */
 	uint64_t rx_scrm_sync                 : 1;  /**< RX scrambler synchronization status. One when synchronization achieved. */
 	uint64_t rx_bdry_sync                 : 1;  /**< RX word boundary sync status. One when synchronization achieved. */
 #else
 	uint64_t rx_bdry_sync                 : 1;
 	uint64_t rx_scrm_sync                 : 1;
-	uint64_t reserved_2_63                : 62;
+	uint64_t rx_trn_val                   : 1;
+	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
 	struct cvmx_ocx_lnex_status_s         cn78xx;
@@ -1479,7 +1727,8 @@ union cvmx_ocx_lne_dbg {
 	uint64_t u64;
 	struct cvmx_ocx_lne_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_37_63               : 27;
+	uint64_t reserved_38_63               : 26;
+	uint64_t frc_stats_ena                : 1;  /**< Enable FRC statistic counters. */
 	uint64_t rx_dis_psh_skip              : 1;  /**< When RX_DIS_PSH_SKIP=0, skip words are de-stripped. When RX_DIS_PSH_SKIP=1, skip words are
                                                          discarded in the lane logic. If the lane is in internal loopback mode, RX_DIS_PSH_SKIP is
                                                          ignored and skip words are always discarded in the lane logic. */
@@ -1514,7 +1763,8 @@ union cvmx_ocx_lne_dbg {
 	uint64_t rx_dis_ukwn                  : 1;
 	uint64_t rx_mfrm_len                  : 2;
 	uint64_t rx_dis_psh_skip              : 1;
-	uint64_t reserved_37_63               : 27;
+	uint64_t frc_stats_ena                : 1;
+	uint64_t reserved_38_63               : 26;
 #endif
 	} s;
 	struct cvmx_ocx_lne_dbg_s             cn78xx;
@@ -1542,7 +1792,9 @@ union cvmx_ocx_lnkx_cfg {
                                                          LINK 0 may not select QLM4, QLM5.
                                                          LINK 1 may not select QLM0, QLM1, QLM4, QLM5.
                                                          LINK 2 may not select QLM0, QLM1.
-                                                         This field is initialized using the OCI_SPD pins during a cold reset.
+                                                         During a cold reset, this field is initialized to 0x3f when pi_oci_spd == 0xf.
+                                                         During a cold reset, this field is initialized to 0x0  when pi_oci_spd != 0xf.
+                                                         This field is not modified by hardware at any other time.
                                                          This field is not affected by soft or warm reset. */
 	uint64_t reserved_38_47               : 10;
 	uint64_t qlm_select                   : 6;  /**< QLM select mask, where each bit corresponds to a QLM. A link will transmit/receive data
@@ -1557,7 +1809,17 @@ union cvmx_ocx_lnkx_cfg {
                                                          QLM_SELECT<5> = LNE(23..23) = QLM5.
                                                          LINK 0 may not select QLM4, QLM5.
                                                          LINK 1 may not select QLM0, QLM1, QLM4, QLM5.
-                                                         LINK 2 may not select QLM0, QLM1. */
+                                                         LINK 2 may not select QLM0, QLM1.
+                                                         LINK 0 automatically selects QLM0 when QLM_MANUAL[0]=0
+                                                         LINK 0 automatically selects QLM1 when QLM_MANUAL[1]=0
+                                                         LINK 0 automatically selects QLM2 when QLM_MANUAL[2]=0 and OCX_QLM2_CFG.SER_LOCAL=0
+                                                         LINK 1 automatically selects QLM2 when QLM_MANUAL[2]=0 and OCX_QLM2_CFG.SER_LOCAL=1
+                                                         LINK 1 automatically selects QLM3 when QLM_MANUAL[3]=0 and OCX_QLM3_CFG.SER_LOCAL=1
+                                                         LINK 2 automatically selects QLM3 when QLM_MANUAL[3]=0 and OCX_QLM3_CFG.SER_LOCAL=0
+                                                         LINK 3 automatically selects QLM4 when QLM_MANUAL[4]=0
+                                                         LINK 3 automatically selects QLM5 when QLM_MANUAL[5]=0
+                                                         NOTE:  A link with QLM_SELECT = 000000 is invalid and will never exchange traffic with the
+                                                         link partner */
 	uint64_t reserved_10_31               : 22;
 	uint64_t lane_align_dis               : 1;  /**< Disable the RX lane alignment. */
 	uint64_t lane_rev                     : 1;  /**< RX lane reversal.   When enabled, lane de-striping is performed from the most significant
@@ -1674,7 +1936,9 @@ union cvmx_ocx_qlmx_cfg {
 	uint64_t u64;
 	struct cvmx_ocx_qlmx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_42_63               : 22;
+	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. */
+	uint64_t reserved_26_31               : 6;
 	uint64_t timer_dis                    : 1;  /**< Disable bad lane timer. A timer counts core clocks (RCLKs) when any enabled lane is not
                                                          ready, i.e. not in the scrambler sync state. If this timer expires before all enabled
                                                          lanes can be made ready, then any lane which is not ready is disabled via
@@ -1682,7 +1946,7 @@ union cvmx_ocx_qlmx_cfg {
 	uint64_t trn_ena                      : 1;  /**< Link training enable. Link training is performed during auto link bring up. Initialized to
                                                          1 during cold reset when OCI_SPD<3:0> pins indicate speed > 6.25 GBAUD. Otherwise,
                                                          initialized to 0 during a cold reset. This field is not affected by soft or warm reset. */
-	uint64_t reserved_20_23               : 4;
+	uint64_t ser_lane_ready               : 4;  /**< SerDes lanes that are ready for bundling into the link. */
 	uint64_t ser_lane_bad                 : 4;  /**< SerDes lanes excluded from use. */
 	uint64_t reserved_7_15                : 9;
 	uint64_t ser_lane_rev                 : 1;  /**< SerDes lane reversal has been detected. */
@@ -1707,8 +1971,8 @@ union cvmx_ocx_qlmx_cfg {
                                                          QLM4/5 can only participate in LNK2; therefore
                                                          OCX_QLM4/5_CFG[SER_LOCAL] has no effect.
                                                          During a cold reset, initialized as follows:
-                                                         OCX_QLM2_CFG.SER_LOCAL = pi_qlm_local[0]
-                                                         OCX_QLM3_CFG.SER_LOCAL = pi_qlm_local[1] */
+                                                         OCX_QLM2_CFG.SER_LOCAL = pi_oci2_link1
+                                                         OCX_QLM3_CFG.SER_LOCAL = pi_oci3_link1 */
 #else
 	uint64_t ser_local                    : 1;
 	uint64_t reserved_1_2                 : 2;
@@ -1718,10 +1982,12 @@ union cvmx_ocx_qlmx_cfg {
 	uint64_t ser_lane_rev                 : 1;
 	uint64_t reserved_7_15                : 9;
 	uint64_t ser_lane_bad                 : 4;
-	uint64_t reserved_20_23               : 4;
+	uint64_t ser_lane_ready               : 4;
 	uint64_t trn_ena                      : 1;
 	uint64_t timer_dis                    : 1;
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_26_31               : 6;
+	uint64_t ser_limit                    : 10;
+	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
 	struct cvmx_ocx_qlmx_cfg_s            cn78xx;
@@ -1804,7 +2070,10 @@ union cvmx_ocx_rlkx_enables {
 	struct cvmx_ocx_rlkx_enables_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t mcd                          : 1;  /**< Master enable for all inbound MCD bits. This bit must be enabled by software. */
+	uint64_t mcd                          : 1;  /**< Master enable for all inbound MCD bits. This bit should always be enabled by software once
+                                                         any
+                                                         Authentik validation has occured and before any MCD traffic is generated.  MCD traffic is
+                                                         typically controlled by the OCX_TLK(0..2)_MCD_CTL register. */
 	uint64_t m_req                        : 1;  /**< Master enable for all inbound memory requests. This bit is typically set at reset but is
                                                          cleared when operating in Authentik mode and must be enabled by software. */
 	uint64_t io_req                       : 1;  /**< Master enable for all inbound I/O Requests. This bit is typically set at reset but is
@@ -1869,6 +2138,11 @@ typedef union cvmx_ocx_rlkx_lnk_data cvmx_ocx_rlkx_lnk_data_t;
 
 /**
  * cvmx_ocx_rlk#_mcd_ctl
+ *
+ * This debug register captures which new MCD bits have been received from the link partner.  The
+ * MCD bits are
+ * received when the both the OCX_RLK(0..2)_ENABLES[MCD] bit is set and the MCD was not
+ * previously transmitted.
  */
 union cvmx_ocx_rlkx_mcd_ctl {
 	uint64_t u64;
@@ -1887,6 +2161,29 @@ union cvmx_ocx_rlkx_mcd_ctl {
 typedef union cvmx_ocx_rlkx_mcd_ctl cvmx_ocx_rlkx_mcd_ctl_t;
 
 /**
+ * cvmx_ocx_tlk#_bist_status
+ *
+ * Contains Status from last Memory BIST for all TX FIFO Memories and REPLAY Memories in this
+ * link.
+ * RX FIFO Status can be found in OCX_COM_BIST_STATUS
+ */
+union cvmx_ocx_tlkx_bist_status {
+	uint64_t u64;
+	struct cvmx_ocx_tlkx_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t status                       : 15; /**< "14:13 - REPLAY Memories BIST Status [1:0]
+                                                         - 12:0  - TX_FIFO[12:0] by Link VC#" */
+#else
+	uint64_t status                       : 15;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_ocx_tlkx_bist_status_s    cn78xx;
+};
+typedef union cvmx_ocx_tlkx_bist_status cvmx_ocx_tlkx_bist_status_t;
+
+/**
  * cvmx_ocx_tlk#_ecc_ctl
  */
 union cvmx_ocx_tlkx_ecc_ctl {
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index c95ae00..fe18f76 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -306,6 +306,28 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 #define CVMX_PKO_DQX_WM_CTL_W1C(offset) (CVMX_ADD_IO_SEG(0x0001540000000048ull) + ((offset) & 1023) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_DQ_DEBUG CVMX_PKO_DQ_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_DQ_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000300128ull);
+}
+#else
+#define CVMX_PKO_DQ_DEBUG (CVMX_ADD_IO_SEG(0x0001540000300128ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_DRAIN_IRQ CVMX_PKO_DRAIN_IRQ_FUNC()
+static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_DRAIN_IRQ not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000000140ull);
+}
+#else
+#define CVMX_PKO_DRAIN_IRQ (CVMX_ADD_IO_SEG(0x0001540000000140ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_ENABLE CVMX_PKO_ENABLE_FUNC()
 static inline uint64_t CVMX_PKO_ENABLE_FUNC(void)
 {
@@ -328,6 +350,28 @@ static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 #define CVMX_PKO_FORMATX_CTL(offset) (CVMX_ADD_IO_SEG(0x0001540000900800ull) + ((offset) & 127) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L1_SQA_DEBUG CVMX_PKO_L1_SQA_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L1_SQA_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000080128ull);
+}
+#else
+#define CVMX_PKO_L1_SQA_DEBUG (CVMX_ADD_IO_SEG(0x0001540000080128ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L1_SQB_DEBUG CVMX_PKO_L1_SQB_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L1_SQB_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L1_SQB_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000080130ull);
+}
+#else
+#define CVMX_PKO_L1_SQB_DEBUG (CVMX_ADD_IO_SEG(0x0001540000080130ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_L1_SQX_CIR(unsigned long offset)
 {
 	if (!(
@@ -537,6 +581,28 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 #define CVMX_PKO_L1_SQX_YELLOW_PACKETS(offset) (CVMX_ADD_IO_SEG(0x0001540000000090ull) + ((offset) & 31) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L2_SQA_DEBUG CVMX_PKO_L2_SQA_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L2_SQA_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000100128ull);
+}
+#else
+#define CVMX_PKO_L2_SQA_DEBUG (CVMX_ADD_IO_SEG(0x0001540000100128ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L2_SQB_DEBUG CVMX_PKO_L2_SQB_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L2_SQB_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L2_SQB_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000100130ull);
+}
+#else
+#define CVMX_PKO_L2_SQB_DEBUG (CVMX_ADD_IO_SEG(0x0001540000100130ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_L2_SQX_CIR(unsigned long offset)
 {
 	if (!(
@@ -691,6 +757,28 @@ static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 #define CVMX_PKO_L3_L2_SQX_CHANNEL(offset) (CVMX_ADD_IO_SEG(0x0001540000080038ull) + ((offset) & 511) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L3_SQA_DEBUG CVMX_PKO_L3_SQA_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L3_SQA_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000180128ull);
+}
+#else
+#define CVMX_PKO_L3_SQA_DEBUG (CVMX_ADD_IO_SEG(0x0001540000180128ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L3_SQB_DEBUG CVMX_PKO_L3_SQB_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L3_SQB_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L3_SQB_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000180130ull);
+}
+#else
+#define CVMX_PKO_L3_SQB_DEBUG (CVMX_ADD_IO_SEG(0x0001540000180130ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_L3_SQX_CIR(unsigned long offset)
 {
 	if (!(
@@ -834,6 +922,28 @@ static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L3_SQX_YELLOW(offset) (CVMX_ADD_IO_SEG(0x0001540000180060ull) + ((offset) & 511) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L4_SQA_DEBUG CVMX_PKO_L4_SQA_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L4_SQA_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L4_SQA_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000200128ull);
+}
+#else
+#define CVMX_PKO_L4_SQA_DEBUG (CVMX_ADD_IO_SEG(0x0001540000200128ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L4_SQB_DEBUG CVMX_PKO_L4_SQB_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L4_SQB_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L4_SQB_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000200130ull);
+}
+#else
+#define CVMX_PKO_L4_SQB_DEBUG (CVMX_ADD_IO_SEG(0x0001540000200130ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_L4_SQX_CIR(unsigned long offset)
 {
 	if (!(
@@ -977,6 +1087,28 @@ static inline uint64_t CVMX_PKO_L4_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L4_SQX_YELLOW(offset) (CVMX_ADD_IO_SEG(0x0001540000200060ull) + ((offset) & 1023) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L5_SQA_DEBUG CVMX_PKO_L5_SQA_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L5_SQA_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L5_SQA_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000280128ull);
+}
+#else
+#define CVMX_PKO_L5_SQA_DEBUG (CVMX_ADD_IO_SEG(0x0001540000280128ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_L5_SQB_DEBUG CVMX_PKO_L5_SQB_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_L5_SQB_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_L5_SQB_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000280130ull);
+}
+#else
+#define CVMX_PKO_L5_SQB_DEBUG (CVMX_ADD_IO_SEG(0x0001540000280130ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_L5_SQX_CIR(unsigned long offset)
 {
 	if (!(
@@ -1131,17 +1263,6 @@ static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 #define CVMX_PKO_LUTX(offset) (CVMX_ADD_IO_SEG(0x0001540000B00000ull) + ((offset) & 1023) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_PKO_LUT_BIST_DONE CVMX_PKO_LUT_BIST_DONE_FUNC()
-static inline uint64_t CVMX_PKO_LUT_BIST_DONE_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_PKO_LUT_BIST_DONE not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001540000B02020ull);
-}
-#else
-#define CVMX_PKO_LUT_BIST_DONE (CVMX_ADD_IO_SEG(0x0001540000B02020ull))
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_LUT_BIST_STATUS CVMX_PKO_LUT_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 {
@@ -1543,6 +1664,17 @@ static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 #define CVMX_PKO_PDM_CFG (CVMX_ADD_IO_SEG(0x0001540000800000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PDM_CFG_DBG CVMX_PKO_PDM_CFG_DBG_FUNC()
+static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PDM_CFG_DBG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000800FF8ull);
+}
+#else
+#define CVMX_PKO_PDM_CFG_DBG (CVMX_ADD_IO_SEG(0x0001540000800FF8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 {
 	if (!(
@@ -1587,6 +1719,17 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL0 (CVMX_ADD_IO_SEG(0x00015400008FFFD0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PDM_ECC_CTL1 CVMX_PKO_PDM_ECC_CTL1_FUNC()
+static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PDM_ECC_CTL1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00015400008FFFD8ull);
+}
+#else
+#define CVMX_PKO_PDM_ECC_CTL1 (CVMX_ADD_IO_SEG(0x00015400008FFFD8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PDM_ECC_DBE_STS0 CVMX_PKO_PDM_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 {
@@ -1603,10 +1746,10 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS_CMB0 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00015400008FFFD8ull);
+	return CVMX_ADD_IO_SEG(0x00015400008FFFE0ull);
 }
 #else
-#define CVMX_PKO_PDM_ECC_DBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x00015400008FFFD8ull))
+#define CVMX_PKO_PDM_ECC_DBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x00015400008FFFE0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PDM_ECC_SBE_STS0 CVMX_PKO_PDM_ECC_SBE_STS0_FUNC()
@@ -1708,17 +1851,6 @@ static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_MWPBUF_DBG (CVMX_ADD_IO_SEG(0x00015400008000A0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_PKO_PDM_SENDPKT_LMTXX_ERR CVMX_PKO_PDM_SENDPKT_LMTXX_ERR_FUNC()
-static inline uint64_t CVMX_PKO_PDM_SENDPKT_LMTXX_ERR_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_PKO_PDM_SENDPKT_LMTXX_ERR not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00015400008000F8ull);
-}
-#else
-#define CVMX_PKO_PDM_SENDPKT_LMTXX_ERR (CVMX_ADD_IO_SEG(0x00015400008000F8ull))
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PDM_STS CVMX_PKO_PDM_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 {
@@ -1730,17 +1862,6 @@ static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 #define CVMX_PKO_PDM_STS (CVMX_ADD_IO_SEG(0x0001540000800008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_PKO_PEB_BIST_DONE CVMX_PKO_PEB_BIST_DONE_FUNC()
-static inline uint64_t CVMX_PKO_PEB_BIST_DONE_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_PKO_PEB_BIST_DONE not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001540000900D08ull);
-}
-#else
-#define CVMX_PKO_PEB_BIST_DONE (CVMX_ADD_IO_SEG(0x0001540000900D08ull))
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PEB_BIST_STATUS CVMX_PKO_PEB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 {
@@ -1939,6 +2060,72 @@ static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TRUNC_ERR_INFO (CVMX_ADD_IO_SEG(0x0001540000900C30ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PQA_DEBUG CVMX_PKO_PQA_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PQA_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000000128ull);
+}
+#else
+#define CVMX_PKO_PQA_DEBUG (CVMX_ADD_IO_SEG(0x0001540000000128ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PQB_DEBUG CVMX_PKO_PQB_DEBUG_FUNC()
+static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PQB_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000000130ull);
+}
+#else
+#define CVMX_PKO_PQB_DEBUG (CVMX_ADD_IO_SEG(0x0001540000000130ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PQ_DEBUG_GREEN CVMX_PKO_PQ_DEBUG_GREEN_FUNC()
+static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PQ_DEBUG_GREEN not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000000058ull);
+}
+#else
+#define CVMX_PKO_PQ_DEBUG_GREEN (CVMX_ADD_IO_SEG(0x0001540000000058ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PQ_DEBUG_LINKS CVMX_PKO_PQ_DEBUG_LINKS_FUNC()
+static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PQ_DEBUG_LINKS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000000068ull);
+}
+#else
+#define CVMX_PKO_PQ_DEBUG_LINKS (CVMX_ADD_IO_SEG(0x0001540000000068ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PQ_DEBUG_YELLOW CVMX_PKO_PQ_DEBUG_YELLOW_FUNC()
+static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PQ_DEBUG_YELLOW not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000000060ull);
+}
+#else
+#define CVMX_PKO_PQ_DEBUG_YELLOW (CVMX_ADD_IO_SEG(0x0001540000000060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PSE_DQ_BIST_STATUS CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PSE_DQ_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000300138ull);
+}
+#else
+#define CVMX_PKO_PSE_DQ_BIST_STATUS (CVMX_ADD_IO_SEG(0x0001540000300138ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PSE_DQ_ECC_CTL0 CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 {
@@ -1994,6 +2181,17 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x0001540000300110ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PSE_PQ_BIST_STATUS CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PSE_PQ_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000000138ull);
+}
+#else
+#define CVMX_PKO_PSE_PQ_BIST_STATUS (CVMX_ADD_IO_SEG(0x0001540000000138ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PSE_PQ_ECC_CTL0 CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 {
@@ -2049,6 +2247,17 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x0001540000000110ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PSE_SQ1_BIST_STATUS CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PSE_SQ1_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000080138ull);
+}
+#else
+#define CVMX_PKO_PSE_SQ1_BIST_STATUS (CVMX_ADD_IO_SEG(0x0001540000080138ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PSE_SQ1_ECC_CTL0 CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 {
@@ -2104,6 +2313,17 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x0001540000080110ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PSE_SQ2_BIST_STATUS CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PSE_SQ2_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000100138ull);
+}
+#else
+#define CVMX_PKO_PSE_SQ2_BIST_STATUS (CVMX_ADD_IO_SEG(0x0001540000100138ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PSE_SQ2_ECC_CTL0 CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 {
@@ -2159,6 +2379,17 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x0001540000100110ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PSE_SQ3_BIST_STATUS CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PSE_SQ3_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000180138ull);
+}
+#else
+#define CVMX_PKO_PSE_SQ3_BIST_STATUS (CVMX_ADD_IO_SEG(0x0001540000180138ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PSE_SQ3_ECC_CTL0 CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 {
@@ -2214,6 +2445,17 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x0001540000180110ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PSE_SQ4_BIST_STATUS CVMX_PKO_PSE_SQ4_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PKO_PSE_SQ4_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PSE_SQ4_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000200138ull);
+}
+#else
+#define CVMX_PKO_PSE_SQ4_BIST_STATUS (CVMX_ADD_IO_SEG(0x0001540000200138ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PSE_SQ4_ECC_CTL0 CVMX_PKO_PSE_SQ4_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_CTL0_FUNC(void)
 {
@@ -2269,6 +2511,17 @@ static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ4_ECC_SBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x0001540000200110ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PSE_SQ5_BIST_STATUS CVMX_PKO_PSE_SQ5_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PKO_PSE_SQ5_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PSE_SQ5_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000280138ull);
+}
+#else
+#define CVMX_PKO_PSE_SQ5_BIST_STATUS (CVMX_ADD_IO_SEG(0x0001540000280138ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PSE_SQ5_ECC_CTL0 CVMX_PKO_PSE_SQ5_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_CTL0_FUNC(void)
 {
@@ -3196,6 +3449,43 @@ union cvmx_pko_dqx_wm_ctl_w1c {
 typedef union cvmx_pko_dqx_wm_ctl_w1c cvmx_pko_dqx_wm_ctl_w1c_t;
 
 /**
+ * cvmx_pko_dq_debug
+ */
+union cvmx_pko_dq_debug {
+	uint64_t u64;
+	struct cvmx_pko_dq_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_dq_debug_s            cn78xx;
+};
+typedef union cvmx_pko_dq_debug cvmx_pko_dq_debug_t;
+
+/**
+ * cvmx_pko_drain_irq
+ */
+union cvmx_pko_drain_irq {
+	uint64_t u64;
+	struct cvmx_pko_drain_irq_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t intr                         : 1;  /**< Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is generated
+                                                         when the DRAIN command reaches the PQ level. Subsequent interrupt messages are only
+                                                         generated
+                                                         after this bit has been cleared by writing 1. Throws PKO_INTSN_E::PKO_PSE_PQ_DRAIN. */
+#else
+	uint64_t intr                         : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_pko_drain_irq_s           cn78xx;
+};
+typedef union cvmx_pko_drain_irq cvmx_pko_drain_irq_t;
+
+/**
  * cvmx_pko_enable
  */
 union cvmx_pko_enable {
@@ -3318,18 +3608,20 @@ union cvmx_pko_l1_sqx_green {
 	struct cvmx_pko_l1_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
+	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+                                                         scheduling queue are active. For internal use only. */
+	uint64_t reserved_19_19               : 1;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t tail                         : 9;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
-                                                         scheduling queue are active. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 9;
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t head                         : 9;
+	uint64_t reserved_19_19               : 1;
+	uint64_t active_vec                   : 20;
+	uint64_t rr_active                    : 1;
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
@@ -3498,20 +3790,15 @@ union cvmx_pko_l1_sqx_red {
 	uint64_t u64;
 	struct cvmx_pko_l1_sqx_red_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_41_63               : 23;
+	uint64_t reserved_19_63               : 45;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t tail                         : 9;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
-                                                         scheduling queue are active. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 9;
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t head                         : 9;
-	uint64_t reserved_41_63               : 23;
+	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_red_s          cn78xx;
@@ -3692,20 +3979,15 @@ union cvmx_pko_l1_sqx_yellow {
 	uint64_t u64;
 	struct cvmx_pko_l1_sqx_yellow_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_41_63               : 23;
+	uint64_t reserved_19_63               : 45;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t tail                         : 9;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
-                                                         scheduling queue are active. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 9;
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t head                         : 9;
-	uint64_t reserved_41_63               : 23;
+	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_yellow_s       cn78xx;
@@ -3749,6 +4031,38 @@ union cvmx_pko_l1_sqx_yellow_packets {
 typedef union cvmx_pko_l1_sqx_yellow_packets cvmx_pko_l1_sqx_yellow_packets_t;
 
 /**
+ * cvmx_pko_l1_sqa_debug
+ */
+union cvmx_pko_l1_sqa_debug {
+	uint64_t u64;
+	struct cvmx_pko_l1_sqa_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l1_sqa_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l1_sqa_debug cvmx_pko_l1_sqa_debug_t;
+
+/**
+ * cvmx_pko_l1_sqb_debug
+ */
+union cvmx_pko_l1_sqb_debug {
+	uint64_t u64;
+	struct cvmx_pko_l1_sqb_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l1_sqb_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l1_sqb_debug cvmx_pko_l1_sqb_debug_t;
+
+/**
  * cvmx_pko_l2_sq#_cir
  */
 union cvmx_pko_l2_sqx_cir {
@@ -3789,18 +4103,20 @@ union cvmx_pko_l2_sqx_green {
 	struct cvmx_pko_l2_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
+	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+                                                         scheduling queue are active. For internal use only. */
+	uint64_t reserved_19_19               : 1;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t tail                         : 9;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
-                                                         scheduling queue are active. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 9;
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t head                         : 9;
+	uint64_t reserved_19_19               : 1;
+	uint64_t active_vec                   : 20;
+	uint64_t rr_active                    : 1;
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
@@ -3916,20 +4232,15 @@ union cvmx_pko_l2_sqx_red {
 	uint64_t u64;
 	struct cvmx_pko_l2_sqx_red_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_41_63               : 23;
+	uint64_t reserved_19_63               : 45;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t tail                         : 9;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
-                                                         scheduling queue are active. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 9;
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t head                         : 9;
-	uint64_t reserved_41_63               : 23;
+	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_red_s          cn78xx;
@@ -4117,20 +4428,15 @@ union cvmx_pko_l2_sqx_yellow {
 	uint64_t u64;
 	struct cvmx_pko_l2_sqx_yellow_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_41_63               : 23;
+	uint64_t reserved_19_63               : 45;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t tail                         : 9;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
-                                                         scheduling queue are active. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 9;
-	uint64_t reserved_25_31               : 7;
+	uint64_t reserved_9_9                 : 1;
 	uint64_t head                         : 9;
-	uint64_t reserved_41_63               : 23;
+	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
 	struct cvmx_pko_l2_sqx_yellow_s       cn78xx;
@@ -4138,6 +4444,38 @@ union cvmx_pko_l2_sqx_yellow {
 typedef union cvmx_pko_l2_sqx_yellow cvmx_pko_l2_sqx_yellow_t;
 
 /**
+ * cvmx_pko_l2_sqa_debug
+ */
+union cvmx_pko_l2_sqa_debug {
+	uint64_t u64;
+	struct cvmx_pko_l2_sqa_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l2_sqa_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l2_sqa_debug cvmx_pko_l2_sqa_debug_t;
+
+/**
+ * cvmx_pko_l2_sqb_debug
+ */
+union cvmx_pko_l2_sqb_debug {
+	uint64_t u64;
+	struct cvmx_pko_l2_sqb_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l2_sqb_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l2_sqb_debug cvmx_pko_l2_sqb_debug_t;
+
+/**
  * cvmx_pko_l3_l2_sq#_channel
  */
 union cvmx_pko_l3_l2_sqx_channel {
@@ -4215,19 +4553,18 @@ union cvmx_pko_l3_sqx_green {
 	uint64_t u64;
 	struct cvmx_pko_l3_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_41_63               : 23;
+	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+                                                         scheduling queue are active. For internal use only. */
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t active_vec                   : 20;
+	uint64_t rr_active                    : 1;
+	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_green_s        cn78xx;
@@ -4342,19 +4679,13 @@ union cvmx_pko_l3_sqx_red {
 	uint64_t u64;
 	struct cvmx_pko_l3_sqx_red_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_20_63               : 44;
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_red_s          cn78xx;
@@ -4531,19 +4862,13 @@ union cvmx_pko_l3_sqx_yellow {
 	uint64_t u64;
 	struct cvmx_pko_l3_sqx_yellow_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_20_63               : 44;
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
 	struct cvmx_pko_l3_sqx_yellow_s       cn78xx;
@@ -4551,6 +4876,38 @@ union cvmx_pko_l3_sqx_yellow {
 typedef union cvmx_pko_l3_sqx_yellow cvmx_pko_l3_sqx_yellow_t;
 
 /**
+ * cvmx_pko_l3_sqa_debug
+ */
+union cvmx_pko_l3_sqa_debug {
+	uint64_t u64;
+	struct cvmx_pko_l3_sqa_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l3_sqa_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l3_sqa_debug cvmx_pko_l3_sqa_debug_t;
+
+/**
+ * cvmx_pko_l3_sqb_debug
+ */
+union cvmx_pko_l3_sqb_debug {
+	uint64_t u64;
+	struct cvmx_pko_l3_sqb_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l3_sqb_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l3_sqb_debug cvmx_pko_l3_sqb_debug_t;
+
+/**
  * cvmx_pko_l4_sq#_cir
  */
 union cvmx_pko_l4_sqx_cir {
@@ -4590,19 +4947,18 @@ union cvmx_pko_l4_sqx_green {
 	uint64_t u64;
 	struct cvmx_pko_l4_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_41_63               : 23;
+	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+                                                         scheduling queue are active. For internal use only. */
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t active_vec                   : 20;
+	uint64_t rr_active                    : 1;
+	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_green_s        cn78xx;
@@ -4717,19 +5073,13 @@ union cvmx_pko_l4_sqx_red {
 	uint64_t u64;
 	struct cvmx_pko_l4_sqx_red_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_20_63               : 44;
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_red_s          cn78xx;
@@ -4906,19 +5256,13 @@ union cvmx_pko_l4_sqx_yellow {
 	uint64_t u64;
 	struct cvmx_pko_l4_sqx_yellow_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_20_63               : 44;
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
 	struct cvmx_pko_l4_sqx_yellow_s       cn78xx;
@@ -4926,6 +5270,38 @@ union cvmx_pko_l4_sqx_yellow {
 typedef union cvmx_pko_l4_sqx_yellow cvmx_pko_l4_sqx_yellow_t;
 
 /**
+ * cvmx_pko_l4_sqa_debug
+ */
+union cvmx_pko_l4_sqa_debug {
+	uint64_t u64;
+	struct cvmx_pko_l4_sqa_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l4_sqa_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l4_sqa_debug cvmx_pko_l4_sqa_debug_t;
+
+/**
+ * cvmx_pko_l4_sqb_debug
+ */
+union cvmx_pko_l4_sqb_debug {
+	uint64_t u64;
+	struct cvmx_pko_l4_sqb_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l4_sqb_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l4_sqb_debug cvmx_pko_l4_sqb_debug_t;
+
+/**
  * cvmx_pko_l5_sq#_cir
  */
 union cvmx_pko_l5_sqx_cir {
@@ -4965,19 +5341,18 @@ union cvmx_pko_l5_sqx_green {
 	uint64_t u64;
 	struct cvmx_pko_l5_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_41_63               : 23;
+	uint64_t rr_active                    : 1;  /**< Round-robin Red Active.  Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to *this*
+                                                         scheduling queue are active. For internal use only. */
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t active_vec                   : 20;
+	uint64_t rr_active                    : 1;
+	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_green_s        cn78xx;
@@ -5092,19 +5467,13 @@ union cvmx_pko_l5_sqx_red {
 	uint64_t u64;
 	struct cvmx_pko_l5_sqx_red_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_20_63               : 44;
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_red_s          cn78xx;
@@ -5281,19 +5650,13 @@ union cvmx_pko_l5_sqx_yellow {
 	uint64_t u64;
 	struct cvmx_pko_l5_sqx_yellow_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t head                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[HEAD]. */
-	uint64_t reserved_26_31               : 6;
-	uint64_t tail                         : 10; /**< See PKO_L1_SQ(0..31)_GREEN[TAIL]. */
-	uint64_t reserved_10_15               : 6;
-	uint64_t active_vec                   : 10; /**< See PKO_L1_SQ(0..31)_GREEN[ACTIVE]. */
+	uint64_t reserved_20_63               : 44;
+	uint64_t head                         : 10; /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t tail                         : 10; /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
 #else
-	uint64_t active_vec                   : 10;
-	uint64_t reserved_10_15               : 6;
 	uint64_t tail                         : 10;
-	uint64_t reserved_26_31               : 6;
 	uint64_t head                         : 10;
-	uint64_t reserved_42_63               : 22;
+	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
 	struct cvmx_pko_l5_sqx_yellow_s       cn78xx;
@@ -5301,6 +5664,38 @@ union cvmx_pko_l5_sqx_yellow {
 typedef union cvmx_pko_l5_sqx_yellow cvmx_pko_l5_sqx_yellow_t;
 
 /**
+ * cvmx_pko_l5_sqa_debug
+ */
+union cvmx_pko_l5_sqa_debug {
+	uint64_t u64;
+	struct cvmx_pko_l5_sqa_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l5_sqa_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l5_sqa_debug cvmx_pko_l5_sqa_debug_t;
+
+/**
+ * cvmx_pko_l5_sqb_debug
+ */
+union cvmx_pko_l5_sqb_debug {
+	uint64_t u64;
+	struct cvmx_pko_l5_sqb_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_l5_sqb_debug_s        cn78xx;
+};
+typedef union cvmx_pko_l5_sqb_debug cvmx_pko_l5_sqb_debug_t;
+
+/**
  * cvmx_pko_lut#
  */
 union cvmx_pko_lutx {
@@ -5325,24 +5720,6 @@ union cvmx_pko_lutx {
 typedef union cvmx_pko_lutx cvmx_pko_lutx_t;
 
 /**
- * cvmx_pko_lut_bist_done
- */
-union cvmx_pko_lut_bist_done {
-	uint64_t u64;
-	struct cvmx_pko_lut_bist_done_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_1_63                : 63;
-	uint64_t bist_done                    : 1;  /**< C2Q LUT BIST done. */
-#else
-	uint64_t bist_done                    : 1;
-	uint64_t reserved_1_63                : 63;
-#endif
-	} s;
-	struct cvmx_pko_lut_bist_done_s       cn78xx;
-};
-typedef union cvmx_pko_lut_bist_done cvmx_pko_lut_bist_done_t;
-
-/**
  * cvmx_pko_lut_bist_status
  */
 union cvmx_pko_lut_bist_status {
@@ -5387,7 +5764,9 @@ union cvmx_pko_lut_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_lut_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t c2q_lut_ram_dbe              : 1;  /**< Double-bit error for C2Q_LUT_RAM. */
+	uint64_t c2q_lut_ram_dbe              : 1;  /**< Double-bit error for C2Q_LUT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -5405,7 +5784,12 @@ union cvmx_pko_lut_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t lut_dbe_cmb0                 : 1;  /**< Double-bit error for C2Q_LUT_RAM. Throws PKO_INTSN_E::PKO_LUT_DBE_CMB0. */
+	uint64_t lut_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_LUT_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_LUT_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_LUT_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -5423,7 +5807,9 @@ union cvmx_pko_lut_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_lut_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t c2q_lut_ram_sbe              : 1;  /**< Single-bit error for C2Q_LUT_RAM. */
+	uint64_t c2q_lut_ram_sbe              : 1;  /**< Single-bit error for C2Q_LUT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -5441,7 +5827,12 @@ union cvmx_pko_lut_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t lut_sbe_cmb0                 : 1;  /**< Single-bit error for C2Q_LUT_RAM. Throws PKO_INTSN_E::PKO_LUT_SBE_CMB0. */
+	uint64_t lut_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_LUT_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_LUT_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_LUT_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -5467,7 +5858,8 @@ union cvmx_pko_macx_cfg {
 	uint64_t fifo_num                     : 5;  /**< The PEB TX FIFO number assigned to the given MAC. A value of 0x1F means unassigned. Unused
                                                          MACs must be assigned a FIFO_NUM = 0x1F. For each active MAC, a unique FIFO_NUM must be
                                                          assigned. Legal values depend on the values in PKO_PTGF(0..7)_CFG[SIZE]. Assigning the
-                                                         same FIFO_NUM to more than a single active MAC will have unpredictable results. */
+                                                         same FIFO_NUM to more than a single active MAC will have unpredictable results.  FIFOs
+                                                         0x1E and 0x1D are invalid and will cause unpredictable results if used. */
 #else
 	uint64_t fifo_num                     : 5;
 	uint64_t skid_max_cnt                 : 2;
@@ -7625,11 +8017,21 @@ union cvmx_pko_ncb_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_ncb_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ncbi_l2_out_ram_dbe          : 1;  /**< Double-bit error for NCBI_L2_OUT_RAM. */
-	uint64_t ncbi_pp_out_ram_dbe          : 1;  /**< Double-bit error for NCBI_PP_OUT_RAM. */
-	uint64_t ncbo_pdm_cmd_dat_ram_dbe     : 1;  /**< Double-bit error for NCBO_PDM_CMD_DAT_RAM. */
-	uint64_t ncbi_l2_pdm_pref_ram_dbe     : 1;  /**< Double-bit error for NCBI_L2_PDM_PREF_RAM. */
-	uint64_t ncbo_pp_fif_ram_dbe          : 1;  /**< Double-bit error for NCBO_PP_FIF_RAM. */
+	uint64_t ncbi_l2_out_ram_dbe          : 1;  /**< Double-bit error for NCBI_L2_OUT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo */
+	uint64_t ncbi_pp_out_ram_dbe          : 1;  /**< Double-bit error for NCBI_PP_OUT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo */
+	uint64_t ncbo_pdm_cmd_dat_ram_dbe     : 1;  /**< Double-bit error for NCBO_PDM_CMD_DAT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo */
+	uint64_t ncbi_l2_pdm_pref_ram_dbe     : 1;  /**< Double-bit error for NCBI_L2_PDM_PREF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
+	uint64_t ncbo_pp_fif_ram_dbe          : 1;  /**< Double-bit error for NCBO_PP_FIF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
 	uint64_t reserved_0_58                : 59;
 #else
 	uint64_t reserved_0_58                : 59;
@@ -7651,7 +8053,16 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ncb_dbe_cmb0                 : 1;  /**< Double-bit error for NCBI_L2_OUT_RAM. Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0. */
+	uint64_t ncb_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_NCB_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -7669,11 +8080,21 @@ union cvmx_pko_ncb_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_ncb_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ncbi_l2_out_ram_sbe          : 1;  /**< Single-bit error for NCBI_L2_OUT_RAM. */
-	uint64_t ncbi_pp_out_ram_sbe          : 1;  /**< Single-bit error for NCBI_PP_OUT_RAM. */
-	uint64_t ncbo_pdm_cmd_dat_ram_sbe     : 1;  /**< Single-bit error for NCBO_PDM_CMD_DAT_RAM. */
-	uint64_t ncbi_l2_pdm_pref_ram_sbe     : 1;  /**< Single-bit error for NCBI_L2_PDM_PREF_RAM. */
-	uint64_t ncbo_pp_fif_ram_sbe          : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM. */
+	uint64_t ncbi_l2_out_ram_sbe          : 1;  /**< Single-bit error for NCBI_L2_OUT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo */
+	uint64_t ncbi_pp_out_ram_sbe          : 1;  /**< Single-bit error for NCBI_PP_OUT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo */
+	uint64_t ncbo_pdm_cmd_dat_ram_sbe     : 1;  /**< Single-bit error for NCBO_PDM_CMD_DAT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo */
+	uint64_t ncbi_l2_pdm_pref_ram_sbe     : 1;  /**< Single-bit error for NCBI_L2_PDM_PREF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
+	uint64_t ncbo_pp_fif_ram_sbe          : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
 	uint64_t reserved_0_58                : 59;
 #else
 	uint64_t reserved_0_58                : 59;
@@ -7695,7 +8116,16 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ncb_sbe_cmb0                 : 1;  /**< Single-bit error for NCBI_L2_OUT_RAM. Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0. */
+	uint64_t ncb_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_NCB_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo
+                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -7797,15 +8227,27 @@ union cvmx_pko_pdm_bist_status {
 	uint64_t dwp_lo_ram_bist_status       : 1;  /**< BIST status for DWP_LO_RAM. */
 	uint64_t mwp_hi_ram_bist_status       : 1;  /**< BIST status for MWP_HI_RAM. */
 	uint64_t mwp_lo_ram_bist_status       : 1;  /**< BIST status for MWP_LO_RAM. */
-	uint64_t fillb_m_dat_ram_bist_status  : 1;  /**< BIST status for FILLB_M_DAT_RAM. */
-	uint64_t fillb_d_dat_ram_bist_status  : 1;  /**< BIST status for FILLB_D_DAT_RAM. */
+	uint64_t fillb_m_rsp_ram_hi_bist_status : 1;/**< BIST status for FILLB_M_RSP_RAM_HI. */
+	uint64_t fillb_m_rsp_ram_lo_bist_status : 1;/**< BIST status for FILLB_M_RSP_RAM_LO. */
+	uint64_t fillb_d_rsp_ram_hi_bist_status : 1;/**< BIST status for FILLB_D_RSP_RAM_HI. */
+	uint64_t fillb_d_rsp_ram_lo_bist_status : 1;/**< BIST status for FILLB_D_RSP_RAM_LO. */
+	uint64_t fillb_d_rsp_dat_fifo_bist_status : 1;/**< BIST status for FILLB_FLSHB_M_DAT_RAM. */
+	uint64_t fillb_m_rsp_dat_fifo_bist_status : 1;/**< BIST status for FILLB_M_DAT_FIFO. */
+	uint64_t flshb_m_dat_ram_bist_status  : 1;  /**< BIST status for FLSHB_M_DAT_RAM. */
+	uint64_t flshb_d_dat_ram_bist_status  : 1;  /**< BIST status for FLSHB_M_DAT_RAM. */
 	uint64_t minpad_ram_bist_status       : 1;  /**< BIST status for MINPAD_RAM. */
-	uint64_t reserved_0_43                : 44;
+	uint64_t reserved_0_37                : 38;
 #else
-	uint64_t reserved_0_43                : 44;
+	uint64_t reserved_0_37                : 38;
 	uint64_t minpad_ram_bist_status       : 1;
-	uint64_t fillb_d_dat_ram_bist_status  : 1;
-	uint64_t fillb_m_dat_ram_bist_status  : 1;
+	uint64_t flshb_d_dat_ram_bist_status  : 1;
+	uint64_t flshb_m_dat_ram_bist_status  : 1;
+	uint64_t fillb_m_rsp_dat_fifo_bist_status : 1;
+	uint64_t fillb_d_rsp_dat_fifo_bist_status : 1;
+	uint64_t fillb_d_rsp_ram_lo_bist_status : 1;
+	uint64_t fillb_d_rsp_ram_hi_bist_status : 1;
+	uint64_t fillb_m_rsp_ram_lo_bist_status : 1;
+	uint64_t fillb_m_rsp_ram_hi_bist_status : 1;
 	uint64_t mwp_lo_ram_bist_status       : 1;
 	uint64_t mwp_hi_ram_bist_status       : 1;
 	uint64_t dwp_lo_ram_bist_status       : 1;
@@ -7863,6 +8305,27 @@ union cvmx_pko_pdm_cfg {
 typedef union cvmx_pko_pdm_cfg cvmx_pko_pdm_cfg_t;
 
 /**
+ * cvmx_pko_pdm_cfg_dbg
+ */
+union cvmx_pko_pdm_cfg_dbg {
+	uint64_t u64;
+	struct cvmx_pko_pdm_cfg_dbg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t cp_stall_thrshld             : 32; /**< Program this register to the 32-bit number of cycles to test for the PDM(CP) stalled on
+                                                         inputs going into the ISR's. PKO_PDM_STS[CP_STALL_THRSHLD_HIT] indicates the threshold has
+                                                         been hit. INTERNAL: Do not list field in HRM. For lab debug only; will likely disapear in
+                                                         pass 2. */
+#else
+	uint64_t cp_stall_thrshld             : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pko_pdm_cfg_dbg_s         cn78xx;
+};
+typedef union cvmx_pko_pdm_cfg_dbg cvmx_pko_pdm_cfg_dbg_t;
+
+/**
  * cvmx_pko_pdm_dq#_minpad
  */
 union cvmx_pko_pdm_dqx_minpad {
@@ -7982,21 +8445,25 @@ union cvmx_pko_pdm_ecc_ctl0 {
 	uint64_t mwp_hi_ram_cdis              : 1;  /**< MWP_HI_RAM ECC correction disable. */
 	uint64_t mwp_lo_ram_flip              : 2;  /**< MWP_LO_RAM flip syndrome bits on write. */
 	uint64_t mwp_lo_ram_cdis              : 1;  /**< MWP_LO_RAM ECC correction disable. */
-	uint64_t fillb_m_dat_ram_flip         : 2;  /**< FILLB_M_DAT_RAM flip syndrome bits on write. */
-	uint64_t fillb_m_dat_ram_cdis         : 1;  /**< FILLB_M_DAT_RAM ECC correction disable. */
-	uint64_t fillb_d_dat_ram_flip         : 2;  /**< FILLB_D_DAT_RAM flip syndrome bits on write. */
-	uint64_t fillb_d_dat_ram_cdis         : 1;  /**< FILLB_D_DAT_RAM ECC correction disable. */
-	uint64_t minpad_ram_flip              : 2;  /**< MINPAD_RAM flip syndrome bits on write. */
-	uint64_t minpad_ram_cdis              : 1;  /**< MINPAD_RAM ECC correction disable. */
-	uint64_t reserved_0_3                 : 4;
+	uint64_t fillb_m_rsp_ram_hi_flip      : 2;  /**< FILLB_M_RSP_RAM_HI flip syndrome bits on write. */
+	uint64_t fillb_m_rsp_ram_hi_cdis      : 1;  /**< FILLB_M_RSP_RAM_HI ECC correction disable. */
+	uint64_t fillb_m_rsp_ram_lo_flip      : 2;  /**< FILLB_M_RSP_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_m_rsp_ram_lo_cdis      : 1;  /**< FILLB_M_RSP_RAM_LO ECC correction disable. */
+	uint64_t fillb_d_rsp_ram_hi_flip      : 2;  /**< FILLB_D_RSP_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_d_rsp_ram_hi_cdis      : 1;  /**< FILLB_D_RSP_RAM_HI ECC correction disable. */
+	uint64_t fillb_d_rsp_ram_lo_flip      : 2;  /**< FILLB_D_DAT_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_d_rsp_ram_lo_cdis      : 1;  /**< FILLB_D_RSP_RAM_LO ECC correction disable. */
+	uint64_t reserved_0_0                 : 1;
 #else
-	uint64_t reserved_0_3                 : 4;
-	uint64_t minpad_ram_cdis              : 1;
-	uint64_t minpad_ram_flip              : 2;
-	uint64_t fillb_d_dat_ram_cdis         : 1;
-	uint64_t fillb_d_dat_ram_flip         : 2;
-	uint64_t fillb_m_dat_ram_cdis         : 1;
-	uint64_t fillb_m_dat_ram_flip         : 2;
+	uint64_t reserved_0_0                 : 1;
+	uint64_t fillb_d_rsp_ram_lo_cdis      : 1;
+	uint64_t fillb_d_rsp_ram_lo_flip      : 2;
+	uint64_t fillb_d_rsp_ram_hi_cdis      : 1;
+	uint64_t fillb_d_rsp_ram_hi_flip      : 2;
+	uint64_t fillb_m_rsp_ram_lo_cdis      : 1;
+	uint64_t fillb_m_rsp_ram_lo_flip      : 2;
+	uint64_t fillb_m_rsp_ram_hi_cdis      : 1;
+	uint64_t fillb_m_rsp_ram_hi_flip      : 2;
 	uint64_t mwp_lo_ram_cdis              : 1;
 	uint64_t mwp_lo_ram_flip              : 2;
 	uint64_t mwp_hi_ram_cdis              : 1;
@@ -8038,38 +8505,106 @@ union cvmx_pko_pdm_ecc_ctl0 {
 typedef union cvmx_pko_pdm_ecc_ctl0 cvmx_pko_pdm_ecc_ctl0_t;
 
 /**
+ * cvmx_pko_pdm_ecc_ctl1
+ */
+union cvmx_pko_pdm_ecc_ctl1 {
+	uint64_t u64;
+	struct cvmx_pko_pdm_ecc_ctl1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_3_63                : 61;
+	uint64_t minpad_ram_flip              : 2;  /**< MINPAD_RAM flip syndrome bits on write. */
+	uint64_t minpad_ram_cdis              : 1;  /**< MINPAD_RAM ECC correction disable. */
+#else
+	uint64_t minpad_ram_cdis              : 1;
+	uint64_t minpad_ram_flip              : 2;
+	uint64_t reserved_3_63                : 61;
+#endif
+	} s;
+	struct cvmx_pko_pdm_ecc_ctl1_s        cn78xx;
+};
+typedef union cvmx_pko_pdm_ecc_ctl1 cvmx_pko_pdm_ecc_ctl1_t;
+
+/**
  * cvmx_pko_pdm_ecc_dbe_sts0
  */
 union cvmx_pko_pdm_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pdm_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t flshb_cache_lo_ram_dbe       : 1;  /**< Double-bit error for FLSHB_CACHE_LO_RAM. */
-	uint64_t flshb_cache_hi_ram_dbe       : 1;  /**< Double-bit error for FLSHB_CACHE_HI_RAM. */
-	uint64_t isrm_ca_iinst_ram_dbe        : 1;  /**< Double-bit error for ISRM_CA_IINST_RAM. */
-	uint64_t isrm_ca_cm_ram_dbe           : 1;  /**< Double-bit error for ISRM_CA_CM_RAM. */
-	uint64_t isrm_st_ram2_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM2. */
-	uint64_t isrm_st_ram1_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM1. */
-	uint64_t isrm_st_ram0_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM0. */
-	uint64_t isrd_st_ram3_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM3. */
-	uint64_t isrd_st_ram2_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM2. */
-	uint64_t isrd_st_ram1_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM1. */
-	uint64_t isrd_st_ram0_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM0. */
-	uint64_t drp_hi_ram_dbe               : 1;  /**< Double-bit error for DRP_HI_RAM. */
-	uint64_t drp_lo_ram_dbe               : 1;  /**< Double-bit error for DRP_LO_RAM. */
-	uint64_t dwp_hi_ram_dbe               : 1;  /**< Double-bit error for DWP_HI_RAM. */
-	uint64_t dwp_lo_ram_dbe               : 1;  /**< Double-bit error for DWP_LO_RAM. */
-	uint64_t mwp_hi_ram_dbe               : 1;  /**< Double-bit error for MWP_HI_RAM. */
-	uint64_t mwp_lo_ram_dbe               : 1;  /**< Double-bit error for MWP_LO_RAM. */
-	uint64_t fillb_m_dat_ram_dbe          : 1;  /**< Double-bit error for FILLB_M_DAT_RAM. */
-	uint64_t fillb_d_dat_ram_dbe          : 1;  /**< Double-bit error for FILLB_D_DAT_RAM. */
-	uint64_t minpad_ram_dbe               : 1;  /**< Double-bit error for MINPAD_RAM. */
-	uint64_t reserved_0_43                : 44;
-#else
-	uint64_t reserved_0_43                : 44;
+	uint64_t flshb_cache_lo_ram_dbe       : 1;  /**< Double-bit error for FLSHB_CACHE_LO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_lo */
+	uint64_t flshb_cache_hi_ram_dbe       : 1;  /**< Double-bit error for FLSHB_CACHE_HI_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi */
+	uint64_t isrm_ca_iinst_ram_dbe        : 1;  /**< Double-bit error for ISRM_CA_IINST_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.iinst_in_fif */
+	uint64_t isrm_ca_cm_ram_dbe           : 1;  /**< Double-bit error for ISRM_CA_CM_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.cred_accum_ctrlr_and_mem.cred_accum_spr */
+	uint64_t isrm_st_ram2_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM2.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem2 */
+	uint64_t isrm_st_ram1_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM1.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem1 */
+	uint64_t isrm_st_ram0_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem0 */
+	uint64_t isrd_st_ram3_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM3.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem3 */
+	uint64_t isrd_st_ram2_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM2.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem2 */
+	uint64_t isrd_st_ram1_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM1.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem1 */
+	uint64_t isrd_st_ram0_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem0 */
+	uint64_t drp_hi_ram_dbe               : 1;  /**< Double-bit error for DRP_HI_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_1 */
+	uint64_t drp_lo_ram_dbe               : 1;  /**< Double-bit error for DRP_LO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_2 */
+	uint64_t dwp_hi_ram_dbe               : 1;  /**< Double-bit error for DWP_HI_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high */
+	uint64_t dwp_lo_ram_dbe               : 1;  /**< Double-bit error for DWP_LO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low */
+	uint64_t mwp_hi_ram_dbe               : 1;  /**< Double-bit error for MWP_HI_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_high */
+	uint64_t mwp_lo_ram_dbe               : 1;  /**< Double-bit error for MWP_LO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_low */
+	uint64_t fillb_m_rsp_ram_hi_dbe       : 1;  /**< Double-bit error for FILLB_M_DAT_RAM_HI.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_hi */
+	uint64_t fillb_m_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_lo */
+	uint64_t fillb_d_rsp_ram_hi_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_HI.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_hi */
+	uint64_t fillb_d_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo */
+	uint64_t minpad_ram_dbe               : 1;  /**< Double-bit error for MINPAD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
+	uint64_t reserved_0_41                : 42;
+#else
+	uint64_t reserved_0_41                : 42;
 	uint64_t minpad_ram_dbe               : 1;
-	uint64_t fillb_d_dat_ram_dbe          : 1;
-	uint64_t fillb_m_dat_ram_dbe          : 1;
+	uint64_t fillb_d_rsp_ram_lo_dbe       : 1;
+	uint64_t fillb_d_rsp_ram_hi_dbe       : 1;
+	uint64_t fillb_m_rsp_ram_lo_dbe       : 1;
+	uint64_t fillb_m_rsp_ram_hi_dbe       : 1;
 	uint64_t mwp_lo_ram_dbe               : 1;
 	uint64_t mwp_hi_ram_dbe               : 1;
 	uint64_t dwp_lo_ram_dbe               : 1;
@@ -8100,7 +8635,33 @@ union cvmx_pko_pdm_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pdm_dbe_cmb0                 : 1;  /**< Double-bit error for FLSHB_CACHE_LO_RAM. Throws PKO_INTSN_E::PKO_PDM_DBE_CMB0. */
+	uint64_t pdm_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PDM_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PDM_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PDM_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_lo
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.iinst_in_fif
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.cred_accum_ctrlr_and_mem.cred_
+                                                         accum_spr
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem0
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem1
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem2
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem0
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem1
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem2
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem3
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_1
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_2
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_low
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_high
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_hi
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_dat_fifo
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -8118,32 +8679,80 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pdm_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t flshb_cache_lo_ram_sbe       : 1;  /**< Single-bit error for FLSHB_CACHE_LO_RAM. */
-	uint64_t flshb_cache_hi_ram_sbe       : 1;  /**< Single-bit error for FLSHB_CACHE_HI_RAM. */
-	uint64_t isrm_ca_iinst_ram_sbe        : 1;  /**< Single-bit error for ISRM_CA_IINST_RAM. */
-	uint64_t isrm_ca_cm_ram_sbe           : 1;  /**< Single-bit error for ISRM_CA_CM_RAM. */
-	uint64_t isrm_st_ram2_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM2. */
-	uint64_t isrm_st_ram1_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM1. */
-	uint64_t isrm_st_ram0_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM0. */
-	uint64_t isrd_st_ram3_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM3. */
-	uint64_t isrd_st_ram2_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM2. */
-	uint64_t isrd_st_ram1_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM1. */
-	uint64_t isrd_st_ram0_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM0. */
-	uint64_t drp_hi_ram_sbe               : 1;  /**< Single-bit error for DRP_HI_RAM. */
-	uint64_t drp_lo_ram_sbe               : 1;  /**< Single-bit error for DRP_LO_RAM. */
-	uint64_t dwp_hi_ram_sbe               : 1;  /**< Single-bit error for DWP_HI_RAM. */
-	uint64_t dwp_lo_ram_sbe               : 1;  /**< Single-bit error for DWP_LO_RAM. */
-	uint64_t mwp_hi_ram_sbe               : 1;  /**< Single-bit error for MWP_HI_RAM. */
-	uint64_t mwp_lo_ram_sbe               : 1;  /**< Single-bit error for MWP_LO_RAM. */
-	uint64_t fillb_m_dat_ram_sbe          : 1;  /**< Single-bit error for FILLB_M_DAT_RAM. */
-	uint64_t fillb_d_dat_ram_sbe          : 1;  /**< Single-bit error for FILLB_D_DAT_RAM. */
-	uint64_t minpad_ram_sbe               : 1;  /**< Single-bit error for MINPAD_RAM. */
-	uint64_t reserved_0_43                : 44;
-#else
-	uint64_t reserved_0_43                : 44;
+	uint64_t flshb_cache_lo_ram_sbe       : 1;  /**< Single-bit error for FLSHB_CACHE_LO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_lo */
+	uint64_t flshb_cache_hi_ram_sbe       : 1;  /**< Single-bit error for FLSHB_CACHE_HI_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi */
+	uint64_t isrm_ca_iinst_ram_sbe        : 1;  /**< Single-bit error for ISRM_CA_IINST_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.iinst_in_fif */
+	uint64_t isrm_ca_cm_ram_sbe           : 1;  /**< Single-bit error for ISRM_CA_CM_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.cred_accum_ctrlr_and_mem.cred_accum_spr */
+	uint64_t isrm_st_ram2_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM2.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem2 */
+	uint64_t isrm_st_ram1_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM1.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem1 */
+	uint64_t isrm_st_ram0_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem0 */
+	uint64_t isrd_st_ram3_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM3.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem3 */
+	uint64_t isrd_st_ram2_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM2.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem2 */
+	uint64_t isrd_st_ram1_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM1.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem1 */
+	uint64_t isrd_st_ram0_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem0 */
+	uint64_t drp_hi_ram_sbe               : 1;  /**< Single-bit error for DRP_HI_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_1 */
+	uint64_t drp_lo_ram_sbe               : 1;  /**< Single-bit error for DRP_LO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_2 */
+	uint64_t dwp_hi_ram_sbe               : 1;  /**< Single-bit error for DWP_HI_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high */
+	uint64_t dwp_lo_ram_sbe               : 1;  /**< Single-bit error for DWP_LO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low */
+	uint64_t mwp_hi_ram_sbe               : 1;  /**< Single-bit error for MWP_HI_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_high */
+	uint64_t mwp_lo_ram_sbe               : 1;  /**< Single-bit error for MWP_LO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_low */
+	uint64_t fillb_m_rsp_ram_hi_sbe       : 1;  /**< Single-bit error for FILLB_M_RSP_RAM_HI.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_hi */
+	uint64_t fillb_m_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_M_RSP_RAM_LO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_lo */
+	uint64_t fillb_d_rsp_ram_hi_sbe       : 1;  /**< Single-bit error for FILLB_D_RSP_RAM_HI.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_hi */
+	uint64_t fillb_d_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_D_RSP_RAM_LO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo */
+	uint64_t minpad_ram_sbe               : 1;  /**< Single-bit error for MINPAD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
+	uint64_t reserved_0_41                : 42;
+#else
+	uint64_t reserved_0_41                : 42;
 	uint64_t minpad_ram_sbe               : 1;
-	uint64_t fillb_d_dat_ram_sbe          : 1;
-	uint64_t fillb_m_dat_ram_sbe          : 1;
+	uint64_t fillb_d_rsp_ram_lo_sbe       : 1;
+	uint64_t fillb_d_rsp_ram_hi_sbe       : 1;
+	uint64_t fillb_m_rsp_ram_lo_sbe       : 1;
+	uint64_t fillb_m_rsp_ram_hi_sbe       : 1;
 	uint64_t mwp_lo_ram_sbe               : 1;
 	uint64_t mwp_hi_ram_sbe               : 1;
 	uint64_t dwp_lo_ram_sbe               : 1;
@@ -8174,7 +8783,33 @@ union cvmx_pko_pdm_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pdm_sbe_cmb0                 : 1;  /**< Single-bit error for FLSHB_CACHE_LO_RAM. Throws PKO_INTSN_E::PKO_PDM_SBE_CMB0. */
+	uint64_t pdm_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PDM_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PDM_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PDM_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_lo
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.iinst_in_fif
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.cred_accum_ctrlr_and_mem.cred_
+                                                         accum_spr
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem0
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem1
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem2
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem0
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem1
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem2
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem3
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_1
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_2
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_low
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_high
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_hi
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_dat_fifo
+                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -8438,64 +9073,101 @@ union cvmx_pko_pdm_mwpbuf_dbg {
 typedef union cvmx_pko_pdm_mwpbuf_dbg cvmx_pko_pdm_mwpbuf_dbg_t;
 
 /**
- * cvmx_pko_pdm_sendpkt_lmtxx_err
- */
-union cvmx_pko_pdm_sendpkt_lmtxx_err {
-	uint64_t u64;
-	struct cvmx_pko_pdm_sendpkt_lmtxx_err_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
-	uint64_t lmtst_err_cond               : 2;  /**< Error condition for PKO_PDM_STS[SENDPKT_LMTST_ERR].
-                                                         if( ERR_COND == 2'b10 ) PKO_DQSTATUS_E::DQNOFPABUF
-                                                         else if( ERR_COND == 2'b01 ) PKO_DQSTATUS_E::DQNOTCREATED */
-	uint64_t lmtdma_err_cond              : 2;  /**< Error condition for PKO_PDM_STS[SENDPKT_LMTDMA_ERR].
-                                                         if( ERR_COND == 2'b10 ) PKO_DQSTATUS_E::DQNOFPABUF
-                                                         else if( ERR_COND == 2'b01 ) PKO_DQSTATUS_E::DQNOTCREATED */
-#else
-	uint64_t lmtdma_err_cond              : 2;
-	uint64_t lmtst_err_cond               : 2;
-	uint64_t reserved_4_63                : 60;
-#endif
-	} s;
-	struct cvmx_pko_pdm_sendpkt_lmtxx_err_s cn78xx;
-};
-typedef union cvmx_pko_pdm_sendpkt_lmtxx_err cvmx_pko_pdm_sendpkt_lmtxx_err_t;
-
-/**
  * cvmx_pko_pdm_sts
  */
 union cvmx_pko_pdm_sts {
 	uint64_t u64;
 	struct cvmx_pko_pdm_sts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_9_63                : 55;
-	uint64_t mwpbuf_data_val_err          : 1;  /**< recieved signal that MWPBUF had data valid error. Throws
+	uint64_t reserved_38_63               : 26;
+	uint64_t cp_stalled_thrshld_hit       : 1;  /**< This register will be set to 1 if the PDM stalls the inputs for more than
+                                                         PKO_PDM_CFG_DBG[CP_STALL_THRSHLD]. INTERNAL: Do not list field in HRM. For lab debug only;
+                                                         will likely disapear in pass 2. */
+	uint64_t reserved_35_36               : 2;
+	uint64_t mwpbuf_data_val_err          : 1;  /**< Recieved signal that MWPBUF had data valid error. Throws
                                                          PKO_INTSN_E::PKO_MWPBUF_DATA_VAL_ERR. */
-	uint64_t drpbuf_data_val_err          : 1;  /**< recieved signal that DRPBUF had data valid error. Throws
+	uint64_t drpbuf_data_val_err          : 1;  /**< Recieved signal that DRPBUF had data valid error. Throws
                                                          PKO_INTSN_E::PKO_DRPBUF_DATA_VAL_ERR. */
-	uint64_t dwpbuf_data_val_err          : 1;  /**< recieved signal that DWPBUF had data valid error. Throws
+	uint64_t dwpbuf_data_val_err          : 1;  /**< Recieved signal that DWPBUF had data valid error. Throws
                                                          PKO_INTSN_E::PKO_DWPBUF_DATA_VAL_ERR. */
-	uint64_t sendpkt_lmtdma_err           : 1;  /**< recieved signal that FPA cannot allocate pointer. Throws
-                                                         PKO_INTSN_E::PKO_SENDPKT_LMTDMA_ERR. */
-	uint64_t sendpkt_lmtst_err            : 1;  /**< recieved signal that FPA cannot allocate pointer. Throws
-                                                         PKO_INTSN_E::PKO_SENDPKT_LMTST_ERR. */
-	uint64_t fpa_no_ptrs                  : 1;  /**< recieved signal that FPA cannot allocate pointer. Throws PKO_INTSN_E::PKO_FPA_NO_PTRS. */
-	uint64_t cp_sendpkt_err_no_drp        : 1;  /**< We did not drop a send-packet, but it appears to violate rules. (1. send jump not at end
-                                                         of descriptor). Throws PKO_INTSN_E::PKO_CP_SENDPKT_ERR_NO_DRP. */
-	uint64_t cp_pkt_drp                   : 1;  /**< Dropped a packet in PDM/CP due to rule violation. Throws PKO_INTSN_E::PKO_CP_ERR_PKT_DROP. */
-	uint64_t desc_crc_err                 : 1;  /**< CRC error occurred in a descriptor. (State may have been corrupted). Throws
-                                                         PKO_INTSN_E::PKO_DESC_CRC_ERR. */
+	uint64_t reserved_30_31               : 2;
+	uint64_t qcmd_iobx_err_sts            : 4;  /**< When PKO_PDM_STS[QCMD_IOBX_ERR] is set, the queue command response's status field
+                                                         for the response causing the error. Note that if multiple errors occur only the first
+                                                         error status will be captured here until PKO_PDM_STS[QCMD_IOBX_ERR] is cleared.
+                                                         Enumerated by PKO_DQSTATUS_E. */
+	uint64_t qcmd_iobx_err                : 1;  /**< Queue command IOBDMA/IOBLD error status occured in PKO/PDM. PKO_PDM_STS[QCMD_IOBX_ERR_STS]
+                                                         contains the status code.
+                                                         Note that this bit and interrupt will not go off for the FPA being out of
+                                                         pointers (PKO_FPA_NO_PTRS is bit 4 in this CSR).
+                                                         Throws PKO_INTSN_E::PKO_QCMD_IOBX_ERR. */
+	uint64_t sendpkt_lmtdma_err_sts       : 4;  /**< This is the status field of the command response on the LMTDMA failure indicated by
+                                                         PKO_PDM_STS[SENDPKT_LMTDMA_ERR] bits being asserted.
+                                                         Note that if multiple errors occur only the first error status will be captured here until
+                                                         PKO_PDM_STS[SENDPKT_LMTDMA_ERR] is cleared.
+                                                         Enumerated by PKO_DQSTATUS_E. */
+	uint64_t sendpkt_lmtdma_err           : 1;  /**< Send-packet of type LMTDMA error status occured in PKO/PDM.
+                                                         PKO_PDM_STS[SENDPKT_LMTDMA_ERR_STS] contains the status code.
+                                                         Note that this bit and interrupt will not go off for the FPA being out of
+                                                         pointers (PKO_FPA_NO_PTRS is bit 4 in this CSR).
+                                                         Throws PKO_INTSN_E::PKO_SENDPKT_LMTDMA_ERR. */
+	uint64_t sendpkt_lmtst_err_sts        : 4;  /**< This is the status field of the command response on the LMTST failure indicated by
+                                                         PKO_PDM_STS[SENDPKT_LMTST_ERR] bits being asserted.
+                                                         Note that if multiple errors occur only the first error status will be captured here until
+                                                         PKO_PDM_STS[SENDPKT_LMTST_ERR] is cleared.
+                                                         Enumerated by PKO_DQSTATUS_E. */
+	uint64_t sendpkt_lmtst_err            : 1;  /**< Send-packet of type LMTST error status occured in PKO/PDM.
+                                                         PKO_PDM_STS[SENDPKT_LMTST_ERR_STS] contains the status code.
+                                                         Note that this bit and interrupt will not go off for the FPA being out of
+                                                         pointers (PKO_FPA_NO_PTRS is bit 4 in this CSR).
+                                                         Throws PKO_INTSN_E::PKO_SENDPKT_LMTST_ERR. */
+	uint64_t fpa_no_ptrs                  : 1;  /**< FPA signalled PKO that FPA can not allocate pointers. This is a fatal error.
+                                                         Throws PKO_INTSN_E::PKO_FPA_NO_PTRS. */
+	uint64_t reserved_12_13               : 2;
+	uint64_t cp_sendpkt_err_no_drp_code   : 2;  /**< This field stores the error code for illegally constructed send-packets that did not drop.
+                                                         Note that if multiple errors occur only the first error code will be captured here until
+                                                         PKO_PDM_STS[CP_SENDPKT_ERR_NO_DRP] is cleared.
+                                                         Codes:
+                                                           2'b00: NO ERROR CODE
+                                                           2'b01: SEND_JUMP not at end of descriptor. */
+	uint64_t cp_sendpkt_err_no_drp        : 1;  /**< PKO/PDM/CP did not drop a send-packet, but it violates rules below.
+                                                         1) SEND_JUMP not at end of descriptor.
+                                                         The error code is captured in PKO_PDM_STS[CP_SENDPKT_ERR_NO_DRP_CODE].
+                                                         Throws PKO_INTSN_E::PKO_CP_SENDPKT_ERR_NO_DRP. */
+	uint64_t reserved_7_8                 : 2;
+	uint64_t cp_sendpkt_err_drop_code     : 3;  /**< This field stores the error code for illegally constructed send-packet drops.
+                                                         Note that if multiple errors occur only the first error code will be captured here until
+                                                         PKO_PDM_STS[CP_SENDPKT_ERR_DROP] is cleared.
+                                                         PKO_CPSENDDROP_E enumerates the codes and conditions. */
+	uint64_t cp_sendpkt_err_drop          : 1;  /**< Dropped a send-packet in PDM/CP due to rule violation.
+                                                         The error code is captured in PKO_PDM_STS[CP_SENDPKT_ERR_DROP_CODE].
+                                                         Throws PKO_INTSN_E::PKO_CP_SENDPKT_ERR_DROP. */
+	uint64_t reserved_1_2                 : 2;
+	uint64_t desc_crc_err                 : 1;  /**< CRC error occurred in a descriptor. (State may have been corrupted).
+                                                         INTERNAL: Note that this is a pass 2 feature.
+                                                         Throws PKO_INTSN_E::PKO_DESC_CRC_ERR. */
 #else
 	uint64_t desc_crc_err                 : 1;
-	uint64_t cp_pkt_drp                   : 1;
+	uint64_t reserved_1_2                 : 2;
+	uint64_t cp_sendpkt_err_drop          : 1;
+	uint64_t cp_sendpkt_err_drop_code     : 3;
+	uint64_t reserved_7_8                 : 2;
 	uint64_t cp_sendpkt_err_no_drp        : 1;
+	uint64_t cp_sendpkt_err_no_drp_code   : 2;
+	uint64_t reserved_12_13               : 2;
 	uint64_t fpa_no_ptrs                  : 1;
 	uint64_t sendpkt_lmtst_err            : 1;
+	uint64_t sendpkt_lmtst_err_sts        : 4;
 	uint64_t sendpkt_lmtdma_err           : 1;
+	uint64_t sendpkt_lmtdma_err_sts       : 4;
+	uint64_t qcmd_iobx_err                : 1;
+	uint64_t qcmd_iobx_err_sts            : 4;
+	uint64_t reserved_30_31               : 2;
 	uint64_t dwpbuf_data_val_err          : 1;
 	uint64_t drpbuf_data_val_err          : 1;
 	uint64_t mwpbuf_data_val_err          : 1;
-	uint64_t reserved_9_63                : 55;
+	uint64_t reserved_35_36               : 2;
+	uint64_t cp_stalled_thrshld_hit       : 1;
+	uint64_t reserved_38_63               : 26;
 #endif
 	} s;
 	struct cvmx_pko_pdm_sts_s             cn78xx;
@@ -8503,76 +9175,6 @@ union cvmx_pko_pdm_sts {
 typedef union cvmx_pko_pdm_sts cvmx_pko_pdm_sts_t;
 
 /**
- * cvmx_pko_peb_bist_done
- */
-union cvmx_pko_peb_bist_done {
-	uint64_t u64;
-	struct cvmx_pko_peb_bist_done_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_26_63               : 38;
-	uint64_t add_work_fifo                : 1;  /**< ADD_WORK_FIFO RAM BIST done. */
-	uint64_t pdm_pse_buf_ram              : 1;  /**< PDM_PSE_BUF RAM BIST done. */
-	uint64_t iobp0_fifo_ram               : 1;  /**< IOBP0_FIFO RAM BIST done. */
-	uint64_t iobp1_fifo_ram               : 1;  /**< IOBP1_FIFO RAM BIST done. */
-	uint64_t state_mem0                   : 1;  /**< STATE_MEM0 RAM BIST done. */
-	uint64_t state_mem1                   : 1;  /**< STATE_MEM1 RAM BIST done. */
-	uint64_t state_mem2                   : 1;  /**< STATE_MEM2 RAM BIST done. */
-	uint64_t state_mem3                   : 1;  /**< STATE_MEM3 RAM BIST done. */
-	uint64_t iobp1_uid_fifo_ram           : 1;  /**< IOBP1_UID_FIFO RAM BIST done. */
-	uint64_t nxt_link_ptr_ram             : 1;  /**< NXT_LINK_PTR RAM BIST done. */
-	uint64_t pd_bank0_ram                 : 1;  /**< PD_BANK0 RAM BIST done. */
-	uint64_t pd_bank1_ram                 : 1;  /**< PD_BANK1 RAM BIST done. */
-	uint64_t pd_bank2_ram                 : 1;  /**< PD_BANK2 RAM BIST done. */
-	uint64_t pd_bank3_ram                 : 1;  /**< PD_BANK3 RAM BIST done. */
-	uint64_t pd_var_bank_ram              : 1;  /**< PD_VAR_BANK RAM BIST done. */
-	uint64_t pdm_resp_buf_ram             : 1;  /**< PDM_RESP_BUF RAM BIST done. */
-	uint64_t tx_fifo_pkt_ram              : 1;  /**< TX_FIFO_PKT RAM BIST done. */
-	uint64_t tx_fifo_hdr_ram              : 1;  /**< TX_FIFO_HDR RAM BIST done. */
-	uint64_t tx_fifo_crc_ram              : 1;  /**< TX_FIFO_CRC RAM BIST done. */
-	uint64_t ts_addwork_ram               : 1;  /**< TS_ADDWORK RAM BIST done. */
-	uint64_t send_mem_ts_fifo             : 1;  /**< SEND_MEM_TS_FIFO RAM BIST done. */
-	uint64_t send_mem_stdn_fifo           : 1;  /**< SEND_MEM_STDN_FIFO RAM BIST done. */
-	uint64_t send_mem_fifo                : 1;  /**< SEND_MEM_FIFO RAM BIST done. */
-	uint64_t pkt_mrk_ram                  : 1;  /**< PKT_MRK RAM BIST done. */
-	uint64_t peb_st_inf_ram               : 1;  /**< PEB_ST_INF RAM BIST done. */
-	uint64_t peb_sm_jmp_ram               : 1;  /**< PEB_SM_JMP RAM BIST done.
-                                                         1 = BIST complete.
-                                                         0 = BIST in progress. */
-#else
-	uint64_t peb_sm_jmp_ram               : 1;
-	uint64_t peb_st_inf_ram               : 1;
-	uint64_t pkt_mrk_ram                  : 1;
-	uint64_t send_mem_fifo                : 1;
-	uint64_t send_mem_stdn_fifo           : 1;
-	uint64_t send_mem_ts_fifo             : 1;
-	uint64_t ts_addwork_ram               : 1;
-	uint64_t tx_fifo_crc_ram              : 1;
-	uint64_t tx_fifo_hdr_ram              : 1;
-	uint64_t tx_fifo_pkt_ram              : 1;
-	uint64_t pdm_resp_buf_ram             : 1;
-	uint64_t pd_var_bank_ram              : 1;
-	uint64_t pd_bank3_ram                 : 1;
-	uint64_t pd_bank2_ram                 : 1;
-	uint64_t pd_bank1_ram                 : 1;
-	uint64_t pd_bank0_ram                 : 1;
-	uint64_t nxt_link_ptr_ram             : 1;
-	uint64_t iobp1_uid_fifo_ram           : 1;
-	uint64_t state_mem3                   : 1;
-	uint64_t state_mem2                   : 1;
-	uint64_t state_mem1                   : 1;
-	uint64_t state_mem0                   : 1;
-	uint64_t iobp1_fifo_ram               : 1;
-	uint64_t iobp0_fifo_ram               : 1;
-	uint64_t pdm_pse_buf_ram              : 1;
-	uint64_t add_work_fifo                : 1;
-	uint64_t reserved_26_63               : 38;
-#endif
-	} s;
-	struct cvmx_pko_peb_bist_done_s       cn78xx;
-};
-typedef union cvmx_pko_peb_bist_done cvmx_pko_peb_bist_done_t;
-
-/**
  * cvmx_pko_peb_bist_status
  */
 union cvmx_pko_peb_bist_status {
@@ -8767,28 +9369,72 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_peb_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. */
-	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. */
-	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. */
-	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. */
-	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. */
-	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM. */
-	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. */
-	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. */
-	uint64_t pd_bank2_ram_dbe             : 1;  /**< Double-bit error for PD_BANK2_RAM. */
-	uint64_t pd_bank1_ram_dbe             : 1;  /**< Double-bit error for PD_BANK1_RAM. */
-	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. */
-	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. */
-	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. */
-	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. */
-	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. */
-	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. */
-	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. */
-	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. */
-	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. */
-	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. */
-	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. */
-	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. */
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t pd_bank2_ram_dbe             : 1;  /**< Double-bit error for PD_BANK2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
+	uint64_t pd_bank1_ram_dbe             : 1;  /**< Double-bit error for PD_BANK1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
 	uint64_t reserved_0_41                : 42;
 #else
 	uint64_t reserved_0_41                : 42;
@@ -8827,7 +9473,33 @@ union cvmx_pko_peb_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t peb_dbe_cmb0                 : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. Throws PKO_INTSN_E::PKO_PEB_DBE_CMB0. */
+	uint64_t peb_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PEB_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PEB_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PEB_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -8845,28 +9517,72 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_peb_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. */
-	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. */
-	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. */
-	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. */
-	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. */
-	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM. */
-	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. */
-	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. */
-	uint64_t pd_bank2_ram_sbe             : 1;  /**< Single-bit error for PD_BANK2_RAM. */
-	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. */
-	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. */
-	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. */
-	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. */
-	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. */
-	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. */
-	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. */
-	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. */
-	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. */
-	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. */
-	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. */
-	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. */
-	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. */
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t pd_bank2_ram_sbe             : 1;  /**< Single-bit error for PD_BANK2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
+	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
 	uint64_t reserved_0_41                : 42;
 #else
 	uint64_t reserved_0_41                : 42;
@@ -8905,7 +9621,33 @@ union cvmx_pko_peb_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t peb_sbe_cmb0                 : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. Throws PKO_INTSN_E::PKO_PEB_SBE_CMB0. */
+	uint64_t peb_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PEB_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PEB_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PEB_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9180,6 +9922,126 @@ union cvmx_pko_peb_trunc_err_info {
 typedef union cvmx_pko_peb_trunc_err_info cvmx_pko_peb_trunc_err_info_t;
 
 /**
+ * cvmx_pko_pq_debug_green
+ */
+union cvmx_pko_pq_debug_green {
+	uint64_t u64;
+	struct cvmx_pko_pq_debug_green_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t g_valid                      : 32; /**< g_valid vector. */
+	uint64_t cred_ok_n                    : 32; /**< cred_ok_n vector. */
+#else
+	uint64_t cred_ok_n                    : 32;
+	uint64_t g_valid                      : 32;
+#endif
+	} s;
+	struct cvmx_pko_pq_debug_green_s      cn78xx;
+};
+typedef union cvmx_pko_pq_debug_green cvmx_pko_pq_debug_green_t;
+
+/**
+ * cvmx_pko_pq_debug_links
+ */
+union cvmx_pko_pq_debug_links {
+	uint64_t u64;
+	struct cvmx_pko_pq_debug_links_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t links_ready                  : 32; /**< links_ready vector. */
+	uint64_t peb_lnk_rdy_ir               : 32; /**< peb_lnk_rdy_ir vector. */
+#else
+	uint64_t peb_lnk_rdy_ir               : 32;
+	uint64_t links_ready                  : 32;
+#endif
+	} s;
+	struct cvmx_pko_pq_debug_links_s      cn78xx;
+};
+typedef union cvmx_pko_pq_debug_links cvmx_pko_pq_debug_links_t;
+
+/**
+ * cvmx_pko_pq_debug_yellow
+ */
+union cvmx_pko_pq_debug_yellow {
+	uint64_t u64;
+	struct cvmx_pko_pq_debug_yellow_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t y_valid                      : 32; /**< y_valid vector. */
+	uint64_t link_vv                      : 32; /**< link_vv vector. */
+#else
+	uint64_t link_vv                      : 32;
+	uint64_t y_valid                      : 32;
+#endif
+	} s;
+	struct cvmx_pko_pq_debug_yellow_s     cn78xx;
+};
+typedef union cvmx_pko_pq_debug_yellow cvmx_pko_pq_debug_yellow_t;
+
+/**
+ * cvmx_pko_pqa_debug
+ */
+union cvmx_pko_pqa_debug {
+	uint64_t u64;
+	struct cvmx_pko_pqa_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_pqa_debug_s           cn78xx;
+};
+typedef union cvmx_pko_pqa_debug cvmx_pko_pqa_debug_t;
+
+/**
+ * cvmx_pko_pqb_debug
+ */
+union cvmx_pko_pqb_debug {
+	uint64_t u64;
+	struct cvmx_pko_pqb_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dbg_vec                      : 64; /**< Debug Vector. */
+#else
+	uint64_t dbg_vec                      : 64;
+#endif
+	} s;
+	struct cvmx_pko_pqb_debug_s           cn78xx;
+};
+typedef union cvmx_pko_pqb_debug cvmx_pko_pqb_debug_t;
+
+/**
+ * cvmx_pko_pse_dq_bist_status
+ */
+union cvmx_pko_pse_dq_bist_status {
+	uint64_t u64;
+	struct cvmx_pko_pse_dq_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t wt_sram                      : 1;  /**< Work Table */
+	uint64_t rt7_sram                     : 1;  /**< Result Table 7 - DQ FIFO[1023:896] */
+	uint64_t rt6_sram                     : 1;  /**< Result Table 6 - DQ FIFO[895:768] */
+	uint64_t rt5_sram                     : 1;  /**< Result Table 5 - DQ FIFO[767:640] */
+	uint64_t rt4_sram                     : 1;  /**< Result Table 4 - DQ FIFO[639:512] */
+	uint64_t rt3_sram                     : 1;  /**< Result Table 3 - DQ FIFO[511:384] */
+	uint64_t rt2_sram                     : 1;  /**< Result Table 2 - DQ FIFO[383:256] */
+	uint64_t rt1_sram                     : 1;  /**< Result Table 1 - DQ FIFO[255:128] */
+	uint64_t rt0_sram                     : 1;  /**< Result Table 0 - DQ FIFO[127:0] */
+#else
+	uint64_t rt0_sram                     : 1;
+	uint64_t rt1_sram                     : 1;
+	uint64_t rt2_sram                     : 1;
+	uint64_t rt3_sram                     : 1;
+	uint64_t rt4_sram                     : 1;
+	uint64_t rt5_sram                     : 1;
+	uint64_t rt6_sram                     : 1;
+	uint64_t rt7_sram                     : 1;
+	uint64_t wt_sram                      : 1;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} s;
+	struct cvmx_pko_pse_dq_bist_status_s  cn78xx;
+};
+typedef union cvmx_pko_pse_dq_bist_status cvmx_pko_pse_dq_bist_status_t;
+
+/**
  * cvmx_pko_pse_dq_ecc_ctl0
  */
 union cvmx_pko_pse_dq_ecc_ctl0 {
@@ -9238,15 +10100,33 @@ union cvmx_pko_pse_dq_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq_wt_ram_dbe                : 1;  /**< Double-bit error for DQ_WT_RAM. */
-	uint64_t dq_rt7_dbe                   : 1;  /**< Double-bit error for DQ_RT7. */
-	uint64_t dq_rt6_dbe                   : 1;  /**< Double-bit error for DQ_RT6. */
-	uint64_t dq_rt5_dbe                   : 1;  /**< Double-bit error for DQ_RT5. */
-	uint64_t dq_rt4_dbe                   : 1;  /**< Double-bit error for DQ_RT4. */
-	uint64_t dq_rt3_dbe                   : 1;  /**< Double-bit error for DQ_RT3. */
-	uint64_t dq_rt2_dbe                   : 1;  /**< Double-bit error for DQ_RT2. */
-	uint64_t dq_rt1_dbe                   : 1;  /**< Double-bit error for DQ_RT1. */
-	uint64_t dq_rt0_dbe                   : 1;  /**< Double-bit error for DQ_RT0. */
+	uint64_t dq_wt_ram_dbe                : 1;  /**< Double-bit error for DQ_WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.wt_sram */
+	uint64_t dq_rt7_dbe                   : 1;  /**< Double-bit error for DQ_RT7_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt7 */
+	uint64_t dq_rt6_dbe                   : 1;  /**< Double-bit error for DQ_RT6_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt6 */
+	uint64_t dq_rt5_dbe                   : 1;  /**< Double-bit error for DQ_RT5_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt5 */
+	uint64_t dq_rt4_dbe                   : 1;  /**< Double-bit error for DQ_RT4_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt4 */
+	uint64_t dq_rt3_dbe                   : 1;  /**< Double-bit error for DQ_RT3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt3 */
+	uint64_t dq_rt2_dbe                   : 1;  /**< Double-bit error for DQ_RT2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt2 */
+	uint64_t dq_rt1_dbe                   : 1;  /**< Double-bit error for DQ_RT1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt1 */
+	uint64_t dq_rt0_dbe                   : 1;  /**< Double-bit error for DQ_RT0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt0 */
 	uint64_t reserved_0_54                : 55;
 #else
 	uint64_t reserved_0_54                : 55;
@@ -9272,7 +10152,20 @@ union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_dq_dbe_cmb0              : 1;  /**< Double-bit error for DQ_WT_RAM. Throws PKO_INTSN_E::PKO_PSE_DQ_DBE_CMB0. */
+	uint64_t pse_dq_dbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_DQ_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_DQ_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_DQ_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.wt_sram
+                                                         pko_pnr2.pko_pse.pse_dq.rt0
+                                                         pko_pnr2.pko_pse.pse_dq.rt1
+                                                         pko_pnr2.pko_pse.pse_dq.rt2
+                                                         pko_pnr2.pko_pse.pse_dq.rt3
+                                                         pko_pnr2.pko_pse.pse_dq.rt4
+                                                         pko_pnr2.pko_pse.pse_dq.rt5
+                                                         pko_pnr2.pko_pse.pse_dq.rt6
+                                                         pko_pnr2.pko_pse.pse_dq.rt7 */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9290,15 +10183,33 @@ union cvmx_pko_pse_dq_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq_wt_ram_sbe                : 1;  /**< Single-bit error for DQ_WT_RAM. */
-	uint64_t dq_rt7_sbe                   : 1;  /**< Single-bit error for DQ_RT7. */
-	uint64_t dq_rt6_sbe                   : 1;  /**< Single-bit error for DQ_RT6. */
-	uint64_t dq_rt5_sbe                   : 1;  /**< Single-bit error for DQ_RT5. */
-	uint64_t dq_rt4_sbe                   : 1;  /**< Single-bit error for DQ_RT4. */
-	uint64_t dq_rt3_sbe                   : 1;  /**< Single-bit error for DQ_RT3. */
-	uint64_t dq_rt2_sbe                   : 1;  /**< Single-bit error for DQ_RT2. */
-	uint64_t dq_rt1_sbe                   : 1;  /**< Single-bit error for DQ_RT1. */
-	uint64_t dq_rt0_sbe                   : 1;  /**< Single-bit error for DQ_RT0. */
+	uint64_t dq_wt_ram_sbe                : 1;  /**< Single-bit error for DQ_WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.wt_sram */
+	uint64_t dq_rt7_sbe                   : 1;  /**< Single-bit error for DQ_RT7_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt7 */
+	uint64_t dq_rt6_sbe                   : 1;  /**< Single-bit error for DQ_RT6_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt6 */
+	uint64_t dq_rt5_sbe                   : 1;  /**< Single-bit error for DQ_RT5_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt5 */
+	uint64_t dq_rt4_sbe                   : 1;  /**< Single-bit error for DQ_RT4_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt4 */
+	uint64_t dq_rt3_sbe                   : 1;  /**< Single-bit error for DQ_RT3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt3 */
+	uint64_t dq_rt2_sbe                   : 1;  /**< Single-bit error for DQ_RT2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt2 */
+	uint64_t dq_rt1_sbe                   : 1;  /**< Single-bit error for DQ_RT1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt1 */
+	uint64_t dq_rt0_sbe                   : 1;  /**< Single-bit error for DQ_RT0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.rt0 */
 	uint64_t reserved_0_54                : 55;
 #else
 	uint64_t reserved_0_54                : 55;
@@ -9324,7 +10235,20 @@ union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_dq_sbe_cmb0              : 1;  /**< Single-bit error for DQ_WT_RAM. Throws PKO_INTSN_E::PKO_PSE_DQ_SBE_CMB0. */
+	uint64_t pse_dq_sbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_DQ_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_DQ_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_DQ_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_dq.wt_sram
+                                                         pko_pnr2.pko_pse.pse_dq.rt0
+                                                         pko_pnr2.pko_pse.pse_dq.rt1
+                                                         pko_pnr2.pko_pse.pse_dq.rt2
+                                                         pko_pnr2.pko_pse.pse_dq.rt3
+                                                         pko_pnr2.pko_pse.pse_dq.rt4
+                                                         pko_pnr2.pko_pse.pse_dq.rt5
+                                                         pko_pnr2.pko_pse.pse_dq.rt6
+                                                         pko_pnr2.pko_pse.pse_dq.rt7 */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9336,6 +10260,52 @@ union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 {
 typedef union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_t;
 
 /**
+ * cvmx_pko_pse_pq_bist_status
+ */
+union cvmx_pko_pse_pq_bist_status {
+	uint64_t u64;
+	struct cvmx_pko_pse_pq_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t tp_sram                      : 1;  /**< Topology Parent - pko_pse_pq_srf32x5e */
+	uint64_t irq_fifo_sram                : 1;  /**< Interrupt Message FIFO - pko_pse_pq_srf1024x10e */
+	uint64_t wmd_sram                     : 1;  /**< Dynamic Watermark State - pko_pse_wmd_srf1024x49e */
+	uint64_t wms_sram                     : 1;  /**< Static Watermark Configuration - pko_pse_wms_srf1024x50e */
+	uint64_t cxd_sram                     : 1;  /**< Dynamic Channel State - pko_pse_cxd_srf32x31e */
+	uint64_t dqd_sram                     : 1;  /**< DQ Dropped Stats - pko_pse_stats_srf1024x88 */
+	uint64_t dqs_sram                     : 1;  /**< DQ Sent Stats - pko_pse_stats_srf1024x88 */
+	uint64_t pqd_sram                     : 1;  /**< PQ Dropped Stats - pko_pse_stats_srf32x88 */
+	uint64_t pqr_sram                     : 1;  /**< PQ Read Stats - pko_pse_stats_srf32x88 */
+	uint64_t pqy_sram                     : 1;  /**< PQ Yellow Stats - pko_pse_stats_srf32x88 */
+	uint64_t pqg_sram                     : 1;  /**< PQ Green Stats - pko_pse_stats_srf32x88 */
+	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State - pko_pse_std_srf32x105e */
+	uint64_t st_sram                      : 1;  /**< Static Shaping Configuration - pko_pse_sts_srf32x74e */
+	uint64_t reserved_1_1                 : 1;
+	uint64_t cxs_sram                     : 1;  /**< Static Channel Credit Configuration - pko_pse_cx0_srf32x6e */
+#else
+	uint64_t cxs_sram                     : 1;
+	uint64_t reserved_1_1                 : 1;
+	uint64_t st_sram                      : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t pqg_sram                     : 1;
+	uint64_t pqy_sram                     : 1;
+	uint64_t pqr_sram                     : 1;
+	uint64_t pqd_sram                     : 1;
+	uint64_t dqs_sram                     : 1;
+	uint64_t dqd_sram                     : 1;
+	uint64_t cxd_sram                     : 1;
+	uint64_t wms_sram                     : 1;
+	uint64_t wmd_sram                     : 1;
+	uint64_t irq_fifo_sram                : 1;
+	uint64_t tp_sram                      : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_pko_pse_pq_bist_status_s  cn78xx;
+};
+typedef union cvmx_pko_pse_pq_bist_status cvmx_pko_pse_pq_bist_status_t;
+
+/**
  * cvmx_pko_pse_pq_ecc_ctl0
  */
 union cvmx_pko_pse_pq_ecc_ctl0 {
@@ -9390,14 +10360,30 @@ union cvmx_pko_pse_pq_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pq_cxs_ram_dbe               : 1;  /**< Double-bit error for PQ_CXS_RAM. */
-	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM. */
-	uint64_t irq_fifo_sram_dbe            : 1;  /**< Double-bit error for IRQ_FIFO_SRAM. */
-	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM. */
-	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM. */
-	uint64_t pq_st_ram_dbe                : 1;  /**< Double-bit error for PQ_ST_RAM. */
-	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM. */
-	uint64_t pq_wms_ram_dbe               : 1;  /**< Double-bit error for PQ_WMS_RAM. */
+	uint64_t pq_cxs_ram_dbe               : 1;  /**< Double-bit error for PQ_CXS_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram */
+	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram */
+	uint64_t irq_fifo_sram_dbe            : 1;  /**< Double-bit error for IRQ_FIFO_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram */
+	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram */
+	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram */
+	uint64_t pq_st_ram_dbe                : 1;  /**< Double-bit error for PQ_ST_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram */
+	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram */
+	uint64_t pq_wms_ram_dbe               : 1;  /**< Double-bit error for PQ_WMS_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
 	uint64_t reserved_0_55                : 56;
 #else
 	uint64_t reserved_0_55                : 56;
@@ -9422,7 +10408,19 @@ union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_pq_dbe_cmb0              : 1;  /**< Double-bit error for PQ_CXS_RAM. Throws PKO_INTSN_E::PKO_PSE_PQ_DBE_CMB0. */
+	uint64_t pse_pq_dbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_PQ_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_PQ_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_PQ_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9440,14 +10438,30 @@ union cvmx_pko_pse_pq_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pq_cxs_ram_sbe               : 1;  /**< Single-bit error for PQ_CXS_RAM. */
-	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM. */
-	uint64_t irq_fifo_sram_sbe            : 1;  /**< Single-bit error for IRQ_FIFO_SRAM. */
-	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM. */
-	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM. */
-	uint64_t pq_st_ram_sbe                : 1;  /**< Single-bit error for PQ_ST_RAM. */
-	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM. */
-	uint64_t pq_wms_ram_sbe               : 1;  /**< Single-bit error for PQ_WMS_RAM. */
+	uint64_t pq_cxs_ram_sbe               : 1;  /**< Single-bit error for PQ_CXS_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram */
+	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram */
+	uint64_t irq_fifo_sram_sbe            : 1;  /**< Single-bit error for IRQ_FIFO_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram */
+	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram */
+	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram */
+	uint64_t pq_st_ram_sbe                : 1;  /**< Single-bit error for PQ_ST_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram */
+	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram */
+	uint64_t pq_wms_ram_sbe               : 1;  /**< Single-bit error for PQ_WMS_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
 	uint64_t reserved_0_55                : 56;
 #else
 	uint64_t reserved_0_55                : 56;
@@ -9472,7 +10486,19 @@ union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_pq_sbe_cmb0              : 1;  /**< Single-bit error for PQ_CXS_RAM. Throws PKO_INTSN_E::PKO_PSE_PQ_SBE_CMB0. */
+	uint64_t pse_pq_sbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_PQ_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_PQ_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_PQ_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9484,6 +10510,64 @@ union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 {
 typedef union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_t;
 
 /**
+ * cvmx_pko_pse_sq1_bist_status
+ */
+union cvmx_pko_pse_sq1_bist_status {
+	uint64_t u64;
+	struct cvmx_pko_pse_sq1_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< SQ[5:1] Scheduling Configuration */
+	uint64_t pc_sram                      : 1;  /**< SQ[1] physical channel - pko_pse_pc_srf32x12e */
+	uint64_t xon_sram                     : 1;  /**< XON SRAM */
+	uint64_t cc_sram                      : 1;  /**< SQ[1] Channel Credit OK State Array */
+	uint64_t vc1_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
+	uint64_t vc0_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
+	uint64_t reserved_21_22               : 2;
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t xo_sram                      : 1;  /**< XOFF SRAM */
+	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t reserved_9_16                : 8;
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
+	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t cxd_sram                     : 1;  /**< SQ[1] Dynamic Channel Credit State */
+	uint64_t cxs_sram                     : 1;  /**< SQ[1] Static Channel Credit Configuration */
+	uint64_t nt_sram                      : 1;  /**< SQ[5:1] "Next" Pointer Table */
+	uint64_t pt_sram                      : 1;  /**< SQ[5:1] "Previous" Pointer Table */
+	uint64_t wt_sram                      : 1;  /**< SQ[5:1] Work Table */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t cxs_sram                     : 1;
+	uint64_t cxd_sram                     : 1;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t tw1_cmd_fifo                 : 1;
+	uint64_t reserved_9_16                : 8;
+	uint64_t rt_sram                      : 1;
+	uint64_t xo_sram                      : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t tp1_sram                     : 1;
+	uint64_t reserved_21_22               : 2;
+	uint64_t vc0_sram                     : 1;
+	uint64_t vc1_sram                     : 1;
+	uint64_t cc_sram                      : 1;
+	uint64_t xon_sram                     : 1;
+	uint64_t pc_sram                      : 1;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_pko_pse_sq1_bist_status_s cn78xx;
+};
+typedef union cvmx_pko_pse_sq1_bist_status cvmx_pko_pse_sq1_bist_status_t;
+
+/**
  * cvmx_pko_pse_sq1_ecc_ctl0
  */
 union cvmx_pko_pse_sq1_ecc_ctl0 {
@@ -9578,24 +10662,60 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cxs_ram_dbe                  : 1;  /**< Double-bit error for CXS_RAM. */
-	uint64_t cxd_ram_dbe                  : 1;  /**< Double-bit error for CXD_RAM. */
-	uint64_t vc1_sram_dbe                 : 1;  /**< Double-bit error for VC1_SRAM. */
-	uint64_t vc0_sram_dbe                 : 1;  /**< Double-bit error for VC0_SRAM. */
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
-	uint64_t pc_ram_dbe                   : 1;  /**< Double-bit error for PC_RAM. */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
+	uint64_t cxs_ram_dbe                  : 1;  /**< Double-bit error for CXS_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxs_sram */
+	uint64_t cxd_ram_dbe                  : 1;  /**< Double-bit error for CXD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxd_sram */
+	uint64_t vc1_sram_dbe                 : 1;  /**< Double-bit error for VC1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc1_sram */
+	uint64_t vc0_sram_dbe                 : 1;  /**< Double-bit error for VC0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc0_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.rt_sram */
+	uint64_t pc_ram_dbe                   : 1;  /**< Double-bit error for PC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.pc_sram */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_0.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_1.sq_fifo_sram */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp0_sram */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp1_sram */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts1_sram */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts0_sram */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std1_sram */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sc_sram */
 	uint64_t reserved_0_45                : 46;
 #else
 	uint64_t reserved_0_45                : 46;
@@ -9630,7 +10750,29 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq1_dbe_cmb0             : 1;  /**< Double-bit error for CXS_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ1_DBE_CMB0. */
+	uint64_t pse_sq1_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ1_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ1_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ1_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxs_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxd_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.pc_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9648,24 +10790,60 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cxs_ram_sbe                  : 1;  /**< Single-bit error for CXS_RAM. */
-	uint64_t cxd_ram_sbe                  : 1;  /**< Single-bit error for CXD_RAM. */
-	uint64_t vc1_sram_sbe                 : 1;  /**< Single-bit error for VC1_SRAM. */
-	uint64_t vc0_sram_sbe                 : 1;  /**< Single-bit error for VC0_SRAM. */
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
-	uint64_t pc_ram_sbe                   : 1;  /**< Single-bit error for PC_RAM. */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
+	uint64_t cxs_ram_sbe                  : 1;  /**< Single-bit error for CXS_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxs_sram */
+	uint64_t cxd_ram_sbe                  : 1;  /**< Single-bit error for CXD_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxd_sram */
+	uint64_t vc1_sram_sbe                 : 1;  /**< Single-bit error for VC1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc0_sram */
+	uint64_t vc0_sram_sbe                 : 1;  /**< Single-bit error for VC0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc1_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.rt_sram */
+	uint64_t pc_ram_sbe                   : 1;  /**< Single-bit error for PC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.pc_sram */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_0.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_1.sq_fifo_sram */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp0_sram */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp1_sram */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts0_sram */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts1_sram */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std0_sram */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std1_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sc_sram */
 	uint64_t reserved_0_45                : 46;
 #else
 	uint64_t reserved_0_45                : 46;
@@ -9700,7 +10878,29 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq1_sbe_cmb0             : 1;  /**< Single-bit error for CXS_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ1_SBE_CMB0. */
+	uint64_t pse_sq1_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ1_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ1_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ1_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxs_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.cxd_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.pc_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9712,6 +10912,52 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 {
 typedef union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_t;
 
 /**
+ * cvmx_pko_pse_sq2_bist_status
+ */
+union cvmx_pko_pse_sq2_bist_status {
+	uint64_t u64;
+	struct cvmx_pko_pse_sq2_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< Scheduling Configuration */
+	uint64_t reserved_21_27               : 7;
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t reserved_18_18               : 1;
+	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t reserved_9_16                : 8;
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
+	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t nt_sram                      : 1;  /**< Next Pointer Table */
+	uint64_t pt_sram                      : 1;  /**< Previous Pointer Table */
+	uint64_t wt_sram                      : 1;  /**< Work Table */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t tw1_cmd_fifo                 : 1;
+	uint64_t reserved_9_16                : 8;
+	uint64_t rt_sram                      : 1;
+	uint64_t reserved_18_18               : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t tp1_sram                     : 1;
+	uint64_t reserved_21_27               : 7;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_pko_pse_sq2_bist_status_s cn78xx;
+};
+typedef union cvmx_pko_pse_sq2_bist_status cvmx_pko_pse_sq2_bist_status_t;
+
+/**
  * cvmx_pko_pse_sq2_ecc_ctl0
  */
 union cvmx_pko_pse_sq2_ecc_ctl0 {
@@ -9786,19 +11032,45 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.rt_sram */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_0.sq_fifo_sram */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp1_sram */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp0_sram */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts1_sram */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts0_sram */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std1_sram */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sc_sram */
 	uint64_t reserved_0_50                : 51;
 #else
 	uint64_t reserved_0_50                : 51;
@@ -9828,7 +11100,24 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq2_dbe_cmb0             : 1;  /**< Double-bit error for SQ_PT_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ2_DBE_CMB0. */
+	uint64_t pse_sq2_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ2_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ2_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ2_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9846,19 +11135,45 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.rt_sram */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_0.sq_fifo_sram */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp1_sram */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp0_sram */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts1_sram */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts0_sram */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std1_sram */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std0_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sc_sram */
 	uint64_t reserved_0_50                : 51;
 #else
 	uint64_t reserved_0_50                : 51;
@@ -9888,7 +11203,24 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq2_sbe_cmb0             : 1;  /**< Single-bit error for SQ_PT_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ2_SBE_CMB0. */
+	uint64_t pse_sq2_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ2_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ2_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ2_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -9900,6 +11232,64 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 {
 typedef union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_t;
 
 /**
+ * cvmx_pko_pse_sq3_bist_status
+ */
+union cvmx_pko_pse_sq3_bist_status {
+	uint64_t u64;
+	struct cvmx_pko_pse_sq3_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< Scheduling Configuration */
+	uint64_t reserved_23_27               : 5;
+	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
+	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t reserved_18_18               : 1;
+	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t reserved_15_16               : 2;
+	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 3 command FIFO SRAM */
+	uint64_t reserved_12_13               : 2;
+	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 2 command FIFO SRAM */
+	uint64_t reserved_9_10                : 2;
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
+	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t nt_sram                      : 1;  /**< Next Pointer Table */
+	uint64_t pt_sram                      : 1;  /**< Previous Pointer Table */
+	uint64_t wt_sram                      : 1;  /**< Work Table */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t tw1_cmd_fifo                 : 1;
+	uint64_t reserved_9_10                : 2;
+	uint64_t tw2_cmd_fifo                 : 1;
+	uint64_t reserved_12_13               : 2;
+	uint64_t tw3_cmd_fifo                 : 1;
+	uint64_t reserved_15_16               : 2;
+	uint64_t rt_sram                      : 1;
+	uint64_t reserved_18_18               : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t tp1_sram                     : 1;
+	uint64_t tp2_sram                     : 1;
+	uint64_t tp3_sram                     : 1;
+	uint64_t reserved_23_27               : 5;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_pko_pse_sq3_bist_status_s cn78xx;
+};
+typedef union cvmx_pko_pse_sq3_bist_status cvmx_pko_pse_sq3_bist_status_t;
+
+/**
  * cvmx_pko_pse_sq3_ecc_ctl0
  */
 union cvmx_pko_pse_sq3_ecc_ctl0 {
@@ -10006,27 +11396,69 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
-	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. */
-	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. */
-	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
-	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM. */
-	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM. */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
-	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. */
-	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
+	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_3.sq_fifo_sram */
+	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_2.sq_fifo_sram */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
+	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp3_sram */
+	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp2_sram */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp1_sram */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
+	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts3_sram */
+	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts2_sram */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts1_sram */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
+	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std3_sram */
+	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std2_sram */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std1_sram */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -10064,7 +11496,32 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq3_dbe_cmb0             : 1;  /**< Double-bit error for SQ_PT_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ3_DBE_CMB0. */
+	uint64_t pse_sq3_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ3_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ3_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ3_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_2.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_3.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10082,27 +11539,69 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
-	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. */
-	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. */
-	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
-	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. */
-	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
-	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. */
-	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
+	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_3.sq_fifo_sram */
+	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_2.sq_fifo_sram */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
+	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp3_sram */
+	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp2_sram */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp1_sram */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
+	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts3_sram */
+	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts2_sram */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts1_sram */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
+	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std3_sram */
+	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std2_sram */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std1_sram */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -10140,7 +11639,32 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq3_sbe_cmb0             : 1;  /**< Single-bit error for SQ_PT_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ3_SBE_CMB0. */
+	uint64_t pse_sq3_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ3_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ3_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ3_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_2.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_3.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10152,6 +11676,64 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 {
 typedef union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_t;
 
 /**
+ * cvmx_pko_pse_sq4_bist_status
+ */
+union cvmx_pko_pse_sq4_bist_status {
+	uint64_t u64;
+	struct cvmx_pko_pse_sq4_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< Scheduling Configuration */
+	uint64_t reserved_23_27               : 5;
+	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
+	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t reserved_18_18               : 1;
+	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t reserved_15_16               : 2;
+	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 3 command FIFO SRAM */
+	uint64_t reserved_12_13               : 2;
+	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 2 command FIFO SRAM */
+	uint64_t reserved_9_10                : 2;
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
+	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t nt_sram                      : 1;  /**< Next Pointer Table */
+	uint64_t pt_sram                      : 1;  /**< Previous Pointer Table */
+	uint64_t wt_sram                      : 1;  /**< Work Table */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t tw1_cmd_fifo                 : 1;
+	uint64_t reserved_9_10                : 2;
+	uint64_t tw2_cmd_fifo                 : 1;
+	uint64_t reserved_12_13               : 2;
+	uint64_t tw3_cmd_fifo                 : 1;
+	uint64_t reserved_15_16               : 2;
+	uint64_t rt_sram                      : 1;
+	uint64_t reserved_18_18               : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t tp1_sram                     : 1;
+	uint64_t tp2_sram                     : 1;
+	uint64_t tp3_sram                     : 1;
+	uint64_t reserved_23_27               : 5;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_pko_pse_sq4_bist_status_s cn78xx;
+};
+typedef union cvmx_pko_pse_sq4_bist_status cvmx_pko_pse_sq4_bist_status_t;
+
+/**
  * cvmx_pko_pse_sq4_ecc_ctl0
  */
 union cvmx_pko_pse_sq4_ecc_ctl0 {
@@ -10258,27 +11840,69 @@ union cvmx_pko_pse_sq4_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq4_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
-	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. */
-	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. */
-	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
-	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM. */
-	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM. */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
-	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. */
-	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.pt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.rt_sram */
+	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_3.sq_fifo_sram */
+	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_2.sq_fifo_sram */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_0.sq_fifo_sram */
+	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp3_sram */
+	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp2_sram */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp1_sram */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp0_sram */
+	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts3_sram */
+	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts2_sram */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts1_sram */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts0_sram */
+	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std3_sram */
+	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std2_sram */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std1_sram */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sc_sram */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -10316,7 +11940,32 @@ union cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq4_dbe_cmb0             : 1;  /**< Double-bit error for SQ_PT_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ4_DBE_CMB0. */
+	uint64_t pse_sq4_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ4_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ4_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ4_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_2.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_3.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10334,27 +11983,69 @@ union cvmx_pko_pse_sq4_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq4_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
-	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. */
-	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. */
-	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
-	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. */
-	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
-	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. */
-	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.rt_sram */
+	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_3.sq_fifo_sram */
+	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_2.sq_fifo_sram */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_0.sq_fifo_sram */
+	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp3_sram */
+	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp2_sram */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp1_sram */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp0_sram */
+	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts3_sram */
+	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts2_sram */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts1_sram */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts0_sram */
+	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std3_sram */
+	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std2_sram */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std1_sram */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std0_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sc_sram */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -10392,7 +12083,32 @@ union cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq4_sbe_cmb0             : 1;  /**< Single-bit error for SQ_PT_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ4_SBE_CMB0. */
+	uint64_t pse_sq4_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ4_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ4_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ4_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_2.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_3.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10404,6 +12120,64 @@ union cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0 {
 typedef union cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0_t;
 
 /**
+ * cvmx_pko_pse_sq5_bist_status
+ */
+union cvmx_pko_pse_sq5_bist_status {
+	uint64_t u64;
+	struct cvmx_pko_pse_sq5_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< Scheduling Configuration */
+	uint64_t reserved_23_27               : 5;
+	uint64_t tp3_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
+	uint64_t tp2_sram                     : 1;  /**< SQ[5:3] Topology Parent Configuration */
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] Topology Parent Configuration */
+	uint64_t reserved_18_18               : 1;
+	uint64_t rt_sram                      : 1;  /**< Result Table */
+	uint64_t reserved_15_16               : 2;
+	uint64_t tw3_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 3 command FIFO SRAM */
+	uint64_t reserved_12_13               : 2;
+	uint64_t tw2_cmd_fifo                 : 1;  /**< SQ[5:3] Timewheel 2 command FIFO SRAM */
+	uint64_t reserved_9_10                : 2;
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic Shaping State */
+	uint64_t sts_sram                     : 1;  /**< Static Shaping Configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] Timewheel 0 command FIFO SRAM */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t nt_sram                      : 1;  /**< Next Pointer Table */
+	uint64_t pt_sram                      : 1;  /**< Previous Pointer Table */
+	uint64_t wt_sram                      : 1;  /**< Work Table */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t tw1_cmd_fifo                 : 1;
+	uint64_t reserved_9_10                : 2;
+	uint64_t tw2_cmd_fifo                 : 1;
+	uint64_t reserved_12_13               : 2;
+	uint64_t tw3_cmd_fifo                 : 1;
+	uint64_t reserved_15_16               : 2;
+	uint64_t rt_sram                      : 1;
+	uint64_t reserved_18_18               : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t tp1_sram                     : 1;
+	uint64_t tp2_sram                     : 1;
+	uint64_t tp3_sram                     : 1;
+	uint64_t reserved_23_27               : 5;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_pko_pse_sq5_bist_status_s cn78xx;
+};
+typedef union cvmx_pko_pse_sq5_bist_status cvmx_pko_pse_sq5_bist_status_t;
+
+/**
  * cvmx_pko_pse_sq5_ecc_ctl0
  */
 union cvmx_pko_pse_sq5_ecc_ctl0 {
@@ -10510,27 +12284,69 @@ union cvmx_pko_pse_sq5_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq5_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
-	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. */
-	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. */
-	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
-	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM. */
-	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM. */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
-	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. */
-	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.pt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.rt_sram */
+	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_3.sq_fifo_sram */
+	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_2.sq_fifo_sram */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_0.sq_fifo_sram */
+	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp3_sram */
+	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp2_sram */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp1_sram */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp0_sram */
+	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts3_sram */
+	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts2_sram */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts1_sram */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts0_sram */
+	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std3_sram */
+	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std2_sram */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std1_sram */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sc_sram */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -10568,7 +12384,32 @@ union cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq5_dbe_cmb0             : 1;  /**< Double-bit error for SQ_PT_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ5_DBE_CMB0. */
+	uint64_t pse_sq5_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ5_ECC_DBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ5_ECC_DBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ5_DBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_2.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_3.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10586,27 +12427,69 @@ union cvmx_pko_pse_sq5_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq5_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
-	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. */
-	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
-	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. */
-	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
-	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. */
-	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
-	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. */
-	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.pt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.rt_sram */
+	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_3.sq_fifo_sram */
+	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_2.sq_fifo_sram */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_0.sq_fifo_sram */
+	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp3_sram */
+	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp2_sram */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp1_sram */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp0_sram */
+	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts3_sram */
+	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts2_sram */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts1_sram */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts0_sram */
+	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std3_sram */
+	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std2_sram */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std1_sram */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std0_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sc_sram */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -10644,7 +12527,32 @@ union cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pse_sq5_sbe_cmb0             : 1;  /**< Single-bit error for SQ_PT_RAM. Throws PKO_INTSN_E::PKO_PSE_SQ5_SBE_CMB0. */
+	uint64_t pse_sq5_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ5_ECC_SBE_STS.
+                                                         To clear this bit, must clear bits in PKO_PSE_SQ5_ECC_SBE_STS.
+                                                         When this bit is set the corresponding interrupt is set.
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ5_SBE_CMB0.
+                                                         INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.pt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.rt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_0.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_1.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_2.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_3.sq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts0_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts1_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts2_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts3_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.wt_sram
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sc_sram */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10662,16 +12570,19 @@ union cvmx_pko_ptfx_status {
 	uint64_t u64;
 	struct cvmx_pko_ptfx_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_11_63               : 53;
-	uint64_t in_flight_cnt                : 6;  /**< This field returns the number of packets currently in-flight within PEB.  Useful both
-                                                         for reconfiguration (able to disable a FIFO when it is empty) and debugging */
+	uint64_t reserved_20_63               : 44;
+	uint64_t total_in_flight_cnt          : 8;  /**< This field returns the total number of packets currently in-flight within PEB.  Useful
+                                                         both for reconfiguration (able to disable a FIFO when it is empty) and debugging */
+	uint64_t in_flight_cnt                : 7;  /**< This field returns the number of packets currently in-flight within PEB for this link.
+                                                         Useful both for reconfiguration (able to disable a FIFO when it is empty) and debugging */
 	uint64_t mac_num                      : 5;  /**< The MAC assigned to the given PKO TX FIFO. A value of 0x1F means unassigned. These
                                                          registers values are derived automatically by the hardware from the
                                                          PKO_MAC(0..27)_CFG[FIFO_NUM] settings. */
 #else
 	uint64_t mac_num                      : 5;
-	uint64_t in_flight_cnt                : 6;
-	uint64_t reserved_11_63               : 53;
+	uint64_t in_flight_cnt                : 7;
+	uint64_t total_in_flight_cnt          : 8;
+	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
 	struct cvmx_pko_ptfx_status_s         cn78xx;
@@ -10710,7 +12621,22 @@ union cvmx_pko_ptgfx_cfg {
 	uint64_t u64;
 	struct cvmx_pko_ptgfx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_3_63                : 61;
+	uint64_t reserved_7_63                : 57;
+	uint64_t reset                        : 1;  /**< This bit will reset the address pointers for the FIFOs in this group.  This should
+                                                         only be performed when a PTGF is empty and the SIZE field is to be being changed. */
+	uint64_t rate                         : 3;  /**< Each PTGF can support up to 100Gbs. The total aggregate rate across all FIFOs
+                                                         (including the NULL) should NEVER exceed 250Gbs.
+                                                         This field represents the rate for each active FIFO in PEB, thus the calculation
+                                                         for throughput is a function of the SIZE field below and if the FIFO is assigned
+                                                         to a MAC in PKO_MACx_CFG.
+                                                         RATE: Throughput
+                                                         ----------------
+                                                         - 000:    6.25Gbs
+                                                         - 001:   12.5 Gbs
+                                                         - 010:   25   Gbs
+                                                         - 011:   50   Gbs
+                                                         - 100:  100   Gbs
+                                                         Note: 101-111 are illegal RATE values and should not be used. */
 	uint64_t size                         : 3;  /**< "The PKO supports up to 29 independent TX FIFOs where 0-27 are physical and 28 is
                                                          virtual. The FIFOs are grouped into 8 sets of four contiguously numbered queues
                                                          where each FIFO has a base storage amount of 2.5K bytes of buffering.
@@ -10732,17 +12658,26 @@ union cvmx_pko_ptgfx_cfg {
                                                          001 :     5.0k    0.0k    2.5k    2.5k
                                                          010 :     2.5k    2.5k    5.0k    0.0k
                                                          011 :     5.0k    0.0k    5.0k    0.0k
-                                                         1xx :    10.0k    0.0k    0.0k    0.0k
+                                                         100 :    10.0k    0.0k    0.0k    0.0k
+                                                         Note: 101-111 are illegal SIZE values and should not be used.
                                                          Note that when a FIFO is set to a size of 0K bytes that FIFO_NUM is no longer legal and
                                                          cannot be assigned to an active MAC. For example, for the set of FIFOs 8-11, if the
                                                          PKO_PTGF(2)_CFG.SIZE = 3'b100 then FIFO_NUMs 9, 10 and 11 are no longer valid. Only
                                                          FIFO_NUM = 8 is available from this set for assignment to a MAC because all of the
                                                          10 Kbytes of buffering was configured to FIFO#8.
                                                          FIFO_NUM = 28 is a virtual FIFO and is used exclusively to indicate the NULL FIFO. Packets
-                                                         targeting the NULL FIFO are dropped by the PKO and their buffers returned to the FPA." */
+                                                         targeting the NULL FIFO are dropped by the PKO and their buffers returned to the FPA. The
+                                                         SIZE field for PKO_PTGF(7) should always be set to zero"
+                                                         Modifications to this field require two writes.  The first write must assert
+                                                         PKO_PTGFx_CFG[RESET]
+                                                         to reset the address pointers for the FIFOS in this group.  The second write clears the
+                                                         RESET
+                                                         bit as well as configures the new SIZE values." */
 #else
 	uint64_t size                         : 3;
-	uint64_t reserved_3_63                : 61;
+	uint64_t rate                         : 3;
+	uint64_t reset                        : 1;
+	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
 	struct cvmx_pko_ptgfx_cfg_s           cn78xx;
@@ -12394,7 +14329,8 @@ union cvmx_pko_status {
 	uint64_t pdm_rdy                      : 1;  /**< PKO PDM block ready for configuration. */
 	uint64_t peb_rdy                      : 1;  /**< PKO PEB block ready for configuration. */
 	uint64_t csi_rdy                      : 1;  /**< PKO CSI block ready for configuration. */
-	uint64_t reserved_4_15                : 12;
+	uint64_t reserved_5_15                : 11;
+	uint64_t ncb_bist_status              : 1;  /**< PKO NCB block BIST status. 0 = BIST passed; 1 = BIST failed. */
 	uint64_t c2qlut_bist_status           : 1;  /**< PKO C2QLUT block BIST status. 0 = BIST passed;
                                                          1 = BIST failed. */
 	uint64_t pdm_bist_status              : 1;  /**< PKO PDM block BIST status. 0 = BIST passed; 1 = BIST failed. */
@@ -12405,7 +14341,8 @@ union cvmx_pko_status {
 	uint64_t peb_bist_status              : 1;
 	uint64_t pdm_bist_status              : 1;
 	uint64_t c2qlut_bist_status           : 1;
-	uint64_t reserved_4_15                : 12;
+	uint64_t ncb_bist_status              : 1;
+	uint64_t reserved_5_15                : 11;
 	uint64_t csi_rdy                      : 1;
 	uint64_t peb_rdy                      : 1;
 	uint64_t pdm_rdy                      : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 86aa674..03f830d 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -190,7 +190,7 @@ union cvmx_rst_boot {
 	uint64_t jtcsrdis                     : 1;  /**< When set, internal CSR access via JTAG TAP controller is disabled This field resets to 1
                                                          in Authentik mode, else 0. */
 	uint64_t ejtagdis                     : 1;  /**< When set, external EJTAG access is disabled This field resets to 1 in Authentik mode, else 0. */
-	uint64_t romen                        : 1;  /**< When set, Authentik/eMMC boot ROM is visible in the boot bus address space.  This field
+	uint64_t romen                        : 1;  /**< When set, Authentik/eMMC boot ROM is visible in the boot bus address space. This field
                                                          resets to 1 in an Authentik part or when booting from eMMC. Else, resets to 0. */
 	uint64_t ckill_ppdis                  : 1;  /**< When set, cores other than 0 are disabled during a CHIPKILL.  Writes have no effect when
                                                          RST_BOOT[CHIPKILL]=1. */
@@ -478,7 +478,7 @@ typedef union cvmx_rst_power_dbg cvmx_rst_power_dbg_t;
 /**
  * cvmx_rst_pp_power
  *
- * These bits should only be changed when the corresponding core is in reset (CIU3_PP_RST).
+ * These bits should only be changed while the corresponding PP is in reset (see CIU3_PP_RST).
  *
  */
 union cvmx_rst_pp_power {
@@ -486,10 +486,10 @@ union cvmx_rst_pp_power {
 	struct cvmx_rst_pp_power_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t gate                         : 48; /**< Powerdown Enable.  When both a bit and the corresponding CIU3_PP_RST bit are set, the core
-                                                         has voltage removed to save power.
-                                                         In typical operation these bits are setup during initialization and PP resets are
-                                                         controlled through CIU3_PP_RST. */
+	uint64_t gate                         : 48; /**< Powerdown enable. When both a bit and the corresponding CIU3_PP_RST bit are set, the core
+                                                         has voltage removed to save power. In typical operation these bits are setup during
+                                                         initialization and PP resets are controlled through CIU3_PP_RST. These bits may only be
+                                                         changed when the corresponding core is in reset using CIU3_PP_RST. */
 #else
 	uint64_t gate                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -521,7 +521,7 @@ union cvmx_rst_soft_prstx {
                                                          If the RST_CTL*[HOST_MODE] = 0, SOFT_PRST resets to 0.
                                                          If the RST_CTL*[HOST_MODE] = 1, SOFT_PRST resets to 1.
                                                          When CN78XX is configured to drive PERST*_L (i.e.
-                                                         RST_CTL0/1[RST_DRV] = 1), this controls the output value on PERST*_L. */
+                                                         RST_CTL(0..3)[RST_DRV] = 1), this controls the output value on PERST*_L. */
 #else
 	uint64_t soft_prst                    : 1;
 	uint64_t reserved_1_63                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 7a614e1..4f9cb37 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -284,39 +284,12 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 #define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
 static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 {
-	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000003E00ull;
-			break;
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000013E00ull;
-			break;
-	}
-	cvmx_warn("CVMX_SLI_MAC_NUMBER not supported on this chip\n");
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+		cvmx_warn("CVMX_SLI_MAC_NUMBER not supported on this chip\n");
 	return 0x0000000000003E00ull;
 }
 #else
-#define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
-static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
-{
-	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000003E00ull;
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000013E00ull;
-	}
-	return 0x0000000000003E00ull;
-}
+#define CVMX_SLI_MAC_NUMBER (0x0000000000003E00ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MEM_ACCESS_CTL CVMX_SLI_MEM_ACCESS_CTL_FUNC()
@@ -1869,7 +1842,7 @@ union cvmx_sli_ctl_status {
 	struct cvmx_sli_ctl_status_cn61xx     cn66xx;
 	struct cvmx_sli_ctl_status_cn63xx     cn68xx;
 	struct cvmx_sli_ctl_status_cn63xx     cn68xxp1;
-	struct cvmx_sli_ctl_status_cn61xx     cn70xx;
+	struct cvmx_sli_ctl_status_cn63xx     cn70xx;
 	struct cvmx_sli_ctl_status_s          cn78xx;
 	struct cvmx_sli_ctl_status_cn61xx     cnf71xx;
 };
@@ -7013,7 +6986,6 @@ typedef union cvmx_sli_pkt_int cvmx_sli_pkt_int_t;
 /**
  * cvmx_sli_pkt_int_levels
  *
- * 0x90F0 reserved SLI_PKT_PCIE_PORT2
  * SLI_PKT_INT_LEVELS = SLI's Packet Interrupt Levels
  * Output packet interrupt levels.
  */
@@ -7426,9 +7398,6 @@ typedef union cvmx_sli_pkt_pcie_port cvmx_sli_pkt_pcie_port_t;
 /**
  * cvmx_sli_pkt_port_in_rst
  *
- * 91c0 reserved
- * 91d0 reserved
- * 91e0 reserved
  * SLI_PKT_PORT_IN_RST = SLI Packet Port In Reset
  * Vector bits related to ring-port for ones that are reset.
  */
-- 
2.6.2

