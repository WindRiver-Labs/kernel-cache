From b2e41f931600a0470f61670fbc0c0746996b43c1 Mon Sep 17 00:00:00 2001
From: Emil <egoranov@caviumnetworks.com>
Date: Sat, 22 Feb 2014 13:46:59 -0800
Subject: [PATCH 550/974] updated only the part compiled for Linux

[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bch.c | 43 +++++++++++++++++++++++++++-
 1 file changed, 42 insertions(+), 1 deletion(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index c90a78d..5e2b3f4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -53,7 +53,11 @@
 # include <asm/octeon/cvmx-fpa1.h>
 # include <asm/octeon/cvmx-helper-fpa.h>
 # include <asm/octeon/cvmx-cmd-queue.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
 #elif defined(CVMX_BUILD_FOR_UBOOT)
+
 # include <common.h>
 # include <asm/arch/cvmx.h>
 # include <asm/arch/cvmx-bch-defs.h>
@@ -86,6 +90,7 @@ CVMX_SHARED cvmx_bch_app_config_t bch_config = {
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 extern int cvm_oct_mem_fill_fpa(int pool, int elements);
 extern int cvm_oct_alloc_fpa_pool(int pool, int size);
+static uint8_t *bounce_buff;
 #endif
 
 /**
@@ -103,6 +108,7 @@ int cvmx_bch_initialize(void)
 
 	/* Initialize FPA pool for BCH pool buffers */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	int i;
 	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
 	bch_pool_size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE;
 
@@ -115,7 +121,11 @@ int cvmx_bch_initialize(void)
 		pr_err("cvm_oct_alloc_fpa_pool(%d, %lld)\n", bch_pool, bch_pool_size);
 		return -ENOMEM;
 	}
-	cvm_oct_mem_fill_fpa(bch_pool, 128);
+
+	for (i = 0; i < 16; i++) {
+		cvmx_fpa1_free(kmalloc(bch_pool_size, GFP_KERNEL), bch_pool, 0);
+	}
+	bounce_buff = cvmx_fpa1_alloc(bch_pool);
 #else
 	bch_pool = (int)cvmx_fpa_get_bch_pool();
 	bch_pool_size = cvmx_fpa_get_bch_pool_block_size();
@@ -170,6 +180,7 @@ EXPORT_SYMBOL(cvmx_bch_initialize);
 int cvmx_bch_shutdown(void)
 {
 	cvmx_bch_ctl_t bch_ctl;
+	int bch_pool;
 
 	debug("%s: ENTER\n", __func__);
 	bch_ctl.u64 = cvmx_read_csr(CVMX_BCH_CTL);
@@ -177,8 +188,26 @@ int cvmx_bch_shutdown(void)
 	cvmx_write_csr(CVMX_BCH_CTL, bch_ctl.u64);
 	cvmx_wait(4);
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
+#else
+	bch_pool = (int)cvmx_fpa_get_bch_pool();
+#endif
 	cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_BCH);
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	/* FIXME: BCH cleanup in SE : AJ */
+	{
+		int i;
+		for (i = 0; i < 16; i++) {
+			kfree(cvmx_fpa1_alloc(bch_pool));
+		}
+		cvmx_fpa1_free(bounce_buff, bch_pool, 0);
+	}
+#else
+	cvmx_fpa_shutdown_pool(bch_pool);
+#endif
+	/* AJ: Fix for FPA3 */
 	return 0;
 }
 EXPORT_SYMBOL(cvmx_bch_shutdown);
@@ -228,6 +257,14 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 
 	debug("%s(%p, %u, %u, %p, %p) ENTRY\n", __func__, block, block_size,
 	      ecc_level, ecc, response);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	/* there was a problem when the first argument is used directly
+	 * despite of the fact it was 8-byte aligned (maybe not proper
+	 * cvmx_prt_to_phys), so we copy data to dedicated 'bounce_buff'
+	 * and set command.s.iword.prt to cvmx_ptr_to_phys((void *)bounce_buff)
+	 */
+	memcpy(bounce_buff, block, block_size);
+#endif
 	memset(&result, 0, sizeof(result));
 	memset(&command, 0, sizeof(command));
 	command.s.cword.ecc_gen = CVMX_BCH_INST_ECC_GENERATION;
@@ -235,7 +272,11 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 	command.s.cword.size = block_size;
 
 	command.s.oword.ptr = cvmx_ptr_to_phys(ecc);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	command.s.iword.ptr = cvmx_ptr_to_phys((void *)bounce_buff);
+#else
 	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);
+#endif
 	command.s.resp.ptr = cvmx_ptr_to_phys((void *)response);
 	debug("Command: cword: 0x%llx, oword: 0x%llx, iword: 0x%llx, resp: 0x%llx\n",
 	      command.u64[0], command.u64[1], command.u64[2], command.u64[3]);
-- 
2.6.2

