From f455d5830769676178a3695062979d3ea16dc7f6 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 19 Feb 2014 13:46:59 -0800
Subject: [PATCH 544/974] MIPS: OCTEON: Update S.E. files to r98762

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c | 303 +++++++++------------
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |   2 +
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |  68 ++++-
 .../cavium-octeon/executive/cvmx-helper-util.c     |   4 +
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |  32 +++
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |  21 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |  70 ++---
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |  19 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |   8 +-
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |  12 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  58 ++++
 arch/mips/include/asm/octeon/cvmx-helper.h         |   4 +-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  89 +++---
 arch/mips/include/asm/octeon/cvmx-mpi-defs.h       |  28 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |  35 +++
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  12 +-
 arch/mips/include/asm/octeon/cvmx-pko3.h           |  58 +++-
 arch/mips/include/asm/octeon/cvmx-qlm.h            |   4 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |  79 +++---
 arch/mips/include/asm/octeon/cvmx-wqe.h            |  30 +-
 20 files changed, 577 insertions(+), 359 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index e1626f5..191ec8e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -83,11 +83,13 @@ int __cvmx_helper_bgx_enumerate(int xiface)
 	/* FIXME: Check here if SGMII is a MIX interface */
 		return 4;
 	} else if (mode == CVMX_QLM_MODE_XAUI
-		   || mode == CVMX_QLM_MODE_XLAUI) {
+		   || mode == CVMX_QLM_MODE_XLAUI
+		   || mode == CVMX_QLM_MODE_40G_KR4) {
 		return 1;
 	} else if (mode == CVMX_QLM_MODE_RXAUI) {
 		return 2;
-	} else if (mode == CVMX_QLM_MODE_XFI) {
+	} else if (mode == CVMX_QLM_MODE_XFI
+		   || mode == CVMX_QLM_MODE_10G_KR) {
 		return 4;
 	} else
 		return 0;
@@ -115,6 +117,7 @@ static void __cvmx_bgx_common_init(int xiface)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
+	int lane_to_sds = 0;
 
 	num_ports = cvmx_helper_ports_on_interface(xiface);
 	mode = cvmx_helper_interface_get_mode(xiface);
@@ -122,18 +125,24 @@ static void __cvmx_bgx_common_init(int xiface)
 	switch (mode) {
 	case CVMX_HELPER_INTERFACE_MODE_SGMII:
 		lmac_type = 0;
+		lane_to_sds = 1;
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
 		lmac_type = 1;
+		lane_to_sds = 0xe4;
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		lmac_type = 2;
 		break;
-	case CVMX_HELPER_INTERFACE_MODE_XLAUI:
-		lmac_type = 4;
-		break;
 	case CVMX_HELPER_INTERFACE_MODE_XFI:
+	case CVMX_HELPER_INTERFACE_MODE_10G_KR:
 		lmac_type = 3;
+		lane_to_sds = 1;
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_XLAUI:
+	case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
+		lmac_type = 4;
+		lane_to_sds = 0xe4;
 		break;
 	default:
 		break;
@@ -145,10 +154,9 @@ static void __cvmx_bgx_common_init(int xiface)
 			cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
 		cmr_config.s.enable = 0;
 		cmr_config.s.lmac_type = lmac_type;
-		cmr_config.s.lane_to_sds = ((mode == CVMX_HELPER_INTERFACE_MODE_SGMII
-					     || mode == CVMX_HELPER_INTERFACE_MODE_XFI)
-					     ? index : ((mode == CVMX_HELPER_INTERFACE_MODE_RXAUI)
-						     ? (index ? 0xe : 4) : 0xe4));
+		cmr_config.s.lane_to_sds = ((lane_to_sds == 1) ? index
+					     : ((lane_to_sds == 0) 
+						 ? (index ? 0xe : 4) : lane_to_sds));
 		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
 	}
 
@@ -186,20 +194,6 @@ static void __cvmx_bgx_common_init(int xiface)
 		/* set rx back pressure (bp_on) on value */
 		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_BP_ON(index, interface), bgx_rx_bp_on.u64);
 	}                                                   
-#if 0
-	/* FIXME for MIX configuration */
-	/* Check if interface 0 or 1 must be routed to the mix */
-	if ((interface == 0 && MUX_78XX_IFACE0) ||
-	    (interface == 1 && MUX_78XX_IFACE1))
-		val = 1;
-	else
-		val = 0;
-
-	bgx_cmr_global_config.u64 = 0;
-	bgx_cmr_global_config.s.pmux_sds_sel = val;
-	cvmx_write_csr(CVMX_BGXX_CMR_GLOBAL_CONFIG(interface),
-		       bgx_cmr_global_config.u64);
-#endif
 }
 
 /**
@@ -773,11 +767,17 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	int interface = xi.interface;
 	int node = xi.node;
 	int use_auto_neg = 0;
-	int qlm = cvmx_qlm_interface(xiface);
-	int lane;
+	int use_training = 0;
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
+	if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
+	    || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4) {
+		use_training = 1;
+		/* FIXME: disabled as it currently doesn't work */
+		use_auto_neg = 0;
+	}
+
 	/* NOTE: This code was moved first, out of order compared to the HRM
 	   because the RESET causes all SPU registers to loose their value */
 	/* 4. Next, bring up the SMU/SPU and the BGX reconciliation layer logic: */
@@ -797,63 +797,63 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 			cvmx_dprintf("BGX%d: SPU stuck in reset\n", interface);
 			return -1;
 		}
-	}
 
-	/* 1. Write BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] to 0,
-	      BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 1 and
-	      BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1. */
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-	cmr_config.s.enable = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+		/* 1. Write BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] to 0,
+		      BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 1 and
+		      BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1. */
+		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+		cmr_config.s.enable = 0;
+		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
 
-	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
-	spu_control1.s.lo_pwr = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+		spu_control1.s.lo_pwr = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
 
-	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
-	spu_misc_control.s.rx_packet_dis = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+		spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+		spu_misc_control.s.rx_packet_dis = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
 
-	/* 2. At this point, it may be appropriate to disable all BGX and SMU/SPU
-	      interrupts, as a number of them will occur during bring-up of the Link.
-	      - zero BGX(0..5)_SMU(0..3)_RX_INT
-	      - zero BGX(0..5)_SMU(0..3)_TX_INT
-	      - zero BGX(0..5)_SPU(0..3)_INT */
-	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface),
+		/* 2. At this point, it may be appropriate to disable all BGX and SMU/SPU
+		    interrupts, as a number of them will occur during bring-up of the Link.
+		    - zero BGX(0..5)_SMU(0..3)_RX_INT
+		    - zero BGX(0..5)_SMU(0..3)_TX_INT
+		    - zero BGX(0..5)_SPU(0..3)_INT */
+		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface),
 			cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_INT(index, interface)));
-	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface),
+		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface),
 			cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_INT(index, interface)));
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface),
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface),
 			cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface)));
 
-	/* 3. Configure the BGX LMAC. */
-	/* 3a. Configure the LMAC type (40GBASE-R/10GBASE-R/RXAUI/XAUI) and
-	     SerDes selection in the BGX(0..5)_CMR(0..3)_CONFIG register, but keep
-	     the ENABLE, DATA_PKT_TX_EN and DATA_PKT_RX_EN bits clear. */
-	/* Already done in bgx_setup_one_time */
+		/* 3. Configure the BGX LMAC. */
+		/* 3a. Configure the LMAC type (40GBASE-R/10GBASE-R/RXAUI/XAUI) and
+		     SerDes selection in the BGX(0..5)_CMR(0..3)_CONFIG register, but keep
+		     the ENABLE, DATA_PKT_TX_EN and DATA_PKT_RX_EN bits clear. */
+		/* Already done in bgx_setup_one_time */
 
-	/* 3b. Write BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 1 and
-	     BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1. */
-	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
-	spu_control1.s.lo_pwr = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+		/* 3b. Write BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 1 and
+		     BGX(0..5)_SPU(0..3)_MISC_CONTROL[RX_PACKET_DIS] = 1. */
+		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+		spu_control1.s.lo_pwr = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
 
-	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
-	spu_misc_control.s.rx_packet_dis = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
+		spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+		spu_misc_control.s.rx_packet_dis = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
 
-	/* 3c. Initialize the selected SerDes lane(s) in the QLM. See Section
-	       28.1.2.2 in the GSER chapter. */
-	/* Already done in QLM setup */
+		/* 3c. Initialize the selected SerDes lane(s) in the QLM. See Section
+		      28.1.2.2 in the GSER chapter. */
+		/* Already done in QLM setup */
 
-	/* 3d. For 10GBASE-KR or 40GBASE-KR, enable link training by writing
-	       BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] = 1. */
-	if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
-		cvmx_bgxx_spux_br_pmd_control_t spu_br_pmd_control;
-		spu_br_pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
-		spu_br_pmd_control.s.train_en = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), spu_br_pmd_control.u64);
+		/* 3d. For 10GBASE-KR or 40GBASE-KR, enable link training by writing
+		     BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] = 1. */
+		if (use_training) {
+			cvmx_bgxx_spux_br_pmd_control_t spu_br_pmd_control;
+			spu_br_pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
+			spu_br_pmd_control.s.train_en = 1;
+			cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), spu_br_pmd_control.u64);
 
+		}
 	}
 	
 	/* 3e. Program all other relevant BGX configuration while
@@ -866,53 +866,53 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 
 	/* 3f. If Forward Error Correction is desired for 10GBASE-R or 40GBASE-R,
 	       enable it by writing BGX(0..5)_SPU(0..3)_FEC_CONTROL[FEC_EN] = 1. */
-	if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
+	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
+		/* FEC is optional for 10GBASE-KR, 40GBASE-KR4, and XLAUI. We're going
+		to disable it by default */
 		spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
-		spu_fec_control.s.fec_en = 1;
+		spu_fec_control.s.fec_en = 0;
 		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), spu_fec_control.u64);
 
-	}
-
-	/* 3g. If Auto-Negotiation is desired, configure and enable
-	       Auto-Negotiation as described in Section 33.6.2. */
-	spu_an_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface));
-	spu_an_control.s.an_en = use_auto_neg;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface), spu_an_control.u64);
-
-	spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_FEC_CONTROL(index, interface));
-	spu_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(index, interface));
-	spu_an_adv.s.fec_req = spu_fec_control.s.fec_en;
-	spu_an_adv.s.fec_able = 1;
-	spu_an_adv.s.a100g_cr10 = 0;
-	spu_an_adv.s.a40g_cr4 = (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI) ;
-	spu_an_adv.s.a40g_kr4 = (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI) ;
-	spu_an_adv.s.a10g_kr = (mode == CVMX_HELPER_INTERFACE_MODE_XFI) ;
-	spu_an_adv.s.a10g_kx4 = (mode == CVMX_HELPER_INTERFACE_MODE_XFI) ;
-	spu_an_adv.s.a1g_kx = 0;
-	spu_an_adv.s.rf = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(index, interface), spu_an_adv.u64);
-
-	/* 3. Set BGX(0..5)_SPU_DBG_CONTROL[AN_ARB_LINK_CHK_EN] = 1. */
-	spu_dbg_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(interface));
-	spu_dbg_control.s.an_arb_link_chk_en = use_auto_neg;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(interface), spu_dbg_control.u64);
-
-	/* 4. Execute the link bring-up sequence in Section 33.6.3. */
-
-	/* 5. If the auto-negotiation protocol is successful,
-	   BGX(0..5)_SPU(0..3)_AN_ADV[AN_COMPLETE] is set along with
-	   BGX(0..5)_SPU(0..3)_INT[AN_COMPLETE] when the link is up. */
+		/* 3g. If Auto-Negotiation is desired, configure and enable
+		      Auto-Negotiation as described in Section 33.6.2. */
+		spu_an_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface));
+		spu_an_control.s.an_en = use_auto_neg;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface), spu_an_control.u64);
+
+		spu_fec_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_FEC_CONTROL(index, interface));
+		spu_an_adv.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(index, interface));
+		spu_an_adv.s.fec_req = spu_fec_control.s.fec_en;
+		spu_an_adv.s.fec_able = 1;
+		spu_an_adv.s.a100g_cr10 = 0;
+		spu_an_adv.s.a40g_cr4 = 0;
+		spu_an_adv.s.a40g_kr4 = (mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4) ;
+		spu_an_adv.s.a10g_kr = (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR) ;
+		spu_an_adv.s.a10g_kx4 = 0;
+		spu_an_adv.s.a1g_kx = 0;
+		spu_an_adv.s.rf = 0;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_AN_ADV(index, interface), spu_an_adv.u64);
+
+		/* 3. Set BGX(0..5)_SPU_DBG_CONTROL[AN_ARB_LINK_CHK_EN] = 1. */
+		spu_dbg_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(interface));
+		spu_dbg_control.s.an_arb_link_chk_en = use_auto_neg;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(interface), spu_dbg_control.u64);
+
+		/* 4. Execute the link bring-up sequence in Section 33.6.3. */
+
+		/* 5. If the auto-negotiation protocol is successful,
+		    BGX(0..5)_SPU(0..3)_AN_ADV[AN_COMPLETE] is set along with
+		    BGX(0..5)_SPU(0..3)_INT[AN_COMPLETE] when the link is up. */
 	
+		/* 3h. Set BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 1 and
+		    BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 0 to enable the LMAC. */
+		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+		cmr_config.s.enable = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
 
-	/* 3h. Set BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 1 and
-	      BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 0 to enable the LMAC. */
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-	cmr_config.s.enable = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
-
-	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
-	spu_control1.s.lo_pwr = 0;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface));
+		spu_control1.s.lo_pwr = 0;
+		cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, interface), spu_control1.u64);
+	}
 
 	/* 4b. Set the polarity and lane swapping of the QLM SerDes. Refer to
 	   Section 33.4.1, BGX(0..5)_SPU(0..3)_MISC_CONTROL[XOR_TXPLRT,XOR_RXPLRT]
@@ -930,56 +930,9 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	smu_tx_ctl.s.uni_en = 0;
 	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface), smu_tx_ctl.u64);
 
-	/* Errata #20844
-	  1) After the link first comes up write the following
-	     register on each lane to prevent the application logic
-	     from stomping on the Coast inputs. This is a one time write,
-	     or if you prefer you could put it in the link up loop and
-	     write it every time the link comes up.
-	  1a) Then write GSER(0..13)_LANE(0..3)_PCS_CTLIFC_2
-	     Set CTLIFC_OVRRD_REQ (later)
-	     Set CFG_RX_CDR_COAST_REQ_OVRRD_EN
-	        Its not clear if #1 and #1a can be combined, lets try it
-	        this way first. */
-	for (lane=0; lane<4; lane++)
-	{
-		cvmx_gserx_lanex_pcs_ctlifc_2_t ctlifc;
-		ctlifc.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_PCS_CTLIFC_2(lane, qlm));
-		ctlifc.s.cfg_rx_cdr_coast_req_ovrrd_en = 1;
-		cvmx_write_csr_node(node, CVMX_GSERX_LANEX_PCS_CTLIFC_2(lane, qlm), ctlifc.u64);
-	}
-
 	return 0;
 }
 
-static void __link_errata_20844(int qlm, int node)
-{
-	int lane;
-	cvmx_gserx_lanex_rx_misc_ovrrd_t misc_ovrrd;
-	cvmx_gserx_lanex_pcs_ctlifc_2_t ctlifc_2;
-
-	/* Errata #20844
-	  2) When a link down event is registered, write the following
-	     register across all lanes twice. */
-	for (lane=0; lane<4; lane++) {
-        	misc_ovrrd.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm));
-        	misc_ovrrd.s.cfg_rx_eie_det_ovrrd_en = 1;
-        	misc_ovrrd.s.cfg_rx_eie_det_ovrrd_val = 0;
-        	cvmx_write_csr_node(node, CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm), misc_ovrrd.u64);
-	}
-
-	for (lane=0; lane<4; lane++) {
-        	misc_ovrrd.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm));
-        	misc_ovrrd.s.cfg_rx_eie_det_ovrrd_en = 1;
-        	misc_ovrrd.s.cfg_rx_eie_det_ovrrd_val = 1;
-        	cvmx_write_csr_node(node, CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm), misc_ovrrd.u64);
-        	ctlifc_2.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_PCS_CTLIFC_2(lane, qlm));
-        	ctlifc_2.s.ctlifc_ovrrd_req = 1;
-        	cvmx_write_csr_node(node, CVMX_GSERX_LANEX_PCS_CTLIFC_2(lane, qlm), ctlifc_2.u64);
-	}
-}
-
-
 static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 {
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
@@ -990,18 +943,20 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 	cvmx_bgxx_spux_int_t spu_int;
 	cvmx_bgxx_spux_misc_control_t spu_misc_control;
 	cvmx_helper_interface_mode_t mode;
-	int qlm = cvmx_qlm_interface(xiface);
+	int use_training = 0;
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
+	if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4)
+		use_training = 1;
+
 	/* Disable packet reception */
 	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
 	spu_misc_control.s.rx_packet_dis = 1;
 	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface), spu_misc_control.u64);
 
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
-		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
-
+		if (use_training) {
 			spu_int.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface));
 			if (!spu_int.s.training_done) {
 				cvmx_bgxx_spux_br_pmd_control_t pmd_control;
@@ -1018,7 +973,7 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 				pmd_control.s.train_restart = 1;
 				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), pmd_control.u64);
 
-				//cvmx_dprintf("Restarting link training failed\n");
+				/*cvmx_dprintf("Restarting link training\n"); */
 				return -1;
 			}
 		}
@@ -1029,19 +984,21 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 			return -1;
 		}
 
-		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
+		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI
+		    || mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
+		    || mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
+		    || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4) {
 			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BR_STATUS1(index, interface),
-					  cvmx_bgxx_spux_br_status1_t, blk_lock, ==, 1, 10000))
+					  cvmx_bgxx_spux_br_status1_t, blk_lock, ==, 1, 10000)) {
 				cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R PCS block not locked\n", node, interface, index);
-				 __link_errata_20844(qlm, node);
                 		return -1;
+			}
 		} else {
 			/* (5) Check to make sure that the link appears up and stable. */
 			/* Wait for PCS to be aligned */
 			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BX_STATUS(index, interface),
 				  cvmx_bgxx_spux_bx_status_t, alignd, ==, 1, 10000)) {
 				cvmx_dprintf("ERROR: %d:BGX%d:%d: PCS not aligned\n", node, interface, index);
-				 __link_errata_20844(qlm, node);
 				return -1;
 			}
 		}
@@ -1056,7 +1013,7 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive fault, need to retry\n",
 					node, interface, index);
 			
-			if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
+			if (use_training) {
 				cvmx_bgxx_spux_br_pmd_control_t pmd_control;
 				spu_int.u64 = 0;
 				spu_int.s.training_failure = 1;
@@ -1069,6 +1026,7 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 				pmd_control.s.train_restart = 1;
 				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface), pmd_control.u64);
 			}
+			/*cvmx_dprintf("training restarting\n"); */
 			return -1;
 		}
 
@@ -1122,7 +1080,6 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 
 int __cvmx_helper_bgx_xaui_enable(int xiface)
 {
-	//cvmx_bgxx_smux_tx_append_t smu_tx_append;
 	cvmx_bgxx_smux_tx_thresh_t smu_tx_thresh;
 	cvmx_bgxx_cmrx_config_t cmr_config;
 	int index;
@@ -1142,7 +1099,7 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 			return res;
 		}
 		smu_tx_thresh.u64 = 0;
-		if (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
+		if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
 		    || mode == CVMX_HELPER_INTERFACE_MODE_XFI)
 			smu_tx_thresh.s.cnt = 0x100;
 		else if (num_ports == 2)
@@ -1190,6 +1147,8 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 		switch(mode) {
 		case CVMX_HELPER_INTERFACE_MODE_XFI:
 		case CVMX_HELPER_INTERFACE_MODE_XLAUI:
+		case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+		case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 			/* Using 64b66b symbol encoding */
 			speed = (speed * 64 + 33) / 66;
 			break;
@@ -1203,8 +1162,10 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 	} else {
 		int res;
 		res = __cvmx_helper_bgx_xaui_link_init(index, xiface);
-		if (res == -1)
-			cvmx_dprintf("Failed to get BGX(%d,%d) link\n", interface, index);
+		if (res == -1) {
+			/*cvmx_dprintf("Failed to get BGX(%d,%d) link\n", interface, index); */
+			return result;
+		}
 	}
 
 	return result;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index d0275a5..c421678 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -497,6 +497,8 @@ void cvmx_helper_cfg_set_jabber_and_frame_max()
 			case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 			case CVMX_HELPER_INTERFACE_MODE_XLAUI:
 			case CVMX_HELPER_INTERFACE_MODE_XFI:
+			case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+			case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 				for (port = 0; port < num_ports; port++) {
 					cvmx_pki_set_max_frm_len(node, port, -1);
 					cvmx_write_csr(CVMX_BGXX_SMUX_RX_JABBER(port, interface), 65535);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 0ca9e46..853203d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -996,6 +996,45 @@ int __cvmx_helper_pko3_init_global(unsigned int node, uint16_t gaura)
 }
 EXPORT_SYMBOL(__cvmx_helper_pko3_init_global);
 
+#ifdef	__PKO_HW_DEBUG
+#define	CVMX_DUMP_REGX(reg) cvmx_dprintf("%s=%#llx\n",#reg,(long long)cvmx_read_csr(reg))
+#define	CVMX_DUMP_REGD(reg) cvmx_dprintf("%s=%lld.\n",#reg,(long long)cvmx_read_csr(reg))
+/*
+ * function for debugging PKO reconfiguration
+ */
+void cvmx_fpa3_aura_dump_regs(unsigned node, uint16_t aura)
+	{
+	int pool_num =
+		cvmx_read_csr_node(node,CVMX_FPA_AURAX_POOL(aura));
+
+	CVMX_DUMP_REGX(CVMX_FPA_AURAX_POOL(aura));
+	CVMX_DUMP_REGX(CVMX_FPA_POOLX_CFG(pool_num));
+	CVMX_DUMP_REGX(CVMX_FPA_POOLX_OP_PC(pool_num));
+	CVMX_DUMP_REGX(CVMX_FPA_POOLX_INT(pool_num));
+	CVMX_DUMP_REGD(CVMX_FPA_POOLX_AVAILABLE(pool_num));
+	CVMX_DUMP_REGD(CVMX_FPA_POOLX_THRESHOLD(pool_num));
+	CVMX_DUMP_REGX(CVMX_FPA_AURAX_CFG(aura));
+	CVMX_DUMP_REGX(CVMX_FPA_AURAX_INT(aura));
+	CVMX_DUMP_REGD(CVMX_FPA_AURAX_CNT(aura));
+	CVMX_DUMP_REGD(CVMX_FPA_AURAX_CNT_LIMIT(aura));
+	CVMX_DUMP_REGX(CVMX_FPA_AURAX_CNT_THRESHOLD(aura));
+	CVMX_DUMP_REGX(CVMX_FPA_AURAX_CNT_LEVELS(aura));
+	CVMX_DUMP_REGX(CVMX_FPA_AURAX_POOL_LEVELS(aura));
+
+	}
+
+void cvmx_pko3_dump_regs(unsigned node)
+{
+	(void) node;
+	CVMX_DUMP_REGX( CVMX_PKO_NCB_INT );
+	CVMX_DUMP_REGX( CVMX_PKO_PEB_ERR_INT );
+	CVMX_DUMP_REGX( CVMX_PKO_PDM_ECC_DBE_STS_CMB0 );
+	CVMX_DUMP_REGX( CVMX_PKO_PDM_ECC_SBE_STS_CMB0 );
+	CVMX_DUMP_REGX( CVMX_PKO_PEB_ECC_DBE_STS0 );
+	CVMX_DUMP_REGX( CVMX_PKO_PEB_ECC_DBE_STS_CMB0 );
+}
+#endif	/* __PKO_HW_DEBUG */
+
 /**
  * Global initialization for PKO3
  *
@@ -1008,34 +1047,42 @@ int cvmx_helper_pko3_init_global(unsigned int node)
 {
 	void *ptr;
 	int res = -1;
-	int16_t aura = -1;
+	int16_t gaura, aura = -1, anode = node;
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	/* Allocate memory required by PKO3 */
 	res = __cvmx_pko3_config_memory(node);
+#endif
 	if(res < 0) {
 		cvmx_dprintf("%s: ERROR: PKO3 memory allocation error\n",
 			__FUNCTION__);
 		return res;
 	}
-	aura = res;
-#endif
+
+	gaura = res;
+	aura = res & ((1 << 10)-1);
+	anode = res >> 10;
+
 	/* Exercise the FPA to make sure the AURA is functional */
-	ptr = cvmx_fpa3_alloc_aura(node, aura);	/* FIXME: aura is global here ? */
+	ptr = cvmx_fpa3_alloc_aura(anode, aura);
 
 	if (ptr == NULL )
 		res = -1;
 	else {
-		cvmx_fpa3_free_aura(ptr, node, aura, 0);
+		cvmx_fpa3_free_aura(ptr, anode, aura, 0);
 		res = 0;
 	}
 
 	if (res < 0) {
-		cvmx_dprintf("ERROR: %s: FPA failure AURA=%#x\n", __func__, aura);
+		cvmx_dprintf("ERROR: %s: FPA failure AURA=%u:%#x\n",
+			__func__, anode, aura);
 		return -1;
 	}
 
-	res = __cvmx_helper_pko3_init_global(node, aura);
+	res = __cvmx_helper_pko3_init_global(node, gaura);
+
+	if (res < 0)
+		cvmx_dprintf("ERROR: %s: failed to start PPKO\n",__func__);
 
 	return res;
 }
@@ -1178,10 +1225,11 @@ int cvmx_helper_pko3_shutdown(unsigned int node)
 	 /* destroy NULL interface here, only PKO knows about it */
 	cvmx_helper_pko3_shut_interface(cvmx_helper_node_interface_to_xiface(node, __CVMX_XIFACE_NULL));
 
-#if 0
-	//XXX- this seems to cause issue on HW
-	// At least the error code differs from expected
+#ifdef	__PKO_DQ_CLOSE_ERRATA_FIXED
 	/* Check that all DQs are closed */
+	/* this seems to cause issue on HW:
+	 * the error code differs from expected
+	 */
 	for(dq =0; dq < (1<<10); dq++) {
 		res = cvmx_pko3_dq_close(node, dq);
 		if (res != 0) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index ce7cff3..4dc4cad 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -217,6 +217,10 @@ const char *cvmx_helper_interface_mode_to_string(cvmx_helper_interface_mode_t mo
 		return "XLAUI";
 	case CVMX_HELPER_INTERFACE_MODE_XFI:
 		return "XFI";
+	case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
+		return "40G_KR4";
+	case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+		return "10G_KR";
 	}
 	return "UNKNOWN";
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index 89596e9..349b230 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -314,6 +314,26 @@ static const struct iface_ops iface_ops_bgx_xfi = {
 	.loopback	= __cvmx_helper_bgx_xaui_configure_loopback,
 };
 
+static const struct iface_ops iface_ops_bgx_10G_KR = {
+	.mode		= CVMX_HELPER_INTERFACE_MODE_10G_KR,
+	.enumerate	= __cvmx_helper_bgx_enumerate,
+	.probe		= __cvmx_helper_bgx_probe,
+	.enable		= __cvmx_helper_bgx_xaui_enable,
+	.link_get	= __cvmx_helper_bgx_xaui_link_get,
+	.link_set	= __cvmx_helper_bgx_xaui_link_set,
+	.loopback	= __cvmx_helper_bgx_xaui_configure_loopback,
+};
+
+static const struct iface_ops iface_ops_bgx_40G_KR4 = {
+	.mode		= CVMX_HELPER_INTERFACE_MODE_40G_KR4,
+	.enumerate	= __cvmx_helper_bgx_enumerate,
+	.probe		= __cvmx_helper_bgx_probe,
+	.enable		= __cvmx_helper_bgx_xaui_enable,
+	.link_get	= __cvmx_helper_bgx_xaui_link_get,
+	.link_set	= __cvmx_helper_bgx_xaui_link_set,
+	.loopback	= __cvmx_helper_bgx_xaui_configure_loopback,
+};
+
 /**
  * @INTERNAL
  * This structure specifies the interface methods used by interfaces
@@ -759,6 +779,10 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn78xx(int xiface)
 			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_xlaui;
 		else if (qlm_mode == CVMX_QLM_MODE_XFI)
 			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_xfi;
+		else if (qlm_mode == CVMX_QLM_MODE_10G_KR)
+			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_10G_KR;
+		else if (qlm_mode == CVMX_QLM_MODE_40G_KR4)
+			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_40G_KR4;
 		else if (qlm_mode == CVMX_QLM_MODE_RXAUI)
 			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_rxaui;
 		else
@@ -1187,6 +1211,8 @@ int cvmx_helper_interface_probe(int xiface)
 	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 	case CVMX_HELPER_INTERFACE_MODE_XLAUI:
 	case CVMX_HELPER_INTERFACE_MODE_XFI:
+	case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+	case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 		has_fcs = 1;
 		padding = CVMX_PKO_PADDING_60;
 		break;
@@ -1276,6 +1302,8 @@ static int __cvmx_helper_global_setup_backpressure(void)
 			case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 			case CVMX_HELPER_INTERFACE_MODE_XLAUI:
 			case CVMX_HELPER_INTERFACE_MODE_XFI:
+			case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+			case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 				break;
 			case CVMX_HELPER_INTERFACE_MODE_RGMII:
 			case CVMX_HELPER_INTERFACE_MODE_GMII:
@@ -1758,6 +1786,8 @@ static int __cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
 		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		case CVMX_HELPER_INTERFACE_MODE_XLAUI:
 		case CVMX_HELPER_INTERFACE_MODE_XFI:
+		case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+		case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 		{
 			cvmx_bgxx_cmrx_config_t cmr_config;
 			int index;
@@ -1850,6 +1880,8 @@ static int __cvmx_helper_shutdown_packet_io_global_cn78xx(int node)
 		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		case CVMX_HELPER_INTERFACE_MODE_XLAUI:
 		case CVMX_HELPER_INTERFACE_MODE_XFI:
+		case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+		case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 		case CVMX_HELPER_INTERFACE_MODE_SGMII:
 		{
 			cvmx_bgxx_cmr_rx_adrx_cam_t cmr_rx_adr;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index c271410..299b470 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,13 +42,14 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 97721 $<hr>
+ * <hr>$Revision: 98763 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-clock.h>
 #include <asm/octeon/cvmx-ciu-defs.h>
 #include <asm/octeon/cvmx-dpi-defs.h>
+#include <asm/octeon/cvmx-gserx-defs.h>
 #include <asm/octeon/cvmx-mio-defs.h>
 #include <asm/octeon/cvmx-npi-defs.h>
 #include <asm/octeon/cvmx-npei-defs.h>
@@ -889,6 +890,7 @@ retry:
 static int __cvmx_pcie_rc_initialize_link_gen2(int pcie_port)
 {
 	uint64_t start_cycle;
+
 	cvmx_pemx_ctl_status_t pem_ctl_status;
 	cvmx_pciercx_cfg032_t pciercx_cfg032;
 	cvmx_pciercx_cfg448_t pciercx_cfg448;
@@ -898,6 +900,23 @@ static int __cvmx_pcie_rc_initialize_link_gen2(int pcie_port)
 	pem_ctl_status.s.lnk_enb = 1;
 	cvmx_write_csr(CVMX_PEMX_CTL_STATUS(pcie_port), pem_ctl_status.u64);
 
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		int lane;
+		cvmx_gserx_lanex_pwr_ctrl_t pwr_ctrl;
+
+		for (lane = 0; lane < 4; lane++) {
+			pwr_ctrl.u64 = cvmx_read_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, pcie_port));
+
+			pwr_ctrl.s.rx_resetn_ovrrd_en = 1;
+			cvmx_write_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, pcie_port), pwr_ctrl.u64);
+			cvmx_wait(1000);
+			pwr_ctrl.u64 = cvmx_read_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, pcie_port));
+
+			pwr_ctrl.s.rx_resetn_ovrrd_en = 0;
+			cvmx_write_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, pcie_port), pwr_ctrl.u64);
+		}
+	}
+
 	/* Wait for the link to come up */
 	start_cycle = cvmx_get_cycle();
 	do {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 302bee4..ff9c378 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -63,6 +63,10 @@ static const bool __native_le = 0;
 static const bool __native_le = 1;
 #endif
 
+#define CVMX_DUMP_REGX(reg) 	\
+	if(debug)		\
+	cvmx_dprintf("%s=%#llx\n",#reg,(long long)cvmx_read_csr_node(node,reg))
+
 static int cvmx_pko_setup_macs(int node);
 
 /*
@@ -135,11 +139,6 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 		return 0;
 	}
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
-
 	/* Clear FLUSH command to be sure */
 	pko_flush.u64 = 0;
 	pko_flush.s.flush_en = 0;
@@ -151,6 +150,8 @@ cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
 	pko_aura.s.laura = aura & (CVMX_FPA3_AURA_NUM-1);
 	cvmx_write_csr_node(node, CVMX_PKO_DPFI_FPA_AURA, pko_aura.u64);
 
+	CVMX_DUMP_REGX(CVMX_PKO_DPFI_FPA_AURA);
+
 	dpfi_enable.u64 = 0;
 	dpfi_enable.s.enable = 1;
 	cvmx_write_csr_node(node, CVMX_PKO_DPFI_ENA, dpfi_enable.u64);
@@ -166,11 +167,6 @@ cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
 			break;
 	} while (!pko_status.s.pko_rdy);
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
-
 	if (!pko_status.s.pko_rdy) {
 		dpfi_status.u64 = cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS);
 		cvmx_dprintf("ERROR: %s: PKO DFPI failed, "
@@ -244,28 +240,17 @@ int cvmx_pko3_hw_disable(int node)
 		}
 	}
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
-
 	//XXX- try to disable PKO first, then flush the DPFI
 	/* disable PKO - all packets should be out by now */
 	pko_enable.u64 = 0;
 	pko_enable.s.enable = 0;
 	cvmx_write_csr_node(node, CVMX_PKO_ENABLE, pko_enable.u64);
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
-
 	/* Reset L1_SQ */
 	for(i = 0; i < 32; i++) {
 		cvmx_pko_l1_sqx_topology_t pko_l1_topology;
 		cvmx_pko_l1_sqx_shape_t pko_l1_shape;
 		cvmx_pko_l1_sqx_link_t pko_l1_link;
-if(debug) cvmx_dprintf("%s: kill L1_SQ%d\n",__func__, i);
 		pko_l1_topology.u64 = 0;
 		pko_l1_topology.s.link = 0x1c;
 		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_TOPOLOGY(i),
@@ -285,7 +270,6 @@ if(debug) cvmx_dprintf("%s: kill L1_SQ%d\n",__func__, i);
 	for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
 		cvmx_pko_macx_cfg_t pko_mac_cfg;
 
-if(debug) cvmx_dprintf("%s: kill MAC %d\n",__func__, mac_num);
 		pko_mac_cfg.u64 = 0;
 		pko_mac_cfg.s.fifo_num = 0x1f;
 		cvmx_write_csr_node(node, CVMX_PKO_MACX_CFG(mac_num),
@@ -296,7 +280,6 @@ if(debug) cvmx_dprintf("%s: kill MAC %d\n",__func__, mac_num);
 	for(fifo = 0; fifo < 8; fifo++) {
 		cvmx_pko_ptgfx_cfg_t pko_ptgfx_cfg;
 
-if(debug) cvmx_dprintf("%s: kill FIFO Group %d\n",__func__, fifo);
 		pko_ptgfx_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_PTGFX_CFG(fifo));
 		/* Simulator asserts if an unused group is reset */
 		if (pko_ptgfx_cfg.u64 == 0)
@@ -307,11 +290,6 @@ if(debug) cvmx_dprintf("%s: kill FIFO Group %d\n",__func__, fifo);
 					pko_ptgfx_cfg.u64);
 	}
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
-
 	/* Set FLUSH_EN to return cached pointers to FPA */
 	pko_flush.u64 = 0;
 	pko_flush.s.flush_en = 1;
@@ -321,10 +299,6 @@ cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
         cycles = cvmx_get_cycle();
         cycles += cvmx_clock_get_rate(CVMX_CLOCK_CORE)/1000 * timeout;
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
 	/* Wait until all pointers have been returned */
 	do {
 		dpfi_status.u64 = cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS);
@@ -332,24 +306,21 @@ cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
 			break;
 	} while (!dpfi_status.s.cache_flushed);
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
+
 
 	/* disable PKO buffer manager, should return all buffers to FPA */
 	dpfi_enable.u64 = 0;
 	dpfi_enable.s.enable = 0;
 	cvmx_write_csr_node(node, CVMX_PKO_DPFI_ENA, dpfi_enable.u64);
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
+	CVMX_DUMP_REGX(CVMX_PKO_DPFI_ENA);
+	CVMX_DUMP_REGX(CVMX_PKO_DPFI_STATUS);
+	CVMX_DUMP_REGX(CVMX_PKO_STATUS);
 
-	/* Clear the FLISH_EN bit, as we are done */
+	/* Clear the FLUSH_EN bit, as we are done */
 	pko_flush.u64 = 0;
 	cvmx_write_csr_node(node, CVMX_PKO_DPFI_FLUSH, pko_flush.u64);
+	CVMX_DUMP_REGX(CVMX_PKO_DPFI_FLUSH);
 
 	if (dpfi_status.s.cache_flushed == 0) {
 		cvmx_dprintf("%s: ERROR: timeout waiting for PKO3 ptr flush\n",
@@ -357,11 +328,6 @@ cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
 		return -1;
 	}
 
-if(debug)
-cvmx_dprintf("%s %u: dpfi_statos=%#llx pko_statos=%#llx\n",__func__, __LINE__,
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_DPFI_STATUS),
-(unsigned long long) cvmx_read_csr_node(node, CVMX_PKO_STATUS));
-
 	return 0;
 }
 
@@ -664,7 +630,7 @@ static int cvmx_pko_setup_macs(int node)
 				fifo_group_cfg[g] = 3; /* 5k,0,5k,0 */
 			else if (cnt == 2 && fifo_group_cfg[g] == 3)
 				/* no change */;
-			else if(cnt == 1 && (fifo & 0x2) && 
+			else if(cnt == 1 && (fifo & 0x2) &&
 				fifo_group_cfg[g] == 3)
 				fifo_group_cfg[g] = 1; /* 5k,0,2.5k 2.5k*/
 			else if(cnt == 1 && (fifo & 0x3)==0x3)
@@ -1274,9 +1240,11 @@ int cvmx_pko3_pdesc_transmit(cvmx_pko3_pdesc_t *pdesc, uint16_t dq)
         if (pko_status.s.dqstatus == PKO_DQSTATUS_PASS)
                 return 0;
 
+#if 0
         cvmx_dprintf("%s: ERROR: failed to enqueue: %s\n",
                                 __FUNCTION__,
                                 pko_dqstatus_error(pko_status.s.dqstatus));
+#endif
 
 	return -1;
 }
@@ -1321,7 +1289,7 @@ int cvmx_pko3_pdesc_buf_append(cvmx_pko3_pdesc_t *pdesc, void *p_data,
 		cvmx_dprintf("%s: subcommand restriction violated\n", __func__);
 		return -1;
 	}
-	
+
 	hdr_s = (void *) &pdesc->word[0];
 
 	if(pdesc->last_aura == -1 && gaura != ((unsigned)-1)) {
@@ -1371,7 +1339,7 @@ int cvmx_pko3_pdesc_buf_append(cvmx_pko3_pdesc_t *pdesc, void *p_data,
  * @param wqe Work Queue Entry in a model-native format.
  * @param node The OCI node of the SSO where the WQE will be delivered.
  * @param group The SSO group where the WQE is delivered.
- * @param tt The SSO Tag Type for the WQE. If tt is not NULL, WQE should 
+ * @param tt The SSO Tag Type for the WQE. If tt is not NULL, WQE should
  * contain a valid tag value for the work entry.
  *
  * @return Returns 0 on success, -1 on error.
@@ -1379,7 +1347,7 @@ int cvmx_pko3_pdesc_buf_append(cvmx_pko3_pdesc_t *pdesc, void *p_data,
  * Restrictions:
  * There can be only one such notification per packet descriptor,
  * but this function may be called at any time after the descriptor
- * is first created from WQE or initialized, and before 
+ * is first created from WQE or initialized, and before
  * starting transmission.
  *
  */
@@ -1534,7 +1502,7 @@ static int cvmx_pko3_pdesc_hdr_offsets(cvmx_pko3_pdesc_t *pdesc)
 	pdesc->hdr_s = hdr_s = (void *) &pdesc->word[0];
 
 	/* Match IPv5/IPv6 protocols with/without options */
-	if ((pdesc->pki_word2.lc_hdr_type & 0x1c) 
+	if ((pdesc->pki_word2.lc_hdr_type & 0x1c)
 		== CVMX_PKI_LTYPE_E_IP4) {
 		hdr_s->s.l3ptr = pdesc->pki_word4.ptr_layer_c;
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 030b0e2..911109f 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 97979 $<hr>
+ * <hr>$Revision: 98310 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1273,15 +1273,28 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 		return CVMX_QLM_MODE_ILK;
 	} else if (gserx_cfg.s.bgx) {
 		cvmx_bgxx_cmrx_config_t cmr_config;
+		cvmx_bgxx_spux_br_pmd_control_t pmd_control;
 		int bgx = (qlm > 2) ? (qlm - 2) : qlm;
 		
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, bgx));
+		pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx));
+		
 		switch(cmr_config.s.lmac_type) {
 		case 0: return CVMX_QLM_MODE_SGMII;
 		case 1:	return CVMX_QLM_MODE_XAUI;
 		case 2:	return CVMX_QLM_MODE_RXAUI;
-		case 3:	return CVMX_QLM_MODE_XFI;
-		case 4:	return CVMX_QLM_MODE_XLAUI;
+		case 3:	
+			/* Use training to determine if we're in 10GBASE-KR or XFI */
+			if (pmd_control.s.train_en)
+				return CVMX_QLM_MODE_10G_KR;
+			else
+				return CVMX_QLM_MODE_XFI;
+		case 4:	
+			/* Use training to determine if we're in 10GBASE-KR or XFI */
+			if (pmd_control.s.train_en)
+				return CVMX_QLM_MODE_40G_KR4;
+			else
+				return CVMX_QLM_MODE_XLAUI;
 		default: return CVMX_QLM_MODE_DISABLED;
 		}
 	} else
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index f108d74..7445005 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 97057 $<hr>
+ * <hr>$Revision: 98685 $<hr>
  *
  */
 
@@ -278,6 +278,9 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_EAP7000_REF = 59,
 	CVMX_BOARD_TYPE_ROUTER7000_REF = 60,
 	CVMX_BOARD_TYPE_EBB7800 = 61,
+	CVMX_BOARD_TYPE_NIC401NVG = 62,
+	CVMX_BOARD_TYPE_NIC210NVG = 63,
+	CVMX_BOARD_TYPE_SFF7000 = 64,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -408,6 +411,9 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EAP7000_REF)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_ROUTER7000_REF)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7800)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC401NVG)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC210NVG)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SFF7000)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index 7f3dec2..de896a6c 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -482,7 +482,8 @@ union cvmx_ciu3_idtx_io {
 	struct cvmx_ciu3_idtx_io_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t io                           : 5;  /**< IO bridges to receive interrupts via this IDT. Enumerated with CIU_DEST_IO_E. */
+	uint64_t io                           : 5;  /**< Bitmask of which IO bridges or MCD to receive interrupts via this IDT.
+                                                         Enumerated with CIU_DEST_IO_E. */
 #else
 	uint64_t io                           : 5;
 	uint64_t reserved_5_63                : 59;
@@ -635,13 +636,16 @@ union cvmx_ciu3_iscx_ctl {
                                                          the change to IDT. */
 	uint64_t imp                          : 1;  /**< Entry implemented. Although the table has 1M entries, most of those do not correspond to
                                                          any INTSN, and as such are not implemented.
-                                                         1 = This index is implemented, and the bits are R/W.
-                                                         0 = This index is not implemented, all bits will return as zero. */
+                                                         1 = The IDT and EN fields for this index are R/W, and may have a corresponding INTSN,
+                                                         although some indices may have IMP set but not have any INTSN use.
+                                                         0 = The IDT and EN fields for this index are RAZ, and do not have any corresponding
+                                                         INTSN. */
 	uint64_t sso_pend                     : 1;  /**< Reserved. INTERNAL: Deprecated. Transaction needs to be sent to SSO. CIU internal state
                                                          for diagnostic use. [SSO_PEND] will be cleared when the entry is transmitted to SSO, or by
                                                          a software clear of [SSO], [RAW] or [EN]. */
 	uint64_t reserved_3_13                : 11;
-	uint64_t sso                          : 1;  /**< Reserved. INTERNAL: Deprecated. Use SSO delivery. */
+	uint64_t sso                          : 1;  /**< Reserved. This field may be read-only for some indexes.
+                                                         INTERNAL: Deprecated. Use SSO delivery. */
 	uint64_t en                           : 1;  /**< Enable interrupt delivery. */
 	uint64_t raw                          : 1;  /**< Interrupt pending before masking. Note read only, must use
                                                          CIU3_ISC()_W1C/CIU3_ISC()_W1S to toggle. */
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 56c9053..7fce9ac 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -1538,6 +1538,17 @@ static inline uint64_t CVMX_GSERX_RX_POLARITY(unsigned long block_id)
 #define CVMX_GSERX_RX_POLARITY(block_id) (CVMX_ADD_IO_SEG(0x0001180090000160ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P1(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P1(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904600B0ull) + ((block_id) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_RX_PWR_CTRL_P1(block_id) (CVMX_ADD_IO_SEG(0x00011800904600B0ull) + ((block_id) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SATA_CFG(unsigned long block_id)
 {
 	if (!(
@@ -6294,6 +6305,53 @@ union cvmx_gserx_rx_polarity {
 typedef union cvmx_gserx_rx_polarity cvmx_gserx_rx_polarity_t;
 
 /**
+ * cvmx_gser#_rx_pwr_ctrl_p1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_rx_pwr_ctrl_p1 {
+	uint64_t u64;
+	struct cvmx_gserx_rx_pwr_ctrl_p1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t p1_rx_resetn                 : 1;  /**< Place the receiver in reset (active low). */
+	uint64_t pq_rx_allow_pll_pd           : 1;  /**< When asserted, permit PLL powerdown (PLL is powered
+                                                         down if all other factors permit). */
+	uint64_t pq_rx_pcs_reset              : 1;  /**< When asserted, the RX power state machine puts the raw PCS RX logic
+                                                         in reset state to save power. */
+	uint64_t p1_rx_agc_en                 : 1;  /**< AGC enable. */
+	uint64_t p1_rx_dfe_en                 : 1;  /**< DFE enable. */
+	uint64_t p1_rx_cdr_en                 : 1;  /**< CDR enable. */
+	uint64_t p1_rx_cdr_coast              : 1;  /**< CDR coast; freezes the frequency of the CDR. */
+	uint64_t p1_rx_cdr_clr                : 1;  /**< CDR clear; clears the frequency of the CDR. */
+	uint64_t p1_rx_subblk_pd              : 5;  /**< RX sub-block powerdown controls to RX:
+                                                         <4> = CTLE.
+                                                         <3> = Reserved.
+                                                         <2> = Lane DLL.
+                                                         <1> = DFE/samplers.
+                                                         <0> = Termination. */
+	uint64_t p1_rx_chpd                   : 1;  /**< RX lane powerdown. */
+#else
+	uint64_t p1_rx_chpd                   : 1;
+	uint64_t p1_rx_subblk_pd              : 5;
+	uint64_t p1_rx_cdr_clr                : 1;
+	uint64_t p1_rx_cdr_coast              : 1;
+	uint64_t p1_rx_cdr_en                 : 1;
+	uint64_t p1_rx_dfe_en                 : 1;
+	uint64_t p1_rx_agc_en                 : 1;
+	uint64_t pq_rx_pcs_reset              : 1;
+	uint64_t pq_rx_allow_pll_pd           : 1;
+	uint64_t p1_rx_resetn                 : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn78xx;
+};
+typedef union cvmx_gserx_rx_pwr_ctrl_p1 cvmx_gserx_rx_pwr_ctrl_p1_t;
+
+/**
  * cvmx_gser#_sata_cfg
  *
  * SATA Config Enable.
diff --git a/arch/mips/include/asm/octeon/cvmx-helper.h b/arch/mips/include/asm/octeon/cvmx-helper.h
index 6d42364..e5c8b33 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper.h
@@ -42,7 +42,7 @@
  *
  * Helper functions for common, but complicated tasks.
  *
- * <hr>$Revision: 96716 $<hr>
+ * <hr>$Revision: 98310 $<hr>
  */
 
 #ifndef __CVMX_HELPER_H__
@@ -130,6 +130,8 @@ typedef enum {
 	CVMX_HELPER_INTERFACE_MODE_AGL,
 	CVMX_HELPER_INTERFACE_MODE_XLAUI,
 	CVMX_HELPER_INTERFACE_MODE_XFI,
+	CVMX_HELPER_INTERFACE_MODE_10G_KR,
+	CVMX_HELPER_INTERFACE_MODE_40G_KR4,
 } cvmx_helper_interface_mode_t;
 
 typedef union {
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 5ff8a7f..caeb024 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -2388,7 +2388,7 @@ typedef union cvmx_mio_boot_dma_adrx cvmx_mio_boot_dma_adrx_t;
  * The DMA operation duration in coprocessor clocks as:
  * MIO_BOOT_DMA_CFG()[SIZE] * MIO_BOOT_DMA_TIM()[TIM_MULT] * CYCLE_TIME.
  * Where:
- * CYCLE_TIME = MIO_BOOT_DMA_TIMn[RD_DLY+PAUSE+DMACK_H+WE_N+WE_A+OE_N+OE_A+DMACK_S].
+ * CYCLE_TIME = MIO_BOOT_DMA_TIM()[RD_DLY+PAUSE+DMACK_H+WE_N+WE_A+OE_N+OE_A+DMACK_S].
  * Coprocessor clocks can be converted to core clocks by multiplying the value by the clock ratio
  * RST_BOOT[C_MUL] / RST_BOOT[PNR_MUL].
  */
@@ -2440,13 +2440,12 @@ union cvmx_mio_boot_dma_cfgx {
 	uint64_t swap8                        : 1;  /**< DMA engine 0-1 8-bit swap. */
 	uint64_t endian                       : 1;  /**< DMA engine 0-1 IOB endian mode (0 = big, 1 = little). */
 	uint64_t size                         : 20; /**< DMA engine 0-1 size. SIZE is specified in number of bus transfers, where one transfer is
-                                                         equal to the following number of bytes, dependent on MIO_BOOT_DMA_TIMn[WIDTH] and
-                                                         MIO_BOOT_DMA_TIMn[DDR]:
-                                                         WIDTH DDR  Transfer Size (bytes)
-                                                         0 0 2
-                                                         0 1 4
-                                                         1 0 4
-                                                         1 1 8 */
+                                                         equal to the following number of bytes, dependent on MIO_BOOT_DMA_TIM()[WIDTH] and
+                                                         MIO_BOOT_DMA_TIM()[DDR]:
+                                                         _ If WIDTH=0, DDR=0, then transfer is 2 bytes.
+                                                         _ If WIDTH=0, DDR=1, then transfer is 4 bytes.
+                                                         _ If WIDTH=1, DDR=0, then transfer is 4 bytes.
+                                                         _ If WIDTH=1, DDR=1, then transfer is 8 bytes. */
 	uint64_t reserved_0_35                : 36;
 #else
 	uint64_t reserved_0_35                : 36;
@@ -2681,7 +2680,9 @@ typedef union cvmx_mio_boot_int cvmx_mio_boot_int_t;
  * The local-region memory-address register specifies the address for reading or writing the
  * local memory. This address post-increments following an access to the MIO boot local-memory
  * data register.
+ *
  * Local-memory region 0 is addresses 0x00-0x78.
+ *
  * Local-memory region 1 is addresses 0x80-0xF8.
  */
 union cvmx_mio_boot_loc_adr {
@@ -2956,8 +2957,8 @@ union cvmx_mio_boot_pin_defs {
                                                          0x8 = 3.3V.
                                                          else Reserved. */
 	uint64_t reserved_33_47               : 15;
-	uint64_t vrm_disable                  : 1;  /**< VRM disabled */
-	uint64_t user1                        : 13; /**< BOOT_AD<31:19> latched during power up */
+	uint64_t vrm_disable                  : 1;  /**< VRM disabled. */
+	uint64_t user1                        : 13; /**< BOOT_AD<31:19> latched during power up. */
 	uint64_t device                       : 3;  /**< BOOT_AD<18:16> latched during power up. Indicates boot device:
                                                          0x0 = Parallel NOR.
                                                          0x1 = Reserved.
@@ -2967,17 +2968,17 @@ union cvmx_mio_boot_pin_defs {
                                                          0x5 = SPI Boot (24-bit address).
                                                          0x6 = SPI Boot (32-bit address).
                                                          0x7 = Reserved. */
-	uint64_t ale                          : 1;  /**< Region 0 default ALE mode */
-	uint64_t width                        : 1;  /**< Region 0 default bus width */
-	uint64_t user13                       : 1;  /**< BOOT_AD<13> latched during power up */
-	uint64_t dmack_p1                     : 1;  /**< BOOT_DMACK<1> default polarity */
-	uint64_t dmack_p0                     : 1;  /**< BOOT_DMACK<0> default polarity */
+	uint64_t ale                          : 1;  /**< Region 0 default ALE mode. */
+	uint64_t width                        : 1;  /**< Region 0 default bus width. */
+	uint64_t user13                       : 1;  /**< BOOT_AD<13> latched during power up. */
+	uint64_t dmack_p1                     : 1;  /**< BOOT_DMACK<1> default polarity. */
+	uint64_t dmack_p0                     : 1;  /**< BOOT_DMACK<0> default polarity. */
 	uint64_t term                         : 2;  /**< Selects default boot-bus driver termination.
-                                                         0x0 = full strength
-                                                         0x1 = 25ohm
-                                                         0x2 = 50ohm
-                                                         0x3 = 65ohm */
-	uint64_t user0                        : 9;  /**< BOOT_AD<8:0> latched during power up */
+                                                         0x0 = full strength.
+                                                         0x1 = 25ohm.
+                                                         0x2 = 50ohm.
+                                                         0x3 = 65ohm. */
+	uint64_t user0                        : 9;  /**< BOOT_AD<8:0> latched during power up. */
 #else
 	uint64_t user0                        : 9;
 	uint64_t term                         : 2;
@@ -3744,6 +3745,7 @@ typedef union cvmx_mio_emm_dma_fifo_cfg cvmx_mio_emm_dma_fifo_cfg_t;
  * successfully. Writes to this register store both the MIO_EMM_DMA_FIFO_CMD and the
  * MIO_EMM_DMA_FIFO_ADR contents into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT]
  * field.
+ *
  * Note: This register has a similar format to the MIO_EMM_DMA_CFG register with the exception
  * that the EN and CLR fields are absent. These are supported in the MIO_EMM_DMA_FIFO_CFG.
  */
@@ -5199,11 +5201,11 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
 	uint64_t pll_half_dis                 : 1;  /**< Fuse information - Coprocessor-clock PLL control. */
 	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C cripple:
-                                                         0x0 = Full cache (16-way, 16 MB)
-                                                         0x1 = 3/4 ways (12-way, 12 MB)
-                                                         0x2 = 1/2 ways (8-way, 8 MB)
-                                                         0x3 = 1/4 ways (4-way, 4MB)
-                                                         0x4-0x7 = Reserved */
+                                                         0x0 = Full cache (16-way, 16 MB).
+                                                         0x1 = 3/4 ways (12-way, 12 MB).
+                                                         0x2 = 1/2 ways (8-way, 8 MB).
+                                                         0x3 = 1/4 ways (4-way, 4MB).
+                                                         0x4-0x7 = Reserved. */
 	uint64_t reserved_31_31               : 1;
 	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information. */
 	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIE specification. */
@@ -5865,6 +5867,7 @@ typedef union cvmx_mio_fus_rcmd cvmx_mio_fus_rcmd_t;
  * IFB fuses are 0 to 1791. The reset values are for IFB fuses for PLL_REF_CLK up to 100MHz when
  * core PLL is engaged. If any of the formulas below result in a value less than zero, the
  * corresponding timing parameter should be set to zero.
+ *
  * Prior to issuing a read to the fuse banks (via MIO_FUS_RCMD), this register should be written
  * with the timing parameters that will be read.
  * This register should not be written while MIO_FUS_RCMD[PEND] = 1.
@@ -6187,6 +6190,15 @@ typedef union cvmx_mio_fus_spr_repair_sum cvmx_mio_fus_spr_repair_sum_t;
  *
  * This register exists to support Authentik. Authentik code should read this register, then
  * clear VAL to prevent other software from observing the value of the TGG fuses.
+ *
+ * INTERNAL: It is never possible to read the TGG fuses via MIO_FUS_RCMD. Whenever the fuse
+ * corresponding to VAL (TGG<63>) is blown, it is not possible to blow any of TGG<62:0>. The fuse
+ * corresponding to VAL must be the one and only lock down bit for TGG<62:0> - no other fuse
+ * lockdown bit can prevent blowing TGG<62:0>. It must always be possible to blow the fuse
+ * corresponding to VAL when it is not already blown. If an Authentik part may be converted to a
+ * non-Authentik part (via some JTAG mechanism or any other mechanism), it must not be possible
+ * to read the TGG fuse values from the Authentik part by performing this conversion -> the reset
+ * value of VAL should be zero in this converted case.
  */
 union cvmx_mio_fus_tgg {
 	uint64_t u64;
@@ -7064,7 +7076,7 @@ union cvmx_mio_ptp_dpll_err_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t n_sclk                       : 32; /**< Latest number of Digital PLL coprocessor clocks in one compensation period. */
 	uint64_t reserved_1_31                : 31;
-	uint64_t dpll_int                     : 1;  /**< Digital PLL error. Throws MIO_PTP_INTSN_E::MIO_PTP_DPLL_ERR_INT. */
+	uint64_t dpll_int                     : 1;  /**< Digital PLL error. Throws MIO_PTP_INTSN_E::MIO_PTP_DPLL_INT. */
 #else
 	uint64_t dpll_int                     : 1;
 	uint64_t reserved_1_31                : 31;
@@ -8892,11 +8904,11 @@ union cvmx_mio_twsx_int {
 	uint64_t sda_ovr                      : 1;  /**< SDA override. */
 	uint64_t reserved_3_7                 : 5;
 	uint64_t core_int                     : 1;  /**< TWSI core interrupt. Ignored when the HLC is enabled. Throws
-                                                         TWS_INTSN_E::MIO_TWS_INT_CORE. */
-	uint64_t ts_int                       : 1;  /**< MIO_TWS(0..1)_TWSI_SW register-update interrupt. Ignored when the HLC is disabled. Throws
-                                                         TWS_INTSN_E::MIO_TWS_INT_TS. */
-	uint64_t st_int                       : 1;  /**< MIO_TWS(0..1)_SW_TWSI register-update interrupt. Ignored when the HLC is disabled. Throws
-                                                         TWS_INTSN_E::MIO_TWS_INT_ST. */
+                                                         TWS_INTSN_E::MIO_TWS()_INT_CORE. */
+	uint64_t ts_int                       : 1;  /**< MIO_TWS()_TWSI_SW register-update interrupt. Ignored when the HLC is disabled. Throws
+                                                         TWS_INTSN_E::MIO_TWS()_INT_TS. */
+	uint64_t st_int                       : 1;  /**< MIO_TWS()_SW_TWSI register-update interrupt. Ignored when the HLC is disabled. Throws
+                                                         TWS_INTSN_E::MIO_TWS()_INT_ST. */
 #else
 	uint64_t st_int                       : 1;
 	uint64_t ts_int                       : 1;
@@ -8917,12 +8929,13 @@ typedef union cvmx_mio_twsx_int cvmx_mio_twsx_int_t;
  * cvmx_mio_tws#_sw_twsi
  *
  * This register allows software to:
- * Initiate master-mode operations with a write operation, and read the result with a
+ * * Initiate master-mode operations with a write operation, and read the result with a
  * read operation.
- * Load four bytes for later retrieval (slave mode) with a write operation and check validity
+ * * Load four bytes for later retrieval (slave mode) with a write operation and check validity
  * with a read operation.
- * Launch a configuration read/write operation with a write operation and read the result with a
- * read operation.
+ * * Launch a configuration read/write operation with a write operation and read the result with
+ * a read operation.
+ *
  * This register should be read or written by software, and read by the TWSI device. The TWSI
  * device can use either two-byte or five-byte read operations to reference this register.
  * The TWSI device considers this register valid when [V] = 1 and [SLONLY] = 1.
@@ -9056,9 +9069,10 @@ typedef union cvmx_mio_twsx_sw_twsi cvmx_mio_twsx_sw_twsi_t;
  *
  * This register contains an additional byte of internal address and four additional bytes of
  * data to be used with TWSI master-mode operations.
+ *
  * The IA field is sent as the first byte of internal address when performing master-mode
- * combined-read/write-with-IA operations and MIO_TWS(0..1)_SW_TWSI[EIA] is set. The D field
- * extends the data field of MIO_TWS(0..1)_SW_TWSI for a total of 8 bytes (SOVR must be set to
+ * combined-read/write-with-IA operations and MIO_TWS()_SW_TWSI[EIA] is set. The D field
+ * extends the data field of MIO_TWS()_SW_TWSI for a total of 8 bytes (SOVR must be set to
  * perform operations greater than 4 bytes).
  */
 union cvmx_mio_twsx_sw_twsi_ext {
@@ -9103,6 +9117,7 @@ typedef union cvmx_mio_twsx_sw_twsi_ext cvmx_mio_twsx_sw_twsi_ext_t;
  *
  * This register allows the TWSI device to transfer data to software and later check that
  * software has received the information.
+ *
  * This register should be read or written by the TWSI device, and read by software. The TWSI
  * device can use one-byte or four-byte payload write operations, and two-byte payload read
  * operations. The TWSI device considers this register valid when V = 1.
diff --git a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
index 96d3cdf..e921c30 100644
--- a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
@@ -133,12 +133,12 @@ union cvmx_mpi_cfg {
 	uint64_t clkdiv                       : 13; /**< Fspi_clk = Fsclk / (2 * CLKDIV)                    |          NS
                                                          CLKDIV = Fsclk / (2 * Fspi_clk) */
 	uint64_t csena3                       : 1;  /**< SPI_CS3_L enable:
-                                                         0=UART1_RTS_L/SPI_CS3_L pin is UART pin.
-                                                         1=UART1_RTS_L/SPI_CS3_L pin is MPI/SPI pin.
+                                                         0 = UART1_RTS_L/SPI_CS3_L pin is UART pin.
+                                                         1 = UART1_RTS_L/SPI_CS3_L pin is MPI/SPI pin.
                                                          SPI_CS3_L drives UART1_RTS_L/SPI_CS3_L. */
 	uint64_t csena2                       : 1;  /**< SPI_CS2_L enable:
-                                                         0=UART1_CTS_L/SPI_CS2_L pin is UART pin.
-                                                         1=UART1_CTS_L/SPI_CS2_L pin is MPI/SPI pin.
+                                                         0 = UART1_CTS_L/SPI_CS2_L pin is UART pin.
+                                                         1 = UART1_CTS_L/SPI_CS2_L pin is MPI/SPI pin.
                                                          SPI_CS2_L drives UART1_CTS_L/SPI_CS2_L. */
 	uint64_t csena1                       : 1;  /**< If 0, BOOT_CE_N<7>/SPI_CS1_L pin is BOOT pin       |          NS
                                                          1, BOOT_CE_N<7>/SPI_CS1_L pin is SPI pin
@@ -515,23 +515,23 @@ union cvmx_mpi_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
 	uint64_t clkdiv                       : 13; /**< Clock divisor.
-                                                         SPI_CK = coprocessor clock / (2 * CLKDIV)
-                                                         CLKDIV = coprocessor clock / (2 * SPI_CK) */
+                                                         _ SPI_CK = coprocessor clock / (2 * CLKDIV)
+                                                         _ CLKDIV = coprocessor clock / (2 * SPI_CK) */
 	uint64_t csena3                       : 1;  /**< SPI_CS3_L enable:
-                                                         0=UART1_RTS_L/SPI_CS3_L pin is UART pin.
-                                                         1=UART1_RTS_L/SPI_CS3_L pin is MPI/SPI pin.
+                                                         0 = UART1_RTS_L/SPI_CS3_L pin is UART pin.
+                                                         1 = UART1_RTS_L/SPI_CS3_L pin is MPI/SPI pin.
                                                          SPI_CS3_L drives UART1_RTS_L/SPI_CS3_L. */
 	uint64_t csena2                       : 1;  /**< SPI_CS2_L enable:
-                                                         0=UART1_CTS_L/SPI_CS2_L pin is UART pin.
-                                                         1=UART1_CTS_L/SPI_CS2_L pin is MPI/SPI pin.
+                                                         0 = UART1_CTS_L/SPI_CS2_L pin is UART pin.
+                                                         1 = UART1_CTS_L/SPI_CS2_L pin is MPI/SPI pin.
                                                          SPI_CS2_L drives UART1_CTS_L/SPI_CS2_L. */
 	uint64_t csena1                       : 1;  /**< SPI_CS1_L enable:
-                                                         0=BOOT_CE_N<7>/SPI_CS1_L pin is boot-bus pin.
-                                                         1=BOOT_CE_N<7>/SPI_CS1_L pin is MPI/SPI pin.
+                                                         0 = BOOT_CE_N<7>/SPI_CS1_L pin is boot-bus pin.
+                                                         1 = BOOT_CE_N<7>/SPI_CS1_L pin is MPI/SPI pin.
                                                          SPI_CS1_L drives BOOT_CE_N<7>/SPI_CS1_L. */
 	uint64_t csena0                       : 1;  /**< SPI_CS0_L enable:
-                                                         0=BOOT_CE_N<6>/SPI_CS0_L pin is boot-bus pin
-                                                         1=BOOT_CE_N<6>/SPI_CS0_L pin is MPI/SPI pin
+                                                         0 = BOOT_CE_N<6>/SPI_CS0_L pin is boot-bus pin.
+                                                         1 = BOOT_CE_N<6>/SPI_CS0_L pin is MPI/SPI pin.
                                                          SPI_CS0_L drives BOOT_CE_N<6>/SPI_CS0_L. */
 	uint64_t cslate                       : 1;  /**< SPI_CSn_L late.
                                                          0 = SPI_CSn_L asserts 1/2 coprocessor-clock cycle before the transaction.
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 0e37331..c503f1b 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -416,6 +416,17 @@ static inline uint64_t CVMX_OCX_LNEX_STS_MSG(unsigned long offset)
 #define CVMX_OCX_LNEX_STS_MSG(offset) (CVMX_ADD_IO_SEG(0x0001180011008010ull) + ((offset) & 31) * 256)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCX_LNEX_TRN_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
+		cvmx_warn("CVMX_OCX_LNEX_TRN_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800110080D0ull) + ((offset) & 31) * 256;
+}
+#else
+#define CVMX_OCX_LNEX_TRN_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800110080D0ull) + ((offset) & 31) * 256)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCX_LNEX_TRN_LD(unsigned long offset)
 {
 	if (!(
@@ -1685,6 +1696,30 @@ union cvmx_ocx_lnex_sts_msg {
 typedef union cvmx_ocx_lnex_sts_msg cvmx_ocx_lnex_sts_msg_t;
 
 /**
+ * cvmx_ocx_lne#_trn_ctl
+ */
+union cvmx_ocx_lnex_trn_ctl {
+	uint64_t u64;
+	struct cvmx_ocx_lnex_trn_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t lock                         : 1;  /**< Training frame boundary locked. */
+	uint64_t done                         : 1;  /**< Training done. For diagnostic use only may be written to 1 to force training done. */
+	uint64_t ena                          : 1;  /**< Training enabled. */
+	uint64_t eie_detect                   : 1;  /**< Electrical idle exit (EIE) detected. */
+#else
+	uint64_t eie_detect                   : 1;
+	uint64_t ena                          : 1;
+	uint64_t done                         : 1;
+	uint64_t lock                         : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_ocx_lnex_trn_ctl_s        cn78xx;
+};
+typedef union cvmx_ocx_lnex_trn_ctl cvmx_ocx_lnex_trn_ctl_t;
+
+/**
  * cvmx_ocx_lne#_trn_ld
  */
 union cvmx_ocx_lnex_trn_ld {
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index c2755bf..0d825df 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1459,8 +1459,16 @@ typedef union cvmx_pki_clx_int cvmx_pki_clx_int_t;
 /**
  * cvmx_pki_cl#_pcam#_action#
  *
- * If multiple PCAM entries hit, the PKI_GEN_INT[PCAMERR] error interrupt is signaled, and it is
- * unpredictable which PCAM action register will be used.
+ * Action performed based on PCAM lookup using the PKI_CL()_PCAM()_TERM() and
+ * PKI_CL()_PCAM()_MATCH() registers.
+ *
+ * If lookup data matches no PCAM entries, then no action takes place. No matches indicates
+ * normal parsing will continue.
+ *
+ * If data matches multiple PCAM entries, PKI_WQE_S[OPCODE] of the processed packet may be set to
+ * PKI_OPCODE_E::RE_PKIPCAM and the PKI_CL()_INT[PCAM_CONF] error interrupt is signaled.  Once a
+ * conflict is detected, the PCAM state is unpredictable and is required to be fully reconfigured
+ * before further valid processing can take place.
  */
 union cvmx_pki_clx_pcamx_actionx {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index c8c32c4..34630e5 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -66,6 +66,9 @@ extern "C" {
 #include "cvmx-scratch.h"
 #endif
 
+#define	__USE_LMTST		/* Temporary work-around */
+#define	__CHECK_FPA	(48*64)	/* Temporary work-around */
+
 /* dwords are from 1-16 */
 /* scratch line for LMT operations */
 #define CVMX_PKO_LMTLINE 2ull	//FIXME- should go somewhere else ?
@@ -304,6 +307,8 @@ union cvmx_pko_lmtdma_data {
 };
 typedef union cvmx_pko_lmtdma_data cvmx_pko_lmtdma_data_t;
 
+extern int cvmx_pko3_internal_buffer_count(unsigned node);
+
 /*
  * PKO descriptor queue operation error string
  *
@@ -314,10 +319,6 @@ typedef union cvmx_pko_lmtdma_data cvmx_pko_lmtdma_data_t;
  */
 const char * pko_dqstatus_error(pko_query_dqstatus_t dqstatus);
 
-static inline uint64_t build_mask(uint64_t bits)
-{
-    return ~((~0x0ull) << bits);
-}
 
 /*
  * This function gets PKO mac num for a interface/port.
@@ -408,6 +409,25 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 		dma_addr += (numwords - 1) << 3;
 	}
 
+#ifdef	__CHECK_FPA	/* Temporary work-around */
+	if (dqop == CVMX_PKO_DQ_SEND) {
+		static int64_t cached_buf_count = 0;
+		if (cached_buf_count > 0) {
+			cached_buf_count -= numwords+1;
+		} else {
+		cached_buf_count = cvmx_pko3_internal_buffer_count(node);
+		if ( cached_buf_count <= __CHECK_FPA) {
+			/* Return same error as if the chip would work right */
+			pko_status.u64 = 0;
+			pko_status.s.dqop = dqop;
+			pko_status.s.dqstatus = PKO_DQSTATUS_NOFPABUF;
+			return pko_status;
+			}
+		cached_buf_count *= (4096/8)-1/48;
+		}
+	}
+#endif
+
 	if (numwords > 15) {
 		cvmx_dprintf("%s: ERROR: Internal error\n",
 				__FUNCTION__);
@@ -421,11 +441,23 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 		scr_off += sizeof(cmds[0]);
 	}
 
+	pko_send_dma_data.u64 = 0;
+
+#ifndef	__USE_LMTST
+	/* Request one return word */
+	pko_send_dma_data.s.rtnlen = 1;
+
 	/* Write all-ones into the return area */
 	cvmx_scratch_write64(scr_off, ~0ull);
 
+#else	/* Temporary work-around */
+	if (dqop != CVMX_PKO_DQ_SEND) {
+		pko_send_dma_data.s.rtnlen = 1;
+		cvmx_scratch_write64(scr_off, ~0ull);
+	}
+#endif
+
 	/* build store data for DMA */
-	pko_send_dma_data.u64 = 0;
 	pko_send_dma_data.s.scraddr = scr_off >> 3;
 	pko_send_dma_data.s.rtnlen = 1;
 	pko_send_dma_data.s.did = 0x51;
@@ -439,12 +471,27 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 	/* issue PKO DMA */
 	cvmx_write64_uint64(dma_addr, pko_send_dma_data.u64);
 
+#ifndef	__USE_LMTST
 	/* Wait for completion */
 	CVMX_SYNCIOBDMA;
 
 	/* Retreive result */
 	pko_status.u64 = cvmx_scratch_read64(scr_off);
+#else	/* Temporary work-around */
+	if (pko_send_dma_data.s.rtnlen) {
+		/* Wait for completion */
+		CVMX_SYNCIOBDMA;
 
+		/* Retreive real result */
+		pko_status.u64 = cvmx_scratch_read64(scr_off);
+	} else {
+		/* Fake positive result */
+		pko_status.u64 = 0;
+		pko_status.s.depth = 1;
+		pko_status.s.dqop = dqop;
+		pko_status.s.dqstatus = PKO_DQSTATUS_PASS;
+	}
+#endif
 	return pko_status;
 }
 
@@ -575,7 +622,6 @@ extern int cvmx_pko3_interface_options(int xiface, int index,
  */
 extern void cvmx_pko3_dq_options(unsigned node, unsigned dq, bool min_pad);
 
-extern int cvmx_pko3_internal_buffer_count(unsigned node);
 
 /* Packet descriptor - PKO3 command buffer + internal state */
 typedef struct cvmx_pko3_pdesc_s {
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index 561205a..e8b9633 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 96753 $<hr>
+ * <hr>$Revision: 98310 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
@@ -187,6 +187,8 @@ enum cvmx_qlm_mode {
 	CVMX_QLM_MODE_SATA_2X1,
 	CVMX_QLM_MODE_XLAUI,
 	CVMX_QLM_MODE_XFI,
+	CVMX_QLM_MODE_10G_KR,
+	CVMX_QLM_MODE_40G_KR4,
 	CVMX_QLM_MODE_PCIE_1X8,  /* 1x8 gen3 / gen2 / gen1 */
 	CVMX_QLM_MODE_OCI
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 7b49c41..438d24b 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -204,27 +204,27 @@ union cvmx_rst_boot {
                                                          'ref-clock speed' should always be 50MHz. */
 	uint64_t reserved_21_23               : 3;
 	uint64_t lboot_oci                    : 3;  /**< Last boot cause mask; resets only with DCOK.
-                                                         <20> Warm reset due to OCI Link 2 going down.
-                                                         <19> Warm reset due to OCI Link 1 going down.
-                                                         <18> Warm reset due to OCI Link 0 going down. */
+                                                         <20> = Warm reset due to OCI Link 2 going down.
+                                                         <19> = Warm reset due to OCI Link 1 going down.
+                                                         <18> = Warm reset due to OCI Link 0 going down. */
 	uint64_t lboot_ext                    : 6;  /**< Last boot cause mask; resets only with DCOK.
-                                                         <17> Warm reset due to Cntl3 link-down or hot-reset.
-                                                         <16> Warm reset due to Cntl2 link-down or hot-reset.
-                                                         <15> Cntl3 reset due to PERST3_L pin.
-                                                         <14> Cntl2 reset due to PERST2_L pin.
-                                                         <13> Warm reset due to PERST3_L pin.
-                                                         <12> Warm reset due to PERST2_L pin. */
+                                                         <17> = Warm reset due to Cntl3 link-down or hot-reset.
+                                                         <16> = Warm reset due to Cntl2 link-down or hot-reset.
+                                                         <15> = Cntl3 reset due to PERST3_L pin.
+                                                         <14> = Cntl2 reset due to PERST2_L pin.
+                                                         <13> = Warm reset due to PERST3_L pin.
+                                                         <12> = Warm reset due to PERST2_L pin. */
 	uint64_t lboot                        : 10; /**< Last boot cause mask; resets only with DCOK.
-                                                         <11> Soft reset due to watchdog.
-                                                         <10> Soft reset due to RST_SOFT_RST write.
-                                                         <9> Warm reset due to Cntl0 link-down or hot-reset.
-                                                         <8> Warm reset due to Cntl1 link-down or hot-reset.
-                                                         <7> Cntl1 reset due to PERST1_L pin.
-                                                         <6> Cntl0 reset due to PERST0_L pin.
-                                                         <5> Warm reset due to PERST1_L pin.
-                                                         <4> Warm reset due to PERST0_L pin.
-                                                         <3> Warm reset due to CHIP_RESET_L pin.
-                                                         <2> Cold reset due to PLL_DC_OK pin. */
+                                                         <11> = Soft reset due to watchdog.
+                                                         <10> = Soft reset due to RST_SOFT_RST write.
+                                                         <9> = Warm reset due to Cntl1 link-down or hot-reset.
+                                                         <8> = Warm reset due to Cntl0 link-down or hot-reset.
+                                                         <7> = Cntl1 reset due to PERST1_L pin.
+                                                         <6> = Cntl0 reset due to PERST0_L pin.
+                                                         <5> = Warm reset due to PERST1_L pin.
+                                                         <4> = Warm reset due to PERST0_L pin.
+                                                         <3> = Warm reset due to CHIP_RESET_L pin.
+                                                         <2> = Cold reset due to PLL_DC_OK pin. */
 	uint64_t rboot                        : 1;  /**< Determines whether core 0 remains in reset after chip cold/warm/soft reset. */
 	uint64_t rboot_pin                    : 1;  /**< Read-only access to REMOTE_BOOT pin. */
 #else
@@ -311,33 +311,33 @@ union cvmx_rst_ctlx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t prst_link                    : 1;  /**< Controls whether corresponding controller link-down or hot-reset causes the assertion of
-                                                         RST_SOFT_PRST*[SOFT_PRST].
+                                                         RST_SOFT_PRST()[SOFT_PRST].
                                                          A warm/soft reset does not change this field. On cold reset, this field is initialized to
                                                          0. */
 	uint64_t rst_done                     : 1;  /**< Read-only access to controller reset status. RST_DONE is always zero (i.e. the controller
                                                          is held in reset) when:
-                                                         * RST_SOFT_PRST*[SOFT_PRST] = 1, or
+                                                         * RST_SOFT_PRST()[SOFT_PRST] = 1, or
                                                          * RST_RCV = 1 and PERST*_L pin is asserted. */
 	uint64_t rst_link                     : 1;  /**< Reset link. Controls whether corresponding controller link-down reset or hot reset causes
                                                          a warm chip reset. On cold reset, this field is initialized as follows:
-                                                         0 when RST_CTL*[HOST_MODE] = 1
-                                                         1 when RST_CTL*[HOST_MODE] = 0
+                                                         _ 0 when RST_CTL()[HOST_MODE] = 1.
+                                                         _ 1 when RST_CTL()[HOST_MODE] = 0.
                                                          Note that a link-down or hot-reset event can never cause a warm chip reset when the
-                                                         controller is in reset (i.e. can never cause a warm reset when RST_DONE = 0). */
-	uint64_t host_mode                    : 1;  /**< Read-only access to the corresponding PEM(0..3)_CFG[HOSTMD] field indicating PEMn is root
+                                                         controller is in reset (i.e. can never cause a warm reset when [RST_DONE] = 0). */
+	uint64_t host_mode                    : 1;  /**< Read-only access to the corresponding PEM()_CFG[HOSTMD] field indicating PEMn is root
                                                          complex (host). For controllers 0 and 2  the initial value is determined by straps. For
                                                          controllers 1 and 3 this field is initially set as host. */
 	uint64_t reserved_4_5                 : 2;
 	uint64_t rst_drv                      : 1;  /**< Controls whether PERST*_L is driven. A warm/soft reset does not change this field. On cold
                                                          reset, this field is initialized as follows:
-                                                         0 when RST_CTL*[HOST_MODE] = 0
-                                                         1 when RST_CTL*[HOST_MODE] = 1
+                                                         _ 0 when RST_CTL()[HOST_MODE] = 0.
+                                                         _ 1 when RST_CTL()[HOST_MODE] = 1.
                                                          When set, CNXXXX drives the corresponding PERST*_L pin. Otherwise, CNXXXX does not drive
                                                          the corresponding PERST*_L pin. */
 	uint64_t rst_rcv                      : 1;  /**< Controls whether PERST*_L is received. A warm/soft reset will not change this field. On
                                                          cold reset, this field is initialized as follows:
-                                                         0 when RST_CTL*[HOST_MODE] = 1
-                                                         1 when RST_CTL*[HOST_MODE] = 0
+                                                         _ 0 when RST_CTL()[HOST_MODE] = 1.
+                                                         _ 1 when RST_CTL()[HOST_MODE] = 0.
                                                          When RST_RCV is equal to 1, the PERST*_L value is received and may be used to reset the
                                                          controller and (optionally, based on RST_CHIP) warm reset the chip.
                                                          When RST_RCV is equal to 1 (and RST_CHIP = 0), RST_INT[PERST*] gets set when the PERST*_L
@@ -408,12 +408,11 @@ union cvmx_rst_int {
 	struct cvmx_rst_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t perst                        : 4;  /**< PERST*_L asserted while RST_CTL*[RST_RCV] = 1 and RST_CTL*[RST_CHIP] = 0. One bit
-                                                         corresponds to each controller. Throws RST_INTSN_E::RST_INT_PERST(0..3). */
+	uint64_t perst                        : 4;  /**< PERST*_L asserted while RST_CTL()[RST_RCV] = 1 and RST_CTL()[RST_CHIP] = 0. One bit
+                                                         corresponds to each controller. */
 	uint64_t reserved_4_7                 : 4;
-	uint64_t rst_link                     : 4;  /**< A controller link-down/hot-reset occurred while RST_CTL*[RST_LINK] = 0. Software must
-                                                         assert then deassert RST_SOFT_PRST*[SOFT_PRST]. One bit corresponds to each controller.
-                                                         Throws RST_INTSN_E::RST_INT_LINK(0..3). */
+	uint64_t rst_link                     : 4;  /**< A controller link-down/hot-reset occurred while RST_CTL()[RST_LINK] = 0. Software must
+                                                         assert then deassert RST_SOFT_PRST()[SOFT_PRST]. One bit corresponds to each controller. */
 #else
 	uint64_t rst_link                     : 4;
 	uint64_t reserved_4_7                 : 4;
@@ -450,9 +449,9 @@ union cvmx_rst_ocx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
 	uint64_t rst_link                     : 3;  /**< Controls whether corresponding OCX link going down causes a chip reset. A warm/soft reset
-                                                         does not change this field. On cold reset, this field is initialized to 0.  See
-                                                         OCX_COM_LINK(0..2)_CTL
-                                                         for a description of what events can contribute to the link_down condition. */
+                                                         does not change this field. On cold reset, this field is initialized to 0. See
+                                                         OCX_COM_LINK()_CTL for a description of what events can contribute to the link_down
+                                                         condition. */
 #else
 	uint64_t rst_link                     : 3;
 	uint64_t reserved_3_63                : 61;
@@ -524,10 +523,10 @@ union cvmx_rst_soft_prstx {
 	uint64_t reserved_1_63                : 63;
 	uint64_t soft_prst                    : 1;  /**< Resets the PCIe logic and corresponding common logic associated with the SLI controller in
                                                          all modes, not just RC mode.
-                                                         * If the RST_CTL*[HOST_MODE] = 0, SOFT_PRST resets to 0.
-                                                         * If the RST_CTL*[HOST_MODE] = 1, SOFT_PRST resets to 1.
+                                                         * If the RST_CTL()[HOST_MODE] = 0, SOFT_PRST resets to 0.
+                                                         * If the RST_CTL()[HOST_MODE] = 1, SOFT_PRST resets to 1.
                                                          When CNXXXX is configured to drive PERST*_L (i.e.
-                                                         RST_CTL(0..3)[RST_DRV] = 1), this controls the output value on PERST*_L. */
+                                                         RST_CTL()[RST_DRV] = 1), this controls the output value on PERST*_L. */
 #else
 	uint64_t soft_prst                    : 1;
 	uint64_t reserved_1_63                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-wqe.h b/arch/mips/include/asm/octeon/cvmx-wqe.h
index ac5538a..9d7f73d 100644
--- a/arch/mips/include/asm/octeon/cvmx-wqe.h
+++ b/arch/mips/include/asm/octeon/cvmx-wqe.h
@@ -725,23 +725,19 @@ typedef union {
 #endif
 } cvmx_pki_wqe_word2_t;
 
-#define CVMX_PKI_LTYPE_NONE 0
-#define CVMX_PKI_LTYPE_IPV4 0x8
-#define CVMX_PKI_LTYPE_IPV6 0xa
-#define CVMX_PKI_LTYPE_TCP 0x10
-#define CVMX_PKI_LTYPE_UDP 0x11
-#define CVMX_PKI_LTYPE_SCTP 0x12
-
-#define CVMX_PKI_ERRLEV_RE 0
-#define CVMX_PKI_ERRLEV_LA 1
-#define CVMX_PKI_ERRLEV_LB 2
-#define CVMX_PKI_ERRLEV_LC 3
-#define CVMX_PKI_ERRLEV_LD 4
-#define CVMX_PKI_ERRLEV_LE 5
-#define CVMX_PKI_ERRLEV_LF 6
-#define CVMX_PKI_ERRLEV_LG 7
-
-#define CVMX_PKI_OPCODE_RE_NONE 0
+#define CVMX_PKI_OPCODE_RE_NONE		0x0
+#define CVMX_PKI_OPCODE_RE_PARTIAL	0x1
+#define CVMX_PKI_OPCODE_RE_JABBER	0x2
+#define CVMX_PKI_OPCODE_RE_FCS		0x7
+#define CVMX_PKI_OPCODE_RE_FCS_RCV	0x8
+#define CVMX_PKI_OPCODE_RE_TERMINATE	0x9
+#define CVMX_PKI_OPCODE_RE_RX_CTL	0xb
+#define CVMX_PKI_OPCODE_RE_SKIP		0xc
+#define CVMX_PKI_OPCODE_RE_DMAPKT	0xf
+#define CVMX_PKI_OPCODE_RE_PKIPAR	0x13
+#define CVMX_PKI_OPCODE_RE_PKIPCAM	0x14
+#define CVMX_PKI_OPCODE_RE_MEMOUT	0x15
+
 
 typedef union {
 	uint64_t u64;
-- 
2.6.2

