From eb5df9209b15d64d2a7c44250f73500a30c98f73 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 1 Nov 2013 14:18:49 -0700
Subject: [PATCH 372/974] mmc: octeon_mmc: Fix error recovery.

Also remove dead code from failed SG dma attempt.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c | 76 +++++++++++++++++--------------------------
 1 file changed, 30 insertions(+), 46 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index ad603a2..f102b05 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -71,6 +71,7 @@ struct octeon_mmc_host {
 	struct platform_device	*pdev;
 	int global_pwr_gpio;
 	bool global_pwr_gpio_low;
+	bool dma_err_pending;
 
 	struct octeon_mmc_slot	*slot[OCTEON_MAX_MMC];
 };
@@ -260,7 +261,6 @@ static void octeon_mmc_dma_next(struct octeon_mmc_host	*host)
 	struct scatterlist *sg;
 	struct mmc_data *data;
 	union cvmx_mio_ndf_dma_cfg dma_cfg;
-	u64 dma_int_en;
 
 	data = host->current_req->data;
 	sg = data->sg + host->sg_idx;
@@ -276,38 +276,7 @@ static void octeon_mmc_dma_next(struct octeon_mmc_host	*host)
 
 	host->sg_idx++;
 
-	if (host->sg_idx >= host->current_req->data->sg_len)
-		dma_int_en = 0;
-	else
-		dma_int_en = 1;
-
-	cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT_EN, dma_int_en);
 	cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG, dma_cfg.u64);
-
-}
-
-static irqreturn_t octeon_mmc_dma_interrupt(int irq, void *dev_id)
-{
-	struct octeon_mmc_host *host = dev_id;
-	unsigned long flags;
-
-	pr_debug("Got interrupt: NDF_DMA_INT\n");
-	spin_lock_irqsave(&host->lock, flags);
-	/* Clear any pending irqs */
-	cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT, 1);
-
-	if (!host->current_req || !host->current_req->data) {
-		dev_err(&host->pdev->dev,
-			"ERROR: no current_req for octeon_mmc_dma_interrupt\n");
-		goto out;
-	}
-
-	if (host->sg_idx < host->current_req->data->sg_len)
-		octeon_mmc_dma_next(host);
-out:
-	spin_unlock_irqrestore(&host->lock, flags);
-
-	return IRQ_RETVAL(1);
 }
 
 static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
@@ -326,12 +295,21 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 
 	pr_debug("Got interrupt: EMM_INT = 0x%llx\n", emm_int.u64);
 
-	if (!req)
+	if (!req) {
+		spin_unlock_irqrestore(&host->lock, flags);
 		goto out;
+	}
 
 	rsp_sts.u64 = cvmx_read_csr(host->base + OCT_MIO_EMM_RSP_STS);
 	pr_debug("octeon_mmc_interrupt  MIO_EMM_RSP_STS 0x%llx\n", rsp_sts.u64);
 
+	if (host->dma_err_pending) {
+		host->current_req = NULL;
+		req->done(req);
+		host_done = true;
+		goto no_req_done;
+	}
+
 	if (!host->dma_active && emm_int.s.buf_done && req->cmd->data &&
 	    ((rsp_sts.u64 >> 7) & 3) == 1) {
 		/* Read */
@@ -370,10 +348,16 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 	host_done = emm_int.s.cmd_done || emm_int.s.dma_done ||
 		emm_int.s.cmd_err || emm_int.s.dma_err;
 	if (host_done && req->done) {
-		if (rsp_sts.u64 & (7ull << 13))
+		if (rsp_sts.s.rsp_bad_sts ||
+		    rsp_sts.s.rsp_crc_err ||
+		    rsp_sts.s.rsp_timeout ||
+		    rsp_sts.s.blk_crc_err ||
+		    rsp_sts.s.blk_timeout ||
+		    rsp_sts.s.dbuf_err) {
 			req->cmd->error = -EILSEQ;
-		else
+		} else {
 			req->cmd->error = 0;
+		}
 
 		if (host->dma_active && req->cmd->data) {
 			req->cmd->data->error = 0;
@@ -409,18 +393,27 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 		}
 		if (emm_int.s.dma_err && rsp_sts.s.dma_pend) {
 			/* Try to clean up failed DMA */
+			union cvmx_mio_ndf_dma_cfg dma_cfg;
 			union cvmx_mio_emm_dma emm_dma;
-			emm_dma.u64 = 0;
+			emm_dma.u64 = cvmx_read_csr(host->base + OCT_MIO_EMM_DMA);
 			emm_dma.s.dma_val = 1;
 			emm_dma.s.dat_null = 1;
 			emm_dma.s.bus_id = rsp_sts.s.bus_id;
 			cvmx_write_csr(host->base + OCT_MIO_EMM_DMA,
 				       emm_dma.u64);
+			dma_cfg.u64 = 0;
+			dma_cfg.s.en = 1;
+			dma_cfg.s.clr = 1;
+			cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG, dma_cfg.u64);
+			host->dma_err_pending = true;
+			host_done = false;
+			goto no_req_done;
 		}
 
 		host->current_req = NULL;
 		req->done(req);
 	}
+no_req_done:
 	spin_unlock_irqrestore(&host->lock, flags);
 	if (host_done)
 		up(&octeon_bootbus_sem);
@@ -635,7 +628,6 @@ static void octeon_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	cvmx_write_csr(host->base + OCT_MIO_EMM_STS_MASK, 0);
 	cvmx_write_csr(host->base + OCT_MIO_EMM_CMD, emm_cmd.u64);
 	pr_debug("Send the command: %llx\n", emm_cmd.u64);
-
 }
 
 static void octeon_mmc_reset_bus(struct octeon_mmc_slot *slot, int preserve)
@@ -951,7 +943,7 @@ static int __init octeon_init_slot(struct octeon_mmc_host *host, int id,
 	mmc->max_blk_size = 512;
 	mmc->max_blk_count = mmc->max_req_size / 512;
 	if (limit_max_blk >= 1)
-		mmc->max_blk_count = min(limit_max_blk, mmc->max_blk_count);
+		mmc->max_blk_count = min_t(unsigned int, limit_max_blk, mmc->max_blk_count);
 
 
 	slot->clock = mmc->f_min;
@@ -1051,14 +1043,6 @@ static int octeon_mmc_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	ret = devm_request_irq(&pdev->dev, dma_irq, octeon_mmc_dma_interrupt,
-			       IRQF_SHARED, DRV_NAME, host);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Error: devm_request_irq %d\n", dma_irq);
-		goto err;
-	}
-
-
 	ret = of_get_named_gpio_flags(node, "power-gpios", 0, &f);
 	if (ret == -EPROBE_DEFER)
 		goto err;
-- 
2.6.2

