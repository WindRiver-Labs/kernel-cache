From 138dc9772febab41b5e8d82e9fe150f3e28d8b5a Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 7 Feb 2014 13:46:59 -0800
Subject: [PATCH 526/974] netdev: octeon3-ethernet: Enable MAC address
 filtering.

Previous code was broken and then commented out.  Fix it and enable
it.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c | 18 ++++++++++--------
 drivers/net/ethernet/octeon/octeon-bgx-port.c  |  6 ++----
 2 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
index ba109b3..6f54faa 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -57,6 +57,16 @@ static int bgx_probe(struct platform_device *pdev)
 	addr = of_translate_address(pdev->dev.of_node, reg);
 	interface = (addr >> 24) & 0xf;
 	numa_node = (addr >> 36) & 0x7;
+
+	__cvmx_helper_packet_hardware_enable(cvmx_helper_node_interface_to_xiface(numa_node, interface));
+	/* Assign 8 CAM entries per LMAC */
+	for (i = 0; i < 32; i++) {
+		union cvmx_bgxx_cmr_rx_adrx_cam adr_cam;
+		adr_cam.u64 = 0;
+		adr_cam.s.id = i >> 3;
+		cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(i, interface), adr_cam.u64);
+	}
+
 	for_each_available_child_of_node(pdev->dev.of_node, child) {
 		if (!of_device_is_compatible(child, "cavium,octeon-7890-bgx-port"))
 			continue;
@@ -81,14 +91,6 @@ static int bgx_probe(struct platform_device *pdev)
 		pki_dev->dev.numa_node = pdev->dev.numa_node;
 #endif
 	}
-	__cvmx_helper_packet_hardware_enable(cvmx_helper_node_interface_to_xiface(numa_node, interface));
-	/* Assign 8 CAM entries per LMAC */
-	for (i = 0; i < 32; i++) {
-		union cvmx_bgxx_cmr_rx_adrx_cam adr_cam;
-		adr_cam.u64 = 0;
-		adr_cam.s.id = i >> 3;
-		cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(i, interface), adr_cam.u64);
-	}
 
 	dev_info(&pdev->dev, "Probed\n");
 	return 0;
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 07cdd5b..a26bcfe 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -85,10 +85,10 @@ static void bgx_port_write_cam(int numa_node, int interface, int index, int cam,
 	u64 m = 0;
 	if (mac)
 		for (i = 0; i < 6; i++)
-			m |= ((u64)mac[i]) << (6 * i);
+			m |= (((u64)mac[i]) << ((5 - i) * 8));
 	adr_cam.u64 = m;
 	adr_cam.s.en = mac ? 1 : 0;
-	adr_cam.s.id = index >> 3;
+	adr_cam.s.id = index;
 	cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(index * 8 + cam, interface), adr_cam.u64);
 }
 
@@ -100,8 +100,6 @@ void bgx_port_set_rx_filtering(struct net_device *netdev)
 	int available_cam_entries, current_cam_entry;
 	struct netdev_hw_addr *ha;
 
-	if(true)
-		return;
 	available_cam_entries = 8;
 	adr_ctl.u64 = 0;
 	adr_ctl.s.bcst_accept = 1; /* Accept all Broadcast*/
-- 
2.6.2

