From e5885ea9d14feb2166c4bdb924fe003e9ab6ae03 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 7 Jul 2014 18:05:50 -0700
Subject: [PATCH 759/974] MIPS: Linux: Update S.E. to r107520 and adjust
 callers.

This gets multi-node Ethernet working much better.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bch.c       |    8 +-
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |    8 +-
 .../cavium-octeon/executive/cvmx-helper-board.c    |    6 +-
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |   41 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |   20 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pko.c |    2 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |   17 +-
 .../cavium-octeon/executive/cvmx-helper-sgmii.c    |    4 +-
 .../cavium-octeon/executive/cvmx-helper-util.c     |    2 +-
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |   26 +-
 .../mips/cavium-octeon/executive/cvmx-pko3-queue.c |   32 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |   45 +-
 arch/mips/cavium-octeon/executive/octeon-feature.c |    1 +
 arch/mips/include/asm/octeon/cvmx-bch-defs.h       |  150 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |  535 ++-
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h       |   44 +-
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |   63 +-
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       |  166 +-
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h       |  706 +++-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |  120 +-
 arch/mips/include/asm/octeon/cvmx-fpa3.h           |    2 +-
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h      |  195 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  867 ++++-
 arch/mips/include/asm/octeon/cvmx-helper-cfg.h     |    4 +-
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       |  179 +-
 arch/mips/include/asm/octeon/cvmx-iobn-defs.h      |   37 +-
 arch/mips/include/asm/octeon/cvmx-iobp-defs.h      |   15 +-
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |  271 +-
 arch/mips/include/asm/octeon/cvmx-lbk-defs.h       |   49 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      | 2598 +++++++++++++--
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  557 +++-
 arch/mips/include/asm/octeon/cvmx-mixx-defs.h      |  129 +-
 arch/mips/include/asm/octeon/cvmx-mpi-defs.h       |   52 +-
 arch/mips/include/asm/octeon/cvmx-ndf-defs.h       |  483 ++-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |   94 +
 arch/mips/include/asm/octeon/cvmx-osm-defs.h       |  255 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |  120 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |  321 +-
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |  264 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      |  202 +-
 arch/mips/include/asm/octeon/cvmx-pexp-defs.h      |   76 +-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  590 +++-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 3116 +++++++++++++++---
 arch/mips/include/asm/octeon/cvmx-pow.h            |   50 +-
 arch/mips/include/asm/octeon/cvmx-rnm-defs.h       |   11 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |  273 +-
 arch/mips/include/asm/octeon/cvmx-sata-defs.h      |  682 +++-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       |  517 +--
 arch/mips/include/asm/octeon/cvmx-smix-defs.h      |   35 +
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |  391 ++-
 arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h   | 3409 ++++++++++++++++----
 arch/mips/include/asm/octeon/octeon-feature.h      |    9 +-
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c     |    9 +-
 drivers/net/ethernet/octeon/octeon3-ethernet.c     |   13 +-
 54 files changed, 15477 insertions(+), 2394 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index 06598d6..832010a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -152,10 +152,10 @@ int cvmx_bch_initialize(void)
 	}
 
 	bch_cmd_buf.u64 = 0;
-	bch_cmd_buf.s.dwb = bch_pool_size / 128;
-	bch_cmd_buf.s.pool = bch_pool;
-	bch_cmd_buf.s.size = bch_pool_size / 8;
-	bch_cmd_buf.s.ptr = cvmx_ptr_to_phys(
+	bch_cmd_buf.cn70xx.dwb = bch_pool_size / 128;
+	bch_cmd_buf.cn70xx.pool = bch_pool;
+	bch_cmd_buf.cn70xx.size = bch_pool_size / 8;
+	bch_cmd_buf.cn70xx.ptr = cvmx_ptr_to_phys(
 		cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_BCH)) >> 7;
 	cvmx_write_csr(CVMX_BCH_CMD_BUF, bch_cmd_buf.u64);
 	cvmx_write_csr(CVMX_BCH_GEN_INT, 7);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 08d15c5..8c07fdd 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -1257,13 +1257,19 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	cvmx_bgxx_spux_status1_t spu_status1;
+	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
+	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
 	cvmx_helper_link_info_t result;
 
 	result.u64 = 0;
 
 	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface));
+	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
+	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, interface));
 
-	if (spu_status1.s.rcv_lnk) {
+	if ((smu_tx_ctl.s.ls == 0)
+	    && (smu_rx_ctl.s.status == 0)
+	    && (spu_status1.s.rcv_lnk)) {
 		int lanes;
 		int qlm = cvmx_qlm_interface(xiface);
 		uint64_t speed;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index 2465fd2..0ce7498 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -822,7 +822,7 @@ int __cvmx_helper_board_get_port_from_dt(void *fdt_addr, int ipd_port)
 	uint32_t *val;
 	int phy_node_offset;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+	if (octeon_has_feature(OCTEON_FEATURE_BGX)) {
 		static int fdt_ports_initialized = 0;
 
 		port_index = cvmx_helper_get_interface_index_num(ipd_port);
@@ -971,7 +971,7 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 	if (dbg)
 		cvmx_dprintf("%s(%p, %d)\n", __func__, phy_info, ipd_port);
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+	if (octeon_has_feature(OCTEON_FEATURE_BGX))
 		return __cvmx_helper_78xx_parse_phy(phy_info, ipd_port);
 
 	if (fdt_addr == 0)
@@ -2125,7 +2125,7 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 	}
 
 	if (phy_info->phy_addr == -1) {
-		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		if (octeon_has_feature(OCTEON_FEATURE_BGX)) {
 			if (__cvmx_helper_78xx_parse_phy(phy_info, ipd_port)) {
 				/*cvmx_dprintf("Error parsing PHY info for 78xx for ipd port %d\n",
 					       ipd_port); */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index fdba105..c670ac3 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -1000,7 +1000,7 @@ int cvmx_pko_alloc_iport_and_queues(int interface, int port, int port_cnt, int q
 }
 EXPORT_SYMBOL(cvmx_pko_alloc_iport_and_queues);
 
-int __cvmx_helper_init_port_config_data(void)
+int __cvmx_helper_init_port_config_data(int node)
 {
 	int rv = 0;
 	int i, j, n;
@@ -1016,31 +1016,28 @@ int __cvmx_helper_init_port_config_data(void)
 		cvmx_printf("%s:\n",__func__);
 
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		int node;
 		/* PKO3: only needs BPID, PKND to be setup,
 		 * while the rest of PKO3 init is done in cvmx-helper-pko3.c
 		 */
-		for (node = 0; node < CVMX_MAX_NODES; node++) {
-			pknd = 0;
-			bpid = 0;
-			for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
-				n = cvmx_helper_interface_enumerate(i);
-				if (cvmx_helper_interface_get_mode(i) !=
-					CVMX_HELPER_INTERFACE_MODE_NPI) {
-					for (j = 0; j < n; j++) {
-						cvmx_cfg_port[node][i][j].ccpp_pknd = pknd++;
-						cvmx_cfg_port[node][i][j].ccpp_bpid = bpid++;
-					}
-				} else {
-					for (j = 0; j < n; j++) {
-						cvmx_cfg_port[node][i][j].ccpp_pknd = pknd;
-						cvmx_cfg_port[node][i][j].ccpp_bpid = bpid;
-					}
-					pknd++;
-					bpid++;
+		pknd = 0;
+		bpid = 0;
+		for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+			int xiface = cvmx_helper_node_interface_to_xiface(node, i);
+			n = cvmx_helper_interface_enumerate(xiface);
+			if (cvmx_helper_interface_get_mode(xiface) != CVMX_HELPER_INTERFACE_MODE_NPI) {
+				for (j = 0; j < n; j++) {
+					cvmx_cfg_port[node][i][j].ccpp_pknd = pknd++;
+					cvmx_cfg_port[node][i][j].ccpp_bpid = bpid++;
 				}
-			} /* for i=0 */
-		}
+			} else {
+				for (j = 0; j < n; j++) {
+					cvmx_cfg_port[node][i][j].ccpp_pknd = pknd;
+					cvmx_cfg_port[node][i][j].ccpp_bpid = bpid;
+				}
+				pknd++;
+				bpid++;
+			}
+		} /* for i=0 */
 		cvmx_helper_cfg_assert(pknd <= CVMX_HELPER_CFG_MAX_PIP_PKND);
 		cvmx_helper_cfg_assert(bpid <= CVMX_HELPER_CFG_MAX_PIP_BPID);
 	} else if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index c69c2bf..a59b7b5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -751,13 +751,16 @@ int __cvmx_helper_pki_qos_rsrcs(int node, struct cvmx_pki_qos_schd *qossch)
 			cvmx_dprintf("aura alloced is %d\n", qossch->aura_num);
 	}
 	/* Reserve sso group resources */
+	/* Find which node work needs to be schedules vinita_to_do to extract node*/
 	if (qossch->sso_grp_per_qos && qossch->sso_grp < 0) {
+		//unsigned grp_node;
+		//grp_node = (abs)(qossch->sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);
 		rs = cvmx_sso_allocate_group(node);
 		if (rs < 0) {
 			cvmx_dprintf("pki-helper:qos-rsrc: ERROR: sso grp not available\n");
 			return rs;
 		}
-		qossch->sso_grp = rs;
+		qossch->sso_grp = rs | (node<<8);
 		if (pki_helper_debug)
 			cvmx_dprintf("pki-helper:qos-rsrc: sso grp alloced is %d\n", qossch->sso_grp);
 	}
@@ -809,14 +812,16 @@ int __cvmx_helper_pki_port_rsrcs(int node, struct cvmx_pki_prt_schd *prtsch)
 		if (pki_helper_debug)
 			cvmx_dprintf("aura alloced is %d\n", prtsch->aura_num);
 	}
-	/* Reserve sso group resources */
+	/* Reserve sso group resources , vinita_to_do to extract node*/
 	if (prtsch->sso_grp_per_prt && prtsch->sso_grp < 0) {
+		//unsigned grp_node;
+		//grp_node = (abs)(prtsch->sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);
 		rs = cvmx_sso_allocate_group(node);
 		if (rs < 0) {
 			cvmx_printf("ERROR: %s: sso grp not available\n", __func__);
 			return rs;
 		}
-		prtsch->sso_grp = rs;
+		prtsch->sso_grp = rs | (node << 8);
 		if (pki_helper_debug)
 			cvmx_dprintf("pki-helper:port-rsrc: sso grp alloced is %d\n", prtsch->sso_grp);
 	}
@@ -869,13 +874,16 @@ int __cvmx_helper_pki_intf_rsrcs(int node, struct cvmx_pki_intf_schd *intf)
 		if (pki_helper_debug)
 			cvmx_dprintf("aura alloced is %d\n", intf->aura_num);
 	}
+	/* vinita_to_do to extract node */
 	if (intf->sso_grp_per_intf && intf->sso_grp < 0) {
+		//unsigned grp_node;
+		//grp_node = (abs)(intf->sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);
 		rs = cvmx_sso_allocate_group(node);
 		if (rs < 0) {
 			cvmx_printf("ERROR: %s: sso grp not available\n", __func__);
 			return rs;
 		}
-		intf->sso_grp = rs;
+		intf->sso_grp = rs | (node << 8);
 	}
 #endif /* CVMX_BUILD_FOR_LINUX_KERNEL */
 	return 0;
@@ -974,12 +982,14 @@ int cvmx_helper_pki_set_gbl_schd(int node, struct cvmx_pki_global_schd *gblsch)
 
 	}
 	if (gblsch->setup_sso_grp) {
+		//unsigned grp_node;
+		//grp_node = (abs)(gblsch->setup_sso_grp + CVMX_PKI_FIND_AVAILABLE_RSRC);/*vinita_to_do to extract node*/
 		rs = cvmx_sso_allocate_group(node);
 		if (rs < 0) {
 			cvmx_dprintf("pki-helper:gbl: ERROR: sso grp not available\n");
 			return rs;
 		}
-		gblsch->sso_grp = rs;
+		gblsch->sso_grp = rs | (node << 8);
 		if (pki_helper_debug)
 			cvmx_dprintf("pki-helper:gbl: sso grp alloced is %d\n", gblsch->sso_grp);
 	}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko.c
index 83acbbf..39df454 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko.c
@@ -181,7 +181,7 @@ int cvmx_helper_pko_init(void)
 	//#	error "Pool number in kernel not implemented"
 #endif
 
-	__cvmx_helper_init_port_config_data();
+	__cvmx_helper_init_port_config_data(0);
 
 	cvmx_pko_hw_init(
 		cvmx_fpa_get_pko_pool(),
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 51537dd..7ef2813 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -111,7 +111,7 @@ static const int cvmx_pko_default_channel_level = 0;
 static const int debug = 0;
 
 /* These global variables are relevant for boot CPU only */
-static cvmx_fpa3_gaura_t __cvmx_pko3_aura;
+static CVMX_SHARED cvmx_fpa3_gaura_t __cvmx_pko3_aura[CVMX_MAX_NODES];
 
 /* This constant can not be modified, defined here for clarity only */
 #define CVMX_PKO3_POOL_BUFFER_SIZE 4096 /* 78XX PKO requires 4KB */
@@ -182,7 +182,7 @@ static int __cvmx_pko3_config_memory(unsigned node)
 	aura_num = aura.node << 10 | aura.laura;
 
 	/* Store handle for destruction */
-	__cvmx_pko3_aura = aura;
+	__cvmx_pko3_aura[node] = aura;
 
 	return aura_num;
 }
@@ -708,7 +708,7 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 	int l2_q_num;
 	int l3_q, l4_q, l5_q;
 	int i, res, res_owner;
-	int xiface;
+	int xiface, ipd_port;
 	int num_dq = 1;	/* # of DQs for NULL */
 	const int dq = 0;	/* Reserve DQ#0 for NULL */
 	const int pko_mac_num = 0x1C; /* MAC# 28 virtual MAC for NULL */
@@ -720,8 +720,10 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 		cvmx_dprintf("%s: null iface dq=%u-%u\n",
 			__FUNCTION__, dq, dq+num_dq-1);
 
+	ipd_port = cvmx_helper_node_to_ipd_port(node, CVMX_PKO3_IPD_PORT_NULL);
+
 	/* Build an identifiable owner identifier by MAC# for easy release */
-	res_owner = __cvmx_helper_pko3_res_owner(CVMX_PKO3_IPD_PORT_NULL);
+	res_owner = __cvmx_helper_pko3_res_owner(ipd_port);
 	if (res_owner < 0) {
 		cvmx_dprintf ("%s: ERROR Invalid interface\n", __FUNCTION__);
 		return -1;
@@ -1115,7 +1117,7 @@ int cvmx_helper_pko3_init_global(unsigned int node)
 	}
 
 	aura_num = res;
-	aura = __cvmx_pko3_aura;
+	aura = __cvmx_pko3_aura[node];
 
 	/* Exercise the FPA to make sure the AURA is functional */
 	ptr = cvmx_fpa3_alloc(aura);
@@ -1182,7 +1184,8 @@ int cvmx_helper_pko3_shut_interface(int xiface)
 	for (index = 0; index < num_ports; index ++) {
 
 		if (__cvmx_helper_xiface_is_null(xiface))
-			ipd_port = CVMX_PKO3_IPD_PORT_NULL;
+                        ipd_port = cvmx_helper_node_to_ipd_port(xi.node,
+				CVMX_PKO3_IPD_PORT_NULL);
 		else
 			ipd_port = cvmx_helper_get_ipd_port(xiface, index);
 
@@ -1300,7 +1303,7 @@ int cvmx_helper_pko3_shutdown(unsigned int node)
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	/* shut down AURA/POOL we created, and free its resources */
-	cvmx_fpa3_shutdown_aura_and_pool(__cvmx_pko3_aura);
+	cvmx_fpa3_shutdown_aura_and_pool(__cvmx_pko3_aura[node]);
 #endif /* CVMX_BUILD_FOR_LINUX_KERNEL */
 	return res;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
index af86375..030c14c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
@@ -43,7 +43,7 @@
  * Functions for SGMII initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 107037 $<hr>
+ * <hr>$Revision: 107438 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -158,7 +158,7 @@ static int __cvmx_helper_need_g15618(void)
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM ||
 	    OCTEON_IS_MODEL(OCTEON_CN63XX) ||
 	    OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_X) ||
-	    OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
+	    OCTEON_IS_MODEL(OCTEON_CN68XX))
 		return 1;
 	else
 		return 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index c8df383..432ec88 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -799,7 +799,7 @@ int __cvmx_helper_setup_gmx(int xiface, int num_ports)
 
 	/* The common BGX settings are already done in the appropriate
 	   enable functions, nothing to do here. */
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+	if (octeon_has_feature(OCTEON_FEATURE_BGX))
 		return 0;
 
 	/* Tell GMX the number of TX ports on this interface */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index 1903eed..6d627a4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -885,19 +885,18 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn68xx(int interface)
 		break;
 
 	case 7:
+	{
+		union cvmx_mio_qlmx_cfg qlm_cfg1;
+		/* Check if PCIe0/PCIe1 is configured for PCIe */
 		qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(3));
+		qlm_cfg1.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(1));
 		/* QLM is disabled when QLM SPD is 15. */
-		if (qlm_cfg.s.qlm_spd == 15) {
-			iface_ops[interface] = &iface_ops_dis;
-		} else if (qlm_cfg.s.qlm_cfg != 0) {
-			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(1));
-			if (qlm_cfg.s.qlm_cfg != 0)
-				iface_ops[interface] = &iface_ops_dis;
-			else
-				iface_ops[interface] = &iface_ops_npi;
-		}
-		else
+		if ((qlm_cfg.s.qlm_spd != 15 && qlm_cfg.s.qlm_cfg == 0)
+                    || (qlm_cfg1.s.qlm_spd != 15 && qlm_cfg1.s.qlm_cfg == 0))
 			iface_ops[interface] = &iface_ops_npi;
+		else
+			iface_ops[interface] = &iface_ops_dis;
+	}
 		break;
 
 	case 8:
@@ -1321,7 +1320,7 @@ static int __cvmx_helper_global_setup_backpressure(void)
 			case CVMX_HELPER_INTERFACE_MODE_SGMII:
 			case CVMX_HELPER_INTERFACE_MODE_QSGMII:
 			case CVMX_HELPER_INTERFACE_MODE_PICMG:
-				if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if (octeon_has_feature(OCTEON_FEATURE_BGX))
 					cvmx_bgx_set_backpressure_override(interface, 0xf);
 				else
 					cvmx_gmx_set_backpressure_override(interface, 0xf);
@@ -1613,7 +1612,7 @@ int cvmx_helper_initialize_packet_io_node(unsigned int node)
 
 	/* PKO3 init precedes that of interfaces */
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		__cvmx_helper_init_port_config_data();
+		__cvmx_helper_init_port_config_data(node);
 		result = cvmx_helper_pko3_init_global(node);
 	}
 	else {
@@ -1948,8 +1947,9 @@ int cvmx_helper_shutdown_packet_io_global(void)
 	int node = cvmx_get_node_num();
 	cvmx_pcsx_mrx_control_reg_t control_reg;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+	if (octeon_has_feature(OCTEON_FEATURE_BGX)) {
 		return __cvmx_helper_shutdown_packet_io_global_cn78xx(node);
+	}
 
 	/* Step 1: Disable all backpressure */
 	for (interface = 0; interface < num_interfaces; interface++) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
index 587861c..fc1f464 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
@@ -198,6 +198,7 @@ int __cvmx_pko3_dq_table_setup(void)
  * in terms of scheduling priority.
  *
  * Note: thus function only populates the node-local translation table.
+ * NOTE: This function would be cleaner if it had a single ipd_port argument
  *
  * @returns 0 on success, -1 on failure.
  */
@@ -205,12 +206,13 @@ int __cvmx_pko3_ipd_dq_register(int xiface, int index,
 		unsigned dq_base, unsigned dq_count)
 {
 	struct cvmx_pko3_dq *dq_table;
-	uint16_t ipd_port;
+	int ipd_port;
 	unsigned i;
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	struct cvmx_xport xp;
 
         if(__cvmx_helper_xiface_is_null(xiface))
-		ipd_port = CVMX_PKO3_IPD_PORT_NULL;
+		ipd_port = cvmx_helper_node_to_ipd_port(xi.node, CVMX_PKO3_IPD_PORT_NULL);
 	else {
 		int p;
 		p = cvmx_helper_get_ipd_port(xiface, index);
@@ -222,15 +224,15 @@ int __cvmx_pko3_ipd_dq_register(int xiface, int index,
 		ipd_port = p;
 	}
 
-
 	xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+
 	i = CVMX_PKO3_SWIZZLE_IPD ^ xp.port;
 
 	/* get per-node table */
 	if(__cvmx_pko3_dq_table == NULL)
 		__cvmx_pko3_dq_table_setup();
 
-	dq_table = __cvmx_pko3_dq_table + CVMX_PKO3_IPD_NUM_MAX * xp.node;
+	dq_table = __cvmx_pko3_dq_table + CVMX_PKO3_IPD_NUM_MAX * xi.node;
 
 	if(debug)
 		cvmx_dprintf("%s: ipd=%#x ix=%#x dq %u cnt %u\n",
@@ -254,20 +256,32 @@ int __cvmx_pko3_ipd_dq_register(int xiface, int index,
  * @INTERNAL
  *
  * Unregister DQs associated with CHAN_E (IPD port)
+ *
+ * NOTE: This function would be cleaner if it had a single ipd_port argument
  */
 int __cvmx_pko3_ipd_dq_unregister(int xiface, int index)
 {
 	struct cvmx_pko3_dq *dq_table;
-	uint16_t ipd_port;
+	int ipd_port;
 	unsigned i;
 	struct cvmx_xport xp;
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
         if(__cvmx_helper_xiface_is_null(xiface))
-		ipd_port = CVMX_PKO3_IPD_PORT_NULL;
-	else
-		ipd_port = cvmx_helper_get_ipd_port(xiface, index);
+		ipd_port = cvmx_helper_node_to_ipd_port(xi.node, CVMX_PKO3_IPD_PORT_NULL);
+	else {
+		int p;
+		p = cvmx_helper_get_ipd_port(xiface, index);
+		if (p < 0) {
+			cvmx_dprintf("ERROR: %s: xiface %#x has no IPD port\n",
+			__func__, xiface);
+			return -1;
+		}
+		ipd_port = p;
+	}
 
 	xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+
 	i = CVMX_PKO3_SWIZZLE_IPD ^ xp.port;
 
 	/* get per-node table */
@@ -275,7 +289,7 @@ int __cvmx_pko3_ipd_dq_unregister(int xiface, int index)
 		__cvmx_pko3_dq_table_setup();
 
 	/* get per-node table */
-	dq_table = __cvmx_pko3_dq_table + CVMX_PKO3_IPD_NUM_MAX * xp.node;
+	dq_table = __cvmx_pko3_dq_table + CVMX_PKO3_IPD_NUM_MAX * xi.node;
 
 	if (dq_table[i].dq_count == 0) {
 		cvmx_dprintf("%s:ipd=%#x already released\n",
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 6bab962..a63622f 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -134,6 +134,9 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 	uint64_t cycles;
 	const unsigned timeout = 100;	/* 100 milliseconds */
 
+	if (node != (aura >> 10))
+		cvmx_dprintf("WARNING: AURA vs PKO node mismatch\n");
+
 	pko_enable.u64 = cvmx_read_csr_node(node, CVMX_PKO_ENABLE);
 	if (pko_enable.s.enable) {
 		cvmx_dprintf("WARNING: %s: PKO already enabled on node %u\n",
@@ -217,7 +220,7 @@ int cvmx_pko3_hw_disable(int node)
 	cvmx_pko_enable_t pko_enable;
 	cvmx_pko_status_t pko_status;
 	uint64_t cycles;
-	const unsigned timeout = 100;	/* 100 milliseconds */
+	const unsigned timeout = 10;	/* 10 milliseconds */
 	unsigned mac_num, fifo, i;
 
 	(void) pko_status;
@@ -298,8 +301,8 @@ int cvmx_pko3_hw_disable(int node)
 	cvmx_write_csr_node(node, CVMX_PKO_DPFI_FLUSH, pko_flush.u64);
 
 	/* Prepare timeout */
-        cycles = cvmx_get_cycle();
-        cycles += cvmx_clock_get_rate(CVMX_CLOCK_CORE)/1000 * timeout;
+	cycles = cvmx_get_cycle();
+	cycles += cvmx_clock_get_rate(CVMX_CLOCK_CORE)/1000 * timeout;
 
 	/* Wait until all pointers have been returned */
 	do {
@@ -308,8 +311,6 @@ int cvmx_pko3_hw_disable(int node)
 			break;
 	} while (!dpfi_status.s.cache_flushed);
 
-
-
 	/* disable PKO buffer manager, should return all buffers to FPA */
 	dpfi_enable.u64 = 0;
 	dpfi_enable.s.enable = 0;
@@ -461,15 +462,6 @@ int cvmx_pko3_dq_query(int node, int dq)
 	return pko_status.s.depth;
 }
 
-static struct cvmx_pko3_mac_s {
-	cvmx_helper_interface_mode_t mac_mode;
-	uint8_t fifo_cnt;
-	uint8_t fifo_id;
-	uint8_t pri;
-	uint8_t spd;
-	uint8_t mac_fifo_cnt;
-} cvmx_pko3_mac_table[ CVMX_PKO_MAX_MACS ];
-
 /*
  * PKO initialization of MACs and FIFOs
  *
@@ -490,10 +482,19 @@ static int cvmx_pko_setup_macs(int node)
 	uint8_t fifo_group_cfg[8];
 	uint8_t fifo_group_spd[8];
 	unsigned fifo_count = 0;
+	struct {
+		cvmx_helper_interface_mode_t mac_mode;
+		uint8_t fifo_cnt;
+		uint8_t fifo_id;
+		uint8_t pri;
+		uint8_t spd;
+		uint8_t mac_fifo_cnt;
+	} cvmx_pko3_mac_table[CVMX_PKO_MAX_MACS];
 
 	/* Initialize FIFO allocation table */
 	memset(&fifo_group_cfg, 0, sizeof(fifo_group_cfg));
 	memset(&fifo_group_spd, 0, sizeof(fifo_group_spd));
+	memset(cvmx_pko3_mac_table, 0, sizeof(cvmx_pko3_mac_table));
 
 	/* Initialize all MACs as disabled */
 	for(mac_num = 0; mac_num < CVMX_PKO_MAX_MACS; mac_num++) {
@@ -505,8 +506,9 @@ static int cvmx_pko_setup_macs(int node)
 	}
 
 	for(interface = 0; interface < num_interfaces; interface ++) {
-		mode = cvmx_helper_interface_get_mode(interface);
-		num_ports = cvmx_helper_interface_enumerate(interface);
+		int xiface =  cvmx_helper_node_interface_to_xiface(node, interface);
+		mode = cvmx_helper_interface_get_mode(xiface);
+		num_ports = cvmx_helper_interface_enumerate(xiface);
 
 		if(mode == CVMX_HELPER_INTERFACE_MODE_DISABLED)
 			continue;
@@ -522,10 +524,10 @@ static int cvmx_pko_setup_macs(int node)
 			int i;
 
 			/* convert interface/port to mac number */
-			i = __cvmx_pko3_get_mac_num(interface, port);
+			i = __cvmx_pko3_get_mac_num(xiface, port);
 			if (i < 0 || i>= CVMX_PKO_MAX_MACS) {
-				cvmx_dprintf("%s: ERROR: interface %d port %d has no MAC\n",
-					__func__, interface, port);
+				cvmx_dprintf("%s: ERROR: interface %d:%u port %d has no MAC\n",
+					     __func__, node, interface, port);
 				continue;
 			}
 
@@ -565,9 +567,8 @@ static int cvmx_pko_setup_macs(int node)
 			}
 
 			if(debug)
-				cvmx_dprintf("%s: intf %u port %u %s "
-					"mac %02u cnt %u spd %u\n",
-				__FUNCTION__, interface, port,
+				cvmx_dprintf("%s: intf %d:%u port %u %s mac %02u cnt %u spd %u\n",
+					     __FUNCTION__, node, interface, port,
 				cvmx_helper_interface_mode_to_string(mode),
 				i, cvmx_pko3_mac_table[i].fifo_cnt,
 				cvmx_pko3_mac_table[i].spd);
diff --git a/arch/mips/cavium-octeon/executive/octeon-feature.c b/arch/mips/cavium-octeon/executive/octeon-feature.c
index ad97437..3dd4c5b 100644
--- a/arch/mips/cavium-octeon/executive/octeon-feature.c
+++ b/arch/mips/cavium-octeon/executive/octeon-feature.c
@@ -141,6 +141,7 @@ void __init octeon_feature_init(void)
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_FAU);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_PKO3);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_HNA);
+	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX_MIX);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_OCX);
 	val = OCTEON_FEATURE_SUCCESS;
diff --git a/arch/mips/include/asm/octeon/cvmx-bch-defs.h b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
index 3837c93..e007d17 100644
--- a/arch/mips/include/asm/octeon/cvmx-bch-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_BCH_BIST_RESULT CVMX_BCH_BIST_RESULT_FUNC()
 static inline uint64_t CVMX_BCH_BIST_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_BCH_BIST_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000080ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_BCH_BIST_RESULT_FUNC(void)
 #define CVMX_BCH_CMD_BUF CVMX_BCH_CMD_BUF_FUNC()
 static inline uint64_t CVMX_BCH_CMD_BUF_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_BCH_CMD_BUF not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000008ull);
 }
@@ -75,10 +75,21 @@ static inline uint64_t CVMX_BCH_CMD_BUF_FUNC(void)
 #define CVMX_BCH_CMD_BUF (CVMX_ADD_IO_SEG(0x0001180071000008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_BCH_CMD_PTR CVMX_BCH_CMD_PTR_FUNC()
+static inline uint64_t CVMX_BCH_CMD_PTR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_BCH_CMD_PTR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180071000020ull);
+}
+#else
+#define CVMX_BCH_CMD_PTR (CVMX_ADD_IO_SEG(0x0001180071000020ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_BCH_CTL CVMX_BCH_CTL_FUNC()
 static inline uint64_t CVMX_BCH_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_BCH_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000000ull);
 }
@@ -86,10 +97,21 @@ static inline uint64_t CVMX_BCH_CTL_FUNC(void)
 #define CVMX_BCH_CTL (CVMX_ADD_IO_SEG(0x0001180071000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_BCH_ECO CVMX_BCH_ECO_FUNC()
+static inline uint64_t CVMX_BCH_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_BCH_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180071000030ull);
+}
+#else
+#define CVMX_BCH_ECO (CVMX_ADD_IO_SEG(0x0001180071000030ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_BCH_ERR_CFG CVMX_BCH_ERR_CFG_FUNC()
 static inline uint64_t CVMX_BCH_ERR_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_BCH_ERR_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180071000010ull);
 }
@@ -118,6 +140,17 @@ static inline uint64_t CVMX_BCH_GEN_INT_EN_FUNC(void)
 #else
 #define CVMX_BCH_GEN_INT_EN (CVMX_ADD_IO_SEG(0x0001180071000090ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_BCH_REG_ERROR CVMX_BCH_REG_ERROR_FUNC()
+static inline uint64_t CVMX_BCH_REG_ERROR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_BCH_REG_ERROR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180071000088ull);
+}
+#else
+#define CVMX_BCH_REG_ERROR (CVMX_ADD_IO_SEG(0x0001180071000088ull))
+#endif
 
 /**
  * cvmx_bch_bist_result
@@ -142,6 +175,7 @@ union cvmx_bch_bist_result {
 	} s;
 	struct cvmx_bch_bist_result_s         cn70xx;
 	struct cvmx_bch_bist_result_s         cn70xxp1;
+	struct cvmx_bch_bist_result_s         cn73xx;
 };
 typedef union cvmx_bch_bist_result cvmx_bch_bist_result_t;
 
@@ -155,6 +189,17 @@ union cvmx_bch_cmd_buf {
 	uint64_t u64;
 	struct cvmx_bch_cmd_buf_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_46_63               : 18;
+	uint64_t size                         : 13; /**< Number of uint64s per command buffer segment. */
+	uint64_t ptr                          : 33; /**< Initial command buffer pointer[39:7] (128B-aligned). */
+#else
+	uint64_t ptr                          : 33;
+	uint64_t size                         : 13;
+	uint64_t reserved_46_63               : 18;
+#endif
+	} s;
+	struct cvmx_bch_cmd_buf_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
 	uint64_t dwb                          : 9;  /**< Number of DontWriteBacks. */
 	uint64_t pool                         : 3;  /**< Free list used to free command buffer segments. */
@@ -167,13 +212,53 @@ union cvmx_bch_cmd_buf {
 	uint64_t dwb                          : 9;
 	uint64_t reserved_58_63               : 6;
 #endif
-	} s;
-	struct cvmx_bch_cmd_buf_s             cn70xx;
-	struct cvmx_bch_cmd_buf_s             cn70xxp1;
+	} cn70xx;
+	struct cvmx_bch_cmd_buf_cn70xx        cn70xxp1;
+	struct cvmx_bch_cmd_buf_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t aura                         : 12; /**< Aura to use when freeing command-buffer segments */
+	uint64_t ldwb                         : 1;  /**< When reading commands that end on cache line boundaries, use load-and-don't write back commands. */
+	uint64_t dfb                          : 1;  /**< Don't free buffers to the FPA. */
+	uint64_t size                         : 13; /**< Number of uint64s per command buffer segment. */
+	uint64_t reserved_0_32                : 33;
+#else
+	uint64_t reserved_0_32                : 33;
+	uint64_t size                         : 13;
+	uint64_t dfb                          : 1;
+	uint64_t ldwb                         : 1;
+	uint64_t aura                         : 12;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_bch_cmd_buf cvmx_bch_cmd_buf_t;
 
 /**
+ * cvmx_bch_cmd_ptr
+ *
+ * This register sets the command-buffer parameters.
+ *
+ */
+union cvmx_bch_cmd_ptr {
+	uint64_t u64;
+	struct cvmx_bch_cmd_ptr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t ptr                          : 35; /**< Initial command-buffer pointer bits <41:7> (128-byte aligned). Overwritten each time the
+                                                         command-buffer segment is exhausted. */
+	uint64_t reserved_0_6                 : 7;
+#else
+	uint64_t reserved_0_6                 : 7;
+	uint64_t ptr                          : 35;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} s;
+	struct cvmx_bch_cmd_ptr_s             cn73xx;
+};
+typedef union cvmx_bch_cmd_ptr cvmx_bch_cmd_ptr_t;
+
+/**
  * cvmx_bch_ctl
  */
 union cvmx_bch_ctl {
@@ -183,12 +268,12 @@ union cvmx_bch_ctl {
 	uint64_t reserved_23_63               : 41;
 	uint64_t free_ena                     : 1;  /**< Enable freeing of command buffers. */
 	uint64_t early_term                   : 4;  /**< Threshold of zero delta interations before declaring early termination.
-                                                         0 will force all iterations to run.  Diagnostic only. */
-	uint64_t one_cmd                      : 1;  /**< Execute a single operation at a time.  Diagnostic only. */
+                                                         0 will force all iterations to run.  For diagnostic use only. */
+	uint64_t one_cmd                      : 1;  /**< Execute a single operation at a time.  For diagnostic use only. */
 	uint64_t erase_disable                : 1;  /**< When ERASE_DISABLE=0, erased blocks bypass the BCH correction.   The 16B result word
                                                          contains an erased block indication.
                                                          A block is considered erased if the number of zeros found in the block (data+ECC) is
-                                                         less than half the ECC level.   For instance, a 2KB block using ECC32 is considered
+                                                         less than half the ECC level.   For instance, a 2 KB block using ECC32 is considered
                                                          erased if few than 16 zeroes are found in the 2048+60 bytes. */
 	uint64_t reserved_6_15                : 10;
 	uint64_t max_read                     : 4;  /**< Maximum number of outstanding data read commands. MAX_READ is a throttle to control IOB
@@ -209,10 +294,29 @@ union cvmx_bch_ctl {
 	} s;
 	struct cvmx_bch_ctl_s                 cn70xx;
 	struct cvmx_bch_ctl_s                 cn70xxp1;
+	struct cvmx_bch_ctl_s                 cn73xx;
 };
 typedef union cvmx_bch_ctl cvmx_bch_ctl_t;
 
 /**
+ * cvmx_bch_eco
+ */
+union cvmx_bch_eco {
+	uint64_t u64;
+	struct cvmx_bch_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_bch_eco_s                 cn73xx;
+};
+typedef union cvmx_bch_eco cvmx_bch_eco_t;
+
+/**
  * cvmx_bch_err_cfg
  */
 union cvmx_bch_err_cfg {
@@ -233,6 +337,7 @@ union cvmx_bch_err_cfg {
 	} s;
 	struct cvmx_bch_err_cfg_s             cn70xx;
 	struct cvmx_bch_err_cfg_s             cn70xxp1;
+	struct cvmx_bch_err_cfg_s             cn73xx;
 };
 typedef union cvmx_bch_err_cfg cvmx_bch_err_cfg_t;
 
@@ -285,4 +390,29 @@ union cvmx_bch_gen_int_en {
 };
 typedef union cvmx_bch_gen_int_en cvmx_bch_gen_int_en_t;
 
+/**
+ * cvmx_bch_reg_error
+ */
+union cvmx_bch_reg_error {
+	uint64_t u64;
+	struct cvmx_bch_reg_error_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_3_63                : 61;
+	uint64_t dat_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the DAT RAM.
+                                                         Throws BCH_INTSN_E::BCH_FIFO_DBE. */
+	uint64_t dat_sbe                      : 1;  /**< An ECC correctable error has occurred in the DAT RAM.
+                                                         Throws BCH_INTSN_E::BCH_FIFO_SBE. */
+	uint64_t doorbell                     : 1;  /**< Error bit indicating a doorbell count has overflowed.
+                                                         Throws BCH_INTSN_E::BCH_FIFO_DOORBELL. */
+#else
+	uint64_t doorbell                     : 1;
+	uint64_t dat_sbe                      : 1;
+	uint64_t dat_dbe                      : 1;
+	uint64_t reserved_3_63                : 61;
+#endif
+	} s;
+	struct cvmx_bch_reg_error_s           cn73xx;
+};
+typedef union cvmx_bch_reg_error cvmx_bch_reg_error_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 971eba2..28dd1d8 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -56,6 +56,7 @@
 static inline uint64_t CVMX_BGXX_CMRX_CONFIG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_CONFIG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -67,6 +68,7 @@ static inline uint64_t CVMX_BGXX_CMRX_CONFIG(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_CMRX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -78,6 +80,7 @@ static inline uint64_t CVMX_BGXX_CMRX_INT(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_BGXX_CMRX_PRT_CBFC_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_PRT_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000408ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -89,6 +92,7 @@ static inline uint64_t CVMX_BGXX_CMRX_PRT_CBFC_CTL(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_CMRX_RX_ADR_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ADR_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000A0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -100,6 +104,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ADR_CTL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_RX_BP_DROP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_DROP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -111,6 +116,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_DROP(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_RX_BP_OFF(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_OFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000090ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -122,6 +128,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_OFF(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_RX_BP_ON(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_ON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000088ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -133,6 +140,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_ON(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_BP_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000A8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -144,6 +152,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_STATUS(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_CMRX_RX_FIFO_LEN(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000C0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -155,6 +164,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_FIFO_LEN(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_RX_ID_MAP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ID_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -166,6 +176,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ID_MAP(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XOFF(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XOFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000B0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -177,6 +188,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XOFF(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XON(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000B8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -188,6 +200,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XON(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -199,6 +212,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long offset, u
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -210,6 +224,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT0(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -221,6 +236,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT1(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -232,6 +248,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT2(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT3(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -243,6 +260,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT3(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT4(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -254,6 +272,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT4(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT5(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -265,6 +284,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT5(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT6(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -276,6 +296,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT6(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT7(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -287,6 +308,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT7(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_STAT8(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -298,6 +320,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT8(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_RX_WEIGHT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_WEIGHT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000098ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -309,6 +332,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_WEIGHT(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_CHANNEL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_CHANNEL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000400ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -320,6 +344,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_CHANNEL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_TX_FIFO_LEN(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000418ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -331,6 +356,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_FIFO_LEN(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMRX_TX_HG2_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_HG2_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000410ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -342,6 +368,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_HG2_STATUS(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_CMRX_TX_OVR_BP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_OVR_BP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000420ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -353,6 +380,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_OVR_BP(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000508ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -364,6 +392,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT0(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000510ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -375,6 +404,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT1(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT10(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT10(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000558ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -386,6 +416,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT10(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT11(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT11(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000560ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -397,6 +428,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT11(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT12(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT12(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000568ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -408,6 +440,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT12(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT13(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT13(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000570ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -419,6 +452,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT13(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT14(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT14(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000578ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -430,6 +464,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT14(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT15(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT15(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000580ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -441,6 +476,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT15(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT16(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT16(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000588ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -452,6 +488,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT16(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT17(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT17(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000590ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -463,6 +500,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT17(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000518ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -474,6 +512,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT2(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT3(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000520ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -485,6 +524,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT3(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT4(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000528ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -496,6 +536,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT4(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT5(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000530ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -507,6 +548,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT5(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT6(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000538ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -518,6 +560,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT6(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT7(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000540ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -529,6 +572,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT7(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT8(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000548ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -540,6 +584,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT8(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMRX_TX_STAT9(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT9(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000550ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -551,6 +596,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT9(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_CMR_BAD(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_BAD(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0001020ull) + ((block_id) & 7) * 0x1000000ull;
@@ -562,6 +608,7 @@ static inline uint64_t CVMX_BGXX_CMR_BAD(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_BIST_STATUS(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000300ull) + ((block_id) & 7) * 0x1000000ull;
@@ -573,6 +620,7 @@ static inline uint64_t CVMX_BGXX_CMR_BIST_STATUS(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_AND(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_AND(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000200ull) + ((block_id) & 7) * 0x1000000ull;
@@ -584,6 +632,7 @@ static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_AND(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_OR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_OR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((block_id) & 7) * 0x1000000ull;
@@ -592,9 +641,21 @@ static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_OR(unsigned long block_id)
 #define CVMX_BGXX_CMR_CHAN_MSK_OR(block_id) (CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((block_id) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_BGXX_CMR_ECO(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2)))))
+		cvmx_warn("CVMX_BGXX_CMR_ECO(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800E0001028ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_BGXX_CMR_ECO(block_id) (CVMX_ADD_IO_SEG(0x00011800E0001028ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_BGXX_CMR_GLOBAL_CONFIG(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_GLOBAL_CONFIG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((block_id) & 7) * 0x1000000ull;
@@ -606,6 +667,7 @@ static inline uint64_t CVMX_BGXX_CMR_GLOBAL_CONFIG(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_MEM_CTRL(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_MEM_CTRL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000018ull) + ((block_id) & 7) * 0x1000000ull;
@@ -617,6 +679,7 @@ static inline uint64_t CVMX_BGXX_CMR_MEM_CTRL(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_MEM_INT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_MEM_INT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000010ull) + ((block_id) & 7) * 0x1000000ull;
@@ -628,6 +691,7 @@ static inline uint64_t CVMX_BGXX_CMR_MEM_INT(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_NXC_ADR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_NXC_ADR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0001018ull) + ((block_id) & 7) * 0x1000000ull;
@@ -639,6 +703,7 @@ static inline uint64_t CVMX_BGXX_CMR_NXC_ADR(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_RX_ADRX_CAM(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 31)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 31)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_ADRX_CAM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000100ull) + (((offset) & 31) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -650,6 +715,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_ADRX_CAM(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_CMR_RX_LMACS(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_LMACS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000308ull) + ((block_id) & 7) * 0x1000000ull;
@@ -661,6 +727,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_LMACS(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_RX_OVR_BP(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_OVR_BP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000318ull) + ((block_id) & 7) * 0x1000000ull;
@@ -672,6 +739,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_OVR_BP(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_CMR_TX_LMACS(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_CMR_TX_LMACS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0001000ull) + ((block_id) & 7) * 0x1000000ull;
@@ -683,6 +751,7 @@ static inline uint64_t CVMX_BGXX_CMR_TX_LMACS(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_GMP_GMI_PRTX_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_PRTX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -694,6 +763,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_PRTX_CFG(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_DECISION(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -705,6 +775,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_DECISION(unsigned long offset, unsi
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -716,6 +787,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -727,6 +799,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_IFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -738,6 +811,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_IFG(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -749,6 +823,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_INT(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_JABBER(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -760,6 +835,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_JABBER(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -771,6 +847,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_GMI_SMACX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_SMACX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038230ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -782,6 +859,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_SMACX(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_APPEND(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -793,6 +871,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_APPEND(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_BURST(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_BURST(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038228ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -804,6 +883,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_BURST(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038270ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -815,6 +895,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_CTL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038500ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -826,6 +907,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_INT(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038240ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -837,6 +919,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038248ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -848,6 +931,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long of
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038238ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -859,6 +943,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long offset
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038258ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -870,6 +955,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038260ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -881,6 +967,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038300ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -892,6 +979,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long offset, uns
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SLOT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SLOT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038220ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -903,6 +991,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SLOT(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038250ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -914,6 +1003,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_THRESH(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -925,6 +1015,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_THRESH(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0039010ull) + ((block_id) & 7) * 0x1000000ull;
@@ -936,6 +1027,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_GMP_GMI_TX_IFG(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_IFG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0039000ull) + ((block_id) & 7) * 0x1000000ull;
@@ -947,6 +1039,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_IFG(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_GMP_GMI_TX_JAM(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_JAM(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0039008ull) + ((block_id) & 7) * 0x1000000ull;
@@ -958,6 +1051,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_JAM(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_GMP_GMI_TX_LFSR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_LFSR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0039028ull) + ((block_id) & 7) * 0x1000000ull;
@@ -969,6 +1063,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_LFSR(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0039018ull) + ((block_id) & 7) * 0x1000000ull;
@@ -980,6 +1075,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long block_i
 static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0039020ull) + ((block_id) & 7) * 0x1000000ull;
@@ -991,6 +1087,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long block_i
 static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_ADV(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1002,6 +1099,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_ADV(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_EXT_ST(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_EXT_ST(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1013,6 +1111,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_EXT_ST(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1024,6 +1123,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_RESULTS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_RESULTS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1035,6 +1135,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_RESULTS(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_INTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_INTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1046,6 +1147,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_INTX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_BGXX_GMP_PCS_LINKX_TIMER(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_LINKX_TIMER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1057,6 +1159,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_LINKX_TIMER(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_MISCX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MISCX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1068,6 +1171,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MISCX_CTL(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1079,6 +1183,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_CONTROL(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1090,6 +1195,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_STATUS(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_STATES(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1101,6 +1207,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_STATES(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_SYNC(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_SYNC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1112,6 +1219,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_SYNC(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1123,6 +1231,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1134,6 +1243,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_GMP_PCS_TXX_STATES(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1145,6 +1255,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TXX_STATES(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1156,6 +1267,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long offset, u
 static inline uint64_t CVMX_BGXX_SMUX_CBFC_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1167,6 +1279,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CBFC_CTL(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SMUX_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020200ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1178,6 +1291,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CTRL(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_BGXX_SMUX_EXT_LOOPBACK(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_EXT_LOOPBACK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020208ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1189,6 +1303,7 @@ static inline uint64_t CVMX_BGXX_SMUX_EXT_LOOPBACK(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_SMUX_HG2_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_HG2_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1200,6 +1315,7 @@ static inline uint64_t CVMX_BGXX_SMUX_HG2_CONTROL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_HI(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_HI(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1211,6 +1327,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_HI(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_LO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_LO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1222,6 +1339,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_LO(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_RX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1233,6 +1351,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_CTL(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_RX_DECISION(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1244,6 +1363,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_DECISION(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CHK(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1255,6 +1375,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CHK(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1266,6 +1387,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CTL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_RX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1277,6 +1399,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_INT(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_RX_JABBER(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1288,6 +1411,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_JABBER(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SMUX_RX_UDD_SKP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1299,6 +1423,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_UDD_SKP(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_SMAC(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_SMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020108ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1310,6 +1435,7 @@ static inline uint64_t CVMX_BGXX_SMUX_SMAC(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_BGXX_SMUX_TX_APPEND(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020100ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1321,6 +1447,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_APPEND(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SMUX_TX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020160ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1332,6 +1459,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_CTL(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_TX_IFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020148ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1343,6 +1471,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_IFG(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_TX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1354,6 +1483,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_INT(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SMUX_TX_MIN_PKT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020118ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1365,6 +1495,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_MIN_PKT(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020150ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1376,6 +1507,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020120ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1387,6 +1519,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long offset
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020110ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1398,6 +1531,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020158ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1409,6 +1543,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_TOGO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1420,6 +1555,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_TOGO(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_ZERO(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1431,6 +1567,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_ZERO(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_TX_SOFT_PAUSE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020128ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1442,6 +1579,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_SOFT_PAUSE(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SMUX_TX_THRESH(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020168ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1453,6 +1591,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_THRESH(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_AN_ADV(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100D8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1464,6 +1603,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_ADV(unsigned long offset, unsigned long
 static inline uint64_t CVMX_BGXX_SPUX_AN_BP_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100F8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1475,6 +1615,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_BP_STATUS(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_SPUX_AN_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100C8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1486,6 +1627,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_CONTROL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_AN_LP_BASE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_BASE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100E0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1497,6 +1639,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_BASE(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_AN_LP_XNP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_XNP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100F0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1508,6 +1651,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_XNP(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_AN_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100D0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1519,6 +1663,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_STATUS(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_AN_XNP_TX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_XNP_TX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100E8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1530,6 +1675,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_XNP_TX(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_BR_ALGN_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_ALGN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1541,6 +1687,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_ALGN_STATUS(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1552,6 +1699,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_SPUX_BR_LANE_MAP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_LANE_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1563,6 +1711,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_LANE_MAP(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1574,6 +1723,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_CONTROL(unsigned long offset, unsig
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_CUP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010088ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1585,6 +1735,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_CUP(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_REP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010090ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1596,6 +1747,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_REP(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_CUP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1607,6 +1759,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_CUP(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_REP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1618,6 +1771,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_REP(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1629,6 +1783,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_STATUS(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1640,6 +1795,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS1(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1651,6 +1807,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS2(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_BR_TP_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1662,6 +1819,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_CONTROL(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BR_TP_ERR_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1673,6 +1831,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_ERR_CNT(unsigned long offset, unsign
 static inline uint64_t CVMX_BGXX_SPUX_BX_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1684,6 +1843,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BX_STATUS(unsigned long offset, unsigned l
 static inline uint64_t CVMX_BGXX_SPUX_CONTROL1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1695,6 +1855,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL1(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SPUX_CONTROL2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1706,6 +1867,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL2(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SPUX_FEC_ABIL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010098ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1717,6 +1879,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_ABIL(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SPUX_FEC_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100A0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1728,6 +1891,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CONTROL(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS01(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100A8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1739,6 +1903,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS01(unsigned long offset, unsi
 static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS23(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100B0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1750,6 +1915,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS23(unsigned long offset, unsi
 static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100B8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1761,6 +1927,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100C0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1772,6 +1939,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(unsigned long offset, un
 static inline uint64_t CVMX_BGXX_SPUX_INT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010220ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1783,6 +1951,7 @@ static inline uint64_t CVMX_BGXX_SPUX_INT(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_BGXX_SPUX_LPCS_STATES(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_LPCS_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010208ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1794,6 +1963,7 @@ static inline uint64_t CVMX_BGXX_SPUX_LPCS_STATES(unsigned long offset, unsigned
 static inline uint64_t CVMX_BGXX_SPUX_MISC_CONTROL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_MISC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1805,6 +1975,7 @@ static inline uint64_t CVMX_BGXX_SPUX_MISC_CONTROL(unsigned long offset, unsigne
 static inline uint64_t CVMX_BGXX_SPUX_SPD_ABIL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_SPD_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1816,6 +1987,7 @@ static inline uint64_t CVMX_BGXX_SPUX_SPD_ABIL(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_BGXX_SPUX_STATUS1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1827,6 +1999,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS1(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_BGXX_SPUX_STATUS2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
@@ -1838,6 +2011,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS2(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_BGXX_SPU_BIST_STATUS(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_SPU_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010318ull) + ((block_id) & 7) * 0x1000000ull;
@@ -1849,6 +2023,7 @@ static inline uint64_t CVMX_BGXX_SPU_BIST_STATUS(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_SPU_DBG_CONTROL(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_SPU_DBG_CONTROL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010300ull) + ((block_id) & 7) * 0x1000000ull;
@@ -1860,6 +2035,7 @@ static inline uint64_t CVMX_BGXX_SPU_DBG_CONTROL(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_SPU_MEM_INT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_SPU_MEM_INT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010310ull) + ((block_id) & 7) * 0x1000000ull;
@@ -1871,6 +2047,7 @@ static inline uint64_t CVMX_BGXX_SPU_MEM_INT(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_SPU_MEM_STATUS(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 5)))))
 		cvmx_warn("CVMX_BGXX_SPU_MEM_STATUS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010308ull) + ((block_id) & 7) * 0x1000000ull;
@@ -1882,6 +2059,7 @@ static inline uint64_t CVMX_BGXX_SPU_MEM_STATUS(unsigned long block_id)
 static inline uint64_t CVMX_BGXX_SPU_SDSX_SKEW_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_SKEW_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010320ull) + (((offset) & 3) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -1893,6 +2071,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_SKEW_STATUS(unsigned long offset, unsi
 static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010340ull) + (((offset) & 3) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -2027,6 +2206,7 @@ union cvmx_bgxx_cmrx_config {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_config_s        cn73xx;
 	struct cvmx_bgxx_cmrx_config_s        cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_config cvmx_bgxx_cmrx_config_t;
@@ -2050,6 +2230,7 @@ union cvmx_bgxx_cmrx_int {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_int_s           cn73xx;
 	struct cvmx_bgxx_cmrx_int_s           cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_int cvmx_bgxx_cmrx_int_t;
@@ -2076,6 +2257,7 @@ union cvmx_bgxx_cmrx_prt_cbfc_ctl {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s  cn73xx;
 	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s  cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_prt_cbfc_ctl cvmx_bgxx_cmrx_prt_cbfc_ctl_t;
@@ -2106,6 +2288,7 @@ union cvmx_bgxx_cmrx_rx_adr_ctl {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_adr_ctl_s    cn73xx;
 	struct cvmx_bgxx_cmrx_rx_adr_ctl_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_adr_ctl cvmx_bgxx_cmrx_rx_adr_ctl_t;
@@ -2128,6 +2311,7 @@ union cvmx_bgxx_cmrx_rx_bp_drop {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_bp_drop_s    cn73xx;
 	struct cvmx_bgxx_cmrx_rx_bp_drop_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_drop cvmx_bgxx_cmrx_rx_bp_drop_t;
@@ -2147,6 +2331,7 @@ union cvmx_bgxx_cmrx_rx_bp_off {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_bp_off_s     cn73xx;
 	struct cvmx_bgxx_cmrx_rx_bp_off_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_off cvmx_bgxx_cmrx_rx_bp_off_t;
@@ -2174,6 +2359,7 @@ union cvmx_bgxx_cmrx_rx_bp_on {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_bp_on_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_bp_on_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_on cvmx_bgxx_cmrx_rx_bp_on_t;
@@ -2194,6 +2380,7 @@ union cvmx_bgxx_cmrx_rx_bp_status {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_bp_status_s  cn73xx;
 	struct cvmx_bgxx_cmrx_rx_bp_status_s  cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_bp_status cvmx_bgxx_cmrx_rx_bp_status_t;
@@ -2212,6 +2399,7 @@ union cvmx_bgxx_cmrx_rx_fifo_len {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_fifo_len_s   cn73xx;
 	struct cvmx_bgxx_cmrx_rx_fifo_len_s   cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_fifo_len cvmx_bgxx_cmrx_rx_fifo_len_t;
@@ -2242,6 +2430,7 @@ union cvmx_bgxx_cmrx_rx_id_map {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_id_map_s     cn73xx;
 	struct cvmx_bgxx_cmrx_rx_id_map_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_id_map cvmx_bgxx_cmrx_rx_id_map_t;
@@ -2263,6 +2452,7 @@ union cvmx_bgxx_cmrx_rx_logl_xoff {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_logl_xoff_s  cn73xx;
 	struct cvmx_bgxx_cmrx_rx_logl_xoff_s  cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_logl_xoff cvmx_bgxx_cmrx_rx_logl_xoff_t;
@@ -2284,6 +2474,7 @@ union cvmx_bgxx_cmrx_rx_logl_xon {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_logl_xon_s   cn73xx;
 	struct cvmx_bgxx_cmrx_rx_logl_xon_s   cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_logl_xon cvmx_bgxx_cmrx_rx_logl_xon_t;
@@ -2302,6 +2493,7 @@ union cvmx_bgxx_cmrx_rx_pause_drop_time {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s cn73xx;
 	struct cvmx_bgxx_cmrx_rx_pause_drop_time_s cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_pause_drop_time cvmx_bgxx_cmrx_rx_pause_drop_time_t;
@@ -2327,6 +2519,7 @@ union cvmx_bgxx_cmrx_rx_stat0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat0_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat0_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat0 cvmx_bgxx_cmrx_rx_stat0_t;
@@ -2349,6 +2542,7 @@ union cvmx_bgxx_cmrx_rx_stat1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat1_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat1_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat1 cvmx_bgxx_cmrx_rx_stat1_t;
@@ -2375,6 +2569,7 @@ union cvmx_bgxx_cmrx_rx_stat2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat2_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat2_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat2 cvmx_bgxx_cmrx_rx_stat2_t;
@@ -2397,6 +2592,7 @@ union cvmx_bgxx_cmrx_rx_stat3 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat3_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat3_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat3 cvmx_bgxx_cmrx_rx_stat3_t;
@@ -2422,6 +2618,7 @@ union cvmx_bgxx_cmrx_rx_stat4 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat4_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat4_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat4 cvmx_bgxx_cmrx_rx_stat4_t;
@@ -2444,6 +2641,7 @@ union cvmx_bgxx_cmrx_rx_stat5 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat5_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat5_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat5 cvmx_bgxx_cmrx_rx_stat5_t;
@@ -2468,6 +2666,7 @@ union cvmx_bgxx_cmrx_rx_stat6 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat6_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat6_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat6 cvmx_bgxx_cmrx_rx_stat6_t;
@@ -2490,6 +2689,7 @@ union cvmx_bgxx_cmrx_rx_stat7 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat7_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat7_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat7 cvmx_bgxx_cmrx_rx_stat7_t;
@@ -2529,6 +2729,7 @@ union cvmx_bgxx_cmrx_rx_stat8 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_stat8_s      cn73xx;
 	struct cvmx_bgxx_cmrx_rx_stat8_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_stat8 cvmx_bgxx_cmrx_rx_stat8_t;
@@ -2549,6 +2750,7 @@ union cvmx_bgxx_cmrx_rx_weight {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_rx_weight_s     cn73xx;
 	struct cvmx_bgxx_cmrx_rx_weight_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_rx_weight cvmx_bgxx_cmrx_rx_weight_t;
@@ -2573,6 +2775,7 @@ union cvmx_bgxx_cmrx_tx_channel {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_channel_s    cn73xx;
 	struct cvmx_bgxx_cmrx_tx_channel_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_channel cvmx_bgxx_cmrx_tx_channel_t;
@@ -2595,6 +2798,7 @@ union cvmx_bgxx_cmrx_tx_fifo_len {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_fifo_len_s   cn73xx;
 	struct cvmx_bgxx_cmrx_tx_fifo_len_s   cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_fifo_len cvmx_bgxx_cmrx_tx_fifo_len_t;
@@ -2618,6 +2822,7 @@ union cvmx_bgxx_cmrx_tx_hg2_status {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_hg2_status_s cn73xx;
 	struct cvmx_bgxx_cmrx_tx_hg2_status_s cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_hg2_status cvmx_bgxx_cmrx_tx_hg2_status_t;
@@ -2638,6 +2843,7 @@ union cvmx_bgxx_cmrx_tx_ovr_bp {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_ovr_bp_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_ovr_bp_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_ovr_bp cvmx_bgxx_cmrx_tx_ovr_bp_t;
@@ -2659,6 +2865,7 @@ union cvmx_bgxx_cmrx_tx_stat0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat0_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat0_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat0 cvmx_bgxx_cmrx_tx_stat0_t;
@@ -2680,6 +2887,7 @@ union cvmx_bgxx_cmrx_tx_stat1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat1_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat1_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat1 cvmx_bgxx_cmrx_tx_stat1_t;
@@ -2694,8 +2902,7 @@ union cvmx_bgxx_cmrx_tx_stat10 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist4                        : 48; /**< Number of packets sent with an octet count between 256-511. Packet length is the sum of
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
-                                                         FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
-                                                         EXTEND cycles.
+                                                         FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2703,6 +2910,7 @@ union cvmx_bgxx_cmrx_tx_stat10 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat10_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat10_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat10 cvmx_bgxx_cmrx_tx_stat10_t;
@@ -2717,8 +2925,7 @@ union cvmx_bgxx_cmrx_tx_stat11 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist5                        : 48; /**< Number of packets sent with an octet count between 512-1023. Packet length is the sum of
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
-                                                         FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
-                                                         EXTEND cycles.
+                                                         FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2726,6 +2933,7 @@ union cvmx_bgxx_cmrx_tx_stat11 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat11_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat11_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat11 cvmx_bgxx_cmrx_tx_stat11_t;
@@ -2740,8 +2948,7 @@ union cvmx_bgxx_cmrx_tx_stat12 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist6                        : 48; /**< Number of packets sent with an octet count between 1024-1518. Packet length is the sum of
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
-                                                         FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
-                                                         EXTEND cycles.
+                                                         FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2749,6 +2956,7 @@ union cvmx_bgxx_cmrx_tx_stat12 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat12_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat12_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat12 cvmx_bgxx_cmrx_tx_stat12_t;
@@ -2763,8 +2971,7 @@ union cvmx_bgxx_cmrx_tx_stat13 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist7                        : 48; /**< Number of packets sent with an octet count > 1518. Packet length is the sum of all data
                                                          transmitted on the wire for the given packet including packet data, pad bytes, FCS bytes,
-                                                         PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
-                                                         cycles.
+                                                         and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2772,6 +2979,7 @@ union cvmx_bgxx_cmrx_tx_stat13 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat13_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat13_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat13 cvmx_bgxx_cmrx_tx_stat13_t;
@@ -2784,7 +2992,8 @@ union cvmx_bgxx_cmrx_tx_stat14 {
 	struct cvmx_bgxx_cmrx_tx_stat14_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t bcst                         : 48; /**< Number of packets sent to broadcast DMAC. Does not include MCST packets.
+	uint64_t bcst                         : 48; /**< Number of packets sent to broadcast DMAC, excluding PAUSE or PFC control packets generated
+                                                         by BGX. Does not include MCST packets.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap.
                                                          Note that BGX determines if the packet is MCST or BCST from the DMAC of the packet. BGX
                                                          assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
@@ -2796,6 +3005,7 @@ union cvmx_bgxx_cmrx_tx_stat14 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat14_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat14_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat14 cvmx_bgxx_cmrx_tx_stat14_t;
@@ -2808,7 +3018,8 @@ union cvmx_bgxx_cmrx_tx_stat15 {
 	struct cvmx_bgxx_cmrx_tx_stat15_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t mcst                         : 48; /**< Number of packets sent to multicast DMAC. Does not include BCST packets.
+	uint64_t mcst                         : 48; /**< Number of packets sent to multicast DMAC, excluding PAUSE or PFC control packets generated
+                                                         by BGX. Does not include BCST packets.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap.
                                                          Note that BGX determines if the packet is MCST or BCST from the DMAC of the packet. BGX
                                                          assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
@@ -2820,6 +3031,7 @@ union cvmx_bgxx_cmrx_tx_stat15 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat15_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat15_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat15 cvmx_bgxx_cmrx_tx_stat15_t;
@@ -2840,6 +3052,7 @@ union cvmx_bgxx_cmrx_tx_stat16 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat16_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat16_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat16 cvmx_bgxx_cmrx_tx_stat16_t;
@@ -2852,10 +3065,9 @@ union cvmx_bgxx_cmrx_tx_stat17 {
 	struct cvmx_bgxx_cmrx_tx_stat17_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t ctl                          : 48; /**< Number of control packets (PAUSE flow control) generated by BGX. It does not include
-                                                         control packets forwarded or generated by the cores.
-                                                         CTL counts the number of generated PFC frames and does not track the number of generated
-                                                         HG2 messages.
+	uint64_t ctl                          : 48; /**< Number of PAUSE or PFC control packets generated by BGX. It does not include control
+                                                         packets forwarded or generated by the cores. Does not track the number of generated HG2
+                                                         messages.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2863,6 +3075,7 @@ union cvmx_bgxx_cmrx_tx_stat17 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat17_s     cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat17_s     cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat17 cvmx_bgxx_cmrx_tx_stat17_t;
@@ -2884,6 +3097,7 @@ union cvmx_bgxx_cmrx_tx_stat2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat2_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat2_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat2 cvmx_bgxx_cmrx_tx_stat2_t;
@@ -2904,6 +3118,7 @@ union cvmx_bgxx_cmrx_tx_stat3 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat3_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat3_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat3 cvmx_bgxx_cmrx_tx_stat3_t;
@@ -2916,11 +3131,12 @@ union cvmx_bgxx_cmrx_tx_stat4 {
 	struct cvmx_bgxx_cmrx_tx_stat4_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t octs                         : 48; /**< Number of total octets sent on the interface. Does not count octets from frames that were
-                                                         truncated due to collisions in half-duplex mode.
+	uint64_t octs                         : 48; /**< Number of total octets sent on the interface, excluding PAUSE or PFC control packets
+                                                         generated by BGX. Does not count octets from frames that were truncated due to collisions
+                                                         in half-duplex mode.
                                                          Octet counts are the sum of all data transmitted on the wire including packet data, pad
-                                                         bytes, FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE
-                                                         byte or EXTEND cycles.
+                                                         bytes, FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
+                                                         cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2928,6 +3144,7 @@ union cvmx_bgxx_cmrx_tx_stat4 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat4_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat4_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat4 cvmx_bgxx_cmrx_tx_stat4_t;
@@ -2940,8 +3157,9 @@ union cvmx_bgxx_cmrx_tx_stat5 {
 	struct cvmx_bgxx_cmrx_tx_stat5_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t pkts                         : 48; /**< Number of total frames sent on the interface. Does not count octets from frames that were
-                                                         truncated due to collisions in half-duplex mode.
+	uint64_t pkts                         : 48; /**< Number of total frames sent on the interface, excluding PAUSE or PFC control packets
+                                                         generated by BGX. Does not count octets from frames that were truncated due to collisions
+                                                         in half-duplex mode.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2949,6 +3167,7 @@ union cvmx_bgxx_cmrx_tx_stat5 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat5_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat5_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat5 cvmx_bgxx_cmrx_tx_stat5_t;
@@ -2961,10 +3180,10 @@ union cvmx_bgxx_cmrx_tx_stat6 {
 	struct cvmx_bgxx_cmrx_tx_stat6_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t hist0                        : 48; /**< Number of packets sent with an octet count < 64. Packet length is the sum of all data
-                                                         transmitted on the wire for the given packet including packet data, pad bytes, FCS bytes,
-                                                         PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
-                                                         cycles.
+	uint64_t hist0                        : 48; /**< Number of packets sent with an octet count < 64, excluding PAUSE or PFC control packets
+                                                         generated by BGX. Packet length is the sum of all data transmitted on the wire for the
+                                                         given packet including packet data, pad bytes, FCS bytes, and JAM bytes. The octet counts
+                                                         do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2972,6 +3191,7 @@ union cvmx_bgxx_cmrx_tx_stat6 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat6_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat6_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat6 cvmx_bgxx_cmrx_tx_stat6_t;
@@ -2984,10 +3204,10 @@ union cvmx_bgxx_cmrx_tx_stat7 {
 	struct cvmx_bgxx_cmrx_tx_stat7_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t hist1                        : 48; /**< Number of packets sent with an octet count of 64. Packet length is the sum of all data
-                                                         transmitted on the wire for the given packet including packet data, pad bytes, FCS bytes,
-                                                         PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
-                                                         cycles.
+	uint64_t hist1                        : 48; /**< Number of packets sent with an octet count of 64, excluding PAUSE or PFC control packets
+                                                         generated by BGX. Packet length is the sum of all data transmitted on the wire for the
+                                                         given packet including packet data, pad bytes, FCS bytes, and JAM bytes. The octet counts
+                                                         do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -2995,6 +3215,7 @@ union cvmx_bgxx_cmrx_tx_stat7 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat7_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat7_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat7 cvmx_bgxx_cmrx_tx_stat7_t;
@@ -3009,8 +3230,7 @@ union cvmx_bgxx_cmrx_tx_stat8 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist2                        : 48; /**< Number of packets sent with an octet count between 65-127. Packet length is the sum of all
                                                          data transmitted on the wire for the given packet including packet data, pad bytes, FCS
-                                                         bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
-                                                         cycles.
+                                                         bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -3018,6 +3238,7 @@ union cvmx_bgxx_cmrx_tx_stat8 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat8_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat8_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat8 cvmx_bgxx_cmrx_tx_stat8_t;
@@ -3032,8 +3253,7 @@ union cvmx_bgxx_cmrx_tx_stat9 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t hist3                        : 48; /**< Number of packets sent with an octet count between 128-255. Packet length is the sum of
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
-                                                         FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
-                                                         EXTEND cycles.
+                                                         FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                          disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
@@ -3041,6 +3261,7 @@ union cvmx_bgxx_cmrx_tx_stat9 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_cmrx_tx_stat9_s      cn73xx;
 	struct cvmx_bgxx_cmrx_tx_stat9_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmrx_tx_stat9 cvmx_bgxx_cmrx_tx_stat9_t;
@@ -3059,6 +3280,7 @@ union cvmx_bgxx_cmr_bad {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_bad_s            cn73xx;
 	struct cvmx_bgxx_cmr_bad_s            cn78xx;
 };
 typedef union cvmx_bgxx_cmr_bad cvmx_bgxx_cmr_bad_t;
@@ -3094,6 +3316,7 @@ union cvmx_bgxx_cmr_bist_status {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_bist_status_s    cn73xx;
 	struct cvmx_bgxx_cmr_bist_status_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmr_bist_status cvmx_bgxx_cmr_bist_status_t;
@@ -3119,6 +3342,7 @@ union cvmx_bgxx_cmr_chan_msk_and {
 	uint64_t msk_and                      : 64;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_chan_msk_and_s   cn73xx;
 	struct cvmx_bgxx_cmr_chan_msk_and_s   cn78xx;
 };
 typedef union cvmx_bgxx_cmr_chan_msk_and cvmx_bgxx_cmr_chan_msk_and_t;
@@ -3144,11 +3368,30 @@ union cvmx_bgxx_cmr_chan_msk_or {
 	uint64_t msk_or                       : 64;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_chan_msk_or_s    cn73xx;
 	struct cvmx_bgxx_cmr_chan_msk_or_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmr_chan_msk_or cvmx_bgxx_cmr_chan_msk_or_t;
 
 /**
+ * cvmx_bgx#_cmr_eco
+ */
+union cvmx_bgxx_cmr_eco {
+	uint64_t u64;
+	struct cvmx_bgxx_cmr_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t eco_ro                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t eco_ro                       : 32;
+#endif
+	} s;
+	struct cvmx_bgxx_cmr_eco_s            cn73xx;
+};
+typedef union cvmx_bgxx_cmr_eco cvmx_bgxx_cmr_eco_t;
+
+/**
  * cvmx_bgx#_cmr_global_config
  *
  * These registers configure the global CMR, PCS, and MAC.
@@ -3158,6 +3401,54 @@ union cvmx_bgxx_cmr_global_config {
 	uint64_t u64;
 	struct cvmx_bgxx_cmr_global_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_6_63                : 58;
+	uint64_t bgx_rgmii_enable             : 1;  /**< For LMAC0, enables the RGMII interface and disables the SGMII interface on both the
+                                                         transmit and recieve paths. */
+	uint64_t cmr_mix1_reset               : 1;  /**< If the MIX1 block is reset, software also needs to reset the MIX interface in the BGX by
+                                                         setting this bit to 1. It resets the MIX interface state in the BGX (mix FIFO and pending
+                                                         requests to MIX) and prevents the RXB FIFOs for all LMACs from pushing data to the
+                                                         interface. Setting this bit to 0 will not reset the MIX interface. After MIX comes out of
+                                                         reset, software should clear CMR_MIX_RESET. */
+	uint64_t cmr_mix0_reset               : 1;  /**< If the MIX0 block is reset, software also needs to reset the MIX interface in the BGX by
+                                                         setting this bit to 1. It resets the MIX interface state in the BGX (mix FIFO and pending
+                                                         requests to MIX) and prevents the RXB FIFOs for all LMACs from pushing data to the
+                                                         interface. Setting this bit to 0 will not reset the MIX interface. After MIX comes out of
+                                                         reset, software should clear CMR_MIX_RESET. */
+	uint64_t cmr_x2p_reset                : 1;  /**< If the PKI block is reset, software also needs to reset the X2P interface in the BGX by
+                                                         setting this bit to 1. It resets the X2P interface state in the BGX (skid FIFO and pending
+                                                         requests to PKI) and prevents the RXB FIFOs for all LMACs from pushing data to the
+                                                         interface. Setting this bit to 0 does not reset the X2P interface. After PKI comes out of
+                                                         reset, software should clear CMR_X2P_RESET. */
+	uint64_t bgx_clk_enable               : 1;  /**< The global clock enable for BGX. Setting this bit overrides clock enables set by
+                                                         BGX()_CMR()_CONFIG[ENABLE] and BGX()_CMR()_CONFIG[LMAC_TYPE], essentially
+                                                         turning on clocks for the entire BGX. Setting this bit to 0 results in not overriding
+                                                         clock enables set by BGX()_CMR()_CONFIG[ENABLE] and
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE]. */
+	uint64_t pmux_sds_sel                 : 1;  /**< SerDes/QLM output select. Specifies which QLM output is selected as the BGX input, as
+                                                         follows:
+                                                         <pre>
+                                                           Block   PMUX_SDS_SEL=0  PMUX_SDS_SEL=1
+                                                           --------------------------------------
+                                                           BGX0:   QLM0            QLM2
+                                                           BGX1:   QLM1            QLM3
+                                                           BGX2:   QLM4            N/A
+                                                           BGX3:   QLM5            N/A
+                                                           BGX4:   QLM6            N/A
+                                                           BGX5:   QLM7            N/A
+                                                         </pre> */
+#else
+	uint64_t pmux_sds_sel                 : 1;
+	uint64_t bgx_clk_enable               : 1;
+	uint64_t cmr_x2p_reset                : 1;
+	uint64_t cmr_mix0_reset               : 1;
+	uint64_t cmr_mix1_reset               : 1;
+	uint64_t bgx_rgmii_enable             : 1;
+	uint64_t reserved_6_63                : 58;
+#endif
+	} s;
+	struct cvmx_bgxx_cmr_global_config_s  cn73xx;
+	struct cvmx_bgxx_cmr_global_config_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t cmr_mix1_reset               : 1;  /**< If the MIX1 block is reset, software also needs to reset the MIX interface in the BGX by
                                                          setting this bit to 1. It resets the MIX interface state in the BGX (mix FIFO and pending
@@ -3199,8 +3490,7 @@ union cvmx_bgxx_cmr_global_config {
 	uint64_t cmr_mix1_reset               : 1;
 	uint64_t reserved_5_63                : 59;
 #endif
-	} s;
-	struct cvmx_bgxx_cmr_global_config_s  cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_bgxx_cmr_global_config cvmx_bgxx_cmr_global_config_t;
 
@@ -3248,6 +3538,7 @@ union cvmx_bgxx_cmr_mem_ctrl {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_mem_ctrl_s       cn73xx;
 	struct cvmx_bgxx_cmr_mem_ctrl_s       cn78xx;
 };
 typedef union cvmx_bgxx_cmr_mem_ctrl cvmx_bgxx_cmr_mem_ctrl_t;
@@ -3300,6 +3591,7 @@ union cvmx_bgxx_cmr_mem_int {
 	uint64_t reserved_18_63               : 46;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_mem_int_s        cn73xx;
 	struct cvmx_bgxx_cmr_mem_int_s        cn78xx;
 };
 typedef union cvmx_bgxx_cmr_mem_int cvmx_bgxx_cmr_mem_int_t;
@@ -3320,6 +3612,7 @@ union cvmx_bgxx_cmr_nxc_adr {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_nxc_adr_s        cn73xx;
 	struct cvmx_bgxx_cmr_nxc_adr_s        cn78xx;
 };
 typedef union cvmx_bgxx_cmr_nxc_adr cvmx_bgxx_cmr_nxc_adr_t;
@@ -3360,6 +3653,7 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_rx_adrx_cam_s    cn73xx;
 	struct cvmx_bgxx_cmr_rx_adrx_cam_s    cn78xx;
 };
 typedef union cvmx_bgxx_cmr_rx_adrx_cam cvmx_bgxx_cmr_rx_adrx_cam_t;
@@ -3389,6 +3683,7 @@ union cvmx_bgxx_cmr_rx_lmacs {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_rx_lmacs_s       cn73xx;
 	struct cvmx_bgxx_cmr_rx_lmacs_s       cn78xx;
 };
 typedef union cvmx_bgxx_cmr_rx_lmacs cvmx_bgxx_cmr_rx_lmacs_t;
@@ -3425,6 +3720,7 @@ union cvmx_bgxx_cmr_rx_ovr_bp {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_rx_ovr_bp_s      cn73xx;
 	struct cvmx_bgxx_cmr_rx_ovr_bp_s      cn78xx;
 };
 typedef union cvmx_bgxx_cmr_rx_ovr_bp cvmx_bgxx_cmr_rx_ovr_bp_t;
@@ -3457,6 +3753,7 @@ union cvmx_bgxx_cmr_tx_lmacs {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_bgxx_cmr_tx_lmacs_s       cn73xx;
 	struct cvmx_bgxx_cmr_tx_lmacs_s       cn78xx;
 };
 typedef union cvmx_bgxx_cmr_tx_lmacs cvmx_bgxx_cmr_tx_lmacs_t;
@@ -3504,6 +3801,7 @@ union cvmx_bgxx_gmp_gmi_prtx_cfg {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_prtx_cfg_s   cn73xx;
 	struct cvmx_bgxx_gmp_gmi_prtx_cfg_s   cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_prtx_cfg cvmx_bgxx_gmp_gmi_prtx_cfg_t;
@@ -3549,6 +3847,7 @@ union cvmx_bgxx_gmp_gmi_rxx_decision {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_decision_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_decision_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_decision cvmx_bgxx_gmp_gmi_rxx_decision_t;
@@ -3581,6 +3880,7 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_chk {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_frm_chk_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_chk_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_frm_chk cvmx_bgxx_gmp_gmi_rxx_frm_chk_t;
@@ -3675,6 +3975,7 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_frm_ctl cvmx_bgxx_gmp_gmi_rxx_frm_ctl_t;
@@ -3701,6 +4002,7 @@ union cvmx_bgxx_gmp_gmi_rxx_ifg {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_ifg_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_ifg_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_ifg cvmx_bgxx_gmp_gmi_rxx_ifg_t;
@@ -3816,6 +4118,7 @@ union cvmx_bgxx_gmp_gmi_rxx_int {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_int_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_int_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_int cvmx_bgxx_gmp_gmi_rxx_int_t;
@@ -3839,6 +4142,7 @@ union cvmx_bgxx_gmp_gmi_rxx_jabber {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_jabber_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_jabber_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_jabber cvmx_bgxx_gmp_gmi_rxx_jabber_t;
@@ -3898,6 +4202,7 @@ union cvmx_bgxx_gmp_gmi_rxx_udd_skp {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_rxx_udd_skp_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_rxx_udd_skp_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_rxx_udd_skp cvmx_bgxx_gmp_gmi_rxx_udd_skp_t;
@@ -3916,6 +4221,7 @@ union cvmx_bgxx_gmp_gmi_smacx {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_smacx_s      cn73xx;
 	struct cvmx_bgxx_gmp_gmi_smacx_s      cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_smacx cvmx_bgxx_gmp_gmi_smacx_t;
@@ -3940,6 +4246,7 @@ union cvmx_bgxx_gmp_gmi_txx_append {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_append_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_append_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_append cvmx_bgxx_gmp_gmi_txx_append_t;
@@ -3962,6 +4269,7 @@ union cvmx_bgxx_gmp_gmi_txx_burst {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_burst_s  cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_burst_s  cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_burst cvmx_bgxx_gmp_gmi_txx_burst_t;
@@ -3984,6 +4292,7 @@ union cvmx_bgxx_gmp_gmi_txx_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_ctl_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_ctl_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_ctl cvmx_bgxx_gmp_gmi_txx_ctl_t;
@@ -4010,6 +4319,7 @@ union cvmx_bgxx_gmp_gmi_txx_int {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_int_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_int_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_int cvmx_bgxx_gmp_gmi_txx_int_t;
@@ -4031,6 +4341,7 @@ union cvmx_bgxx_gmp_gmi_txx_min_pkt {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_min_pkt_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_min_pkt_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_min_pkt cvmx_bgxx_gmp_gmi_txx_min_pkt_t;
@@ -4072,6 +4383,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_t;
@@ -4093,6 +4405,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_t;
@@ -4111,6 +4424,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_togo {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_togo_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_togo_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_togo cvmx_bgxx_gmp_gmi_txx_pause_togo_t;
@@ -4130,6 +4444,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_zero {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_pause_zero_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_pause_zero_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_pause_zero cvmx_bgxx_gmp_gmi_txx_pause_zero_t;
@@ -4158,6 +4473,7 @@ union cvmx_bgxx_gmp_gmi_txx_sgmii_ctl {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_sgmii_ctl cvmx_bgxx_gmp_gmi_txx_sgmii_ctl_t;
@@ -4179,6 +4495,7 @@ union cvmx_bgxx_gmp_gmi_txx_slot {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_slot_s   cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_slot_s   cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_slot cvmx_bgxx_gmp_gmi_txx_slot_t;
@@ -4197,6 +4514,7 @@ union cvmx_bgxx_gmp_gmi_txx_soft_pause {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_soft_pause cvmx_bgxx_gmp_gmi_txx_soft_pause_t;
@@ -4222,6 +4540,7 @@ union cvmx_bgxx_gmp_gmi_txx_thresh {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_txx_thresh_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_txx_thresh_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_txx_thresh cvmx_bgxx_gmp_gmi_txx_thresh_t;
@@ -4240,6 +4559,7 @@ union cvmx_bgxx_gmp_gmi_tx_col_attempt {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_col_attempt_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_col_attempt_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_col_attempt cvmx_bgxx_gmp_gmi_tx_col_attempt_t;
@@ -4272,6 +4592,7 @@ union cvmx_bgxx_gmp_gmi_tx_ifg {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_ifg_s     cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_ifg_s     cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_ifg cvmx_bgxx_gmp_gmi_tx_ifg_t;
@@ -4293,6 +4614,7 @@ union cvmx_bgxx_gmp_gmi_tx_jam {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_jam_s     cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_jam_s     cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_jam cvmx_bgxx_gmp_gmi_tx_jam_t;
@@ -4315,6 +4637,7 @@ union cvmx_bgxx_gmp_gmi_tx_lfsr {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_lfsr_s    cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_lfsr_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_lfsr cvmx_bgxx_gmp_gmi_tx_lfsr_t;
@@ -4333,6 +4656,7 @@ union cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac cvmx_bgxx_gmp_gmi_tx_pause_pkt_dmac_t;
@@ -4354,6 +4678,7 @@ union cvmx_bgxx_gmp_gmi_tx_pause_pkt_type {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_s cn73xx;
 	struct cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_gmi_tx_pause_pkt_type cvmx_bgxx_gmp_gmi_tx_pause_pkt_type_t;
@@ -4395,6 +4720,7 @@ union cvmx_bgxx_gmp_pcs_anx_adv {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_anx_adv_s    cn73xx;
 	struct cvmx_bgxx_gmp_pcs_anx_adv_s    cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_adv cvmx_bgxx_gmp_pcs_anx_adv_t;
@@ -4421,6 +4747,7 @@ union cvmx_bgxx_gmp_pcs_anx_ext_st {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_anx_ext_st_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_anx_ext_st_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_ext_st cvmx_bgxx_gmp_pcs_anx_ext_st_t;
@@ -4466,6 +4793,7 @@ union cvmx_bgxx_gmp_pcs_anx_lp_abil {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_anx_lp_abil_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_lp_abil cvmx_bgxx_gmp_pcs_anx_lp_abil_t;
@@ -4506,6 +4834,7 @@ union cvmx_bgxx_gmp_pcs_anx_results {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_anx_results_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_anx_results_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_anx_results cvmx_bgxx_gmp_pcs_anx_results_t;
@@ -4558,6 +4887,7 @@ union cvmx_bgxx_gmp_pcs_intx {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_intx_s       cn73xx;
 	struct cvmx_bgxx_gmp_pcs_intx_s       cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_intx cvmx_bgxx_gmp_pcs_intx_t;
@@ -4581,6 +4911,7 @@ union cvmx_bgxx_gmp_pcs_linkx_timer {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_linkx_timer_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_linkx_timer_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_linkx_timer cvmx_bgxx_gmp_pcs_linkx_timer_t;
@@ -4645,6 +4976,7 @@ union cvmx_bgxx_gmp_pcs_miscx_ctl {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s  cn73xx;
 	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s  cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_miscx_ctl cvmx_bgxx_gmp_pcs_miscx_ctl_t;
@@ -4715,6 +5047,7 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_mrx_control_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_mrx_control_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_mrx_control cvmx_bgxx_gmp_pcs_mrx_control_t;
@@ -4779,6 +5112,7 @@ union cvmx_bgxx_gmp_pcs_mrx_status {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_mrx_status_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_mrx_status_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_mrx_status cvmx_bgxx_gmp_pcs_mrx_status_t;
@@ -4807,6 +5141,7 @@ union cvmx_bgxx_gmp_pcs_rxx_states {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_rxx_states_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_rxx_states_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_rxx_states cvmx_bgxx_gmp_pcs_rxx_states_t;
@@ -4827,6 +5162,7 @@ union cvmx_bgxx_gmp_pcs_rxx_sync {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_rxx_sync_s   cn73xx;
 	struct cvmx_bgxx_gmp_pcs_rxx_sync_s   cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_rxx_sync cvmx_bgxx_gmp_pcs_rxx_sync_t;
@@ -4867,6 +5203,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_an_adv {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_sgmx_an_adv_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_sgmx_an_adv_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_sgmx_an_adv cvmx_bgxx_gmp_pcs_sgmx_an_adv_t;
@@ -4902,6 +5239,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_lp_adv {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_sgmx_lp_adv_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_sgmx_lp_adv_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_sgmx_lp_adv cvmx_bgxx_gmp_pcs_sgmx_lp_adv_t;
@@ -4927,6 +5265,7 @@ union cvmx_bgxx_gmp_pcs_txx_states {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_txx_states_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_txx_states_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_txx_states cvmx_bgxx_gmp_pcs_txx_states_t;
@@ -4960,6 +5299,7 @@ union cvmx_bgxx_gmp_pcs_tx_rxx_polarity {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_gmp_pcs_tx_rxx_polarity_s cn73xx;
 	struct cvmx_bgxx_gmp_pcs_tx_rxx_polarity_s cn78xx;
 };
 typedef union cvmx_bgxx_gmp_pcs_tx_rxx_polarity cvmx_bgxx_gmp_pcs_tx_rxx_polarity_t;
@@ -4996,6 +5336,7 @@ union cvmx_bgxx_smux_cbfc_ctl {
 	uint64_t phys_en                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_cbfc_ctl_s      cn73xx;
 	struct cvmx_bgxx_smux_cbfc_ctl_s      cn78xx;
 };
 typedef union cvmx_bgxx_smux_cbfc_ctl cvmx_bgxx_smux_cbfc_ctl_t;
@@ -5018,6 +5359,7 @@ union cvmx_bgxx_smux_ctrl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_ctrl_s          cn73xx;
 	struct cvmx_bgxx_smux_ctrl_s          cn78xx;
 };
 typedef union cvmx_bgxx_smux_ctrl cvmx_bgxx_smux_ctrl_t;
@@ -5043,6 +5385,7 @@ union cvmx_bgxx_smux_ext_loopback {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_ext_loopback_s  cn73xx;
 	struct cvmx_bgxx_smux_ext_loopback_s  cn78xx;
 };
 typedef union cvmx_bgxx_smux_ext_loopback cvmx_bgxx_smux_ext_loopback_t;
@@ -5095,6 +5438,7 @@ union cvmx_bgxx_smux_hg2_control {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_hg2_control_s   cn73xx;
 	struct cvmx_bgxx_smux_hg2_control_s   cn78xx;
 };
 typedef union cvmx_bgxx_smux_hg2_control cvmx_bgxx_smux_hg2_control_t;
@@ -5118,6 +5462,7 @@ union cvmx_bgxx_smux_rx_bad_col_hi {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_bad_col_hi_s cn73xx;
 	struct cvmx_bgxx_smux_rx_bad_col_hi_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_bad_col_hi cvmx_bgxx_smux_rx_bad_col_hi_t;
@@ -5135,6 +5480,7 @@ union cvmx_bgxx_smux_rx_bad_col_lo {
 	uint64_t lane_rxd                     : 64;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_bad_col_lo_s cn73xx;
 	struct cvmx_bgxx_smux_rx_bad_col_lo_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_bad_col_lo cvmx_bgxx_smux_rx_bad_col_lo_t;
@@ -5157,6 +5503,7 @@ union cvmx_bgxx_smux_rx_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_ctl_s        cn73xx;
 	struct cvmx_bgxx_smux_rx_ctl_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_ctl cvmx_bgxx_smux_rx_ctl_t;
@@ -5181,6 +5528,7 @@ union cvmx_bgxx_smux_rx_decision {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_decision_s   cn73xx;
 	struct cvmx_bgxx_smux_rx_decision_s   cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_decision cvmx_bgxx_smux_rx_decision_t;
@@ -5214,6 +5562,7 @@ union cvmx_bgxx_smux_rx_frm_chk {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_frm_chk_s    cn73xx;
 	struct cvmx_bgxx_smux_rx_frm_chk_s    cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_frm_chk cvmx_bgxx_smux_rx_frm_chk_t;
@@ -5285,6 +5634,7 @@ union cvmx_bgxx_smux_rx_frm_ctl {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_frm_ctl_s    cn73xx;
 	struct cvmx_bgxx_smux_rx_frm_ctl_s    cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_frm_ctl cvmx_bgxx_smux_rx_frm_ctl_t;
@@ -5346,6 +5696,7 @@ union cvmx_bgxx_smux_rx_int {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_int_s        cn73xx;
 	struct cvmx_bgxx_smux_rx_int_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_int cvmx_bgxx_smux_rx_int_t;
@@ -5378,6 +5729,7 @@ union cvmx_bgxx_smux_rx_jabber {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_jabber_s     cn73xx;
 	struct cvmx_bgxx_smux_rx_jabber_s     cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_jabber cvmx_bgxx_smux_rx_jabber_t;
@@ -5434,6 +5786,7 @@ union cvmx_bgxx_smux_rx_udd_skp {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_rx_udd_skp_s    cn73xx;
 	struct cvmx_bgxx_smux_rx_udd_skp_s    cn78xx;
 };
 typedef union cvmx_bgxx_smux_rx_udd_skp cvmx_bgxx_smux_rx_udd_skp_t;
@@ -5452,6 +5805,7 @@ union cvmx_bgxx_smux_smac {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_smac_s          cn73xx;
 	struct cvmx_bgxx_smux_smac_s          cn78xx;
 };
 typedef union cvmx_bgxx_smux_smac cvmx_bgxx_smux_smac_t;
@@ -5481,6 +5835,7 @@ union cvmx_bgxx_smux_tx_append {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_append_s     cn73xx;
 	struct cvmx_bgxx_smux_tx_append_s     cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_append cvmx_bgxx_smux_tx_append_t;
@@ -5527,6 +5882,63 @@ union cvmx_bgxx_smux_tx_ctl {
                                                          1 = Local fault. RS layer sends continuous remote fault sequences.
                                                          2 = Remote fault. RS layer sends continuous idle sequences.
                                                          3 = Link drain. RS layer drops full packets to allow BGX and PKO to drain their FIFOs. */
+	uint64_t reserved_3_3                 : 1;
+	uint64_t x4a_dis                      : 1;  /**< Disable 4-byte SOP align (effectively force 8-byte SOP align) for all 10G variants
+                                                         (XAUI, RXAUI, 10G). */
+	uint64_t uni_en                       : 1;  /**< Enable unidirectional mode (IEEE Clause 66). */
+	uint64_t dic_en                       : 1;  /**< Enable the deficit idle counter for IFG averaging. */
+#else
+	uint64_t dic_en                       : 1;
+	uint64_t uni_en                       : 1;
+	uint64_t x4a_dis                      : 1;
+	uint64_t reserved_3_3                 : 1;
+	uint64_t ls                           : 2;
+	uint64_t ls_byp                       : 1;
+	uint64_t l2p_bp_conv                  : 1;
+	uint64_t hg_en                        : 1;
+	uint64_t hg_pause_hgi                 : 2;
+	uint64_t spu_mrk_cnt                  : 20;
+	uint64_t reserved_31_63               : 33;
+#endif
+	} s;
+	struct cvmx_bgxx_smux_tx_ctl_s        cn73xx;
+	struct cvmx_bgxx_smux_tx_ctl_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_31_63               : 33;
+	uint64_t spu_mrk_cnt                  : 20; /**< 40GBASE-R transmit marker interval count. Specifies the interval (number of 66-bit BASE-R
+                                                         blocks) at which the LMAC transmit logic inserts 40GBASE-R alignment markers. An internal
+                                                         counter in SMU is initialized to this value, counts down for each BASE-R block transmitted
+                                                         by the LMAC, and wraps back to the initial value from 0. The LMAC transmit logic inserts
+                                                         alignment markers for lanes 0, 1, 2 and 3, respectively, in the last four BASE-R blocks
+                                                         before the counter wraps (3, 2, 1, 0). The default value corresponds to an alignment
+                                                         marker period of 16363 blocks (exclusive) per lane, as specified in 802.3ba-2010. The
+                                                         default value should always be used for normal operation. */
+	uint64_t hg_pause_hgi                 : 2;  /**< HGI field for hardware-generated HiGig PAUSE packets. */
+	uint64_t hg_en                        : 1;  /**< Enable HiGig mode.
+                                                         When this field is set and BGX()_SMU()_RX_UDD_SKP[LEN] = 12, the interface is in
+                                                         HiGig/HiGig+ mode and the following must be set:
+                                                         * BGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 0.
+                                                         * BGX()_SMU()_RX_UDD_SKP[FCSSEL] = 0.
+                                                         * BGX()_SMU()_RX_UDD_SKP[LEN] = 12.
+                                                         * BGX()_SMU()_TX_APPEND[PREAMBLE] = 0.
+                                                         When this field is set and BGX()_SMU()_RX_UDD_SKP[LEN] = 16, the interface is in
+                                                         HiGig2 mode and the following must be set:
+                                                         * BGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 0.
+                                                         * BGX()_SMU()_RX_UDD_SKP[FCSSEL] = 0.
+                                                         * BGX()_SMU()_RX_UDD_SKP[LEN] = 16.
+                                                         * BGX()_SMU()_TX_APPEND[PREAMBLE] = 0.
+                                                         * BGX()_SMU()_CBFC_CTL[RX_EN] = 0.
+                                                         * BGX()_SMU()_CBFC_CTL[TX_EN] = 0. */
+	uint64_t l2p_bp_conv                  : 1;  /**< If set, causes TX to generate 802.3 pause packets when CMR applies logical backpressure
+                                                         (XOFF), if and only if BGX()_SMU()_CBFC_CTL[TX_EN] is clear and
+                                                         BGX()_SMU()_HG2_CONTROL[HG2TX_EN] is clear. */
+	uint64_t ls_byp                       : 1;  /**< Bypass the link status, as determined by the XGMII receiver, and set the link status of
+                                                         the transmitter to LS. */
+	uint64_t ls                           : 2;  /**< Link status.
+                                                         0 = Link OK; link runs normally. RS passes MAC data to PCS.
+                                                         1 = Local fault. RS layer sends continuous remote fault sequences.
+                                                         2 = Remote fault. RS layer sends continuous idle sequences.
+                                                         3 = Link drain. RS layer drops full packets to allow BGX and PKO to drain their FIFOs. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t uni_en                       : 1;  /**< Enable unidirectional mode (IEEE Clause 66). */
 	uint64_t dic_en                       : 1;  /**< Enable the deficit idle counter for IFG averaging. */
@@ -5542,8 +5954,7 @@ union cvmx_bgxx_smux_tx_ctl {
 	uint64_t spu_mrk_cnt                  : 20;
 	uint64_t reserved_31_63               : 33;
 #endif
-	} s;
-	struct cvmx_bgxx_smux_tx_ctl_s        cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_ctl cvmx_bgxx_smux_tx_ctl_t;
 
@@ -5569,6 +5980,7 @@ union cvmx_bgxx_smux_tx_ifg {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_ifg_s        cn73xx;
 	struct cvmx_bgxx_smux_tx_ifg_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_ifg cvmx_bgxx_smux_tx_ifg_t;
@@ -5596,6 +6008,7 @@ union cvmx_bgxx_smux_tx_int {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_int_s        cn73xx;
 	struct cvmx_bgxx_smux_tx_int_s        cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_int cvmx_bgxx_smux_tx_int_t;
@@ -5616,6 +6029,7 @@ union cvmx_bgxx_smux_tx_min_pkt {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_min_pkt_s    cn73xx;
 	struct cvmx_bgxx_smux_tx_min_pkt_s    cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_min_pkt cvmx_bgxx_smux_tx_min_pkt_t;
@@ -5637,6 +6051,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_dmac {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_pkt_dmac_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_dmac_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_dmac cvmx_bgxx_smux_tx_pause_pkt_dmac_t;
@@ -5668,6 +6083,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_interval {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_pkt_interval_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_interval_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_interval cvmx_bgxx_smux_tx_pause_pkt_interval_t;
@@ -5689,6 +6105,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_time {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_pkt_time_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_time_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_time cvmx_bgxx_smux_tx_pause_pkt_time_t;
@@ -5710,6 +6127,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_type {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_pkt_type_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_pkt_type_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_pkt_type cvmx_bgxx_smux_tx_pause_pkt_type_t;
@@ -5731,6 +6149,7 @@ union cvmx_bgxx_smux_tx_pause_togo {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_togo_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_togo_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_togo cvmx_bgxx_smux_tx_pause_togo_t;
@@ -5750,6 +6169,7 @@ union cvmx_bgxx_smux_tx_pause_zero {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_pause_zero_s cn73xx;
 	struct cvmx_bgxx_smux_tx_pause_zero_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_pause_zero cvmx_bgxx_smux_tx_pause_zero_t;
@@ -5768,6 +6188,7 @@ union cvmx_bgxx_smux_tx_soft_pause {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_soft_pause_s cn73xx;
 	struct cvmx_bgxx_smux_tx_soft_pause_s cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_soft_pause cvmx_bgxx_smux_tx_soft_pause_t;
@@ -5794,6 +6215,7 @@ union cvmx_bgxx_smux_tx_thresh {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_bgxx_smux_tx_thresh_s     cn73xx;
 	struct cvmx_bgxx_smux_tx_thresh_s     cn78xx;
 };
 typedef union cvmx_bgxx_smux_tx_thresh cvmx_bgxx_smux_tx_thresh_t;
@@ -5857,6 +6279,7 @@ union cvmx_bgxx_spux_an_adv {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_adv_s        cn73xx;
 	struct cvmx_bgxx_spux_an_adv_s        cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_adv cvmx_bgxx_spux_an_adv_t;
@@ -5898,6 +6321,7 @@ union cvmx_bgxx_spux_an_bp_status {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_bp_status_s  cn73xx;
 	struct cvmx_bgxx_spux_an_bp_status_s  cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_bp_status cvmx_bgxx_spux_an_bp_status_t;
@@ -5937,6 +6361,7 @@ union cvmx_bgxx_spux_an_control {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_control_s    cn73xx;
 	struct cvmx_bgxx_spux_an_control_s    cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_control cvmx_bgxx_spux_an_control_t;
@@ -5993,6 +6418,7 @@ union cvmx_bgxx_spux_an_lp_base {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_lp_base_s    cn73xx;
 	struct cvmx_bgxx_spux_an_lp_base_s    cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_lp_base cvmx_bgxx_spux_an_lp_base_t;
@@ -6026,6 +6452,7 @@ union cvmx_bgxx_spux_an_lp_xnp {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_lp_xnp_s     cn73xx;
 	struct cvmx_bgxx_spux_an_lp_xnp_s     cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_lp_xnp cvmx_bgxx_spux_an_lp_xnp_t;
@@ -6080,6 +6507,7 @@ union cvmx_bgxx_spux_an_status {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_status_s     cn73xx;
 	struct cvmx_bgxx_spux_an_status_s     cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_status cvmx_bgxx_spux_an_status_t;
@@ -6124,6 +6552,7 @@ union cvmx_bgxx_spux_an_xnp_tx {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_an_xnp_tx_s     cn73xx;
 	struct cvmx_bgxx_spux_an_xnp_tx_s     cn78xx;
 };
 typedef union cvmx_bgxx_spux_an_xnp_tx cvmx_bgxx_spux_an_xnp_tx_t;
@@ -6163,6 +6592,7 @@ union cvmx_bgxx_spux_br_algn_status {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_algn_status_s cn73xx;
 	struct cvmx_bgxx_spux_br_algn_status_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_algn_status cvmx_bgxx_spux_br_algn_status_t;
@@ -6198,6 +6628,7 @@ union cvmx_bgxx_spux_br_bip_err_cnt {
 	uint64_t bip_err_cnt_ln3              : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_bip_err_cnt_s cn73xx;
 	struct cvmx_bgxx_spux_br_bip_err_cnt_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_bip_err_cnt cvmx_bgxx_spux_br_bip_err_cnt_t;
@@ -6243,6 +6674,7 @@ union cvmx_bgxx_spux_br_lane_map {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_lane_map_s   cn73xx;
 	struct cvmx_bgxx_spux_br_lane_map_s   cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_lane_map cvmx_bgxx_spux_br_lane_map_t;
@@ -6266,6 +6698,7 @@ union cvmx_bgxx_spux_br_pmd_control {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_control_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_control_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_control cvmx_bgxx_spux_br_pmd_control_t;
@@ -6309,6 +6742,7 @@ union cvmx_bgxx_spux_br_pmd_ld_cup {
 	uint64_t ln3_cup                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_ld_cup_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_ld_cup_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_ld_cup cvmx_bgxx_spux_br_pmd_ld_cup_t;
@@ -6349,6 +6783,7 @@ union cvmx_bgxx_spux_br_pmd_ld_rep {
 	uint64_t ln3_rep                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_ld_rep_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_ld_rep_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_ld_rep cvmx_bgxx_spux_br_pmd_ld_rep_t;
@@ -6385,6 +6820,7 @@ union cvmx_bgxx_spux_br_pmd_lp_cup {
 	uint64_t ln3_cup                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_lp_cup_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_lp_cup_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_lp_cup cvmx_bgxx_spux_br_pmd_lp_cup_t;
@@ -6421,6 +6857,7 @@ union cvmx_bgxx_spux_br_pmd_lp_rep {
 	uint64_t ln3_rep                      : 16;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_lp_rep_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_lp_rep_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_lp_rep cvmx_bgxx_spux_br_pmd_lp_rep_t;
@@ -6452,6 +6889,7 @@ union cvmx_bgxx_spux_br_pmd_status {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_pmd_status_s cn73xx;
 	struct cvmx_bgxx_spux_br_pmd_status_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_pmd_status cvmx_bgxx_spux_br_pmd_status_t;
@@ -6495,6 +6933,7 @@ union cvmx_bgxx_spux_br_status1 {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_status1_s    cn73xx;
 	struct cvmx_bgxx_spux_br_status1_s    cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_status1 cvmx_bgxx_spux_br_status1_t;
@@ -6562,6 +7001,7 @@ union cvmx_bgxx_spux_br_status2 {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_status2_s    cn73xx;
 	struct cvmx_bgxx_spux_br_status2_s    cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_status2 cvmx_bgxx_spux_br_status2_t;
@@ -6602,6 +7042,7 @@ union cvmx_bgxx_spux_br_tp_control {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_tp_control_s cn73xx;
 	struct cvmx_bgxx_spux_br_tp_control_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_tp_control cvmx_bgxx_spux_br_tp_control_t;
@@ -6631,6 +7072,7 @@ union cvmx_bgxx_spux_br_tp_err_cnt {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_br_tp_err_cnt_s cn73xx;
 	struct cvmx_bgxx_spux_br_tp_err_cnt_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_br_tp_err_cnt cvmx_bgxx_spux_br_tp_err_cnt_t;
@@ -6660,6 +7102,7 @@ union cvmx_bgxx_spux_bx_status {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_bx_status_s     cn73xx;
 	struct cvmx_bgxx_spux_bx_status_s     cn78xx;
 };
 typedef union cvmx_bgxx_spux_bx_status cvmx_bgxx_spux_bx_status_t;
@@ -6717,6 +7160,7 @@ union cvmx_bgxx_spux_control1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_control1_s      cn73xx;
 	struct cvmx_bgxx_spux_control1_s      cn78xx;
 };
 typedef union cvmx_bgxx_spux_control1 cvmx_bgxx_spux_control1_t;
@@ -6750,6 +7194,7 @@ union cvmx_bgxx_spux_control2 {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_control2_s      cn73xx;
 	struct cvmx_bgxx_spux_control2_s      cn78xx;
 };
 typedef union cvmx_bgxx_spux_control2 cvmx_bgxx_spux_control2_t;
@@ -6772,6 +7217,7 @@ union cvmx_bgxx_spux_fec_abil {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_abil_s      cn73xx;
 	struct cvmx_bgxx_spux_fec_abil_s      cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_abil cvmx_bgxx_spux_fec_abil_t;
@@ -6800,6 +7246,7 @@ union cvmx_bgxx_spux_fec_control {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_control_s   cn73xx;
 	struct cvmx_bgxx_spux_fec_control_s   cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_control cvmx_bgxx_spux_fec_control_t;
@@ -6837,6 +7284,7 @@ union cvmx_bgxx_spux_fec_corr_blks01 {
 	uint64_t ln1_corr_blks                : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_corr_blks01_s cn73xx;
 	struct cvmx_bgxx_spux_fec_corr_blks01_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_corr_blks01 cvmx_bgxx_spux_fec_corr_blks01_t;
@@ -6869,6 +7317,7 @@ union cvmx_bgxx_spux_fec_corr_blks23 {
 	uint64_t ln3_corr_blks                : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_corr_blks23_s cn73xx;
 	struct cvmx_bgxx_spux_fec_corr_blks23_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_corr_blks23 cvmx_bgxx_spux_fec_corr_blks23_t;
@@ -6906,6 +7355,7 @@ union cvmx_bgxx_spux_fec_uncorr_blks01 {
 	uint64_t ln1_uncorr_blks              : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_uncorr_blks01_s cn73xx;
 	struct cvmx_bgxx_spux_fec_uncorr_blks01_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_uncorr_blks01 cvmx_bgxx_spux_fec_uncorr_blks01_t;
@@ -6938,6 +7388,7 @@ union cvmx_bgxx_spux_fec_uncorr_blks23 {
 	uint64_t ln3_uncorr_blks              : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_fec_uncorr_blks23_s cn73xx;
 	struct cvmx_bgxx_spux_fec_uncorr_blks23_s cn78xx;
 };
 typedef union cvmx_bgxx_spux_fec_uncorr_blks23 cvmx_bgxx_spux_fec_uncorr_blks23_t;
@@ -7024,6 +7475,7 @@ union cvmx_bgxx_spux_int {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_int_s           cn73xx;
 	struct cvmx_bgxx_spux_int_s           cn78xx;
 };
 typedef union cvmx_bgxx_spux_int cvmx_bgxx_spux_int_t;
@@ -7052,6 +7504,7 @@ union cvmx_bgxx_spux_lpcs_states {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_lpcs_states_s   cn73xx;
 	struct cvmx_bgxx_spux_lpcs_states_s   cn78xx;
 };
 typedef union cvmx_bgxx_spux_lpcs_states cvmx_bgxx_spux_lpcs_states_t;
@@ -7124,6 +7577,7 @@ union cvmx_bgxx_spux_misc_control {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_misc_control_s  cn73xx;
 	struct cvmx_bgxx_spux_misc_control_s  cn78xx;
 };
 typedef union cvmx_bgxx_spux_misc_control cvmx_bgxx_spux_misc_control_t;
@@ -7148,6 +7602,7 @@ union cvmx_bgxx_spux_spd_abil {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_spd_abil_s      cn73xx;
 	struct cvmx_bgxx_spux_spd_abil_s      cn78xx;
 };
 typedef union cvmx_bgxx_spux_spd_abil cvmx_bgxx_spux_spd_abil_t;
@@ -7185,6 +7640,7 @@ union cvmx_bgxx_spux_status1 {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_status1_s       cn73xx;
 	struct cvmx_bgxx_spux_status1_s       cn78xx;
 };
 typedef union cvmx_bgxx_spux_status1 cvmx_bgxx_spux_status1_t;
@@ -7226,6 +7682,7 @@ union cvmx_bgxx_spux_status2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_bgxx_spux_status2_s       cn73xx;
 	struct cvmx_bgxx_spux_status2_s       cn78xx;
 };
 typedef union cvmx_bgxx_spux_status2 cvmx_bgxx_spux_status2_t;
@@ -7248,6 +7705,7 @@ union cvmx_bgxx_spu_bist_status {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_bist_status_s    cn73xx;
 	struct cvmx_bgxx_spu_bist_status_s    cn78xx;
 };
 typedef union cvmx_bgxx_spu_bist_status cvmx_bgxx_spu_bist_status_t;
@@ -7365,6 +7823,7 @@ union cvmx_bgxx_spu_dbg_control {
 	uint64_t reserved_56_63               : 8;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_dbg_control_s    cn73xx;
 	struct cvmx_bgxx_spu_dbg_control_s    cn78xx;
 };
 typedef union cvmx_bgxx_spu_dbg_control cvmx_bgxx_spu_dbg_control_t;
@@ -7387,6 +7846,7 @@ union cvmx_bgxx_spu_mem_int {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_mem_int_s        cn73xx;
 	struct cvmx_bgxx_spu_mem_int_s        cn78xx;
 };
 typedef union cvmx_bgxx_spu_mem_int cvmx_bgxx_spu_mem_int_t;
@@ -7411,6 +7871,7 @@ union cvmx_bgxx_spu_mem_status {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_mem_status_s     cn73xx;
 	struct cvmx_bgxx_spu_mem_status_s     cn78xx;
 };
 typedef union cvmx_bgxx_spu_mem_status cvmx_bgxx_spu_mem_status_t;
@@ -7432,6 +7893,7 @@ union cvmx_bgxx_spu_sdsx_skew_status {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_sdsx_skew_status_s cn73xx;
 	struct cvmx_bgxx_spu_sdsx_skew_status_s cn78xx;
 };
 typedef union cvmx_bgxx_spu_sdsx_skew_status cvmx_bgxx_spu_sdsx_skew_status_t;
@@ -7489,6 +7951,7 @@ union cvmx_bgxx_spu_sdsx_states {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_bgxx_spu_sdsx_states_s    cn73xx;
 	struct cvmx_bgxx_spu_sdsx_states_s    cn78xx;
 };
 typedef union cvmx_bgxx_spu_sdsx_states cvmx_bgxx_spu_sdsx_states_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index ca48ab7..7145bbe 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -217,6 +217,7 @@ static inline uint64_t CVMX_CIU_DINT_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000720ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 			break;
 	}
@@ -243,6 +244,7 @@ static inline uint64_t CVMX_CIU_DINT_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000720ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000720ull);
@@ -437,6 +439,7 @@ static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000728ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 			break;
 	}
@@ -463,6 +466,7 @@ static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000728ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000728ull);
@@ -962,6 +966,7 @@ static inline uint64_t CVMX_CIU_PP_DBG_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000708ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 			break;
 	}
@@ -988,6 +993,7 @@ static inline uint64_t CVMX_CIU_PP_DBG_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000708ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000708ull);
@@ -1034,6 +1040,10 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 			if ((offset <= 47))
 				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 15))
+				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 15) * 8;
+			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001070100100200ull) + ((offset) & 31) * 8;
@@ -1067,6 +1077,8 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001070000000580ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100200ull) + (offset) * 8;
 	}
@@ -1094,6 +1106,7 @@ static inline uint64_t CVMX_CIU_PP_RST_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000700ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 			break;
 	}
@@ -1120,6 +1133,7 @@ static inline uint64_t CVMX_CIU_PP_RST_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000700ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000700ull);
@@ -1134,6 +1148,7 @@ static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001070000000740ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 			break;
 	}
@@ -1148,6 +1163,7 @@ static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000740ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001010000000110ull);
@@ -1485,6 +1501,10 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 			if ((offset <= 47))
 				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 15))
+				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 15) * 8;
+			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001070100100000ull) + ((offset) & 31) * 8;
@@ -1518,6 +1538,8 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001070000000500ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100000ull) + (offset) * 8;
 	}
@@ -2759,6 +2781,7 @@ union cvmx_ciu_dint {
 	struct cvmx_ciu_dint_cn68xx           cn68xxp1;
 	struct cvmx_ciu_dint_cn52xx           cn70xx;
 	struct cvmx_ciu_dint_cn52xx           cn70xxp1;
+	struct cvmx_ciu_dint_cn38xx           cn73xx;
 	struct cvmx_ciu_dint_s                cn78xx;
 	struct cvmx_ciu_dint_cn52xx           cnf71xx;
 };
@@ -3936,6 +3959,7 @@ union cvmx_ciu_fuse {
 	struct cvmx_ciu_fuse_cn68xx           cn68xxp1;
 	struct cvmx_ciu_fuse_cn52xx           cn70xx;
 	struct cvmx_ciu_fuse_cn52xx           cn70xxp1;
+	struct cvmx_ciu_fuse_cn38xx           cn73xx;
 	struct cvmx_ciu_fuse_s                cn78xx;
 	struct cvmx_ciu_fuse_cn52xx           cnf71xx;
 };
@@ -12919,6 +12943,7 @@ union cvmx_ciu_pp_dbg {
 	struct cvmx_ciu_pp_dbg_cn68xx         cn68xxp1;
 	struct cvmx_ciu_pp_dbg_cn52xx         cn70xx;
 	struct cvmx_ciu_pp_dbg_cn52xx         cn70xxp1;
+	struct cvmx_ciu_pp_dbg_cn38xx         cn73xx;
 	struct cvmx_ciu_pp_dbg_s              cn78xx;
 	struct cvmx_ciu_pp_dbg_cn52xx         cnf71xx;
 };
@@ -12958,7 +12983,7 @@ union cvmx_ciu_pp_pokex {
 	struct cvmx_ciu_pp_pokex_s            cn68xxp1;
 	struct cvmx_ciu_pp_pokex_s            cn70xx;
 	struct cvmx_ciu_pp_pokex_s            cn70xxp1;
-	struct cvmx_ciu_pp_pokex_cn78xx {
+	struct cvmx_ciu_pp_pokex_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t poke                         : 1;  /**< Core poke. Writing any value to this register does the following:
@@ -12970,7 +12995,8 @@ union cvmx_ciu_pp_pokex {
 	uint64_t poke                         : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_ciu_pp_pokex_cn73xx       cn78xx;
 	struct cvmx_ciu_pp_pokex_s            cnf71xx;
 };
 typedef union cvmx_ciu_pp_pokex cvmx_ciu_pp_pokex_t;
@@ -13102,6 +13128,7 @@ union cvmx_ciu_pp_rst {
 	struct cvmx_ciu_pp_rst_cn68xx         cn68xxp1;
 	struct cvmx_ciu_pp_rst_cn52xx         cn70xx;
 	struct cvmx_ciu_pp_rst_cn52xx         cn70xxp1;
+	struct cvmx_ciu_pp_rst_cn38xx         cn73xx;
 	struct cvmx_ciu_pp_rst_s              cn78xx;
 	struct cvmx_ciu_pp_rst_cn52xx         cnf71xx;
 };
@@ -13129,6 +13156,18 @@ union cvmx_ciu_pp_rst_pending {
 	} s;
 	struct cvmx_ciu_pp_rst_pending_s      cn70xx;
 	struct cvmx_ciu_pp_rst_pending_s      cn70xxp1;
+	struct cvmx_ciu_pp_rst_pending_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pend                         : 16; /**< Set if corresponding core is waiting to change its reset state. Normally a reset change
+                                                         occurs immediately but if RST_PP_POWER[GATE] bit is set and the core is released from
+                                                         reset a delay of 64K core clocks between each core reset will apply to satisfy power
+                                                         management. */
+#else
+	uint64_t pend                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_ciu_pp_rst_pending_s      cn78xx;
 };
 typedef union cvmx_ciu_pp_rst_pending cvmx_ciu_pp_rst_pending_t;
@@ -16755,6 +16794,7 @@ union cvmx_ciu_wdogx {
 	struct cvmx_ciu_wdogx_s               cn68xxp1;
 	struct cvmx_ciu_wdogx_s               cn70xx;
 	struct cvmx_ciu_wdogx_s               cn70xxp1;
+	struct cvmx_ciu_wdogx_s               cn73xx;
 	struct cvmx_ciu_wdogx_s               cn78xx;
 	struct cvmx_ciu_wdogx_s               cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index 59d6038..3be9e88 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_CIU3_BIST CVMX_CIU3_BIST_FUNC()
 static inline uint64_t CVMX_CIU3_BIST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_BIST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000001C0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_CIU3_BIST_FUNC(void)
 #define CVMX_CIU3_CONST CVMX_CIU3_CONST_FUNC()
 static inline uint64_t CVMX_CIU3_CONST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_CONST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000220ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_CIU3_CONST_FUNC(void)
 #define CVMX_CIU3_CTL CVMX_CIU3_CTL_FUNC()
 static inline uint64_t CVMX_CIU3_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000000E0ull);
 }
@@ -89,6 +89,7 @@ static inline uint64_t CVMX_CIU3_CTL_FUNC(void)
 static inline uint64_t CVMX_CIU3_DESTX_IO_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_CIU3_DESTX_IO_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000210000ull) + ((offset) & 7) * 8;
@@ -100,6 +101,7 @@ static inline uint64_t CVMX_CIU3_DESTX_IO_INT(unsigned long offset)
 static inline uint64_t CVMX_CIU3_DESTX_PP_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 143)))))
 		cvmx_warn("CVMX_CIU3_DESTX_PP_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000200000ull) + ((offset) & 255) * 8;
@@ -111,7 +113,7 @@ static inline uint64_t CVMX_CIU3_DESTX_PP_INT(unsigned long offset)
 #define CVMX_CIU3_GSTOP CVMX_CIU3_GSTOP_FUNC()
 static inline uint64_t CVMX_CIU3_GSTOP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_GSTOP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000140ull);
 }
@@ -122,6 +124,7 @@ static inline uint64_t CVMX_CIU3_GSTOP_FUNC(void)
 static inline uint64_t CVMX_CIU3_IDTX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_CIU3_IDTX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000110000ull) + ((offset) & 255) * 8;
@@ -133,6 +136,7 @@ static inline uint64_t CVMX_CIU3_IDTX_CTL(unsigned long offset)
 static inline uint64_t CVMX_CIU3_IDTX_IO(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_CIU3_IDTX_IO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000130000ull) + ((offset) & 255) * 8;
@@ -144,6 +148,7 @@ static inline uint64_t CVMX_CIU3_IDTX_IO(unsigned long offset)
 static inline uint64_t CVMX_CIU3_IDTX_PPX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 255)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id <= 255))))))
 		cvmx_warn("CVMX_CIU3_IDTX_PPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001010000120000ull) + ((block_id) & 255) * 0x20ull;
@@ -155,7 +160,7 @@ static inline uint64_t CVMX_CIU3_IDTX_PPX(unsigned long offset, unsigned long bl
 #define CVMX_CIU3_INTR_RAM_ECC_CTL CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_RAM_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000260ull);
 }
@@ -166,7 +171,7 @@ static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC(void)
 #define CVMX_CIU3_INTR_RAM_ECC_ST CVMX_CIU3_INTR_RAM_ECC_ST_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_ST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_RAM_ECC_ST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000280ull);
 }
@@ -177,7 +182,7 @@ static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_ST_FUNC(void)
 #define CVMX_CIU3_INTR_READY CVMX_CIU3_INTR_READY_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_READY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_READY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000002A0ull);
 }
@@ -188,7 +193,7 @@ static inline uint64_t CVMX_CIU3_INTR_READY_FUNC(void)
 #define CVMX_CIU3_INTR_SLOWDOWN CVMX_CIU3_INTR_SLOWDOWN_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_SLOWDOWN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_INTR_SLOWDOWN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000240ull);
 }
@@ -199,6 +204,7 @@ static inline uint64_t CVMX_CIU3_INTR_SLOWDOWN_FUNC(void)
 static inline uint64_t CVMX_CIU3_ISCX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010080000000ull) + ((offset) & 1048575) * 8;
@@ -210,6 +216,7 @@ static inline uint64_t CVMX_CIU3_ISCX_CTL(unsigned long offset)
 static inline uint64_t CVMX_CIU3_ISCX_W1C(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010090000000ull) + ((offset) & 1048575) * 8;
@@ -221,6 +228,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1C(unsigned long offset)
 static inline uint64_t CVMX_CIU3_ISCX_W1S(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_W1S(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00010100A0000000ull) + ((offset) & 1048575) * 8;
@@ -232,7 +240,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1S(unsigned long offset)
 #define CVMX_CIU3_NMI CVMX_CIU3_NMI_FUNC()
 static inline uint64_t CVMX_CIU3_NMI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_CIU3_NMI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000160ull);
 }
@@ -243,6 +251,7 @@ static inline uint64_t CVMX_CIU3_NMI_FUNC(void)
 static inline uint64_t CVMX_CIU3_SISCX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 191))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 191)))))
 		cvmx_warn("CVMX_CIU3_SISCX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000220000ull) + ((offset) & 255) * 8;
@@ -254,6 +263,7 @@ static inline uint64_t CVMX_CIU3_SISCX(unsigned long offset)
 static inline uint64_t CVMX_CIU3_TIMX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 9)))))
 		cvmx_warn("CVMX_CIU3_TIMX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001010000010000ull) + ((offset) & 15) * 8;
@@ -285,6 +295,7 @@ union cvmx_ciu3_bist {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_ciu3_bist_s               cn73xx;
 	struct cvmx_ciu3_bist_s               cn78xx;
 };
 typedef union cvmx_ciu3_bist cvmx_ciu3_bist_t;
@@ -307,6 +318,7 @@ union cvmx_ciu3_const {
 	uint64_t dests_io                     : 16;
 #endif
 	} s;
+	struct cvmx_ciu3_const_s              cn73xx;
 	struct cvmx_ciu3_const_s              cn78xx;
 };
 typedef union cvmx_ciu3_const cvmx_ciu3_const_t;
@@ -336,6 +348,7 @@ union cvmx_ciu3_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_ciu3_ctl_s                cn73xx;
 	struct cvmx_ciu3_ctl_s                cn78xx;
 };
 typedef union cvmx_ciu3_ctl cvmx_ciu3_ctl_t;
@@ -368,6 +381,7 @@ union cvmx_ciu3_destx_io_int {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_ciu3_destx_io_int_s       cn73xx;
 	struct cvmx_ciu3_destx_io_int_s       cn78xx;
 };
 typedef union cvmx_ciu3_destx_io_int cvmx_ciu3_destx_io_int_t;
@@ -400,6 +414,7 @@ union cvmx_ciu3_destx_pp_int {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_ciu3_destx_pp_int_s       cn73xx;
 	struct cvmx_ciu3_destx_pp_int_s       cn78xx;
 };
 typedef union cvmx_ciu3_destx_pp_int cvmx_ciu3_destx_pp_int_t;
@@ -418,6 +433,7 @@ union cvmx_ciu3_gstop {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_ciu3_gstop_s              cn73xx;
 	struct cvmx_ciu3_gstop_s              cn78xx;
 };
 typedef union cvmx_ciu3_gstop cvmx_ciu3_gstop_t;
@@ -454,6 +470,7 @@ union cvmx_ciu3_idtx_ctl {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_ciu3_idtx_ctl_s           cn73xx;
 	struct cvmx_ciu3_idtx_ctl_s           cn78xx;
 };
 typedef union cvmx_ciu3_idtx_ctl cvmx_ciu3_idtx_ctl_t;
@@ -476,6 +493,7 @@ union cvmx_ciu3_idtx_io {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_ciu3_idtx_io_s            cn73xx;
 	struct cvmx_ciu3_idtx_io_s            cn78xx;
 };
 typedef union cvmx_ciu3_idtx_io cvmx_ciu3_idtx_io_t;
@@ -497,6 +515,15 @@ union cvmx_ciu3_idtx_ppx {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_ciu3_idtx_ppx_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pp                           : 16; /**< Bitmask of which cores receive interrupts via this IDT. */
+#else
+	uint64_t pp                           : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_ciu3_idtx_ppx_s           cn78xx;
 };
 typedef union cvmx_ciu3_idtx_ppx cvmx_ciu3_idtx_ppx_t;
@@ -520,6 +547,7 @@ union cvmx_ciu3_intr_ram_ecc_ctl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_ciu3_intr_ram_ecc_ctl_s   cn73xx;
 	struct cvmx_ciu3_intr_ram_ecc_ctl_s   cn78xx;
 };
 typedef union cvmx_ciu3_intr_ram_ecc_ctl cvmx_ciu3_intr_ram_ecc_ctl_t;
@@ -552,6 +580,7 @@ union cvmx_ciu3_intr_ram_ecc_st {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_ciu3_intr_ram_ecc_st_s    cn73xx;
 	struct cvmx_ciu3_intr_ram_ecc_st_s    cn78xx;
 };
 typedef union cvmx_ciu3_intr_ram_ecc_st cvmx_ciu3_intr_ram_ecc_st_t;
@@ -576,6 +605,7 @@ union cvmx_ciu3_intr_ready {
 	uint64_t reserved_46_63               : 18;
 #endif
 	} s;
+	struct cvmx_ciu3_intr_ready_s         cn73xx;
 	struct cvmx_ciu3_intr_ready_s         cn78xx;
 };
 typedef union cvmx_ciu3_intr_ready cvmx_ciu3_intr_ready_t;
@@ -599,6 +629,7 @@ union cvmx_ciu3_intr_slowdown {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_ciu3_intr_slowdown_s      cn73xx;
 	struct cvmx_ciu3_intr_slowdown_s      cn78xx;
 };
 typedef union cvmx_ciu3_intr_slowdown cvmx_ciu3_intr_slowdown_t;
@@ -638,6 +669,7 @@ union cvmx_ciu3_iscx_ctl {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_ciu3_iscx_ctl_s           cn73xx;
 	struct cvmx_ciu3_iscx_ctl_s           cn78xx;
 };
 typedef union cvmx_ciu3_iscx_ctl cvmx_ciu3_iscx_ctl_t;
@@ -658,6 +690,7 @@ union cvmx_ciu3_iscx_w1c {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_ciu3_iscx_w1c_s           cn73xx;
 	struct cvmx_ciu3_iscx_w1c_s           cn78xx;
 };
 typedef union cvmx_ciu3_iscx_w1c cvmx_ciu3_iscx_w1c_t;
@@ -678,6 +711,7 @@ union cvmx_ciu3_iscx_w1s {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_ciu3_iscx_w1s_s           cn73xx;
 	struct cvmx_ciu3_iscx_w1s_s           cn78xx;
 };
 typedef union cvmx_ciu3_iscx_w1s cvmx_ciu3_iscx_w1s_t;
@@ -696,6 +730,15 @@ union cvmx_ciu3_nmi {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_ciu3_nmi_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t nmi                          : 16; /**< Writing a 1 to a bit sends an NMI pulse to the corresponding core vector. */
+#else
+	uint64_t nmi                          : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_ciu3_nmi_s                cn78xx;
 };
 typedef union cvmx_ciu3_nmi cvmx_ciu3_nmi_t;
@@ -712,6 +755,7 @@ union cvmx_ciu3_siscx {
 	uint64_t en                           : 64;
 #endif
 	} s;
+	struct cvmx_ciu3_siscx_s              cn73xx;
 	struct cvmx_ciu3_siscx_s              cn78xx;
 };
 typedef union cvmx_ciu3_siscx cvmx_ciu3_siscx_t;
@@ -735,6 +779,7 @@ union cvmx_ciu3_timx {
 	uint64_t reserved_37_63               : 27;
 #endif
 	} s;
+	struct cvmx_ciu3_timx_s               cn73xx;
 	struct cvmx_ciu3_timx_s               cn78xx;
 };
 typedef union cvmx_ciu3_timx cvmx_ciu3_timx_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index ed35782..0e1e30f 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_DPI_BIST_STATUS CVMX_DPI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_DPI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000000ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_DPI_BIST_STATUS_FUNC(void)
 #define CVMX_DPI_CTL CVMX_DPI_CTL_FUNC()
 static inline uint64_t CVMX_DPI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000040ull);
 }
@@ -83,6 +83,7 @@ static inline uint64_t CVMX_DPI_DMAX_COUNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_COUNTS(%lu) is invalid on this chip\n", offset);
@@ -100,6 +101,7 @@ static inline uint64_t CVMX_DPI_DMAX_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_DBELL(%lu) is invalid on this chip\n", offset);
@@ -116,6 +118,7 @@ static inline uint64_t CVMX_DPI_DMAX_ERR_RSP_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_ERR_RSP_STATUS(%lu) is invalid on this chip\n", offset);
@@ -133,6 +136,7 @@ static inline uint64_t CVMX_DPI_DMAX_IBUFF_SADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_IBUFF_SADDR(%lu) is invalid on this chip\n", offset);
@@ -149,6 +153,7 @@ static inline uint64_t CVMX_DPI_DMAX_IFLIGHT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_IFLIGHT(%lu) is invalid on this chip\n", offset);
@@ -166,6 +171,7 @@ static inline uint64_t CVMX_DPI_DMAX_NADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_NADDR(%lu) is invalid on this chip\n", offset);
@@ -183,6 +189,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQBNK0(%lu) is invalid on this chip\n", offset);
@@ -200,6 +207,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQBNK1(%lu) is invalid on this chip\n", offset);
@@ -212,6 +220,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK1(unsigned long offset)
 static inline uint64_t CVMX_DPI_DMAX_REQQ_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQQ_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001DF0000000180ull) + ((offset) & 7) * 8;
@@ -223,7 +232,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQQ_CTL(unsigned long offset)
 #define CVMX_DPI_DMA_CONTROL CVMX_DPI_DMA_CONTROL_FUNC()
 static inline uint64_t CVMX_DPI_DMA_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_DMA_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000048ull);
 }
@@ -239,6 +248,7 @@ static inline uint64_t CVMX_DPI_DMA_ENGX_EN(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DPI_DMA_ENGX_EN(%lu) is invalid on this chip\n", offset);
@@ -265,6 +275,10 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 			if ((offset <= 47))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 15))
+				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 15) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_DPI_DMA_PPX_CNT (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001DF0000000B00ull) + ((offset) & 3) * 8;
@@ -281,6 +295,8 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001DF0000000B00ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001DF0000000B00ull) + (offset) * 8;
 }
@@ -289,7 +305,7 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 #define CVMX_DPI_DMA_PP_INT CVMX_DPI_DMA_PP_INT_FUNC()
 static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_DMA_PP_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000038ull);
 }
@@ -300,7 +316,7 @@ static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
 #define CVMX_DPI_ECC_CTL CVMX_DPI_ECC_CTL_FUNC()
 static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000018ull);
 }
@@ -311,7 +327,7 @@ static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 #define CVMX_DPI_ECC_INT CVMX_DPI_ECC_INT_FUNC()
 static inline uint64_t CVMX_DPI_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000020ull);
 }
@@ -327,6 +343,7 @@ static inline uint64_t CVMX_DPI_ENGX_BUF(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DPI_ENGX_BUF(%lu) is invalid on this chip\n", offset);
@@ -339,7 +356,7 @@ static inline uint64_t CVMX_DPI_ENGX_BUF(unsigned long offset)
 #define CVMX_DPI_INFO_REG CVMX_DPI_INFO_REG_FUNC()
 static inline uint64_t CVMX_DPI_INFO_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_INFO_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000980ull);
 }
@@ -361,7 +378,7 @@ static inline uint64_t CVMX_DPI_INT_EN_FUNC(void)
 #define CVMX_DPI_INT_REG CVMX_DPI_INT_REG_FUNC()
 static inline uint64_t CVMX_DPI_INT_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_INT_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000008ull);
 }
@@ -376,6 +393,7 @@ static inline uint64_t CVMX_DPI_NCBX_CFG(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_DPI_NCBX_CFG(%lu) is invalid on this chip\n", block_id);
@@ -388,7 +406,7 @@ static inline uint64_t CVMX_DPI_NCBX_CFG(unsigned long block_id)
 #define CVMX_DPI_NCB_CTL CVMX_DPI_NCB_CTL_FUNC()
 static inline uint64_t CVMX_DPI_NCB_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_NCB_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000028ull);
 }
@@ -399,7 +417,7 @@ static inline uint64_t CVMX_DPI_NCB_CTL_FUNC(void)
 #define CVMX_DPI_PINT_INFO CVMX_DPI_PINT_INFO_FUNC()
 static inline uint64_t CVMX_DPI_PINT_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_PINT_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000830ull);
 }
@@ -410,7 +428,7 @@ static inline uint64_t CVMX_DPI_PINT_INFO_FUNC(void)
 #define CVMX_DPI_PKT_ERR_RSP CVMX_DPI_PKT_ERR_RSP_FUNC()
 static inline uint64_t CVMX_DPI_PKT_ERR_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_PKT_ERR_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000078ull);
 }
@@ -421,7 +439,7 @@ static inline uint64_t CVMX_DPI_PKT_ERR_RSP_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RSP CVMX_DPI_REQ_ERR_RSP_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000058ull);
 }
@@ -432,7 +450,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RSP_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RSP_EN CVMX_DPI_REQ_ERR_RSP_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RSP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RSP_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000068ull);
 }
@@ -443,7 +461,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RSP_EN_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RST CVMX_DPI_REQ_ERR_RST_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000060ull);
 }
@@ -454,7 +472,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RST_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RST_EN CVMX_DPI_REQ_ERR_RST_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RST_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RST_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000070ull);
 }
@@ -465,7 +483,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RST_EN_FUNC(void)
 #define CVMX_DPI_REQ_ERR_SKIP_COMP CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_SKIP_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000838ull);
 }
@@ -476,7 +494,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC(void)
 #define CVMX_DPI_REQ_GBL_EN CVMX_DPI_REQ_GBL_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_GBL_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_DPI_REQ_GBL_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000050ull);
 }
@@ -492,6 +510,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_CFG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DPI_SLI_PRTX_CFG(%lu) is invalid on this chip\n", offset);
@@ -518,15 +537,16 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR(unsigned long offset)
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 1) * 8;
 			break;
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 2))
-				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
+			break;
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000928ull) + ((offset) & 1) * 8;
@@ -549,10 +569,11 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR(unsigned long offset)
 			if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000928ull) + (offset) * 8;
@@ -569,6 +590,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR_INFO(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DPI_SLI_PRTX_ERR_INFO(%lu) is invalid on this chip\n", offset);
@@ -581,7 +603,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR_INFO(unsigned long offset)
 #define CVMX_DPI_SWA_Q_VMID CVMX_DPI_SWA_Q_VMID_FUNC()
 static inline uint64_t CVMX_DPI_SWA_Q_VMID_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DPI_SWA_Q_VMID not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000030ull);
 }
@@ -646,6 +668,7 @@ union cvmx_dpi_bist_status {
 	struct cvmx_dpi_bist_status_cn63xx    cn68xxp1;
 	struct cvmx_dpi_bist_status_cn61xx    cn70xx;
 	struct cvmx_dpi_bist_status_cn61xx    cn70xxp1;
+	struct cvmx_dpi_bist_status_s         cn73xx;
 	struct cvmx_dpi_bist_status_s         cn78xx;
 	struct cvmx_dpi_bist_status_cn61xx    cnf71xx;
 };
@@ -686,6 +709,7 @@ union cvmx_dpi_ctl {
 	struct cvmx_dpi_ctl_s                 cn68xxp1;
 	struct cvmx_dpi_ctl_cn61xx            cn70xx;
 	struct cvmx_dpi_ctl_cn61xx            cn70xxp1;
+	struct cvmx_dpi_ctl_cn61xx            cn73xx;
 	struct cvmx_dpi_ctl_cn61xx            cn78xx;
 	struct cvmx_dpi_ctl_cn61xx            cnf71xx;
 };
@@ -719,6 +743,7 @@ union cvmx_dpi_dmax_counts {
 	struct cvmx_dpi_dmax_counts_s         cn68xxp1;
 	struct cvmx_dpi_dmax_counts_s         cn70xx;
 	struct cvmx_dpi_dmax_counts_s         cn70xxp1;
+	struct cvmx_dpi_dmax_counts_s         cn73xx;
 	struct cvmx_dpi_dmax_counts_s         cn78xx;
 	struct cvmx_dpi_dmax_counts_s         cnf71xx;
 };
@@ -751,6 +776,7 @@ union cvmx_dpi_dmax_dbell {
 	struct cvmx_dpi_dmax_dbell_s          cn68xxp1;
 	struct cvmx_dpi_dmax_dbell_s          cn70xx;
 	struct cvmx_dpi_dmax_dbell_s          cn70xxp1;
+	struct cvmx_dpi_dmax_dbell_s          cn73xx;
 	struct cvmx_dpi_dmax_dbell_s          cn78xx;
 	struct cvmx_dpi_dmax_dbell_s          cnf71xx;
 };
@@ -783,6 +809,7 @@ union cvmx_dpi_dmax_err_rsp_status {
 	struct cvmx_dpi_dmax_err_rsp_status_s cn68xxp1;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn70xx;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn70xxp1;
+	struct cvmx_dpi_dmax_err_rsp_status_s cn73xx;
 	struct cvmx_dpi_dmax_err_rsp_status_s cn78xx;
 	struct cvmx_dpi_dmax_err_rsp_status_s cnf71xx;
 };
@@ -872,7 +899,7 @@ union cvmx_dpi_dmax_ibuff_saddr {
 	struct cvmx_dpi_dmax_ibuff_saddr_cn68xx cn68xxp1;
 	struct cvmx_dpi_dmax_ibuff_saddr_cn61xx cn70xx;
 	struct cvmx_dpi_dmax_ibuff_saddr_cn61xx cn70xxp1;
-	struct cvmx_dpi_dmax_ibuff_saddr_cn78xx {
+	struct cvmx_dpi_dmax_ibuff_saddr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t idle                         : 1;  /**< DMA request queue is idle. When asserted, the associated request queue is idle. */
 	uint64_t reserved_62_62               : 1;
@@ -894,7 +921,8 @@ union cvmx_dpi_dmax_ibuff_saddr {
 	uint64_t reserved_62_62               : 1;
 	uint64_t idle                         : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_dpi_dmax_ibuff_saddr_cn73xx cn78xx;
 	struct cvmx_dpi_dmax_ibuff_saddr_cn61xx cnf71xx;
 };
 typedef union cvmx_dpi_dmax_ibuff_saddr cvmx_dpi_dmax_ibuff_saddr_t;
@@ -921,6 +949,7 @@ union cvmx_dpi_dmax_iflight {
 	struct cvmx_dpi_dmax_iflight_s        cn68xxp1;
 	struct cvmx_dpi_dmax_iflight_s        cn70xx;
 	struct cvmx_dpi_dmax_iflight_s        cn70xxp1;
+	struct cvmx_dpi_dmax_iflight_s        cn73xx;
 	struct cvmx_dpi_dmax_iflight_s        cn78xx;
 	struct cvmx_dpi_dmax_iflight_s        cnf71xx;
 };
@@ -970,6 +999,7 @@ union cvmx_dpi_dmax_naddr {
 	struct cvmx_dpi_dmax_naddr_cn68xx     cn68xxp1;
 	struct cvmx_dpi_dmax_naddr_cn61xx     cn70xx;
 	struct cvmx_dpi_dmax_naddr_cn61xx     cn70xxp1;
+	struct cvmx_dpi_dmax_naddr_s          cn73xx;
 	struct cvmx_dpi_dmax_naddr_s          cn78xx;
 	struct cvmx_dpi_dmax_naddr_cn61xx     cnf71xx;
 };
@@ -998,6 +1028,7 @@ union cvmx_dpi_dmax_reqbnk0 {
 	struct cvmx_dpi_dmax_reqbnk0_s        cn68xxp1;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn70xx;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn70xxp1;
+	struct cvmx_dpi_dmax_reqbnk0_s        cn73xx;
 	struct cvmx_dpi_dmax_reqbnk0_s        cn78xx;
 	struct cvmx_dpi_dmax_reqbnk0_s        cnf71xx;
 };
@@ -1026,6 +1057,7 @@ union cvmx_dpi_dmax_reqbnk1 {
 	struct cvmx_dpi_dmax_reqbnk1_s        cn68xxp1;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn70xx;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn70xxp1;
+	struct cvmx_dpi_dmax_reqbnk1_s        cn73xx;
 	struct cvmx_dpi_dmax_reqbnk1_s        cn78xx;
 	struct cvmx_dpi_dmax_reqbnk1_s        cnf71xx;
 };
@@ -1060,6 +1092,7 @@ union cvmx_dpi_dmax_reqq_ctl {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_dpi_dmax_reqq_ctl_s       cn73xx;
 	struct cvmx_dpi_dmax_reqq_ctl_s       cn78xx;
 };
 typedef union cvmx_dpi_dmax_reqq_ctl cvmx_dpi_dmax_reqq_ctl_t;
@@ -1451,7 +1484,7 @@ union cvmx_dpi_dma_control {
 	struct cvmx_dpi_dma_control_cn63xx    cn68xxp1;
 	struct cvmx_dpi_dma_control_cn61xx    cn70xx;
 	struct cvmx_dpi_dma_control_cn61xx    cn70xxp1;
-	struct cvmx_dpi_dma_control_cn78xx {
+	struct cvmx_dpi_dma_control_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t ffp_dis                      : 1;  /**< Force forward progress disable. The DMA engines will compete for shared resources. If the
@@ -1474,7 +1507,9 @@ union cvmx_dpi_dma_control {
                                                          should not be disabled while processing instructions.
                                                          When PKT_EN=1, then DMA_ENB<5>=0 and DMA_ENB<4>=0. */
 	uint64_t reserved_35_47               : 13;
-	uint64_t ncb_tag                      : 1;  /**< Reserved. */
+	uint64_t ncb_tag                      : 1;  /**< NCB tag enable. It allows DMA Read/Write transactions over NCB to be mapped to
+                                                         individual request queues by using tags. This enables more parallelism, giving a
+                                                         performance boost. */
 	uint64_t b0_lend                      : 1;  /**< Little-endian. When set to 1 and the DPI is in the mode to write 0 to L2C when a DMA
                                                          transaction is done, the address to be written is treated as a little-endian address. */
 	uint64_t ldwb                         : 1;  /**< Load don't write back. When set, the hardware is able to issue LDWB commands to the cache.
@@ -1519,7 +1554,8 @@ union cvmx_dpi_dma_control {
 	uint64_t ffp_dis                      : 1;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_dpi_dma_control_cn73xx    cn78xx;
 	struct cvmx_dpi_dma_control_cn61xx    cnf71xx;
 };
 typedef union cvmx_dpi_dma_control cvmx_dpi_dma_control_t;
@@ -1555,6 +1591,7 @@ union cvmx_dpi_dma_engx_en {
 	struct cvmx_dpi_dma_engx_en_s         cn68xxp1;
 	struct cvmx_dpi_dma_engx_en_s         cn70xx;
 	struct cvmx_dpi_dma_engx_en_s         cn70xxp1;
+	struct cvmx_dpi_dma_engx_en_s         cn73xx;
 	struct cvmx_dpi_dma_engx_en_s         cn78xx;
 	struct cvmx_dpi_dma_engx_en_s         cnf71xx;
 };
@@ -1589,6 +1626,7 @@ union cvmx_dpi_dma_ppx_cnt {
 	struct cvmx_dpi_dma_ppx_cnt_s         cn68xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn70xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn70xxp1;
+	struct cvmx_dpi_dma_ppx_cnt_s         cn73xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cn78xx;
 	struct cvmx_dpi_dma_ppx_cnt_s         cnf71xx;
 };
@@ -1608,6 +1646,15 @@ union cvmx_dpi_dma_pp_int {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_dpi_dma_pp_int_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t complete                     : 16; /**< DPI DMA per-core instruction completion interrupt. See DPI_DMA_PP()_CNT. */
+#else
+	uint64_t complete                     : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_dpi_dma_pp_int_s          cn78xx;
 };
 typedef union cvmx_dpi_dma_pp_int cvmx_dpi_dma_pp_int_t;
@@ -1639,6 +1686,7 @@ union cvmx_dpi_ecc_ctl {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_dpi_ecc_ctl_s             cn73xx;
 	struct cvmx_dpi_ecc_ctl_s             cn78xx;
 };
 typedef union cvmx_dpi_ecc_ctl cvmx_dpi_ecc_ctl_t;
@@ -1697,6 +1745,7 @@ union cvmx_dpi_ecc_int {
 	uint64_t reserved_47_63               : 17;
 #endif
 	} s;
+	struct cvmx_dpi_ecc_int_s             cn73xx;
 	struct cvmx_dpi_ecc_int_s             cn78xx;
 };
 typedef union cvmx_dpi_ecc_int cvmx_dpi_ecc_int_t;
@@ -1791,6 +1840,7 @@ union cvmx_dpi_engx_buf {
 	struct cvmx_dpi_engx_buf_cn61xx       cn68xxp1;
 	struct cvmx_dpi_engx_buf_cn61xx       cn70xx;
 	struct cvmx_dpi_engx_buf_cn61xx       cn70xxp1;
+	struct cvmx_dpi_engx_buf_s            cn73xx;
 	struct cvmx_dpi_engx_buf_s            cn78xx;
 	struct cvmx_dpi_engx_buf_cn61xx       cnf71xx;
 };
@@ -1846,6 +1896,7 @@ union cvmx_dpi_info_reg {
 	struct cvmx_dpi_info_reg_s            cn68xxp1;
 	struct cvmx_dpi_info_reg_s            cn70xx;
 	struct cvmx_dpi_info_reg_s            cn70xxp1;
+	struct cvmx_dpi_info_reg_s            cn73xx;
 	struct cvmx_dpi_info_reg_s            cn78xx;
 	struct cvmx_dpi_info_reg_s            cnf71xx;
 };
@@ -2092,6 +2143,7 @@ union cvmx_dpi_int_reg {
 	struct cvmx_dpi_int_reg_cn63xx        cn68xxp1;
 	struct cvmx_dpi_int_reg_s             cn70xx;
 	struct cvmx_dpi_int_reg_s             cn70xxp1;
+	struct cvmx_dpi_int_reg_s             cn73xx;
 	struct cvmx_dpi_int_reg_s             cn78xx;
 	struct cvmx_dpi_int_reg_s             cnf71xx;
 };
@@ -2121,6 +2173,7 @@ union cvmx_dpi_ncbx_cfg {
 	struct cvmx_dpi_ncbx_cfg_s            cn68xx;
 	struct cvmx_dpi_ncbx_cfg_s            cn70xx;
 	struct cvmx_dpi_ncbx_cfg_s            cn70xxp1;
+	struct cvmx_dpi_ncbx_cfg_s            cn73xx;
 	struct cvmx_dpi_ncbx_cfg_s            cn78xx;
 	struct cvmx_dpi_ncbx_cfg_s            cnf71xx;
 };
@@ -2163,6 +2216,41 @@ union cvmx_dpi_ncb_ctl {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_dpi_ncb_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t ncbsel_prt_xor_dis           : 1;  /**< Disable the inclusion of the instruction header LPORT field when computing the NCB bus. */
+	uint64_t reserved_21_23               : 3;
+	uint64_t ncbsel_zbw                   : 1;  /**< ZBW select.
+                                                         0 = Zero-byte-write transaction will make requests and receive responses using NCB2.
+                                                         1 = Zero-byte-write transaction will make requests and receive responses using NCB3. */
+	uint64_t reserved_17_19               : 3;
+	uint64_t ncbsel_req                   : 1;  /**< Request select.
+                                                         0 = Instruction request transaction will make requests and receive responses using NCB2.
+                                                         1 = Instruction request transaction will make requests and receive responses using NCB3. */
+	uint64_t reserved_13_15               : 3;
+	uint64_t ncbsel_dst                   : 1;  /**< Destination select.
+                                                         0 = Transaction will make requests and receive responses using NCB2.
+                                                         1 = Transaction will make requests and receive responses using NCB3. */
+	uint64_t reserved_9_11                : 3;
+	uint64_t ncbsel_src                   : 1;  /**< Source select.
+                                                         0 = Transaction will make requests and receive responses using NCB2.
+                                                         1 = Transaction will make requests and receive responses using NCB3. */
+	uint64_t reserved_0_7                 : 8;
+#else
+	uint64_t reserved_0_7                 : 8;
+	uint64_t ncbsel_src                   : 1;
+	uint64_t reserved_9_11                : 3;
+	uint64_t ncbsel_dst                   : 1;
+	uint64_t reserved_13_15               : 3;
+	uint64_t ncbsel_req                   : 1;
+	uint64_t reserved_17_19               : 3;
+	uint64_t ncbsel_zbw                   : 1;
+	uint64_t reserved_21_23               : 3;
+	uint64_t ncbsel_prt_xor_dis           : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn73xx;
 	struct cvmx_dpi_ncb_ctl_s             cn78xx;
 };
 typedef union cvmx_dpi_ncb_ctl cvmx_dpi_ncb_ctl_t;
@@ -2196,6 +2284,7 @@ union cvmx_dpi_pint_info {
 	struct cvmx_dpi_pint_info_s           cn68xxp1;
 	struct cvmx_dpi_pint_info_s           cn70xx;
 	struct cvmx_dpi_pint_info_s           cn70xxp1;
+	struct cvmx_dpi_pint_info_s           cn73xx;
 	struct cvmx_dpi_pint_info_s           cn78xx;
 	struct cvmx_dpi_pint_info_s           cnf71xx;
 };
@@ -2224,6 +2313,7 @@ union cvmx_dpi_pkt_err_rsp {
 	struct cvmx_dpi_pkt_err_rsp_s         cn68xxp1;
 	struct cvmx_dpi_pkt_err_rsp_s         cn70xx;
 	struct cvmx_dpi_pkt_err_rsp_s         cn70xxp1;
+	struct cvmx_dpi_pkt_err_rsp_s         cn73xx;
 	struct cvmx_dpi_pkt_err_rsp_s         cn78xx;
 	struct cvmx_dpi_pkt_err_rsp_s         cnf71xx;
 };
@@ -2255,6 +2345,7 @@ union cvmx_dpi_req_err_rsp {
 	struct cvmx_dpi_req_err_rsp_s         cn68xxp1;
 	struct cvmx_dpi_req_err_rsp_s         cn70xx;
 	struct cvmx_dpi_req_err_rsp_s         cn70xxp1;
+	struct cvmx_dpi_req_err_rsp_s         cn73xx;
 	struct cvmx_dpi_req_err_rsp_s         cn78xx;
 	struct cvmx_dpi_req_err_rsp_s         cnf71xx;
 };
@@ -2284,6 +2375,7 @@ union cvmx_dpi_req_err_rsp_en {
 	struct cvmx_dpi_req_err_rsp_en_s      cn68xxp1;
 	struct cvmx_dpi_req_err_rsp_en_s      cn70xx;
 	struct cvmx_dpi_req_err_rsp_en_s      cn70xxp1;
+	struct cvmx_dpi_req_err_rsp_en_s      cn73xx;
 	struct cvmx_dpi_req_err_rsp_en_s      cn78xx;
 	struct cvmx_dpi_req_err_rsp_en_s      cnf71xx;
 };
@@ -2316,6 +2408,7 @@ union cvmx_dpi_req_err_rst {
 	struct cvmx_dpi_req_err_rst_s         cn68xxp1;
 	struct cvmx_dpi_req_err_rst_s         cn70xx;
 	struct cvmx_dpi_req_err_rst_s         cn70xxp1;
+	struct cvmx_dpi_req_err_rst_s         cn73xx;
 	struct cvmx_dpi_req_err_rst_s         cn78xx;
 	struct cvmx_dpi_req_err_rst_s         cnf71xx;
 };
@@ -2346,6 +2439,7 @@ union cvmx_dpi_req_err_rst_en {
 	struct cvmx_dpi_req_err_rst_en_s      cn68xxp1;
 	struct cvmx_dpi_req_err_rst_en_s      cn70xx;
 	struct cvmx_dpi_req_err_rst_en_s      cn70xxp1;
+	struct cvmx_dpi_req_err_rst_en_s      cn73xx;
 	struct cvmx_dpi_req_err_rst_en_s      cn78xx;
 	struct cvmx_dpi_req_err_rst_en_s      cnf71xx;
 };
@@ -2389,6 +2483,7 @@ union cvmx_dpi_req_err_skip_comp {
 	struct cvmx_dpi_req_err_skip_comp_s   cn68xxp1;
 	struct cvmx_dpi_req_err_skip_comp_s   cn70xx;
 	struct cvmx_dpi_req_err_skip_comp_s   cn70xxp1;
+	struct cvmx_dpi_req_err_skip_comp_s   cn73xx;
 	struct cvmx_dpi_req_err_skip_comp_s   cn78xx;
 	struct cvmx_dpi_req_err_skip_comp_s   cnf71xx;
 };
@@ -2417,6 +2512,7 @@ union cvmx_dpi_req_gbl_en {
 	struct cvmx_dpi_req_gbl_en_s          cn68xxp1;
 	struct cvmx_dpi_req_gbl_en_s          cn70xx;
 	struct cvmx_dpi_req_gbl_en_s          cn70xxp1;
+	struct cvmx_dpi_req_gbl_en_s          cn73xx;
 	struct cvmx_dpi_req_gbl_en_s          cn78xx;
 	struct cvmx_dpi_req_gbl_en_s          cnf71xx;
 };
@@ -2826,10 +2922,12 @@ union cvmx_dpi_sli_prtx_cfg {
 #endif
 	} cn70xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn70xx   cn70xxp1;
-	struct cvmx_dpi_sli_prtx_cfg_cn78xx {
+	struct cvmx_dpi_sli_prtx_cfg_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t ncbsel                       : 1;  /**< Reserved. */
+	uint64_t ncbsel                       : 1;  /**< NCB select.
+                                                         0 = Inbound/outbound transaction will make requests and receive responses using NCB2.
+                                                         1 = Inbound/outbound transaction will make requests and receive responses using NCB3. */
 	uint64_t reserved_25_27               : 3;
 	uint64_t halt                         : 1;  /**< When set, HALT indicates that the MAC has detected a reset condition. No further
                                                          instructions that reference the MAC from any instruction queue will be issued until the
@@ -2895,7 +2993,8 @@ union cvmx_dpi_sli_prtx_cfg {
 	uint64_t ncbsel                       : 1;
 	uint64_t reserved_29_63               : 35;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_dpi_sli_prtx_cfg_cn73xx   cn78xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn61xx   cnf71xx;
 };
 typedef union cvmx_dpi_sli_prtx_cfg cvmx_dpi_sli_prtx_cfg_t;
@@ -2929,6 +3028,7 @@ union cvmx_dpi_sli_prtx_err {
 	struct cvmx_dpi_sli_prtx_err_s        cn68xxp1;
 	struct cvmx_dpi_sli_prtx_err_s        cn70xx;
 	struct cvmx_dpi_sli_prtx_err_s        cn70xxp1;
+	struct cvmx_dpi_sli_prtx_err_s        cn73xx;
 	struct cvmx_dpi_sli_prtx_err_s        cn78xx;
 	struct cvmx_dpi_sli_prtx_err_s        cnf71xx;
 };
@@ -3023,6 +3123,7 @@ union cvmx_dpi_sli_prtx_err_info {
 	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn68xxp1;
 	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn70xx;
 	struct cvmx_dpi_sli_prtx_err_info_cn61xx cn70xxp1;
+	struct cvmx_dpi_sli_prtx_err_info_s   cn73xx;
 	struct cvmx_dpi_sli_prtx_err_info_s   cn78xx;
 	struct cvmx_dpi_sli_prtx_err_info_cn61xx cnf71xx;
 };
@@ -3057,6 +3158,7 @@ union cvmx_dpi_swa_q_vmid {
 	uint64_t vmid7                        : 8;
 #endif
 	} s;
+	struct cvmx_dpi_swa_q_vmid_s          cn73xx;
 	struct cvmx_dpi_swa_q_vmid_s          cn78xx;
 };
 typedef union cvmx_dpi_swa_q_vmid cvmx_dpi_swa_q_vmid_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
index fa33c6b..0f1d7d7 100644
--- a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -163,9 +163,65 @@ static inline uint64_t CVMX_DTX_ASE_SELX(unsigned long offset)
 #define CVMX_DTX_ASE_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E8000ull) + ((offset) & 1) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_BCH_BCST_RSP CVMX_DTX_BCH_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_BCH_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_DTX_BCH_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE388080ull);
+}
+#else
+#define CVMX_DTX_BCH_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE388080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_BCH_CTL CVMX_DTX_BCH_CTL_FUNC()
+static inline uint64_t CVMX_DTX_BCH_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_DTX_BCH_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE388060ull);
+}
+#else
+#define CVMX_DTX_BCH_CTL (CVMX_ADD_IO_SEG(0x00011800FE388060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BCH_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_BCH_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE388040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_BCH_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE388040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BCH_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_BCH_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE388020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_BCH_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE388020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BCH_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_BCH_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE388000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_BCH_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE388000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_BGXX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DTX_BGXX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE700080ull) + ((offset) & 7) * 32768;
@@ -177,6 +233,7 @@ static inline uint64_t CVMX_DTX_BGXX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_BGXX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_DTX_BGXX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE700060ull) + ((offset) & 7) * 32768;
@@ -188,6 +245,7 @@ static inline uint64_t CVMX_DTX_BGXX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_BGXX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -199,6 +257,7 @@ static inline uint64_t CVMX_DTX_BGXX_DATX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_BGXX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -210,6 +269,7 @@ static inline uint64_t CVMX_DTX_BGXX_ENAX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
 		cvmx_warn("CVMX_DTX_BGXX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -221,7 +281,7 @@ static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_BROADCAST_CTL CVMX_DTX_BROADCAST_CTL_FUNC()
 static inline uint64_t CVMX_DTX_BROADCAST_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_BROADCAST_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0060ull);
 }
@@ -233,6 +293,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BROADCAST_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0020ull) + ((offset) & 1) * 8;
@@ -245,6 +306,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BROADCAST_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0000ull) + ((offset) & 1) * 8;
@@ -256,7 +318,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_SELX(unsigned long offset)
 #define CVMX_DTX_CIU_BCST_RSP CVMX_DTX_CIU_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_CIU_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE808080ull);
 }
@@ -267,7 +329,7 @@ static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
 #define CVMX_DTX_CIU_CTL CVMX_DTX_CIU_CTL_FUNC()
 static inline uint64_t CVMX_DTX_CIU_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_CIU_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE808060ull);
 }
@@ -278,6 +340,7 @@ static inline uint64_t CVMX_DTX_CIU_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_CIU_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808040ull) + ((offset) & 1) * 8;
@@ -289,6 +352,7 @@ static inline uint64_t CVMX_DTX_CIU_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_CIU_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808020ull) + ((offset) & 1) * 8;
@@ -300,6 +364,7 @@ static inline uint64_t CVMX_DTX_CIU_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_CIU_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE808000ull) + ((offset) & 1) * 8;
@@ -311,7 +376,7 @@ static inline uint64_t CVMX_DTX_CIU_SELX(unsigned long offset)
 #define CVMX_DTX_DFA_BCST_RSP CVMX_DTX_DFA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DFA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8080ull);
 }
@@ -322,7 +387,7 @@ static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_DFA_CTL CVMX_DTX_DFA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_DFA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DFA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8060ull);
 }
@@ -334,6 +399,7 @@ static inline uint64_t CVMX_DTX_DFA_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8040ull) + ((offset) & 1) * 8;
@@ -346,6 +412,7 @@ static inline uint64_t CVMX_DTX_DFA_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8020ull) + ((offset) & 1) * 8;
@@ -358,6 +425,7 @@ static inline uint64_t CVMX_DTX_DFA_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8000ull) + ((offset) & 1) * 8;
@@ -369,7 +437,7 @@ static inline uint64_t CVMX_DTX_DFA_SELX(unsigned long offset)
 #define CVMX_DTX_DPI_BCST_RSP CVMX_DTX_DPI_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DPI_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8080ull);
 }
@@ -380,7 +448,7 @@ static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
 #define CVMX_DTX_DPI_CTL CVMX_DTX_DPI_CTL_FUNC()
 static inline uint64_t CVMX_DTX_DPI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_DPI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8060ull);
 }
@@ -392,6 +460,7 @@ static inline uint64_t CVMX_DTX_DPI_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8040ull) + ((offset) & 1) * 8;
@@ -404,6 +473,7 @@ static inline uint64_t CVMX_DTX_DPI_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8020ull) + ((offset) & 1) * 8;
@@ -416,6 +486,7 @@ static inline uint64_t CVMX_DTX_DPI_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8000ull) + ((offset) & 1) * 8;
@@ -432,6 +503,7 @@ static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE140080ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 			break;
 	}
@@ -446,6 +518,7 @@ static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140080ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
@@ -460,6 +533,7 @@ static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE140060ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 			break;
 	}
@@ -474,6 +548,7 @@ static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140060ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
@@ -488,6 +563,7 @@ static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE140040ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + ((offset) & 1) * 8;
 			break;
@@ -502,6 +578,7 @@ static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140040ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
@@ -516,6 +593,7 @@ static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE140020ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + ((offset) & 1) * 8;
 			break;
@@ -530,6 +608,7 @@ static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140020ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
@@ -544,6 +623,7 @@ static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE140000ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + ((offset) & 1) * 8;
 			break;
@@ -558,6 +638,7 @@ static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
@@ -622,6 +703,7 @@ static inline uint64_t CVMX_DTX_GMXX_SELX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_GSERX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_DTX_GSERX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE480080ull) + ((offset) & 15) * 32768;
@@ -633,6 +715,7 @@ static inline uint64_t CVMX_DTX_GSERX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_GSERX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
 		cvmx_warn("CVMX_DTX_GSERX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE480060ull) + ((offset) & 15) * 32768;
@@ -644,6 +727,7 @@ static inline uint64_t CVMX_DTX_GSERX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_GSERX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480040ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -655,6 +739,7 @@ static inline uint64_t CVMX_DTX_GSERX_DATX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_GSERX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480020ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -666,6 +751,7 @@ static inline uint64_t CVMX_DTX_GSERX_ENAX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_DTX_GSERX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480000ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
@@ -677,7 +763,7 @@ static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long b
 #define CVMX_DTX_HNA_BCST_RSP CVMX_DTX_HNA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_HNA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE238080ull);
 }
@@ -688,7 +774,7 @@ static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_HNA_CTL CVMX_DTX_HNA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_HNA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_HNA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE238060ull);
 }
@@ -699,6 +785,7 @@ static inline uint64_t CVMX_DTX_HNA_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_HNA_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238040ull) + ((offset) & 1) * 8;
@@ -710,6 +797,7 @@ static inline uint64_t CVMX_DTX_HNA_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_HNA_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238020ull) + ((offset) & 1) * 8;
@@ -721,6 +809,7 @@ static inline uint64_t CVMX_DTX_HNA_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_HNA_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238000ull) + ((offset) & 1) * 8;
@@ -732,7 +821,7 @@ static inline uint64_t CVMX_DTX_HNA_SELX(unsigned long offset)
 #define CVMX_DTX_ILA_BCST_RSP CVMX_DTX_ILA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ILA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ILA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8080ull);
 }
@@ -743,7 +832,7 @@ static inline uint64_t CVMX_DTX_ILA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ILA_CTL CVMX_DTX_ILA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ILA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ILA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8060ull);
 }
@@ -754,6 +843,7 @@ static inline uint64_t CVMX_DTX_ILA_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_ILA_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8040ull) + ((offset) & 1) * 8;
@@ -765,6 +855,7 @@ static inline uint64_t CVMX_DTX_ILA_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ILA_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8020ull) + ((offset) & 1) * 8;
@@ -776,6 +867,7 @@ static inline uint64_t CVMX_DTX_ILA_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ILA_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8000ull) + ((offset) & 1) * 8;
@@ -787,7 +879,7 @@ static inline uint64_t CVMX_DTX_ILA_SELX(unsigned long offset)
 #define CVMX_DTX_ILK_BCST_RSP CVMX_DTX_ILK_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ILK_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ILK_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0080ull);
 }
@@ -798,7 +890,7 @@ static inline uint64_t CVMX_DTX_ILK_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ILK_CTL CVMX_DTX_ILK_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ILK_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ILK_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0060ull);
 }
@@ -809,6 +901,7 @@ static inline uint64_t CVMX_DTX_ILK_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_ILK_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILK_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0040ull) + ((offset) & 1) * 8;
@@ -820,6 +913,7 @@ static inline uint64_t CVMX_DTX_ILK_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ILK_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILK_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0020ull) + ((offset) & 1) * 8;
@@ -831,6 +925,7 @@ static inline uint64_t CVMX_DTX_ILK_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ILK_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILK_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0000ull) + ((offset) & 1) * 8;
@@ -842,7 +937,7 @@ static inline uint64_t CVMX_DTX_ILK_SELX(unsigned long offset)
 #define CVMX_DTX_IOBN_BCST_RSP CVMX_DTX_IOBN_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBN_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE780080ull);
 }
@@ -853,7 +948,7 @@ static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
 #define CVMX_DTX_IOBN_CTL CVMX_DTX_IOBN_CTL_FUNC()
 static inline uint64_t CVMX_DTX_IOBN_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBN_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE780060ull);
 }
@@ -864,6 +959,7 @@ static inline uint64_t CVMX_DTX_IOBN_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_IOBN_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780040ull) + ((offset) & 1) * 8;
@@ -875,6 +971,7 @@ static inline uint64_t CVMX_DTX_IOBN_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_IOBN_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780020ull) + ((offset) & 1) * 8;
@@ -886,6 +983,7 @@ static inline uint64_t CVMX_DTX_IOBN_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE780000ull) + ((offset) & 1) * 8;
@@ -897,7 +995,7 @@ static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
 #define CVMX_DTX_IOBP_BCST_RSP CVMX_DTX_IOBP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0080ull);
 }
@@ -908,7 +1006,7 @@ static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_IOBP_CTL CVMX_DTX_IOBP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_IOBP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_IOBP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0060ull);
 }
@@ -919,6 +1017,7 @@ static inline uint64_t CVMX_DTX_IOBP_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_IOBP_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0040ull) + ((offset) & 1) * 8;
@@ -930,6 +1029,7 @@ static inline uint64_t CVMX_DTX_IOBP_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_IOBP_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0020ull) + ((offset) & 1) * 8;
@@ -941,6 +1041,7 @@ static inline uint64_t CVMX_DTX_IOBP_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_IOBP_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0000ull) + ((offset) & 1) * 8;
@@ -1118,6 +1219,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE420080ull) + ((offset) & 3) * 32768;
@@ -1130,6 +1232,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE420060ull) + ((offset) & 3) * 32768;
@@ -1142,6 +1245,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_DATX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1154,6 +1258,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_ENAX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1166,6 +1271,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_SELX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE420000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1178,6 +1284,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0080ull) + ((offset) & 3) * 32768;
@@ -1190,6 +1297,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0060ull) + ((offset) & 3) * 32768;
@@ -1202,6 +1310,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_DATX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1214,6 +1323,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_ENAX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1226,6 +1336,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_SELX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE2E0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1238,6 +1349,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE240080ull) + ((offset) & 7) * 32768;
@@ -1250,6 +1362,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE240060ull) + ((offset) & 7) * 32768;
@@ -1262,6 +1375,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_DATX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1274,6 +1388,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_ENAX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1286,6 +1401,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_SELX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE240000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
@@ -1297,6 +1413,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_SELX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_LAPX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LAPX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE060080ull) + ((offset) & 1) * 32768;
@@ -1308,6 +1425,7 @@ static inline uint64_t CVMX_DTX_LAPX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_LAPX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LAPX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE060060ull) + ((offset) & 1) * 32768;
@@ -1319,6 +1437,7 @@ static inline uint64_t CVMX_DTX_LAPX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_LAPX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LAPX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE060040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
@@ -1330,6 +1449,7 @@ static inline uint64_t CVMX_DTX_LAPX_DATX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_LAPX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LAPX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE060020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
@@ -1341,6 +1461,7 @@ static inline uint64_t CVMX_DTX_LAPX_ENAX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_LAPX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LAPX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE060000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
@@ -1352,7 +1473,7 @@ static inline uint64_t CVMX_DTX_LAPX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_LBK_BCST_RSP CVMX_DTX_LBK_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_LBK_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE090080ull);
 }
@@ -1363,7 +1484,7 @@ static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
 #define CVMX_DTX_LBK_CTL CVMX_DTX_LBK_CTL_FUNC()
 static inline uint64_t CVMX_DTX_LBK_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_LBK_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE090060ull);
 }
@@ -1374,6 +1495,7 @@ static inline uint64_t CVMX_DTX_LBK_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_LBK_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090040ull) + ((offset) & 1) * 8;
@@ -1385,6 +1507,7 @@ static inline uint64_t CVMX_DTX_LBK_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_LBK_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090020ull) + ((offset) & 1) * 8;
@@ -1396,6 +1519,7 @@ static inline uint64_t CVMX_DTX_LBK_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_LBK_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE090000ull) + ((offset) & 1) * 8;
@@ -1408,6 +1532,7 @@ static inline uint64_t CVMX_DTX_LMCX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_LMCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE440080ull) + ((offset) & 3) * 32768;
@@ -1420,6 +1545,7 @@ static inline uint64_t CVMX_DTX_LMCX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_LMCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE440060ull) + ((offset) & 3) * 32768;
@@ -1432,6 +1558,7 @@ static inline uint64_t CVMX_DTX_LMCX_DATX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1444,6 +1571,7 @@ static inline uint64_t CVMX_DTX_LMCX_ENAX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1456,6 +1584,7 @@ static inline uint64_t CVMX_DTX_LMCX_SELX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_LMCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE440000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1467,7 +1596,7 @@ static inline uint64_t CVMX_DTX_LMCX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_MIO_BCST_RSP CVMX_DTX_MIO_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_MIO_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE000080ull);
 }
@@ -1478,7 +1607,7 @@ static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
 #define CVMX_DTX_MIO_CTL CVMX_DTX_MIO_CTL_FUNC()
 static inline uint64_t CVMX_DTX_MIO_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_MIO_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE000060ull);
 }
@@ -1490,6 +1619,7 @@ static inline uint64_t CVMX_DTX_MIO_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000040ull) + ((offset) & 1) * 8;
@@ -1502,6 +1632,7 @@ static inline uint64_t CVMX_DTX_MIO_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000020ull) + ((offset) & 1) * 8;
@@ -1514,6 +1645,7 @@ static inline uint64_t CVMX_DTX_MIO_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE000000ull) + ((offset) & 1) * 8;
@@ -1525,6 +1657,7 @@ static inline uint64_t CVMX_DTX_MIO_SELX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_LNKX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE180080ull) + ((offset) & 3) * 32768;
@@ -1536,6 +1669,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_LNKX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE180060ull) + ((offset) & 3) * 32768;
@@ -1547,6 +1681,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_LNKX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE180040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1558,6 +1693,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_DATX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_LNKX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE180020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1569,6 +1705,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_ENAX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_LNKX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE180000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1580,6 +1717,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_SELX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_OLEX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0080ull) + ((offset) & 3) * 32768;
@@ -1591,6 +1729,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_OLEX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0060ull) + ((offset) & 3) * 32768;
@@ -1602,6 +1741,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_OLEX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1613,6 +1753,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_DATX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_OLEX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1624,6 +1765,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_ENAX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_OLEX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1635,7 +1777,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_SELX(unsigned long offset, unsigned lon
 #define CVMX_DTX_OCX_TOP_BCST_RSP CVMX_DTX_OCX_TOP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_OCX_TOP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_OCX_TOP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE088080ull);
 }
@@ -1646,7 +1788,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_OCX_TOP_CTL CVMX_DTX_OCX_TOP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_OCX_TOP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_OCX_TOP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE088060ull);
 }
@@ -1657,6 +1799,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_OCX_TOP_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_TOP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE088040ull) + ((offset) & 1) * 8;
@@ -1668,6 +1811,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_TOP_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_TOP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE088020ull) + ((offset) & 1) * 8;
@@ -1679,6 +1823,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_TOP_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_TOP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE088000ull) + ((offset) & 1) * 8;
@@ -1690,7 +1835,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_SELX(unsigned long offset)
 #define CVMX_DTX_OSM_BCST_RSP CVMX_DTX_OSM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_OSM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
 }
@@ -1701,7 +1846,7 @@ static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_OSM_CTL CVMX_DTX_OSM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_OSM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
 }
@@ -1712,6 +1857,7 @@ static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OSM_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
@@ -1723,6 +1869,7 @@ static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OSM_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
@@ -1734,6 +1881,7 @@ static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OSM_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
@@ -1801,6 +1949,7 @@ static inline uint64_t CVMX_DTX_PEMX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_PEMX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE600080ull) + ((offset) & 3) * 32768;
@@ -1813,6 +1962,7 @@ static inline uint64_t CVMX_DTX_PEMX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_PEMX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE600060ull) + ((offset) & 3) * 32768;
@@ -1825,6 +1975,7 @@ static inline uint64_t CVMX_DTX_PEMX_DATX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1837,6 +1988,7 @@ static inline uint64_t CVMX_DTX_PEMX_ENAX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1849,6 +2001,7 @@ static inline uint64_t CVMX_DTX_PEMX_SELX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_PEMX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -1915,7 +2068,7 @@ static inline uint64_t CVMX_DTX_PIP_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PBE_BCST_RSP CVMX_DTX_PKI_PBE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PBE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE228080ull);
 }
@@ -1926,7 +2079,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PBE_CTL CVMX_DTX_PKI_PBE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PBE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PBE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE228060ull);
 }
@@ -1937,6 +2090,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_PKI_PBE_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228040ull) + ((offset) & 1) * 8;
@@ -1948,6 +2102,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PBE_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228020ull) + ((offset) & 1) * 8;
@@ -1959,6 +2114,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE228000ull) + ((offset) & 1) * 8;
@@ -1970,7 +2126,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PFE_BCST_RSP CVMX_DTX_PKI_PFE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PFE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE220080ull);
 }
@@ -1981,7 +2137,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PFE_CTL CVMX_DTX_PKI_PFE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PFE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PFE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE220060ull);
 }
@@ -1992,6 +2148,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_PKI_PFE_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220040ull) + ((offset) & 1) * 8;
@@ -2003,6 +2160,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PFE_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220020ull) + ((offset) & 1) * 8;
@@ -2014,6 +2172,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE220000ull) + ((offset) & 1) * 8;
@@ -2025,7 +2184,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PIX_BCST_RSP CVMX_DTX_PKI_PIX_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PIX_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE230080ull);
 }
@@ -2036,7 +2195,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PIX_CTL CVMX_DTX_PKI_PIX_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PIX_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_PKI_PIX_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE230060ull);
 }
@@ -2047,6 +2206,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_PKI_PIX_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230040ull) + ((offset) & 1) * 8;
@@ -2058,6 +2218,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PIX_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230020ull) + ((offset) & 1) * 8;
@@ -2069,6 +2230,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_PKI_PIX_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE230000ull) + ((offset) & 1) * 8;
@@ -2085,6 +2247,7 @@ static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE280080ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 			break;
 	}
@@ -2099,6 +2262,7 @@ static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280080ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
@@ -2113,6 +2277,7 @@ static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800FE280060ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 			break;
 	}
@@ -2127,6 +2292,7 @@ static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280060ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
@@ -2141,6 +2307,7 @@ static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE280040ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + ((offset) & 1) * 8;
 			break;
@@ -2155,6 +2322,7 @@ static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280040ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
@@ -2169,6 +2337,7 @@ static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE280020ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + ((offset) & 1) * 8;
 			break;
@@ -2183,6 +2352,7 @@ static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280020ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
@@ -2197,6 +2367,7 @@ static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800FE280000ull) + ((offset) & 1) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + ((offset) & 1) * 8;
 			break;
@@ -2211,6 +2382,7 @@ static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
@@ -2275,7 +2447,7 @@ static inline uint64_t CVMX_DTX_POW_SELX(unsigned long offset)
 #define CVMX_DTX_RAD_BCST_RSP CVMX_DTX_RAD_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RAD_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE380080ull);
 }
@@ -2286,7 +2458,7 @@ static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RAD_CTL CVMX_DTX_RAD_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RAD_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RAD_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE380060ull);
 }
@@ -2297,6 +2469,7 @@ static inline uint64_t CVMX_DTX_RAD_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_RAD_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380040ull) + ((offset) & 1) * 8;
@@ -2308,6 +2481,7 @@ static inline uint64_t CVMX_DTX_RAD_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_RAD_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380020ull) + ((offset) & 1) * 8;
@@ -2319,6 +2493,7 @@ static inline uint64_t CVMX_DTX_RAD_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_RAD_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380000ull) + ((offset) & 1) * 8;
@@ -2330,7 +2505,7 @@ static inline uint64_t CVMX_DTX_RAD_SELX(unsigned long offset)
 #define CVMX_DTX_RNM_BCST_RSP CVMX_DTX_RNM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RNM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE200080ull);
 }
@@ -2341,7 +2516,7 @@ static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RNM_CTL CVMX_DTX_RNM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RNM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RNM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE200060ull);
 }
@@ -2352,6 +2527,7 @@ static inline uint64_t CVMX_DTX_RNM_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_RNM_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200040ull) + ((offset) & 1) * 8;
@@ -2363,6 +2539,7 @@ static inline uint64_t CVMX_DTX_RNM_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_RNM_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200020ull) + ((offset) & 1) * 8;
@@ -2374,6 +2551,7 @@ static inline uint64_t CVMX_DTX_RNM_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE200000ull) + ((offset) & 1) * 8;
@@ -2385,7 +2563,7 @@ static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
 #define CVMX_DTX_RST_BCST_RSP CVMX_DTX_RST_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RST_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE030080ull);
 }
@@ -2396,7 +2574,7 @@ static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RST_CTL CVMX_DTX_RST_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RST_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_RST_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE030060ull);
 }
@@ -2408,6 +2586,7 @@ static inline uint64_t CVMX_DTX_RST_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030040ull) + ((offset) & 1) * 8;
@@ -2420,6 +2599,7 @@ static inline uint64_t CVMX_DTX_RST_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030020ull) + ((offset) & 1) * 8;
@@ -2432,6 +2612,7 @@ static inline uint64_t CVMX_DTX_RST_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE030000ull) + ((offset) & 1) * 8;
@@ -2498,7 +2679,7 @@ static inline uint64_t CVMX_DTX_SATA_SELX(unsigned long offset)
 #define CVMX_DTX_SLI_BCST_RSP CVMX_DTX_SLI_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SLI_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8080ull);
 }
@@ -2509,7 +2690,7 @@ static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SLI_CTL CVMX_DTX_SLI_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SLI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SLI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8060ull);
 }
@@ -2521,6 +2702,7 @@ static inline uint64_t CVMX_DTX_SLI_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8040ull) + ((offset) & 1) * 8;
@@ -2533,6 +2715,7 @@ static inline uint64_t CVMX_DTX_SLI_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8020ull) + ((offset) & 1) * 8;
@@ -2545,6 +2728,7 @@ static inline uint64_t CVMX_DTX_SLI_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8000ull) + ((offset) & 1) * 8;
@@ -2556,7 +2740,7 @@ static inline uint64_t CVMX_DTX_SLI_SELX(unsigned long offset)
 #define CVMX_DTX_SSO_BCST_RSP CVMX_DTX_SSO_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SSO_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEB38080ull);
 }
@@ -2567,7 +2751,7 @@ static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SSO_CTL CVMX_DTX_SSO_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SSO_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_SSO_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEB38060ull);
 }
@@ -2578,6 +2762,7 @@ static inline uint64_t CVMX_DTX_SSO_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_SSO_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38040ull) + ((offset) & 1) * 8;
@@ -2589,6 +2774,7 @@ static inline uint64_t CVMX_DTX_SSO_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_SSO_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38020ull) + ((offset) & 1) * 8;
@@ -2600,6 +2786,7 @@ static inline uint64_t CVMX_DTX_SSO_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_SSO_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FEB38000ull) + ((offset) & 1) * 8;
@@ -2611,7 +2798,7 @@ static inline uint64_t CVMX_DTX_SSO_SELX(unsigned long offset)
 #define CVMX_DTX_TIM_BCST_RSP CVMX_DTX_TIM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_TIM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0080ull);
 }
@@ -2622,7 +2809,7 @@ static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_TIM_CTL CVMX_DTX_TIM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_TIM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_TIM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0060ull);
 }
@@ -2634,6 +2821,7 @@ static inline uint64_t CVMX_DTX_TIM_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0040ull) + ((offset) & 1) * 8;
@@ -2646,6 +2834,7 @@ static inline uint64_t CVMX_DTX_TIM_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0020ull) + ((offset) & 1) * 8;
@@ -2658,6 +2847,7 @@ static inline uint64_t CVMX_DTX_TIM_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0000ull) + ((offset) & 1) * 8;
@@ -2668,62 +2858,148 @@ static inline uint64_t CVMX_DTX_TIM_SELX(unsigned long offset)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_BCST_RSP(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_DTX_USBDRDX_BCST_RSP(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE348080ull) + ((offset) & 1) * 32768;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_BCST_RSP (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE348080ull) + ((offset) & 1) * 32768;
 }
 #else
-#define CVMX_DTX_USBDRDX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768)
+static inline uint64_t CVMX_DTX_USBDRDX_BCST_RSP(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340080ull) + (offset) * 32768;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348080ull) + (offset) * 32768;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348080ull) + (offset) * 32768;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_DTX_USBDRDX_CTL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE348060ull) + ((offset) & 1) * 32768;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE348060ull) + ((offset) & 1) * 32768;
 }
 #else
-#define CVMX_DTX_USBDRDX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768)
+static inline uint64_t CVMX_DTX_USBDRDX_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340060ull) + (offset) * 32768;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348060ull) + (offset) * 32768;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348060ull) + (offset) * 32768;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_DATX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_DTX_USBDRDX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE348040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_DATX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE348040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
 #else
-#define CVMX_DTX_USBDRDX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+static inline uint64_t CVMX_DTX_USBDRDX_DATX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348040ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348040ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_ENAX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_DTX_USBDRDX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE348020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_ENAX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE348020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
 #else
-#define CVMX_DTX_USBDRDX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+static inline uint64_t CVMX_DTX_USBDRDX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348020ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348020ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBDRDX_SELX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_DTX_USBDRDX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800FE348000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_USBDRDX_SELX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE348000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
 }
 #else
-#define CVMX_DTX_USBDRDX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+static inline uint64_t CVMX_DTX_USBDRDX_SELX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE348000ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE348000ull) + ((offset) + (block_id) * 0x1000ull) * 8;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_DTX_USBHX_BCST_RSP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340080ull);
@@ -2735,6 +3011,7 @@ static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long block_id)
 static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_DTX_USBHX_CTL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340060ull);
@@ -2746,6 +3023,7 @@ static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long block_id)
 static inline uint64_t CVMX_DTX_USBHX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -2757,6 +3035,7 @@ static inline uint64_t CVMX_DTX_USBHX_DATX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_USBHX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -2768,6 +3047,7 @@ static inline uint64_t CVMX_DTX_USBHX_ENAX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_USBHX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -2779,7 +3059,7 @@ static inline uint64_t CVMX_DTX_USBHX_SELX(unsigned long offset, unsigned long b
 #define CVMX_DTX_ZIP_BCST_RSP CVMX_DTX_ZIP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ZIP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0080ull);
 }
@@ -2790,7 +3070,7 @@ static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ZIP_CTL CVMX_DTX_ZIP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ZIP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_DTX_ZIP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0060ull);
 }
@@ -2801,6 +3081,7 @@ static inline uint64_t CVMX_DTX_ZIP_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_ZIP_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0040ull) + ((offset) & 1) * 8;
@@ -2812,6 +3093,7 @@ static inline uint64_t CVMX_DTX_ZIP_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ZIP_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0020ull) + ((offset) & 1) * 8;
@@ -2823,6 +3105,7 @@ static inline uint64_t CVMX_DTX_ZIP_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ZIP_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0000ull) + ((offset) & 1) * 8;
@@ -3037,6 +3320,106 @@ union cvmx_dtx_ase_selx {
 typedef union cvmx_dtx_ase_selx cvmx_dtx_ase_selx_t;
 
 /**
+ * cvmx_dtx_bch_bcst_rsp
+ */
+union cvmx_dtx_bch_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_bch_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_bch_bcst_rsp_s        cn73xx;
+};
+typedef union cvmx_dtx_bch_bcst_rsp cvmx_dtx_bch_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_bch_ctl
+ */
+union cvmx_dtx_bch_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_bch_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_bch_ctl_s             cn73xx;
+};
+typedef union cvmx_dtx_bch_ctl cvmx_dtx_bch_ctl_t;
+
+/**
+ * cvmx_dtx_bch_dat#
+ */
+union cvmx_dtx_bch_datx {
+	uint64_t u64;
+	struct cvmx_dtx_bch_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_bch_datx_s            cn73xx;
+};
+typedef union cvmx_dtx_bch_datx cvmx_dtx_bch_datx_t;
+
+/**
+ * cvmx_dtx_bch_ena#
+ */
+union cvmx_dtx_bch_enax {
+	uint64_t u64;
+	struct cvmx_dtx_bch_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_bch_enax_s            cn73xx;
+};
+typedef union cvmx_dtx_bch_enax cvmx_dtx_bch_enax_t;
+
+/**
+ * cvmx_dtx_bch_sel#
+ */
+union cvmx_dtx_bch_selx {
+	uint64_t u64;
+	struct cvmx_dtx_bch_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_bch_selx_s            cn73xx;
+};
+typedef union cvmx_dtx_bch_selx cvmx_dtx_bch_selx_t;
+
+/**
  * cvmx_dtx_bgx#_bcst_rsp
  */
 union cvmx_dtx_bgxx_bcst_rsp {
@@ -3050,6 +3433,7 @@ union cvmx_dtx_bgxx_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_bgxx_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_bgxx_bcst_rsp cvmx_dtx_bgxx_bcst_rsp_t;
@@ -3076,6 +3460,7 @@ union cvmx_dtx_bgxx_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_ctl_s            cn73xx;
 	struct cvmx_dtx_bgxx_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_bgxx_ctl cvmx_dtx_bgxx_ctl_t;
@@ -3095,6 +3480,7 @@ union cvmx_dtx_bgxx_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_datx_s           cn73xx;
 	struct cvmx_dtx_bgxx_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_bgxx_datx cvmx_dtx_bgxx_datx_t;
@@ -3114,6 +3500,7 @@ union cvmx_dtx_bgxx_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_enax_s           cn73xx;
 	struct cvmx_dtx_bgxx_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_bgxx_enax cvmx_dtx_bgxx_enax_t;
@@ -3132,6 +3519,7 @@ union cvmx_dtx_bgxx_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_bgxx_selx_s           cn73xx;
 	struct cvmx_dtx_bgxx_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_bgxx_selx cvmx_dtx_bgxx_selx_t;
@@ -3160,6 +3548,7 @@ union cvmx_dtx_broadcast_ctl {
 	} s;
 	struct cvmx_dtx_broadcast_ctl_s       cn70xx;
 	struct cvmx_dtx_broadcast_ctl_s       cn70xxp1;
+	struct cvmx_dtx_broadcast_ctl_s       cn73xx;
 	struct cvmx_dtx_broadcast_ctl_s       cn78xx;
 };
 typedef union cvmx_dtx_broadcast_ctl cvmx_dtx_broadcast_ctl_t;
@@ -3181,6 +3570,7 @@ union cvmx_dtx_broadcast_enax {
 	} s;
 	struct cvmx_dtx_broadcast_enax_s      cn70xx;
 	struct cvmx_dtx_broadcast_enax_s      cn70xxp1;
+	struct cvmx_dtx_broadcast_enax_s      cn73xx;
 	struct cvmx_dtx_broadcast_enax_s      cn78xx;
 };
 typedef union cvmx_dtx_broadcast_enax cvmx_dtx_broadcast_enax_t;
@@ -3201,6 +3591,7 @@ union cvmx_dtx_broadcast_selx {
 	} s;
 	struct cvmx_dtx_broadcast_selx_s      cn70xx;
 	struct cvmx_dtx_broadcast_selx_s      cn70xxp1;
+	struct cvmx_dtx_broadcast_selx_s      cn73xx;
 	struct cvmx_dtx_broadcast_selx_s      cn78xx;
 };
 typedef union cvmx_dtx_broadcast_selx cvmx_dtx_broadcast_selx_t;
@@ -3219,6 +3610,7 @@ union cvmx_dtx_ciu_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_ciu_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_ciu_bcst_rsp cvmx_dtx_ciu_bcst_rsp_t;
@@ -3245,6 +3637,7 @@ union cvmx_dtx_ciu_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_ctl_s             cn73xx;
 	struct cvmx_dtx_ciu_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_ciu_ctl cvmx_dtx_ciu_ctl_t;
@@ -3264,6 +3657,7 @@ union cvmx_dtx_ciu_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_datx_s            cn73xx;
 	struct cvmx_dtx_ciu_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_ciu_datx cvmx_dtx_ciu_datx_t;
@@ -3283,6 +3677,7 @@ union cvmx_dtx_ciu_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_enax_s            cn73xx;
 	struct cvmx_dtx_ciu_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_ciu_enax cvmx_dtx_ciu_enax_t;
@@ -3301,6 +3696,7 @@ union cvmx_dtx_ciu_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_ciu_selx_s            cn73xx;
 	struct cvmx_dtx_ciu_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_ciu_selx cvmx_dtx_ciu_selx_t;
@@ -3321,6 +3717,7 @@ union cvmx_dtx_dfa_bcst_rsp {
 	} s;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_dfa_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_dfa_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_dfa_bcst_rsp cvmx_dtx_dfa_bcst_rsp_t;
@@ -3349,6 +3746,7 @@ union cvmx_dtx_dfa_ctl {
 	} s;
 	struct cvmx_dtx_dfa_ctl_s             cn70xx;
 	struct cvmx_dtx_dfa_ctl_s             cn70xxp1;
+	struct cvmx_dtx_dfa_ctl_s             cn73xx;
 	struct cvmx_dtx_dfa_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_dfa_ctl cvmx_dtx_dfa_ctl_t;
@@ -3370,6 +3768,7 @@ union cvmx_dtx_dfa_datx {
 	} s;
 	struct cvmx_dtx_dfa_datx_s            cn70xx;
 	struct cvmx_dtx_dfa_datx_s            cn70xxp1;
+	struct cvmx_dtx_dfa_datx_s            cn73xx;
 	struct cvmx_dtx_dfa_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_dfa_datx cvmx_dtx_dfa_datx_t;
@@ -3391,6 +3790,7 @@ union cvmx_dtx_dfa_enax {
 	} s;
 	struct cvmx_dtx_dfa_enax_s            cn70xx;
 	struct cvmx_dtx_dfa_enax_s            cn70xxp1;
+	struct cvmx_dtx_dfa_enax_s            cn73xx;
 	struct cvmx_dtx_dfa_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_dfa_enax cvmx_dtx_dfa_enax_t;
@@ -3411,6 +3811,7 @@ union cvmx_dtx_dfa_selx {
 	} s;
 	struct cvmx_dtx_dfa_selx_s            cn70xx;
 	struct cvmx_dtx_dfa_selx_s            cn70xxp1;
+	struct cvmx_dtx_dfa_selx_s            cn73xx;
 	struct cvmx_dtx_dfa_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_dfa_selx cvmx_dtx_dfa_selx_t;
@@ -3431,6 +3832,7 @@ union cvmx_dtx_dpi_bcst_rsp {
 	} s;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_dpi_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_dpi_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_dpi_bcst_rsp cvmx_dtx_dpi_bcst_rsp_t;
@@ -3459,6 +3861,7 @@ union cvmx_dtx_dpi_ctl {
 	} s;
 	struct cvmx_dtx_dpi_ctl_s             cn70xx;
 	struct cvmx_dtx_dpi_ctl_s             cn70xxp1;
+	struct cvmx_dtx_dpi_ctl_s             cn73xx;
 	struct cvmx_dtx_dpi_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_dpi_ctl cvmx_dtx_dpi_ctl_t;
@@ -3480,6 +3883,7 @@ union cvmx_dtx_dpi_datx {
 	} s;
 	struct cvmx_dtx_dpi_datx_s            cn70xx;
 	struct cvmx_dtx_dpi_datx_s            cn70xxp1;
+	struct cvmx_dtx_dpi_datx_s            cn73xx;
 	struct cvmx_dtx_dpi_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_dpi_datx cvmx_dtx_dpi_datx_t;
@@ -3501,6 +3905,7 @@ union cvmx_dtx_dpi_enax {
 	} s;
 	struct cvmx_dtx_dpi_enax_s            cn70xx;
 	struct cvmx_dtx_dpi_enax_s            cn70xxp1;
+	struct cvmx_dtx_dpi_enax_s            cn73xx;
 	struct cvmx_dtx_dpi_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_dpi_enax cvmx_dtx_dpi_enax_t;
@@ -3521,6 +3926,7 @@ union cvmx_dtx_dpi_selx {
 	} s;
 	struct cvmx_dtx_dpi_selx_s            cn70xx;
 	struct cvmx_dtx_dpi_selx_s            cn70xxp1;
+	struct cvmx_dtx_dpi_selx_s            cn73xx;
 	struct cvmx_dtx_dpi_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_dpi_selx cvmx_dtx_dpi_selx_t;
@@ -3541,6 +3947,7 @@ union cvmx_dtx_fpa_bcst_rsp {
 	} s;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_fpa_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_fpa_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_fpa_bcst_rsp cvmx_dtx_fpa_bcst_rsp_t;
@@ -3569,6 +3976,7 @@ union cvmx_dtx_fpa_ctl {
 	} s;
 	struct cvmx_dtx_fpa_ctl_s             cn70xx;
 	struct cvmx_dtx_fpa_ctl_s             cn70xxp1;
+	struct cvmx_dtx_fpa_ctl_s             cn73xx;
 	struct cvmx_dtx_fpa_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_fpa_ctl cvmx_dtx_fpa_ctl_t;
@@ -3590,6 +3998,7 @@ union cvmx_dtx_fpa_datx {
 	} s;
 	struct cvmx_dtx_fpa_datx_s            cn70xx;
 	struct cvmx_dtx_fpa_datx_s            cn70xxp1;
+	struct cvmx_dtx_fpa_datx_s            cn73xx;
 	struct cvmx_dtx_fpa_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_fpa_datx cvmx_dtx_fpa_datx_t;
@@ -3611,6 +4020,7 @@ union cvmx_dtx_fpa_enax {
 	} s;
 	struct cvmx_dtx_fpa_enax_s            cn70xx;
 	struct cvmx_dtx_fpa_enax_s            cn70xxp1;
+	struct cvmx_dtx_fpa_enax_s            cn73xx;
 	struct cvmx_dtx_fpa_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_fpa_enax cvmx_dtx_fpa_enax_t;
@@ -3631,6 +4041,7 @@ union cvmx_dtx_fpa_selx {
 	} s;
 	struct cvmx_dtx_fpa_selx_s            cn70xx;
 	struct cvmx_dtx_fpa_selx_s            cn70xxp1;
+	struct cvmx_dtx_fpa_selx_s            cn73xx;
 	struct cvmx_dtx_fpa_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_fpa_selx cvmx_dtx_fpa_selx_t;
@@ -3754,6 +4165,7 @@ union cvmx_dtx_gserx_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_bcst_rsp_s      cn73xx;
 	struct cvmx_dtx_gserx_bcst_rsp_s      cn78xx;
 };
 typedef union cvmx_dtx_gserx_bcst_rsp cvmx_dtx_gserx_bcst_rsp_t;
@@ -3780,6 +4192,7 @@ union cvmx_dtx_gserx_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_ctl_s           cn73xx;
 	struct cvmx_dtx_gserx_ctl_s           cn78xx;
 };
 typedef union cvmx_dtx_gserx_ctl cvmx_dtx_gserx_ctl_t;
@@ -3799,6 +4212,7 @@ union cvmx_dtx_gserx_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_datx_s          cn73xx;
 	struct cvmx_dtx_gserx_datx_s          cn78xx;
 };
 typedef union cvmx_dtx_gserx_datx cvmx_dtx_gserx_datx_t;
@@ -3818,6 +4232,7 @@ union cvmx_dtx_gserx_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_enax_s          cn73xx;
 	struct cvmx_dtx_gserx_enax_s          cn78xx;
 };
 typedef union cvmx_dtx_gserx_enax cvmx_dtx_gserx_enax_t;
@@ -3836,6 +4251,7 @@ union cvmx_dtx_gserx_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_gserx_selx_s          cn73xx;
 	struct cvmx_dtx_gserx_selx_s          cn78xx;
 };
 typedef union cvmx_dtx_gserx_selx cvmx_dtx_gserx_selx_t;
@@ -3854,6 +4270,7 @@ union cvmx_dtx_hna_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_hna_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_hna_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_hna_bcst_rsp cvmx_dtx_hna_bcst_rsp_t;
@@ -3880,6 +4297,7 @@ union cvmx_dtx_hna_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_hna_ctl_s             cn73xx;
 	struct cvmx_dtx_hna_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_hna_ctl cvmx_dtx_hna_ctl_t;
@@ -3899,6 +4317,7 @@ union cvmx_dtx_hna_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_hna_datx_s            cn73xx;
 	struct cvmx_dtx_hna_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_hna_datx cvmx_dtx_hna_datx_t;
@@ -3918,6 +4337,7 @@ union cvmx_dtx_hna_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_hna_enax_s            cn73xx;
 	struct cvmx_dtx_hna_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_hna_enax cvmx_dtx_hna_enax_t;
@@ -3936,6 +4356,7 @@ union cvmx_dtx_hna_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_hna_selx_s            cn73xx;
 	struct cvmx_dtx_hna_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_hna_selx cvmx_dtx_hna_selx_t;
@@ -3954,6 +4375,7 @@ union cvmx_dtx_ila_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_ila_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_ila_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_ila_bcst_rsp cvmx_dtx_ila_bcst_rsp_t;
@@ -3980,6 +4402,7 @@ union cvmx_dtx_ila_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_ila_ctl_s             cn73xx;
 	struct cvmx_dtx_ila_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_ila_ctl cvmx_dtx_ila_ctl_t;
@@ -3999,6 +4422,7 @@ union cvmx_dtx_ila_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ila_datx_s            cn73xx;
 	struct cvmx_dtx_ila_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_ila_datx cvmx_dtx_ila_datx_t;
@@ -4018,6 +4442,7 @@ union cvmx_dtx_ila_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ila_enax_s            cn73xx;
 	struct cvmx_dtx_ila_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_ila_enax cvmx_dtx_ila_enax_t;
@@ -4036,6 +4461,7 @@ union cvmx_dtx_ila_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_ila_selx_s            cn73xx;
 	struct cvmx_dtx_ila_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_ila_selx cvmx_dtx_ila_selx_t;
@@ -4054,6 +4480,7 @@ union cvmx_dtx_ilk_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_ilk_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_ilk_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_ilk_bcst_rsp cvmx_dtx_ilk_bcst_rsp_t;
@@ -4080,6 +4507,7 @@ union cvmx_dtx_ilk_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_ilk_ctl_s             cn73xx;
 	struct cvmx_dtx_ilk_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_ilk_ctl cvmx_dtx_ilk_ctl_t;
@@ -4099,6 +4527,7 @@ union cvmx_dtx_ilk_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ilk_datx_s            cn73xx;
 	struct cvmx_dtx_ilk_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_ilk_datx cvmx_dtx_ilk_datx_t;
@@ -4118,6 +4547,7 @@ union cvmx_dtx_ilk_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ilk_enax_s            cn73xx;
 	struct cvmx_dtx_ilk_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_ilk_enax cvmx_dtx_ilk_enax_t;
@@ -4136,6 +4566,7 @@ union cvmx_dtx_ilk_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_ilk_selx_s            cn73xx;
 	struct cvmx_dtx_ilk_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_ilk_selx cvmx_dtx_ilk_selx_t;
@@ -4259,6 +4690,7 @@ union cvmx_dtx_iobn_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_iobn_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_iobn_bcst_rsp cvmx_dtx_iobn_bcst_rsp_t;
@@ -4285,6 +4717,7 @@ union cvmx_dtx_iobn_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_ctl_s            cn73xx;
 	struct cvmx_dtx_iobn_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_iobn_ctl cvmx_dtx_iobn_ctl_t;
@@ -4304,6 +4737,7 @@ union cvmx_dtx_iobn_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_datx_s           cn73xx;
 	struct cvmx_dtx_iobn_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_iobn_datx cvmx_dtx_iobn_datx_t;
@@ -4323,6 +4757,7 @@ union cvmx_dtx_iobn_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_enax_s           cn73xx;
 	struct cvmx_dtx_iobn_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_iobn_enax cvmx_dtx_iobn_enax_t;
@@ -4341,6 +4776,7 @@ union cvmx_dtx_iobn_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_iobn_selx_s           cn73xx;
 	struct cvmx_dtx_iobn_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_iobn_selx cvmx_dtx_iobn_selx_t;
@@ -4359,6 +4795,7 @@ union cvmx_dtx_iobp_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_iobp_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_iobp_bcst_rsp cvmx_dtx_iobp_bcst_rsp_t;
@@ -4385,6 +4822,7 @@ union cvmx_dtx_iobp_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_ctl_s            cn73xx;
 	struct cvmx_dtx_iobp_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_iobp_ctl cvmx_dtx_iobp_ctl_t;
@@ -4404,6 +4842,7 @@ union cvmx_dtx_iobp_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_datx_s           cn73xx;
 	struct cvmx_dtx_iobp_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_iobp_datx cvmx_dtx_iobp_datx_t;
@@ -4423,6 +4862,7 @@ union cvmx_dtx_iobp_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_enax_s           cn73xx;
 	struct cvmx_dtx_iobp_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_iobp_enax cvmx_dtx_iobp_enax_t;
@@ -4441,6 +4881,7 @@ union cvmx_dtx_iobp_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_iobp_selx_s           cn73xx;
 	struct cvmx_dtx_iobp_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_iobp_selx cvmx_dtx_iobp_selx_t;
@@ -4671,6 +5112,7 @@ union cvmx_dtx_l2c_cbcx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn73xx;
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_bcst_rsp cvmx_dtx_l2c_cbcx_bcst_rsp_t;
@@ -4699,6 +5141,7 @@ union cvmx_dtx_l2c_cbcx_ctl {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_ctl_s        cn73xx;
 	struct cvmx_dtx_l2c_cbcx_ctl_s        cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_ctl cvmx_dtx_l2c_cbcx_ctl_t;
@@ -4720,6 +5163,7 @@ union cvmx_dtx_l2c_cbcx_datx {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_datx_s       cn73xx;
 	struct cvmx_dtx_l2c_cbcx_datx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_datx cvmx_dtx_l2c_cbcx_datx_t;
@@ -4741,6 +5185,7 @@ union cvmx_dtx_l2c_cbcx_enax {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_enax_s       cn73xx;
 	struct cvmx_dtx_l2c_cbcx_enax_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_enax cvmx_dtx_l2c_cbcx_enax_t;
@@ -4761,6 +5206,7 @@ union cvmx_dtx_l2c_cbcx_selx {
 	} s;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_selx_s       cn73xx;
 	struct cvmx_dtx_l2c_cbcx_selx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_cbcx_selx cvmx_dtx_l2c_cbcx_selx_t;
@@ -4781,6 +5227,7 @@ union cvmx_dtx_l2c_mcix_bcst_rsp {
 	} s;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn73xx;
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_bcst_rsp cvmx_dtx_l2c_mcix_bcst_rsp_t;
@@ -4809,6 +5256,7 @@ union cvmx_dtx_l2c_mcix_ctl {
 	} s;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_ctl_s        cn73xx;
 	struct cvmx_dtx_l2c_mcix_ctl_s        cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_ctl cvmx_dtx_l2c_mcix_ctl_t;
@@ -4830,6 +5278,7 @@ union cvmx_dtx_l2c_mcix_datx {
 	} s;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_datx_s       cn73xx;
 	struct cvmx_dtx_l2c_mcix_datx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_datx cvmx_dtx_l2c_mcix_datx_t;
@@ -4851,6 +5300,7 @@ union cvmx_dtx_l2c_mcix_enax {
 	} s;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_enax_s       cn73xx;
 	struct cvmx_dtx_l2c_mcix_enax_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_enax cvmx_dtx_l2c_mcix_enax_t;
@@ -4871,6 +5321,7 @@ union cvmx_dtx_l2c_mcix_selx {
 	} s;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_selx_s       cn73xx;
 	struct cvmx_dtx_l2c_mcix_selx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_mcix_selx cvmx_dtx_l2c_mcix_selx_t;
@@ -4891,6 +5342,7 @@ union cvmx_dtx_l2c_tadx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn70xx;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn73xx;
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_bcst_rsp cvmx_dtx_l2c_tadx_bcst_rsp_t;
@@ -4919,6 +5371,7 @@ union cvmx_dtx_l2c_tadx_ctl {
 	} s;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn70xx;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_ctl_s        cn73xx;
 	struct cvmx_dtx_l2c_tadx_ctl_s        cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_ctl cvmx_dtx_l2c_tadx_ctl_t;
@@ -4940,6 +5393,7 @@ union cvmx_dtx_l2c_tadx_datx {
 	} s;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_datx_s       cn73xx;
 	struct cvmx_dtx_l2c_tadx_datx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_datx cvmx_dtx_l2c_tadx_datx_t;
@@ -4961,6 +5415,7 @@ union cvmx_dtx_l2c_tadx_enax {
 	} s;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_enax_s       cn73xx;
 	struct cvmx_dtx_l2c_tadx_enax_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_enax cvmx_dtx_l2c_tadx_enax_t;
@@ -4981,6 +5436,7 @@ union cvmx_dtx_l2c_tadx_selx {
 	} s;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn70xx;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_selx_s       cn73xx;
 	struct cvmx_dtx_l2c_tadx_selx_s       cn78xx;
 };
 typedef union cvmx_dtx_l2c_tadx_selx cvmx_dtx_l2c_tadx_selx_t;
@@ -4999,6 +5455,7 @@ union cvmx_dtx_lapx_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_lapx_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_lapx_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_lapx_bcst_rsp cvmx_dtx_lapx_bcst_rsp_t;
@@ -5025,6 +5482,7 @@ union cvmx_dtx_lapx_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_lapx_ctl_s            cn73xx;
 	struct cvmx_dtx_lapx_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_lapx_ctl cvmx_dtx_lapx_ctl_t;
@@ -5044,6 +5502,7 @@ union cvmx_dtx_lapx_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_lapx_datx_s           cn73xx;
 	struct cvmx_dtx_lapx_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_lapx_datx cvmx_dtx_lapx_datx_t;
@@ -5063,6 +5522,7 @@ union cvmx_dtx_lapx_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_lapx_enax_s           cn73xx;
 	struct cvmx_dtx_lapx_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_lapx_enax cvmx_dtx_lapx_enax_t;
@@ -5081,6 +5541,7 @@ union cvmx_dtx_lapx_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_lapx_selx_s           cn73xx;
 	struct cvmx_dtx_lapx_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_lapx_selx cvmx_dtx_lapx_selx_t;
@@ -5099,6 +5560,7 @@ union cvmx_dtx_lbk_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_lbk_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_lbk_bcst_rsp cvmx_dtx_lbk_bcst_rsp_t;
@@ -5125,6 +5587,7 @@ union cvmx_dtx_lbk_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_ctl_s             cn73xx;
 	struct cvmx_dtx_lbk_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_lbk_ctl cvmx_dtx_lbk_ctl_t;
@@ -5144,6 +5607,7 @@ union cvmx_dtx_lbk_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_datx_s            cn73xx;
 	struct cvmx_dtx_lbk_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_lbk_datx cvmx_dtx_lbk_datx_t;
@@ -5163,6 +5627,7 @@ union cvmx_dtx_lbk_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_enax_s            cn73xx;
 	struct cvmx_dtx_lbk_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_lbk_enax cvmx_dtx_lbk_enax_t;
@@ -5181,6 +5646,7 @@ union cvmx_dtx_lbk_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_lbk_selx_s            cn73xx;
 	struct cvmx_dtx_lbk_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_lbk_selx cvmx_dtx_lbk_selx_t;
@@ -5201,6 +5667,7 @@ union cvmx_dtx_lmcx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn70xx;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn70xxp1;
+	struct cvmx_dtx_lmcx_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_lmcx_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_lmcx_bcst_rsp cvmx_dtx_lmcx_bcst_rsp_t;
@@ -5229,6 +5696,7 @@ union cvmx_dtx_lmcx_ctl {
 	} s;
 	struct cvmx_dtx_lmcx_ctl_s            cn70xx;
 	struct cvmx_dtx_lmcx_ctl_s            cn70xxp1;
+	struct cvmx_dtx_lmcx_ctl_s            cn73xx;
 	struct cvmx_dtx_lmcx_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_lmcx_ctl cvmx_dtx_lmcx_ctl_t;
@@ -5250,6 +5718,7 @@ union cvmx_dtx_lmcx_datx {
 	} s;
 	struct cvmx_dtx_lmcx_datx_s           cn70xx;
 	struct cvmx_dtx_lmcx_datx_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_datx_s           cn73xx;
 	struct cvmx_dtx_lmcx_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_lmcx_datx cvmx_dtx_lmcx_datx_t;
@@ -5271,6 +5740,7 @@ union cvmx_dtx_lmcx_enax {
 	} s;
 	struct cvmx_dtx_lmcx_enax_s           cn70xx;
 	struct cvmx_dtx_lmcx_enax_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_enax_s           cn73xx;
 	struct cvmx_dtx_lmcx_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_lmcx_enax cvmx_dtx_lmcx_enax_t;
@@ -5291,6 +5761,7 @@ union cvmx_dtx_lmcx_selx {
 	} s;
 	struct cvmx_dtx_lmcx_selx_s           cn70xx;
 	struct cvmx_dtx_lmcx_selx_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_selx_s           cn73xx;
 	struct cvmx_dtx_lmcx_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_lmcx_selx cvmx_dtx_lmcx_selx_t;
@@ -5311,6 +5782,7 @@ union cvmx_dtx_mio_bcst_rsp {
 	} s;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_mio_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_mio_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_mio_bcst_rsp cvmx_dtx_mio_bcst_rsp_t;
@@ -5339,6 +5811,7 @@ union cvmx_dtx_mio_ctl {
 	} s;
 	struct cvmx_dtx_mio_ctl_s             cn70xx;
 	struct cvmx_dtx_mio_ctl_s             cn70xxp1;
+	struct cvmx_dtx_mio_ctl_s             cn73xx;
 	struct cvmx_dtx_mio_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_mio_ctl cvmx_dtx_mio_ctl_t;
@@ -5360,6 +5833,7 @@ union cvmx_dtx_mio_datx {
 	} s;
 	struct cvmx_dtx_mio_datx_s            cn70xx;
 	struct cvmx_dtx_mio_datx_s            cn70xxp1;
+	struct cvmx_dtx_mio_datx_s            cn73xx;
 	struct cvmx_dtx_mio_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_mio_datx cvmx_dtx_mio_datx_t;
@@ -5381,6 +5855,7 @@ union cvmx_dtx_mio_enax {
 	} s;
 	struct cvmx_dtx_mio_enax_s            cn70xx;
 	struct cvmx_dtx_mio_enax_s            cn70xxp1;
+	struct cvmx_dtx_mio_enax_s            cn73xx;
 	struct cvmx_dtx_mio_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_mio_enax cvmx_dtx_mio_enax_t;
@@ -5401,6 +5876,7 @@ union cvmx_dtx_mio_selx {
 	} s;
 	struct cvmx_dtx_mio_selx_s            cn70xx;
 	struct cvmx_dtx_mio_selx_s            cn70xxp1;
+	struct cvmx_dtx_mio_selx_s            cn73xx;
 	struct cvmx_dtx_mio_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_mio_selx cvmx_dtx_mio_selx_t;
@@ -5419,6 +5895,7 @@ union cvmx_dtx_ocx_lnkx_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_lnkx_bcst_rsp_s   cn73xx;
 	struct cvmx_dtx_ocx_lnkx_bcst_rsp_s   cn78xx;
 };
 typedef union cvmx_dtx_ocx_lnkx_bcst_rsp cvmx_dtx_ocx_lnkx_bcst_rsp_t;
@@ -5445,6 +5922,7 @@ union cvmx_dtx_ocx_lnkx_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_lnkx_ctl_s        cn73xx;
 	struct cvmx_dtx_ocx_lnkx_ctl_s        cn78xx;
 };
 typedef union cvmx_dtx_ocx_lnkx_ctl cvmx_dtx_ocx_lnkx_ctl_t;
@@ -5464,6 +5942,7 @@ union cvmx_dtx_ocx_lnkx_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_lnkx_datx_s       cn73xx;
 	struct cvmx_dtx_ocx_lnkx_datx_s       cn78xx;
 };
 typedef union cvmx_dtx_ocx_lnkx_datx cvmx_dtx_ocx_lnkx_datx_t;
@@ -5483,6 +5962,7 @@ union cvmx_dtx_ocx_lnkx_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_lnkx_enax_s       cn73xx;
 	struct cvmx_dtx_ocx_lnkx_enax_s       cn78xx;
 };
 typedef union cvmx_dtx_ocx_lnkx_enax cvmx_dtx_ocx_lnkx_enax_t;
@@ -5501,6 +5981,7 @@ union cvmx_dtx_ocx_lnkx_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_lnkx_selx_s       cn73xx;
 	struct cvmx_dtx_ocx_lnkx_selx_s       cn78xx;
 };
 typedef union cvmx_dtx_ocx_lnkx_selx cvmx_dtx_ocx_lnkx_selx_t;
@@ -5519,6 +6000,7 @@ union cvmx_dtx_ocx_olex_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_olex_bcst_rsp_s   cn73xx;
 	struct cvmx_dtx_ocx_olex_bcst_rsp_s   cn78xx;
 };
 typedef union cvmx_dtx_ocx_olex_bcst_rsp cvmx_dtx_ocx_olex_bcst_rsp_t;
@@ -5545,6 +6027,7 @@ union cvmx_dtx_ocx_olex_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_olex_ctl_s        cn73xx;
 	struct cvmx_dtx_ocx_olex_ctl_s        cn78xx;
 };
 typedef union cvmx_dtx_ocx_olex_ctl cvmx_dtx_ocx_olex_ctl_t;
@@ -5564,6 +6047,7 @@ union cvmx_dtx_ocx_olex_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_olex_datx_s       cn73xx;
 	struct cvmx_dtx_ocx_olex_datx_s       cn78xx;
 };
 typedef union cvmx_dtx_ocx_olex_datx cvmx_dtx_ocx_olex_datx_t;
@@ -5583,6 +6067,7 @@ union cvmx_dtx_ocx_olex_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_olex_enax_s       cn73xx;
 	struct cvmx_dtx_ocx_olex_enax_s       cn78xx;
 };
 typedef union cvmx_dtx_ocx_olex_enax cvmx_dtx_ocx_olex_enax_t;
@@ -5601,6 +6086,7 @@ union cvmx_dtx_ocx_olex_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_olex_selx_s       cn73xx;
 	struct cvmx_dtx_ocx_olex_selx_s       cn78xx;
 };
 typedef union cvmx_dtx_ocx_olex_selx cvmx_dtx_ocx_olex_selx_t;
@@ -5619,6 +6105,7 @@ union cvmx_dtx_ocx_top_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_top_bcst_rsp_s    cn73xx;
 	struct cvmx_dtx_ocx_top_bcst_rsp_s    cn78xx;
 };
 typedef union cvmx_dtx_ocx_top_bcst_rsp cvmx_dtx_ocx_top_bcst_rsp_t;
@@ -5645,6 +6132,7 @@ union cvmx_dtx_ocx_top_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_top_ctl_s         cn73xx;
 	struct cvmx_dtx_ocx_top_ctl_s         cn78xx;
 };
 typedef union cvmx_dtx_ocx_top_ctl cvmx_dtx_ocx_top_ctl_t;
@@ -5664,6 +6152,7 @@ union cvmx_dtx_ocx_top_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_top_datx_s        cn73xx;
 	struct cvmx_dtx_ocx_top_datx_s        cn78xx;
 };
 typedef union cvmx_dtx_ocx_top_datx cvmx_dtx_ocx_top_datx_t;
@@ -5683,6 +6172,7 @@ union cvmx_dtx_ocx_top_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_top_enax_s        cn73xx;
 	struct cvmx_dtx_ocx_top_enax_s        cn78xx;
 };
 typedef union cvmx_dtx_ocx_top_enax cvmx_dtx_ocx_top_enax_t;
@@ -5701,6 +6191,7 @@ union cvmx_dtx_ocx_top_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_ocx_top_selx_s        cn73xx;
 	struct cvmx_dtx_ocx_top_selx_s        cn78xx;
 };
 typedef union cvmx_dtx_ocx_top_selx cvmx_dtx_ocx_top_selx_t;
@@ -5719,6 +6210,7 @@ union cvmx_dtx_osm_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_osm_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_osm_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_osm_bcst_rsp cvmx_dtx_osm_bcst_rsp_t;
@@ -5745,6 +6237,7 @@ union cvmx_dtx_osm_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_osm_ctl_s             cn73xx;
 	struct cvmx_dtx_osm_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_osm_ctl cvmx_dtx_osm_ctl_t;
@@ -5764,6 +6257,7 @@ union cvmx_dtx_osm_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_osm_datx_s            cn73xx;
 	struct cvmx_dtx_osm_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_osm_datx cvmx_dtx_osm_datx_t;
@@ -5783,6 +6277,7 @@ union cvmx_dtx_osm_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_osm_enax_s            cn73xx;
 	struct cvmx_dtx_osm_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_osm_enax cvmx_dtx_osm_enax_t;
@@ -5801,6 +6296,7 @@ union cvmx_dtx_osm_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_osm_selx_s            cn73xx;
 	struct cvmx_dtx_osm_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_osm_selx cvmx_dtx_osm_selx_t;
@@ -5926,6 +6422,7 @@ union cvmx_dtx_pemx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn70xx;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn70xxp1;
+	struct cvmx_dtx_pemx_bcst_rsp_s       cn73xx;
 	struct cvmx_dtx_pemx_bcst_rsp_s       cn78xx;
 };
 typedef union cvmx_dtx_pemx_bcst_rsp cvmx_dtx_pemx_bcst_rsp_t;
@@ -5954,6 +6451,7 @@ union cvmx_dtx_pemx_ctl {
 	} s;
 	struct cvmx_dtx_pemx_ctl_s            cn70xx;
 	struct cvmx_dtx_pemx_ctl_s            cn70xxp1;
+	struct cvmx_dtx_pemx_ctl_s            cn73xx;
 	struct cvmx_dtx_pemx_ctl_s            cn78xx;
 };
 typedef union cvmx_dtx_pemx_ctl cvmx_dtx_pemx_ctl_t;
@@ -5975,6 +6473,7 @@ union cvmx_dtx_pemx_datx {
 	} s;
 	struct cvmx_dtx_pemx_datx_s           cn70xx;
 	struct cvmx_dtx_pemx_datx_s           cn70xxp1;
+	struct cvmx_dtx_pemx_datx_s           cn73xx;
 	struct cvmx_dtx_pemx_datx_s           cn78xx;
 };
 typedef union cvmx_dtx_pemx_datx cvmx_dtx_pemx_datx_t;
@@ -5996,6 +6495,7 @@ union cvmx_dtx_pemx_enax {
 	} s;
 	struct cvmx_dtx_pemx_enax_s           cn70xx;
 	struct cvmx_dtx_pemx_enax_s           cn70xxp1;
+	struct cvmx_dtx_pemx_enax_s           cn73xx;
 	struct cvmx_dtx_pemx_enax_s           cn78xx;
 };
 typedef union cvmx_dtx_pemx_enax cvmx_dtx_pemx_enax_t;
@@ -6016,6 +6516,7 @@ union cvmx_dtx_pemx_selx {
 	} s;
 	struct cvmx_dtx_pemx_selx_s           cn70xx;
 	struct cvmx_dtx_pemx_selx_s           cn70xxp1;
+	struct cvmx_dtx_pemx_selx_s           cn73xx;
 	struct cvmx_dtx_pemx_selx_s           cn78xx;
 };
 typedef union cvmx_dtx_pemx_selx cvmx_dtx_pemx_selx_t;
@@ -6139,6 +6640,7 @@ union cvmx_dtx_pki_pbe_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn73xx;
 	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_bcst_rsp cvmx_dtx_pki_pbe_bcst_rsp_t;
@@ -6165,6 +6667,7 @@ union cvmx_dtx_pki_pbe_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_ctl_s         cn73xx;
 	struct cvmx_dtx_pki_pbe_ctl_s         cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_ctl cvmx_dtx_pki_pbe_ctl_t;
@@ -6184,6 +6687,7 @@ union cvmx_dtx_pki_pbe_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_datx_s        cn73xx;
 	struct cvmx_dtx_pki_pbe_datx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_datx cvmx_dtx_pki_pbe_datx_t;
@@ -6203,6 +6707,7 @@ union cvmx_dtx_pki_pbe_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_enax_s        cn73xx;
 	struct cvmx_dtx_pki_pbe_enax_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_enax cvmx_dtx_pki_pbe_enax_t;
@@ -6221,6 +6726,7 @@ union cvmx_dtx_pki_pbe_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pbe_selx_s        cn73xx;
 	struct cvmx_dtx_pki_pbe_selx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pbe_selx cvmx_dtx_pki_pbe_selx_t;
@@ -6239,6 +6745,7 @@ union cvmx_dtx_pki_pfe_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn73xx;
 	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_bcst_rsp cvmx_dtx_pki_pfe_bcst_rsp_t;
@@ -6265,6 +6772,7 @@ union cvmx_dtx_pki_pfe_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_ctl_s         cn73xx;
 	struct cvmx_dtx_pki_pfe_ctl_s         cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_ctl cvmx_dtx_pki_pfe_ctl_t;
@@ -6284,6 +6792,7 @@ union cvmx_dtx_pki_pfe_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_datx_s        cn73xx;
 	struct cvmx_dtx_pki_pfe_datx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_datx cvmx_dtx_pki_pfe_datx_t;
@@ -6303,6 +6812,7 @@ union cvmx_dtx_pki_pfe_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_enax_s        cn73xx;
 	struct cvmx_dtx_pki_pfe_enax_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_enax cvmx_dtx_pki_pfe_enax_t;
@@ -6321,6 +6831,7 @@ union cvmx_dtx_pki_pfe_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pfe_selx_s        cn73xx;
 	struct cvmx_dtx_pki_pfe_selx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pfe_selx cvmx_dtx_pki_pfe_selx_t;
@@ -6339,6 +6850,7 @@ union cvmx_dtx_pki_pix_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn73xx;
 	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_bcst_rsp cvmx_dtx_pki_pix_bcst_rsp_t;
@@ -6365,6 +6877,7 @@ union cvmx_dtx_pki_pix_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_ctl_s         cn73xx;
 	struct cvmx_dtx_pki_pix_ctl_s         cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_ctl cvmx_dtx_pki_pix_ctl_t;
@@ -6384,6 +6897,7 @@ union cvmx_dtx_pki_pix_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_datx_s        cn73xx;
 	struct cvmx_dtx_pki_pix_datx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_datx cvmx_dtx_pki_pix_datx_t;
@@ -6403,6 +6917,7 @@ union cvmx_dtx_pki_pix_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_enax_s        cn73xx;
 	struct cvmx_dtx_pki_pix_enax_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_enax cvmx_dtx_pki_pix_enax_t;
@@ -6421,6 +6936,7 @@ union cvmx_dtx_pki_pix_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_pki_pix_selx_s        cn73xx;
 	struct cvmx_dtx_pki_pix_selx_s        cn78xx;
 };
 typedef union cvmx_dtx_pki_pix_selx cvmx_dtx_pki_pix_selx_t;
@@ -6441,6 +6957,7 @@ union cvmx_dtx_pko_bcst_rsp {
 	} s;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_pko_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_pko_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_pko_bcst_rsp cvmx_dtx_pko_bcst_rsp_t;
@@ -6469,6 +6986,7 @@ union cvmx_dtx_pko_ctl {
 	} s;
 	struct cvmx_dtx_pko_ctl_s             cn70xx;
 	struct cvmx_dtx_pko_ctl_s             cn70xxp1;
+	struct cvmx_dtx_pko_ctl_s             cn73xx;
 	struct cvmx_dtx_pko_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_pko_ctl cvmx_dtx_pko_ctl_t;
@@ -6490,6 +7008,7 @@ union cvmx_dtx_pko_datx {
 	} s;
 	struct cvmx_dtx_pko_datx_s            cn70xx;
 	struct cvmx_dtx_pko_datx_s            cn70xxp1;
+	struct cvmx_dtx_pko_datx_s            cn73xx;
 	struct cvmx_dtx_pko_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_pko_datx cvmx_dtx_pko_datx_t;
@@ -6511,6 +7030,7 @@ union cvmx_dtx_pko_enax {
 	} s;
 	struct cvmx_dtx_pko_enax_s            cn70xx;
 	struct cvmx_dtx_pko_enax_s            cn70xxp1;
+	struct cvmx_dtx_pko_enax_s            cn73xx;
 	struct cvmx_dtx_pko_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_pko_enax cvmx_dtx_pko_enax_t;
@@ -6531,6 +7051,7 @@ union cvmx_dtx_pko_selx {
 	} s;
 	struct cvmx_dtx_pko_selx_s            cn70xx;
 	struct cvmx_dtx_pko_selx_s            cn70xxp1;
+	struct cvmx_dtx_pko_selx_s            cn73xx;
 	struct cvmx_dtx_pko_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_pko_selx cvmx_dtx_pko_selx_t;
@@ -6654,6 +7175,7 @@ union cvmx_dtx_rad_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_rad_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_rad_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_rad_bcst_rsp cvmx_dtx_rad_bcst_rsp_t;
@@ -6680,6 +7202,7 @@ union cvmx_dtx_rad_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_rad_ctl_s             cn73xx;
 	struct cvmx_dtx_rad_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_rad_ctl cvmx_dtx_rad_ctl_t;
@@ -6699,6 +7222,7 @@ union cvmx_dtx_rad_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_rad_datx_s            cn73xx;
 	struct cvmx_dtx_rad_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_rad_datx cvmx_dtx_rad_datx_t;
@@ -6718,6 +7242,7 @@ union cvmx_dtx_rad_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_rad_enax_s            cn73xx;
 	struct cvmx_dtx_rad_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_rad_enax cvmx_dtx_rad_enax_t;
@@ -6736,6 +7261,7 @@ union cvmx_dtx_rad_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_rad_selx_s            cn73xx;
 	struct cvmx_dtx_rad_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_rad_selx cvmx_dtx_rad_selx_t;
@@ -6754,6 +7280,7 @@ union cvmx_dtx_rnm_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_rnm_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_rnm_bcst_rsp cvmx_dtx_rnm_bcst_rsp_t;
@@ -6780,6 +7307,7 @@ union cvmx_dtx_rnm_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_ctl_s             cn73xx;
 	struct cvmx_dtx_rnm_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_rnm_ctl cvmx_dtx_rnm_ctl_t;
@@ -6799,6 +7327,7 @@ union cvmx_dtx_rnm_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_datx_s            cn73xx;
 	struct cvmx_dtx_rnm_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_rnm_datx cvmx_dtx_rnm_datx_t;
@@ -6818,6 +7347,7 @@ union cvmx_dtx_rnm_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_enax_s            cn73xx;
 	struct cvmx_dtx_rnm_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_rnm_enax cvmx_dtx_rnm_enax_t;
@@ -6836,6 +7366,7 @@ union cvmx_dtx_rnm_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_rnm_selx_s            cn73xx;
 	struct cvmx_dtx_rnm_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_rnm_selx cvmx_dtx_rnm_selx_t;
@@ -6856,6 +7387,7 @@ union cvmx_dtx_rst_bcst_rsp {
 	} s;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_rst_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_rst_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_rst_bcst_rsp cvmx_dtx_rst_bcst_rsp_t;
@@ -6884,6 +7416,7 @@ union cvmx_dtx_rst_ctl {
 	} s;
 	struct cvmx_dtx_rst_ctl_s             cn70xx;
 	struct cvmx_dtx_rst_ctl_s             cn70xxp1;
+	struct cvmx_dtx_rst_ctl_s             cn73xx;
 	struct cvmx_dtx_rst_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_rst_ctl cvmx_dtx_rst_ctl_t;
@@ -6905,6 +7438,7 @@ union cvmx_dtx_rst_datx {
 	} s;
 	struct cvmx_dtx_rst_datx_s            cn70xx;
 	struct cvmx_dtx_rst_datx_s            cn70xxp1;
+	struct cvmx_dtx_rst_datx_s            cn73xx;
 	struct cvmx_dtx_rst_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_rst_datx cvmx_dtx_rst_datx_t;
@@ -6926,6 +7460,7 @@ union cvmx_dtx_rst_enax {
 	} s;
 	struct cvmx_dtx_rst_enax_s            cn70xx;
 	struct cvmx_dtx_rst_enax_s            cn70xxp1;
+	struct cvmx_dtx_rst_enax_s            cn73xx;
 	struct cvmx_dtx_rst_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_rst_enax cvmx_dtx_rst_enax_t;
@@ -6946,6 +7481,7 @@ union cvmx_dtx_rst_selx {
 	} s;
 	struct cvmx_dtx_rst_selx_s            cn70xx;
 	struct cvmx_dtx_rst_selx_s            cn70xxp1;
+	struct cvmx_dtx_rst_selx_s            cn73xx;
 	struct cvmx_dtx_rst_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_rst_selx cvmx_dtx_rst_selx_t;
@@ -7071,6 +7607,7 @@ union cvmx_dtx_sli_bcst_rsp {
 	} s;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_sli_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_sli_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_sli_bcst_rsp cvmx_dtx_sli_bcst_rsp_t;
@@ -7099,6 +7636,7 @@ union cvmx_dtx_sli_ctl {
 	} s;
 	struct cvmx_dtx_sli_ctl_s             cn70xx;
 	struct cvmx_dtx_sli_ctl_s             cn70xxp1;
+	struct cvmx_dtx_sli_ctl_s             cn73xx;
 	struct cvmx_dtx_sli_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_sli_ctl cvmx_dtx_sli_ctl_t;
@@ -7120,6 +7658,7 @@ union cvmx_dtx_sli_datx {
 	} s;
 	struct cvmx_dtx_sli_datx_s            cn70xx;
 	struct cvmx_dtx_sli_datx_s            cn70xxp1;
+	struct cvmx_dtx_sli_datx_s            cn73xx;
 	struct cvmx_dtx_sli_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_sli_datx cvmx_dtx_sli_datx_t;
@@ -7141,6 +7680,7 @@ union cvmx_dtx_sli_enax {
 	} s;
 	struct cvmx_dtx_sli_enax_s            cn70xx;
 	struct cvmx_dtx_sli_enax_s            cn70xxp1;
+	struct cvmx_dtx_sli_enax_s            cn73xx;
 	struct cvmx_dtx_sli_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_sli_enax cvmx_dtx_sli_enax_t;
@@ -7161,6 +7701,7 @@ union cvmx_dtx_sli_selx {
 	} s;
 	struct cvmx_dtx_sli_selx_s            cn70xx;
 	struct cvmx_dtx_sli_selx_s            cn70xxp1;
+	struct cvmx_dtx_sli_selx_s            cn73xx;
 	struct cvmx_dtx_sli_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_sli_selx cvmx_dtx_sli_selx_t;
@@ -7179,6 +7720,7 @@ union cvmx_dtx_sso_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_sso_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_sso_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_sso_bcst_rsp cvmx_dtx_sso_bcst_rsp_t;
@@ -7205,6 +7747,7 @@ union cvmx_dtx_sso_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_sso_ctl_s             cn73xx;
 	struct cvmx_dtx_sso_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_sso_ctl cvmx_dtx_sso_ctl_t;
@@ -7224,6 +7767,7 @@ union cvmx_dtx_sso_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_sso_datx_s            cn73xx;
 	struct cvmx_dtx_sso_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_sso_datx cvmx_dtx_sso_datx_t;
@@ -7243,6 +7787,7 @@ union cvmx_dtx_sso_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_sso_enax_s            cn73xx;
 	struct cvmx_dtx_sso_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_sso_enax cvmx_dtx_sso_enax_t;
@@ -7261,6 +7806,7 @@ union cvmx_dtx_sso_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_sso_selx_s            cn73xx;
 	struct cvmx_dtx_sso_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_sso_selx cvmx_dtx_sso_selx_t;
@@ -7281,6 +7827,7 @@ union cvmx_dtx_tim_bcst_rsp {
 	} s;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn70xx;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_tim_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_tim_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_tim_bcst_rsp cvmx_dtx_tim_bcst_rsp_t;
@@ -7309,6 +7856,7 @@ union cvmx_dtx_tim_ctl {
 	} s;
 	struct cvmx_dtx_tim_ctl_s             cn70xx;
 	struct cvmx_dtx_tim_ctl_s             cn70xxp1;
+	struct cvmx_dtx_tim_ctl_s             cn73xx;
 	struct cvmx_dtx_tim_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_tim_ctl cvmx_dtx_tim_ctl_t;
@@ -7330,6 +7878,7 @@ union cvmx_dtx_tim_datx {
 	} s;
 	struct cvmx_dtx_tim_datx_s            cn70xx;
 	struct cvmx_dtx_tim_datx_s            cn70xxp1;
+	struct cvmx_dtx_tim_datx_s            cn73xx;
 	struct cvmx_dtx_tim_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_tim_datx cvmx_dtx_tim_datx_t;
@@ -7351,6 +7900,7 @@ union cvmx_dtx_tim_enax {
 	} s;
 	struct cvmx_dtx_tim_enax_s            cn70xx;
 	struct cvmx_dtx_tim_enax_s            cn70xxp1;
+	struct cvmx_dtx_tim_enax_s            cn73xx;
 	struct cvmx_dtx_tim_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_tim_enax cvmx_dtx_tim_enax_t;
@@ -7371,6 +7921,7 @@ union cvmx_dtx_tim_selx {
 	} s;
 	struct cvmx_dtx_tim_selx_s            cn70xx;
 	struct cvmx_dtx_tim_selx_s            cn70xxp1;
+	struct cvmx_dtx_tim_selx_s            cn73xx;
 	struct cvmx_dtx_tim_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_tim_selx cvmx_dtx_tim_selx_t;
@@ -7391,6 +7942,7 @@ union cvmx_dtx_usbdrdx_bcst_rsp {
 	} s;
 	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn70xx;
 	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn70xxp1;
+	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_bcst_rsp cvmx_dtx_usbdrdx_bcst_rsp_t;
 
@@ -7418,6 +7970,7 @@ union cvmx_dtx_usbdrdx_ctl {
 	} s;
 	struct cvmx_dtx_usbdrdx_ctl_s         cn70xx;
 	struct cvmx_dtx_usbdrdx_ctl_s         cn70xxp1;
+	struct cvmx_dtx_usbdrdx_ctl_s         cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_ctl cvmx_dtx_usbdrdx_ctl_t;
 
@@ -7438,6 +7991,7 @@ union cvmx_dtx_usbdrdx_datx {
 	} s;
 	struct cvmx_dtx_usbdrdx_datx_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_datx_s        cn70xxp1;
+	struct cvmx_dtx_usbdrdx_datx_s        cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_datx cvmx_dtx_usbdrdx_datx_t;
 
@@ -7458,6 +8012,7 @@ union cvmx_dtx_usbdrdx_enax {
 	} s;
 	struct cvmx_dtx_usbdrdx_enax_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_enax_s        cn70xxp1;
+	struct cvmx_dtx_usbdrdx_enax_s        cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_enax cvmx_dtx_usbdrdx_enax_t;
 
@@ -7477,6 +8032,7 @@ union cvmx_dtx_usbdrdx_selx {
 	} s;
 	struct cvmx_dtx_usbdrdx_selx_s        cn70xx;
 	struct cvmx_dtx_usbdrdx_selx_s        cn70xxp1;
+	struct cvmx_dtx_usbdrdx_selx_s        cn73xx;
 };
 typedef union cvmx_dtx_usbdrdx_selx cvmx_dtx_usbdrdx_selx_t;
 
@@ -7494,6 +8050,7 @@ union cvmx_dtx_usbhx_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_bcst_rsp_s      cn73xx;
 	struct cvmx_dtx_usbhx_bcst_rsp_s      cn78xx;
 };
 typedef union cvmx_dtx_usbhx_bcst_rsp cvmx_dtx_usbhx_bcst_rsp_t;
@@ -7520,6 +8077,7 @@ union cvmx_dtx_usbhx_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_ctl_s           cn73xx;
 	struct cvmx_dtx_usbhx_ctl_s           cn78xx;
 };
 typedef union cvmx_dtx_usbhx_ctl cvmx_dtx_usbhx_ctl_t;
@@ -7539,6 +8097,7 @@ union cvmx_dtx_usbhx_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_datx_s          cn73xx;
 	struct cvmx_dtx_usbhx_datx_s          cn78xx;
 };
 typedef union cvmx_dtx_usbhx_datx cvmx_dtx_usbhx_datx_t;
@@ -7558,6 +8117,7 @@ union cvmx_dtx_usbhx_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_enax_s          cn73xx;
 	struct cvmx_dtx_usbhx_enax_s          cn78xx;
 };
 typedef union cvmx_dtx_usbhx_enax cvmx_dtx_usbhx_enax_t;
@@ -7576,6 +8136,7 @@ union cvmx_dtx_usbhx_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_usbhx_selx_s          cn73xx;
 	struct cvmx_dtx_usbhx_selx_s          cn78xx;
 };
 typedef union cvmx_dtx_usbhx_selx cvmx_dtx_usbhx_selx_t;
@@ -7594,6 +8155,7 @@ union cvmx_dtx_zip_bcst_rsp {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_dtx_zip_bcst_rsp_s        cn73xx;
 	struct cvmx_dtx_zip_bcst_rsp_s        cn78xx;
 };
 typedef union cvmx_dtx_zip_bcst_rsp cvmx_dtx_zip_bcst_rsp_t;
@@ -7620,6 +8182,7 @@ union cvmx_dtx_zip_ctl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_dtx_zip_ctl_s             cn73xx;
 	struct cvmx_dtx_zip_ctl_s             cn78xx;
 };
 typedef union cvmx_dtx_zip_ctl cvmx_dtx_zip_ctl_t;
@@ -7639,6 +8202,7 @@ union cvmx_dtx_zip_datx {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_zip_datx_s            cn73xx;
 	struct cvmx_dtx_zip_datx_s            cn78xx;
 };
 typedef union cvmx_dtx_zip_datx cvmx_dtx_zip_datx_t;
@@ -7658,6 +8222,7 @@ union cvmx_dtx_zip_enax {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_dtx_zip_enax_s            cn73xx;
 	struct cvmx_dtx_zip_enax_s            cn78xx;
 };
 typedef union cvmx_dtx_zip_enax cvmx_dtx_zip_enax_t;
@@ -7676,6 +8241,7 @@ union cvmx_dtx_zip_selx {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_dtx_zip_selx_s            cn73xx;
 	struct cvmx_dtx_zip_selx_s            cn78xx;
 };
 typedef union cvmx_dtx_zip_selx cvmx_dtx_zip_selx_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index a82c84f..6d6059b 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -65,6 +65,7 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001180028000458ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 			break;
 	}
@@ -83,6 +84,7 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180028000458ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000458ull);
@@ -92,6 +94,7 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 static inline uint64_t CVMX_FPA_AURAX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020100000ull) + ((offset) & 1023) * 8;
@@ -103,6 +106,7 @@ static inline uint64_t CVMX_FPA_AURAX_CFG(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020200000ull) + ((offset) & 1023) * 8;
@@ -114,6 +118,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT_ADD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_ADD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020300000ull) + ((offset) & 1023) * 8;
@@ -125,6 +130,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_ADD(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT_LEVELS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_LEVELS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020800000ull) + ((offset) & 1023) * 8;
@@ -136,6 +142,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_LEVELS(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT_LIMIT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_LIMIT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020400000ull) + ((offset) & 1023) * 8;
@@ -147,6 +154,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_LIMIT(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_CNT_THRESHOLD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_THRESHOLD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020500000ull) + ((offset) & 1023) * 8;
@@ -158,6 +166,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_THRESHOLD(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020600000ull) + ((offset) & 1023) * 8;
@@ -169,6 +178,7 @@ static inline uint64_t CVMX_FPA_AURAX_INT(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_POOL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_POOL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020000000ull) + ((offset) & 1023) * 8;
@@ -180,6 +190,7 @@ static inline uint64_t CVMX_FPA_AURAX_POOL(unsigned long offset)
 static inline uint64_t CVMX_FPA_AURAX_POOL_LEVELS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_FPA_AURAX_POOL_LEVELS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280020700000ull) + ((offset) & 1023) * 8;
@@ -208,6 +219,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011800280000E8ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 			break;
 	}
@@ -234,6 +246,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800280000E8ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800280000E8ull);
@@ -243,7 +256,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 #define CVMX_FPA_CLK_COUNT CVMX_FPA_CLK_COUNT_FUNC()
 static inline uint64_t CVMX_FPA_CLK_COUNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_CLK_COUNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00012800000000F0ull);
 }
@@ -255,7 +268,7 @@ static inline uint64_t CVMX_FPA_CLK_COUNT_FUNC(void)
 #define CVMX_FPA_ECC_CTL CVMX_FPA_ECC_CTL_FUNC()
 static inline uint64_t CVMX_FPA_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000058ull);
 }
@@ -266,7 +279,7 @@ static inline uint64_t CVMX_FPA_ECC_CTL_FUNC(void)
 #define CVMX_FPA_ECC_INT CVMX_FPA_ECC_INT_FUNC()
 static inline uint64_t CVMX_FPA_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000068ull);
 }
@@ -277,7 +290,7 @@ static inline uint64_t CVMX_FPA_ECC_INT_FUNC(void)
 #define CVMX_FPA_ERR_INT CVMX_FPA_ERR_INT_FUNC()
 static inline uint64_t CVMX_FPA_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000040ull);
 }
@@ -377,7 +390,7 @@ static inline uint64_t CVMX_FPA_FPFX_SIZE(unsigned long offset)
 #define CVMX_FPA_GEN_CFG CVMX_FPA_GEN_CFG_FUNC()
 static inline uint64_t CVMX_FPA_GEN_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_GEN_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000050ull);
 }
@@ -401,6 +414,7 @@ static inline uint64_t CVMX_FPA_PACKET_THRESHOLD_FUNC(void)
 static inline uint64_t CVMX_FPA_POOLX_AVAILABLE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_AVAILABLE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010300000ull) + ((offset) & 63) * 8;
@@ -412,6 +426,7 @@ static inline uint64_t CVMX_FPA_POOLX_AVAILABLE(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010000000ull) + ((offset) & 63) * 8;
@@ -438,6 +453,10 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 			if ((offset <= 63))
 				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 31) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_END_ADDR (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180028000358ull) + ((offset) & 7) * 8;
@@ -455,6 +474,8 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180028000358ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000358ull) + (offset) * 8;
 }
@@ -463,6 +484,7 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_FPF_MARKS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_FPF_MARKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010100000ull) + ((offset) & 63) * 8;
@@ -474,6 +496,7 @@ static inline uint64_t CVMX_FPA_POOLX_FPF_MARKS(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010A00000ull) + ((offset) & 63) * 8;
@@ -485,6 +508,7 @@ static inline uint64_t CVMX_FPA_POOLX_INT(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_OP_PC(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_OP_PC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010F00000ull) + ((offset) & 63) * 8;
@@ -496,6 +520,7 @@ static inline uint64_t CVMX_FPA_POOLX_OP_PC(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_STACK_ADDR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_ADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010900000ull) + ((offset) & 63) * 8;
@@ -507,6 +532,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_ADDR(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_STACK_BASE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_BASE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010700000ull) + ((offset) & 63) * 8;
@@ -518,6 +544,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_BASE(unsigned long offset)
 static inline uint64_t CVMX_FPA_POOLX_STACK_END(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_END(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001280010800000ull) + ((offset) & 63) * 8;
@@ -544,6 +571,10 @@ static inline uint64_t CVMX_FPA_POOLX_START_ADDR(unsigned long offset)
 			if ((offset <= 63))
 				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 31) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_START_ADDR (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180028000258ull) + ((offset) & 7) * 8;
@@ -561,6 +592,8 @@ static inline uint64_t CVMX_FPA_POOLX_START_ADDR(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180028000258ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000258ull) + (offset) * 8;
 }
@@ -585,6 +618,10 @@ static inline uint64_t CVMX_FPA_POOLX_THRESHOLD(unsigned long offset)
 			if ((offset <= 63))
 				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 63) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 31) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_THRESHOLD (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180028000140ull) + ((offset) & 7) * 8;
@@ -603,6 +640,8 @@ static inline uint64_t CVMX_FPA_POOLX_THRESHOLD(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180028000140ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180028000140ull) + (offset) * 8;
 }
@@ -678,7 +717,7 @@ static inline uint64_t CVMX_FPA_QUEX_PAGE_INDEX(unsigned long offset)
 #define CVMX_FPA_RD_LATENCY_PC CVMX_FPA_RD_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_FPA_RD_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RD_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000610ull);
 }
@@ -689,7 +728,7 @@ static inline uint64_t CVMX_FPA_RD_LATENCY_PC_FUNC(void)
 #define CVMX_FPA_RD_REQ_PC CVMX_FPA_RD_REQ_PC_FUNC()
 static inline uint64_t CVMX_FPA_RD_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RD_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000600ull);
 }
@@ -700,7 +739,7 @@ static inline uint64_t CVMX_FPA_RD_REQ_PC_FUNC(void)
 #define CVMX_FPA_RED_DELAY CVMX_FPA_RED_DELAY_FUNC()
 static inline uint64_t CVMX_FPA_RED_DELAY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_RED_DELAY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000100ull);
 }
@@ -711,7 +750,7 @@ static inline uint64_t CVMX_FPA_RED_DELAY_FUNC(void)
 #define CVMX_FPA_SFT_RST CVMX_FPA_SFT_RST_FUNC()
 static inline uint64_t CVMX_FPA_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_FPA_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000000ull);
 }
@@ -783,7 +822,7 @@ union cvmx_fpa_addr_range_error {
 	struct cvmx_fpa_addr_range_error_cn61xx cn68xxp1;
 	struct cvmx_fpa_addr_range_error_cn61xx cn70xx;
 	struct cvmx_fpa_addr_range_error_cn61xx cn70xxp1;
-	struct cvmx_fpa_addr_range_error_cn78xx {
+	struct cvmx_fpa_addr_range_error_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
 	uint64_t pool                         : 6;  /**< Pool that address was sent to. */
@@ -795,7 +834,8 @@ union cvmx_fpa_addr_range_error {
 	uint64_t pool                         : 6;
 	uint64_t reserved_54_63               : 10;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_fpa_addr_range_error_cn73xx cn78xx;
 	struct cvmx_fpa_addr_range_error_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_addr_range_error cvmx_fpa_addr_range_error_t;
@@ -836,6 +876,7 @@ union cvmx_fpa_aurax_cfg {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cfg_s           cn73xx;
 	struct cvmx_fpa_aurax_cfg_s           cn78xx;
 };
 typedef union cvmx_fpa_aurax_cfg cvmx_fpa_aurax_cfg_t;
@@ -854,6 +895,7 @@ union cvmx_fpa_aurax_cnt {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_s           cn73xx;
 	struct cvmx_fpa_aurax_cnt_s           cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt cvmx_fpa_aurax_cnt_t;
@@ -878,6 +920,7 @@ union cvmx_fpa_aurax_cnt_add {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_add_s       cn73xx;
 	struct cvmx_fpa_aurax_cnt_add_s       cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt_add cvmx_fpa_aurax_cnt_add_t;
@@ -907,11 +950,11 @@ union cvmx_fpa_aurax_cnt_levels {
                                                          calculations. */
 	uint64_t bp                           : 8;  /**< Backpressure can assert if the current 8-bit shifted and saturated FPA_AURA()_CNT[CNT] is
                                                          equal to or greater than this value. */
-	uint64_t drop                         : 8;  /**< If [RED_ENA]==1 and RED processing is requested, the packet will be dropped if
+	uint64_t drop                         : 8;  /**< If [RED_ENA]=1 and RED processing is requested, the packet will be dropped if
                                                          [LEVEL] is equal to or greater than this value.
-                                                         If DROP processing is requested, the packet will be dropped if the current 8-bit
-                                                         shifted and saturated FPA_AURA()_CNT[CNT] is equal to or greater than this
-                                                         value. */
+                                                         If [DROP_DIS]=0 and DROP processing is requested, the packet will be dropped if
+                                                         the current 8-bit shifted and saturated FPA_AURA()_CNT[CNT] is equal to or greater
+                                                         than this value. */
 	uint64_t pass                         : 8;  /**< Aura RED processing will not drop an allocation request if [LEVEL] is less than this value. */
 	uint64_t level                        : 8;  /**< Current moving average of the 8-bit shifted and saturated FPA_AURA()_CNT[CNT].
                                                          The lower [LEVEL] is, the more free resources. The highest [LEVEL]'s indicate buffer
@@ -929,6 +972,7 @@ union cvmx_fpa_aurax_cnt_levels {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_levels_s    cn73xx;
 	struct cvmx_fpa_aurax_cnt_levels_s    cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt_levels cvmx_fpa_aurax_cnt_levels_t;
@@ -949,6 +993,7 @@ union cvmx_fpa_aurax_cnt_limit {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_limit_s     cn73xx;
 	struct cvmx_fpa_aurax_cnt_limit_s     cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt_limit cvmx_fpa_aurax_cnt_limit_t;
@@ -969,6 +1014,7 @@ union cvmx_fpa_aurax_cnt_threshold {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_cnt_threshold_s cn73xx;
 	struct cvmx_fpa_aurax_cnt_threshold_s cn78xx;
 };
 typedef union cvmx_fpa_aurax_cnt_threshold cvmx_fpa_aurax_cnt_threshold_t;
@@ -990,6 +1036,7 @@ union cvmx_fpa_aurax_int {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_int_s           cn73xx;
 	struct cvmx_fpa_aurax_int_s           cn78xx;
 };
 typedef union cvmx_fpa_aurax_int cvmx_fpa_aurax_int_t;
@@ -1011,6 +1058,7 @@ union cvmx_fpa_aurax_pool {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_pool_s          cn73xx;
 	struct cvmx_fpa_aurax_pool_s          cn78xx;
 };
 typedef union cvmx_fpa_aurax_pool cvmx_fpa_aurax_pool_t;
@@ -1044,11 +1092,11 @@ union cvmx_fpa_aurax_pool_levels {
                                                          processing. */
 	uint64_t bp                           : 8;  /**< Backpressure can assert if the current 8-bit shifted and saturated
                                                          FPA_POOL()_AVAILABLE[COUNT] for the aura is equal to or less than this value. */
-	uint64_t drop                         : 8;  /**< If [RED_ENA]==1 and RED processing is requested, the packet will be dropped if
+	uint64_t drop                         : 8;  /**< If [RED_ENA]=1 and RED processing is requested, the packet will be dropped if
                                                          [LEVEL] is equal to or less than this value.
-                                                         If DROP processing is requested, the packet will be dropped if the current 8-bit
-                                                         shifted and saturated FPA_POOL()_AVAILABLE[COUNT] for the aura is equal to or
-                                                         less than this value. */
+                                                         If [DROP_DIS]=0 and DROP processing is requested, the packet will be dropped
+                                                         if the current 8-bit shifted and saturated FPA_POOL()_AVAILABLE[COUNT] for the
+                                                         aura is equal to or less than this value. */
 	uint64_t pass                         : 8;  /**< Aura-unique pool RED processing will not drop an allocation request if [LEVEL] is larger
                                                          than this value. */
 	uint64_t level                        : 8;  /**< Current moving average of the 8-bit shifted and saturated FPA_POOL()_AVAILABLE[COUNT] for
@@ -1068,6 +1116,7 @@ union cvmx_fpa_aurax_pool_levels {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_fpa_aurax_pool_levels_s   cn73xx;
 	struct cvmx_fpa_aurax_pool_levels_s   cn78xx;
 };
 typedef union cvmx_fpa_aurax_pool_levels cvmx_fpa_aurax_pool_levels_t;
@@ -1122,7 +1171,7 @@ union cvmx_fpa_bist_status {
 	struct cvmx_fpa_bist_status_cn30xx    cn68xxp1;
 	struct cvmx_fpa_bist_status_cn30xx    cn70xx;
 	struct cvmx_fpa_bist_status_cn30xx    cn70xxp1;
-	struct cvmx_fpa_bist_status_cn78xx {
+	struct cvmx_fpa_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_38_63               : 26;
 	uint64_t status                       : 38; /**< Memory BIST status. */
@@ -1130,7 +1179,8 @@ union cvmx_fpa_bist_status {
 	uint64_t status                       : 38;
 	uint64_t reserved_38_63               : 26;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_fpa_bist_status_cn73xx    cn78xx;
 	struct cvmx_fpa_bist_status_cn30xx    cnf71xx;
 };
 typedef union cvmx_fpa_bist_status cvmx_fpa_bist_status_t;
@@ -1151,6 +1201,7 @@ union cvmx_fpa_clk_count {
 	uint64_t clk_cnt                      : 64;
 #endif
 	} s;
+	struct cvmx_fpa_clk_count_s           cn73xx;
 	struct cvmx_fpa_clk_count_s           cn78xx;
 };
 typedef union cvmx_fpa_clk_count cvmx_fpa_clk_count_t;
@@ -1277,6 +1328,7 @@ union cvmx_fpa_ecc_ctl {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_fpa_ecc_ctl_s             cn73xx;
 	struct cvmx_fpa_ecc_ctl_s             cn78xx;
 };
 typedef union cvmx_fpa_ecc_ctl cvmx_fpa_ecc_ctl_t;
@@ -1304,6 +1356,7 @@ union cvmx_fpa_ecc_int {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_fpa_ecc_int_s             cn73xx;
 	struct cvmx_fpa_ecc_int_s             cn78xx;
 };
 typedef union cvmx_fpa_ecc_int cvmx_fpa_ecc_int_t;
@@ -1335,6 +1388,7 @@ union cvmx_fpa_err_int {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_fpa_err_int_s             cn73xx;
 	struct cvmx_fpa_err_int_s             cn78xx;
 };
 typedef union cvmx_fpa_err_int cvmx_fpa_err_int_t;
@@ -1645,6 +1699,7 @@ union cvmx_fpa_gen_cfg {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_fpa_gen_cfg_s             cn73xx;
 	struct cvmx_fpa_gen_cfg_s             cn78xx;
 };
 typedef union cvmx_fpa_gen_cfg cvmx_fpa_gen_cfg_t;
@@ -3187,6 +3242,7 @@ union cvmx_fpa_poolx_available {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_available_s     cn73xx;
 	struct cvmx_fpa_poolx_available_s     cn78xx;
 };
 typedef union cvmx_fpa_poolx_available cvmx_fpa_poolx_available_t;
@@ -3236,6 +3292,7 @@ union cvmx_fpa_poolx_cfg {
 	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_cfg_s           cn73xx;
 	struct cvmx_fpa_poolx_cfg_s           cn78xx;
 };
 typedef union cvmx_fpa_poolx_cfg cvmx_fpa_poolx_cfg_t;
@@ -3269,7 +3326,7 @@ union cvmx_fpa_poolx_end_addr {
 	struct cvmx_fpa_poolx_end_addr_cn61xx cn68xxp1;
 	struct cvmx_fpa_poolx_end_addr_cn61xx cn70xx;
 	struct cvmx_fpa_poolx_end_addr_cn61xx cn70xxp1;
-	struct cvmx_fpa_poolx_end_addr_cn78xx {
+	struct cvmx_fpa_poolx_end_addr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
 	uint64_t addr                         : 35; /**< Address. */
@@ -3279,7 +3336,8 @@ union cvmx_fpa_poolx_end_addr {
 	uint64_t addr                         : 35;
 	uint64_t reserved_42_63               : 22;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_fpa_poolx_end_addr_cn73xx cn78xx;
 	struct cvmx_fpa_poolx_end_addr_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_poolx_end_addr cvmx_fpa_poolx_end_addr_t;
@@ -3314,6 +3372,7 @@ union cvmx_fpa_poolx_fpf_marks {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_fpf_marks_s     cn73xx;
 	struct cvmx_fpa_poolx_fpf_marks_s     cn78xx;
 };
 typedef union cvmx_fpa_poolx_fpf_marks cvmx_fpa_poolx_fpf_marks_t;
@@ -3347,6 +3406,7 @@ union cvmx_fpa_poolx_int {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_int_s           cn73xx;
 	struct cvmx_fpa_poolx_int_s           cn78xx;
 };
 typedef union cvmx_fpa_poolx_int cvmx_fpa_poolx_int_t;
@@ -3363,6 +3423,7 @@ union cvmx_fpa_poolx_op_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_op_pc_s         cn73xx;
 	struct cvmx_fpa_poolx_op_pc_s         cn78xx;
 };
 typedef union cvmx_fpa_poolx_op_pc cvmx_fpa_poolx_op_pc_t;
@@ -3384,6 +3445,7 @@ union cvmx_fpa_poolx_stack_addr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_stack_addr_s    cn73xx;
 	struct cvmx_fpa_poolx_stack_addr_s    cn78xx;
 };
 typedef union cvmx_fpa_poolx_stack_addr cvmx_fpa_poolx_stack_addr_t;
@@ -3404,6 +3466,7 @@ union cvmx_fpa_poolx_stack_base {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_stack_base_s    cn73xx;
 	struct cvmx_fpa_poolx_stack_base_s    cn78xx;
 };
 typedef union cvmx_fpa_poolx_stack_base cvmx_fpa_poolx_stack_base_t;
@@ -3425,6 +3488,7 @@ union cvmx_fpa_poolx_stack_end {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_fpa_poolx_stack_end_s     cn73xx;
 	struct cvmx_fpa_poolx_stack_end_s     cn78xx;
 };
 typedef union cvmx_fpa_poolx_stack_end cvmx_fpa_poolx_stack_end_t;
@@ -3458,7 +3522,7 @@ union cvmx_fpa_poolx_start_addr {
 	struct cvmx_fpa_poolx_start_addr_cn61xx cn68xxp1;
 	struct cvmx_fpa_poolx_start_addr_cn61xx cn70xx;
 	struct cvmx_fpa_poolx_start_addr_cn61xx cn70xxp1;
-	struct cvmx_fpa_poolx_start_addr_cn78xx {
+	struct cvmx_fpa_poolx_start_addr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
 	uint64_t addr                         : 35; /**< Address. Defaults to 1 so that a NULL pointer free will cause an exception. */
@@ -3468,7 +3532,8 @@ union cvmx_fpa_poolx_start_addr {
 	uint64_t addr                         : 35;
 	uint64_t reserved_42_63               : 22;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_fpa_poolx_start_addr_cn73xx cn78xx;
 	struct cvmx_fpa_poolx_start_addr_cn61xx cnf71xx;
 };
 typedef union cvmx_fpa_poolx_start_addr cvmx_fpa_poolx_start_addr_t;
@@ -3515,6 +3580,7 @@ union cvmx_fpa_poolx_threshold {
 	struct cvmx_fpa_poolx_threshold_cn68xx cn68xxp1;
 	struct cvmx_fpa_poolx_threshold_cn61xx cn70xx;
 	struct cvmx_fpa_poolx_threshold_cn61xx cn70xxp1;
+	struct cvmx_fpa_poolx_threshold_s     cn73xx;
 	struct cvmx_fpa_poolx_threshold_s     cn78xx;
 	struct cvmx_fpa_poolx_threshold_cn61xx cnf71xx;
 };
@@ -3733,6 +3799,7 @@ union cvmx_fpa_rd_latency_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_fpa_rd_latency_pc_s       cn73xx;
 	struct cvmx_fpa_rd_latency_pc_s       cn78xx;
 };
 typedef union cvmx_fpa_rd_latency_pc cvmx_fpa_rd_latency_pc_t;
@@ -3749,6 +3816,7 @@ union cvmx_fpa_rd_req_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_fpa_rd_req_pc_s           cn73xx;
 	struct cvmx_fpa_rd_req_pc_s           cn78xx;
 };
 typedef union cvmx_fpa_rd_req_pc cvmx_fpa_rd_req_pc_t;
@@ -3777,6 +3845,7 @@ union cvmx_fpa_red_delay {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_fpa_red_delay_s           cn73xx;
 	struct cvmx_fpa_red_delay_s           cn78xx;
 };
 typedef union cvmx_fpa_red_delay cvmx_fpa_red_delay_t;
@@ -3803,6 +3872,7 @@ union cvmx_fpa_sft_rst {
 	uint64_t busy                         : 1;
 #endif
 	} s;
+	struct cvmx_fpa_sft_rst_s             cn73xx;
 	struct cvmx_fpa_sft_rst_s             cn78xx;
 };
 typedef union cvmx_fpa_sft_rst cvmx_fpa_sft_rst_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa3.h b/arch/mips/include/asm/octeon/cvmx-fpa3.h
index b786bdb..1909ca9 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa3.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa3.h
@@ -42,7 +42,7 @@
  *
  * Interface to the CN78XX Free Pool Allocator, a.k.a. FPA3
  *
- * <hr>$Revision: 106689 $<hr>
+ * <hr>$Revision: 107316 $<hr>
  *
  */
 
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index 6eb8f75..67ec6f1 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -76,6 +76,10 @@ static inline uint64_t CVMX_GPIO_BIT_CFGX(unsigned long offset)
 			if ((offset <= 19))
 				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
+			break;
 	}
 	cvmx_warn("CVMX_GPIO_BIT_CFGX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000800ull) + ((offset) & 15) * 8;
@@ -100,6 +104,8 @@ static inline uint64_t CVMX_GPIO_BIT_CFGX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001070000000800ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000800ull) + (offset) * 8;
 }
@@ -126,6 +132,7 @@ static inline uint64_t CVMX_GPIO_CLK_GENX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_GPIO_CLK_GENX(%lu) is invalid on this chip\n", offset);
@@ -154,6 +161,7 @@ static inline uint64_t CVMX_GPIO_CLK_SYNCEX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_GPIO_CLK_SYNCEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00010700000008E0ull) + ((offset) & 1) * 8;
@@ -165,7 +173,7 @@ static inline uint64_t CVMX_GPIO_CLK_SYNCEX(unsigned long offset)
 #define CVMX_GPIO_COMP CVMX_GPIO_COMP_FUNC()
 static inline uint64_t CVMX_GPIO_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000D00ull);
 }
@@ -187,6 +195,7 @@ static inline uint64_t CVMX_GPIO_DBG_ENA_FUNC(void)
 static inline uint64_t CVMX_GPIO_INTRX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_GPIO_INTRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000A00ull) + ((offset) & 15) * 8;
@@ -199,6 +208,7 @@ static inline uint64_t CVMX_GPIO_INTRX(unsigned long offset)
 static inline uint64_t CVMX_GPIO_MC_INTRX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 4) && (offset <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 4) && (offset <= 7))))))
 		cvmx_warn("CVMX_GPIO_MC_INTRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000C20ull) + ((offset) & 7) * 8 - 8*4;
@@ -207,10 +217,21 @@ static inline uint64_t CVMX_GPIO_MC_INTRX(unsigned long offset)
 #define CVMX_GPIO_MC_INTRX(offset) (CVMX_ADD_IO_SEG(0x0001070000000C20ull) + ((offset) & 7) * 8 - 8*4)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GPIO_MC_INTRX_W1S(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 4) && (offset <= 7))))))
+		cvmx_warn("CVMX_GPIO_MC_INTRX_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070000000E20ull) + ((offset) & 7) * 8 - 8*4;
+}
+#else
+#define CVMX_GPIO_MC_INTRX_W1S(offset) (CVMX_ADD_IO_SEG(0x0001070000000E20ull) + ((offset) & 7) * 8 - 8*4)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_GPIO_MULTI_CAST CVMX_GPIO_MULTI_CAST_FUNC()
 static inline uint64_t CVMX_GPIO_MULTI_CAST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_GPIO_MULTI_CAST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008B0ull);
 }
@@ -221,7 +242,7 @@ static inline uint64_t CVMX_GPIO_MULTI_CAST_FUNC(void)
 #define CVMX_GPIO_OCLA_EXTEN_TRIG CVMX_GPIO_OCLA_EXTEN_TRIG_FUNC()
 static inline uint64_t CVMX_GPIO_OCLA_EXTEN_TRIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_OCLA_EXTEN_TRIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008B8ull);
 }
@@ -255,7 +276,7 @@ static inline uint64_t CVMX_GPIO_SATA_CTL_FUNC(void)
 #define CVMX_GPIO_TIM_CTL CVMX_GPIO_TIM_CTL_FUNC()
 static inline uint64_t CVMX_GPIO_TIM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_GPIO_TIM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008A0ull);
 }
@@ -265,6 +286,17 @@ static inline uint64_t CVMX_GPIO_TIM_CTL_FUNC(void)
 #define CVMX_GPIO_TX_CLR (CVMX_ADD_IO_SEG(0x0001070000000890ull))
 #define CVMX_GPIO_TX_SET (CVMX_ADD_IO_SEG(0x0001070000000888ull))
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_GPIO_USBDRD_CTL CVMX_GPIO_USBDRD_CTL_FUNC()
+static inline uint64_t CVMX_GPIO_USBDRD_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_GPIO_USBDRD_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00010700000008A8ull);
+}
+#else
+#define CVMX_GPIO_USBDRD_CTL (CVMX_ADD_IO_SEG(0x00010700000008A8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_GPIO_USBH_CTL CVMX_GPIO_USBH_CTL_FUNC()
 static inline uint64_t CVMX_GPIO_USBH_CTL_FUNC(void)
 {
@@ -273,6 +305,7 @@ static inline uint64_t CVMX_GPIO_USBH_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00010700000008A0ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000898ull);
 			break;
 	}
@@ -287,6 +320,7 @@ static inline uint64_t CVMX_GPIO_USBH_CTL_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00010700000008A0ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000898ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000898ull);
@@ -452,6 +486,7 @@ union cvmx_gpio_bit_cfgx {
 #endif
 	} cn70xx;
 	struct cvmx_gpio_bit_cfgx_cn70xx      cn70xxp1;
+	struct cvmx_gpio_bit_cfgx_cn70xx      cn73xx;
 	struct cvmx_gpio_bit_cfgx_cn70xx      cn78xx;
 	struct cvmx_gpio_bit_cfgx_cn61xx      cnf71xx;
 };
@@ -509,6 +544,7 @@ union cvmx_gpio_clk_genx {
 	struct cvmx_gpio_clk_genx_s           cn68xxp1;
 	struct cvmx_gpio_clk_genx_s           cn70xx;
 	struct cvmx_gpio_clk_genx_s           cn70xxp1;
+	struct cvmx_gpio_clk_genx_s           cn73xx;
 	struct cvmx_gpio_clk_genx_s           cn78xx;
 	struct cvmx_gpio_clk_genx_s           cnf71xx;
 };
@@ -669,18 +705,19 @@ union cvmx_gpio_clk_syncex {
 #endif
 	} cn70xx;
 	struct cvmx_gpio_clk_syncex_cn70xx    cn70xxp1;
-	struct cvmx_gpio_clk_syncex_cn78xx {
+	struct cvmx_gpio_clk_syncex_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t qlm_sel                      : 4;  /**< Selects which QLM(0..7) to select from. */
+	uint64_t qlm_sel                      : 4;  /**< Selects which QLM(0..3) or DLM(4..6) to select from, value 7-15 are invalid. */
 	uint64_t reserved_4_7                 : 4;
-	uint64_t div                          : 2;  /**< GPIO internal clock divider setting relative to QLM SERDES CLOCK_SYNCE. The maximum
+	uint64_t div                          : 2;  /**< GPIO internal clock divider setting relative to QLM/DLM SERDES CLOCK_SYNCE. The maximum
                                                          supported GPIO output frequency is 125 MHz.
                                                          0x0 = Divide by 20.
                                                          0x1 = Divide by 40.
                                                          0x2 = Divide by 80.
                                                          0x3 = Divide by 160. */
-	uint64_t lane_sel                     : 2;  /**< Selects which RX lane clock from QLMx to use as the GPIO internal QLMx clock. */
+	uint64_t lane_sel                     : 2;  /**< Selects which RX lane clock from QLMx(DLMx) to use as the GPIO internal QLMx(DLMx) clock.
+                                                         For DLMx, valid LANE_SEL is 0/1. */
 #else
 	uint64_t lane_sel                     : 2;
 	uint64_t div                          : 2;
@@ -688,7 +725,8 @@ union cvmx_gpio_clk_syncex {
 	uint64_t qlm_sel                      : 4;
 	uint64_t reserved_12_63               : 52;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_gpio_clk_syncex_cn73xx    cn78xx;
 };
 typedef union cvmx_gpio_clk_syncex cvmx_gpio_clk_syncex_t;
 
@@ -716,6 +754,7 @@ union cvmx_gpio_comp {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_gpio_comp_s               cn73xx;
 	struct cvmx_gpio_comp_s               cn78xx;
 };
 typedef union cvmx_gpio_comp cvmx_gpio_comp_t;
@@ -790,6 +829,20 @@ union cvmx_gpio_intrx {
 	uint64_t u64;
 	struct cvmx_gpio_intrx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t intr_w1s                     : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to set, otherwise
+                                                         will clear automatically when GPIO pin de-asserts. Read out value is INTR. */
+	uint64_t intr                         : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to clear, otherwise
+                                                         will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(). */
+#else
+	uint64_t intr                         : 1;
+	uint64_t intr_w1s                     : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_gpio_intrx_s              cn73xx;
+	struct cvmx_gpio_intrx_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t intr                         : 1;  /**< GPIO signalled interrupt. If interrupts are edge sensitive, write one to clear, otherwise
                                                          will clear automatically when GPIO pin de-asserts. Throws GPIO_INTSN_E::GPIO_INTR(). */
@@ -797,8 +850,7 @@ union cvmx_gpio_intrx {
 	uint64_t intr                         : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
-	} s;
-	struct cvmx_gpio_intrx_s              cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_gpio_intrx cvmx_gpio_intrx_t;
 
@@ -822,11 +874,44 @@ union cvmx_gpio_mc_intrx {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_gpio_mc_intrx_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t intr                         : 16; /**< GPIO interrupt for each core. When corresponding GPIO4-7 is edge-triggered and MILTI_CAST
+                                                         is enabled, a GPIO assertion will set all 48 bits. Each bit is expected to be routed to
+                                                         interrupt a different core using the CIU, and each core will then write one to clear its
+                                                         corresponding bit in this register. Throws GPIO_INTSN_E::GPIO_MC_INTR()_PP(). */
+#else
+	uint64_t intr                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_gpio_mc_intrx_s           cn78xx;
 };
 typedef union cvmx_gpio_mc_intrx cvmx_gpio_mc_intrx_t;
 
 /**
+ * cvmx_gpio_mc_intr#_w1s
+ */
+union cvmx_gpio_mc_intrx_w1s {
+	uint64_t u64;
+	struct cvmx_gpio_mc_intrx_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t intr                         : 16; /**< GPIO interrupt for each core. When corresponding GPIO4-7 is edge-triggered and MILTI_CAST
+                                                         is enabled, a GPIO assertion will set all 48 bits. Each bit is expected to be routed to
+                                                         interrupt a different core using the CIU, and each core will then write one to clear its
+                                                         corresponding bit in this register. Throws GPIO_INTSN_E::GPIO_MC_INTR()_PP(). */
+#else
+	uint64_t intr                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gpio_mc_intrx_w1s_s       cn73xx;
+};
+typedef union cvmx_gpio_mc_intrx_w1s cvmx_gpio_mc_intrx_w1s_t;
+
+/**
  * cvmx_gpio_multi_cast
  *
  * This register enables multicast GPIO interrupts.
@@ -852,6 +937,7 @@ union cvmx_gpio_multi_cast {
 	struct cvmx_gpio_multi_cast_s         cn61xx;
 	struct cvmx_gpio_multi_cast_s         cn70xx;
 	struct cvmx_gpio_multi_cast_s         cn70xxp1;
+	struct cvmx_gpio_multi_cast_s         cn73xx;
 	struct cvmx_gpio_multi_cast_s         cn78xx;
 	struct cvmx_gpio_multi_cast_s         cnf71xx;
 };
@@ -876,6 +962,7 @@ union cvmx_gpio_ocla_exten_trig {
 	} s;
 	struct cvmx_gpio_ocla_exten_trig_s    cn70xx;
 	struct cvmx_gpio_ocla_exten_trig_s    cn70xxp1;
+	struct cvmx_gpio_ocla_exten_trig_s    cn73xx;
 	struct cvmx_gpio_ocla_exten_trig_s    cn78xx;
 };
 typedef union cvmx_gpio_ocla_exten_trig cvmx_gpio_ocla_exten_trig_t;
@@ -919,15 +1006,23 @@ union cvmx_gpio_rx_dat {
 	uint64_t u64;
 	struct cvmx_gpio_rx_dat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t dat                          : 32; /**< GPIO Read Data */
+#else
+	uint64_t dat                          : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gpio_rx_dat_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_24_63               : 40;
 	uint64_t dat                          : 24; /**< GPIO Read Data */
 #else
 	uint64_t dat                          : 24;
 	uint64_t reserved_24_63               : 40;
 #endif
-	} s;
-	struct cvmx_gpio_rx_dat_s             cn30xx;
-	struct cvmx_gpio_rx_dat_s             cn31xx;
+	} cn30xx;
+	struct cvmx_gpio_rx_dat_cn30xx        cn31xx;
 	struct cvmx_gpio_rx_dat_cn38xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
@@ -938,7 +1033,7 @@ union cvmx_gpio_rx_dat {
 #endif
 	} cn38xx;
 	struct cvmx_gpio_rx_dat_cn38xx        cn38xxp2;
-	struct cvmx_gpio_rx_dat_s             cn50xx;
+	struct cvmx_gpio_rx_dat_cn30xx        cn50xx;
 	struct cvmx_gpio_rx_dat_cn38xx        cn52xx;
 	struct cvmx_gpio_rx_dat_cn38xx        cn52xxp1;
 	struct cvmx_gpio_rx_dat_cn38xx        cn56xx;
@@ -961,6 +1056,7 @@ union cvmx_gpio_rx_dat {
 	struct cvmx_gpio_rx_dat_cn38xx        cn68xxp1;
 	struct cvmx_gpio_rx_dat_cn61xx        cn70xx;
 	struct cvmx_gpio_rx_dat_cn61xx        cn70xxp1;
+	struct cvmx_gpio_rx_dat_s             cn73xx;
 	struct cvmx_gpio_rx_dat_cn61xx        cn78xx;
 	struct cvmx_gpio_rx_dat_cn61xx        cnf71xx;
 };
@@ -1030,6 +1126,7 @@ union cvmx_gpio_tim_ctl {
 #endif
 	} cn68xx;
 	struct cvmx_gpio_tim_ctl_cn68xx       cn68xxp1;
+	struct cvmx_gpio_tim_ctl_s            cn73xx;
 	struct cvmx_gpio_tim_ctl_s            cn78xx;
 };
 typedef union cvmx_gpio_tim_ctl cvmx_gpio_tim_ctl_t;
@@ -1041,17 +1138,25 @@ union cvmx_gpio_tx_clr {
 	uint64_t u64;
 	struct cvmx_gpio_tx_clr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_24_63               : 40;
-	uint64_t clr                          : 24; /**< Bit mask to indicate which GPIO_TX_DAT bits to set
+	uint64_t reserved_32_63               : 32;
+	uint64_t clr                          : 32; /**< Bit mask to indicate which GPIO_TX_DAT bits to set
                                                          to '0'. When read, CLR returns the GPIO_TX_DAT
                                                          storage. */
 #else
+	uint64_t clr                          : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gpio_tx_clr_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t clr                          : 24; /**< Bit mask to indicate which bits to drive to '0'. */
+#else
 	uint64_t clr                          : 24;
 	uint64_t reserved_24_63               : 40;
 #endif
-	} s;
-	struct cvmx_gpio_tx_clr_s             cn30xx;
-	struct cvmx_gpio_tx_clr_s             cn31xx;
+	} cn30xx;
+	struct cvmx_gpio_tx_clr_cn30xx        cn31xx;
 	struct cvmx_gpio_tx_clr_cn38xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
@@ -1062,7 +1167,7 @@ union cvmx_gpio_tx_clr {
 #endif
 	} cn38xx;
 	struct cvmx_gpio_tx_clr_cn38xx        cn38xxp2;
-	struct cvmx_gpio_tx_clr_s             cn50xx;
+	struct cvmx_gpio_tx_clr_cn30xx        cn50xx;
 	struct cvmx_gpio_tx_clr_cn38xx        cn52xx;
 	struct cvmx_gpio_tx_clr_cn38xx        cn52xxp1;
 	struct cvmx_gpio_tx_clr_cn38xx        cn56xx;
@@ -1087,6 +1192,7 @@ union cvmx_gpio_tx_clr {
 	struct cvmx_gpio_tx_clr_cn38xx        cn68xxp1;
 	struct cvmx_gpio_tx_clr_cn61xx        cn70xx;
 	struct cvmx_gpio_tx_clr_cn61xx        cn70xxp1;
+	struct cvmx_gpio_tx_clr_s             cn73xx;
 	struct cvmx_gpio_tx_clr_cn61xx        cn78xx;
 	struct cvmx_gpio_tx_clr_cn61xx        cnf71xx;
 };
@@ -1099,17 +1205,25 @@ union cvmx_gpio_tx_set {
 	uint64_t u64;
 	struct cvmx_gpio_tx_set_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_24_63               : 40;
-	uint64_t set                          : 24; /**< Bit mask to indicate which GPIO_TX_DAT bits to set
+	uint64_t reserved_32_63               : 32;
+	uint64_t set                          : 32; /**< Bit mask to indicate which GPIO_TX_DAT bits to set
                                                          to '1'. When read, SET returns the GPIO_TX_DAT
                                                          storage. */
 #else
+	uint64_t set                          : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gpio_tx_set_cn30xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t set                          : 24; /**< Bit mask to indicate which bits to drive to '1'. */
+#else
 	uint64_t set                          : 24;
 	uint64_t reserved_24_63               : 40;
 #endif
-	} s;
-	struct cvmx_gpio_tx_set_s             cn30xx;
-	struct cvmx_gpio_tx_set_s             cn31xx;
+	} cn30xx;
+	struct cvmx_gpio_tx_set_cn30xx        cn31xx;
 	struct cvmx_gpio_tx_set_cn38xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
@@ -1120,7 +1234,7 @@ union cvmx_gpio_tx_set {
 #endif
 	} cn38xx;
 	struct cvmx_gpio_tx_set_cn38xx        cn38xxp2;
-	struct cvmx_gpio_tx_set_s             cn50xx;
+	struct cvmx_gpio_tx_set_cn30xx        cn50xx;
 	struct cvmx_gpio_tx_set_cn38xx        cn52xx;
 	struct cvmx_gpio_tx_set_cn38xx        cn52xxp1;
 	struct cvmx_gpio_tx_set_cn38xx        cn56xx;
@@ -1145,12 +1259,31 @@ union cvmx_gpio_tx_set {
 	struct cvmx_gpio_tx_set_cn38xx        cn68xxp1;
 	struct cvmx_gpio_tx_set_cn61xx        cn70xx;
 	struct cvmx_gpio_tx_set_cn61xx        cn70xxp1;
+	struct cvmx_gpio_tx_set_s             cn73xx;
 	struct cvmx_gpio_tx_set_cn61xx        cn78xx;
 	struct cvmx_gpio_tx_set_cn61xx        cnf71xx;
 };
 typedef union cvmx_gpio_tx_set cvmx_gpio_tx_set_t;
 
 /**
+ * cvmx_gpio_usbdrd_ctl
+ */
+union cvmx_gpio_usbdrd_ctl {
+	uint64_t u64;
+	struct cvmx_gpio_usbdrd_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t sel                          : 5;  /**< Selects the GPIO(0..31) input pin for USBDRD over-current control. */
+#else
+	uint64_t sel                          : 5;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_gpio_usbdrd_ctl_s         cn73xx;
+};
+typedef union cvmx_gpio_usbdrd_ctl cvmx_gpio_usbdrd_ctl_t;
+
+/**
  * cvmx_gpio_usbh_ctl
  *
  * Select GPIO0-19 received data (GPIO_RX_DAT[DAT]) routing to USB.
@@ -1183,16 +1316,16 @@ union cvmx_gpio_usbh_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_gpio_usbh_ctl_cn70xx      cn70xxp1;
-	struct cvmx_gpio_usbh_ctl_cn78xx {
+	struct cvmx_gpio_usbh_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t sel                          : 5;  /**< Selects the GPIO(0..19) input pin for USBH over-current control. With SEL values 20-31,
-                                                         signal is always zero. */
+	uint64_t sel                          : 5;  /**< Selects the GPIO(0..31) input pin for USBH over-current control. */
 #else
 	uint64_t sel                          : 5;
 	uint64_t reserved_5_63                : 59;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_gpio_usbh_ctl_cn73xx      cn78xx;
 };
 typedef union cvmx_gpio_usbh_ctl cvmx_gpio_usbh_ctl_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index a95e311..0e13e64f 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -56,6 +56,7 @@
 static inline uint64_t CVMX_GSERX_ANA_ATEST(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_ANA_ATEST(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000800ull) + ((block_id) & 15) * 0x1000000ull;
@@ -67,6 +68,7 @@ static inline uint64_t CVMX_GSERX_ANA_ATEST(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_ANA_SEL(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_ANA_SEL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000808ull) + ((block_id) & 15) * 0x1000000ull;
@@ -78,6 +80,7 @@ static inline uint64_t CVMX_GSERX_ANA_SEL(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_BR_RXX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_RXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000400ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -89,6 +92,7 @@ static inline uint64_t CVMX_GSERX_BR_RXX_CTL(unsigned long offset, unsigned long
 static inline uint64_t CVMX_GSERX_BR_RXX_EER(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_RXX_EER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000418ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -100,6 +104,7 @@ static inline uint64_t CVMX_GSERX_BR_RXX_EER(unsigned long offset, unsigned long
 static inline uint64_t CVMX_GSERX_BR_TXX_CTL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000420ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -111,6 +116,7 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CTL(unsigned long offset, unsigned long
 static inline uint64_t CVMX_GSERX_BR_TXX_CUR(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_CUR(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000438ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128;
@@ -119,9 +125,21 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CUR(unsigned long offset, unsigned long
 #define CVMX_GSERX_BR_TXX_CUR(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090000438ull) + (((offset) & 3) + ((block_id) & 15) * 0x20000ull) * 128)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_BR_TXX_TAP(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_BR_TXX_TAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000440ull) + (((offset) & 3) + ((block_id) & 7) * 0x20000ull) * 128;
+}
+#else
+#define CVMX_GSERX_BR_TXX_TAP(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090000440ull) + (((offset) & 3) + ((block_id) & 7) * 0x20000ull) * 128)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_CFG(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_CFG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000080ull) + ((block_id) & 15) * 0x1000000ull;
@@ -133,6 +151,7 @@ static inline uint64_t CVMX_GSERX_CFG(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_DBG(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_DBG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000098ull) + ((block_id) & 15) * 0x1000000ull;
@@ -496,6 +515,7 @@ static inline uint64_t CVMX_GSERX_DLMX_TX_TERM_OFFSET(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_EQ_WAIT_TIME(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((block_id) & 15) * 0x1000000ull;
@@ -507,6 +527,7 @@ static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_GLBL_PLL_MONITOR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_GLBL_PLL_MONITOR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090460100ull) + ((block_id) & 15) * 0x1000000ull;
@@ -518,6 +539,7 @@ static inline uint64_t CVMX_GSERX_GLBL_PLL_MONITOR(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_GLBL_TAD(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_GLBL_TAD(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090460400ull) + ((block_id) & 15) * 0x1000000ull;
@@ -529,6 +551,7 @@ static inline uint64_t CVMX_GSERX_GLBL_TAD(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_GLBL_TM_ADMON(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_GLBL_TM_ADMON(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090460408ull) + ((block_id) & 15) * 0x1000000ull;
@@ -540,6 +563,7 @@ static inline uint64_t CVMX_GSERX_GLBL_TM_ADMON(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_IDDQ_MODE(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_IDDQ_MODE(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000018ull) + ((block_id) & 15) * 0x1000000ull;
@@ -551,6 +575,7 @@ static inline uint64_t CVMX_GSERX_IDDQ_MODE(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANEX_LBERT_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0020ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -562,6 +587,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_CFG(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_LBERT_ECNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_ECNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0028ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -573,6 +599,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_ECNT(unsigned long offset, unsigne
 static inline uint64_t CVMX_GSERX_LANEX_LBERT_PAT_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_PAT_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -584,6 +611,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_PAT_CFG(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -595,6 +623,7 @@ static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_0(unsigned long offset, unsigne
 static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -606,6 +635,7 @@ static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_1(unsigned long offset, unsigne
 static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -617,6 +647,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_0(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0068ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -628,6 +659,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_1(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0070ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -639,6 +671,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_2(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -650,6 +683,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(unsigned long offset,
 static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PWR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -661,6 +695,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL_P2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PWR_CTRL_P2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904600B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -672,6 +707,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL_P2(unsigned long offset, unsign
 static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440280ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -683,6 +719,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440288ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -694,6 +731,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_1(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440290ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -705,6 +743,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_2(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440038ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -716,6 +755,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_1(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440040ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -727,6 +767,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_2(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440208ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -738,6 +779,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(unsigned long offset,
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -749,6 +791,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_1(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -760,6 +803,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_2(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440000ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -771,6 +815,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_0(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440008ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -782,6 +827,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_1(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440010ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -793,6 +839,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_2(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_3(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440018ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -804,6 +851,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_3(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_4(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440020ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -815,6 +863,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_4(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_5(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440028ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -826,6 +875,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_5(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CTLE_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440058ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -837,6 +887,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_LOOP_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_LOOP_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440048ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -848,6 +899,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_LOOP_CTRL(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_MISC_OVRRD(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440258ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -859,6 +911,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440060ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -870,6 +923,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_VAL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_VAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440078ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -881,6 +935,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_VAL(unsigned long offset, uns
 static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440240ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -892,6 +947,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(unsigned long offset, u
 static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440248ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -903,6 +959,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(unsigned long offset, u
 static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440250ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -914,6 +971,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(unsigned long offset, u
 static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090440200ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -925,6 +983,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_CTRL(unsigned long offset, unsign
 static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -936,6 +995,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_0(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904402C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -944,9 +1004,43 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_1(unsigned long offset, un
 #define CVMX_GSERX_LANEX_RX_VMA_STATUS_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_0(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_SDS_PIN_MON_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_LANEX_SDS_PIN_MON_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_SDS_PIN_MON_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400A8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -958,6 +1052,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_0(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400B0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -969,6 +1064,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_1(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400B8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -980,6 +1076,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_2(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_3(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400C0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -991,6 +1088,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_3(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904400C8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
@@ -1002,6 +1100,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(unsigned long offset, un
 static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_LPBKEN(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000110ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1013,6 +1112,7 @@ static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_MODE(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_MODE(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000118ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1024,6 +1124,7 @@ static inline uint64_t CVMX_GSERX_LANE_MODE(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_POFF(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_POFF(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000108ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1035,6 +1136,7 @@ static inline uint64_t CVMX_GSERX_LANE_POFF(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_PX_MODE_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0040ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1046,6 +1148,7 @@ static inline uint64_t CVMX_GSERX_LANE_PX_MODE_0(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANE_PX_MODE_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0048ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1057,6 +1160,7 @@ static inline uint64_t CVMX_GSERX_LANE_PX_MODE_1(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_LANE_SRST(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_SRST(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000100ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1068,6 +1172,7 @@ static inline uint64_t CVMX_GSERX_LANE_SRST(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E01B0ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1079,6 +1184,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E01B8ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1090,6 +1196,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E01C0ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1101,6 +1208,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_0(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_0(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E01C8ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1112,6 +1220,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_0(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_1(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_1(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E01D0ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1123,6 +1232,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_1(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_2(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_2(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E01D8ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1508,6 +1618,7 @@ static inline uint64_t CVMX_GSERX_PHYX_OVRD_IN_LO(unsigned long offset, unsigned
 static inline uint64_t CVMX_GSERX_PHY_CTL(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_PHY_CTL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000000ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1519,6 +1630,7 @@ static inline uint64_t CVMX_GSERX_PHY_CTL(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_PIPE_LPBK(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_PIPE_LPBK(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1530,6 +1642,7 @@ static inline uint64_t CVMX_GSERX_PIPE_LPBK(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_PLL_PX_MODE_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_PLL_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0030ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1541,6 +1654,7 @@ static inline uint64_t CVMX_GSERX_PLL_PX_MODE_0(unsigned long offset, unsigned l
 static inline uint64_t CVMX_GSERX_PLL_PX_MODE_1(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_PLL_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0038ull) + (((offset) & 15) + ((block_id) & 15) * 0x80000ull) * 32;
@@ -1552,6 +1666,7 @@ static inline uint64_t CVMX_GSERX_PLL_PX_MODE_1(unsigned long offset, unsigned l
 static inline uint64_t CVMX_GSERX_PLL_STAT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_PLL_STAT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000010ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1563,6 +1678,7 @@ static inline uint64_t CVMX_GSERX_PLL_STAT(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_QLM_STAT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_QLM_STAT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800900000A0ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1574,6 +1690,7 @@ static inline uint64_t CVMX_GSERX_QLM_STAT(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_RDET_TIME(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_RDET_TIME(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904E0008ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1582,9 +1699,32 @@ static inline uint64_t CVMX_GSERX_RDET_TIME(unsigned long block_id)
 #define CVMX_GSERX_RDET_TIME(block_id) (CVMX_ADD_IO_SEG(0x00011800904E0008ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_REFCLK_EVT_CNTR(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6)))))
+		cvmx_warn("CVMX_GSERX_REFCLK_EVT_CNTR(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000178ull) + ((block_id) & 7) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_REFCLK_EVT_CNTR(block_id) (CVMX_ADD_IO_SEG(0x0001180090000178ull) + ((block_id) & 7) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_REFCLK_EVT_CTRL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6)))))
+		cvmx_warn("CVMX_GSERX_REFCLK_EVT_CTRL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000170ull) + ((block_id) & 7) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_REFCLK_EVT_CTRL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000170ull) + ((block_id) & 7) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_REFCLK_SEL(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_REFCLK_SEL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000008ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1596,6 +1736,7 @@ static inline uint64_t CVMX_GSERX_REFCLK_SEL(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_RX_COAST(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_COAST(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000138ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1607,6 +1748,7 @@ static inline uint64_t CVMX_GSERX_RX_COAST(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_RX_EIE_DETEN(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_DETEN(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000148ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1618,6 +1760,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_DETEN(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_RX_EIE_DETSTS(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_DETSTS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000150ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1629,6 +1772,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_DETSTS(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_RX_EIE_FILTER(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_FILTER(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000158ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1640,6 +1784,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_FILTER(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_RX_POLARITY(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_POLARITY(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000160ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1651,6 +1796,7 @@ static inline uint64_t CVMX_GSERX_RX_POLARITY(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P1(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P1(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904600B0ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1670,15 +1816,54 @@ static inline uint64_t CVMX_GSERX_SATA_CFG(unsigned long block_id)
 #define CVMX_GSERX_SATA_CFG(block_id) (CVMX_ADD_IO_SEG(0x0001180090100208ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_SATA_LANE_RST(unsigned long block_id)
+static inline uint64_t CVMX_GSERX_SATA_LANEX_TX_AMPX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_LANE_RST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090100210ull);
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2))))))
+		cvmx_warn("CVMX_GSERX_SATA_LANEX_TX_AMPX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
+	return CVMX_ADD_IO_SEG(0x0001180090000B00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3);
+}
+#else
+#define CVMX_GSERX_SATA_LANEX_TX_AMPX(a, b, c) (CVMX_ADD_IO_SEG(0x0001180090000B00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SATA_LANEX_TX_PREEMPHX(unsigned long a, unsigned long b, unsigned long c)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 6)) && ((b <= 1)) && ((c <= 2))))))
+		cvmx_warn("CVMX_GSERX_SATA_LANEX_TX_PREEMPHX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
+	return CVMX_ADD_IO_SEG(0x0001180090000A00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3);
 }
 #else
-#define CVMX_GSERX_SATA_LANE_RST(block_id) (CVMX_ADD_IO_SEG(0x0001180090100210ull))
+#define CVMX_GSERX_SATA_LANEX_TX_PREEMPHX(a, b, c) (CVMX_ADD_IO_SEG(0x0001180090000A00ull) + ((a) << 24) + ((b) << 5) + ((c) << 3))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SATA_LANE_RST(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001180090100210ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 6))
+				return CVMX_ADD_IO_SEG(0x0001180090000908ull) + ((block_id) & 7) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_GSERX_SATA_LANE_RST (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000908ull) + ((block_id) & 7) * 0x1000000ull;
+}
+#else
+static inline uint64_t CVMX_GSERX_SATA_LANE_RST(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090100210ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090000908ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180090000908ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SATA_P0_TX_AMP_GENX(unsigned long offset, unsigned long block_id)
@@ -1782,29 +1967,64 @@ static inline uint64_t CVMX_GSERX_SATA_SSC_RANGE(unsigned long block_id)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SATA_STATUS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090100200ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001180090100200ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 6))
+				return CVMX_ADD_IO_SEG(0x0001180090100900ull) + ((block_id) & 7) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_GSERX_SATA_STATUS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090100900ull) + ((block_id) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SATA_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180090100200ull))
+static inline uint64_t CVMX_GSERX_SATA_STATUS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090100200ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090100900ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180090100900ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SATA_TX_INVERT(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0)))))
-		cvmx_warn("CVMX_GSERX_SATA_TX_INVERT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090100220ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001180090100220ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 6))
+				return CVMX_ADD_IO_SEG(0x0001180090000910ull) + ((block_id) & 7) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_GSERX_SATA_TX_INVERT (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000910ull) + ((block_id) & 7) * 0x1000000ull;
 }
 #else
-#define CVMX_GSERX_SATA_TX_INVERT(block_id) (CVMX_ADD_IO_SEG(0x0001180090100220ull))
+static inline uint64_t CVMX_GSERX_SATA_TX_INVERT(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090100220ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180090000910ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180090000910ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_SCRATCH(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1816,6 +2036,7 @@ static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_RX_SDLL_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090460220ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
@@ -1827,6 +2048,7 @@ static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_SLICE_CFG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090460060ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1838,6 +2060,7 @@ static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_SPD(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_SPD(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000088ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1849,6 +2072,7 @@ static inline uint64_t CVMX_GSERX_SPD(unsigned long block_id)
 static inline uint64_t CVMX_GSERX_SRST(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_SRST(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000090ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1857,9 +2081,32 @@ static inline uint64_t CVMX_GSERX_SRST(unsigned long block_id)
 #define CVMX_GSERX_SRST(block_id) (CVMX_ADD_IO_SEG(0x0001180090000090ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_TXCLK_EVT_CNTR(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6)))))
+		cvmx_warn("CVMX_GSERX_TXCLK_EVT_CNTR(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000188ull) + ((block_id) & 7) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_TXCLK_EVT_CNTR(block_id) (CVMX_ADD_IO_SEG(0x0001180090000188ull) + ((block_id) & 7) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_TXCLK_EVT_CTRL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6)))))
+		cvmx_warn("CVMX_GSERX_TXCLK_EVT_CTRL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090000180ull) + ((block_id) & 7) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_TXCLK_EVT_CTRL(block_id) (CVMX_ADD_IO_SEG(0x0001180090000180ull) + ((block_id) & 7) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_TX_VBOOST(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
 		cvmx_warn("CVMX_GSERX_TX_VBOOST(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180090000130ull) + ((block_id) & 15) * 0x1000000ull;
@@ -1890,6 +2137,7 @@ union cvmx_gserx_ana_atest {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_gserx_ana_atest_s         cn73xx;
 	struct cvmx_gserx_ana_atest_s         cn78xx;
 };
 typedef union cvmx_gserx_ana_atest cvmx_gserx_ana_atest_t;
@@ -1911,6 +2159,7 @@ union cvmx_gserx_ana_sel {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_gserx_ana_sel_s           cn73xx;
 	struct cvmx_gserx_ana_sel_s           cn78xx;
 };
 typedef union cvmx_gserx_ana_sel cvmx_gserx_ana_sel_t;
@@ -1946,6 +2195,7 @@ union cvmx_gserx_br_rxx_ctl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_gserx_br_rxx_ctl_s        cn73xx;
 	struct cvmx_gserx_br_rxx_ctl_s        cn78xx;
 };
 typedef union cvmx_gserx_br_rxx_ctl cvmx_gserx_br_rxx_ctl_t;
@@ -1990,6 +2240,7 @@ union cvmx_gserx_br_rxx_eer {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_br_rxx_eer_s        cn73xx;
 	struct cvmx_gserx_br_rxx_eer_s        cn78xx;
 };
 typedef union cvmx_gserx_br_rxx_eer cvmx_gserx_br_rxx_eer_t;
@@ -2009,6 +2260,7 @@ union cvmx_gserx_br_txx_ctl {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_br_txx_ctl_s        cn73xx;
 	struct cvmx_gserx_br_txx_ctl_s        cn78xx;
 };
 typedef union cvmx_gserx_br_txx_ctl cvmx_gserx_br_txx_ctl_t;
@@ -2033,17 +2285,78 @@ union cvmx_gserx_br_txx_cur {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_br_txx_cur_s        cn73xx;
 	struct cvmx_gserx_br_txx_cur_s        cn78xx;
 };
 typedef union cvmx_gserx_br_txx_cur cvmx_gserx_br_txx_cur_t;
 
 /**
+ * cvmx_gser#_br_tx#_tap
+ */
+union cvmx_gserx_br_txx_tap {
+	uint64_t u64;
+	struct cvmx_gserx_br_txx_tap_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t txt_pre                      : 4;  /**< After TX Base-R Link Training, this is the resultant POST Tap value that was
+                                                         written to the PHY.  This field has no meaning if TX Base-R Link Traning was
+                                                         not performed.
+                                                         For diagnostic use only. */
+	uint64_t txt_swing                    : 5;  /**< After TX Base-R Link Training, this is the resultant SWING Tap value that was
+                                                         written to the PHY.  This field has no meaning if TX Base-R Link Traning was
+                                                         not performed.
+                                                         For diagnostic use only. */
+	uint64_t txt_post                     : 5;  /**< After TX Base-R Link Training, this is the resultant POST Tap value that was
+                                                         written to the PHY.  This field has no meaning if TX Base-R Link Traning was
+                                                         not performed.
+                                                         For diagnostic use only. */
+#else
+	uint64_t txt_post                     : 5;
+	uint64_t txt_swing                    : 5;
+	uint64_t txt_pre                      : 4;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_br_txx_tap_s        cn73xx;
+};
+typedef union cvmx_gserx_br_txx_tap cvmx_gserx_br_txx_tap_t;
+
+/**
  * cvmx_gser#_cfg
  */
 union cvmx_gserx_cfg {
 	uint64_t u64;
 	struct cvmx_gserx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_6_63                : 58;
+	uint64_t sata                         : 1;  /**< Indicates the GSER is configured for SATA mode. Only one of the BGX, SATA, or PCIE
+                                                         modes can be set at any one time. */
+	uint64_t bgx_quad                     : 1;  /**< For non-CCPI links, indicates the BGX is in quad aggregation mode when GSER()_CFG[BGX]
+                                                         is also set. A single controller is used for all four lanes. For CCPI links, this bit has
+                                                         no meaning. */
+	uint64_t bgx_dual                     : 1;  /**< For non-CCPI links, indicates the BGX is in dual aggregation mode when GSER()_CFG[BGX]
+                                                         is also set. A single controller is used for lanes 0 and 1 and another controller is used
+                                                         for lanes 2 and 3. For CCPI links, this bit has no meaning. */
+	uint64_t bgx                          : 1;  /**< For non-CCPI links, indicates the GSER is configured for BGX mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For CCPI links, this bit has no meaning. */
+	uint64_t ila                          : 1;  /**< For non-CCPI links, indicates the GSER is configured for ILK/ILA mode. For CCPI links this
+                                                         bit will be set. Only one of the BGX, ILA, or PCIE modes can be set at any one time. For
+                                                         CCPI links, this bit has no meaning. */
+	uint64_t pcie                         : 1;  /**< For non-CCPI links, indicates the GSER is configured for PCIE mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For CCPI links, this bit has no meaning. */
+#else
+	uint64_t pcie                         : 1;
+	uint64_t ila                          : 1;
+	uint64_t bgx                          : 1;
+	uint64_t bgx_dual                     : 1;
+	uint64_t bgx_quad                     : 1;
+	uint64_t sata                         : 1;
+	uint64_t reserved_6_63                : 58;
+#endif
+	} s;
+	struct cvmx_gserx_cfg_s               cn73xx;
+	struct cvmx_gserx_cfg_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t bgx_quad                     : 1;  /**< For non-CCPI links, indicates the BGX is in quad aggregation mode when GSER()_CFG[BGX]
                                                          is also set. A single controller is used for all four lanes. For CCPI links, this bit has
@@ -2066,8 +2379,7 @@ union cvmx_gserx_cfg {
 	uint64_t bgx_quad                     : 1;
 	uint64_t reserved_5_63                : 59;
 #endif
-	} s;
-	struct cvmx_gserx_cfg_s               cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_gserx_cfg cvmx_gserx_cfg_t;
 
@@ -2086,6 +2398,7 @@ union cvmx_gserx_dbg {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_dbg_s               cn73xx;
 	struct cvmx_gserx_dbg_s               cn78xx;
 };
 typedef union cvmx_gserx_dbg cvmx_gserx_dbg_t;
@@ -2969,6 +3282,7 @@ union cvmx_gserx_eq_wait_time {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_gserx_eq_wait_time_s      cn73xx;
 	struct cvmx_gserx_eq_wait_time_s      cn78xx;
 };
 typedef union cvmx_gserx_eq_wait_time cvmx_gserx_eq_wait_time_t;
@@ -3002,6 +3316,7 @@ union cvmx_gserx_glbl_pll_monitor {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_glbl_pll_monitor_s  cn73xx;
 	struct cvmx_gserx_glbl_pll_monitor_s  cn78xx;
 };
 typedef union cvmx_gserx_glbl_pll_monitor cvmx_gserx_glbl_pll_monitor_t;
@@ -3070,6 +3385,7 @@ union cvmx_gserx_glbl_tad {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_gserx_glbl_tad_s          cn73xx;
 	struct cvmx_gserx_glbl_tad_s          cn78xx;
 };
 typedef union cvmx_gserx_glbl_tad cvmx_gserx_glbl_tad_t;
@@ -3103,6 +3419,7 @@ union cvmx_gserx_glbl_tm_admon {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_gserx_glbl_tm_admon_s     cn73xx;
 	struct cvmx_gserx_glbl_tm_admon_s     cn78xx;
 };
 typedef union cvmx_gserx_glbl_tm_admon cvmx_gserx_glbl_tm_admon_t;
@@ -3124,6 +3441,7 @@ union cvmx_gserx_iddq_mode {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_iddq_mode_s         cn73xx;
 	struct cvmx_gserx_iddq_mode_s         cn78xx;
 };
 typedef union cvmx_gserx_iddq_mode cvmx_gserx_iddq_mode_t;
@@ -3198,6 +3516,7 @@ union cvmx_gserx_lanex_lbert_cfg {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_lbert_cfg_s   cn73xx;
 	struct cvmx_gserx_lanex_lbert_cfg_s   cn78xx;
 };
 typedef union cvmx_gserx_lanex_lbert_cfg cvmx_gserx_lanex_lbert_cfg_t;
@@ -3228,6 +3547,7 @@ union cvmx_gserx_lanex_lbert_ecnt {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_lbert_ecnt_s  cn73xx;
 	struct cvmx_gserx_lanex_lbert_ecnt_s  cn78xx;
 };
 typedef union cvmx_gserx_lanex_lbert_ecnt cvmx_gserx_lanex_lbert_ecnt_t;
@@ -3251,6 +3571,7 @@ union cvmx_gserx_lanex_lbert_pat_cfg {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_lbert_pat_cfg_s cn73xx;
 	struct cvmx_gserx_lanex_lbert_pat_cfg_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_lbert_pat_cfg cvmx_gserx_lanex_lbert_pat_cfg_t;
@@ -3297,6 +3618,7 @@ union cvmx_gserx_lanex_misc_cfg_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_misc_cfg_0_s  cn73xx;
 	struct cvmx_gserx_lanex_misc_cfg_0_s  cn78xx;
 };
 typedef union cvmx_gserx_lanex_misc_cfg_0 cvmx_gserx_lanex_misc_cfg_0_t;
@@ -3335,6 +3657,7 @@ union cvmx_gserx_lanex_misc_cfg_1 {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_misc_cfg_1_s  cn73xx;
 	struct cvmx_gserx_lanex_misc_cfg_1_s  cn78xx;
 };
 typedef union cvmx_gserx_lanex_misc_cfg_1 cvmx_gserx_lanex_misc_cfg_1_t;
@@ -3386,6 +3709,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_0 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn73xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_0 cvmx_gserx_lanex_pcs_ctlifc_0_t;
@@ -3418,6 +3742,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_1 {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn73xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_1 cvmx_gserx_lanex_pcs_ctlifc_1_t;
@@ -3479,6 +3804,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn73xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_2 cvmx_gserx_lanex_pcs_ctlifc_2_t;
@@ -3503,6 +3829,7 @@ union cvmx_gserx_lanex_pma_loopback_ctrl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_pma_loopback_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pma_loopback_ctrl cvmx_gserx_lanex_pma_loopback_ctrl_t;
@@ -3580,6 +3907,7 @@ union cvmx_gserx_lanex_pwr_ctrl {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pwr_ctrl_s    cn73xx;
 	struct cvmx_gserx_lanex_pwr_ctrl_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_pwr_ctrl cvmx_gserx_lanex_pwr_ctrl_t;
@@ -3627,6 +3955,7 @@ union cvmx_gserx_lanex_pwr_ctrl_p2 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pwr_ctrl_p2_s cn73xx;
 	struct cvmx_gserx_lanex_pwr_ctrl_p2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_pwr_ctrl_p2 cvmx_gserx_lanex_pwr_ctrl_p2_t;
@@ -3650,6 +3979,7 @@ union cvmx_gserx_lanex_rx_aeq_out_0 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn73xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_0 cvmx_gserx_lanex_rx_aeq_out_0_t;
@@ -3674,6 +4004,7 @@ union cvmx_gserx_lanex_rx_aeq_out_1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_1 cvmx_gserx_lanex_rx_aeq_out_1_t;
@@ -3698,6 +4029,7 @@ union cvmx_gserx_lanex_rx_aeq_out_2 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn73xx;
 	struct cvmx_gserx_lanex_rx_aeq_out_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_aeq_out_2 cvmx_gserx_lanex_rx_aeq_out_2_t;
@@ -3726,6 +4058,7 @@ union cvmx_gserx_lanex_rx_cdr_ctrl_1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_ctrl_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_ctrl_1 cvmx_gserx_lanex_rx_cdr_ctrl_1_t;
@@ -3753,6 +4086,7 @@ union cvmx_gserx_lanex_rx_cdr_ctrl_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_ctrl_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_ctrl_2 cvmx_gserx_lanex_rx_cdr_ctrl_2_t;
@@ -3780,6 +4114,7 @@ union cvmx_gserx_lanex_rx_cdr_misc_ctrl_0 {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_misc_ctrl_0 cvmx_gserx_lanex_rx_cdr_misc_ctrl_0_t;
@@ -3805,6 +4140,7 @@ union cvmx_gserx_lanex_rx_cdr_status_1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_status_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_status_1 cvmx_gserx_lanex_rx_cdr_status_1_t;
@@ -3829,6 +4165,7 @@ union cvmx_gserx_lanex_rx_cdr_status_2 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn73xx;
 	struct cvmx_gserx_lanex_rx_cdr_status_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cdr_status_2 cvmx_gserx_lanex_rx_cdr_status_2_t;
@@ -3846,6 +4183,76 @@ union cvmx_gserx_lanex_rx_cfg_0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t rx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power State Machine data rate signal. */
+	uint64_t reserved_14_14               : 1;
+	uint64_t rx_resetn_ovvrd_val          : 1;  /**< This value overrides the RX Power State machine rx_resetn control
+                                                         signal when GSER()_LANE()_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
+	uint64_t pcs_sds_rx_eyemon_en         : 1;  /**< RX eyemon test enable. */
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;  /**< <11>: Reserved
+                                                         <10-8>:
+                                                           0x0 = 540mV.
+                                                           0x1 = 540mV + 20mV.
+                                                           0x2-0x3 = Reserved.
+                                                           0x4 = 100-620mV (default).
+                                                           0x5-0x7 = Reserved. */
+	uint64_t rx_datarate_ovrrd_val        : 2;  /**< Specifies the data rate when RX_DATARATE_OVRRD_EN is asserted:
+                                                         0x0 = Full rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate. */
+	uint64_t cfg_rx_pol_invert            : 1;  /**< Invert the receive data.  Allies with GSER()_LANE()_MISC_CFG_0[USE_PMA_POLARITY]
+                                                         is deasserted. */
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;  /**< Not supported. */
+#else
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;
+	uint64_t cfg_rx_pol_invert            : 1;
+	uint64_t rx_datarate_ovrrd_val        : 2;
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;
+	uint64_t pcs_sds_rx_eyemon_en         : 1;
+	uint64_t rx_resetn_ovvrd_val          : 1;
+	uint64_t reserved_14_14               : 1;
+	uint64_t rx_datarate_ovrrd_en         : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_cfg_0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t rx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power State Machine data rate signal. */
+	uint64_t pcs_rx_tristate_enable       : 1;  /**< RX termination high-Z enable. */
+	uint64_t rx_resetn_ovvrd_val          : 1;  /**< This value overrides the RX Power State machine rx_resetn control
+                                                         signal when GSER()_LANE()_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
+	uint64_t pcs_sds_rx_eyemon_en         : 1;  /**< RX eyemon test enable. */
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;  /**< <11>: Reserved
+                                                         <10-8>:
+                                                           0x0 = 540mV.
+                                                           0x1 = 540mV + 20mV.
+                                                           0x2-0x3 = Reserved.
+                                                           0x4 = 100-620mV (default).
+                                                           0x5-0x7 = Reserved. */
+	uint64_t rx_datarate_ovrrd_val        : 2;  /**< Specifies the data rate when RX_DATARATE_OVRRD_EN is asserted:
+                                                         0x0 = Full rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate. */
+	uint64_t cfg_rx_pol_invert            : 1;  /**< Invert the receive data.  Allies with GSER()_LANE()_MISC_CFG_0[USE_PMA_POLARITY]
+                                                         is deasserted. */
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;  /**< Not supported. */
+#else
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;
+	uint64_t cfg_rx_pol_invert            : 1;
+	uint64_t rx_datarate_ovrrd_val        : 2;
+	uint64_t pcs_sds_rx_pcm_ctrl          : 4;
+	uint64_t pcs_sds_rx_eyemon_en         : 1;
+	uint64_t rx_resetn_ovvrd_val          : 1;
+	uint64_t pcs_rx_tristate_enable       : 1;
+	uint64_t rx_datarate_ovrrd_en         : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
+	struct cvmx_gserx_lanex_rx_cfg_0_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t rx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power State Machine data rate signal. */
 	uint64_t pcs_sds_rx_tristate_enable   : 1;  /**< RX termination high-Z enable. */
 	uint64_t rx_resetn_ovvrd_val          : 1;  /**< This value overrides the RX Power State machine rx_resetn control
                                                          signal when GSER()_LANE()_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
@@ -3876,8 +4283,7 @@ union cvmx_gserx_lanex_rx_cfg_0 {
 	uint64_t rx_datarate_ovrrd_en         : 1;
 	uint64_t reserved_16_63               : 48;
 #endif
-	} s;
-	struct cvmx_gserx_lanex_rx_cfg_0_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_0 cvmx_gserx_lanex_rx_cfg_0_t;
 
@@ -3923,6 +4329,7 @@ union cvmx_gserx_lanex_rx_cfg_1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_1_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_1_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_1 cvmx_gserx_lanex_rx_cfg_1_t;
@@ -3949,11 +4356,11 @@ union cvmx_gserx_lanex_rx_cfg_2 {
 	uint64_t reserved_10_10               : 1;
 	uint64_t rx_sds_rx_agc_mval           : 10; /**< AGC manual value only used when GSERX_LANE()_RX_CFG_5[RX_AGC_MEN_OVVRD_VAL] is set.
                                                          <9:8>: Reserved.
-                                                         <7:4>: Pre-CTL gain
+                                                         <7:4>: Pre-CTLE (continuous time linear equalizer) gain:
                                                          - 0 = -6dB
                                                          - 1 = -5dB
                                                          - 3 = +5dB.
-                                                         <3:0>: Post-CTL gain (steps of 0.0875)
+                                                         <3:0>: Post-CTLE gain (steps of 0.0875):
                                                          - 0x0 = lowest
                                                          - 0xf = lowest * 2.3125. */
 #else
@@ -3965,6 +4372,7 @@ union cvmx_gserx_lanex_rx_cfg_2 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_2_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_2_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_2 cvmx_gserx_lanex_rx_cfg_2_t;
@@ -4000,6 +4408,7 @@ union cvmx_gserx_lanex_rx_cfg_3 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_3_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_3_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_3 cvmx_gserx_lanex_rx_cfg_3_t;
@@ -4035,6 +4444,7 @@ union cvmx_gserx_lanex_rx_cfg_4 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_4_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_4_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_4 cvmx_gserx_lanex_rx_cfg_4_t;
@@ -4067,6 +4477,7 @@ union cvmx_gserx_lanex_rx_cfg_5 {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_cfg_5_s    cn73xx;
 	struct cvmx_gserx_lanex_rx_cfg_5_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_cfg_5 cvmx_gserx_lanex_rx_cfg_5_t;
@@ -4113,6 +4524,7 @@ union cvmx_gserx_lanex_rx_ctle_ctrl {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_rx_ctle_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_ctle_ctrl cvmx_gserx_lanex_rx_ctle_ctrl_t;
@@ -4149,6 +4561,7 @@ union cvmx_gserx_lanex_rx_loop_ctrl {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_loop_ctrl cvmx_gserx_lanex_rx_loop_ctrl_t;
@@ -4184,6 +4597,48 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;  /**< When asserted, pcs_sds_rx_err_det_ctrl is set
                                                          to cfg_rx_errdet_ctrl in registers
                                                          GSER()_LANE()_RX_CFG_3 and GSER()_LANE()_RX_CFG_4. */
+	uint64_t reserved_1_3                 : 3;
+	uint64_t cfg_rxeq_eval_restore_en     : 1;  /**< When asserted, AGC and CTLE use the RX EQ settings determined from RX EQ
+                                                         evaluation process when VMA is not in manual mode. Otherwise, default settings are used. */
+#else
+	uint64_t cfg_rxeq_eval_restore_en     : 1;
+	uint64_t reserved_1_3                 : 3;
+	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;
+	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;
+	uint64_t reserved_6_6                 : 1;
+	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;
+	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;
+	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;
+	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_en   : 1;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn73xx;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;  /**< Not supported. */
+	uint64_t cfg_rx_oob_clk_en_ovrrd_en   : 1;  /**< Not supported. */
+	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;  /**< Override value for RX Electrical-Idle-Exit
+                                                         Detect Enable. */
+	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;  /**< Override enable for RX Electrical-Idle-Exit
+                                                         Detect Enable. */
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;  /**< Not supported. */
+	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;  /**< Training mode control in override mode. */
+	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;  /**< Override enable for RX-EQ Eval
+                                                         When asserted, training mode is controlled by
+                                                         CFG_RX_EQ_EVAL_OVRRD_VAL. */
+	uint64_t reserved_6_6                 : 1;
+	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;  /**< When asserted, override DLL lock enable
+                                                         signal from the RX Power State machine with
+                                                         CFG_RX_DLL_LOCKEN in register
+                                                         GSER()_LANE()_RX_CFG_1. */
+	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;  /**< When asserted, pcs_sds_rx_err_det_ctrl is set
+                                                         to cfg_rx_errdet_ctrl in registers
+                                                         GSER()_LANE()_RX_CFG_3 and GSER()_LANE()_RX_CFG_4. */
 	uint64_t reserved_0_3                 : 4;
 #else
 	uint64_t reserved_0_3                 : 4;
@@ -4199,8 +4654,7 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;
 	uint64_t reserved_14_63               : 50;
 #endif
-	} s;
-	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_misc_ovrrd cvmx_gserx_lanex_rx_misc_ovrrd_t;
 
@@ -4233,6 +4687,7 @@ union cvmx_gserx_lanex_rx_precorr_ctrl {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_rx_precorr_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_precorr_ctrl cvmx_gserx_lanex_rx_precorr_ctrl_t;
@@ -4258,6 +4713,7 @@ union cvmx_gserx_lanex_rx_precorr_val {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_precorr_val_s cn73xx;
 	struct cvmx_gserx_lanex_rx_precorr_val_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_precorr_val cvmx_gserx_lanex_rx_precorr_val_t;
@@ -4293,6 +4749,7 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_0 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s cn73xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_0 cvmx_gserx_lanex_rx_valbbd_ctrl_0_t;
@@ -4335,6 +4792,7 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_1 cvmx_gserx_lanex_rx_valbbd_ctrl_1_t;
@@ -4386,6 +4844,7 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_2 {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s cn73xx;
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_2_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_2 cvmx_gserx_lanex_rx_valbbd_ctrl_2_t;
@@ -4426,6 +4885,7 @@ union cvmx_gserx_lanex_rx_vma_ctrl {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn73xx;
 	struct cvmx_gserx_lanex_rx_vma_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_vma_ctrl cvmx_gserx_lanex_rx_vma_ctrl_t;
@@ -4451,6 +4911,7 @@ union cvmx_gserx_lanex_rx_vma_status_0 {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_vma_status_0_s cn73xx;
 	struct cvmx_gserx_lanex_rx_vma_status_0_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_vma_status_0 cvmx_gserx_lanex_rx_vma_status_0_t;
@@ -4468,10 +4929,10 @@ union cvmx_gserx_lanex_rx_vma_status_1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t sds_pcs_rx_vma_status        : 16; /**< <15:8>: Output is controlled by GSER()_LANE()_RX_CFG_3[CFG_RX_ERRDET_CTRL[6:5]
-                                                         0x0 = Pre-CTL gain, CTLE Peak.
-                                                         0x1 = CTL pole, SDLL_IQ.
-                                                         0x2 = Window counter[11:3].
-                                                         0x3 = Window counter[19:12] (VMA RAW FOM).
+                                                         0x0 = Window counter[19:12] (VMA RAW FOM).
+                                                         0x1 = Window counter[11:4].
+                                                         0x2 = CTLE (continous time linear equalizer) pole, SDLL_IQ.
+                                                         0x3 = Pre-CTLE gain, CTLE Peak.
                                                          <7>: Training done
                                                          <6>: Internal state machine training done
                                                          <5:3>: Internal state machine Delta
@@ -4481,11 +4942,133 @@ union cvmx_gserx_lanex_rx_vma_status_1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_rx_vma_status_1_s cn73xx;
 	struct cvmx_gserx_lanex_rx_vma_status_1_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_rx_vma_status_1 cvmx_gserx_lanex_rx_vma_status_1_t;
 
 /**
+ * cvmx_gser#_lane#_sds_pin_mon_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_sds_pin_mon_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_sds_pin_mon_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t pcs_sds_tx_widthsel          : 2;  /**< TX parallel interface width settings (RAW PCS to
+                                                         SerDes TX).
+                                                         0x0 = 8-bit raw data (not supported).
+                                                         0x1 = 10-bit raw data (not supported).
+                                                         0x2 = 16-bit raw data (not supported).
+                                                         0x3 = 20-bit raw data. */
+	uint64_t pcs_sds_rx_pcie_mode         : 1;  /**< Selects between RX terminations:
+                                                         0x0 = pcs_sds_rx_terminate_to_vdda.
+                                                         0x1 = VSS. */
+	uint64_t reserved_5_6                 : 2;
+	uint64_t pcs_sds_rx_misc_ctrl_5       : 1;  /**< Not Used. */
+	uint64_t tx_detrx_state               : 2;  /**< RX detection state:
+                                                         0x0 = IDLE.
+                                                         0x1 = Charge Up.
+                                                         0x2 = Detection.
+                                                         0x3 = Restore common mode. */
+	uint64_t pcs_sds_tx_rx_detect_dis     : 1;  /**< TX detect RX, mode disable. */
+	uint64_t pcs_sds_tx_detect_pulsen     : 1;  /**< TX detect RX, pulse enable. */
+#else
+	uint64_t pcs_sds_tx_detect_pulsen     : 1;
+	uint64_t pcs_sds_tx_rx_detect_dis     : 1;
+	uint64_t tx_detrx_state               : 2;
+	uint64_t pcs_sds_rx_misc_ctrl_5       : 1;
+	uint64_t reserved_5_6                 : 2;
+	uint64_t pcs_sds_rx_pcie_mode         : 1;
+	uint64_t pcs_sds_tx_widthsel          : 2;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_sds_pin_mon_0_s cn73xx;
+};
+typedef union cvmx_gserx_lanex_sds_pin_mon_0 cvmx_gserx_lanex_sds_pin_mon_0_t;
+
+/**
+ * cvmx_gser#_lane#_sds_pin_mon_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_sds_pin_mon_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_sds_pin_mon_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_rx_chpd              : 1;  /**< RX channel powerdown signal. */
+	uint64_t pcs_sds_rx_eie_en            : 1;  /**< Enable for electrical idle detection circuit
+                                                         in SerDes RX. */
+	uint64_t reserved_13_13               : 1;
+	uint64_t pcs_sds_ln_loopback_mode     : 1;  /**< TX to RX on chip loopback control signal. */
+	uint64_t pcs_sds_tx_chpd              : 1;  /**< TX channel powerdown signal. */
+	uint64_t pcs_sds_rx_widthsel          : 2;  /**< Width select.
+                                                         0x0 = 8-bit raw data.
+                                                         0x1 = 10-bit raw data.
+                                                         0x2 = 16-bit raw data.
+                                                         0x3 = 20-bit raw data. */
+	uint64_t reserved_8_8                 : 1;
+	uint64_t pcs_sds_tx_resetn            : 1;  /**< TX reset, active low (RAW PCS output to lane TX). */
+	uint64_t pcs_sds_tx_tristate_en       : 1;  /**< TX driver tristate enable (RAW PCS output to lane TX). */
+	uint64_t pcs_sds_tx_swing             : 5;  /**< TX swing (RAW PCS output to lane TX). */
+	uint64_t pcs_sds_tx_elec_idle         : 1;  /**< TX electrical idle control (RAW PCS output to lane TX). */
+#else
+	uint64_t pcs_sds_tx_elec_idle         : 1;
+	uint64_t pcs_sds_tx_swing             : 5;
+	uint64_t pcs_sds_tx_tristate_en       : 1;
+	uint64_t pcs_sds_tx_resetn            : 1;
+	uint64_t reserved_8_8                 : 1;
+	uint64_t pcs_sds_rx_widthsel          : 2;
+	uint64_t pcs_sds_tx_chpd              : 1;
+	uint64_t pcs_sds_ln_loopback_mode     : 1;
+	uint64_t reserved_13_13               : 1;
+	uint64_t pcs_sds_rx_eie_en            : 1;
+	uint64_t pcs_sds_rx_chpd              : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_sds_pin_mon_1_s cn73xx;
+};
+typedef union cvmx_gserx_lanex_sds_pin_mon_1 cvmx_gserx_lanex_sds_pin_mon_1_t;
+
+/**
+ * cvmx_gser#_lane#_sds_pin_mon_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_sds_pin_mon_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_sds_pin_mon_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_11_63               : 53;
+	uint64_t pcs_sds_tx_vboost_en         : 1;  /**< TX boost enable. */
+	uint64_t pcs_sds_tx_turbos_en         : 1;  /**< TX turbo mode enable signal, increases swing of TX
+                                                         through current mode. */
+	uint64_t pcs_sds_premptap             : 9;  /**< Pre-emphasis control.
+                                                         <8:4> = Post-cursor.
+                                                         <3:0> = Pre-cursor. */
+#else
+	uint64_t pcs_sds_premptap             : 9;
+	uint64_t pcs_sds_tx_turbos_en         : 1;
+	uint64_t pcs_sds_tx_vboost_en         : 1;
+	uint64_t reserved_11_63               : 53;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_sds_pin_mon_2_s cn73xx;
+};
+typedef union cvmx_gserx_lanex_sds_pin_mon_2 cvmx_gserx_lanex_sds_pin_mon_2_t;
+
+/**
  * cvmx_gser#_lane#_tx_cfg_0
  *
  * These registers are for diagnostic use only. These registers are reset by hardware only during
@@ -4521,6 +5104,7 @@ union cvmx_gserx_lanex_tx_cfg_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_cfg_0_s    cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_0_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_0 cvmx_gserx_lanex_tx_cfg_0_t;
@@ -4582,6 +5166,7 @@ union cvmx_gserx_lanex_tx_cfg_1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_cfg_1_s    cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_1_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_1 cvmx_gserx_lanex_tx_cfg_1_t;
@@ -4613,6 +5198,7 @@ union cvmx_gserx_lanex_tx_cfg_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_cfg_2_s    cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_2_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_2 cvmx_gserx_lanex_tx_cfg_2_t;
@@ -4644,6 +5230,7 @@ union cvmx_gserx_lanex_tx_cfg_3 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_cfg_3_s    cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_3_s    cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_3 cvmx_gserx_lanex_tx_cfg_3_t;
@@ -4669,6 +5256,7 @@ union cvmx_gserx_lanex_tx_pre_emphasis {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn73xx;
 	struct cvmx_gserx_lanex_tx_pre_emphasis_s cn78xx;
 };
 typedef union cvmx_gserx_lanex_tx_pre_emphasis cvmx_gserx_lanex_tx_pre_emphasis_t;
@@ -4695,6 +5283,7 @@ union cvmx_gserx_lane_lpbken {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_lane_lpbken_s       cn73xx;
 	struct cvmx_gserx_lane_lpbken_s       cn78xx;
 };
 typedef union cvmx_gserx_lane_lpbken cvmx_gserx_lane_lpbken_t;
@@ -4718,14 +5307,10 @@ union cvmx_gserx_lane_mode {
                                                          0x2: R_8G_REFCLK100.
                                                          0x3: R_125G_REFCLK15625_KX (not supported).
                                                          0x4: R_3125G_REFCLK15625_XAUI.
-                                                         For XAUI applications:
                                                          0x5: R_103125G_REFCLK15625_KR.
-                                                         For XFI, XLAUI, KR applications:
                                                          0x6: R_125G_REFCLK15625_SGMII.
-                                                         For SGMII applications:
                                                          0x7: R_5G_REFCLK15625_QSGMII (not supported).
                                                          0x8: R_625G_REFCLK15625_RXAUI.
-                                                         For RXAUI, DXAUI applications:
                                                          0x9: R_25G_REFCLK125.
                                                          0xA: R_5G_REFCLK125.
                                                          0xB: R_8G_REFCLK125.
@@ -4751,6 +5336,7 @@ union cvmx_gserx_lane_mode {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_lane_mode_s         cn73xx;
 	struct cvmx_gserx_lane_mode_s         cn78xx;
 };
 typedef union cvmx_gserx_lane_mode cvmx_gserx_lane_mode_t;
@@ -4871,6 +5457,7 @@ union cvmx_gserx_lane_px_mode_0 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_gserx_lane_px_mode_0_s    cn73xx;
 	struct cvmx_gserx_lane_px_mode_0_s    cn78xx;
 };
 typedef union cvmx_gserx_lane_px_mode_0 cvmx_gserx_lane_px_mode_0_t;
@@ -4932,6 +5519,7 @@ union cvmx_gserx_lane_px_mode_1 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lane_px_mode_1_s    cn73xx;
 	struct cvmx_gserx_lane_px_mode_1_s    cn78xx;
 };
 typedef union cvmx_gserx_lane_px_mode_1 cvmx_gserx_lane_px_mode_1_t;
@@ -4958,6 +5546,7 @@ union cvmx_gserx_lane_poff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_lane_poff_s         cn73xx;
 	struct cvmx_gserx_lane_poff_s         cn78xx;
 };
 typedef union cvmx_gserx_lane_poff cvmx_gserx_lane_poff_t;
@@ -4983,6 +5572,7 @@ union cvmx_gserx_lane_srst {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_lane_srst_s         cn73xx;
 	struct cvmx_gserx_lane_srst_s         cn78xx;
 };
 typedef union cvmx_gserx_lane_srst cvmx_gserx_lane_srst_t;
@@ -5014,6 +5604,7 @@ union cvmx_gserx_lane_vma_coarse_ctrl_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn73xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_0_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_0 cvmx_gserx_lane_vma_coarse_ctrl_0_t;
@@ -5040,6 +5631,7 @@ union cvmx_gserx_lane_vma_coarse_ctrl_1 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn73xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_1_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_1 cvmx_gserx_lane_vma_coarse_ctrl_1_t;
@@ -5066,6 +5658,7 @@ union cvmx_gserx_lane_vma_coarse_ctrl_2 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn73xx;
 	struct cvmx_gserx_lane_vma_coarse_ctrl_2_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_coarse_ctrl_2 cvmx_gserx_lane_vma_coarse_ctrl_2_t;
@@ -5106,6 +5699,7 @@ union cvmx_gserx_lane_vma_fine_ctrl_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn73xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_0_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_0 cvmx_gserx_lane_vma_fine_ctrl_0_t;
@@ -5135,6 +5729,7 @@ union cvmx_gserx_lane_vma_fine_ctrl_1 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn73xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_1_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_1 cvmx_gserx_lane_vma_fine_ctrl_1_t;
@@ -5164,6 +5759,7 @@ union cvmx_gserx_lane_vma_fine_ctrl_2 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn73xx;
 	struct cvmx_gserx_lane_vma_fine_ctrl_2_s cn78xx;
 };
 typedef union cvmx_gserx_lane_vma_fine_ctrl_2 cvmx_gserx_lane_vma_fine_ctrl_2_t;
@@ -6308,6 +6904,7 @@ union cvmx_gserx_phy_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_gserx_phy_ctl_s           cn73xx;
 	struct cvmx_gserx_phy_ctl_s           cn78xx;
 };
 typedef union cvmx_gserx_phy_ctl cvmx_gserx_phy_ctl_t;
@@ -6328,6 +6925,7 @@ union cvmx_gserx_pipe_lpbk {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_pipe_lpbk_s         cn73xx;
 	struct cvmx_gserx_pipe_lpbk_s         cn78xx;
 };
 typedef union cvmx_gserx_pipe_lpbk cvmx_gserx_pipe_lpbk_t;
@@ -6390,6 +6988,7 @@ union cvmx_gserx_pll_px_mode_0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_pll_px_mode_0_s     cn73xx;
 	struct cvmx_gserx_pll_px_mode_0_s     cn78xx;
 };
 typedef union cvmx_gserx_pll_px_mode_0 cvmx_gserx_pll_px_mode_0_t;
@@ -6463,6 +7062,7 @@ union cvmx_gserx_pll_px_mode_1 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_pll_px_mode_1_s     cn73xx;
 	struct cvmx_gserx_pll_px_mode_1_s     cn78xx;
 };
 typedef union cvmx_gserx_pll_px_mode_1 cvmx_gserx_pll_px_mode_1_t;
@@ -6481,6 +7081,7 @@ union cvmx_gserx_pll_stat {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_pll_stat_s          cn73xx;
 	struct cvmx_gserx_pll_stat_s          cn78xx;
 };
 typedef union cvmx_gserx_pll_stat cvmx_gserx_pll_stat_t;
@@ -6502,6 +7103,7 @@ union cvmx_gserx_qlm_stat {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_gserx_qlm_stat_s          cn73xx;
 	struct cvmx_gserx_qlm_stat_s          cn78xx;
 };
 typedef union cvmx_gserx_qlm_stat cvmx_gserx_qlm_stat_t;
@@ -6530,11 +7132,57 @@ union cvmx_gserx_rdet_time {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_rdet_time_s         cn73xx;
 	struct cvmx_gserx_rdet_time_s         cn78xx;
 };
 typedef union cvmx_gserx_rdet_time cvmx_gserx_rdet_time_t;
 
 /**
+ * cvmx_gser#_refclk_evt_cntr
+ */
+union cvmx_gserx_refclk_evt_cntr {
+	uint64_t u64;
+	struct cvmx_gserx_refclk_evt_cntr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t count                        : 32; /**< This register can only be reliably read when GSER()_REFCLK_EVT_CTRL[ENB]
+                                                         is clear.
+                                                         When GSER()_REFCLK_EVT_CTRL[CLR] is set, [COUNT] goes to zero.
+                                                         When GSER()_REFCLK_EVT_CTRL[ENB] is set, [COUNT] is incremented
+                                                         in positve edges of the QLM reference clock.
+                                                         When GSER()_REFCLK_EVT_CTRL[ENB] is not set, [COUNT] is held; this must
+                                                         be used when [COUNT] is being read for reliable results. */
+#else
+	uint64_t count                        : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gserx_refclk_evt_cntr_s   cn73xx;
+};
+typedef union cvmx_gserx_refclk_evt_cntr cvmx_gserx_refclk_evt_cntr_t;
+
+/**
+ * cvmx_gser#_refclk_evt_ctrl
+ */
+union cvmx_gserx_refclk_evt_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_refclk_evt_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t clr                          : 1;  /**< When set, clears GSER()_REFCLK_EVT_CNTR[COUNT]. */
+	uint64_t enb                          : 1;  /**< When set, enables the GSER()_REFCLK_EVT_CNTR[COUNT] to increment
+                                                         on positive edges of the QLM reference clock. */
+#else
+	uint64_t enb                          : 1;
+	uint64_t clr                          : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_gserx_refclk_evt_ctrl_s   cn73xx;
+};
+typedef union cvmx_gserx_refclk_evt_ctrl cvmx_gserx_refclk_evt_ctrl_t;
+
+/**
  * cvmx_gser#_refclk_sel
  *
  * This register selects the reference clock.
@@ -6562,6 +7210,7 @@ union cvmx_gserx_refclk_sel {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_gserx_refclk_sel_s        cn73xx;
 	struct cvmx_gserx_refclk_sel_s        cn78xx;
 };
 typedef union cvmx_gserx_refclk_sel cvmx_gserx_refclk_sel_t;
@@ -6592,6 +7241,7 @@ union cvmx_gserx_rx_coast {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_rx_coast_s          cn73xx;
 	struct cvmx_gserx_rx_coast_s          cn78xx;
 };
 typedef union cvmx_gserx_rx_coast cvmx_gserx_rx_coast_t;
@@ -6621,6 +7271,7 @@ union cvmx_gserx_rx_eie_deten {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_rx_eie_deten_s      cn73xx;
 	struct cvmx_gserx_rx_eie_deten_s      cn78xx;
 };
 typedef union cvmx_gserx_rx_eie_deten cvmx_gserx_rx_eie_deten_t;
@@ -6668,6 +7319,7 @@ union cvmx_gserx_rx_eie_detsts {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_gserx_rx_eie_detsts_s     cn73xx;
 	struct cvmx_gserx_rx_eie_detsts_s     cn78xx;
 };
 typedef union cvmx_gserx_rx_eie_detsts cvmx_gserx_rx_eie_detsts_t;
@@ -6702,6 +7354,7 @@ union cvmx_gserx_rx_eie_filter {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_rx_eie_filter_s     cn73xx;
 	struct cvmx_gserx_rx_eie_filter_s     cn78xx;
 };
 typedef union cvmx_gserx_rx_eie_filter cvmx_gserx_rx_eie_filter_t;
@@ -6729,6 +7382,7 @@ union cvmx_gserx_rx_polarity {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_rx_polarity_s       cn73xx;
 	struct cvmx_gserx_rx_polarity_s       cn78xx;
 };
 typedef union cvmx_gserx_rx_polarity cvmx_gserx_rx_polarity_t;
@@ -6776,6 +7430,7 @@ union cvmx_gserx_rx_pwr_ctrl_p1 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn73xx;
 	struct cvmx_gserx_rx_pwr_ctrl_p1_s    cn78xx;
 };
 typedef union cvmx_gserx_rx_pwr_ctrl_p1 cvmx_gserx_rx_pwr_ctrl_p1_t;
@@ -6803,6 +7458,59 @@ union cvmx_gserx_sata_cfg {
 typedef union cvmx_gserx_sata_cfg cvmx_gserx_sata_cfg_t;
 
 /**
+ * cvmx_gser#_sata_lane#_tx_amp#
+ *
+ * SATA lane TX launch amplitude at Gen 1, 2 and 3 speeds.
+ * * AMP(0) is for Gen1.
+ * * AMP(1) is for Gen2.
+ * * AMP(2) is for Gen3.
+ */
+union cvmx_gserx_sata_lanex_tx_ampx {
+	uint64_t u64;
+	struct cvmx_gserx_sata_lanex_tx_ampx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t tx_amp_gen                   : 7;  /**< This status value sets the Tx driver launch amplitude in the
+                                                         case where the PHY is running at the Gen1, Gen2, and Gen3
+                                                         rates. Used for tuning at the board level for Rx eye compliance.
+                                                         This register is unused for GSER(0..4). */
+#else
+	uint64_t tx_amp_gen                   : 7;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} s;
+	struct cvmx_gserx_sata_lanex_tx_ampx_s cn73xx;
+};
+typedef union cvmx_gserx_sata_lanex_tx_ampx cvmx_gserx_sata_lanex_tx_ampx_t;
+
+/**
+ * cvmx_gser#_sata_lane#_tx_preemph#
+ *
+ * SATA TX pre-emphasis at Gen 1, 2 and 3 speeds. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
+ * * PREEMPH(0) is for Gen1.
+ * * PREEMPH(1) is for Gen2.
+ * * PREEMPH(2) is for Gen3.
+ */
+union cvmx_gserx_sata_lanex_tx_preemphx {
+	uint64_t u64;
+	struct cvmx_gserx_sata_lanex_tx_preemphx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t tx_preemph                   : 7;  /**< This static value sets the Tx driver de-emphasis value in the
+                                                         case where the PHY is running at the Gen1, Gen2, and Gen3
+                                                         rates. Used for tuning at the board level for Rx eye compliance.
+                                                         This register is unused for GSER(0..4). */
+#else
+	uint64_t tx_preemph                   : 7;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} s;
+	struct cvmx_gserx_sata_lanex_tx_preemphx_s cn73xx;
+};
+typedef union cvmx_gserx_sata_lanex_tx_preemphx cvmx_gserx_sata_lanex_tx_preemphx_t;
+
+/**
  * cvmx_gser#_sata_lane_rst
  *
  * Lane Reset Control.
@@ -6813,8 +7521,10 @@ union cvmx_gserx_sata_lane_rst {
 	struct cvmx_gserx_sata_lane_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t l1_rst                       : 1;  /**< Independent reset for Lane 1. */
-	uint64_t l0_rst                       : 1;  /**< Independent reset for Lane 0. */
+	uint64_t l1_rst                       : 1;  /**< Independent reset for lane 1.
+                                                         This register is unused for GSER(0..4). */
+	uint64_t l0_rst                       : 1;  /**< Independent reset for lane 0.
+                                                         This register is unused for GSER(0..4). */
 #else
 	uint64_t l0_rst                       : 1;
 	uint64_t l1_rst                       : 1;
@@ -6823,6 +7533,7 @@ union cvmx_gserx_sata_lane_rst {
 	} s;
 	struct cvmx_gserx_sata_lane_rst_s     cn70xx;
 	struct cvmx_gserx_sata_lane_rst_s     cn70xxp1;
+	struct cvmx_gserx_sata_lane_rst_s     cn73xx;
 };
 typedef union cvmx_gserx_sata_lane_rst cvmx_gserx_sata_lane_rst_t;
 
@@ -7067,7 +7778,8 @@ union cvmx_gserx_sata_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t p1_rdy                       : 1;  /**< PHY Lane 1 is ready to send and receive data. */
-	uint64_t p0_rdy                       : 1;  /**< PHY Lane 0 is ready to send and receive data. */
+	uint64_t p0_rdy                       : 1;  /**< PHY Lane 0 is ready to send and receive data.
+                                                         This register is unused for GSER(0..4). */
 #else
 	uint64_t p0_rdy                       : 1;
 	uint64_t p1_rdy                       : 1;
@@ -7076,19 +7788,27 @@ union cvmx_gserx_sata_status {
 	} s;
 	struct cvmx_gserx_sata_status_s       cn70xx;
 	struct cvmx_gserx_sata_status_s       cn70xxp1;
+	struct cvmx_gserx_sata_status_s       cn73xx;
 };
 typedef union cvmx_gserx_sata_status cvmx_gserx_sata_status_t;
 
 /**
  * cvmx_gser#_sata_tx_invert
  *
- * SATA Transmit Polarity Inversion.
+ * TX Lane Data Invert Control.
  *
  */
 union cvmx_gserx_sata_tx_invert {
 	uint64_t u64;
 	struct cvmx_gserx_sata_tx_invert_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} s;
+	struct cvmx_gserx_sata_tx_invert_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t tx1_invert                   : 1;  /**< Instructs the PHY to perform a polarity inversion on the Lane 1
                                                           transmitted data.
@@ -7103,9 +7823,23 @@ union cvmx_gserx_sata_tx_invert {
 	uint64_t tx1_invert                   : 1;
 	uint64_t reserved_2_63                : 62;
 #endif
-	} s;
-	struct cvmx_gserx_sata_tx_invert_s    cn70xx;
-	struct cvmx_gserx_sata_tx_invert_s    cn70xxp1;
+	} cn70xx;
+	struct cvmx_gserx_sata_tx_invert_cn70xx cn70xxp1;
+	struct cvmx_gserx_sata_tx_invert_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t l1_inv                       : 1;  /**< Instructs the SATA PCS to perform a polarity inversion on the
+                                                         lane 1 transmitted data.
+                                                         This register is unused for GSER(0..4). */
+	uint64_t l0_inv                       : 1;  /**< Instructs the SATA PCS to perform a polarity inversion on the
+                                                         lane 0 transmitted data.
+                                                         This register is unused for GSER(0..4). */
+#else
+	uint64_t l0_inv                       : 1;
+	uint64_t l1_inv                       : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_gserx_sata_tx_invert cvmx_gserx_sata_tx_invert_t;
 
@@ -7126,6 +7860,7 @@ union cvmx_gserx_scratch {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_scratch_s           cn73xx;
 	struct cvmx_gserx_scratch_s           cn78xx;
 };
 typedef union cvmx_gserx_scratch cvmx_gserx_scratch_t;
@@ -7162,6 +7897,7 @@ union cvmx_gserx_slicex_rx_sdll_ctrl {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn73xx;
 	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn78xx;
 };
 typedef union cvmx_gserx_slicex_rx_sdll_ctrl cvmx_gserx_slicex_rx_sdll_ctrl_t;
@@ -7194,6 +7930,7 @@ union cvmx_gserx_slice_cfg {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_gserx_slice_cfg_s         cn73xx;
 	struct cvmx_gserx_slice_cfg_s         cn78xx;
 };
 typedef union cvmx_gserx_slice_cfg cvmx_gserx_slice_cfg_t;
@@ -7251,6 +7988,13 @@ union cvmx_gserx_spd {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_spd_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} cn73xx;
 	struct cvmx_gserx_spd_s               cn78xx;
 };
 typedef union cvmx_gserx_spd cvmx_gserx_spd_t;
@@ -7273,6 +8017,7 @@ union cvmx_gserx_srst {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_gserx_srst_s              cn73xx;
 	struct cvmx_gserx_srst_s              cn78xx;
 };
 typedef union cvmx_gserx_srst cvmx_gserx_srst_t;
@@ -7299,8 +8044,54 @@ union cvmx_gserx_tx_vboost {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_gserx_tx_vboost_s         cn73xx;
 	struct cvmx_gserx_tx_vboost_s         cn78xx;
 };
 typedef union cvmx_gserx_tx_vboost cvmx_gserx_tx_vboost_t;
 
+/**
+ * cvmx_gser#_txclk_evt_cntr
+ */
+union cvmx_gserx_txclk_evt_cntr {
+	uint64_t u64;
+	struct cvmx_gserx_txclk_evt_cntr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t count                        : 32; /**< This register can only be reliably read when GSER()_TXCLK_EVT_CTRL[ENB]
+                                                         is clear.
+                                                         When GSER()_TXCLK_EVT_CTRL[CLR] is set, [COUNT] goes to zero.
+                                                         When GSER()_TXCLK_EVT_CTRL[ENB] is set, [COUNT] is incremented
+                                                         in positve edges of the QLM reference clock.
+                                                         When GSER()_TXCLK_EVT_CTRL[ENB] is not set, [COUNT] value is held;
+                                                         this must be used when [COUNT] is being read for reliable results. */
+#else
+	uint64_t count                        : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_gserx_txclk_evt_cntr_s    cn73xx;
+};
+typedef union cvmx_gserx_txclk_evt_cntr cvmx_gserx_txclk_evt_cntr_t;
+
+/**
+ * cvmx_gser#_txclk_evt_ctrl
+ */
+union cvmx_gserx_txclk_evt_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_txclk_evt_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t clr                          : 1;  /**< When set, clears GSER()_TXCLK_EVT_CNTR[COUNT]. */
+	uint64_t enb                          : 1;  /**< When set, enables the GSER()_TXCLK_EVT_CNTR[COUNT] to increment
+                                                         on positive edges of the QLM reference clock. */
+#else
+	uint64_t enb                          : 1;
+	uint64_t clr                          : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_gserx_txclk_evt_ctrl_s    cn73xx;
+};
+typedef union cvmx_gserx_txclk_evt_ctrl cvmx_gserx_txclk_evt_ctrl_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
index 71422b9e..8daae81 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -355,7 +355,7 @@ extern int cvmx_helper_cfg_ipd2pko_port_num(int ipd_port);
  * @INTERNAL
  * The init function
  *
- * @param none
+ * @param node
  * @return 0 for success.
  *
  * Note: this function is meant to be called to set the ``configured
@@ -363,7 +363,7 @@ extern int cvmx_helper_cfg_ipd2pko_port_num(int ipd_port);
  * any of the corresponding cvmx_helper_cfg_xxxx() functions are
  * called.
  */
-extern int __cvmx_helper_init_port_config_data(void);
+extern int __cvmx_helper_init_port_config_data(int node);
 
 /*
  * @INTERNAL
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index c6bdd88..5f156d8 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_HNA_BIST0 CVMX_HNA_BIST0_FUNC()
 static inline uint64_t CVMX_HNA_BIST0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_BIST0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470007F0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_HNA_BIST0_FUNC(void)
 #define CVMX_HNA_BIST1 CVMX_HNA_BIST1_FUNC()
 static inline uint64_t CVMX_HNA_BIST1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_BIST1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470007F8ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_HNA_BIST1_FUNC(void)
 #define CVMX_HNA_CONFIG CVMX_HNA_CONFIG_FUNC()
 static inline uint64_t CVMX_HNA_CONFIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_CONFIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000000ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_HNA_CONFIG_FUNC(void)
 #define CVMX_HNA_CONTROL CVMX_HNA_CONTROL_FUNC()
 static inline uint64_t CVMX_HNA_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000020ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_HNA_CONTROL_FUNC(void)
 #define CVMX_HNA_DBELL CVMX_HNA_DBELL_FUNC()
 static inline uint64_t CVMX_HNA_DBELL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_DBELL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470000000000ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_HNA_DBELL_FUNC(void)
 #define CVMX_HNA_DIFCTL CVMX_HNA_DIFCTL_FUNC()
 static inline uint64_t CVMX_HNA_DIFCTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_DIFCTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470600000000ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_HNA_DIFCTL_FUNC(void)
 #define CVMX_HNA_DIFRDPTR CVMX_HNA_DIFRDPTR_FUNC()
 static inline uint64_t CVMX_HNA_DIFRDPTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_DIFRDPTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470200000000ull);
 }
@@ -133,7 +133,7 @@ static inline uint64_t CVMX_HNA_DIFRDPTR_FUNC(void)
 #define CVMX_HNA_ERROR CVMX_HNA_ERROR_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_ERROR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000028ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 #define CVMX_HNA_ERROR_CAPTURE_DATA CVMX_HNA_ERROR_CAPTURE_DATA_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_CAPTURE_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_ERROR_CAPTURE_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000038ull);
 }
@@ -155,7 +155,7 @@ static inline uint64_t CVMX_HNA_ERROR_CAPTURE_DATA_FUNC(void)
 #define CVMX_HNA_ERROR_CAPTURE_INFO CVMX_HNA_ERROR_CAPTURE_INFO_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_CAPTURE_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_ERROR_CAPTURE_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000030ull);
 }
@@ -166,6 +166,7 @@ static inline uint64_t CVMX_HNA_ERROR_CAPTURE_INFO_FUNC(void)
 static inline uint64_t CVMX_HNA_HNC0_RAM1X(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC0_RAM1X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400000000ull) + ((offset) & 63) * 8;
@@ -177,6 +178,7 @@ static inline uint64_t CVMX_HNA_HNC0_RAM1X(unsigned long offset)
 static inline uint64_t CVMX_HNA_HNC0_RAM2X(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC0_RAM2X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400040000ull) + ((offset) & 63) * 8;
@@ -188,6 +190,7 @@ static inline uint64_t CVMX_HNA_HNC0_RAM2X(unsigned long offset)
 static inline uint64_t CVMX_HNA_HNC1_RAM1X(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC1_RAM1X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400400000ull) + ((offset) & 63) * 8;
@@ -199,6 +202,7 @@ static inline uint64_t CVMX_HNA_HNC1_RAM1X(unsigned long offset)
 static inline uint64_t CVMX_HNA_HNC1_RAM2X(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC1_RAM2X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400440000ull) + ((offset) & 63) * 8;
@@ -210,7 +214,7 @@ static inline uint64_t CVMX_HNA_HNC1_RAM2X(unsigned long offset)
 #define CVMX_HNA_HPU_CSR CVMX_HNA_HPU_CSR_FUNC()
 static inline uint64_t CVMX_HNA_HPU_CSR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_HPU_CSR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000010ull);
 }
@@ -221,7 +225,7 @@ static inline uint64_t CVMX_HNA_HPU_CSR_FUNC(void)
 #define CVMX_HNA_HPU_DBG CVMX_HNA_HPU_DBG_FUNC()
 static inline uint64_t CVMX_HNA_HPU_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_HPU_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000008ull);
 }
@@ -232,7 +236,7 @@ static inline uint64_t CVMX_HNA_HPU_DBG_FUNC(void)
 #define CVMX_HNA_HPU_EIR CVMX_HNA_HPU_EIR_FUNC()
 static inline uint64_t CVMX_HNA_HPU_EIR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_HPU_EIR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000018ull);
 }
@@ -243,7 +247,7 @@ static inline uint64_t CVMX_HNA_HPU_EIR_FUNC(void)
 #define CVMX_HNA_PFC0_CNT CVMX_HNA_PFC0_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC0_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC0_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000090ull);
 }
@@ -254,7 +258,7 @@ static inline uint64_t CVMX_HNA_PFC0_CNT_FUNC(void)
 #define CVMX_HNA_PFC0_CTL CVMX_HNA_PFC0_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC0_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC0_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000088ull);
 }
@@ -265,7 +269,7 @@ static inline uint64_t CVMX_HNA_PFC0_CTL_FUNC(void)
 #define CVMX_HNA_PFC1_CNT CVMX_HNA_PFC1_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC1_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC1_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000A0ull);
 }
@@ -276,7 +280,7 @@ static inline uint64_t CVMX_HNA_PFC1_CNT_FUNC(void)
 #define CVMX_HNA_PFC1_CTL CVMX_HNA_PFC1_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC1_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC1_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000098ull);
 }
@@ -287,7 +291,7 @@ static inline uint64_t CVMX_HNA_PFC1_CTL_FUNC(void)
 #define CVMX_HNA_PFC2_CNT CVMX_HNA_PFC2_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC2_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC2_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000B0ull);
 }
@@ -298,7 +302,7 @@ static inline uint64_t CVMX_HNA_PFC2_CNT_FUNC(void)
 #define CVMX_HNA_PFC2_CTL CVMX_HNA_PFC2_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC2_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC2_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000A8ull);
 }
@@ -309,7 +313,7 @@ static inline uint64_t CVMX_HNA_PFC2_CTL_FUNC(void)
 #define CVMX_HNA_PFC3_CNT CVMX_HNA_PFC3_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC3_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC3_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000C0ull);
 }
@@ -320,7 +324,7 @@ static inline uint64_t CVMX_HNA_PFC3_CNT_FUNC(void)
 #define CVMX_HNA_PFC3_CTL CVMX_HNA_PFC3_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC3_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC3_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000B8ull);
 }
@@ -331,7 +335,7 @@ static inline uint64_t CVMX_HNA_PFC3_CTL_FUNC(void)
 #define CVMX_HNA_PFC_GCTL CVMX_HNA_PFC_GCTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC_GCTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_PFC_GCTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000080ull);
 }
@@ -342,7 +346,7 @@ static inline uint64_t CVMX_HNA_PFC_GCTL_FUNC(void)
 #define CVMX_HNA_SBD_DBG0 CVMX_HNA_SBD_DBG0_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_SBD_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000040ull);
 }
@@ -353,7 +357,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG0_FUNC(void)
 #define CVMX_HNA_SBD_DBG1 CVMX_HNA_SBD_DBG1_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_SBD_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000048ull);
 }
@@ -364,7 +368,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG1_FUNC(void)
 #define CVMX_HNA_SBD_DBG2 CVMX_HNA_SBD_DBG2_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_SBD_DBG2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000050ull);
 }
@@ -375,7 +379,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG2_FUNC(void)
 #define CVMX_HNA_SBD_DBG3 CVMX_HNA_SBD_DBG3_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_HNA_SBD_DBG3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000058ull);
 }
@@ -412,6 +416,7 @@ union cvmx_hna_bist0 {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_hna_bist0_s               cn73xx;
 	struct cvmx_hna_bist0_s               cn78xx;
 };
 typedef union cvmx_hna_bist0 cvmx_hna_bist0_t;
@@ -443,6 +448,7 @@ union cvmx_hna_bist1 {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_hna_bist1_s               cn73xx;
 	struct cvmx_hna_bist1_s               cn78xx;
 };
 typedef union cvmx_hna_bist1 cvmx_hna_bist1_t;
@@ -547,6 +553,100 @@ union cvmx_hna_config {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_hna_config_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t stk_ll_dis                   : 1;  /**< Stack linked-list disable. When set, the linked-list mechanism for run stack and save
+                                                         stack structures is disabled. In this mode, the linked-list chunk boundary checking is not
+                                                         done, and therefore the previous/next pointers are non-existent. The stacks are
+                                                         effectively in an infinite linear buffer, bounded only by the maximum sizes provided in
+                                                         the instruction (IWORD3[RUNSTACKSZ] and IWORD6[SVSTACKSZ]). There is no space reserved for
+                                                         the previous and next pointers, and [STK_CHKSZ] is ignored.
+                                                         When the STK_LL_DIS is cleared, the stack linked-list mechanism operates as per spec. */
+	uint64_t reserved_23_23               : 1;
+	uint64_t stk_chksz                    : 3;  /**< Stack chunk size. This encoded value specifies the chunk size for both the RNSTK/SVSTK
+                                                         data structures. The RNSTK/SVSTK use a doubly linked list where each chunk's first two
+                                                         64-bit entries contain the previous and next chunk pointers.
+                                                         0x0 = 32 entries or 256 bytes.
+                                                         0x1 = 64 entries or 512 bytes.
+                                                         0x2 = 128 entries or 1K bytes.
+                                                         0x3 = 256 entries or 2K bytes.
+                                                         0x4 = 512 entries or 4K bytes.
+                                                         0x5 = 1024 entries or 8K bytes.
+                                                         0x6 = 2048 entries or 16K bytes.
+                                                         0x7 = 4096 entries or 32K bytes.
+                                                         NOTE: This field can only be changed at initialization/power on time before the HNA is fed
+                                                         instructions. */
+	uint64_t rnstk_lwm                    : 4;  /**< RNSTK low watermark. This field specifies the low watermark for the run stack. Valid
+                                                         range: 0-15.
+                                                         Once the run stack goes below the low watermark, HNA fills entries from the global run
+                                                         stack head to the local run stack tail. The granularity of this field is represented as
+                                                         number of 128B cachelines.
+                                                         NOTE: This field can only be changed at initialization/power on time before the HNA is fed
+                                                         instructions. */
+	uint64_t rnstk_hwm                    : 4;  /**< RNSTK high watermark. This field specifies the high watermark for the run stack. Valid
+                                                         range: 0-15.
+                                                         Once the local run stack level goes above the high watermark, the HNA spills entries from
+                                                         the local run stack tail to the global run stack head (in DDR memory). The granularity of
+                                                         this field is represented as number of 128B cachelines.
+                                                         NOTE: This field can only be changed at initialization/power on time before the HNA is fed
+                                                         instructions. */
+	uint64_t reserved_9_11                : 3;
+	uint64_t ecccordis                    : 1;  /**< ECC correction disable. When set, all HNA ECC protected data structures disable their ECC
+                                                         correction logic. When clear (default) ECC correction is always enabled. */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t clmskcrip                    : 2;  /**< Cluster cripple mask. A one in each bit of the mask represents which HPC cluster to
+                                                         cripple. CN73XX HNA has 2 clusters, where all CLMSKCRIP mask bits are used.
+                                                         Software NOTE: The MIO_FUS___HNA_CLMASK_CRIPPLE[1:0] fuse bits are forced into this
+                                                         register at reset. Any fuse bits that contain 1 are disallowed during a write and are
+                                                         always read as 1. */
+	uint64_t hpu_clcrip                   : 3;  /**< HPU cluster cripple. Encoding which represents number of HPUs to cripple for each
+                                                         cluster. Typically HPU_CLCRIP=0x0, which enables all HPUs within each cluster. However,
+                                                         when the HNA performance counters are used, software may want to limit the number of HPUs
+                                                         per cluster available, as there are only 4 parallel performance counters.
+                                                         0x0 = HPU[9:0]:ON, All engines enabled
+                                                         0x1 = HPU[9]:OFF /HPU[8:0]:ON, (n-1) engines enabled.
+                                                         0x2 = HPU[9:8]:OFF /HPU[7:0]:ON, (n-2) engines enabled.
+                                                         0x2 = HPU[9:7]:OFF /HPU[6:0]:ON, (n-3) engines enabled.
+                                                         0x3 = HPU[9:6]:OFF /HPU[5:0]:ON, (n-4) engines enabled.
+                                                         0x4 = HPU[9:5]:OFF /HPU[4:0]:ON, (n-5) engines enabled.
+                                                         0x5 = HPU[9:4]:OFF /HPU[3:0]:ON, (n-6) engines enabled.
+                                                         0x6 = HPU[9:2]:OFF /HPU[1:0]:ON, (n-8) engines enabled.
+                                                         0x7 = HPU[9:1]:OFF /HPU[0]:ON, (n-9) 1 engine enabled.
+                                                         NOTE: Higher numbered HPUs are crippled first. For instance, on CN78XX (with 10
+                                                         HPUs/cluster), if HPU_CLCRIP=0x1, then HPU numbers [9] within the cluster are
+                                                         crippled and only HPU numbers 0-8 are available.
+                                                         Software NOTE: The MIO_FUS___HNA_NUMHPU_CRIPPLE[2:0] fuse bits are forced into this
+                                                         register at reset. Any fuse bits that contain 1 are disallowed during a write and are
+                                                         always read as 1.
+                                                         INTERNAL: The encodings are done in such a way as to later be used with fuses (for future
+                                                         revisions which will disable some number of HPUs). Blowing a fuse has the effect that
+                                                         there will always be fewer HPUs available. [i.e: we never want a customer to blow
+                                                         additional fuses to get more HPUs]. */
+	uint64_t hpuclkdis                    : 1;  /**< HNA clock disable source. When set, the HNA clocks for HPU (thread engine) operation are
+                                                         disabled (to conserve overall chip clocking power when the HNA function is not used).
+                                                         NOTE: When set, software must never issue NCB-direct CSR operations to the HNA (will
+                                                         result in NCB bus timeout errors).
+                                                         NOTE: This should only be written to a different value during power-on software
+                                                         initialization.
+                                                         Software NOTE: The MIO_FUS___HNA_HPU_DISABLE fuse bit is forced into this register at
+                                                         reset. If the fuse bit contains 1, writes to HPUCLKDIS are disallowed and are always read
+                                                         as 1. */
+#else
+	uint64_t hpuclkdis                    : 1;
+	uint64_t hpu_clcrip                   : 3;
+	uint64_t clmskcrip                    : 2;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t ecccordis                    : 1;
+	uint64_t reserved_9_11                : 3;
+	uint64_t rnstk_hwm                    : 4;
+	uint64_t rnstk_lwm                    : 4;
+	uint64_t stk_chksz                    : 3;
+	uint64_t reserved_23_23               : 1;
+	uint64_t stk_ll_dis                   : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn73xx;
 	struct cvmx_hna_config_s              cn78xx;
 };
 typedef union cvmx_hna_config cvmx_hna_config_t;
@@ -595,6 +695,7 @@ union cvmx_hna_control {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_hna_control_s             cn73xx;
 	struct cvmx_hna_control_s             cn78xx;
 };
 typedef union cvmx_hna_control cvmx_hna_control_t;
@@ -627,6 +728,7 @@ union cvmx_hna_dbell {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_hna_dbell_s               cn73xx;
 	struct cvmx_hna_dbell_s               cn78xx;
 };
 typedef union cvmx_hna_dbell cvmx_hna_dbell_t;
@@ -675,6 +777,7 @@ union cvmx_hna_difctl {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_hna_difctl_s              cn73xx;
 	struct cvmx_hna_difctl_s              cn78xx;
 };
 typedef union cvmx_hna_difctl cvmx_hna_difctl_t;
@@ -709,6 +812,7 @@ union cvmx_hna_difrdptr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_hna_difrdptr_s            cn73xx;
 	struct cvmx_hna_difrdptr_s            cn78xx;
 };
 typedef union cvmx_hna_difrdptr cvmx_hna_difrdptr_t;
@@ -795,6 +899,7 @@ union cvmx_hna_error {
 	uint64_t reserved_21_63               : 43;
 #endif
 	} s;
+	struct cvmx_hna_error_s               cn73xx;
 	struct cvmx_hna_error_s               cn78xx;
 };
 typedef union cvmx_hna_error cvmx_hna_error_t;
@@ -849,6 +954,7 @@ union cvmx_hna_error_capture_data {
 	uint64_t hpu_stat                     : 64;
 #endif
 	} s;
+	struct cvmx_hna_error_capture_data_s  cn73xx;
 	struct cvmx_hna_error_capture_data_s  cn78xx;
 };
 typedef union cvmx_hna_error_capture_data cvmx_hna_error_capture_data_t;
@@ -882,6 +988,7 @@ union cvmx_hna_error_capture_info {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_hna_error_capture_info_s  cn73xx;
 	struct cvmx_hna_error_capture_info_s  cn78xx;
 };
 typedef union cvmx_hna_error_capture_info cvmx_hna_error_capture_info_t;
@@ -902,6 +1009,7 @@ union cvmx_hna_hnc0_ram1x {
 	uint64_t ram1_data                    : 64;
 #endif
 	} s;
+	struct cvmx_hna_hnc0_ram1x_s          cn73xx;
 	struct cvmx_hna_hnc0_ram1x_s          cn78xx;
 };
 typedef union cvmx_hna_hnc0_ram1x cvmx_hna_hnc0_ram1x_t;
@@ -922,6 +1030,7 @@ union cvmx_hna_hnc0_ram2x {
 	uint64_t ram2_data                    : 64;
 #endif
 	} s;
+	struct cvmx_hna_hnc0_ram2x_s          cn73xx;
 	struct cvmx_hna_hnc0_ram2x_s          cn78xx;
 };
 typedef union cvmx_hna_hnc0_ram2x cvmx_hna_hnc0_ram2x_t;
@@ -942,6 +1051,7 @@ union cvmx_hna_hnc1_ram1x {
 	uint64_t ram1_data                    : 64;
 #endif
 	} s;
+	struct cvmx_hna_hnc1_ram1x_s          cn73xx;
 	struct cvmx_hna_hnc1_ram1x_s          cn78xx;
 };
 typedef union cvmx_hna_hnc1_ram1x cvmx_hna_hnc1_ram1x_t;
@@ -962,6 +1072,7 @@ union cvmx_hna_hnc1_ram2x {
 	uint64_t ram2_data                    : 64;
 #endif
 	} s;
+	struct cvmx_hna_hnc1_ram2x_s          cn73xx;
 	struct cvmx_hna_hnc1_ram2x_s          cn78xx;
 };
 typedef union cvmx_hna_hnc1_ram2x cvmx_hna_hnc1_ram2x_t;
@@ -983,6 +1094,7 @@ union cvmx_hna_hpu_csr {
 	uint64_t csrdat                       : 64;
 #endif
 	} s;
+	struct cvmx_hna_hpu_csr_s             cn73xx;
 	struct cvmx_hna_hpu_csr_s             cn78xx;
 };
 typedef union cvmx_hna_hpu_csr cvmx_hna_hpu_csr_t;
@@ -1011,6 +1123,7 @@ union cvmx_hna_hpu_dbg {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_hna_hpu_dbg_s             cn73xx;
 	struct cvmx_hna_hpu_dbg_s             cn78xx;
 };
 typedef union cvmx_hna_hpu_dbg cvmx_hna_hpu_dbg_t;
@@ -1047,6 +1160,7 @@ union cvmx_hna_hpu_eir {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_hna_hpu_eir_s             cn73xx;
 	struct cvmx_hna_hpu_eir_s             cn78xx;
 };
 typedef union cvmx_hna_hpu_eir cvmx_hna_hpu_eir_t;
@@ -1065,6 +1179,7 @@ union cvmx_hna_pfc0_cnt {
 	uint64_t pfcnt                        : 64;
 #endif
 	} s;
+	struct cvmx_hna_pfc0_cnt_s            cn73xx;
 	struct cvmx_hna_pfc0_cnt_s            cn78xx;
 };
 typedef union cvmx_hna_pfc0_cnt cvmx_hna_pfc0_cnt_t;
@@ -1094,6 +1209,7 @@ union cvmx_hna_pfc0_ctl {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_hna_pfc0_ctl_s            cn73xx;
 	struct cvmx_hna_pfc0_ctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc0_ctl cvmx_hna_pfc0_ctl_t;
@@ -1112,6 +1228,7 @@ union cvmx_hna_pfc1_cnt {
 	uint64_t pfcnt                        : 64;
 #endif
 	} s;
+	struct cvmx_hna_pfc1_cnt_s            cn73xx;
 	struct cvmx_hna_pfc1_cnt_s            cn78xx;
 };
 typedef union cvmx_hna_pfc1_cnt cvmx_hna_pfc1_cnt_t;
@@ -1140,6 +1257,7 @@ union cvmx_hna_pfc1_ctl {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_hna_pfc1_ctl_s            cn73xx;
 	struct cvmx_hna_pfc1_ctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc1_ctl cvmx_hna_pfc1_ctl_t;
@@ -1158,6 +1276,7 @@ union cvmx_hna_pfc2_cnt {
 	uint64_t pfcnt                        : 64;
 #endif
 	} s;
+	struct cvmx_hna_pfc2_cnt_s            cn73xx;
 	struct cvmx_hna_pfc2_cnt_s            cn78xx;
 };
 typedef union cvmx_hna_pfc2_cnt cvmx_hna_pfc2_cnt_t;
@@ -1186,6 +1305,7 @@ union cvmx_hna_pfc2_ctl {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_hna_pfc2_ctl_s            cn73xx;
 	struct cvmx_hna_pfc2_ctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc2_ctl cvmx_hna_pfc2_ctl_t;
@@ -1204,6 +1324,7 @@ union cvmx_hna_pfc3_cnt {
 	uint64_t pfcnt                        : 64;
 #endif
 	} s;
+	struct cvmx_hna_pfc3_cnt_s            cn73xx;
 	struct cvmx_hna_pfc3_cnt_s            cn78xx;
 };
 typedef union cvmx_hna_pfc3_cnt cvmx_hna_pfc3_cnt_t;
@@ -1232,6 +1353,7 @@ union cvmx_hna_pfc3_ctl {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_hna_pfc3_ctl_s            cn73xx;
 	struct cvmx_hna_pfc3_ctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc3_ctl cvmx_hna_pfc3_ctl_t;
@@ -1291,6 +1413,7 @@ union cvmx_hna_pfc_gctl {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_hna_pfc_gctl_s            cn73xx;
 	struct cvmx_hna_pfc_gctl_s            cn78xx;
 };
 typedef union cvmx_hna_pfc_gctl cvmx_hna_pfc_gctl_t;
@@ -1339,6 +1462,7 @@ union cvmx_hna_sbd_dbg0 {
 	uint64_t sbd                          : 64;
 #endif
 	} s;
+	struct cvmx_hna_sbd_dbg0_s            cn73xx;
 	struct cvmx_hna_sbd_dbg0_s            cn78xx;
 };
 typedef union cvmx_hna_sbd_dbg0 cvmx_hna_sbd_dbg0_t;
@@ -1363,6 +1487,7 @@ union cvmx_hna_sbd_dbg1 {
 	uint64_t sbd                          : 64;
 #endif
 	} s;
+	struct cvmx_hna_sbd_dbg1_s            cn73xx;
 	struct cvmx_hna_sbd_dbg1_s            cn78xx;
 };
 typedef union cvmx_hna_sbd_dbg1 cvmx_hna_sbd_dbg1_t;
@@ -1387,6 +1512,7 @@ union cvmx_hna_sbd_dbg2 {
 	uint64_t sbd                          : 64;
 #endif
 	} s;
+	struct cvmx_hna_sbd_dbg2_s            cn73xx;
 	struct cvmx_hna_sbd_dbg2_s            cn78xx;
 };
 typedef union cvmx_hna_sbd_dbg2 cvmx_hna_sbd_dbg2_t;
@@ -1421,6 +1547,7 @@ union cvmx_hna_sbd_dbg3 {
 	uint64_t sbd                          : 64;
 #endif
 	} s;
+	struct cvmx_hna_sbd_dbg3_s            cn73xx;
 	struct cvmx_hna_sbd_dbg3_s            cn78xx;
 };
 typedef union cvmx_hna_sbd_dbg3 cvmx_hna_sbd_dbg3_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
index 022efe4..14a17a6 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_IOBN_BIST_STATUS CVMX_IOBN_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_IOBN_BIST_STATUS_FUNC(void)
 #define CVMX_IOBN_CHIP_CUR_PWR CVMX_IOBN_CHIP_CUR_PWR_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_CUR_PWR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_CUR_PWR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000068ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_IOBN_CHIP_CUR_PWR_FUNC(void)
 #define CVMX_IOBN_CHIP_GLB_PWR_THROTTLE CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_GLB_PWR_THROTTLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000038ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC(void)
 #define CVMX_IOBN_CHIP_PWR_OUT CVMX_IOBN_CHIP_PWR_OUT_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_PWR_OUT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_PWR_OUT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000048ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_IOBN_CHIP_PWR_OUT_FUNC(void)
 #define CVMX_IOBN_CONTROL CVMX_IOBN_CONTROL_FUNC()
 static inline uint64_t CVMX_IOBN_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000008ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_IOBN_CONTROL_FUNC(void)
 #define CVMX_IOBN_CREDITS CVMX_IOBN_CREDITS_FUNC()
 static inline uint64_t CVMX_IOBN_CREDITS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_CREDITS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000028ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_IOBN_CREDITS_FUNC(void)
 #define CVMX_IOBN_ECC CVMX_IOBN_ECC_FUNC()
 static inline uint64_t CVMX_IOBN_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000010ull);
 }
@@ -133,7 +133,7 @@ static inline uint64_t CVMX_IOBN_ECC_FUNC(void)
 #define CVMX_IOBN_GBL_DLL CVMX_IOBN_GBL_DLL_FUNC()
 static inline uint64_t CVMX_IOBN_GBL_DLL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_GBL_DLL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0001000ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_IOBN_GBL_DLL_FUNC(void)
 #define CVMX_IOBN_HIGH_PRIORITY CVMX_IOBN_HIGH_PRIORITY_FUNC()
 static inline uint64_t CVMX_IOBN_HIGH_PRIORITY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_HIGH_PRIORITY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000000ull);
 }
@@ -155,7 +155,7 @@ static inline uint64_t CVMX_IOBN_HIGH_PRIORITY_FUNC(void)
 #define CVMX_IOBN_INT_SUM CVMX_IOBN_INT_SUM_FUNC()
 static inline uint64_t CVMX_IOBN_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000020ull);
 }
@@ -166,6 +166,7 @@ static inline uint64_t CVMX_IOBN_INT_SUM_FUNC(void)
 static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_IOBN_NCBX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800F0004000ull) + ((offset) & 3) * 8;
@@ -177,7 +178,7 @@ static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
 #define CVMX_IOBN_PP_BIST_STATUS CVMX_IOBN_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_PP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBN_PP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000700ull);
 }
@@ -254,6 +255,7 @@ union cvmx_iobn_bist_status {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_iobn_bist_status_s        cn73xx;
 	struct cvmx_iobn_bist_status_s        cn78xx;
 };
 typedef union cvmx_iobn_bist_status cvmx_iobn_bist_status_t;
@@ -286,6 +288,7 @@ union cvmx_iobn_chip_cur_pwr {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_iobn_chip_cur_pwr_s       cn73xx;
 	struct cvmx_iobn_chip_cur_pwr_s       cn78xx;
 };
 typedef union cvmx_iobn_chip_cur_pwr cvmx_iobn_chip_cur_pwr_t;
@@ -328,6 +331,7 @@ union cvmx_iobn_chip_glb_pwr_throttle {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_iobn_chip_glb_pwr_throttle_s cn73xx;
 	struct cvmx_iobn_chip_glb_pwr_throttle_s cn78xx;
 };
 typedef union cvmx_iobn_chip_glb_pwr_throttle cvmx_iobn_chip_glb_pwr_throttle_t;
@@ -360,6 +364,7 @@ union cvmx_iobn_chip_pwr_out {
 	uint64_t cpu_pwr                      : 16;
 #endif
 	} s;
+	struct cvmx_iobn_chip_pwr_out_s       cn73xx;
 	struct cvmx_iobn_chip_pwr_out_s       cn78xx;
 };
 typedef union cvmx_iobn_chip_pwr_out cvmx_iobn_chip_pwr_out_t;
@@ -381,6 +386,7 @@ union cvmx_iobn_control {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_iobn_control_s            cn73xx;
 	struct cvmx_iobn_control_s            cn78xx;
 };
 typedef union cvmx_iobn_control cvmx_iobn_control_t;
@@ -438,6 +444,7 @@ union cvmx_iobn_credits {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_iobn_credits_s            cn73xx;
 	struct cvmx_iobn_credits_s            cn78xx;
 };
 typedef union cvmx_iobn_credits cvmx_iobn_credits_t;
@@ -537,6 +544,7 @@ union cvmx_iobn_ecc {
 	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
+	struct cvmx_iobn_ecc_s                cn73xx;
 	struct cvmx_iobn_ecc_s                cn78xx;
 };
 typedef union cvmx_iobn_ecc cvmx_iobn_ecc_t;
@@ -576,6 +584,7 @@ union cvmx_iobn_gbl_dll {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_iobn_gbl_dll_s            cn73xx;
 	struct cvmx_iobn_gbl_dll_s            cn78xx;
 };
 typedef union cvmx_iobn_gbl_dll cvmx_iobn_gbl_dll_t;
@@ -602,6 +611,7 @@ union cvmx_iobn_high_priority {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_iobn_high_priority_s      cn73xx;
 	struct cvmx_iobn_high_priority_s      cn78xx;
 };
 typedef union cvmx_iobn_high_priority cvmx_iobn_high_priority_t;
@@ -777,6 +787,7 @@ union cvmx_iobn_int_sum {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_iobn_int_sum_s            cn73xx;
 	struct cvmx_iobn_int_sum_s            cn78xx;
 };
 typedef union cvmx_iobn_int_sum cvmx_iobn_int_sum_t;
@@ -785,7 +796,7 @@ typedef union cvmx_iobn_int_sum cvmx_iobn_int_sum_t;
  * cvmx_iobn_ncb#_ctl
  *
  * This register controls the type of store operation used for full cache blocks stores.
- * Added in pass 2.
+ *
  */
 union cvmx_iobn_ncbx_ctl {
 	uint64_t u64;
@@ -810,6 +821,7 @@ union cvmx_iobn_ncbx_ctl {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_iobn_ncbx_ctl_s           cn73xx;
 	struct cvmx_iobn_ncbx_ctl_s           cn78xx;
 };
 typedef union cvmx_iobn_ncbx_ctl cvmx_iobn_ncbx_ctl_t;
@@ -833,6 +845,7 @@ union cvmx_iobn_pp_bist_status {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_iobn_pp_bist_status_s     cn73xx;
 	struct cvmx_iobn_pp_bist_status_s     cn78xx;
 };
 typedef union cvmx_iobn_pp_bist_status cvmx_iobn_pp_bist_status_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
index ad0918f..b716d79 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_IOBP_BIST_STATUS CVMX_IOBP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_IOBP_BIST_STATUS_FUNC(void)
 #define CVMX_IOBP_CREDITS CVMX_IOBP_CREDITS_FUNC()
 static inline uint64_t CVMX_IOBP_CREDITS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_CREDITS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010028ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_IOBP_CREDITS_FUNC(void)
 #define CVMX_IOBP_ECC CVMX_IOBP_ECC_FUNC()
 static inline uint64_t CVMX_IOBP_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010010ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_IOBP_ECC_FUNC(void)
 #define CVMX_IOBP_INT_SUM CVMX_IOBP_INT_SUM_FUNC()
 static inline uint64_t CVMX_IOBP_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010020ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_IOBP_INT_SUM_FUNC(void)
 #define CVMX_IOBP_PP_BIST_STATUS CVMX_IOBP_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBP_PP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_IOBP_PP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010700ull);
 }
@@ -145,6 +145,7 @@ union cvmx_iobp_bist_status {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_iobp_bist_status_s        cn73xx;
 	struct cvmx_iobp_bist_status_s        cn78xx;
 };
 typedef union cvmx_iobp_bist_status cvmx_iobp_bist_status_t;
@@ -178,6 +179,7 @@ union cvmx_iobp_credits {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_iobp_credits_s            cn73xx;
 	struct cvmx_iobp_credits_s            cn78xx;
 };
 typedef union cvmx_iobp_credits cvmx_iobp_credits_t;
@@ -227,6 +229,7 @@ union cvmx_iobp_ecc {
 	uint64_t reserved_22_63               : 42;
 #endif
 	} s;
+	struct cvmx_iobp_ecc_s                cn73xx;
 	struct cvmx_iobp_ecc_s                cn78xx;
 };
 typedef union cvmx_iobp_ecc cvmx_iobp_ecc_t;
@@ -312,6 +315,7 @@ union cvmx_iobp_int_sum {
 	uint64_t reserved_46_63               : 18;
 #endif
 	} s;
+	struct cvmx_iobp_int_sum_s            cn73xx;
 	struct cvmx_iobp_int_sum_s            cn78xx;
 };
 typedef union cvmx_iobp_int_sum cvmx_iobp_int_sum_t;
@@ -335,6 +339,7 @@ union cvmx_iobp_pp_bist_status {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_iobp_pp_bist_status_s     cn73xx;
 	struct cvmx_iobp_pp_bist_status_s     cn78xx;
 };
 typedef union cvmx_iobp_pp_bist_status cvmx_iobp_pp_bist_status_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 1ef42c6..db5de1a 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_L2C_BIG_CTL CVMX_L2C_BIG_CTL_FUNC()
 static inline uint64_t CVMX_L2C_BIG_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_BIG_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800030ull);
 }
@@ -157,6 +157,7 @@ static inline uint64_t CVMX_L2C_CBCX_BIST_STATUS(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080E007F8ull) + ((block_id) & 3) * 0x40000ull;
@@ -168,6 +169,7 @@ static inline uint64_t CVMX_L2C_CBCX_BIST_STATUS(unsigned long block_id)
 static inline uint64_t CVMX_L2C_CBCX_DLL(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_DLL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080E00018ull) + ((block_id) & 3) * 0x40000ull;
@@ -179,6 +181,7 @@ static inline uint64_t CVMX_L2C_CBCX_DLL(unsigned long block_id)
 static inline uint64_t CVMX_L2C_CBCX_HOLEERR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_HOLEERR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080E007D0ull) + ((block_id) & 3) * 0x40000ull;
@@ -191,6 +194,7 @@ static inline uint64_t CVMX_L2C_CBCX_INT(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_INT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080E00028ull) + ((block_id) & 3) * 0x40000ull;
@@ -203,6 +207,7 @@ static inline uint64_t CVMX_L2C_CBCX_IOCERR(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_IOCERR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080E007E8ull) + ((block_id) & 3) * 0x40000ull;
@@ -214,6 +219,7 @@ static inline uint64_t CVMX_L2C_CBCX_IOCERR(unsigned long block_id)
 static inline uint64_t CVMX_L2C_CBCX_IODISOCIERR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_IODISOCIERR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080E007D8ull) + ((block_id) & 3) * 0x40000ull;
@@ -224,19 +230,37 @@ static inline uint64_t CVMX_L2C_CBCX_IODISOCIERR(unsigned long block_id)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((block_id >= 2) && (block_id <= 3))))))
-		cvmx_warn("CVMX_L2C_CBCX_MIBERR(%lu) is invalid on this chip\n", block_id);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (((block_id >= 2) && (block_id <= 3)))
+				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((block_id) & 3) * 0x40000ull - 262144*2;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 1))
+				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((block_id) & 1) * 0x40000ull - 262144*1;
+			break;
+	}
+	cvmx_warn("CVMX_L2C_CBCX_MIBERR (block_id = %lu) not supported on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((block_id) & 3) * 0x40000ull - 262144*2;
 }
 #else
-#define CVMX_L2C_CBCX_MIBERR(block_id) (CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((block_id) & 3) * 0x40000ull - 262144*2)
+static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (block_id) * 0x40000ull - 262144*2;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (block_id) * 0x40000ull - 262144*1;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (block_id) * 0x40000ull - 262144*2;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_L2C_CBCX_RSDERR(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_CBCX_RSDERR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080E007F0ull) + ((block_id) & 3) * 0x40000ull;
@@ -259,7 +283,7 @@ static inline uint64_t CVMX_L2C_CFG_FUNC(void)
 #define CVMX_L2C_COP0_ADR CVMX_L2C_COP0_ADR_FUNC()
 static inline uint64_t CVMX_L2C_COP0_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_COP0_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800038ull);
 }
@@ -270,7 +294,7 @@ static inline uint64_t CVMX_L2C_COP0_ADR_FUNC(void)
 #define CVMX_L2C_COP0_DAT CVMX_L2C_COP0_DAT_FUNC()
 static inline uint64_t CVMX_L2C_COP0_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_COP0_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800040ull);
 }
@@ -296,7 +320,7 @@ static inline uint64_t CVMX_L2C_COP0_MAPX(unsigned long offset)
 #define CVMX_L2C_CTL CVMX_L2C_CTL_FUNC()
 static inline uint64_t CVMX_L2C_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800000ull);
 }
@@ -344,7 +368,7 @@ static inline uint64_t CVMX_L2C_DUT_MAPX(unsigned long offset)
 #define CVMX_L2C_ECC_CTL CVMX_L2C_ECC_CTL_FUNC()
 static inline uint64_t CVMX_L2C_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800010ull);
 }
@@ -478,6 +502,7 @@ static inline uint64_t CVMX_L2C_INVX_PFC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_L2C_INVX_PFC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800820ull) + ((offset) & 7) * 64;
@@ -499,6 +524,7 @@ static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long block_id)
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 			break;
@@ -518,6 +544,7 @@ static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long block_id __attribute__ ((
 			return CVMX_ADD_IO_SEG(0x0001180080800420ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800420ull);
@@ -537,6 +564,7 @@ static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long block_id)
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 			break;
@@ -556,6 +584,7 @@ static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long block_id __attribute__ ((
 			return CVMX_ADD_IO_SEG(0x0001180080800428ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800428ull);
@@ -632,6 +661,7 @@ static inline uint64_t CVMX_L2C_MCIX_BIST_STATUS(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_MCIX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((block_id) & 3) * 0x40000ull;
@@ -644,6 +674,7 @@ static inline uint64_t CVMX_L2C_MCIX_ERR(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_MCIX_ERR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((block_id) & 3) * 0x40000ull;
@@ -656,6 +687,7 @@ static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_L2C_MCIX_INT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080C00028ull) + ((block_id) & 3) * 0x40000ull;
@@ -667,7 +699,7 @@ static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long block_id)
 #define CVMX_L2C_OCI_CTL CVMX_L2C_OCI_CTL_FUNC()
 static inline uint64_t CVMX_L2C_OCI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_OCI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800020ull);
 }
@@ -770,6 +802,7 @@ static inline uint64_t CVMX_L2C_QOS_IOBX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_QOS_IOBX(%lu) is invalid on this chip\n", offset);
@@ -787,6 +820,7 @@ static inline uint64_t CVMX_L2C_QOS_PPX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_QOS_PPX(%lu) is invalid on this chip\n", offset);
@@ -799,7 +833,7 @@ static inline uint64_t CVMX_L2C_QOS_PPX(unsigned long offset)
 #define CVMX_L2C_QOS_WGT CVMX_L2C_QOS_WGT_FUNC()
 static inline uint64_t CVMX_L2C_QOS_WGT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_QOS_WGT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800008ull);
 }
@@ -829,6 +863,10 @@ static inline uint64_t CVMX_L2C_RSCX_PFC(unsigned long offset)
 			if ((offset <= 9))
 				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 15) * 64;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 3) * 64;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_RSCX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800410ull) + ((offset) & 0) * 64;
@@ -848,6 +886,8 @@ static inline uint64_t CVMX_L2C_RSCX_PFC(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800410ull) + (offset) * 64;
 }
@@ -875,6 +915,10 @@ static inline uint64_t CVMX_L2C_RSDX_PFC(unsigned long offset)
 			if ((offset <= 9))
 				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 15) * 64;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 3) * 64;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_RSDX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800418ull) + ((offset) & 0) * 64;
@@ -894,6 +938,8 @@ static inline uint64_t CVMX_L2C_RSDX_PFC(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800418ull) + (offset) * 64;
 }
@@ -958,6 +1004,7 @@ static inline uint64_t CVMX_L2C_TADX_DLL(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_DLL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id) & 7) * 0x40000ull;
@@ -1000,6 +1047,7 @@ static inline uint64_t CVMX_L2C_TADX_ERR(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_ERR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A007D0ull) + ((block_id) & 7) * 0x40000ull;
@@ -1031,6 +1079,7 @@ static inline uint64_t CVMX_L2C_TADX_INT(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_L2C_TADX_INT(%lu) is invalid on this chip\n", block_id);
@@ -1104,6 +1153,7 @@ static inline uint64_t CVMX_L2C_TADX_PFCX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 7))))))
 		cvmx_warn("CVMX_L2C_TADX_PFCX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A00400ull) + (((offset) & 3) + ((block_id) & 7) * 0x8000ull) * 8;
@@ -1120,6 +1170,7 @@ static inline uint64_t CVMX_L2C_TADX_PRF(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_L2C_TADX_PRF(%lu) is invalid on this chip\n", block_id);
@@ -1129,6 +1180,17 @@ static inline uint64_t CVMX_L2C_TADX_PRF(unsigned long block_id)
 #define CVMX_L2C_TADX_PRF(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00008ull) + ((block_id) & 7) * 0x40000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_L2C_TADX_STAT(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_L2C_TADX_STAT(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((block_id) & 3) * 0x40000ull;
+}
+#else
+#define CVMX_L2C_TADX_STAT(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((block_id) & 3) * 0x40000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_L2C_TADX_TAG(unsigned long block_id)
 {
 	if (!(
@@ -1137,6 +1199,7 @@ static inline uint64_t CVMX_L2C_TADX_TAG(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_L2C_TADX_TAG(%lu) is invalid on this chip\n", block_id);
@@ -1149,6 +1212,7 @@ static inline uint64_t CVMX_L2C_TADX_TAG(unsigned long block_id)
 static inline uint64_t CVMX_L2C_TADX_TIMEOUT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_TIMEOUT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A007C8ull) + ((block_id) & 7) * 0x40000ull;
@@ -1160,6 +1224,7 @@ static inline uint64_t CVMX_L2C_TADX_TIMEOUT(unsigned long block_id)
 static inline uint64_t CVMX_L2C_TADX_TIMETWO(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TADX_TIMETWO(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A007C0ull) + ((block_id) & 7) * 0x40000ull;
@@ -1171,7 +1236,7 @@ static inline uint64_t CVMX_L2C_TADX_TIMETWO(unsigned long block_id)
 #define CVMX_L2C_TAD_CTL CVMX_L2C_TAD_CTL_FUNC()
 static inline uint64_t CVMX_L2C_TAD_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_L2C_TAD_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800018ull);
 }
@@ -1183,6 +1248,7 @@ static inline uint64_t CVMX_L2C_TBFX_BIST_STATUS(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TBFX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((block_id) & 7) * 0x40000ull;
@@ -1195,6 +1261,7 @@ static inline uint64_t CVMX_L2C_TDTX_BIST_STATUS(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TDTX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((block_id) & 7) * 0x40000ull;
@@ -1207,6 +1274,7 @@ static inline uint64_t CVMX_L2C_TQDX_ERR(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TQDX_ERR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A007D8ull) + ((block_id) & 7) * 0x40000ull;
@@ -1219,6 +1287,7 @@ static inline uint64_t CVMX_L2C_TTGX_BIST_STATUS(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TTGX_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((block_id) & 7) * 0x40000ull;
@@ -1231,6 +1300,7 @@ static inline uint64_t CVMX_L2C_TTGX_ERR(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 7)))))
 		cvmx_warn("CVMX_L2C_TTGX_ERR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((block_id) & 7) * 0x40000ull;
@@ -1347,6 +1417,7 @@ static inline uint64_t CVMX_L2C_WPAR_IOBX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_L2C_WPAR_IOBX(%lu) is invalid on this chip\n", offset);
@@ -1364,6 +1435,7 @@ static inline uint64_t CVMX_L2C_WPAR_PPX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_WPAR_PPX(%lu) is invalid on this chip\n", offset);
@@ -1395,6 +1467,10 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 			if ((offset <= 9))
 				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 15) * 64;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 3) * 64;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_XMCX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800400ull) + ((offset) & 0) * 64;
@@ -1414,6 +1490,8 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800400ull) + (offset) * 64;
 }
@@ -1422,7 +1500,7 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 #define CVMX_L2C_XMC_CMD CVMX_L2C_XMC_CMD_FUNC()
 static inline uint64_t CVMX_L2C_XMC_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_L2C_XMC_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800028ull);
 }
@@ -1452,6 +1530,10 @@ static inline uint64_t CVMX_L2C_XMDX_PFC(unsigned long offset)
 			if ((offset <= 9))
 				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 15) * 64;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 3) * 64;
+			break;
 	}
 	cvmx_warn("CVMX_L2C_XMDX_PFC (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080800408ull) + ((offset) & 0) * 64;
@@ -1471,6 +1553,8 @@ static inline uint64_t CVMX_L2C_XMDX_PFC(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080800408ull) + (offset) * 64;
 }
@@ -1581,6 +1665,7 @@ union cvmx_l2c_big_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_big_ctl_cn70xx        cn70xxp1;
+	struct cvmx_l2c_big_ctl_cn70xx        cn73xx;
 	struct cvmx_l2c_big_ctl_cn70xx        cn78xx;
 	struct cvmx_l2c_big_ctl_cn61xx        cnf71xx;
 };
@@ -2321,7 +2406,7 @@ union cvmx_l2c_cbcx_bist_status {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_cbcx_bist_status_cn70xx cn70xxp1;
-	struct cvmx_l2c_cbcx_bist_status_cn78xx {
+	struct cvmx_l2c_cbcx_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_37_63               : 27;
 	uint64_t mibfl                        : 5;  /**< BIST failure status for various MIB memories. ([XMD, IPM, IRM, MXD, MXN]) */
@@ -2331,7 +2416,8 @@ union cvmx_l2c_cbcx_bist_status {
 	uint64_t mibfl                        : 5;
 	uint64_t reserved_37_63               : 27;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_cbcx_bist_status_cn73xx cn78xx;
 };
 typedef union cvmx_l2c_cbcx_bist_status cvmx_l2c_cbcx_bist_status_t;
 
@@ -2366,6 +2452,7 @@ union cvmx_l2c_cbcx_dll {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_l2c_cbcx_dll_s            cn73xx;
 	struct cvmx_l2c_cbcx_dll_s            cn78xx;
 };
 typedef union cvmx_l2c_cbcx_dll cvmx_l2c_cbcx_dll_t;
@@ -2403,6 +2490,7 @@ union cvmx_l2c_cbcx_holeerr {
 	uint64_t holerd                       : 1;
 #endif
 	} s;
+	struct cvmx_l2c_cbcx_holeerr_s        cn73xx;
 	struct cvmx_l2c_cbcx_holeerr_s        cn78xx;
 };
 typedef union cvmx_l2c_cbcx_holeerr cvmx_l2c_cbcx_holeerr_t;
@@ -2462,7 +2550,7 @@ union cvmx_l2c_cbcx_int {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_cbcx_int_cn70xx       cn70xxp1;
-	struct cvmx_l2c_cbcx_int_cn78xx {
+	struct cvmx_l2c_cbcx_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t holerd                       : 1;  /**< Read reference to 256MB hole occurred. */
@@ -2490,7 +2578,8 @@ union cvmx_l2c_cbcx_int {
 	uint64_t holerd                       : 1;
 	uint64_t reserved_10_63               : 54;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_cbcx_int_cn73xx       cn78xx;
 };
 typedef union cvmx_l2c_cbcx_int cvmx_l2c_cbcx_int_t;
 
@@ -2521,13 +2610,14 @@ union cvmx_l2c_cbcx_iocerr {
 	} s;
 	struct cvmx_l2c_cbcx_iocerr_s         cn70xx;
 	struct cvmx_l2c_cbcx_iocerr_s         cn70xxp1;
-	struct cvmx_l2c_cbcx_iocerr_cn78xx {
+	struct cvmx_l2c_cbcx_iocerr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_0_63                : 64;
 #else
 	uint64_t reserved_0_63                : 64;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_cbcx_iocerr_cn73xx    cn78xx;
 };
 typedef union cvmx_l2c_cbcx_iocerr cvmx_l2c_cbcx_iocerr_t;
 
@@ -2563,6 +2653,7 @@ union cvmx_l2c_cbcx_iodisocierr {
 	uint64_t iorddisoci                   : 1;
 #endif
 	} s;
+	struct cvmx_l2c_cbcx_iodisocierr_s    cn73xx;
 	struct cvmx_l2c_cbcx_iodisocierr_s    cn78xx;
 };
 typedef union cvmx_l2c_cbcx_iodisocierr cvmx_l2c_cbcx_iodisocierr_t;
@@ -2601,6 +2692,7 @@ union cvmx_l2c_cbcx_miberr {
 	uint64_t mibdbe                       : 1;
 #endif
 	} s;
+	struct cvmx_l2c_cbcx_miberr_s         cn73xx;
 	struct cvmx_l2c_cbcx_miberr_s         cn78xx;
 };
 typedef union cvmx_l2c_cbcx_miberr cvmx_l2c_cbcx_miberr_t;
@@ -2640,6 +2732,7 @@ union cvmx_l2c_cbcx_rsderr {
 	} s;
 	struct cvmx_l2c_cbcx_rsderr_s         cn70xx;
 	struct cvmx_l2c_cbcx_rsderr_s         cn70xxp1;
+	struct cvmx_l2c_cbcx_rsderr_s         cn73xx;
 	struct cvmx_l2c_cbcx_rsderr_s         cn78xx;
 };
 typedef union cvmx_l2c_cbcx_rsderr cvmx_l2c_cbcx_rsderr_t;
@@ -3351,6 +3444,7 @@ union cvmx_l2c_cop0_adr {
 	} s;
 	struct cvmx_l2c_cop0_adr_s            cn70xx;
 	struct cvmx_l2c_cop0_adr_s            cn70xxp1;
+	struct cvmx_l2c_cop0_adr_s            cn73xx;
 	struct cvmx_l2c_cop0_adr_s            cn78xx;
 };
 typedef union cvmx_l2c_cop0_adr cvmx_l2c_cop0_adr_t;
@@ -3372,6 +3466,7 @@ union cvmx_l2c_cop0_dat {
 	} s;
 	struct cvmx_l2c_cop0_dat_s            cn70xx;
 	struct cvmx_l2c_cop0_dat_s            cn70xxp1;
+	struct cvmx_l2c_cop0_dat_s            cn73xx;
 	struct cvmx_l2c_cop0_dat_s            cn78xx;
 };
 typedef union cvmx_l2c_cop0_dat cvmx_l2c_cop0_dat_t;
@@ -3867,7 +3962,7 @@ union cvmx_l2c_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_ctl_cn70xx            cn70xxp1;
-	struct cvmx_l2c_ctl_cn78xx {
+	struct cvmx_l2c_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t ocla_qos                     : 3;  /**< QOS level for the transactions from OCLA to L2C. */
@@ -3911,7 +4006,8 @@ union cvmx_l2c_ctl {
 	uint64_t ocla_qos                     : 3;
 	uint64_t reserved_32_63               : 32;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_ctl_cn73xx            cn78xx;
 	struct cvmx_l2c_ctl_cn61xx            cnf71xx;
 };
 typedef union cvmx_l2c_ctl cvmx_l2c_ctl_t;
@@ -4604,7 +4700,7 @@ union cvmx_l2c_ecc_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_ecc_ctl_cn70xx        cn70xxp1;
-	struct cvmx_l2c_ecc_ctl_cn78xx {
+	struct cvmx_l2c_ecc_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t mibflip                      : 2;  /**< Generate an ECC error in the MIB. See note above. */
@@ -4622,7 +4718,8 @@ union cvmx_l2c_ecc_ctl {
 	uint64_t mibflip                      : 2;
 	uint64_t reserved_12_63               : 52;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_ecc_ctl_cn73xx        cn78xx;
 };
 typedef union cvmx_l2c_ecc_ctl cvmx_l2c_ecc_ctl_t;
 
@@ -5467,6 +5564,7 @@ union cvmx_l2c_invx_pfc {
 	} s;
 	struct cvmx_l2c_invx_pfc_s            cn70xx;
 	struct cvmx_l2c_invx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_invx_pfc_s            cn73xx;
 	struct cvmx_l2c_invx_pfc_s            cn78xx;
 };
 typedef union cvmx_l2c_invx_pfc cvmx_l2c_invx_pfc_t;
@@ -5494,6 +5592,7 @@ union cvmx_l2c_iocx_pfc {
 	struct cvmx_l2c_iocx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_iocx_pfc_s            cn70xx;
 	struct cvmx_l2c_iocx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_iocx_pfc_s            cn73xx;
 	struct cvmx_l2c_iocx_pfc_s            cn78xx;
 	struct cvmx_l2c_iocx_pfc_s            cnf71xx;
 };
@@ -5522,6 +5621,7 @@ union cvmx_l2c_iorx_pfc {
 	struct cvmx_l2c_iorx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_iorx_pfc_s            cn70xx;
 	struct cvmx_l2c_iorx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_iorx_pfc_s            cn73xx;
 	struct cvmx_l2c_iorx_pfc_s            cn78xx;
 	struct cvmx_l2c_iorx_pfc_s            cnf71xx;
 };
@@ -6077,6 +6177,7 @@ union cvmx_l2c_mcix_bist_status {
 	} s;
 	struct cvmx_l2c_mcix_bist_status_s    cn70xx;
 	struct cvmx_l2c_mcix_bist_status_s    cn70xxp1;
+	struct cvmx_l2c_mcix_bist_status_s    cn73xx;
 	struct cvmx_l2c_mcix_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_mcix_bist_status cvmx_l2c_mcix_bist_status_t;
@@ -6122,6 +6223,7 @@ union cvmx_l2c_mcix_err {
 	} s;
 	struct cvmx_l2c_mcix_err_s            cn70xx;
 	struct cvmx_l2c_mcix_err_s            cn70xxp1;
+	struct cvmx_l2c_mcix_err_s            cn73xx;
 	struct cvmx_l2c_mcix_err_s            cn78xx;
 };
 typedef union cvmx_l2c_mcix_err cvmx_l2c_mcix_err_t;
@@ -6147,6 +6249,7 @@ union cvmx_l2c_mcix_int {
 	} s;
 	struct cvmx_l2c_mcix_int_s            cn70xx;
 	struct cvmx_l2c_mcix_int_s            cn70xxp1;
+	struct cvmx_l2c_mcix_int_s            cn73xx;
 	struct cvmx_l2c_mcix_int_s            cn78xx;
 };
 typedef union cvmx_l2c_mcix_int cvmx_l2c_mcix_int_t;
@@ -6241,6 +6344,7 @@ union cvmx_l2c_oci_ctl {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_l2c_oci_ctl_s             cn73xx;
 	struct cvmx_l2c_oci_ctl_s             cn78xx;
 };
 typedef union cvmx_l2c_oci_ctl cvmx_l2c_oci_ctl_t;
@@ -6745,6 +6849,7 @@ union cvmx_l2c_qos_iobx {
 	struct cvmx_l2c_qos_iobx_s            cn68xxp1;
 	struct cvmx_l2c_qos_iobx_s            cn70xx;
 	struct cvmx_l2c_qos_iobx_s            cn70xxp1;
+	struct cvmx_l2c_qos_iobx_s            cn73xx;
 	struct cvmx_l2c_qos_iobx_s            cn78xx;
 	struct cvmx_l2c_qos_iobx_cn61xx       cnf71xx;
 };
@@ -6784,6 +6889,7 @@ union cvmx_l2c_qos_ppx {
 	struct cvmx_l2c_qos_ppx_s             cn68xxp1;
 	struct cvmx_l2c_qos_ppx_s             cn70xx;
 	struct cvmx_l2c_qos_ppx_s             cn70xxp1;
+	struct cvmx_l2c_qos_ppx_s             cn73xx;
 	struct cvmx_l2c_qos_ppx_s             cn78xx;
 	struct cvmx_l2c_qos_ppx_cn61xx        cnf71xx;
 };
@@ -6840,6 +6946,7 @@ union cvmx_l2c_qos_wgt {
 	struct cvmx_l2c_qos_wgt_s             cn68xxp1;
 	struct cvmx_l2c_qos_wgt_s             cn70xx;
 	struct cvmx_l2c_qos_wgt_s             cn70xxp1;
+	struct cvmx_l2c_qos_wgt_s             cn73xx;
 	struct cvmx_l2c_qos_wgt_s             cn78xx;
 	struct cvmx_l2c_qos_wgt_cn61xx        cnf71xx;
 };
@@ -6868,6 +6975,7 @@ union cvmx_l2c_rscx_pfc {
 	struct cvmx_l2c_rscx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_rscx_pfc_s            cn70xx;
 	struct cvmx_l2c_rscx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_rscx_pfc_s            cn73xx;
 	struct cvmx_l2c_rscx_pfc_s            cn78xx;
 	struct cvmx_l2c_rscx_pfc_s            cnf71xx;
 };
@@ -6896,6 +7004,7 @@ union cvmx_l2c_rsdx_pfc {
 	struct cvmx_l2c_rsdx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_rsdx_pfc_s            cn70xx;
 	struct cvmx_l2c_rsdx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_rsdx_pfc_s            cn73xx;
 	struct cvmx_l2c_rsdx_pfc_s            cn78xx;
 	struct cvmx_l2c_rsdx_pfc_s            cnf71xx;
 };
@@ -7186,6 +7295,7 @@ union cvmx_l2c_tadx_dll {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tadx_dll_cn70xx       cn70xxp1;
+	struct cvmx_l2c_tadx_dll_s            cn73xx;
 	struct cvmx_l2c_tadx_dll_s            cn78xx;
 };
 typedef union cvmx_l2c_tadx_dll cvmx_l2c_tadx_dll_t;
@@ -7337,7 +7447,7 @@ union cvmx_l2c_tadx_err {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tadx_err_cn70xx       cn70xxp1;
-	struct cvmx_l2c_tadx_err_cn78xx {
+	struct cvmx_l2c_tadx_err_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t bigrd                        : 1;  /**< Logged information is for a BIGRD error. */
 	uint64_t bigwr                        : 1;  /**< Logged information is for a BIGWR error. */
@@ -7369,7 +7479,8 @@ union cvmx_l2c_tadx_err {
 	uint64_t bigwr                        : 1;
 	uint64_t bigrd                        : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_tadx_err_cn73xx       cn78xx;
 };
 typedef union cvmx_l2c_tadx_err cvmx_l2c_tadx_err_t;
 
@@ -7623,7 +7734,7 @@ union cvmx_l2c_tadx_int {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tadx_int_cn70xx       cn70xxp1;
-	struct cvmx_l2c_tadx_int_cn78xx {
+	struct cvmx_l2c_tadx_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
 	uint64_t wrdisoci                     : 1;  /**< Illegal write operation to a remote node with L2C_OCI_CTL[ENAOCI][node] clear. See
@@ -7688,7 +7799,8 @@ union cvmx_l2c_tadx_int {
 	uint64_t wrdisoci                     : 1;
 	uint64_t reserved_36_63               : 28;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_l2c_tadx_int_cn73xx       cn78xx;
 	struct cvmx_l2c_tadx_int_cn61xx       cnf71xx;
 };
 typedef union cvmx_l2c_tadx_int cvmx_l2c_tadx_int_t;
@@ -7707,6 +7819,7 @@ union cvmx_l2c_tadx_pfcx {
 	} s;
 	struct cvmx_l2c_tadx_pfcx_s           cn70xx;
 	struct cvmx_l2c_tadx_pfcx_s           cn70xxp1;
+	struct cvmx_l2c_tadx_pfcx_s           cn73xx;
 	struct cvmx_l2c_tadx_pfcx_s           cn78xx;
 };
 typedef union cvmx_l2c_tadx_pfcx cvmx_l2c_tadx_pfcx_t;
@@ -7842,12 +7955,38 @@ union cvmx_l2c_tadx_prf {
 	struct cvmx_l2c_tadx_prf_s            cn68xxp1;
 	struct cvmx_l2c_tadx_prf_s            cn70xx;
 	struct cvmx_l2c_tadx_prf_s            cn70xxp1;
+	struct cvmx_l2c_tadx_prf_s            cn73xx;
 	struct cvmx_l2c_tadx_prf_s            cn78xx;
 	struct cvmx_l2c_tadx_prf_s            cnf71xx;
 };
 typedef union cvmx_l2c_tadx_prf cvmx_l2c_tadx_prf_t;
 
 /**
+ * cvmx_l2c_tad#_stat
+ *
+ * This register holds information about the instantaneous state of the TAD.
+ *
+ */
+union cvmx_l2c_tadx_stat {
+	uint64_t u64;
+	struct cvmx_l2c_tadx_stat_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t lfb_valid_cnt                : 6;  /**< The number of LFBs in use. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t vbf_inuse_cnt                : 5;  /**< The number of MCI VBFs in use. */
+#else
+	uint64_t vbf_inuse_cnt                : 5;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t lfb_valid_cnt                : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_l2c_tadx_stat_s           cn73xx;
+};
+typedef union cvmx_l2c_tadx_stat cvmx_l2c_tadx_stat_t;
+
+/**
  * cvmx_l2c_tad#_tag
  *
  * This register holds the tag information for LTGL2I and STGL2I commands.
@@ -7935,6 +8074,47 @@ union cvmx_l2c_tadx_tag {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tadx_tag_cn70xx       cn70xxp1;
+	struct cvmx_l2c_tadx_tag_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. Ignored/loaded with 0 for RTG accesses. If TS is Invalid (0) SBLKDTY
+                                                         must be 0 or operation is undefined. */
+	uint64_t reserved_58_59               : 2;
+	uint64_t businfo                      : 9;  /**< The bus information bits. Legal values: when [57]==1, we are in idmode and
+                                                         [56:53] must be 0, [52:49] are the PPVID of the PP which could be holding the
+                                                         block; when [57]==0, we are in bus mask mode and [56:52] must be 0 and if any of
+                                                         [51:48] is 1 then any of the PP's on that bus (3..0) could contain the
+                                                         block. Operation is undefined if an STGL2I causes an illegal value to be written
+                                                         to the L2 TAGs. LTGL2Is will only load legal values into this register. */
+	uint64_t ecc                          : 7;  /**< The tag ECC. This field is undefined if L2C_CTL[DISECC] is not 1 when the LTGL2I reads the tags. */
+	uint64_t reserved_40_41               : 2;
+	uint64_t tag                          : 22; /**< The tag. TAG<39:18> is the corresponding bits from the L2C+LMC internal L2/DRAM byte
+                                                         address. */
+	uint64_t reserved_6_17                : 12;
+	uint64_t node                         : 2;  /**< Reserved. */
+	uint64_t ts                           : 2;  /**< The tag state.
+                                                         0x0 = Invalid.
+                                                         0x1 = Shared.
+                                                         0x2 = Exclusive.
+                                                         Note that a local address will never have the value of exclusive as that state is incloded
+                                                         as shared in the TAG and invalid in the RTG. */
+	uint64_t used                         : 1;  /**< The LRU use bit. If setting the LOCK bit, the USE bit should also be set or the operation
+                                                         is undefined.  Ignored/loaded with 0 for RTG accesses. */
+	uint64_t lock                         : 1;  /**< The lock bit. If setting the LOCK bit, the USE bit should also be set or the operation is
+                                                         undefined.  Ignored/loaded with 0 for RTG accesses. */
+#else
+	uint64_t lock                         : 1;
+	uint64_t used                         : 1;
+	uint64_t ts                           : 2;
+	uint64_t node                         : 2;
+	uint64_t reserved_6_17                : 12;
+	uint64_t tag                          : 22;
+	uint64_t reserved_40_41               : 2;
+	uint64_t ecc                          : 7;
+	uint64_t businfo                      : 9;
+	uint64_t reserved_58_59               : 2;
+	uint64_t sblkdty                      : 4;
+#endif
+	} cn73xx;
 	struct cvmx_l2c_tadx_tag_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. Ignored/loaded with 0 for RTG accesses. If TS is Invalid (0) SBLKDTY
@@ -8017,6 +8197,7 @@ union cvmx_l2c_tadx_timeout {
 	uint64_t infolfb                      : 1;
 #endif
 	} s;
+	struct cvmx_l2c_tadx_timeout_s        cn73xx;
 	struct cvmx_l2c_tadx_timeout_s        cn78xx;
 };
 typedef union cvmx_l2c_tadx_timeout cvmx_l2c_tadx_timeout_t;
@@ -8051,6 +8232,7 @@ union cvmx_l2c_tadx_timetwo {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_l2c_tadx_timetwo_s        cn73xx;
 	struct cvmx_l2c_tadx_timetwo_s        cn78xx;
 };
 typedef union cvmx_l2c_tadx_timetwo cvmx_l2c_tadx_timetwo_t;
@@ -8122,6 +8304,7 @@ union cvmx_l2c_tad_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_tad_ctl_cn70xx        cn70xxp1;
+	struct cvmx_l2c_tad_ctl_s             cn73xx;
 	struct cvmx_l2c_tad_ctl_s             cn78xx;
 };
 typedef union cvmx_l2c_tad_ctl cvmx_l2c_tad_ctl_t;
@@ -8146,6 +8329,7 @@ union cvmx_l2c_tbfx_bist_status {
 	} s;
 	struct cvmx_l2c_tbfx_bist_status_s    cn70xx;
 	struct cvmx_l2c_tbfx_bist_status_s    cn70xxp1;
+	struct cvmx_l2c_tbfx_bist_status_s    cn73xx;
 	struct cvmx_l2c_tbfx_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_tbfx_bist_status cvmx_l2c_tbfx_bist_status_t;
@@ -8166,6 +8350,7 @@ union cvmx_l2c_tdtx_bist_status {
 	} s;
 	struct cvmx_l2c_tdtx_bist_status_s    cn70xx;
 	struct cvmx_l2c_tdtx_bist_status_s    cn70xxp1;
+	struct cvmx_l2c_tdtx_bist_status_s    cn73xx;
 	struct cvmx_l2c_tdtx_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_tdtx_bist_status cvmx_l2c_tdtx_bist_status_t;
@@ -8213,6 +8398,7 @@ union cvmx_l2c_tqdx_err {
 	} s;
 	struct cvmx_l2c_tqdx_err_s            cn70xx;
 	struct cvmx_l2c_tqdx_err_s            cn70xxp1;
+	struct cvmx_l2c_tqdx_err_s            cn73xx;
 	struct cvmx_l2c_tqdx_err_s            cn78xx;
 };
 typedef union cvmx_l2c_tqdx_err cvmx_l2c_tqdx_err_t;
@@ -8259,6 +8445,7 @@ union cvmx_l2c_ttgx_bist_status {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_ttgx_bist_status_cn70xx cn70xxp1;
+	struct cvmx_l2c_ttgx_bist_status_s    cn73xx;
 	struct cvmx_l2c_ttgx_bist_status_s    cn78xx;
 };
 typedef union cvmx_l2c_ttgx_bist_status cvmx_l2c_ttgx_bist_status_t;
@@ -8271,7 +8458,7 @@ typedef union cvmx_l2c_ttgx_bist_status cvmx_l2c_ttgx_bist_status_t;
  * and L2IDX fields for equal or lower priority errors until cleared by software.
  * The syndrome is recorded for DBE errors, though the utility of the value is not clear.
  * A NOWAY error does not change the value of the SYN field, and leaves WAY unpredictable.
- * L2IDX[19:7] is the L2 block index associated with the command which had no way to allocate.
+ * L2IDX[17:7] is the L2 block index associated with the command which had no way to allocate.
  */
 union cvmx_l2c_ttgx_err {
 	uint64_t u64;
@@ -8316,6 +8503,29 @@ union cvmx_l2c_ttgx_err {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_ttgx_err_cn70xx       cn70xxp1;
+	struct cvmx_l2c_ttgx_err_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t tagdbe                       : 1;  /**< Information refers to a double-bit TAG ECC error. */
+	uint64_t tagsbe                       : 1;  /**< Information refers to a single-bit TAG ECC error. */
+	uint64_t noway                        : 1;  /**< Information refers to a NOWAY error. */
+	uint64_t reserved_39_60               : 22;
+	uint64_t syn                          : 7;  /**< Syndrome for the single-bit error. */
+	uint64_t reserved_22_31               : 10;
+	uint64_t way                          : 4;  /**< Way of the L2 block containing the error */
+	uint64_t l2idx                        : 11; /**< Index of the L2 block containing the error */
+	uint64_t reserved_0_6                 : 7;
+#else
+	uint64_t reserved_0_6                 : 7;
+	uint64_t l2idx                        : 11;
+	uint64_t way                          : 4;
+	uint64_t reserved_22_31               : 10;
+	uint64_t syn                          : 7;
+	uint64_t reserved_39_60               : 22;
+	uint64_t noway                        : 1;
+	uint64_t tagsbe                       : 1;
+	uint64_t tagdbe                       : 1;
+#endif
+	} cn73xx;
 	struct cvmx_l2c_ttgx_err_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t tagdbe                       : 1;  /**< Information refers to a double-bit TAG ECC error. */
@@ -8717,6 +8927,7 @@ union cvmx_l2c_wpar_iobx {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_wpar_iobx_cn70xx      cn70xxp1;
+	struct cvmx_l2c_wpar_iobx_s           cn73xx;
 	struct cvmx_l2c_wpar_iobx_s           cn78xx;
 	struct cvmx_l2c_wpar_iobx_s           cnf71xx;
 };
@@ -8760,6 +8971,7 @@ union cvmx_l2c_wpar_ppx {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_wpar_ppx_cn70xx       cn70xxp1;
+	struct cvmx_l2c_wpar_ppx_s            cn73xx;
 	struct cvmx_l2c_wpar_ppx_s            cn78xx;
 	struct cvmx_l2c_wpar_ppx_s            cnf71xx;
 };
@@ -8788,6 +9000,7 @@ union cvmx_l2c_xmcx_pfc {
 	struct cvmx_l2c_xmcx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_xmcx_pfc_s            cn70xx;
 	struct cvmx_l2c_xmcx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_xmcx_pfc_s            cn73xx;
 	struct cvmx_l2c_xmcx_pfc_s            cn78xx;
 	struct cvmx_l2c_xmcx_pfc_s            cnf71xx;
 };
@@ -8890,6 +9103,7 @@ union cvmx_l2c_xmc_cmd {
 #endif
 	} cn70xx;
 	struct cvmx_l2c_xmc_cmd_cn70xx        cn70xxp1;
+	struct cvmx_l2c_xmc_cmd_cn70xx        cn73xx;
 	struct cvmx_l2c_xmc_cmd_cn70xx        cn78xx;
 	struct cvmx_l2c_xmc_cmd_cn61xx        cnf71xx;
 };
@@ -8918,6 +9132,7 @@ union cvmx_l2c_xmdx_pfc {
 	struct cvmx_l2c_xmdx_pfc_s            cn68xxp1;
 	struct cvmx_l2c_xmdx_pfc_s            cn70xx;
 	struct cvmx_l2c_xmdx_pfc_s            cn70xxp1;
+	struct cvmx_l2c_xmdx_pfc_s            cn73xx;
 	struct cvmx_l2c_xmdx_pfc_s            cn78xx;
 	struct cvmx_l2c_xmdx_pfc_s            cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
index 0114201..f1ec6ad 100644
--- a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_LBK_BIST_RESULT CVMX_LBK_BIST_RESULT_FUNC()
 static inline uint64_t CVMX_LBK_BIST_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_BIST_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000020ull);
 }
@@ -67,6 +67,7 @@ static inline uint64_t CVMX_LBK_BIST_RESULT_FUNC(void)
 static inline uint64_t CVMX_LBK_CHX_PKIND(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_LBK_CHX_PKIND(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180012000200ull) + ((offset) & 63) * 8;
@@ -75,10 +76,21 @@ static inline uint64_t CVMX_LBK_CHX_PKIND(unsigned long offset)
 #define CVMX_LBK_CHX_PKIND(offset) (CVMX_ADD_IO_SEG(0x0001180012000200ull) + ((offset) & 63) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_LBK_CLK_GATE_CTL CVMX_LBK_CLK_GATE_CTL_FUNC()
+static inline uint64_t CVMX_LBK_CLK_GATE_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_LBK_CLK_GATE_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180012000008ull);
+}
+#else
+#define CVMX_LBK_CLK_GATE_CTL (CVMX_ADD_IO_SEG(0x0001180012000008ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_LBK_DAT_ERR_INFO CVMX_LBK_DAT_ERR_INFO_FUNC()
 static inline uint64_t CVMX_LBK_DAT_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_DAT_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000050ull);
 }
@@ -89,7 +101,7 @@ static inline uint64_t CVMX_LBK_DAT_ERR_INFO_FUNC(void)
 #define CVMX_LBK_ECC_CFG CVMX_LBK_ECC_CFG_FUNC()
 static inline uint64_t CVMX_LBK_ECC_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_ECC_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000060ull);
 }
@@ -100,7 +112,7 @@ static inline uint64_t CVMX_LBK_ECC_CFG_FUNC(void)
 #define CVMX_LBK_INT CVMX_LBK_INT_FUNC()
 static inline uint64_t CVMX_LBK_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000040ull);
 }
@@ -111,7 +123,7 @@ static inline uint64_t CVMX_LBK_INT_FUNC(void)
 #define CVMX_LBK_SFT_RST CVMX_LBK_SFT_RST_FUNC()
 static inline uint64_t CVMX_LBK_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_LBK_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000000ull);
 }
@@ -136,6 +148,7 @@ union cvmx_lbk_bist_result {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_lbk_bist_result_s         cn73xx;
 	struct cvmx_lbk_bist_result_s         cn78xx;
 };
 typedef union cvmx_lbk_bist_result cvmx_lbk_bist_result_t;
@@ -154,11 +167,33 @@ union cvmx_lbk_chx_pkind {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_lbk_chx_pkind_s           cn73xx;
 	struct cvmx_lbk_chx_pkind_s           cn78xx;
 };
 typedef union cvmx_lbk_chx_pkind cvmx_lbk_chx_pkind_t;
 
 /**
+ * cvmx_lbk_clk_gate_ctl
+ *
+ * This register is for diagnostic use only.
+ *
+ */
+union cvmx_lbk_clk_gate_ctl {
+	uint64_t u64;
+	struct cvmx_lbk_clk_gate_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t dis                          : 1;  /**< Clock gate disable. When set, forces gated clock to always on. */
+#else
+	uint64_t dis                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_lbk_clk_gate_ctl_s        cn73xx;
+};
+typedef union cvmx_lbk_clk_gate_ctl cvmx_lbk_clk_gate_ctl_t;
+
+/**
  * cvmx_lbk_dat_err_info
  */
 union cvmx_lbk_dat_err_info {
@@ -190,6 +225,7 @@ union cvmx_lbk_dat_err_info {
 	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
+	struct cvmx_lbk_dat_err_info_s        cn73xx;
 	struct cvmx_lbk_dat_err_info_s        cn78xx;
 };
 typedef union cvmx_lbk_dat_err_info cvmx_lbk_dat_err_info_t;
@@ -211,6 +247,7 @@ union cvmx_lbk_ecc_cfg {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_lbk_ecc_cfg_s             cn73xx;
 	struct cvmx_lbk_ecc_cfg_s             cn78xx;
 };
 typedef union cvmx_lbk_ecc_cfg cvmx_lbk_ecc_cfg_t;
@@ -243,6 +280,7 @@ union cvmx_lbk_int {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_lbk_int_s                 cn73xx;
 	struct cvmx_lbk_int_s                 cn78xx;
 };
 typedef union cvmx_lbk_int cvmx_lbk_int_t;
@@ -261,6 +299,7 @@ union cvmx_lbk_sft_rst {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_lbk_sft_rst_s             cn73xx;
 	struct cvmx_lbk_sft_rst_s             cn78xx;
 };
 typedef union cvmx_lbk_sft_rst cvmx_lbk_sft_rst_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index a86010c..b70f36e 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -56,14 +56,6 @@
 static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			if ((block_id == 0))
-				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((block_id) & 0) * 0x60000000ull;
-			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 3))
-				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((block_id) & 3) * 0x1000000ull;
-			break;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800880000F0ull) + ((block_id) & 1) * 0x60000000ull;
@@ -73,6 +65,15 @@ static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long block_id)
 			if ((block_id == 0))
 				return CVMX_ADD_IO_SEG(0x00011800880000F0ull);
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((block_id) & 0) * 0x60000000ull;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 3))
+				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((block_id) & 3) * 0x1000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_LMCX_BIST_CTL (block_id = %lu) not supported on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((block_id) & 3) * 0x1000000ull;
@@ -81,15 +82,16 @@ static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long block_id)
 static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (block_id) * 0x60000000ull;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000F0ull) + (block_id) * 0x60000000ull;
 		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000F0ull);
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (block_id) * 0x60000000ull;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (block_id) * 0x1000000ull;
 }
@@ -116,6 +118,7 @@ static inline uint64_t CVMX_LMCX_CHAR_CTL(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_CTL(%lu) is invalid on this chip\n", block_id);
@@ -129,6 +132,7 @@ static inline uint64_t CVMX_LMCX_CHAR_DQ_ERR_COUNT(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_CHAR_DQ_ERR_COUNT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000040ull) + ((block_id) & 3) * 0x1000000ull;
@@ -145,6 +149,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK0(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK0(%lu) is invalid on this chip\n", block_id);
@@ -162,6 +167,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK1(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK1(%lu) is invalid on this chip\n", block_id);
@@ -179,6 +185,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK2(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK2(%lu) is invalid on this chip\n", block_id);
@@ -196,6 +203,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK3(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK3(%lu) is invalid on this chip\n", block_id);
@@ -213,6 +221,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK4(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_CHAR_MASK4(%lu) is invalid on this chip\n", block_id);
@@ -247,6 +256,7 @@ static inline uint64_t CVMX_LMCX_COMP_CTL2(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_COMP_CTL2(%lu) is invalid on this chip\n", block_id);
@@ -264,6 +274,7 @@ static inline uint64_t CVMX_LMCX_CONFIG(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_CONFIG(%lu) is invalid on this chip\n", block_id);
@@ -281,6 +292,7 @@ static inline uint64_t CVMX_LMCX_CONTROL(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_CONTROL(%lu) is invalid on this chip\n", block_id);
@@ -322,6 +334,17 @@ static inline uint64_t CVMX_LMCX_CTL1(unsigned long block_id)
 #define CVMX_LMCX_CTL1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((block_id) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_DBTRAIN_CTL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_DBTRAIN_CTL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800880003F8ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_DBTRAIN_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800880003F8ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_DCLK_CNT(unsigned long block_id)
 {
 	if (!(
@@ -330,6 +353,7 @@ static inline uint64_t CVMX_LMCX_DCLK_CNT(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_DCLK_CNT(%lu) is invalid on this chip\n", block_id);
@@ -405,6 +429,7 @@ static inline uint64_t CVMX_LMCX_DDR4_DIMM_CTL(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_DDR4_DIMM_CTL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800880003F0ull) + ((block_id) & 3) * 0x1000000ull;
@@ -421,6 +446,7 @@ static inline uint64_t CVMX_LMCX_DDR_PLL_CTL(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_DDR_PLL_CTL(%lu) is invalid on this chip\n", block_id);
@@ -450,6 +476,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_DDR4_PARAMS0(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_DDR4_PARAMS0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800880000D0ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -462,6 +489,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_DDR4_PARAMS1(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_DDR4_PARAMS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000140ull) + (((offset) & 1) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -478,6 +506,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_PARAMS(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_PARAMS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -495,6 +524,7 @@ static inline uint64_t CVMX_LMCX_DIMM_CTL(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_DIMM_CTL(%lu) is invalid on this chip\n", block_id);
@@ -524,6 +554,7 @@ static inline uint64_t CVMX_LMCX_DLL_CTL2(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_DLL_CTL2(%lu) is invalid on this chip\n", block_id);
@@ -541,6 +572,7 @@ static inline uint64_t CVMX_LMCX_DLL_CTL3(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_DLL_CTL3(%lu) is invalid on this chip\n", block_id);
@@ -569,6 +601,7 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((block_id) & 0) * 0x60000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((block_id) & 3) * 0x1000000ull;
@@ -593,6 +626,7 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (block_id) * 0x60000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (block_id) * 0x1000000ull;
 	}
@@ -603,6 +637,7 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long block_id)
 static inline uint64_t CVMX_LMCX_ECC_PARITY_TEST(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_ECC_PARITY_TEST(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000108ull) + ((block_id) & 3) * 0x1000000ull;
@@ -628,15 +663,16 @@ static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long block_id)
 			if ((block_id == 0))
 				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 0) * 0x60000000ull;
 			break;
-		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 1) * 0x60000000ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 1) * 0x60000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_LMCX_ECC_SYND (block_id = %lu) not supported on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id) & 0) * 0x60000000ull;
@@ -657,11 +693,12 @@ static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long block_id)
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x60000000ull;
-		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x60000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x60000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (block_id) * 0x60000000ull;
 }
@@ -671,6 +708,7 @@ static inline uint64_t CVMX_LMCX_EXT_CONFIG(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_EXT_CONFIG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((block_id) & 3) * 0x1000000ull;
@@ -679,6 +717,17 @@ static inline uint64_t CVMX_LMCX_EXT_CONFIG(unsigned long block_id)
 #define CVMX_LMCX_EXT_CONFIG(block_id) (CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((block_id) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_EXT_CONFIG2(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_EXT_CONFIG2(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_EXT_CONFIG2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_FADR(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
@@ -696,15 +745,16 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long block_id)
 			if ((block_id == 0))
 				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 0) * 0x60000000ull;
 			break;
-		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			if ((block_id <= 1))
-				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 1) * 0x60000000ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 1) * 0x60000000ull;
+			break;
 	}
 	cvmx_warn("CVMX_LMCX_FADR (block_id = %lu) not supported on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id) & 0) * 0x60000000ull;
@@ -725,16 +775,50 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long block_id)
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x60000000ull;
-		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x60000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x60000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (block_id) * 0x60000000ull;
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE0(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE0(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000340ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_GENERAL_PURPOSE0(block_id) (CVMX_ADD_IO_SEG(0x0001180088000340ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE1(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE1(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000348ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_GENERAL_PURPOSE1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000348ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_GENERAL_PURPOSE2(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_GENERAL_PURPOSE2(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000350ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_GENERAL_PURPOSE2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000350ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_IFB_CNT(unsigned long block_id)
 {
 	if (!(
@@ -743,6 +827,7 @@ static inline uint64_t CVMX_LMCX_IFB_CNT(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_IFB_CNT(%lu) is invalid on this chip\n", block_id);
@@ -794,6 +879,7 @@ static inline uint64_t CVMX_LMCX_INT(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_INT(%lu) is invalid on this chip\n", block_id);
@@ -811,6 +897,7 @@ static inline uint64_t CVMX_LMCX_INT_EN(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_INT_EN(%lu) is invalid on this chip\n", block_id);
@@ -823,6 +910,7 @@ static inline uint64_t CVMX_LMCX_INT_EN(unsigned long block_id)
 static inline uint64_t CVMX_LMCX_LANEX_CRC_SWIZ(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 8)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 8)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_LMCX_LANEX_CRC_SWIZ(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000380ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
@@ -873,6 +961,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS0(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS0(%lu) is invalid on this chip\n", block_id);
@@ -890,6 +979,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS1(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS1(%lu) is invalid on this chip\n", block_id);
@@ -903,6 +993,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS2(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS2(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((block_id) & 3) * 0x1000000ull;
@@ -915,6 +1006,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS3(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS3(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((block_id) & 3) * 0x1000000ull;
@@ -927,6 +1019,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA0(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA0(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((block_id) & 3) * 0x1000000ull;
@@ -939,6 +1032,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA1(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA1(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((block_id) & 3) * 0x1000000ull;
@@ -951,6 +1045,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA2(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA2(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((block_id) & 3) * 0x1000000ull;
@@ -963,6 +1058,7 @@ static inline uint64_t CVMX_LMCX_MR_MPR_CTL(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_MR_MPR_CTL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((block_id) & 3) * 0x1000000ull;
@@ -971,6 +1067,17 @@ static inline uint64_t CVMX_LMCX_MR_MPR_CTL(unsigned long block_id)
 #define CVMX_LMCX_MR_MPR_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((block_id) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_NS_CTL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_NS_CTL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000178ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_NS_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000178ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_NXM(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
@@ -989,6 +1096,7 @@ static inline uint64_t CVMX_LMCX_NXM(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((block_id) & 0) * 0x60000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((block_id) & 3) * 0x1000000ull;
@@ -1012,6 +1120,7 @@ static inline uint64_t CVMX_LMCX_NXM(unsigned long block_id)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (block_id) * 0x60000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (block_id) * 0x1000000ull;
 	}
@@ -1023,6 +1132,7 @@ static inline uint64_t CVMX_LMCX_NXM_FADR(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_NXM_FADR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((block_id) & 3) * 0x1000000ull;
@@ -1039,6 +1149,7 @@ static inline uint64_t CVMX_LMCX_OPS_CNT(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_OPS_CNT(%lu) is invalid on this chip\n", block_id);
@@ -1090,6 +1201,7 @@ static inline uint64_t CVMX_LMCX_PHY_CTL(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_PHY_CTL(%lu) is invalid on this chip\n", block_id);
@@ -1140,6 +1252,17 @@ static inline uint64_t CVMX_LMCX_PLL_STATUS(unsigned long block_id)
 #define CVMX_LMCX_PLL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800880000B0ull) + ((block_id) & 1) * 0x60000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_PPR_CTL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_PPR_CTL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800880003E0ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_PPR_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800880003E0ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_READ_LEVEL_CTL(unsigned long block_id)
 {
 	if (!(
@@ -1176,6 +1299,17 @@ static inline uint64_t CVMX_LMCX_READ_LEVEL_RANKX(unsigned long offset, unsigned
 #define CVMX_LMCX_READ_LEVEL_RANKX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180088000100ull) + (((offset) & 3) + ((block_id) & 1) * 0xC000000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_REF_STATUS(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_REF_STATUS(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_REF_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long block_id)
 {
 	if (!(
@@ -1184,6 +1318,7 @@ static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_RESET_CTL(%lu) is invalid on this chip\n", block_id);
@@ -1193,6 +1328,28 @@ static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long block_id)
 #define CVMX_LMCX_RESET_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180088000180ull) + ((block_id) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_RETRY_CONFIG(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_RETRY_CONFIG(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000110ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_RETRY_CONFIG(block_id) (CVMX_ADD_IO_SEG(0x0001180088000110ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_RETRY_STATUS(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_RETRY_STATUS(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000118ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_RETRY_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180088000118ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_RLEVEL_CTL(unsigned long block_id)
 {
 	if (!(
@@ -1201,6 +1358,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_CTL(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_RLEVEL_CTL(%lu) is invalid on this chip\n", block_id);
@@ -1218,6 +1376,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_DBG(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_RLEVEL_DBG(%lu) is invalid on this chip\n", block_id);
@@ -1235,6 +1394,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_RANKX(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_LMCX_RLEVEL_RANKX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1283,6 +1443,7 @@ static inline uint64_t CVMX_LMCX_RODT_MASK(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_RODT_MASK(%lu) is invalid on this chip\n", block_id);
@@ -1298,6 +1459,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLED_FADR(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_SCRAMBLED_FADR(%lu) is invalid on this chip\n", block_id);
@@ -1313,6 +1475,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG0(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG0(%lu) is invalid on this chip\n", block_id);
@@ -1328,6 +1491,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG1(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG1(%lu) is invalid on this chip\n", block_id);
@@ -1337,10 +1501,22 @@ static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG1(unsigned long block_id)
 #define CVMX_LMCX_SCRAMBLE_CFG1(block_id) (CVMX_ADD_IO_SEG(0x0001180088000328ull) + ((block_id) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG2(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_SCRAMBLE_CFG2(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000338ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_SCRAMBLE_CFG2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000338ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_SEQ_CTL(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_SEQ_CTL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((block_id) & 3) * 0x1000000ull;
@@ -1357,6 +1533,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL0(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_SLOT_CTL0(%lu) is invalid on this chip\n", block_id);
@@ -1374,6 +1551,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL1(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_SLOT_CTL1(%lu) is invalid on this chip\n", block_id);
@@ -1391,6 +1569,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL2(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_SLOT_CTL2(%lu) is invalid on this chip\n", block_id);
@@ -1400,6 +1579,17 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL2(unsigned long block_id)
 #define CVMX_LMCX_SLOT_CTL2(block_id) (CVMX_ADD_IO_SEG(0x0001180088000208ull) + ((block_id) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_SLOT_CTL3(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_LMCX_SLOT_CTL3(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_SLOT_CTL3(block_id) (CVMX_ADD_IO_SEG(0x0001180088000248ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_TIMING_PARAMS0(unsigned long block_id)
 {
 	if (!(
@@ -1408,6 +1598,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS0(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_TIMING_PARAMS0(%lu) is invalid on this chip\n", block_id);
@@ -1425,6 +1616,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS1(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_TIMING_PARAMS1(%lu) is invalid on this chip\n", block_id);
@@ -1438,6 +1630,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS2(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_LMCX_TIMING_PARAMS2(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((block_id) & 3) * 0x1000000ull;
@@ -1484,6 +1677,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_CTL(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_WLEVEL_CTL(%lu) is invalid on this chip\n", block_id);
@@ -1501,6 +1695,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_DBG(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_WLEVEL_DBG(%lu) is invalid on this chip\n", block_id);
@@ -1532,6 +1727,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned lon
 				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 0) * 0x200000ull) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if (((offset <= 3)) && ((block_id <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
@@ -1554,6 +1750,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned lon
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800880002B0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
@@ -1599,6 +1796,7 @@ static inline uint64_t CVMX_LMCX_WODT_MASK(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id == 0)))))
 		cvmx_warn("CVMX_LMCX_WODT_MASK(%lu) is invalid on this chip\n", block_id);
@@ -1618,7 +1816,9 @@ union cvmx_lmcx_bist_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_bist_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_5_63                : 59;
+	uint64_t macram_bist_status           : 1;  /**< Maximum Activate Counts RAM BIST status.
+                                                         1 means fail. */
 	uint64_t dlcram_bist_status           : 1;  /**< DLC RAM BIST status; 1 means fail. */
 	uint64_t dlcram_bist_done             : 1;  /**< DLC RAM BIST complete indication; 1 means complete. */
 	uint64_t start_bist                   : 1;  /**< Start BIST on DLC memory. */
@@ -1628,7 +1828,8 @@ union cvmx_lmcx_bist_ctl {
 	uint64_t start_bist                   : 1;
 	uint64_t dlcram_bist_done             : 1;
 	uint64_t dlcram_bist_status           : 1;
-	uint64_t reserved_4_63                : 60;
+	uint64_t macram_bist_status           : 1;
+	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
 	struct cvmx_lmcx_bist_ctl_cn50xx {
@@ -1660,6 +1861,25 @@ union cvmx_lmcx_bist_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_bist_ctl_cn70xx      cn70xxp1;
+	struct cvmx_lmcx_bist_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t macram_bist_status           : 1;  /**< Maximum Activate Counts RAM BIST status.
+                                                         1 means fail. */
+	uint64_t dlcram_bist_status           : 1;  /**< DLC RAM BIST status; 1 means fail. */
+	uint64_t dlcram_bist_done             : 1;  /**< DLC and MAC RAM BIST complete indication;
+                                                         1 means both RAMs have completed. */
+	uint64_t start_bist                   : 1;  /**< Start BIST on DLC and MAC memory. */
+	uint64_t clear_bist                   : 1;  /**< Start clear BIST on DLC and MAC memory. */
+#else
+	uint64_t clear_bist                   : 1;
+	uint64_t start_bist                   : 1;
+	uint64_t dlcram_bist_done             : 1;
+	uint64_t dlcram_bist_status           : 1;
+	uint64_t macram_bist_status           : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_bist_ctl_cn70xx      cn78xx;
 };
 typedef union cvmx_lmcx_bist_ctl cvmx_lmcx_bist_ctl_t;
@@ -1802,6 +2022,7 @@ union cvmx_lmcx_char_ctl {
 	struct cvmx_lmcx_char_ctl_cn63xx      cn68xxp1;
 	struct cvmx_lmcx_char_ctl_s           cn70xx;
 	struct cvmx_lmcx_char_ctl_s           cn70xxp1;
+	struct cvmx_lmcx_char_ctl_s           cn73xx;
 	struct cvmx_lmcx_char_ctl_s           cn78xx;
 	struct cvmx_lmcx_char_ctl_cn61xx      cnf71xx;
 };
@@ -1826,6 +2047,7 @@ union cvmx_lmcx_char_dq_err_count {
 	} s;
 	struct cvmx_lmcx_char_dq_err_count_s  cn70xx;
 	struct cvmx_lmcx_char_dq_err_count_s  cn70xxp1;
+	struct cvmx_lmcx_char_dq_err_count_s  cn73xx;
 	struct cvmx_lmcx_char_dq_err_count_s  cn78xx;
 };
 typedef union cvmx_lmcx_char_dq_err_count cvmx_lmcx_char_dq_err_count_t;
@@ -1853,6 +2075,7 @@ union cvmx_lmcx_char_mask0 {
 	struct cvmx_lmcx_char_mask0_s         cn68xxp1;
 	struct cvmx_lmcx_char_mask0_s         cn70xx;
 	struct cvmx_lmcx_char_mask0_s         cn70xxp1;
+	struct cvmx_lmcx_char_mask0_s         cn73xx;
 	struct cvmx_lmcx_char_mask0_s         cn78xx;
 	struct cvmx_lmcx_char_mask0_s         cnf71xx;
 };
@@ -1883,6 +2106,7 @@ union cvmx_lmcx_char_mask1 {
 	struct cvmx_lmcx_char_mask1_s         cn68xxp1;
 	struct cvmx_lmcx_char_mask1_s         cn70xx;
 	struct cvmx_lmcx_char_mask1_s         cn70xxp1;
+	struct cvmx_lmcx_char_mask1_s         cn73xx;
 	struct cvmx_lmcx_char_mask1_s         cn78xx;
 	struct cvmx_lmcx_char_mask1_s         cnf71xx;
 };
@@ -1911,6 +2135,7 @@ union cvmx_lmcx_char_mask2 {
 	struct cvmx_lmcx_char_mask2_s         cn68xxp1;
 	struct cvmx_lmcx_char_mask2_s         cn70xx;
 	struct cvmx_lmcx_char_mask2_s         cn70xxp1;
+	struct cvmx_lmcx_char_mask2_s         cn73xx;
 	struct cvmx_lmcx_char_mask2_s         cn78xx;
 	struct cvmx_lmcx_char_mask2_s         cnf71xx;
 };
@@ -1941,6 +2166,7 @@ union cvmx_lmcx_char_mask3 {
 	struct cvmx_lmcx_char_mask3_s         cn68xxp1;
 	struct cvmx_lmcx_char_mask3_s         cn70xx;
 	struct cvmx_lmcx_char_mask3_s         cn70xxp1;
+	struct cvmx_lmcx_char_mask3_s         cn73xx;
 	struct cvmx_lmcx_char_mask3_s         cn78xx;
 	struct cvmx_lmcx_char_mask3_s         cnf71xx;
 };
@@ -2075,6 +2301,7 @@ union cvmx_lmcx_char_mask4 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_char_mask4_cn70xx    cn70xxp1;
+	struct cvmx_lmcx_char_mask4_s         cn73xx;
 	struct cvmx_lmcx_char_mask4_s         cn78xx;
 	struct cvmx_lmcx_char_mask4_cn61xx    cnf71xx;
 };
@@ -2427,6 +2654,7 @@ union cvmx_lmcx_comp_ctl2 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_comp_ctl2_cn70xx     cn70xxp1;
+	struct cvmx_lmcx_comp_ctl2_cn70xx     cn73xx;
 	struct cvmx_lmcx_comp_ctl2_cn70xx     cn78xx;
 	struct cvmx_lmcx_comp_ctl2_cn61xx     cnf71xx;
 };
@@ -2450,7 +2678,7 @@ union cvmx_lmcx_config {
 	uint64_t u64;
 	struct cvmx_lmcx_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_63_63               : 1;
+	uint64_t lrdimm_ena                   : 1;  /**< Load Reduced DIMM Enable. When set allows the use of JEDEC DDR4 LRDIMMs. */
 	uint64_t bg2_enable                   : 1;  /**< BG2 pin is active for DDR4 mode. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
                                                          Typically only cleared for DDR4 *16 devices, where there is no BG2 pin on the device. */
 	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
@@ -2648,7 +2876,7 @@ union cvmx_lmcx_config {
 	uint64_t mode32b                      : 1;
 	uint64_t mode_x4dev                   : 1;
 	uint64_t bg2_enable                   : 1;
-	uint64_t reserved_63_63               : 1;
+	uint64_t lrdimm_ena                   : 1;
 #endif
 	} s;
 	struct cvmx_lmcx_config_cn61xx {
@@ -3788,6 +4016,200 @@ union cvmx_lmcx_config {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_config_cn70xx        cn70xxp1;
+	struct cvmx_lmcx_config_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t lrdimm_ena                   : 1;  /**< Load Reduced DIMM Enable. When set allows the use of JEDEC DDR4 LRDIMMs. */
+	uint64_t bg2_enable                   : 1;  /**< BG2 pin is active for DDR4 mode. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
+                                                         Typically only cleared for DDR4 *16 devices, where there is no BG2 pin on the device. */
+	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
+	uint64_t mode32b                      : 1;  /**< 32-bit datapath mode. When set, only 32 DQ pins are used. */
+	uint64_t scrz                         : 1;  /**< Hide LMC()_SCRAMBLE_CFG0 and LMC()_SCRAMBLE_CFG1 when set. */
+	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 3 reads.
+                                                         The recommended EARLY_UNLOAD_D1_R1 value can be calculated after the final
+                                                         LMC()_RLEVEL_RANK3[BYTE*] values are selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting for rank 3 (i.e. calculate
+                                                         maxset=MAX(LMC()_RLEVEL_RANK3[BYTEi]) across all i), then set EARLY_UNLOAD_D1_R1 when the
+                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_R1 = (maxset<1:0>
+                                                         !=3)). */
+	uint64_t early_unload_d1_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 2 reads.
+                                                         The recommended EARLY_UNLOAD_D1_RO value can be calculated after the final
+                                                         LMC()_RLEVEL_RANK2[BYTE*] values are selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting for rank 2 (i.e. calculate
+                                                         maxset=MAX(LMC()_RLEVEL_RANK2[BYTEi]) across all i), then set EARLY_UNLOAD_D1_RO when the
+                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_RO = (maxset<1:0>
+                                                         !=3)). */
+	uint64_t early_unload_d0_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 1 reads.
+                                                         The recommended EARLY_UNLOAD_D0_R1 value can be calculated after the final
+                                                         LMC()_RLEVEL_RANK1[BYTE*] values are selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting for rank 1 (i.e. calculate
+                                                         maxset=MAX(LMC()_RLEVEL_RANK1[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R1 when the
+                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R1 = (maxset<1:0>
+                                                         !=3)). */
+	uint64_t early_unload_d0_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 0 reads.
+                                                         The recommended EARLY_UNLOAD_D0_R0 value can be calculated after the final
+                                                         LMC()_RLEVEL_RANK0[BYTE*] values are selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting for rank 0 (i.e. calculate
+                                                         maxset=MAX(LMC()_RLEVEL_RANK0[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R0 when the
+                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R0 = (maxset<1:0>
+                                                         !=3)). */
+	uint64_t init_status                  : 4;  /**< Indicates status of initialization. INIT_STATUS[n] = 1 implies rank n has been
+                                                         initialized.
+                                                         Software must set necessary RANKMASK bits before executing the initialization sequence
+                                                         using LMC()_SEQ_CTL. If the rank has been selected for init with the RANKMASK bits,
+                                                         the INIT_STATUS bits will be set after successful initialization and after self-refresh
+                                                         exit. INIT_STATUS determines the chip-selects that assert during refresh, ZQCS, precharge
+                                                         power-down entry/exit, and self-refresh entry SEQ_SELs. */
+	uint64_t mirrmask                     : 4;  /**< "Mask determining which ranks are address-mirrored.
+                                                         MIRRMASK<n> = 1 means Rank n addresses are mirrored for
+                                                         0 <= n <= 3.
+                                                         In DDR3, a mirrored read/write operation has the following differences:
+                                                         * DDR#_BA<1> is swapped with DDR#_BA<0>.
+                                                         * DDR#_A<8> is swapped with DDR#_A<7>.
+                                                         * DDR#_A<6> is swapped with DDR#_A<5>.
+                                                         * DDR#_A<4> is swapped with DDR#_A<3>.
+                                                         When RANK_ENA = 0, MIRRMASK<1> MBZ.
+                                                         In DDR4, a mirrored read/write operation has the following differences:
+                                                         * DDR#_BG<1> is swapped with DDR#_BG<0>.
+                                                         * DDR#_BA<1> is swapped with DDR#_BA<0>.
+                                                         * DDR#_A<13> is swapped with DDR#_A<11>.
+                                                         * DDR#_A<8> is swapped with DDR#_A<7>.
+                                                         * DDR#_A<6> is swapped with DDR#_A<5>.
+                                                         * DDR#_A<4> is swapped with DDR#_A<3>.
+                                                         For CN70XX, MIRRMASK<3:2> MBZ.
+                                                         * When RANK_ENA = 0, MIRRMASK<1> MBZ." */
+	uint64_t rankmask                     : 4;  /**< Mask to select rank to be leveled/initialized. To write-level/read-level/initialize rank
+                                                         i, set RANKMASK<i>:
+                                                         <pre>
+                                                                       RANK_ENA = 1   RANK_ENA = 0
+                                                         RANKMASK<0> = DIMM0_CS0      DIMM0_CS0
+                                                         RANKMASK<1> = DIMM0_CS1      MBZ
+                                                         RANKMASK<2> = DIMM1_CS0      DIMM1_CS0
+                                                         RANKMASK<3> = DIMM1_CS1      MBZ
+                                                         </pre>
+                                                         For read/write leveling, each rank has to be leveled separately, so RANKMASK should only
+                                                         have one bit set. RANKMASK is not used during self-refresh entry/exit and precharge power-
+                                                         down entry/exit instruction sequences. When RANK_ENA = 0, RANKMASK<1> and RANKMASK<3> MBZ. */
+	uint64_t rank_ena                     : 1;  /**< "RANK enable (for use with dual-rank DIMMs).
+                                                         * For dual-rank DIMMs, the RANK_ENA bit will enable the drive of the DDR#_DIMM*_CS*_L and
+                                                         ODT_<1:0> pins differently based on the (PBANK_LSB - 1) address bit.
+                                                         * Write 0 for SINGLE ranked DIMMs." */
+	uint64_t sref_with_dll                : 1;  /**< Self-refresh entry/exit write mode registers. When set, self-refresh entry sequence writes
+                                                         MR2 and MR1 (in this order, in all ranks), and self-refresh exit sequence writes MR1, MR0,
+                                                         MR2, and MR3 (in this order, for all ranks). The write operations occur before self-
+                                                         refresh entry, and after self-refresh exit. When clear, self-refresh entry and exit
+                                                         instruction sequences do not write any mode registers in the DDR3/4 parts. */
+	uint64_t early_dqx                    : 1;  /**< Set this bit to send DQx signals one CK cycle earlier for the case when the shortest DQx
+                                                         lines have a larger delay than the CK line. */
+	uint64_t ref_zqcs_int                 : 22; /**< Refresh interval is represented in number of 512 CK cycle increments. ZQCS interval is
+                                                         represented in a number of refresh intervals. A refresh sequence is triggered when bits
+                                                         <24:18> are equal to 0x0, and a ZQCS sequence is triggered when <39:18> are equal to 0x0.
+                                                         The ZQCS timer only decrements when the refresh timer is 0.
+                                                         Program <24:18> to RND-DN(TREFI/clkPeriod/512).
+                                                         A value of 0 in bits <24:18> will effectively turn off refresh.
+                                                         Program <36:25> to (RND-DN(ZQCS_Period / Refresh_Period) - 1), where Refresh_Period is the
+                                                         effective period programmed in bits <24:18>. Note that this value should always be greater
+                                                         than 32, to account for resistor calibration delays.
+                                                         000_00000000_0000000: Reserved
+                                                         Max Refresh interval = 127 * 512= 65024 CK cycles.
+                                                         Max ZQCS interval = 32768 * 127 * 512 = 2130706432 CK cycles.
+                                                         If refresh interval is programmed to ~8us, max ZQCS interval is ~262ms, or ~4 ZQCS
+                                                         operations per second.
+                                                         LMC()_CONFIG[INIT_STATUS] determines which ranks receive the REF / ZQCS. LMC does not
+                                                         send any refreshes / ZQCS's when LMC()_CONFIG[INIT_STATUS]=0. */
+	uint64_t reset                        : 1;  /**< Reset one-shot pulse for LMC()_OPS_CNT, LMC()_IFB_CNT, and LMC()_DCLK_CNT
+                                                         CSRs.
+                                                         To cause the reset, software writes this to a 1, then rewrites it to a 0. */
+	uint64_t ecc_adr                      : 1;  /**< Include memory reference address in the ECC calculation.
+                                                         0 = disabled, 1 = enabled. */
+	uint64_t forcewrite                   : 4;  /**< Force the oldest outstanding write to complete after having waited for 2^FORCEWRITE CK
+                                                         cycles. 0 = disabled. */
+	uint64_t idlepower                    : 3;  /**< Enter precharge power-down mode after the memory controller has been idle for
+                                                         2^(2+IDLEPOWER) CK cycles. 0 = disabled.
+                                                         This field should only be programmed after initialization.
+                                                         LMC()_MODEREG_PARAMS0[PPD] determines whether the DRAM DLL is disabled during the
+                                                         precharge power-down. */
+	uint64_t pbank_lsb                    : 4;  /**< DIMM address bit select. Reverting to the explanation for ROW_LSB, PBANK_LSB would be:
+                                                         ROW_LSB bit + num_rowbits + num_rankbits
+                                                         Decoding for PBANK_LSB:
+                                                         0x0: DIMM = mem_adr<28>; if RANK_ENA=1, rank = mem_adr<27>.
+                                                         0x1: DIMM = mem_adr<29>; if RANK_ENA=1, rank = mem_adr<28>.
+                                                         0x2: DIMM = mem_adr<30>; if RANK_ENA=1, rank = mem_adr<29>.
+                                                         0x3: DIMM = mem_adr<31>; if RANK_ENA=1, rank = mem_adr<30>.
+                                                         0x4: DIMM = mem_adr<32>; if RANK_ENA=1, rank = mem_adr<31>.
+                                                         0x5: DIMM = mem_adr<33>; if RANK_ENA=1, rank = mem_adr<32>.
+                                                         0x6: DIMM = mem_adr<34>; if RANK_ENA=1, rank = mem_adr<33>.
+                                                         0x7: DIMM = mem_adr<35>; if RANK_ENA=1, rank = mem_adr<34>.
+                                                         0x8: DIMM = mem_adr<36>; if RANK_ENA=1, rank = mem_adr<35>.
+                                                         0x9: DIMM = mem_adr<37>; if RANK_ENA=1, rank = mem_adr<36>.
+                                                         0xA: DIMM = 0;           if RANK_ENA=1, rank = mem_adr<37>.
+                                                         0xB-0xF: Reserved.
+                                                         For example, for a DIMM made of Samsung's K4B1G0846C-F7 1Gb (16M * 8 bit * 8 bank)
+                                                         parts, the column address width = 10, so with 10b of col, 3b of bus, 3b of bank, ROW_LSB =
+                                                         16. So, row = mem_adr<29:16>.
+                                                         With RANK_ENA = 0, PBANK_LSB = 2.
+                                                         With RANK_ENA = 1, PBANK_LSB = 3.
+                                                         TBD for interfacing with 8H 3DS, regardless of RANK_ENA value, set this 0xA. */
+	uint64_t row_lsb                      : 3;  /**< "Row address bit select.
+                                                         0x0 = Address bit 14 is LSB.
+                                                         0x1 = Address bit 15 is LSB.
+                                                         0x2 = Address bit 16 is LSB.
+                                                         0x3 = Address bit 17 is LSB.
+                                                         0x4 = Address bit 18 is LSB.
+                                                         0x5 = Address bit 19 is LSB.
+                                                         0x6 = Address bit 20 is LSB.
+                                                         0x6 = Reserved.
+                                                         Encoding used to determine which memory address bit position represents the low order DDR
+                                                         ROW address. The processor's memory address<34:7> needs to be translated to DRAM addresses
+                                                         (bnk,row,col,rank and DIMM) and that is a function of the following:
+                                                         * Datapath width (64).
+                                                         * Number of banks (8).
+                                                         * Number of column bits of the memory part--specified indirectly by this register.
+                                                         * Number of row bits of the memory part--specified indirectly by PBANK_LSB.
+                                                         * Number of ranks in a DIMM--specified by RANK_ENA.
+                                                         * Number of DIMMs in the system by the register below (PBANK_LSB).
+                                                         Col address starts from mem_addr[3] for 64b (8Bytes) DQ width. ROW_LSB is mem_adr[15] for
+                                                         64b mode. Therefore, the ROW_LSB parameter should be set to 001 (64b).
+                                                         For example, for a DIMM made of Samsung's K4B1G0846C-F7 1GB (16M * 8 bit * 8 bank)
+                                                         parts, the column address width = 10, so with 10b of col, 3b of bus, 3b of bank, ROW_LSB =
+                                                         16. So, row = mem_adr<29:16>.
+                                                         Refer to Cache-block Read Transaction Example, Cache-block Read Transaction Example." */
+	uint64_t ecc_ena                      : 1;  /**< ECC enable. When set, enables the 8b ECC check/correct logic. Should be 1 when used with
+                                                         DIMMs with ECC; 0, otherwise.
+                                                         * When this mode is turned on, DQ<71:64> on write operations contains the ECC code
+                                                         generated for the 64 bits of data which will be written in the memory. Later on read
+                                                         operations, will be used to check for single-bit error (which will be auto-corrected) and
+                                                         double-bit error (which will be reported).
+                                                         * When not turned on, DQ<71:64> are driven to 0. Please refer to SEC_ERR, DED_ERR,
+                                                         LMC()_FADR, and LMC()_ECC_SYND registers for diagnostics information when there is
+                                                         an error. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t ecc_ena                      : 1;
+	uint64_t row_lsb                      : 3;
+	uint64_t pbank_lsb                    : 4;
+	uint64_t idlepower                    : 3;
+	uint64_t forcewrite                   : 4;
+	uint64_t ecc_adr                      : 1;
+	uint64_t reset                        : 1;
+	uint64_t ref_zqcs_int                 : 22;
+	uint64_t early_dqx                    : 1;
+	uint64_t sref_with_dll                : 1;
+	uint64_t rank_ena                     : 1;
+	uint64_t rankmask                     : 4;
+	uint64_t mirrmask                     : 4;
+	uint64_t init_status                  : 4;
+	uint64_t early_unload_d0_r0           : 1;
+	uint64_t early_unload_d0_r1           : 1;
+	uint64_t early_unload_d1_r0           : 1;
+	uint64_t early_unload_d1_r1           : 1;
+	uint64_t scrz                         : 1;
+	uint64_t mode32b                      : 1;
+	uint64_t mode_x4dev                   : 1;
+	uint64_t bg2_enable                   : 1;
+	uint64_t lrdimm_ena                   : 1;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_config_cn70xx        cn78xx;
 	struct cvmx_lmcx_config_cn61xx        cnf71xx;
 };
@@ -4200,6 +4622,7 @@ union cvmx_lmcx_control {
 	struct cvmx_lmcx_control_cn68xx       cn68xxp1;
 	struct cvmx_lmcx_control_s            cn70xx;
 	struct cvmx_lmcx_control_s            cn70xxp1;
+	struct cvmx_lmcx_control_s            cn73xx;
 	struct cvmx_lmcx_control_s            cn78xx;
 	struct cvmx_lmcx_control_cn66xx       cnf71xx;
 };
@@ -5053,6 +5476,86 @@ union cvmx_lmcx_ctl1 {
 typedef union cvmx_lmcx_ctl1 cvmx_lmcx_ctl1_t;
 
 /**
+ * cvmx_lmc#_dbtrain_ctl
+ *
+ * This register contains control bits that are used during the Data Buffer
+ * training sequence in DDR4 LRDIMM mode. When one of the data buffer training
+ * sequence is initiated, it uses the contents of this register to control
+ * its operation.
+ */
+union cvmx_lmcx_dbtrain_ctl {
+	uint64_t u64;
+	struct cvmx_lmcx_dbtrain_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t db_output_impedance          : 3;  /**< Host Interface DQ/DQS Output Driver Impedance control.
+                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
+                                                         environment, i.e., CONFIG[LRDIMM_ENA] = 1, SEQ_CTL[SEQ_SEL] = 0x6.
+                                                         0x0 = RZQ/6 (40 ohm).
+                                                         0x1 = RZQ/7 (34 ohm).
+                                                         0x2 = RZQ/5 (48 ohm).
+                                                         0x3-0x7 = Reserved. */
+	uint64_t db_sel                       : 1;  /**< Used when running Host Interface Write Leveling.
+                                                         0 = selects DIMM0's Data Buffer.
+                                                         1 = selects DIMM1's Data Buffer. */
+	uint64_t tccd_sel                     : 1;  /**< When set, the sequence uses MODEREG_PARAMS3[TCCD_L] to space out
+                                                         back-to-back read commands. Otherwise it will space out back-to-back
+                                                         reads with a default value of 4 cycles.
+                                                         While in DRAM MPR mode, reads from Page 0 may use tCCD_S or tCCD_L.
+                                                         Reads from Pages 1, 2 or 3 however must use tCCD_L, thereby requring
+                                                         this bit to be set. */
+	uint64_t rw_train                     : 1;  /**< When set, the DBTRAIN sequence will perform a Write to the DRAM
+                                                         memory array using burst patern that are set in the CSRs
+                                                         LMC()_GENERAL_PURPOSE0[DATA]<61:0>, LMC()_GENERAL_PURPOSE1[DATA]<61:0> and
+                                                         LMC()_GENERAL_PURPOSE2[DATA]<15:0>.
+                                                         This burst pattern gets shifted by one byte at every cycle.
+                                                         The sequence will then do the reads to the same location and compare
+                                                         the data coming back with this pattern.
+                                                         The bit-wise comparison result gets stored in
+                                                         LMC()_MPR_DATA0[MPR_DATA]<63:0> and LMC()_MPR_DATA1[MPR_DATA]<7:0>. */
+	uint64_t read_dq_count                : 7;  /**< The amount of cycles until a pulse is issued to sample the DQ into the
+                                                         MPR register. This bits control the timing of when to sample the data
+                                                         buffer training result. */
+	uint64_t read_cmd_count               : 5;  /**< The amount of Read Commands to be sent during the data buffer training.
+                                                         This can be set to zero in which case the sequence does not send any
+                                                         Read commands to accommodate for the DWL training mode. */
+	uint64_t write_ena                    : 1;  /**< Enables the write operation. This is mainly used to accomplish the MWD
+                                                         training sequence of the data buffer.
+                                                         DBTRAIN_CTL[ACTIVATE] must be set to 1 for this to take effect. */
+	uint64_t activate                     : 1;  /**< Enables the activate command during the data buffer training sequence. */
+	uint64_t prank                        : 2;  /**< Physical Rank bits for Read/Write/Activate operation during the data buffer
+                                                         training. */
+	uint64_t lrank                        : 3;  /**< Logical Rank bits for Read/Write/Activate operation during the data buffer
+                                                         training. */
+	uint64_t row_a                        : 18; /**< The row address for the Activate command during dbtrain. */
+	uint64_t bg                           : 2;  /**< The Bank Group that the commands are directed to while in data buffer
+                                                         training sequence. */
+	uint64_t ba                           : 2;  /**< The bank address for the commands while in data buffer training sequence. */
+	uint64_t column_a                     : 13; /**< Column address for the Read/Write operation during the data buffer
+                                                         training. */
+#else
+	uint64_t column_a                     : 13;
+	uint64_t ba                           : 2;
+	uint64_t bg                           : 2;
+	uint64_t row_a                        : 18;
+	uint64_t lrank                        : 3;
+	uint64_t prank                        : 2;
+	uint64_t activate                     : 1;
+	uint64_t write_ena                    : 1;
+	uint64_t read_cmd_count               : 5;
+	uint64_t read_dq_count                : 7;
+	uint64_t rw_train                     : 1;
+	uint64_t tccd_sel                     : 1;
+	uint64_t db_sel                       : 1;
+	uint64_t db_output_impedance          : 3;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} s;
+	struct cvmx_lmcx_dbtrain_ctl_s        cn73xx;
+};
+typedef union cvmx_lmcx_dbtrain_ctl cvmx_lmcx_dbtrain_ctl_t;
+
+/**
  * cvmx_lmc#_dclk_cnt
  *
  * LMC_DCLK_CNT  = Performance Counters
@@ -5076,6 +5579,7 @@ union cvmx_lmcx_dclk_cnt {
 	struct cvmx_lmcx_dclk_cnt_s           cn68xxp1;
 	struct cvmx_lmcx_dclk_cnt_s           cn70xx;
 	struct cvmx_lmcx_dclk_cnt_s           cn70xxp1;
+	struct cvmx_lmcx_dclk_cnt_s           cn73xx;
 	struct cvmx_lmcx_dclk_cnt_s           cn78xx;
 	struct cvmx_lmcx_dclk_cnt_s           cnf71xx;
 };
@@ -5431,14 +5935,50 @@ typedef union cvmx_lmcx_ddr2_ctl cvmx_lmcx_ddr2_ctl_t;
 /**
  * cvmx_lmc#_ddr4_dimm_ctl
  *
- * This register is used only when LMC(0..3)_CONTROL[RDIMM_ENA] = 1. During an RCW initialization
- * sequence, this register controls LMC's write operations to the extended DDR4 control words in
- * the JEDEC standard registering clock driver on an RDIMM.
+ * Bits 0-21 of this register is used only when LMC()_CONTROL[RDIMM_ENA] = 1.
+ *
+ * Bits 22-27 is used only when LMC()_CONFIG[LRDIMM_ENA] = 1 AND
+ * LMC()_MR_MPR_CTL[MR_WR_PBA_ENABLE] = 1.
+ *
+ * During an RCW initialization sequence, bits 0-21 controls LMC's write
+ * operations to the extended DDR4 control words in the JEDEC standard
+ * registering clock driver on an RDIMM.
+ *
+ * During PBA mode of an MRW sequence, bits 22-27 controls the Buffer Configuration
+ * Control Word F0BC1x settings during the BCW write.
  */
 union cvmx_lmcx_ddr4_dimm_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_ddr4_dimm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_28_63               : 36;
+	uint64_t rank_timing_enable           : 1;  /**< Package Rank Timing Alignment Enable bit for the DDR4 LRDIMM Buffer Configuration Control
+                                                         Word F0BC1x DA[7]. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t bodt_trans_mode              : 1;  /**< BODT input handling in Transparent Mode for the DDR4 LRDIMM Buffer Conifguration Control
+                                                         Word F0BC1x. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t trans_mode_ena               : 1;  /**< Transparent Mode Enable bit for DDR4 LRDIMM Buffer Configuration Control Word
+                                                         F0BC1x DA[5]. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t read_preamble_mode           : 1;  /**< Read Preamble Training Mode Enable bit for DDR4 LRDIMM Buffer Configuration Control Word
+                                                         F0BC1x DA[4]. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t buff_config_da3              : 1;  /**< Reserved setting value in F0BC1x DA3. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t mpr_over_ena                 : 1;  /**< MPR Override Mode Enable bit for the DDR4 LRDIMM Buffer Configuration Control Word
+                                                         F0BC1x DA[1]. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t ddr4_dimm1_wmask             : 11; /**< DIMM1 write mask. If (DIMM1_WMASK[n] = 1), write DIMM1.RCn. */
+	uint64_t ddr4_dimm0_wmask             : 11; /**< DIMM0 write mask. If (DIMM0_WMASK[n] = 1), write DIMM0.RCn. */
+#else
+	uint64_t ddr4_dimm0_wmask             : 11;
+	uint64_t ddr4_dimm1_wmask             : 11;
+	uint64_t mpr_over_ena                 : 1;
+	uint64_t buff_config_da3              : 1;
+	uint64_t read_preamble_mode           : 1;
+	uint64_t trans_mode_ena               : 1;
+	uint64_t bodt_trans_mode              : 1;
+	uint64_t rank_timing_enable           : 1;
+	uint64_t reserved_28_63               : 36;
+#endif
+	} s;
+	struct cvmx_lmcx_ddr4_dimm_ctl_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_22_63               : 42;
 	uint64_t ddr4_dimm1_wmask             : 11; /**< DIMM1 write mask. If (DIMM1_WMASK[n] = 1), write DIMM1.RCn. */
 	uint64_t ddr4_dimm0_wmask             : 11; /**< DIMM0 write mask. If (DIMM0_WMASK[n] = 1), write DIMM0.RCn. */
@@ -5447,10 +5987,10 @@ union cvmx_lmcx_ddr4_dimm_ctl {
 	uint64_t ddr4_dimm1_wmask             : 11;
 	uint64_t reserved_22_63               : 42;
 #endif
-	} s;
-	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn70xx;
-	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn70xxp1;
-	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn78xx;
+	} cn70xx;
+	struct cvmx_lmcx_ddr4_dimm_ctl_cn70xx cn70xxp1;
+	struct cvmx_lmcx_ddr4_dimm_ctl_s      cn73xx;
+	struct cvmx_lmcx_ddr4_dimm_ctl_cn70xx cn78xx;
 };
 typedef union cvmx_lmcx_ddr4_dimm_ctl cvmx_lmcx_ddr4_dimm_ctl_t;
 
@@ -5482,7 +6022,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_ddr_pll_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_44_63               : 20;
+	uint64_t reserved_45_63               : 19;
+	uint64_t dclk_alt_refclk_sel          : 1;  /**< Select alternate reference clock for DCLK PLL. */
 	uint64_t bwadj                        : 12; /**< Bandwidth control for DCLK PLLs. */
 	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
 	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC()_DDR_PLL_CTL[DDR4_MODE]. */
@@ -5511,7 +6052,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t phy_dcok                     : 1;
 	uint64_t dclk_invert                  : 1;
 	uint64_t bwadj                        : 12;
-	uint64_t reserved_44_63               : 20;
+	uint64_t dclk_alt_refclk_sel          : 1;
+	uint64_t reserved_45_63               : 19;
 #endif
 	} s;
 	struct cvmx_lmcx_ddr_pll_ctl_cn61xx {
@@ -5630,6 +6172,69 @@ union cvmx_lmcx_ddr_pll_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_ddr_pll_ctl_cn70xx   cn70xxp1;
+	struct cvmx_lmcx_ddr_pll_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_45_63               : 19;
+	uint64_t dclk_alt_refclk_sel          : 1;  /**< Select alternate reference clock for DCLK PLL. */
+	uint64_t bwadj                        : 12; /**< Bandwidth control for DCLK PLLs. */
+	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
+	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC()_DDR_PLL_CTL[DDR4_MODE]. */
+	uint64_t ddr4_mode                    : 1;  /**< DDR4 mode select: 1 = DDR4, 0 = DDR3. */
+	uint64_t pll_fbslip                   : 1;  /**< PLL FBSLIP indication. */
+	uint64_t pll_lock                     : 1;  /**< PLL LOCK indication. */
+	uint64_t pll_rfslip                   : 1;  /**< PLL RFSLIP indication. */
+	uint64_t clkr                         : 2;  /**< PLL post-divider control. */
+	uint64_t jtg_test_mode                : 1;  /**< Reserved; must be zero. INTERNAL: JTAG test mode. Clock alignment between DCLK & REFCLK as
+                                                         well as FCLK & REFCLK can only be performed after the ddr_pll_divider_reset is deasserted.
+                                                         SW need to wait at least 10 reference clock cycles after deasserting pll_divider_reset
+                                                         before asserting LMC()_DDR_PLL_CTL[JTG_TEST_MODE]. During alignment (which can take up
+                                                         to 160 microseconds) DCLK and FCLK can exhibit some high-frequency pulses. Therefore, all
+                                                         bring up activities in that clock domain need to be delayed (when the chip operates in
+                                                         jtg_test_mode) by about 160 microseconds to ensure that lock is achieved. */
+	uint64_t ddr_div_reset                : 1;  /**< DDR postscalar divider reset. */
+	uint64_t ddr_ps_en                    : 4;  /**< DDR postscalar divide ratio. Determines the LMC CK speed.
+                                                         0x0 = divide LMC PLL by 1.
+                                                         0x1 = divide LMC PLL by 2.
+                                                         0x2 = divide LMC PLL by 3.
+                                                         0x3 = divide LMC PLL by 4.
+                                                         0x4 = divide LMC PLL by 5.
+                                                         0x5 = divide LMC PLL by 6.
+                                                         0x6 = divide LMC PLL by 7.
+                                                         0x7 = divide LMC PLL by 8.
+                                                         0x8 = divide LMC PLL by 10.
+                                                         0x9 = divide LMC PLL by 12.
+                                                         0xA = Reserved.
+                                                         0xB = Reserved.
+                                                         0xC = Reserved.
+                                                         0xD = Reserved.
+                                                         0xE = Reserved.
+                                                         0xF = Reserved.
+                                                         DDR_PS_EN is not used when DDR_DIV_RESET = 1. */
+	uint64_t reserved_9_17                : 9;
+	uint64_t clkf_ext                     : 1;  /**< A 1-bit extension to the CLKF register to support for DDR4-2666. */
+	uint64_t reset_n                      : 1;  /**< PLL reset */
+	uint64_t clkf                         : 7;  /**< Multiply reference by CLKF. 32 <= CLKF <= 64. LMC PLL frequency = 50 * CLKF. min = 1.6
+                                                         GHz, max = 3.2 GHz. */
+#else
+	uint64_t clkf                         : 7;
+	uint64_t reset_n                      : 1;
+	uint64_t clkf_ext                     : 1;
+	uint64_t reserved_9_17                : 9;
+	uint64_t ddr_ps_en                    : 4;
+	uint64_t ddr_div_reset                : 1;
+	uint64_t jtg_test_mode                : 1;
+	uint64_t clkr                         : 2;
+	uint64_t pll_rfslip                   : 1;
+	uint64_t pll_lock                     : 1;
+	uint64_t pll_fbslip                   : 1;
+	uint64_t ddr4_mode                    : 1;
+	uint64_t phy_dcok                     : 1;
+	uint64_t dclk_invert                  : 1;
+	uint64_t bwadj                        : 12;
+	uint64_t dclk_alt_refclk_sel          : 1;
+	uint64_t reserved_45_63               : 19;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_ddr_pll_ctl_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
@@ -5791,6 +6396,7 @@ union cvmx_lmcx_dimmx_ddr4_params0 {
 	} s;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn70xx;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn70xxp1;
+	struct cvmx_lmcx_dimmx_ddr4_params0_s cn73xx;
 	struct cvmx_lmcx_dimmx_ddr4_params0_s cn78xx;
 };
 typedef union cvmx_lmcx_dimmx_ddr4_params0 cvmx_lmcx_dimmx_ddr4_params0_t;
@@ -5818,6 +6424,7 @@ union cvmx_lmcx_dimmx_ddr4_params1 {
 	} s;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn70xx;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn70xxp1;
+	struct cvmx_lmcx_dimmx_ddr4_params1_s cn73xx;
 	struct cvmx_lmcx_dimmx_ddr4_params1_s cn78xx;
 };
 typedef union cvmx_lmcx_dimmx_ddr4_params1 cvmx_lmcx_dimmx_ddr4_params1_t;
@@ -5879,6 +6486,7 @@ union cvmx_lmcx_dimmx_params {
 	struct cvmx_lmcx_dimmx_params_s       cn68xxp1;
 	struct cvmx_lmcx_dimmx_params_s       cn70xx;
 	struct cvmx_lmcx_dimmx_params_s       cn70xxp1;
+	struct cvmx_lmcx_dimmx_params_s       cn73xx;
 	struct cvmx_lmcx_dimmx_params_s       cn78xx;
 	struct cvmx_lmcx_dimmx_params_s       cnf71xx;
 };
@@ -5936,6 +6544,7 @@ union cvmx_lmcx_dimm_ctl {
 	struct cvmx_lmcx_dimm_ctl_s           cn68xxp1;
 	struct cvmx_lmcx_dimm_ctl_s           cn70xx;
 	struct cvmx_lmcx_dimm_ctl_s           cn70xxp1;
+	struct cvmx_lmcx_dimm_ctl_s           cn73xx;
 	struct cvmx_lmcx_dimm_ctl_s           cn78xx;
 	struct cvmx_lmcx_dimm_ctl_s           cnf71xx;
 };
@@ -6095,6 +6704,7 @@ union cvmx_lmcx_dll_ctl2 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_dll_ctl2_cn70xx      cn70xxp1;
+	struct cvmx_lmcx_dll_ctl2_cn70xx      cn73xx;
 	struct cvmx_lmcx_dll_ctl2_cn70xx      cn78xx;
 	struct cvmx_lmcx_dll_ctl2_cn61xx      cnf71xx;
 };
@@ -6110,9 +6720,20 @@ union cvmx_lmcx_dll_ctl3 {
 	uint64_t u64;
 	struct cvmx_lmcx_dll_ctl3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_0_63                : 64;
-#else
-	uint64_t reserved_0_63                : 64;
+	uint64_t reserved_50_63               : 14;
+	uint64_t wr_deskew_ena                : 1;  /**< When set, it enables the write bit deskew feature. */
+	uint64_t wr_deskew_ld                 : 1;  /**< When set, the bit deskew settings in DLL_CTL3[OFFSET] gets loaded to
+                                                         the designated byte DLL_CTL3[BYTE_SEL] and bit DLL_CTL3[BIT_SELECT]
+                                                         for write bit deskew. This is a oneshot and clears itself each time
+                                                         it is set. */
+	uint64_t bit_select                   : 4;  /**< Selects specific DQ bit in byte DLL_CTL3[BYTE_SEL] for write bit deskew. */
+	uint64_t reserved_0_43                : 44;
+#else
+	uint64_t reserved_0_43                : 44;
+	uint64_t bit_select                   : 4;
+	uint64_t wr_deskew_ld                 : 1;
+	uint64_t wr_deskew_ena                : 1;
+	uint64_t reserved_50_63               : 14;
 #endif
 	} s;
 	struct cvmx_lmcx_dll_ctl3_cn61xx {
@@ -6296,6 +6917,64 @@ union cvmx_lmcx_dll_ctl3 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_dll_ctl3_cn70xx      cn70xxp1;
+	struct cvmx_lmcx_dll_ctl3_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_50_63               : 14;
+	uint64_t wr_deskew_ena                : 1;  /**< When set, it enables the write bit deskew feature. */
+	uint64_t wr_deskew_ld                 : 1;  /**< When set, the bit deskew settings in DLL_CTL3[OFFSET] gets loaded to
+                                                         the designated byte DLL_CTL3[BYTE_SEL] and bit DLL_CTL3[BIT_SELECT]
+                                                         for write bit deskew. This is a oneshot and clears itself each time
+                                                         it is set. */
+	uint64_t bit_select                   : 4;  /**< Selects specific DQ bit in byte DLL_CTL3[BYTE_SEL] for write bit deskew. */
+	uint64_t dclk90_fwd                   : 1;  /**< Reserved; must be zero. INTERNAL: Generate a one cycle pulse to forward setting. This is a
+                                                         oneshot and clears itself each time it is set. */
+	uint64_t ddr_90_dly_byp               : 1;  /**< Reserved; must be zero. INTERNAL: Bypass DDR90_DLY in clock tree. */
+	uint64_t dclk90_recal_dis             : 1;  /**< Disable periodic recalibration of DDR90 delay line in. */
+	uint64_t dclk90_byp_sel               : 1;  /**< Bypass setting select for DDR90 delay line. */
+	uint64_t dclk90_byp_setting           : 9;  /**< Bypass setting for DDR90 delay line. */
+	uint64_t dll_fast                     : 1;  /**< Reserved; must be zero. INTERNAL: DLL lock, 0=DLL locked. */
+	uint64_t dll90_setting                : 9;  /**< Reserved; must be zero. INTERNAL: Encoded DLL settings. Works in conjunction with
+                                                         DLL90_BYTE_SEL. */
+	uint64_t fine_tune_mode               : 1;  /**< DLL fine tune mode. 0 = disabled; 1 = enable. When enabled, calibrate internal PHY DLL
+                                                         every LMC()_CONFIG[REF_ZQCS_INT] CK cycles. */
+	uint64_t dll_mode                     : 1;  /**< Reserved; must be zero. INTERNAL: DLL mode. */
+	uint64_t dll90_byte_sel               : 4;  /**< Observe DLL settings for selected byte.
+                                                         0x0 = byte 0.
+                                                         0x1 = byte 1.
+                                                         - ...
+                                                         0x8: byte 8.
+                                                         0x9-0xF: reserved. */
+	uint64_t offset_ena                   : 1;  /**< Reserved; must be zero. INTERNAL: Offset enable. 1=enable. */
+	uint64_t load_offset                  : 1;  /**< Reserved; must be zero. INTERNAL: Load offset. 0=disable, 1=generate a one cycle pulse to
+                                                         the PHY. This field is a oneshot and clears itself each time it is set. */
+	uint64_t mode_sel                     : 2;  /**< Reserved; must be zero. INTERNAL: Mode select. 0x0 = reset, 0x1 = write, 0x2 = read, 0x3 =
+                                                         write and read. */
+	uint64_t byte_sel                     : 4;  /**< Reserved; must be zero. INTERNAL: Byte select. 0x0 = no byte, 0x1 = byte 0, ..., 0x9 =
+                                                         byte 8, 0xA = all bytes, 0xB-0xF = Reserved. */
+	uint64_t offset                       : 7;  /**< Reserved; must be zero. INTERNAL: Write/read offset setting. <5:0>: offset (not
+                                                         two's-complement), <5>: 0 = increment, 1 = decrement. */
+#else
+	uint64_t offset                       : 7;
+	uint64_t byte_sel                     : 4;
+	uint64_t mode_sel                     : 2;
+	uint64_t load_offset                  : 1;
+	uint64_t offset_ena                   : 1;
+	uint64_t dll90_byte_sel               : 4;
+	uint64_t dll_mode                     : 1;
+	uint64_t fine_tune_mode               : 1;
+	uint64_t dll90_setting                : 9;
+	uint64_t dll_fast                     : 1;
+	uint64_t dclk90_byp_setting           : 9;
+	uint64_t dclk90_byp_sel               : 1;
+	uint64_t dclk90_recal_dis             : 1;
+	uint64_t ddr_90_dly_byp               : 1;
+	uint64_t dclk90_fwd                   : 1;
+	uint64_t bit_select                   : 4;
+	uint64_t wr_deskew_ld                 : 1;
+	uint64_t wr_deskew_ena                : 1;
+	uint64_t reserved_50_63               : 14;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_dll_ctl3_cn70xx      cn78xx;
 	struct cvmx_lmcx_dll_ctl3_cn61xx      cnf71xx;
 };
@@ -6393,6 +7072,7 @@ union cvmx_lmcx_dual_memcfg {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_dual_memcfg_cn70xx   cn70xxp1;
+	struct cvmx_lmcx_dual_memcfg_cn70xx   cn73xx;
 	struct cvmx_lmcx_dual_memcfg_cn70xx   cn78xx;
 	struct cvmx_lmcx_dual_memcfg_cn61xx   cnf71xx;
 };
@@ -6430,6 +7110,7 @@ union cvmx_lmcx_ecc_parity_test {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_lmcx_ecc_parity_test_s    cn73xx;
 	struct cvmx_lmcx_ecc_parity_test_s    cn78xx;
 };
 typedef union cvmx_lmcx_ecc_parity_test cvmx_lmcx_ecc_parity_test_t;
@@ -6492,6 +7173,7 @@ union cvmx_lmcx_ecc_synd {
 	struct cvmx_lmcx_ecc_synd_s           cn68xxp1;
 	struct cvmx_lmcx_ecc_synd_s           cn70xx;
 	struct cvmx_lmcx_ecc_synd_s           cn70xxp1;
+	struct cvmx_lmcx_ecc_synd_s           cn73xx;
 	struct cvmx_lmcx_ecc_synd_s           cn78xx;
 	struct cvmx_lmcx_ecc_synd_s           cnf71xx;
 };
@@ -6507,7 +7189,55 @@ union cvmx_lmcx_ext_config {
 	uint64_t u64;
 	struct cvmx_lmcx_ext_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_49_63               : 15;
+	uint64_t reserved_60_63               : 4;
+	uint64_t ref_block                    : 1;  /**< When set, LMC is blocked to initiate any refresh sequence. LMC then will only
+                                                         allow refresh sequence to start when LMC()_REF_STATUS[REF_COUNT] has
+                                                         reached the maximum value of 0x7. */
+	uint64_t mrs_side                     : 1;  /**< Only applies when EXT_CONFIG[MRS_ONE_SIDE] is set.
+                                                         0 = MRS command is sent to the A side of an RDIMM/LRDIMM.
+                                                         1 = MRS command is sent to the B side of an RDIMM/LRDIMM. */
+	uint64_t mrs_one_side                 : 1;  /**< Only applies to DDR4 RDIMM/LRDIMM.
+                                                         When set, MRS commands are directed to either the A or B
+                                                         side of the RCD.
+                                                         PDA operation is NOT allowed when this bit is set. In
+                                                         other words, MR_MPR_CTL[MR_WR_PDA_ENABLE]
+                                                         must be cleared before running MRW sequence with this
+                                                         bit turned on. */
+	uint64_t mrs_bside_invert_disable     : 1;  /**< When set, the command decoder cancels the auto inversion of
+                                                         A3-A9, A11, A13, A17, BA0, BA1 and BG0 during MRS/MRS_PDA
+                                                         command to the B side of the RDIMM/LRDIMM.
+                                                         When set, make sure that the RCD's control word
+                                                         RC00 DA[0] = 1 so that the output inversion is disabled in
+                                                         the DDR4 RCD. */
+	uint64_t dimm_sel_invert_off          : 1;  /**< During coalesce_address_mode, the default logic would be to invert
+                                                         the pbank bit whenever NXM[MEM_MSB_D1_R0] > NXM[MEM_MSB_D0_R0].
+                                                         When this bit is set to 1, it disables this default behaviour.
+                                                         This configuration has lower priority compared to
+                                                         DIMM_SEL_FORCE_INVERT. */
+	uint64_t dimm_sel_force_invert        : 1;  /**< When set to 1, this bit forces the pbank bit to be inverted
+                                                         when in coalesce_address_mode. That is, pbank value of 0 selects
+                                                         DIMM1 instead of DIMM0.
+                                                         Intended to be use for the case of DIMM1 having bigger rank/s
+                                                         than DIMM0. This bit has priority over DIMM_SEL_INVERT_OFF. */
+	uint64_t coalesce_address_mode        : 1;  /**< When set to 1, this bit enables LMC to coalesce the cache-line
+                                                         address space into the DRAMs' address.
+                                                         INTERNAL: FIXME - more explanation */
+	uint64_t dimm1_cid                    : 2;  /**< DIMM1 configuration bits that represent the number of Chip
+                                                         ID of the DRAM. This value is use for decoding address
+                                                         as well as routing Chip IDs to the appropriate output
+                                                         pins.
+                                                         0x0 = 0 Chip ID  (Mono-Die stack).
+                                                         0x1 = 1 Chip ID  (2H 3DS).
+                                                         0x2 = 2 Chip IDs (4H 3DS).
+                                                         0x3 = 3 Chip IDs (8H 3DS). */
+	uint64_t dimm0_cid                    : 2;  /**< DIMM0 configuration bits that represent the number of Chip
+                                                         ID of the DRAM. This value is use for decoding address
+                                                         as well as routing Chip IDs to the appropriate output
+                                                         pins.
+                                                         0x0 = 0 Chip ID  (Mono-Die stack).
+                                                         0x1 = 1 Chip ID  (2H 3DS).
+                                                         0x2 = 2 Chip IDs (4H 3DS).
+                                                         0x3 = 3 Chip IDs (8H 3DS). */
 	uint64_t rcd_parity_check             : 1;  /**< Enables the one cycle delay of the CA parity output. This MUST be set to 1 when using DDR4
                                                          RDIMM AND parity checking in RCD is enabled (RC0E DA0 = 1). Set this to 0 otherwise.
                                                          To enable the parity checking in RCD, set this bit first BEFORE issuing the RCW write RC0E
@@ -6598,7 +7328,16 @@ union cvmx_lmcx_ext_config {
 	uint64_t error_alert_n_sample         : 1;
 	uint64_t reserved_46_47               : 2;
 	uint64_t rcd_parity_check             : 1;
-	uint64_t reserved_49_63               : 15;
+	uint64_t dimm0_cid                    : 2;
+	uint64_t dimm1_cid                    : 2;
+	uint64_t coalesce_address_mode        : 1;
+	uint64_t dimm_sel_force_invert        : 1;
+	uint64_t dimm_sel_invert_off          : 1;
+	uint64_t mrs_bside_invert_disable     : 1;
+	uint64_t mrs_one_side                 : 1;
+	uint64_t mrs_side                     : 1;
+	uint64_t ref_block                    : 1;
+	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
 	struct cvmx_lmcx_ext_config_cn70xx {
@@ -6640,11 +7379,158 @@ union cvmx_lmcx_ext_config {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_ext_config_cn70xx    cn70xxp1;
-	struct cvmx_lmcx_ext_config_s         cn78xx;
+	struct cvmx_lmcx_ext_config_s         cn73xx;
+	struct cvmx_lmcx_ext_config_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_49_63               : 15;
+	uint64_t rcd_parity_check             : 1;  /**< Enables the one cycle delay of the CA parity output. This MUST be set to 1 when using DDR4
+                                                         RDIMM AND parity checking in RCD is enabled (RC0E DA0 = 1). Set this to 0 otherwise.
+                                                         To enable the parity checking in RCD, set this bit first BEFORE issuing the RCW write RC0E
+                                                         DA0 = 1. */
+	uint64_t reserved_46_47               : 2;
+	uint64_t error_alert_n_sample         : 1;  /**< Read to get a sample of the DDR*_ERROR_ALERT_L signal. */
+	uint64_t ea_int_polarity              : 1;  /**< Set to invert DDR*_ERROR_ALERT_L interrupt polarity. When clear, interrupt is signaled on
+                                                         the rising edge of DDR*_ERROR_ALERT_L. When set, interrupt is signalled on the falling
+                                                         edge of DDR*_ERROR_ALERT_L. */
+	uint64_t reserved_43_43               : 1;
+	uint64_t par_addr_mask                : 3;  /**< Mask applied to parity for address bits 14, 13, and 12. Clear to exclude these address
+                                                         bits from the parity calculation, necessary if the DRAM device does not have these pins. */
+	uint64_t reserved_38_39               : 2;
+	uint64_t mrs_cmd_override             : 1;  /**< Set to override behavior of MRS and RCS DRAM operations. */
+	uint64_t mrs_cmd_select               : 1;  /**< When MRS_CMD_OVERRIDE is set, use this bit to select which style of operation for MRS and
+                                                         RCW commands.
+                                                         If this bit is clear, select operation where signals other than CS are active before and
+                                                         after the CS_N active cycle.
+                                                         When this bit is set, select the operation where the other command signals (DDR*_RAS_L,
+                                                         DDR*_CAS_L, DDR*_WE_L, DDR*_A<15:0>, etc) all are active only during the cycle where the
+                                                         CS_N is also active. */
+	uint64_t reserved_33_35               : 3;
+	uint64_t invert_data                  : 1;  /**< Set this bit to cause all data to be inverted before writing or reading to/from DRAM. This
+                                                         effectively uses the scramble logic to instead invert all the data, so this bit must not
+                                                         be set if data scrambling is enabled. May be useful if data inversion will result in lower
+                                                         power. */
+	uint64_t reserved_30_31               : 2;
+	uint64_t cmd_rti                      : 1;  /**< Set this bit to change the behavior of the LMC to return to a completely idle command (no
+                                                         CS active, no command pins active, and address/bank address/bank group all low) on the
+                                                         interface after an active command, rather than only forcing the CS inactive between
+                                                         commands. */
+	uint64_t cal_ena                      : 1;  /**< Set to cause LMC to operate in CAL mode. First set LMC()_MODEREG_PARAMS3[CAL], then
+                                                         set CAL_ENA. */
+	uint64_t reserved_27_27               : 1;
+	uint64_t par_include_a17              : 1;  /**< If set, include A17 in parity calculations in DDR4 mode. */
+	uint64_t par_include_bg1              : 1;  /**< If set, include BG1 in parity calculations in DDR4 mode. */
+	uint64_t gen_par                      : 1;  /**< Enable parity generation in the DRAM commands; must be set prior to enabling parity in
+                                                         register or DRAM devices. */
+	uint64_t reserved_21_23               : 3;
+	uint64_t vrefint_seq_deskew           : 1;  /**< Personality bit to change the operation of what is normally the internal Vref training
+                                                         sequence into the deskew training sequence. */
+	uint64_t read_ena_bprch               : 1;  /**< Enable pad receiver one cycle longer than normal during read operations. */
+	uint64_t read_ena_fprch               : 1;  /**< Enable pad receiver starting one cycle earlier than normal during read operations. */
+	uint64_t slot_ctl_reset_force         : 1;  /**< Write 1 to reset the slot-control override for all slot-control registers. After writing a
+                                                         1 to this bit, slot-control registers will update with changes made to other timing-
+                                                         control registers. This is a one-shot operation; it automatically returns to 0 after a
+                                                         write to 1. */
+	uint64_t ref_int_lsbs                 : 9;  /**< Refresh-interval value least-significant bits. The default is 0x0; but it can be set to a
+                                                         non-zero value to get a more precise refresh interval. */
+	uint64_t drive_ena_bprch              : 1;  /**< Drive DQx for one cycle longer than normal during write operations. */
+	uint64_t drive_ena_fprch              : 1;  /**< Drive DQX starting one cycle earlier than normal during write operations. */
+	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. INTERNAL: DLC RAM flip syndrome control bits. */
+	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. INTERNAL: DLC RAM correction disable control. */
+	uint64_t dlc_nxm_rd                   : 1;  /**< When set, enable NXM events for HFA read operations. INTERNAL: Default is disabled, but
+                                                         could be useful for debug of DLC/DFA accesses. */
+	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. INTERNAL: Default is disabled as L2C
+                                                         NXM read operations are possible and expected during normal operation. */
+	uint64_t l2c_nxm_wr                   : 1;  /**< When set, enable NXM events for L2C write operations. */
+#else
+	uint64_t l2c_nxm_wr                   : 1;
+	uint64_t l2c_nxm_rd                   : 1;
+	uint64_t dlc_nxm_rd                   : 1;
+	uint64_t dlcram_cor_dis               : 1;
+	uint64_t dlcram_flip_synd             : 2;
+	uint64_t drive_ena_fprch              : 1;
+	uint64_t drive_ena_bprch              : 1;
+	uint64_t ref_int_lsbs                 : 9;
+	uint64_t slot_ctl_reset_force         : 1;
+	uint64_t read_ena_fprch               : 1;
+	uint64_t read_ena_bprch               : 1;
+	uint64_t vrefint_seq_deskew           : 1;
+	uint64_t reserved_21_23               : 3;
+	uint64_t gen_par                      : 1;
+	uint64_t par_include_bg1              : 1;
+	uint64_t par_include_a17              : 1;
+	uint64_t reserved_27_27               : 1;
+	uint64_t cal_ena                      : 1;
+	uint64_t cmd_rti                      : 1;
+	uint64_t reserved_30_31               : 2;
+	uint64_t invert_data                  : 1;
+	uint64_t reserved_33_35               : 3;
+	uint64_t mrs_cmd_select               : 1;
+	uint64_t mrs_cmd_override             : 1;
+	uint64_t reserved_38_39               : 2;
+	uint64_t par_addr_mask                : 3;
+	uint64_t reserved_43_43               : 1;
+	uint64_t ea_int_polarity              : 1;
+	uint64_t error_alert_n_sample         : 1;
+	uint64_t reserved_46_47               : 2;
+	uint64_t rcd_parity_check             : 1;
+	uint64_t reserved_49_63               : 15;
+#endif
+	} cn78xx;
 };
 typedef union cvmx_lmcx_ext_config cvmx_lmcx_ext_config_t;
 
 /**
+ * cvmx_lmc#_ext_config2
+ *
+ * This register has additional configuration and control bits for the LMC.
+ *
+ */
+union cvmx_lmcx_ext_config2 {
+	uint64_t u64;
+	struct cvmx_lmcx_ext_config2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t row_col_switch               : 1;  /**< When set, the memory address bit position that represents bit 4 of the COLUMN
+                                                         address (bit 5 in 32-bit mode) becomes the low order DDR ROW address bit.
+                                                         The upper DDR COLUMN address portion is selected using LMC()_CONFIG[ROW_LSB]
+                                                         (and LMC()_DUAL_MEMCFG[ROW_LSB] for dual-memory configuration).
+                                                         It is recommended to set this bit to 1 when TRR_ON is set. */
+	uint64_t trr_on                       : 1;  /**< When set, this enables row activates counts of the
+                                                         DRAM used in Target Row Refresh mode. This bit can
+                                                         be safely set after the LMC()_EXT_CONFIG2[MACRAM_SCRUB_DONE]
+                                                         has a value of 1. */
+	uint64_t mac                          : 3;  /**< Sets the maximum number of activates allowed within a tMAW interval.
+                                                         0x0 = 100K.
+                                                         0x1 = 400K/2.
+                                                         0x2 = 500K/2.
+                                                         0x3 = 600K/2.
+                                                         0x4 = 700K/2.
+                                                         0x5 = 800K/2.
+                                                         0x6 = 900K/2.
+                                                         0x7 = 1000K/2. */
+	uint64_t macram_scrub_done            : 1;  /**< Maximum Activate Count memory scrub complete indication;
+                                                         1 means the memory has been scrubbed to all zero. */
+	uint64_t macram_scrub                 : 1;  /**< When set, the Maximum Activate Count memory will be scrubbed to all zero values. This
+                                                         should be done before enabling TRR mode by setting LMC()_EXT_CONFIG2[TRR_ON].
+                                                         This is a one-shot operation; it automatically returns to 0 after a write to 1. */
+	uint64_t macram_flip_synd             : 2;  /**< Reserved. INTERNAL: MAC RAM flip syndrome control bits. */
+	uint64_t macram_cor_dis               : 1;  /**< Reserved. INTERNAL: MAC RAM correction disable control. */
+#else
+	uint64_t macram_cor_dis               : 1;
+	uint64_t macram_flip_synd             : 2;
+	uint64_t macram_scrub                 : 1;
+	uint64_t macram_scrub_done            : 1;
+	uint64_t mac                          : 3;
+	uint64_t trr_on                       : 1;
+	uint64_t row_col_switch               : 1;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_lmcx_ext_config2_s        cn73xx;
+};
+typedef union cvmx_lmcx_ext_config2 cvmx_lmcx_ext_config2_t;
+
+/**
  * cvmx_lmc#_fadr
  *
  * This register only captures the first transaction with ECC errors. A DED error can over-write
@@ -6664,13 +7550,15 @@ union cvmx_lmcx_fadr {
 	uint64_t u64;
 	struct cvmx_lmcx_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_40_63               : 24;
+	uint64_t reserved_43_63               : 21;
+	uint64_t fcid                         : 3;  /**< Failing CID number. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t reserved_0_37                : 38;
 #else
 	uint64_t reserved_0_37                : 38;
 	uint64_t fill_order                   : 2;
-	uint64_t reserved_40_63               : 24;
+	uint64_t fcid                         : 3;
+	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
 	struct cvmx_lmcx_fadr_cn30xx {
@@ -6752,12 +7640,85 @@ union cvmx_lmcx_fadr {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_fadr_cn70xx          cn70xxp1;
+	struct cvmx_lmcx_fadr_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_43_63               : 21;
+	uint64_t fcid                         : 3;  /**< Failing CID number. */
+	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
+	uint64_t fdimm                        : 1;  /**< Failing DIMM number. */
+	uint64_t fbunk                        : 1;  /**< Failing rank number. */
+	uint64_t fbank                        : 4;  /**< Failing bank number. Bits <3:0>. */
+	uint64_t frow                         : 18; /**< Failing row address. Bits <17:0>. */
+	uint64_t fcol                         : 14; /**< Failing column address <13:0>. Technically, represents the address of the 64b data that
+                                                         had an ECC error, i.e., FCOL[0] is always 0. Can be used in conjunction with
+                                                         LMC()_INT[DED_ERR] to isolate the 64b chunk of data in error. */
+#else
+	uint64_t fcol                         : 14;
+	uint64_t frow                         : 18;
+	uint64_t fbank                        : 4;
+	uint64_t fbunk                        : 1;
+	uint64_t fdimm                        : 1;
+	uint64_t fill_order                   : 2;
+	uint64_t fcid                         : 3;
+	uint64_t reserved_43_63               : 21;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_fadr_cn70xx          cn78xx;
 	struct cvmx_lmcx_fadr_cn61xx          cnf71xx;
 };
 typedef union cvmx_lmcx_fadr cvmx_lmcx_fadr_t;
 
 /**
+ * cvmx_lmc#_general_purpose0
+ */
+union cvmx_lmcx_general_purpose0 {
+	uint64_t u64;
+	struct cvmx_lmcx_general_purpose0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t data                         : 64; /**< General purpose data register.  See LMC()_PPR_CTL and LMC()_DBTRAIN_CTL[RW_TRAIN]. */
+#else
+	uint64_t data                         : 64;
+#endif
+	} s;
+	struct cvmx_lmcx_general_purpose0_s   cn73xx;
+};
+typedef union cvmx_lmcx_general_purpose0 cvmx_lmcx_general_purpose0_t;
+
+/**
+ * cvmx_lmc#_general_purpose1
+ */
+union cvmx_lmcx_general_purpose1 {
+	uint64_t u64;
+	struct cvmx_lmcx_general_purpose1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t data                         : 64; /**< General purpose data register.  See LMC()_PPR_CTL and LMC()_DBTRAIN_CTL[RW_TRAIN]. */
+#else
+	uint64_t data                         : 64;
+#endif
+	} s;
+	struct cvmx_lmcx_general_purpose1_s   cn73xx;
+};
+typedef union cvmx_lmcx_general_purpose1 cvmx_lmcx_general_purpose1_t;
+
+/**
+ * cvmx_lmc#_general_purpose2
+ */
+union cvmx_lmcx_general_purpose2 {
+	uint64_t u64;
+	struct cvmx_lmcx_general_purpose2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t data                         : 16; /**< General purpose data register.  See LMC()_PPR_CTL and LMC()_DBTRAIN_CTL[RW_TRAIN]. */
+#else
+	uint64_t data                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_lmcx_general_purpose2_s   cn73xx;
+};
+typedef union cvmx_lmcx_general_purpose2 cvmx_lmcx_general_purpose2_t;
+
+/**
  * cvmx_lmc#_ifb_cnt
  *
  * LMC_IFB_CNT  = Performance Counters
@@ -6782,6 +7743,7 @@ union cvmx_lmcx_ifb_cnt {
 	struct cvmx_lmcx_ifb_cnt_s            cn68xxp1;
 	struct cvmx_lmcx_ifb_cnt_s            cn70xx;
 	struct cvmx_lmcx_ifb_cnt_s            cn70xxp1;
+	struct cvmx_lmcx_ifb_cnt_s            cn73xx;
 	struct cvmx_lmcx_ifb_cnt_s            cn78xx;
 	struct cvmx_lmcx_ifb_cnt_s            cnf71xx;
 };
@@ -6863,7 +7825,9 @@ union cvmx_lmcx_int {
 	uint64_t u64;
 	struct cvmx_lmcx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_12_63               : 52;
+	uint64_t reserved_14_63               : 50;
+	uint64_t macram_ded_err               : 1;  /**< MAC RAM ECC double error detect (DED). */
+	uint64_t macram_sec_err               : 1;  /**< MAC RAM ECC single error correct (SEC). */
 	uint64_t ddr_err                      : 1;  /**< DDR RAM error alert interrupt. */
 	uint64_t dlcram_ded_err               : 1;  /**< DLC RAM ECC double error detect (DED). */
 	uint64_t dlcram_sec_err               : 1;  /**< DLC RAM ECC single error correct (SEC). */
@@ -6900,7 +7864,9 @@ union cvmx_lmcx_int {
 	uint64_t dlcram_sec_err               : 1;
 	uint64_t dlcram_ded_err               : 1;
 	uint64_t ddr_err                      : 1;
-	uint64_t reserved_12_63               : 52;
+	uint64_t macram_sec_err               : 1;
+	uint64_t macram_ded_err               : 1;
+	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
 	struct cvmx_lmcx_int_cn61xx {
@@ -6944,13 +7910,42 @@ union cvmx_lmcx_int {
 	struct cvmx_lmcx_int_cn61xx           cn66xx;
 	struct cvmx_lmcx_int_cn61xx           cn68xx;
 	struct cvmx_lmcx_int_cn61xx           cn68xxp1;
-	struct cvmx_lmcx_int_s                cn70xx;
-	struct cvmx_lmcx_int_s                cn70xxp1;
-	struct cvmx_lmcx_int_s                cn78xx;
-	struct cvmx_lmcx_int_cn61xx           cnf71xx;
-};
-typedef union cvmx_lmcx_int cvmx_lmcx_int_t;
-
+	struct cvmx_lmcx_int_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t ddr_err                      : 1;  /**< Reserved. */
+	uint64_t dlcram_ded_err               : 1;  /**< Reserved. */
+	uint64_t dlcram_sec_err               : 1;  /**< Reserved. */
+	uint64_t ded_err                      : 4;  /**< Double error detected (DED) of Rd Data.
+                                                         In 32b mode, each bit corresponds to 2 phases:
+                                                         <5> corresponds to DQ[31:0]_c0_p1/0
+                                                         <6> corresponds to DQ[31:0]_c1_p1/0
+                                                         <7> corresponds to DQ[31:0]_c2_p1/0
+                                                         <8> corresponds to DQ[31:0]_c3_p1/0 */
+	uint64_t sec_err                      : 4;  /**< Single error (corrected) of Rd Data.
+                                                         In 32b mode, each bit corresponds to 2 phases:
+                                                         <1> corresponds to DQ[31:0]_c0_p1/0
+                                                         <2> corresponds to DQ[31:0]_c1_p1/0
+                                                         <3> corresponds to DQ[31:0]_c2_p1/0
+                                                         <4> corresponds to DQ[31:0]_c3_p1/0 */
+	uint64_t nxm_wr_err                   : 1;  /**< Write to nonexistent memory. */
+#else
+	uint64_t nxm_wr_err                   : 1;
+	uint64_t sec_err                      : 4;
+	uint64_t ded_err                      : 4;
+	uint64_t dlcram_sec_err               : 1;
+	uint64_t dlcram_ded_err               : 1;
+	uint64_t ddr_err                      : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_int_cn70xx           cn70xxp1;
+	struct cvmx_lmcx_int_s                cn73xx;
+	struct cvmx_lmcx_int_cn70xx           cn78xx;
+	struct cvmx_lmcx_int_cn61xx           cnf71xx;
+};
+typedef union cvmx_lmcx_int cvmx_lmcx_int_t;
+
 /**
  * cvmx_lmc#_int_en
  *
@@ -7014,6 +8009,7 @@ union cvmx_lmcx_int_en {
 	struct cvmx_lmcx_int_en_cn61xx        cn68xxp1;
 	struct cvmx_lmcx_int_en_s             cn70xx;
 	struct cvmx_lmcx_int_en_s             cn70xxp1;
+	struct cvmx_lmcx_int_en_s             cn73xx;
 	struct cvmx_lmcx_int_en_s             cn78xx;
 	struct cvmx_lmcx_int_en_cn61xx        cnf71xx;
 };
@@ -7068,6 +8064,7 @@ union cvmx_lmcx_lanex_crc_swiz {
 	uint64_t reserved_56_63               : 8;
 #endif
 	} s;
+	struct cvmx_lmcx_lanex_crc_swiz_s     cn73xx;
 	struct cvmx_lmcx_lanex_crc_swiz_s     cn78xx;
 };
 typedef union cvmx_lmcx_lanex_crc_swiz cvmx_lmcx_lanex_crc_swiz_t;
@@ -7467,13 +8464,211 @@ typedef union cvmx_lmcx_mem_cfg1 cvmx_lmcx_mem_cfg1_t;
 /**
  * cvmx_lmc#_modereg_params0
  *
- * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.
+ * These parameters are written into the DDR3/DDR4 MR0, MR1, MR2 and MR3 registers.
  *
  */
 union cvmx_lmcx_modereg_params0 {
 	uint64_t u64;
 	struct cvmx_lmcx_modereg_params0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_27_63               : 37;
+	uint64_t cl_ext                       : 1;  /**< Reserved; must be zero.
+                                                         INTERNAL: The extended bit for the proposed CAS Latency spec change. The new
+                                                         CAS Latency in DDR4 DRAM is defined in MR0(A12,A6,A5,A4,A2). This bit sets
+                                                         the A12 bit.
+                                                         See LMC()_MODEREG_PARAMS0[CL]. */
+	uint64_t al_ext                       : 1;  /**< Reserved; must be zero.
+                                                          INTERNAL: The extended bit for the new Additive latency settings for DDR4 3DS.
+                                                          Together with LMC()_MODEREG_PARAMS0[AL], this covers additive latency settings
+                                                          of up to CL-6.
+                                                         - 0: CL - (LMC()_MODEREG_PARAMS0[AL])
+                                                         - 1: CL - (LMC()_MODEREG_PARAMS0[AL] + 4)
+                                                          See LMC()_MODEREG_PARAMS0[AL]. */
+	uint64_t ppd                          : 1;  /**< DLL Control for precharge powerdown
+                                                         0 = Slow exit (DLL off)
+                                                         1 = Fast exit (DLL on)
+                                                         LMC writes this value to MR0[PPD] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[PPD] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t wrp                          : 3;  /**< Write recovery for auto precharge
+                                                         Should be programmed to be equal to or greater than
+                                                         RNDUP[tWR(ns)/tCYC(ns)]
+                                                         000 = 5
+                                                         001 = 5
+                                                         010 = 6
+                                                         011 = 7
+                                                         100 = 8
+                                                         101 = 10
+                                                         110 = 12
+                                                         111 = 14
+                                                         LMC writes this value to MR0[WR] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[WR] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t dllr                         : 1;  /**< DLL Reset
+                                                         LMC writes this value to MR0[DLL] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[DLL] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t tm                           : 1;  /**< Test Mode
+                                                         LMC writes this value to MR0[TM] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[TM] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t rbt                          : 1;  /**< Read Burst Type
+                                                         1 = interleaved (fixed)
+                                                         LMC writes this value to MR0[RBT] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[RBT] value must be 1 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t cl                           : 4;  /**< CAS Latency
+                                                         0010 = 5
+                                                         0100 = 6
+                                                         0110 = 7
+                                                         1000 = 8
+                                                         1010 = 9
+                                                         1100 = 10
+                                                         1110 = 11
+                                                         0001 = 12
+                                                         0011 = 13
+                                                         0101 = 14
+                                                         0111 = 15
+                                                         1001 = 16
+                                                         0000, 1011, 1101, 1111 = Reserved
+                                                         LMC writes this value to MR0[CAS Latency / CL] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[CAS Latency / CL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t bl                           : 2;  /**< Burst Length
+                                                         0 = 8 (fixed)
+                                                         LMC writes this value to MR0[BL] in the selected DDR3 parts
+                                                         during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[BL] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t qoff                         : 1;  /**< Qoff Enable
+                                                         0 = enable
+                                                         1 = disable
+                                                         LMC writes this value to MR1[Qoff] in the DDR3 parts in the selected ranks
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         The MR1[Qoff] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t tdqs                         : 1;  /**< TDQS Enable
+                                                         0 = disable
+                                                         LMC writes this value to MR1[TDQS] in the DDR3 parts in the selected ranks
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t wlev                         : 1;  /**< Write Leveling Enable
+                                                         0 = disable
+                                                         LMC writes MR1[Level]=0 in the DDR3 parts in the selected ranks
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         (Write-leveling can only be initiated via the
+                                                         write-leveling instruction sequence.)
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t al                           : 2;  /**< Additive Latency
+                                                         00 = 0
+                                                         01 = CL-1
+                                                         10 = CL-2
+                                                         11 = Reserved
+                                                         LMC writes this value to MR1[AL] in the selected DDR3 parts
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR1[AL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation.
+                                                         See also LMC*_CONTROL[POCAS]. */
+	uint64_t dll                          : 1;  /**< DLL Enable
+                                                         0 = enable
+                                                         1 = disable.
+                                                         LMC writes this value to MR1[DLL] in the selected DDR3 parts
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR1[DLL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation.
+                                                         In dll-off mode, CL/CWL must be programmed
+                                                         equal to 6/6, respectively, as per the DDR3 specifications. */
+	uint64_t mpr                          : 1;  /**< MPR
+                                                         LMC writes this value to MR3[MPR] in the selected DDR3 parts
+                                                         during power-up/init, read-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         (LMC also writes MR3[MPR]=1 at the beginning of the
+                                                         read-leveling instruction sequence. Read-leveling should only be initiated via the
+                                                         read-leveling instruction sequence.)
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR3[MPR] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t mprloc                       : 2;  /**< MPR Location
+                                                         LMC writes this value to MR3[MPRLoc] in the selected DDR3 parts
+                                                         during power-up/init, read-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh exit instruction sequences.
+                                                         (LMC also writes MR3[MPRLoc]=0 at the beginning of the
+                                                         read-leveling instruction sequence.)
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR3[MPRLoc] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t cwl                          : 3;  /**< CAS Write Latency
+                                                         - 000: 5
+                                                         - 001: 6
+                                                         - 010: 7
+                                                         - 011: 8
+                                                         - 100: 9
+                                                         - 101: 10
+                                                         - 110: 11
+                                                         - 111: 12
+                                                         LMC writes this value to MR2[CWL] in the selected DDR3 parts
+                                                         during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR2[CWL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+#else
+	uint64_t cwl                          : 3;
+	uint64_t mprloc                       : 2;
+	uint64_t mpr                          : 1;
+	uint64_t dll                          : 1;
+	uint64_t al                           : 2;
+	uint64_t wlev                         : 1;
+	uint64_t tdqs                         : 1;
+	uint64_t qoff                         : 1;
+	uint64_t bl                           : 2;
+	uint64_t cl                           : 4;
+	uint64_t rbt                          : 1;
+	uint64_t tm                           : 1;
+	uint64_t dllr                         : 1;
+	uint64_t wrp                          : 3;
+	uint64_t ppd                          : 1;
+	uint64_t al_ext                       : 1;
+	uint64_t cl_ext                       : 1;
+	uint64_t reserved_27_63               : 37;
+#endif
+	} s;
+	struct cvmx_lmcx_modereg_params0_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t ppd                          : 1;  /**< DLL Control for precharge powerdown
                                                          0 = Slow exit (DLL off)
@@ -7655,29 +8850,224 @@ union cvmx_lmcx_modereg_params0 {
 	uint64_t ppd                          : 1;
 	uint64_t reserved_25_63               : 39;
 #endif
+	} cn61xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn63xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn63xxp1;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn66xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn68xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn68xxp1;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn70xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn70xxp1;
+	struct cvmx_lmcx_modereg_params0_s    cn73xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cn78xx;
+	struct cvmx_lmcx_modereg_params0_cn61xx cnf71xx;
+};
+typedef union cvmx_lmcx_modereg_params0 cvmx_lmcx_modereg_params0_t;
+
+/**
+ * cvmx_lmc#_modereg_params1
+ *
+ * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.
+ *
+ */
+union cvmx_lmcx_modereg_params1 {
+	uint64_t u64;
+	struct cvmx_lmcx_modereg_params1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_51_63               : 13;
+	uint64_t db_output_impedance          : 3;  /**< Host Interface DQ/DQS Output Driver Impedance control for DIMM0's Data Buffer.
+                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
+                                                         environment, i.e., CONFIG[LRDIMM_ENA] = 1, SEQ_CTL[SEQ_SEL] = 0x6.
+                                                         0x0 = RZQ/6 (40 ohm).
+                                                         0x1 = RZQ/7 (34 ohm).
+                                                         0x2 = RZQ/5 (48 ohm).
+                                                         0x3-0x7 = Reserved. */
+	uint64_t rtt_nom_11                   : 3;  /**< RTT_NOM Rank 3
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_11                       : 2;  /**< Output Driver Impedance Control Rank 3
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_11                    : 2;  /**< RTT_WR Rank 3
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_11                       : 1;  /**< Self-refresh temperature range Rank 3
+                                                         LMC writes this value to MR2[SRT] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_11                       : 1;  /**< Auto self-refresh Rank 3
+                                                         LMC writes this value to MR2[ASR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_11                      : 3;  /**< Partial array self-refresh Rank 3
+                                                         LMC writes this value to MR2[PASR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_nom_10                   : 3;  /**< RTT_NOM Rank 2
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_10                       : 2;  /**< Output Driver Impedance Control Rank 2
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_10                    : 2;  /**< RTT_WR Rank 2
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_10                       : 1;  /**< Self-refresh temperature range Rank 2
+                                                         LMC writes this value to MR2[SRT] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_10                       : 1;  /**< Auto self-refresh Rank 2
+                                                         LMC writes this value to MR2[ASR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_10                      : 3;  /**< Partial array self-refresh Rank 2
+                                                         LMC writes this value to MR2[PASR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_nom_01                   : 3;  /**< RTT_NOM Rank 1
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_01                       : 2;  /**< Output Driver Impedance Control Rank 1
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_01                    : 2;  /**< RTT_WR Rank 1
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_01                       : 1;  /**< Self-refresh temperature range Rank 1
+                                                         LMC writes this value to MR2[SRT] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_01                       : 1;  /**< Auto self-refresh Rank 1
+                                                         LMC writes this value to MR2[ASR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_01                      : 3;  /**< Partial array self-refresh Rank 1
+                                                         LMC writes this value to MR2[PASR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_nom_00                   : 3;  /**< RTT_NOM Rank 0
+                                                         LMC writes this value to MR1[Rtt_Nom] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.
+                                                         Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
+	uint64_t dic_00                       : 2;  /**< Output Driver Impedance Control Rank 0
+                                                         LMC writes this value to MR1[D.I.C.] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_00                    : 2;  /**< RTT_WR Rank 0
+                                                         LMC writes this value to MR2[Rtt_WR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_00                       : 1;  /**< Self-refresh temperature range Rank 0
+                                                         LMC writes this value to MR2[SRT] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_00                       : 1;  /**< Auto self-refresh Rank 0
+                                                         LMC writes this value to MR2[ASR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_00                      : 3;  /**< Partial array self-refresh Rank 0
+                                                         LMC writes this value to MR2[PASR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts
+                                                         when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,
+                                                         self-refresh entry and exit instruction sequences.
+                                                         See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+#else
+	uint64_t pasr_00                      : 3;
+	uint64_t asr_00                       : 1;
+	uint64_t srt_00                       : 1;
+	uint64_t rtt_wr_00                    : 2;
+	uint64_t dic_00                       : 2;
+	uint64_t rtt_nom_00                   : 3;
+	uint64_t pasr_01                      : 3;
+	uint64_t asr_01                       : 1;
+	uint64_t srt_01                       : 1;
+	uint64_t rtt_wr_01                    : 2;
+	uint64_t dic_01                       : 2;
+	uint64_t rtt_nom_01                   : 3;
+	uint64_t pasr_10                      : 3;
+	uint64_t asr_10                       : 1;
+	uint64_t srt_10                       : 1;
+	uint64_t rtt_wr_10                    : 2;
+	uint64_t dic_10                       : 2;
+	uint64_t rtt_nom_10                   : 3;
+	uint64_t pasr_11                      : 3;
+	uint64_t asr_11                       : 1;
+	uint64_t srt_11                       : 1;
+	uint64_t rtt_wr_11                    : 2;
+	uint64_t dic_11                       : 2;
+	uint64_t rtt_nom_11                   : 3;
+	uint64_t db_output_impedance          : 3;
+	uint64_t reserved_51_63               : 13;
+#endif
 	} s;
-	struct cvmx_lmcx_modereg_params0_s    cn61xx;
-	struct cvmx_lmcx_modereg_params0_s    cn63xx;
-	struct cvmx_lmcx_modereg_params0_s    cn63xxp1;
-	struct cvmx_lmcx_modereg_params0_s    cn66xx;
-	struct cvmx_lmcx_modereg_params0_s    cn68xx;
-	struct cvmx_lmcx_modereg_params0_s    cn68xxp1;
-	struct cvmx_lmcx_modereg_params0_s    cn70xx;
-	struct cvmx_lmcx_modereg_params0_s    cn70xxp1;
-	struct cvmx_lmcx_modereg_params0_s    cn78xx;
-	struct cvmx_lmcx_modereg_params0_s    cnf71xx;
-};
-typedef union cvmx_lmcx_modereg_params0 cvmx_lmcx_modereg_params0_t;
-
-/**
- * cvmx_lmc#_modereg_params1
- *
- * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.
- *
- */
-union cvmx_lmcx_modereg_params1 {
-	uint64_t u64;
-	struct cvmx_lmcx_modereg_params1_s {
+	struct cvmx_lmcx_modereg_params1_cn61xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t rtt_nom_11                   : 3;  /**< RTT_NOM Rank 3
@@ -7863,17 +9253,17 @@ union cvmx_lmcx_modereg_params1 {
 	uint64_t rtt_nom_11                   : 3;
 	uint64_t reserved_48_63               : 16;
 #endif
-	} s;
-	struct cvmx_lmcx_modereg_params1_s    cn61xx;
-	struct cvmx_lmcx_modereg_params1_s    cn63xx;
-	struct cvmx_lmcx_modereg_params1_s    cn63xxp1;
-	struct cvmx_lmcx_modereg_params1_s    cn66xx;
-	struct cvmx_lmcx_modereg_params1_s    cn68xx;
-	struct cvmx_lmcx_modereg_params1_s    cn68xxp1;
-	struct cvmx_lmcx_modereg_params1_s    cn70xx;
-	struct cvmx_lmcx_modereg_params1_s    cn70xxp1;
-	struct cvmx_lmcx_modereg_params1_s    cn78xx;
-	struct cvmx_lmcx_modereg_params1_s    cnf71xx;
+	} cn61xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn63xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn63xxp1;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn66xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn68xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn68xxp1;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn70xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn70xxp1;
+	struct cvmx_lmcx_modereg_params1_s    cn73xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cn78xx;
+	struct cvmx_lmcx_modereg_params1_cn61xx cnf71xx;
 };
 typedef union cvmx_lmcx_modereg_params1 cvmx_lmcx_modereg_params1_t;
 
@@ -7950,6 +9340,7 @@ union cvmx_lmcx_modereg_params2 {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} cn70xxp1;
+	struct cvmx_lmcx_modereg_params2_s    cn73xx;
 	struct cvmx_lmcx_modereg_params2_s    cn78xx;
 };
 typedef union cvmx_lmcx_modereg_params2 cvmx_lmcx_modereg_params2_t;
@@ -7964,7 +9355,11 @@ union cvmx_lmcx_modereg_params3 {
 	uint64_t u64;
 	struct cvmx_lmcx_modereg_params3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_33_63               : 31;
+	uint64_t reserved_39_63               : 25;
+	uint64_t xrank_add_tccd_l             : 3;  /**< Add additional cycles on top of the 4 cycles applied to tCCD_L
+                                                         when crossing logical rank (to the same bank group) of a 3DS DRAM. */
+	uint64_t xrank_add_tccd_s             : 3;  /**< Add additional cycles on top of the 4 cycles applied to tCCD_S
+                                                         when crossing logical rank (to a different bank group) of a 3DS DRAM. */
 	uint64_t mpr_fmt                      : 2;  /**< MPR format. */
 	uint64_t wr_cmd_lat                   : 2;  /**< Write command latency when CRC and DM are both enabled. */
 	uint64_t fgrm                         : 3;  /**< Fine granularity refresh mode. */
@@ -8016,12 +9411,68 @@ union cvmx_lmcx_modereg_params3 {
 	uint64_t fgrm                         : 3;
 	uint64_t wr_cmd_lat                   : 2;
 	uint64_t mpr_fmt                      : 2;
-	uint64_t reserved_33_63               : 31;
+	uint64_t xrank_add_tccd_s             : 3;
+	uint64_t xrank_add_tccd_l             : 3;
+	uint64_t reserved_39_63               : 25;
 #endif
 	} s;
-	struct cvmx_lmcx_modereg_params3_s    cn70xx;
-	struct cvmx_lmcx_modereg_params3_s    cn70xxp1;
-	struct cvmx_lmcx_modereg_params3_s    cn78xx;
+	struct cvmx_lmcx_modereg_params3_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_33_63               : 31;
+	uint64_t mpr_fmt                      : 2;  /**< MPR format. */
+	uint64_t wr_cmd_lat                   : 2;  /**< Write command latency when CRC and DM are both enabled. */
+	uint64_t fgrm                         : 3;  /**< Fine granularity refresh mode. */
+	uint64_t temp_sense                   : 1;  /**< Temperature sensor readout enable. */
+	uint64_t pda                          : 1;  /**< Per DRAM addressability. */
+	uint64_t gd                           : 1;  /**< Gear-down mode. */
+	uint64_t crc                          : 1;  /**< CRC mode. */
+	uint64_t lpasr                        : 2;  /**< LP auto self refresh. */
+	uint64_t tccd_l                       : 3;  /**< TCCD_L timing parameter:
+                                                         0x0 = 4. 0x3 = 7.
+                                                         0x1 = 5. 0x4 = 8.
+                                                         0x2 = 6. 0x5-0x7 = reserved. */
+	uint64_t rd_dbi                       : 1;  /**< Read DBI, must be 0. */
+	uint64_t wr_dbi                       : 1;  /**< Write DBI, must be 0. */
+	uint64_t dm                           : 1;  /**< Data mask enable. */
+	uint64_t ca_par_pers                  : 1;  /**< Command/address persistent parity error mode. */
+	uint64_t odt_pd                       : 1;  /**< ODT in PD mode. */
+	uint64_t par_lat_mode                 : 3;  /**< Parity latency mode. */
+	uint64_t wr_preamble                  : 1;  /**< Write preamble, 0 = one nCK, 1 = two nCK. */
+	uint64_t rd_preamble                  : 1;  /**< Write preamble, 0 = one nCK, 1 = two nCK. */
+	uint64_t sre_abort                    : 1;  /**< Self refresh abort. */
+	uint64_t cal                          : 3;  /**< CS-to-CMD/ADDR latency mode (cycles). */
+	uint64_t vref_mon                     : 1;  /**< Internal VREF monitor: 0 = disable, 1 = enable. */
+	uint64_t tc_ref                       : 1;  /**< Temperature controlled refresh range: 0 = normal, 1 = extended. */
+	uint64_t max_pd                       : 1;  /**< Maximum power-down mode: 0 = disable, 1 = enable. */
+#else
+	uint64_t max_pd                       : 1;
+	uint64_t tc_ref                       : 1;
+	uint64_t vref_mon                     : 1;
+	uint64_t cal                          : 3;
+	uint64_t sre_abort                    : 1;
+	uint64_t rd_preamble                  : 1;
+	uint64_t wr_preamble                  : 1;
+	uint64_t par_lat_mode                 : 3;
+	uint64_t odt_pd                       : 1;
+	uint64_t ca_par_pers                  : 1;
+	uint64_t dm                           : 1;
+	uint64_t wr_dbi                       : 1;
+	uint64_t rd_dbi                       : 1;
+	uint64_t tccd_l                       : 3;
+	uint64_t lpasr                        : 2;
+	uint64_t crc                          : 1;
+	uint64_t gd                           : 1;
+	uint64_t pda                          : 1;
+	uint64_t temp_sense                   : 1;
+	uint64_t fgrm                         : 3;
+	uint64_t wr_cmd_lat                   : 2;
+	uint64_t mpr_fmt                      : 2;
+	uint64_t reserved_33_63               : 31;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_modereg_params3_cn70xx cn70xxp1;
+	struct cvmx_lmcx_modereg_params3_s    cn73xx;
+	struct cvmx_lmcx_modereg_params3_cn70xx cn78xx;
 };
 typedef union cvmx_lmcx_modereg_params3 cvmx_lmcx_modereg_params3_t;
 
@@ -8043,6 +9494,7 @@ union cvmx_lmcx_mpr_data0 {
 	} s;
 	struct cvmx_lmcx_mpr_data0_s          cn70xx;
 	struct cvmx_lmcx_mpr_data0_s          cn70xxp1;
+	struct cvmx_lmcx_mpr_data0_s          cn73xx;
 	struct cvmx_lmcx_mpr_data0_s          cn78xx;
 };
 typedef union cvmx_lmcx_mpr_data0 cvmx_lmcx_mpr_data0_t;
@@ -8065,6 +9517,7 @@ union cvmx_lmcx_mpr_data1 {
 	} s;
 	struct cvmx_lmcx_mpr_data1_s          cn70xx;
 	struct cvmx_lmcx_mpr_data1_s          cn70xxp1;
+	struct cvmx_lmcx_mpr_data1_s          cn73xx;
 	struct cvmx_lmcx_mpr_data1_s          cn78xx;
 };
 typedef union cvmx_lmcx_mpr_data1 cvmx_lmcx_mpr_data1_t;
@@ -8089,6 +9542,7 @@ union cvmx_lmcx_mpr_data2 {
 	} s;
 	struct cvmx_lmcx_mpr_data2_s          cn70xx;
 	struct cvmx_lmcx_mpr_data2_s          cn70xxp1;
+	struct cvmx_lmcx_mpr_data2_s          cn73xx;
 	struct cvmx_lmcx_mpr_data2_s          cn78xx;
 };
 typedef union cvmx_lmcx_mpr_data2 cvmx_lmcx_mpr_data2_t;
@@ -8103,9 +9557,23 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_mr_mpr_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_57_63               : 7;
+	uint64_t reserved_61_63               : 3;
+	uint64_t mr_wr_secure_key_ena         : 1;  /**< When set, this enables the issuing of security key with the
+                                                         unique address field A[17:0] set by LMC()_MR_MPR_CTL[MR_WR_ADDR]
+                                                         during the MRW sequence.
+                                                         Set this to 1 when executing DRAM Post Package Repair manually
+                                                         by using MRW operation. */
+	uint64_t pba_func_space               : 3;  /**< Set the Function Space Selector during PBA mode of the MRW
+                                                         sequence. */
 	uint64_t mr_wr_bg1                    : 1;  /**< BG1 part of the address select for MRS in DDR4 mode. */
-	uint64_t reserved_53_55               : 3;
+	uint64_t mpr_sample_dq_enable         : 1;  /**< Reserved. INTERNAL: Sample the whole r128dat1_2a and r128dat0_2a
+                                                         in one cycle. This has priority over the whole-byte mode. i.e., when
+                                                         this bit is set to 1, the MPR register ignores the value of the
+                                                         MPR_WHOLE_BYTE_ENABLE bit. */
+	uint64_t pda_early_dqx                : 1;  /**< When set, it enables lmc_dqx early for PDA/PBA operation. */
+	uint64_t mr_wr_pba_enable             : 1;  /**< Per Buffer Addressability write enable. When set, MRW operations use PBA, enabled by
+                                                         MR_WR_PDA_MASK per buffer.
+                                                         Only available for DDR4 LRDIMM. */
 	uint64_t mr_wr_use_default_value      : 1;  /**< When set, write the value to the MR that is computed from the value set in various CSR
                                                          fields that would be used during initialization, rather that using the value in the
                                                          LMC()_MR_MPR_CTL[MR_WR_ADDR]. Useful to rewrite the same value or to change single
@@ -8144,9 +9612,13 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t mpr_byte_select              : 4;
 	uint64_t mpr_whole_byte_enable        : 1;
 	uint64_t mr_wr_use_default_value      : 1;
-	uint64_t reserved_53_55               : 3;
+	uint64_t mr_wr_pba_enable             : 1;
+	uint64_t pda_early_dqx                : 1;
+	uint64_t mpr_sample_dq_enable         : 1;
 	uint64_t mr_wr_bg1                    : 1;
-	uint64_t reserved_57_63               : 7;
+	uint64_t pba_func_space               : 3;
+	uint64_t mr_wr_secure_key_ena         : 1;
+	uint64_t reserved_61_63               : 3;
 #endif
 	} s;
 	struct cvmx_lmcx_mr_mpr_ctl_cn70xx {
@@ -8191,11 +9663,88 @@ union cvmx_lmcx_mr_mpr_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_mr_mpr_ctl_cn70xx    cn70xxp1;
-	struct cvmx_lmcx_mr_mpr_ctl_s         cn78xx;
+	struct cvmx_lmcx_mr_mpr_ctl_s         cn73xx;
+	struct cvmx_lmcx_mr_mpr_ctl_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_57_63               : 7;
+	uint64_t mr_wr_bg1                    : 1;  /**< BG1 part of the address select for MRS in DDR4 mode. */
+	uint64_t reserved_53_55               : 3;
+	uint64_t mr_wr_use_default_value      : 1;  /**< When set, write the value to the MR that is computed from the value set in various CSR
+                                                         fields that would be used during initialization, rather that using the value in the
+                                                         LMC()_MR_MPR_CTL[MR_WR_ADDR]. Useful to rewrite the same value or to change single
+                                                         bits without having to compute a whole new value for the MR. */
+	uint64_t mpr_whole_byte_enable        : 1;  /**< Reserved. INTERNAL: Select a whole byte of DRAM data to read when whole-byte mode enabled. */
+	uint64_t mpr_byte_select              : 4;  /**< Reserved. INTERNAL: Select a whole byte of DRAM data to read when whole-byte mode enabled. */
+	uint64_t mpr_bit_select               : 2;  /**< Select which of four bits to read for each nibble of DRAM data. Typically all four bits
+                                                         from a *4 device, or all eight bits from a *8 device, or all 16 bits from a *16 device
+                                                         carry the same data, but this field allows selection of which device bit will be used to
+                                                         read the MPR data. */
+	uint64_t mpr_wr                       : 1;  /**< MPR sequence will perform a write operation when set. */
+	uint64_t mpr_loc                      : 2;  /**< MPR location select for MPR sequence. Only makes a difference for DDR4. */
+	uint64_t mr_wr_pda_enable             : 1;  /**< PDA write enable. When set, MRW operations use PDA, enabled by MR_WR_PDA_MASK per device.
+                                                         Only available for DDR4 devices. */
+	uint64_t mr_wr_pda_mask               : 18; /**< PDA mask. If MR_WR_PDA_ENABLE = 1 and there is a 1 in the bit for this mask value, then
+                                                         the corresponding DRAM device is enabled for the PDA MR write operation.
+                                                         Bit<23> corresponds to the lowest order, *4 device, and bit<40> corresponds to the highest
+                                                         order *4 device, for a total of up to 18 devices. */
+	uint64_t mr_wr_rank                   : 2;  /**< Selects the DRAM rank for either MRW or MPR sequences. */
+	uint64_t mr_wr_sel                    : 3;  /**< Selects which MR to write with the MR write sequence.
+                                                         Which pins to drive and how to drive them is automatically controlled through the DDR3/4
+                                                         mode setting. Bits<19:18> are also used to select the MPR page for an MPR sequence.
+                                                         A value of 0x7 selects an RCW write for both DDR4 and DDR3 MRW operations. */
+	uint64_t mr_wr_addr                   : 18; /**< Sets a value for A<17:0> for MR write operations. Note that many of these bits must be 0
+                                                         for various MRs. Bits<7:0> are also used for write data on an MPR sequence write
+                                                         operation. */
+#else
+	uint64_t mr_wr_addr                   : 18;
+	uint64_t mr_wr_sel                    : 3;
+	uint64_t mr_wr_rank                   : 2;
+	uint64_t mr_wr_pda_mask               : 18;
+	uint64_t mr_wr_pda_enable             : 1;
+	uint64_t mpr_loc                      : 2;
+	uint64_t mpr_wr                       : 1;
+	uint64_t mpr_bit_select               : 2;
+	uint64_t mpr_byte_select              : 4;
+	uint64_t mpr_whole_byte_enable        : 1;
+	uint64_t mr_wr_use_default_value      : 1;
+	uint64_t reserved_53_55               : 3;
+	uint64_t mr_wr_bg1                    : 1;
+	uint64_t reserved_57_63               : 7;
+#endif
+	} cn78xx;
 };
 typedef union cvmx_lmcx_mr_mpr_ctl cvmx_lmcx_mr_mpr_ctl_t;
 
 /**
+ * cvmx_lmc#_ns_ctl
+ *
+ * This register contains control parameters for handling non-secure accesses.
+ *
+ */
+union cvmx_lmcx_ns_ctl {
+	uint64_t u64;
+	struct cvmx_lmcx_ns_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_26_63               : 38;
+	uint64_t ns_scramble_dis              : 1;  /**< When set, this field disables data scrambling on non-secure accesses only.
+                                                         When data scrambling is enabled by setting CONTROL[SCRAMBLE_ENA] to 1, this
+                                                         field needs to be cleared to 0 in order to enable data scrambling on
+                                                         non-secure mode. */
+	uint64_t reserved_18_24               : 7;
+	uint64_t adr_offset                   : 18; /**< Sets the offset to the upper 18 bits of L2C-LMC address when a non-secure mode
+                                                         transaction occurs. */
+#else
+	uint64_t adr_offset                   : 18;
+	uint64_t reserved_18_24               : 7;
+	uint64_t ns_scramble_dis              : 1;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} s;
+	struct cvmx_lmcx_ns_ctl_s             cn73xx;
+};
+typedef union cvmx_lmcx_ns_ctl cvmx_lmcx_ns_ctl_t;
+
+/**
  * cvmx_lmc#_nxm
  *
  * Following is the decoding for mem_msb/rank:
@@ -8310,6 +9859,7 @@ union cvmx_lmcx_nxm {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_nxm_cn70xx           cn70xxp1;
+	struct cvmx_lmcx_nxm_cn70xx           cn73xx;
 	struct cvmx_lmcx_nxm_cn70xx           cn78xx;
 	struct cvmx_lmcx_nxm_s                cnf71xx;
 };
@@ -8328,6 +9878,25 @@ union cvmx_lmcx_nxm_fadr {
 	uint64_t u64;
 	struct cvmx_lmcx_nxm_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t nxm_faddr_ext                : 1;  /**< Extended bit for the Failing L2C-LMC address (bit 37). */
+	uint64_t nxm_src                      : 1;  /**< Indicates the source of the operation that caused a NXM error:
+                                                         0 = L2C, 1 = HFA */
+	uint64_t nxm_type                     : 1;  /**< Indicates the type of operation that caused NXM error:
+                                                         0 = Read, 1 = Write */
+	uint64_t nxm_faddr                    : 37; /**< Failing L2C-LMC address. Bits<3:0> are always 0s for an HFA access, and bits<4:0> are
+                                                         always 0s for an L2C access. Bits<5:4> represent the fill order for an L2C read operation,
+                                                         and the start point within a cache line for a write operation. */
+#else
+	uint64_t nxm_faddr                    : 37;
+	uint64_t nxm_type                     : 1;
+	uint64_t nxm_src                      : 1;
+	uint64_t nxm_faddr_ext                : 1;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} s;
+	struct cvmx_lmcx_nxm_fadr_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_39_63               : 25;
 	uint64_t nxm_src                      : 1;  /**< Indicates the source of the operation that caused a NXM error:
                                                          0 = L2C, 1 = HFA */
@@ -8342,10 +9911,10 @@ union cvmx_lmcx_nxm_fadr {
 	uint64_t nxm_src                      : 1;
 	uint64_t reserved_39_63               : 25;
 #endif
-	} s;
-	struct cvmx_lmcx_nxm_fadr_s           cn70xx;
-	struct cvmx_lmcx_nxm_fadr_s           cn70xxp1;
-	struct cvmx_lmcx_nxm_fadr_s           cn78xx;
+	} cn70xx;
+	struct cvmx_lmcx_nxm_fadr_cn70xx      cn70xxp1;
+	struct cvmx_lmcx_nxm_fadr_s           cn73xx;
+	struct cvmx_lmcx_nxm_fadr_cn70xx      cn78xx;
 };
 typedef union cvmx_lmcx_nxm_fadr cvmx_lmcx_nxm_fadr_t;
 
@@ -8375,6 +9944,7 @@ union cvmx_lmcx_ops_cnt {
 	struct cvmx_lmcx_ops_cnt_s            cn68xxp1;
 	struct cvmx_lmcx_ops_cnt_s            cn70xx;
 	struct cvmx_lmcx_ops_cnt_s            cn70xxp1;
+	struct cvmx_lmcx_ops_cnt_s            cn73xx;
 	struct cvmx_lmcx_ops_cnt_s            cn78xx;
 	struct cvmx_lmcx_ops_cnt_s            cnf71xx;
 };
@@ -8456,7 +10026,22 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_phy_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_51_63               : 13;
+	uint64_t reserved_56_63               : 8;
+	uint64_t dm_disable                   : 1;  /**< Write to 1 to disable the DRAM Data Mask feature by having LMC driving a constant value on
+                                                         the
+                                                         DDRX_DQS<17:9>_P pins of the chip during write operations. LMC drives a constant 0 in DDR3
+                                                         and drives a constant 1 in DDR4.
+                                                         Note that setting this field high is NOT allowed when LMC has the Write DBI feature turned
+                                                         on
+                                                         (MODEREG_PARAMS3[WR_DBI]=1). */
+	uint64_t c1_sel                       : 2;  /**< 0x0 = C1 is not routed to any output pin.
+                                                         0x1 = C1 is routed to CS3.
+                                                         0x2 = C1 is routed to A17 address pin.
+                                                         0x3 = C1 is not routed to any output pin. */
+	uint64_t c0_sel                       : 2;  /**< 0x0 = C0 is not routed to any output pin.
+                                                         0x1 = C0 is routed to CS2.
+                                                         0x2 = C0 is routed to TEN output pin.
+                                                         0x3 = C0 is not routed to any output pin. */
 	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
                                                          clear to value of 0. */
 	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
@@ -8536,7 +10121,10 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t dsk_dbg_rd_data              : 10;
 	uint64_t dsk_dbg_rd_complete          : 1;
 	uint64_t phy_reset                    : 1;
-	uint64_t reserved_51_63               : 13;
+	uint64_t c0_sel                       : 2;
+	uint64_t c1_sel                       : 2;
+	uint64_t dm_disable                   : 1;
+	uint64_t reserved_56_63               : 8;
 #endif
 	} s;
 	struct cvmx_lmcx_phy_ctl_cn61xx {
@@ -8607,9 +10195,91 @@ union cvmx_lmcx_phy_ctl {
 	struct cvmx_lmcx_phy_ctl_cn61xx       cn66xx;
 	struct cvmx_lmcx_phy_ctl_cn61xx       cn68xx;
 	struct cvmx_lmcx_phy_ctl_cn61xx       cn68xxp1;
-	struct cvmx_lmcx_phy_ctl_s            cn70xx;
-	struct cvmx_lmcx_phy_ctl_s            cn70xxp1;
-	struct cvmx_lmcx_phy_ctl_s            cn78xx;
+	struct cvmx_lmcx_phy_ctl_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_51_63               : 13;
+	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
+                                                         clear to value of 0. */
+	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
+                                                         operation is started, then set to 1 when operation is complete. */
+	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. INTERNAL: Data from a deskew read operation. Only valid when the
+                                                         LMCX_PHY_CTL[DSK_DBG_RD_COMPLETE] bit is set. */
+	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. INTERNAL: Write 1 to start deskew data read operation, will automatically clear
+                                                         to 0. Write to 1 will also clear the complete bit. */
+	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. INTERNAL: Adjust clock toggle rate for reading deskew debug information:
+                                                         0 = Deskew read clock toggles every 1 DCLK
+                                                         1 = Deskew read clock toggles every 2 DCLKs
+                                                         2 = Deskew read clock toggles every 3 DCLKs
+                                                         3 = Deskew read clock toggles every 4 DCLKs */
+	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
+                                                         DDR PHY. */
+	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
+                                                         0 = 8 bits per byte lane, no DBI
+                                                         1 = 9 bits per byte lane, including DBI */
+	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
+                                                         byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
+	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation. */
+	uint64_t dbi_mode_ena                 : 1;  /**< Enable DBI mode for PHY, must be 0.  DBI mode not supported
+                                                         in CN70XX. */
+	uint64_t ddr_error_n_ena              : 1;  /**< Reserved. */
+	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
+	uint64_t dac_on                       : 1;  /**< Reserved. INTERNAL: PHY DAC on. */
+	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMCX_PHY_CTL[PHY_DSK_BYP]
+                                                         when loopback is enabled. */
+	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. INTERNAL: PHY loopback enable. */
+	uint64_t phy_dsk_reset                : 1;  /**< PHY deskew reset. When set, the deskew reset signal goes active if the Vrefint/deskew
+                                                         training sequence is in the idle state. */
+	uint64_t phy_dsk_byp                  : 1;  /**< PHY deskew bypass. */
+	uint64_t phy_pwr_save_disable         : 1;  /**< DDR PHY power save disable. */
+	uint64_t ten                          : 1;  /**< DDR PHY test enable pin. */
+	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. INTERNAL: Set to force read_enable to PHY active all the time. */
+	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. INTERNAL: Low Voltage Mode (1.35V.) */
+	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
+	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
+	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
+	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
+	uint64_t loopback                     : 1;  /**< Reserved; must be zero. INTERNAL: Loopback enable. */
+	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. INTERNAL: Loopback pos mode. */
+	uint64_t ts_stagger                   : 1;  /**< TS stagger mode. This mode configures output drivers with two-stage drive strength to
+                                                         avoid undershoot issues on the bus when strong drivers are suddenly turned on. When this
+                                                         mode is asserted, CN78XX will configure output drivers to be weak drivers (60ohm output
+                                                         impedance) at the first CK cycle, and change drivers to the designated drive strengths
+                                                         specified in LMC(0..0)_COMP_CTL2[CMD_CTL/CK_CTL/DQX_CTL] starting at the following cycle. */
+#else
+	uint64_t ts_stagger                   : 1;
+	uint64_t loopback_pos                 : 1;
+	uint64_t loopback                     : 1;
+	uint64_t ck_dlyout0                   : 4;
+	uint64_t ck_tune0                     : 1;
+	uint64_t ck_dlyout1                   : 4;
+	uint64_t ck_tune1                     : 1;
+	uint64_t lv_mode                      : 1;
+	uint64_t rx_always_on                 : 1;
+	uint64_t ten                          : 1;
+	uint64_t phy_pwr_save_disable         : 1;
+	uint64_t phy_dsk_byp                  : 1;
+	uint64_t phy_dsk_reset                : 1;
+	uint64_t int_phy_loopback_ena         : 1;
+	uint64_t int_pad_loopback_ena         : 1;
+	uint64_t dac_on                       : 1;
+	uint64_t ref_pin_on                   : 1;
+	uint64_t ddr_error_n_ena              : 1;
+	uint64_t dbi_mode_ena                 : 1;
+	uint64_t dsk_dbg_bit_sel              : 4;
+	uint64_t dsk_dbg_byte_sel             : 4;
+	uint64_t dsk_dbg_num_bits_sel         : 1;
+	uint64_t dsk_dbg_offset               : 2;
+	uint64_t dsk_dbg_clk_scaler           : 2;
+	uint64_t dsk_dbg_rd_start             : 1;
+	uint64_t dsk_dbg_rd_data              : 10;
+	uint64_t dsk_dbg_rd_complete          : 1;
+	uint64_t phy_reset                    : 1;
+	uint64_t reserved_51_63               : 13;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_phy_ctl_cn70xx       cn70xxp1;
+	struct cvmx_lmcx_phy_ctl_s            cn73xx;
+	struct cvmx_lmcx_phy_ctl_cn70xx       cn78xx;
 	struct cvmx_lmcx_phy_ctl_cn61xx       cnf71xx;
 };
 typedef union cvmx_lmcx_phy_ctl cvmx_lmcx_phy_ctl_t;
@@ -8821,9 +10491,67 @@ union cvmx_lmcx_pll_status {
 	uint64_t rfslip                       : 1;
 	uint64_t reserved_2_63                : 62;
 #endif
-	} cn58xxp1;
+	} cn58xxp1;
+};
+typedef union cvmx_lmcx_pll_status cvmx_lmcx_pll_status_t;
+
+/**
+ * cvmx_lmc#_ppr_ctl
+ *
+ * This register contains programmable timing and control parameters used
+ * when running the post package repair sequence. The timing fields
+ * PPR_CTL[TPGMPST], PPR_CTL[TPGM_EXIT] and PPR_CTL[TPGM] need to be set as
+ * to satisfy the minimum values mentioned in the JEDEC DDR4 spec before
+ * running the PPR sequence. See LMC()_SEQ_CTL[SEQ_SEL,INIT_START] to run
+ * the PPR sequence.
+ *
+ * Running Hard PPR may require LMC to issue Security Key as four consecutive
+ * MR0 commands, each with a unique address field A[17:0]. Set the Security
+ * Key in the general purpose CSRs as follows:
+ *
+ * _ Security Key 0 = LMC()_GENERAL_PURPOSE0[DATA]<17:0>.
+ * _ Security Key 1 = LMC()_GENERAL_PURPOSE0[DATA]<35:18>.
+ * _ Security Key 2 = LMC()_GENERAL_PURPOSE1[DATA]<17:0>.
+ * _ Security Key 3 = LMC()_GENERAL_PURPOSE1[DATA]<35:18>.
+ */
+union cvmx_lmcx_ppr_ctl {
+	uint64_t u64;
+	struct cvmx_lmcx_ppr_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t skip_issue_security          : 1;  /**< Personality bit for the PPR sequence. When set, this field forces the sequence to skip
+                                                         issuing four consecutive MR0 commands that suppliy the Security Key. */
+	uint64_t sppr                         : 1;  /**< Personality bit for the PPR sequence. When set, this field forces the sequence to run
+                                                         the Soft PPR mode. */
+	uint64_t tpgm                         : 10; /**< Indicates the programming time (tPGM) constraint used when running PPR sequence.
+                                                         For hard PPR (PPR_CTL[SPPR] = 0), set this field as follows:
+                                                         RNDUP[TPGM(ns) / (1048576 * TCYC(ns))].
+                                                         For soft PPR (PPR_CTL[SPPR] = 1), set this field as follows:
+                                                         RNDUP[TPGM(ns) / TCYC(ns))].
+                                                         TPGM is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not data
+                                                         rate). */
+	uint64_t tpgm_exit                    : 5;  /**< Indicates PPR Exit time (tPGM_Exit) contrainst used when running PPR sequence.
+                                                         Set this field as follows:
+                                                         _ RNDUP[TPGM_EXIT(ns) / TCYC(ns)]
+                                                         where TPGM_EXIT is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not
+                                                         data rate). */
+	uint64_t tpgmpst                      : 7;  /**< Indicates New Address Setting time (tPGMPST) constraint used when running PPR sequence.
+                                                         Set this field as follows:
+                                                         _ RNDUP[TPGMPST(ns) / (1024 * TCYC(ns))]
+                                                         where TPGMPST is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not
+                                                         data rate). */
+#else
+	uint64_t tpgmpst                      : 7;
+	uint64_t tpgm_exit                    : 5;
+	uint64_t tpgm                         : 10;
+	uint64_t sppr                         : 1;
+	uint64_t skip_issue_security          : 1;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_lmcx_ppr_ctl_s            cn73xx;
 };
-typedef union cvmx_lmcx_pll_status cvmx_lmcx_pll_status_t;
+typedef union cvmx_lmcx_ppr_ctl cvmx_lmcx_ppr_ctl_t;
 
 /**
  * cvmx_lmc#_read_level_ctl
@@ -8955,6 +10683,30 @@ union cvmx_lmcx_read_level_rankx {
 typedef union cvmx_lmcx_read_level_rankx cvmx_lmcx_read_level_rankx_t;
 
 /**
+ * cvmx_lmc#_ref_status
+ *
+ * This register contains the status of the refresh pending counter.
+ *
+ */
+union cvmx_lmcx_ref_status {
+	uint64_t u64;
+	struct cvmx_lmcx_ref_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t ref_pend_max_clr             : 1;  /**< Indicates that the number of pending refreshes has reached 7. Requiring
+                                                         software to clear the flag by setting this field to 1. */
+	uint64_t ref_count                    : 3;  /**< Reads back the number of pending refreshes that LMC has yet to execute. */
+#else
+	uint64_t ref_count                    : 3;
+	uint64_t ref_pend_max_clr             : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_lmcx_ref_status_s         cn73xx;
+};
+typedef union cvmx_lmcx_ref_status cvmx_lmcx_ref_status_t;
+
+/**
  * cvmx_lmc#_reset_ctl
  *
  * Specify the RSL base addresses for the block.
@@ -8990,12 +10742,109 @@ union cvmx_lmcx_reset_ctl {
 	struct cvmx_lmcx_reset_ctl_s          cn68xxp1;
 	struct cvmx_lmcx_reset_ctl_s          cn70xx;
 	struct cvmx_lmcx_reset_ctl_s          cn70xxp1;
+	struct cvmx_lmcx_reset_ctl_s          cn73xx;
 	struct cvmx_lmcx_reset_ctl_s          cn78xx;
 	struct cvmx_lmcx_reset_ctl_s          cnf71xx;
 };
 typedef union cvmx_lmcx_reset_ctl cvmx_lmcx_reset_ctl_t;
 
 /**
+ * cvmx_lmc#_retry_config
+ *
+ * This register configures automatic retry operation.
+ *
+ */
+union cvmx_lmcx_retry_config {
+	uint64_t u64;
+	struct cvmx_lmcx_retry_config_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_56_63               : 8;
+	uint64_t max_errors                   : 24; /**< Maximum number of errors before errors are ignored. */
+	uint64_t reserved_13_31               : 19;
+	uint64_t error_continue               : 1;  /**< If LMC()_RETRY_CONFIG[AUTO_ERROR_CONTINUE] is cleared, LMC will wait
+                                                         for a 1 to be written to LMC()_RETRY_CONFIG[ERROR_CONTINUE] before
+                                                         continuing operations after an error. */
+	uint64_t reserved_9_11                : 3;
+	uint64_t auto_error_continue          : 1;  /**< When set, LMC will automatically proceed with error handling and normal
+                                                         operation after an error occurs.  If clear, LMC will cease all operations
+                                                         except for refresh as soon as possible, and will not continue with error
+                                                         handling or normal operation until LMC()_RETRY_CONFIG[ERROR_CONTINUE]
+                                                         is written with a 1. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t pulse_count_auto_clr         : 1;  /**< When set, LMC()_RETRY_STATUS[ERROR_PULSE_COUNT_VALID] will clear
+                                                         whenever the error interrupt is cleared. */
+	uint64_t reserved_1_3                 : 3;
+	uint64_t retry_enable                 : 1;  /**< Enable retry on errors. */
+#else
+	uint64_t retry_enable                 : 1;
+	uint64_t reserved_1_3                 : 3;
+	uint64_t pulse_count_auto_clr         : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t auto_error_continue          : 1;
+	uint64_t reserved_9_11                : 3;
+	uint64_t error_continue               : 1;
+	uint64_t reserved_13_31               : 19;
+	uint64_t max_errors                   : 24;
+	uint64_t reserved_56_63               : 8;
+#endif
+	} s;
+	struct cvmx_lmcx_retry_config_s       cn73xx;
+};
+typedef union cvmx_lmcx_retry_config cvmx_lmcx_retry_config_t;
+
+/**
+ * cvmx_lmc#_retry_status
+ *
+ * This register provides status on automatic retry operation.
+ *
+ */
+union cvmx_lmcx_retry_status {
+	uint64_t u64;
+	struct cvmx_lmcx_retry_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t clear_error_count            : 1;  /**< Clear the error count, one shot operation. */
+	uint64_t clear_error_pulse_count      : 1;  /**< Clear the error count, one shot operation. */
+	uint64_t reserved_57_61               : 5;
+	uint64_t error_pulse_count_valid      : 1;  /**< When set and the count is valid, indicates that the counter has saturated,
+                                                         which effectively indicates that a command error has occured and not a CRC
+                                                         error. */
+	uint64_t error_pulse_count_sat        : 1;  /**< When set and the count is valid, indicates that the counter has saturated,
+                                                         which effectively indicates that a command error has occured and not a CRC
+                                                         error. */
+	uint64_t reserved_52_54               : 3;
+	uint64_t error_pulse_count            : 4;  /**< Count of cycles in last error pulse since clear.  This count will be cleared
+                                                         either by clearing the interrupt or writing a 1 to the pulse count clear bit. */
+	uint64_t reserved_45_47               : 3;
+	uint64_t error_sequence               : 5;  /**< Sequence number for sequence that was running when error occurred. */
+	uint64_t reserved_33_39               : 7;
+	uint64_t error_type                   : 1;  /**< Error type:
+                                                         0 = Error during a sequence run.
+                                                         1 = Error during normal operation, which means a read or write operation. Effectively this
+                                                         means a command error for a read or write operation, or a CRC error for a write data
+                                                         operation. */
+	uint64_t reserved_24_31               : 8;
+	uint64_t error_count                  : 24; /**< Number of errors encountered since last cleared. */
+#else
+	uint64_t error_count                  : 24;
+	uint64_t reserved_24_31               : 8;
+	uint64_t error_type                   : 1;
+	uint64_t reserved_33_39               : 7;
+	uint64_t error_sequence               : 5;
+	uint64_t reserved_45_47               : 3;
+	uint64_t error_pulse_count            : 4;
+	uint64_t reserved_52_54               : 3;
+	uint64_t error_pulse_count_sat        : 1;
+	uint64_t error_pulse_count_valid      : 1;
+	uint64_t reserved_57_61               : 5;
+	uint64_t clear_error_pulse_count      : 1;
+	uint64_t clear_error_count            : 1;
+#endif
+	} s;
+	struct cvmx_lmcx_retry_status_s       cn73xx;
+};
+typedef union cvmx_lmcx_retry_status cvmx_lmcx_retry_status_t;
+
+/**
  * cvmx_lmc#_rlevel_ctl
  */
 union cvmx_lmcx_rlevel_ctl {
@@ -9122,6 +10971,7 @@ union cvmx_lmcx_rlevel_ctl {
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cn68xxp1;
 	struct cvmx_lmcx_rlevel_ctl_s         cn70xx;
 	struct cvmx_lmcx_rlevel_ctl_s         cn70xxp1;
+	struct cvmx_lmcx_rlevel_ctl_s         cn73xx;
 	struct cvmx_lmcx_rlevel_ctl_s         cn78xx;
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cnf71xx;
 };
@@ -9158,6 +11008,7 @@ union cvmx_lmcx_rlevel_dbg {
 	struct cvmx_lmcx_rlevel_dbg_s         cn68xxp1;
 	struct cvmx_lmcx_rlevel_dbg_s         cn70xx;
 	struct cvmx_lmcx_rlevel_dbg_s         cn70xxp1;
+	struct cvmx_lmcx_rlevel_dbg_s         cn73xx;
 	struct cvmx_lmcx_rlevel_dbg_s         cn78xx;
 	struct cvmx_lmcx_rlevel_dbg_s         cnf71xx;
 };
@@ -9234,6 +11085,7 @@ union cvmx_lmcx_rlevel_rankx {
 	struct cvmx_lmcx_rlevel_rankx_s       cn68xxp1;
 	struct cvmx_lmcx_rlevel_rankx_s       cn70xx;
 	struct cvmx_lmcx_rlevel_rankx_s       cn70xxp1;
+	struct cvmx_lmcx_rlevel_rankx_s       cn73xx;
 	struct cvmx_lmcx_rlevel_rankx_s       cn78xx;
 	struct cvmx_lmcx_rlevel_rankx_s       cnf71xx;
 };
@@ -9432,6 +11284,7 @@ union cvmx_lmcx_rodt_mask {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_rodt_mask_cn70xx     cn70xxp1;
+	struct cvmx_lmcx_rodt_mask_cn70xx     cn73xx;
 	struct cvmx_lmcx_rodt_mask_cn70xx     cn78xx;
 	struct cvmx_lmcx_rodt_mask_s          cnf71xx;
 };
@@ -9456,6 +11309,7 @@ union cvmx_lmcx_scramble_cfg0 {
 	struct cvmx_lmcx_scramble_cfg0_s      cn66xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cn70xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cn70xxp1;
+	struct cvmx_lmcx_scramble_cfg0_s      cn73xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cn78xx;
 	struct cvmx_lmcx_scramble_cfg0_s      cnf71xx;
 };
@@ -9480,12 +11334,29 @@ union cvmx_lmcx_scramble_cfg1 {
 	struct cvmx_lmcx_scramble_cfg1_s      cn66xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cn70xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cn70xxp1;
+	struct cvmx_lmcx_scramble_cfg1_s      cn73xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cn78xx;
 	struct cvmx_lmcx_scramble_cfg1_s      cnf71xx;
 };
 typedef union cvmx_lmcx_scramble_cfg1 cvmx_lmcx_scramble_cfg1_t;
 
 /**
+ * cvmx_lmc#_scramble_cfg2
+ */
+union cvmx_lmcx_scramble_cfg2 {
+	uint64_t u64;
+	struct cvmx_lmcx_scramble_cfg2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t key                          : 64; /**< Scramble key for data. */
+#else
+	uint64_t key                          : 64;
+#endif
+	} s;
+	struct cvmx_lmcx_scramble_cfg2_s      cn73xx;
+};
+typedef union cvmx_lmcx_scramble_cfg2 cvmx_lmcx_scramble_cfg2_t;
+
+/**
  * cvmx_lmc#_scrambled_fadr
  *
  * LMC()_FADR captures the failing pre-scrambled address location (split into DIMM, bunk,
@@ -9508,7 +11379,8 @@ union cvmx_lmcx_scrambled_fadr {
 	uint64_t u64;
 	struct cvmx_lmcx_scrambled_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_40_63               : 24;
+	uint64_t reserved_43_63               : 21;
+	uint64_t fcid                         : 3;  /**< Failing CID number. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t reserved_14_37               : 24;
 	uint64_t fcol                         : 14; /**< Failing Column Address[13:0]
@@ -9520,7 +11392,8 @@ union cvmx_lmcx_scrambled_fadr {
 	uint64_t fcol                         : 14;
 	uint64_t reserved_14_37               : 24;
 	uint64_t fill_order                   : 2;
-	uint64_t reserved_40_63               : 24;
+	uint64_t fcid                         : 3;
+	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
 	struct cvmx_lmcx_scrambled_fadr_cn61xx {
@@ -9567,6 +11440,29 @@ union cvmx_lmcx_scrambled_fadr {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_scrambled_fadr_cn70xx cn70xxp1;
+	struct cvmx_lmcx_scrambled_fadr_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_43_63               : 21;
+	uint64_t fcid                         : 3;  /**< Failing CID number. */
+	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
+	uint64_t fdimm                        : 1;  /**< Failing DIMM number. */
+	uint64_t fbunk                        : 1;  /**< Failing rank number. */
+	uint64_t fbank                        : 4;  /**< Failing bank number. Bits <3:0>. */
+	uint64_t frow                         : 18; /**< Failing row address. Bits <17:0>. */
+	uint64_t fcol                         : 14; /**< Failing column address <13:0>. Technically, represents the address of the 128b data that
+                                                         had an ECC error, i.e., FCOL<0> is always 0. Can be used in conjunction with
+                                                         LMC()_CONFIG[DED_ERR] to isolate the 64b chunk of data in error. */
+#else
+	uint64_t fcol                         : 14;
+	uint64_t frow                         : 18;
+	uint64_t fbank                        : 4;
+	uint64_t fbunk                        : 1;
+	uint64_t fdimm                        : 1;
+	uint64_t fill_order                   : 2;
+	uint64_t fcid                         : 3;
+	uint64_t reserved_43_63               : 21;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_scrambled_fadr_cn70xx cn78xx;
 	struct cvmx_lmcx_scrambled_fadr_cn61xx cnf71xx;
 };
@@ -9651,6 +11547,7 @@ union cvmx_lmcx_seq_ctl {
 	} s;
 	struct cvmx_lmcx_seq_ctl_s            cn70xx;
 	struct cvmx_lmcx_seq_ctl_s            cn70xxp1;
+	struct cvmx_lmcx_seq_ctl_s            cn73xx;
 	struct cvmx_lmcx_seq_ctl_s            cn78xx;
 };
 typedef union cvmx_lmcx_seq_ctl cvmx_lmcx_seq_ctl_t;
@@ -9660,35 +11557,22 @@ typedef union cvmx_lmcx_seq_ctl cvmx_lmcx_seq_ctl_t;
  *
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
- * fields in th
- * LMC(0..3)_WLEVEL_RANK(0..1), LMC(0..3)_CONTROL, and LMC(0..3)_MODEREG_PARAMS0 registers
+ * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL, and LMC()_MODEREG_PARAMS0 registers
  * change. Ideally, only read this register after LMC has been initialized and
- * LMC(0..3)_RLEVEL_RANK(0..1), LMC(0..3)_WLEVEL_RANK(0..1) have valid data.
- * The field value is the minimum CK cycles between when the DRAM
- * part registers CAS commands of the first and second types from different cache blocks.
+ * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
+ *
+ * The interpretation of the fields in this register depends on LMC(0)_CONFIG[DDR2T]:
  *
- * "*_S_INIT" fields are DDR3 timing or DDR4 short timing parameters
- * "*_L_INIT" fields are DDR4 long timing parameters
- *
- * The hardware-calculated minimums are:
- * min R2R_S_INIT = 4
- * min R2W_S_INIT = 8 + (RL + MaxRdSkew) (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]
- * min W2R_S_INIT = 5 + LMC*_TIMING_PARAMS1[TWTR] + WL
- * min W2W_S_INIT = 4
- * min R2R_L_INIT = LMC*_MODEREG_PARAMS3[TCCD_L] (decoded)
- * min R2W_L_INIT = 8 + (RL + MaxRdSkew) (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]
- * min W2R_L_INIT = 5 + LMC*_TIMING_PARAMS2[TWTR_L] + WL
- * min W2W_L_INIT = LMC*_MODEREG_PARAMS3[TCCD_L] (decoded)
- * where
- * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects
- * AL)
- * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)
- * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1
- * (max is across all ranks i (0..3) and bytes j (0..8))
- * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX]
- * (min is across all ranks i (0..3) and bytes j (0..8))
- *
- * R2W_INIT has 1 CK cycle built in for OCTEON-internal ODT settling/channel turnaround time.
+ * * If LMC()_CONFIG[DDR2T]=1, (FieldValue + 4) is the minimum CK cycles between when
+ * the DRAM part registers CAS commands of the first and second types from different cache
+ * blocks.
+ *
+ * If LMC()_CONFIG[DDR2T]=0, (FieldValue + 3) is the minimum CK cycles between when the DRAM
+ * part registers CAS commands of the first and second types from different cache blocks.
+ * FieldValue = 0 is always illegal in this case.
+ * The hardware-calculated minimums for these fields are shown in LMC(0)_SLOT_CTL0 Hardware-
+ * Calculated Minimums.
  */
 union cvmx_lmcx_slot_ctl0 {
 	uint64_t u64;
@@ -9757,6 +11641,7 @@ union cvmx_lmcx_slot_ctl0 {
 	struct cvmx_lmcx_slot_ctl0_cn61xx     cn68xxp1;
 	struct cvmx_lmcx_slot_ctl0_s          cn70xx;
 	struct cvmx_lmcx_slot_ctl0_s          cn70xxp1;
+	struct cvmx_lmcx_slot_ctl0_s          cn73xx;
 	struct cvmx_lmcx_slot_ctl0_s          cn78xx;
 	struct cvmx_lmcx_slot_ctl0_cn61xx     cnf71xx;
 };
@@ -9767,33 +11652,22 @@ typedef union cvmx_lmcx_slot_ctl0 cvmx_lmcx_slot_ctl0_t;
  *
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
- * fields in this register to the minimum allowed value when any of LMC(0..3)_RLEVEL_RANK(0..1),
- * LMC(0..3)_WLEVEL_RANK(0..1), LMC(0..3)_CONTROL and LMC(0..3)_MODEREG_PARAMS0 CSRs change.
+ * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
  * Ideally, only read this register after LMC has been initialized and
- * LMC(0..3)_RLEVEL_RANK(0..1), LMC(0..3)_WLEVEL_RANK(0..1) have valid data.
- * The field value is the minimum CK cycles between when the DRAM
+ * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
+ *
+ * The interpretation of the fields in this CSR depends on LMC(0)_CONFIG[DDR2T]:
+ *
+ * * If LMC()_CONFIG[DDR2T]=1, (FieldValue + 4) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ *
+ * * If LMC()_CONFIG[DDR2T]=0, (FieldValue + 3) is the minimum CK cycles between when the DRAM
  * part registers CAS commands of the first and second types from different cache blocks.
+ * FieldValue = 0 is always illegal in this case.
  *
- * The hardware-calculated minimums are:
- * min R2R_XRANK_INIT = 5 + MaxRdSkew MinRdSkew + LMC*_CONTROL[RODT_BPRCH]
- * min R2W_XRANK_INIT = 8 + (RL + MaxRdSkew) - (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]
- * min W2R_XRANK_INIT = 6 + MaxWrSkew + LMC*_CONTROL[FPRCH2]
- * min W2W_XRANK_INIT = 7 + MaxWrSkew - MinWrSkew
- * where
- * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects
- * AL)
- * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)
- * MinRdSkew = min(LMC*_RLEVEL_RANKi[BYTEj]/4)                              (min is across all
- * ranks i (0..3) and bytes j (0..8))
- * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1                          (max is across all
- * ranks i (0..3) and bytes j (0..8))
- * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX]     (min is across all
- * ranks i (0..3) and bytes j (0..8))
- * MaxWrSkew = max(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX] + 1 (max is across all
- * ranks i (0..3) and bytes j (0..8))
- * R2W_XRANK_INIT has 1 extra CK cycle built in for OCTEON-internal ODT settling/channel
- * turnaround time.
- * W2R_XRANK_INIT has 1 extra CK cycle built in for channel turnaround time.
+ * The hardware-calculated minimums for these fields are shown in LMC(0)_SLOT_CTL1 Hardware-
+ * Calculated Minimums.
  */
 union cvmx_lmcx_slot_ctl1 {
 	uint64_t u64;
@@ -9828,6 +11702,7 @@ union cvmx_lmcx_slot_ctl1 {
 	struct cvmx_lmcx_slot_ctl1_s          cn68xxp1;
 	struct cvmx_lmcx_slot_ctl1_s          cn70xx;
 	struct cvmx_lmcx_slot_ctl1_s          cn70xxp1;
+	struct cvmx_lmcx_slot_ctl1_s          cn73xx;
 	struct cvmx_lmcx_slot_ctl1_s          cn78xx;
 	struct cvmx_lmcx_slot_ctl1_s          cnf71xx;
 };
@@ -9838,35 +11713,21 @@ typedef union cvmx_lmcx_slot_ctl1 cvmx_lmcx_slot_ctl1_t;
  *
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
- * fields in this register to the minimum allowed value when any of LMC(0..3)_RLEVEL_RANK(0..1),
- * LMC(0..3)_WLEVEL_RANK(0..1)LMC*_WLEVEL_RANKn, LMC*_CONTROL and LMC*_MODEREG_PARAMS0 CSRs
- * change. Ideally, only read this register after LMC has been initialized and LMC*_RLEVEL_RANKn,
- * LMC*_WLEVEL_RANKn have valid data.
+ * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
+ * Ideally, only read this register after LMC has been initialized and
+ * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
  *
- * The field value is the minimum CK cycles between when the DRAM
- * part registers CAS commands of the first and second types from different cache blocks.
+ * The interpretation of the fields in this CSR depends on LMC(0)_CONFIG[DDR2T]:
+ *
+ * * If LMC()_CONFIG[DDR2T] = 1, (FieldValue + 4) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
  *
- * The hardware-calculated minimums are:
- * min R2R_XDIMM_INIT = 6 + MaxRdSkew MinRdSkew + LMC*_CONTROL[RODT_BPRCH]
- * min R2W_XDIMM_INIT = 9 + (RL + MaxRdSkew) - (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]
- * min W2R_XDIMM_INIT = 6 + MaxWrSkew + LMC*_CONTROL[FPRCH2]
- * min W2W_XDIMM_INIT = 8 + MaxWrSkew - MinWrSkew
- * where
- * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects
- * AL)
- * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)
- * MinRdSkew = min(LMC*_RLEVEL_RANKi[BYTEj]/4)                              (min is across all
- * ranks i (0..3) and bytes j (0..8))
- * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1                          (max is across all
- * ranks i (0..3) and bytes j (0..8))
- * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX]     (min is across all
- * ranks i (0..3) and bytes j (0..8))
- * MaxWrSkew = max(LMC*_WLEVEL_RANKi[BYTEj]/8) LMC*_CONFIG[EARLY_DQX] + 1 (max is across all
- * ranks i (0..3) and bytes j (0..8))
- * R2W_XDIMM_INIT has 2 extra CK cycles built in for OCTEON-internal ODT settling/channel
- * turnaround time.
- * R2R_XDIMM_INIT, W2R_XRANK_INIT, W2W_XDIMM_INIT have 1 extra CK cycle built in for channel
- * turnaround time.
+ * * If LMC()_CONFIG[DDR2T] = 0, (FieldValue + 3) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ * FieldValue = 0 is always illegal in this case.
+ *
+ * The hardware-calculated minimums for these fields are shown in LMC Registers.
  */
 union cvmx_lmcx_slot_ctl2 {
 	uint64_t u64;
@@ -9901,19 +11762,84 @@ union cvmx_lmcx_slot_ctl2 {
 	struct cvmx_lmcx_slot_ctl2_s          cn68xxp1;
 	struct cvmx_lmcx_slot_ctl2_s          cn70xx;
 	struct cvmx_lmcx_slot_ctl2_s          cn70xxp1;
+	struct cvmx_lmcx_slot_ctl2_s          cn73xx;
 	struct cvmx_lmcx_slot_ctl2_s          cn78xx;
 	struct cvmx_lmcx_slot_ctl2_s          cnf71xx;
 };
 typedef union cvmx_lmcx_slot_ctl2 cvmx_lmcx_slot_ctl2_t;
 
 /**
+ * cvmx_lmc#_slot_ctl3
+ *
+ * This register is an assortment of control fields needed by the memory controller. If software
+ * has not previously written to this register (since the last DRESET), hardware updates the
+ * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
+ * Ideally, only read this register after LMC has been initialized and
+ * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
+ *
+ * The interpretation of the fields in this CSR depends on LMC(0)_CONFIG[DDR2T]:
+ *
+ * * If LMC()_CONFIG[DDR2T] = 1, (FieldValue + 4) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ *
+ * * If LMC()_CONFIG[DDR2T] = 0, (FieldValue + 3) is the minimum CK cycles between when the
+ * DRAM part registers CAS commands of the first and second types from different cache blocks.
+ * FieldValue = 0 is always illegal in this case.
+ *
+ * The hardware-calculated minimums for these fields are shown in LMC Registers.
+ */
+union cvmx_lmcx_slot_ctl3 {
+	uint64_t u64;
+	struct cvmx_lmcx_slot_ctl3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t w2w_l_xrank_init             : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
+                                                         accesses to a different logical rank, and same BG for DDR4. */
+	uint64_t w2r_l_xrank_init             : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
+                                                         to a different logical rank, and same BG for DDR4. */
+	uint64_t r2w_l_xrank_init             : 6;  /**< Read-to-write spacing control for back-to-back read followed by write cache block accesses
+                                                         to a different logical rank, and same BG for DDR4. */
+	uint64_t r2r_l_xrank_init             : 6;  /**< Read-to-read spacing control for back-to-back read followed by read cache block accesses
+                                                         to a different logical rank, and same BG for DDR4. */
+	uint64_t w2w_xrank_init               : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
+                                                         accesses to a different logical rank. */
+	uint64_t w2r_xrank_init               : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
+                                                         to a different logical rank. */
+	uint64_t r2w_xrank_init               : 6;  /**< Read-to-write spacing control for back-to-back read followed by write cache block accesses
+                                                         to a different logical rank. */
+	uint64_t r2r_xrank_init               : 6;  /**< Read-to-read spacing control for back-to-back read followed by read cache block accesses
+                                                         to a different logical rank. */
+#else
+	uint64_t r2r_xrank_init               : 6;
+	uint64_t r2w_xrank_init               : 6;
+	uint64_t w2r_xrank_init               : 6;
+	uint64_t w2w_xrank_init               : 6;
+	uint64_t r2r_l_xrank_init             : 6;
+	uint64_t r2w_l_xrank_init             : 6;
+	uint64_t w2r_l_xrank_init             : 6;
+	uint64_t w2w_l_xrank_init             : 6;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_lmcx_slot_ctl3_s          cn73xx;
+};
+typedef union cvmx_lmcx_slot_ctl3 cvmx_lmcx_slot_ctl3_t;
+
+/**
  * cvmx_lmc#_timing_params0
  */
 union cvmx_lmcx_timing_params0 {
 	uint64_t u64;
 	struct cvmx_lmcx_timing_params0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_53_63               : 11;
+	uint64_t tbcw                         : 5;  /**< Indicates tBCW constraints. Set this field as follows:
+                                                         _ RNDUP[TBCW(ns) / TCYC(ns)] - 1
+                                                         where TBCW is from the JEDEC DDR4DB spec, and TCYC(ns) is the DDR clock frequency (not
+                                                         data rate).
+                                                         TYP = 16. */
+	uint64_t reserved_26_47               : 22;
 	uint64_t tmrd                         : 4;  /**< Indicates tMRD constraints.
                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,
                                                          where tMRD is from the DDR3 spec, and tCYC(ns)
@@ -9925,7 +11851,9 @@ union cvmx_lmcx_timing_params0 {
 	uint64_t tckeon                       : 8;
 	uint64_t reserved_8_21                : 14;
 	uint64_t tmrd                         : 4;
-	uint64_t reserved_26_63               : 38;
+	uint64_t reserved_26_47               : 22;
+	uint64_t tbcw                         : 5;
+	uint64_t reserved_53_63               : 11;
 #endif
 	} s;
 	struct cvmx_lmcx_timing_params0_cn61xx {
@@ -10140,6 +12068,81 @@ union cvmx_lmcx_timing_params0 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_timing_params0_cn70xx cn70xxp1;
+	struct cvmx_lmcx_timing_params0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_53_63               : 11;
+	uint64_t tbcw                         : 5;  /**< Indicates tBCW constraints. Set this field as follows:
+                                                         _ RNDUP[TBCW(ns) / TCYC(ns)] - 1
+                                                         where TBCW is from the JEDEC DDR4DB spec, and TCYC(ns) is the DDR clock frequency (not
+                                                         data rate).
+                                                         TYP = 16. */
+	uint64_t tcksre                       : 4;  /**< Indicates TCKSRE constraints. Set this field as follows:
+                                                         _ RNDUP[TCKSRE(ns) / TCYC(ns)] - 1
+                                                         where TCKSRE is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(5nCK, 10 ns). */
+	uint64_t trp                          : 5;  /**< Indicates TRP constraints. Set TRP as follows:
+                                                         _ RNDUP[TRP(ns) / TCYC(ns)] - 1
+                                                         where TRP and TRTP are from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency
+                                                         (not data rate).
+                                                         TYP TRP = 10-15ns.
+                                                         TYP TRTP = max(4nCK, 7.5 ns). */
+	uint64_t tzqinit                      : 4;  /**< Indicates TZQINIT constraints. Set this field as follows:
+                                                         _ RNDUP[TZQINIT(ns) / (256 * TCYC(ns))]
+                                                         where TZQINIT is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 2 (equivalent to 512). */
+	uint64_t tdllk                        : 4;  /**< Indicates TDLLK constraints. Set this field as follows:
+                                                         _ RNDUP[TDLLK(ns) / (256 * TCYC(ns))]
+                                                         where TDLLK is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 3 (equivalent to 768).
+                                                         This parameter is used in self-refresh exit and assumed to be greater than TRFC. */
+	uint64_t tmod                         : 5;  /**< Indicates tMOD constraints. Set this field as follows:
+                                                         _ RNDUP[TMOD(ns) / TCYC(ns)] - 1
+                                                         where TMOD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(24nCK, 15 ns). */
+	uint64_t tmrd                         : 4;  /**< Indicates TMRD constraints. Set this field as follows:
+                                                         _ RNDUP[TMRD(ns) / TCYC(ns)] - 1
+                                                         where TMRD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 8nCK. */
+	uint64_t txpr                         : 6;  /**< Indicates TXPR constraints. Set this field as follows:
+                                                         _ RNDUP[TXPR(ns) / (16 * TCYC(ns))]
+                                                         where TXPR is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(5nCK, TRFC+10 ns). */
+	uint64_t tcke                         : 4;  /**< Indicates TCKE constraints. Set this field as follows:
+                                                         _ RNDUP[TCKE(ns) / TCYC(ns)] - 1
+                                                         where TCKE is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(3nCK, 7.5/5.625/5.625/5 ns).
+                                                         Because a DDR4 register can shorten the pulse width of CKE (it delays the falling edge
+                                                         but does not delay the rising edge), care must be taken to set this parameter larger
+                                                         to account for this effective reduction in the pulse width. */
+	uint64_t tzqcs                        : 4;  /**< Indicates TZQCS constraints. This field is set as follows:
+                                                         _ RNDUP[(2 * TZQCS(ns)) / (16 * TCYC(ns))]
+                                                         where TZQCS is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP >= 8 (greater-than-or-equal-to 128), to allow for dclk90 calibration. */
+	uint64_t reserved_0_7                 : 8;
+#else
+	uint64_t reserved_0_7                 : 8;
+	uint64_t tzqcs                        : 4;
+	uint64_t tcke                         : 4;
+	uint64_t txpr                         : 6;
+	uint64_t tmrd                         : 4;
+	uint64_t tmod                         : 5;
+	uint64_t tdllk                        : 4;
+	uint64_t tzqinit                      : 4;
+	uint64_t trp                          : 5;
+	uint64_t tcksre                       : 4;
+	uint64_t tbcw                         : 5;
+	uint64_t reserved_53_63               : 11;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_timing_params0_cn70xx cn78xx;
 	struct cvmx_lmcx_timing_params0_cn61xx cnf71xx;
 };
@@ -10152,7 +12155,28 @@ union cvmx_lmcx_timing_params1 {
 	uint64_t u64;
 	struct cvmx_lmcx_timing_params1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_58_63               : 6;
+	uint64_t txp_ext                      : 1;  /**< A 1-bit extension to the TXP register to support DDR4-2666 and
+                                                         above. */
+	uint64_t tpdm_full_cycle_ena          : 1;  /**< When set, this field enables the addition of one-cycle delay to the
+                                                         Write/Read latency calculation. This is to compensate the case when
+                                                         tPDM delay in the RCD of an RDIMM/LRDIMM is greater than one-cycle.
+                                                         Only valid in RDIMM  (LMC()_CTL[RDIMM_ENA]=1) or LRDIMM
+                                                         (LMC()_CONFIG[LRDIMM_ENA=1) mode. */
+	uint64_t trfc_dlr                     : 7;  /**< Indicates TRFC_DLR constraints. Set this field as follows:
+                                                         _ RNDUP[TRFC_DLR(ns) / (8 * TCYC(ns))]
+                                                         where TRFC_DLR is from the JEDEC 3D Stacked SDRAM spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 90-120 ns.
+                                                         0x0 = reserved.
+                                                         0x1 = 8 TCYC.
+                                                         0x2 = 16 TCYC.
+                                                         0x3 = 24 TCYC.
+                                                         0x4 = 32 TCYC.
+                                                         - ...
+                                                         0x7E = 1008 TCYC.
+                                                         0x7F = 1016 TCYC. */
+	uint64_t reserved_4_48                : 45;
 	uint64_t tmprr                        : 4;  /**< Indicates tMPRR constraints.
                                                          Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,
                                                          where tMPRR is from the DDR3 spec, and tCYC(ns)
@@ -10160,7 +12184,11 @@ union cvmx_lmcx_timing_params1 {
                                                          TYP=1nCK */
 #else
 	uint64_t tmprr                        : 4;
-	uint64_t reserved_4_63                : 60;
+	uint64_t reserved_4_48                : 45;
+	uint64_t trfc_dlr                     : 7;
+	uint64_t tpdm_full_cycle_ena          : 1;
+	uint64_t txp_ext                      : 1;
+	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
 	struct cvmx_lmcx_timing_params1_cn61xx {
@@ -10491,6 +12519,138 @@ union cvmx_lmcx_timing_params1 {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_timing_params1_cn70xx cn70xxp1;
+	struct cvmx_lmcx_timing_params1_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_58_63               : 6;
+	uint64_t txp_ext                      : 1;  /**< A 1-bit extension to the TXP register to support DDR4-2666 and
+                                                         above. */
+	uint64_t tpdm_full_cycle_ena          : 1;  /**< When set, this field enables the addition of one-cycle delay to the
+                                                         Write/Read latency calculation. This is to compensate the case when
+                                                         tPDM delay in the RCD of an RDIMM/LRDIMM is greater than one-cycle.
+                                                         Only valid in RDIMM  (LMC()_CTL[RDIMM_ENA]=1) or LRDIMM
+                                                         (LMC()_CONFIG[LRDIMM_ENA=1) mode. */
+	uint64_t trfc_dlr                     : 7;  /**< Indicates TRFC_DLR constraints. Set this field as follows:
+                                                         _ RNDUP[TRFC_DLR(ns) / (8 * TCYC(ns))]
+                                                         where TRFC_DLR is from the JEDEC 3D Stacked SDRAM spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 90-120 ns.
+                                                         0x0 = reserved.
+                                                         0x1 = 8 TCYC.
+                                                         0x2 = 16 TCYC.
+                                                         0x3 = 24 TCYC.
+                                                         0x4 = 32 TCYC.
+                                                         - ...
+                                                         0x7E = 1008 TCYC.
+                                                         0x7F = 1016 TCYC. */
+	uint64_t txpdll                       : 5;  /**< Indicates TXPDLL constraints. Set this field as follows:
+                                                         _ RNDUP[TXPDLL(ns) / TCYC(ns)] - 1
+                                                         where TXPDLL is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP=max(10nCK, 24 ns) */
+	uint64_t tfaw                         : 5;  /**< Indicates TFAW constraints. Set this field as follows:
+                                                         _ RNDUP[TFAW(ns) / (4 * TCYC(ns))]
+                                                         where TFAW is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 30-40 ns
+                                                         When interfacing with DIMMs that contain 3DS DRAMs, set this field as follows:
+                                                         _ RNDUP[TFAW_SLR(ns) / (4 * TCYC(ns))]
+                                                         where TFAW_SLR is the Four activate window to the same logical rank from the
+                                                         JEDEC DDR4 3D Stacked spec. */
+	uint64_t twldqsen                     : 4;  /**< Indicates TWLDQSEN constraints. Set this field as follows:
+                                                         _ RNDUP[TWLDQSEN(ns) / (4 * TCYC(ns))]
+                                                         where TWLDQSEN is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(25nCK) */
+	uint64_t twlmrd                       : 4;  /**< Indicates TWLMRD constraints. Set this field as follows:
+                                                         _ RNDUP[TWLMRD(ns) / (4 * TCYC(ns))]
+                                                         where TWLMRD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(40nCK) */
+	uint64_t txp                          : 3;  /**< Indicates TXP constraints. Set this field as follows:
+                                                         _ RNDUP[TXP(ns) / TCYC(ns)] - 1
+                                                         where TXP is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP=max(3nCK, 7.5 ns) */
+	uint64_t trrd                         : 3;  /**< Indicates TRRD constraints. Set this field as follows:
+                                                         _ RNDUP[TRRD(ns) / TCYC(ns)] - 1,
+                                                         where TRRD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(4nCK, 10 ns)
+                                                         0x0 = Reserved.
+                                                         0x1 = 2 TCYC.
+                                                         - ...
+                                                         0x6 = 7 TCYC.
+                                                         0x7 = 8 TCYC.
+                                                         For DDR4, this is the TRRD_S parameter. */
+	uint64_t trfc                         : 7;  /**< Indicates TRFC constraints. Set this field as follows:
+                                                         _ RNDUP[TRFC(ns) / (8 * TCYC(ns))]
+                                                         where TRFC is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 90-350 ns
+                                                         0x0 = reserved.
+                                                         0x1 = 8 TCYC.
+                                                         0x2 = 16 TCYC.
+                                                         0x3 = 24 TCYC.
+                                                         0x4 = 32 TCYC.
+                                                         - ...
+                                                         0x7E = 1008 TCYC.
+                                                         0x7F = 1016 TCYC. */
+	uint64_t twtr                         : 4;  /**< Indicates TWTR constraints. Set this field as follows:
+                                                         _ RNDUP[TWTR(ns) / TCYC(ns)] - 1
+                                                         where TWTR is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = max(4nCK, 7.5 ns)
+                                                         For DDR4, this CSR field represents TWTR_S.
+                                                         0x0 = reserved.
+                                                         0x1 = 2.
+                                                         - ...
+                                                         0x7 = 8.
+                                                         0x8-0xF = reserved. */
+	uint64_t trcd                         : 4;  /**< Indicates TRCD constraints. Set this field as follows:
+                                                         _ RNDUP[TRCD(ns) / TCYC(ns)]
+                                                         where TRCD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 10-15 ns
+                                                         0x0 = reserved.
+                                                         0x1 = 2 (2 is the smallest value allowed).
+                                                         0x2 = 2.
+                                                         - ...
+                                                         0xE = 14.
+                                                         0xA-0xF = reserved.
+                                                         In 2T mode, make this register TRCD - 1, not going below 2. */
+	uint64_t tras                         : 6;  /**< Indicates TRAS constraints. Set TRAS (CSR field) as follows:
+                                                         _ RNDUP[TRAS(ns)/TCYC(ns)] - 1,
+                                                         where TRAS is from the DDR3/DDR4 spec, and TCYC(ns) is the DDR clock frequency (not data
+                                                         rate).
+                                                         TYP = 35ns - 9 * TREFI
+                                                         0x0 = reserved.
+                                                         0x1 = 2 TCYC.
+                                                         - 0010:  3 TCYC.
+                                                         - ...
+                                                         0x3F: 64 TCYC. */
+	uint64_t tmprr                        : 4;  /**< Indicates TMPRR constraints. Set this field as follows:
+                                                         _ RNDUP[TMPRR(ns) / TCYC(ns)] - 1
+                                                         where TMPRR is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
+                                                         frequency (not data rate).
+                                                         TYP = 1 nCK */
+#else
+	uint64_t tmprr                        : 4;
+	uint64_t tras                         : 6;
+	uint64_t trcd                         : 4;
+	uint64_t twtr                         : 4;
+	uint64_t trfc                         : 7;
+	uint64_t trrd                         : 3;
+	uint64_t txp                          : 3;
+	uint64_t twlmrd                       : 4;
+	uint64_t twldqsen                     : 4;
+	uint64_t tfaw                         : 5;
+	uint64_t txpdll                       : 5;
+	uint64_t trfc_dlr                     : 7;
+	uint64_t tpdm_full_cycle_ena          : 1;
+	uint64_t txp_ext                      : 1;
+	uint64_t reserved_58_63               : 6;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_timing_params1_cn70xx cn78xx;
 	struct cvmx_lmcx_timing_params1_cn61xx cnf71xx;
 };
@@ -10506,7 +12666,10 @@ union cvmx_lmcx_timing_params2 {
 	uint64_t u64;
 	struct cvmx_lmcx_timing_params2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_15_63               : 49;
+	uint64_t reserved_16_63               : 48;
+	uint64_t trrd_l_ext                   : 1;  /**< MSB of TWTR_L constraints. Set this field
+                                                         when requiring tRRD_L of more than 8 nCK. Otherwise
+                                                         this bit must be 0. */
 	uint64_t trtp                         : 4;  /**< Specifies the TRTP parameter, in cycles. Set this field as follows:
                                                          _ RNDUP[TRTP(ns) / TCYC(ns)] - 1,
                                                          For DDR3, typical = max(4 nCK, 7.5ns).
@@ -10539,12 +12702,47 @@ union cvmx_lmcx_timing_params2 {
 	uint64_t twtr_l                       : 4;
 	uint64_t t_rw_op_max                  : 4;
 	uint64_t trtp                         : 4;
-	uint64_t reserved_15_63               : 49;
+	uint64_t trrd_l_ext                   : 1;
+	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
-	struct cvmx_lmcx_timing_params2_s     cn70xx;
-	struct cvmx_lmcx_timing_params2_s     cn70xxp1;
-	struct cvmx_lmcx_timing_params2_s     cn78xx;
+	struct cvmx_lmcx_timing_params2_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t trtp                         : 4;  /**< Specifies the TRTP parameter, in cycles. Set this field as follows:
+                                                         RNDUP[TRTP(ns) / TCYC(ns)] - 1,
+                                                         For DDR3, typical = max(4 nCK, 7.5ns).
+                                                         For DDR4 the TRTP parameter is dictated by the TWR MR bits. */
+	uint64_t t_rw_op_max                  : 4;  /**< Specifies the maximum delay for a read or write operation to complete, used to set the
+                                                         timing of MRW and MPR operations. Set this field as follows:
+                                                         RNDUP[Maximum operation delay (cycles) / 8]
+                                                         Typical = 0x7. */
+	uint64_t twtr_l                       : 4;  /**< Specifies TWTR_L constraints. Set this field as follows:
+                                                         RNDUP[TWTR_L(ns) / TCYC(ns)] - 1
+                                                         where TWTR_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
+                                                         data rate).
+                                                         Typical = MAX(4 nCK, 7.5 ns)
+                                                         INTERNAL: Seems the '- 1' is because we add 1 back into slot timing equation */
+	uint64_t trrd_l                       : 3;  /**< Specifies TRRD_L constraints. Set this field as follows:
+                                                         RNDUP[TRRD_L(ns) / TCYC(ns)] - 1,
+                                                         where TRRD_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
+                                                         data rate).
+                                                         Typical = MAX(4 nCK, 7.5 ns)
+                                                         0x0 = reserved. 0x4 = five TCYC.
+                                                         0x1 = two TCYC. 0x5 = six TCYC.
+                                                         0x2 = three TCYC. 0x6 = seven TCYC.
+                                                         0x3 = four TCYC. 0x7 = eight TCYC. */
+#else
+	uint64_t trrd_l                       : 3;
+	uint64_t twtr_l                       : 4;
+	uint64_t t_rw_op_max                  : 4;
+	uint64_t trtp                         : 4;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_timing_params2_cn70xx cn70xxp1;
+	struct cvmx_lmcx_timing_params2_s     cn73xx;
+	struct cvmx_lmcx_timing_params2_cn70xx cn78xx;
 };
 typedef union cvmx_lmcx_timing_params2 cvmx_lmcx_timing_params2_t;
 
@@ -10668,6 +12866,7 @@ union cvmx_lmcx_wlevel_ctl {
 	struct cvmx_lmcx_wlevel_ctl_s         cn68xxp1;
 	struct cvmx_lmcx_wlevel_ctl_s         cn70xx;
 	struct cvmx_lmcx_wlevel_ctl_s         cn70xxp1;
+	struct cvmx_lmcx_wlevel_ctl_s         cn73xx;
 	struct cvmx_lmcx_wlevel_ctl_s         cn78xx;
 	struct cvmx_lmcx_wlevel_ctl_s         cnf71xx;
 };
@@ -10714,6 +12913,7 @@ union cvmx_lmcx_wlevel_dbg {
 	struct cvmx_lmcx_wlevel_dbg_s         cn68xxp1;
 	struct cvmx_lmcx_wlevel_dbg_s         cn70xx;
 	struct cvmx_lmcx_wlevel_dbg_s         cn70xxp1;
+	struct cvmx_lmcx_wlevel_dbg_s         cn73xx;
 	struct cvmx_lmcx_wlevel_dbg_s         cn78xx;
 	struct cvmx_lmcx_wlevel_dbg_s         cnf71xx;
 };
@@ -10808,6 +13008,7 @@ union cvmx_lmcx_wlevel_rankx {
 	struct cvmx_lmcx_wlevel_rankx_s       cn68xxp1;
 	struct cvmx_lmcx_wlevel_rankx_s       cn70xx;
 	struct cvmx_lmcx_wlevel_rankx_s       cn70xxp1;
+	struct cvmx_lmcx_wlevel_rankx_s       cn73xx;
 	struct cvmx_lmcx_wlevel_rankx_s       cn78xx;
 	struct cvmx_lmcx_wlevel_rankx_s       cnf71xx;
 };
@@ -11022,6 +13223,7 @@ union cvmx_lmcx_wodt_mask {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_wodt_mask_cn70xx     cn70xxp1;
+	struct cvmx_lmcx_wodt_mask_cn70xx     cn73xx;
 	struct cvmx_lmcx_wodt_mask_cn70xx     cn78xx;
 	struct cvmx_lmcx_wodt_mask_s          cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 74f8e9e..b284bfa 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -57,7 +57,7 @@
 #define CVMX_MIO_BOOT_COMP CVMX_MIO_BOOT_COMP_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_BOOT_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000000B8ull);
 }
@@ -79,6 +79,7 @@ static inline uint64_t CVMX_MIO_BOOT_CTL_FUNC(void)
 static inline uint64_t CVMX_MIO_BOOT_DMA_ADRX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_ADRX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000000110ull) + ((offset) & 1) * 8;
@@ -96,6 +97,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_CFGX(%lu) is invalid on this chip\n", offset);
@@ -114,6 +116,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_INTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_INTX(%lu) is invalid on this chip\n", offset);
@@ -140,6 +143,17 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_INT_ENX(unsigned long offset)
 #define CVMX_MIO_BOOT_DMA_INT_ENX(offset) (CVMX_ADD_IO_SEG(0x0001180000000150ull) + ((offset) & 3) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_MIO_BOOT_DMA_INT_W1SX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_MIO_BOOT_DMA_INT_W1SX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000000150ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_MIO_BOOT_DMA_INT_W1SX(offset) (CVMX_ADD_IO_SEG(0x0001180000000150ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 {
 	if (!(
@@ -149,6 +163,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_TIMX(%lu) is invalid on this chip\n", offset);
@@ -157,6 +172,17 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 #else
 #define CVMX_MIO_BOOT_DMA_TIMX(offset) (CVMX_ADD_IO_SEG(0x0001180000000120ull) + ((offset) & 3) * 8)
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_MIO_BOOT_ECO CVMX_MIO_BOOT_ECO_FUNC()
+static inline uint64_t CVMX_MIO_BOOT_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_MIO_BOOT_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800000001F8ull);
+}
+#else
+#define CVMX_MIO_BOOT_ECO (CVMX_ADD_IO_SEG(0x00011800000001F8ull))
+#endif
 #define CVMX_MIO_BOOT_ERR (CVMX_ADD_IO_SEG(0x00011800000000A0ull))
 #define CVMX_MIO_BOOT_INT (CVMX_ADD_IO_SEG(0x00011800000000A8ull))
 #define CVMX_MIO_BOOT_LOC_ADR (CVMX_ADD_IO_SEG(0x0001180000000090ull))
@@ -176,6 +202,7 @@ static inline uint64_t CVMX_MIO_BOOT_LOC_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_LOC_CFGX(%lu) is invalid on this chip\n", offset);
@@ -189,7 +216,7 @@ static inline uint64_t CVMX_MIO_BOOT_LOC_CFGX(unsigned long offset)
 #define CVMX_MIO_BOOT_PIN_DEFS CVMX_MIO_BOOT_PIN_DEFS_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_PIN_DEFS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_BOOT_PIN_DEFS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000000C0ull);
 }
@@ -212,6 +239,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_MIO_BOOT_REG_CFGX(%lu) is invalid on this chip\n", offset);
@@ -236,6 +264,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_TIMX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_MIO_BOOT_REG_TIMX(%lu) is invalid on this chip\n", offset);
@@ -249,7 +278,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_TIMX(unsigned long offset)
 #define CVMX_MIO_EMM_ACCESS_WDOG CVMX_MIO_EMM_ACCESS_WDOG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_ACCESS_WDOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_ACCESS_WDOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020F0ull);
 }
@@ -260,7 +289,7 @@ static inline uint64_t CVMX_MIO_EMM_ACCESS_WDOG_FUNC(void)
 #define CVMX_MIO_EMM_BUF_DAT CVMX_MIO_EMM_BUF_DAT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_BUF_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_BUF_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020E8ull);
 }
@@ -271,7 +300,7 @@ static inline uint64_t CVMX_MIO_EMM_BUF_DAT_FUNC(void)
 #define CVMX_MIO_EMM_BUF_IDX CVMX_MIO_EMM_BUF_IDX_FUNC()
 static inline uint64_t CVMX_MIO_EMM_BUF_IDX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_BUF_IDX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020E0ull);
 }
@@ -282,7 +311,7 @@ static inline uint64_t CVMX_MIO_EMM_BUF_IDX_FUNC(void)
 #define CVMX_MIO_EMM_CFG CVMX_MIO_EMM_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002000ull);
 }
@@ -293,7 +322,7 @@ static inline uint64_t CVMX_MIO_EMM_CFG_FUNC(void)
 #define CVMX_MIO_EMM_CMD CVMX_MIO_EMM_CMD_FUNC()
 static inline uint64_t CVMX_MIO_EMM_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002058ull);
 }
@@ -304,7 +333,7 @@ static inline uint64_t CVMX_MIO_EMM_CMD_FUNC(void)
 #define CVMX_MIO_EMM_DMA CVMX_MIO_EMM_DMA_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002050ull);
 }
@@ -315,7 +344,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FUNC(void)
 #define CVMX_MIO_EMM_DMA_ADR CVMX_MIO_EMM_DMA_ADR_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000188ull);
 }
@@ -326,7 +355,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_ADR_FUNC(void)
 #define CVMX_MIO_EMM_DMA_CFG CVMX_MIO_EMM_DMA_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000180ull);
 }
@@ -337,7 +366,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_CFG_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_ADR CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000170ull);
 }
@@ -348,7 +377,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_CFG CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000160ull);
 }
@@ -359,7 +388,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_CMD CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000178ull);
 }
@@ -370,7 +399,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT CVMX_MIO_EMM_DMA_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000190ull);
 }
@@ -381,7 +410,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT_W1S CVMX_MIO_EMM_DMA_INT_W1S_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_INT_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000198ull);
 }
@@ -392,7 +421,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
 #define CVMX_MIO_EMM_INT CVMX_MIO_EMM_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002078ull);
 }
@@ -411,11 +440,23 @@ static inline uint64_t CVMX_MIO_EMM_INT_EN_FUNC(void)
 #define CVMX_MIO_EMM_INT_EN (CVMX_ADD_IO_SEG(0x0001180000002080ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_MIO_EMM_INT_W1S CVMX_MIO_EMM_INT_W1S_FUNC()
+static inline uint64_t CVMX_MIO_EMM_INT_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_MIO_EMM_INT_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180000002080ull);
+}
+#else
+#define CVMX_MIO_EMM_INT_W1S (CVMX_ADD_IO_SEG(0x0001180000002080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_EMM_MODEX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_MIO_EMM_MODEX(%lu) is invalid on this chip\n", offset);
@@ -428,7 +469,7 @@ static inline uint64_t CVMX_MIO_EMM_MODEX(unsigned long offset)
 #define CVMX_MIO_EMM_RCA CVMX_MIO_EMM_RCA_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RCA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RCA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020A0ull);
 }
@@ -439,7 +480,7 @@ static inline uint64_t CVMX_MIO_EMM_RCA_FUNC(void)
 #define CVMX_MIO_EMM_RSP_HI CVMX_MIO_EMM_RSP_HI_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002070ull);
 }
@@ -450,7 +491,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_HI_FUNC(void)
 #define CVMX_MIO_EMM_RSP_LO CVMX_MIO_EMM_RSP_LO_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002068ull);
 }
@@ -461,7 +502,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_LO_FUNC(void)
 #define CVMX_MIO_EMM_RSP_STS CVMX_MIO_EMM_RSP_STS_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002060ull);
 }
@@ -472,7 +513,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_STS_FUNC(void)
 #define CVMX_MIO_EMM_SAMPLE CVMX_MIO_EMM_SAMPLE_FUNC()
 static inline uint64_t CVMX_MIO_EMM_SAMPLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_SAMPLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002090ull);
 }
@@ -483,7 +524,7 @@ static inline uint64_t CVMX_MIO_EMM_SAMPLE_FUNC(void)
 #define CVMX_MIO_EMM_STS_MASK CVMX_MIO_EMM_STS_MASK_FUNC()
 static inline uint64_t CVMX_MIO_EMM_STS_MASK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_STS_MASK not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002098ull);
 }
@@ -494,7 +535,7 @@ static inline uint64_t CVMX_MIO_EMM_STS_MASK_FUNC(void)
 #define CVMX_MIO_EMM_SWITCH CVMX_MIO_EMM_SWITCH_FUNC()
 static inline uint64_t CVMX_MIO_EMM_SWITCH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_SWITCH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002048ull);
 }
@@ -505,7 +546,7 @@ static inline uint64_t CVMX_MIO_EMM_SWITCH_FUNC(void)
 #define CVMX_MIO_EMM_WDOG CVMX_MIO_EMM_WDOG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_WDOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_EMM_WDOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002088ull);
 }
@@ -525,6 +566,7 @@ static inline uint64_t CVMX_MIO_FUS_BNK_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_FUS_BNK_DATX(%lu) is invalid on this chip\n", offset);
@@ -541,7 +583,7 @@ static inline uint64_t CVMX_MIO_FUS_BNK_DATX(unsigned long offset)
 #define CVMX_MIO_FUS_DAT4 CVMX_MIO_FUS_DAT4_FUNC()
 static inline uint64_t CVMX_MIO_FUS_DAT4_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_DAT4 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001420ull);
 }
@@ -563,7 +605,7 @@ static inline uint64_t CVMX_MIO_FUS_EMA_FUNC(void)
 #define CVMX_MIO_FUS_INT CVMX_MIO_FUS_INT_FUNC()
 static inline uint64_t CVMX_MIO_FUS_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001548ull);
 }
@@ -588,6 +630,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 			break;
 	}
@@ -611,6 +654,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x0001180000001420ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001420ull);
@@ -620,7 +664,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 #define CVMX_MIO_FUS_PLL CVMX_MIO_FUS_PLL_FUNC()
 static inline uint64_t CVMX_MIO_FUS_PLL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_PLL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001580ull);
 }
@@ -632,7 +676,7 @@ static inline uint64_t CVMX_MIO_FUS_PLL_FUNC(void)
 #define CVMX_MIO_FUS_PROG_TIMES CVMX_MIO_FUS_PROG_TIMES_FUNC()
 static inline uint64_t CVMX_MIO_FUS_PROG_TIMES_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_PROG_TIMES not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001518ull);
 }
@@ -644,7 +688,7 @@ static inline uint64_t CVMX_MIO_FUS_PROG_TIMES_FUNC(void)
 #define CVMX_MIO_FUS_READ_TIMES CVMX_MIO_FUS_READ_TIMES_FUNC()
 static inline uint64_t CVMX_MIO_FUS_READ_TIMES_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_FUS_READ_TIMES not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001570ull);
 }
@@ -689,6 +733,7 @@ static inline uint64_t CVMX_MIO_FUS_RPR_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_FUS_RPR_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001530ull) + ((offset) & 1) * 8;
@@ -700,7 +745,7 @@ static inline uint64_t CVMX_MIO_FUS_RPR_DATX(unsigned long offset)
 #define CVMX_MIO_FUS_SOFT_REPAIR CVMX_MIO_FUS_SOFT_REPAIR_FUNC()
 static inline uint64_t CVMX_MIO_FUS_SOFT_REPAIR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_FUS_SOFT_REPAIR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001540ull);
 }
@@ -714,15 +759,16 @@ static inline uint64_t CVMX_MIO_FUS_SOFT_REPAIR_FUNC(void)
 static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
-			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
+			break;
 	}
 	cvmx_warn("CVMX_MIO_FUS_TGG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001428ull);
@@ -732,13 +778,14 @@ static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 }
@@ -825,7 +872,7 @@ static inline uint64_t CVMX_MIO_PLL_SETTING_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_HI_INCR CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_HI_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F40ull);
 }
@@ -836,7 +883,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_LO_INCR CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_LO_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F48ull);
 }
@@ -847,7 +894,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_THRESH_HI CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_THRESH_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F38ull);
 }
@@ -858,7 +905,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_THRESH_LO CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_THRESH_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F30ull);
 }
@@ -869,7 +916,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_CFG CVMX_MIO_PTP_CLOCK_CFG_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F00ull);
 }
@@ -880,7 +927,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_CFG_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_COMP CVMX_MIO_PTP_CLOCK_COMP_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F18ull);
 }
@@ -891,7 +938,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_COMP_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_HI CVMX_MIO_PTP_CLOCK_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F10ull);
 }
@@ -902,7 +949,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_HI_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_LO CVMX_MIO_PTP_CLOCK_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F08ull);
 }
@@ -913,7 +960,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_LO_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_ERR_INT CVMX_MIO_PTP_DPLL_ERR_INT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F90ull);
 }
@@ -924,7 +971,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_INT_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_ERR_THRESH CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_ERR_THRESH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F88ull);
 }
@@ -935,7 +982,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_INCR CVMX_MIO_PTP_DPLL_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F80ull);
 }
@@ -946,7 +993,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_INCR_FUNC(void)
 #define CVMX_MIO_PTP_EVT_CNT CVMX_MIO_PTP_EVT_CNT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_EVT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_EVT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F28ull);
 }
@@ -957,7 +1004,7 @@ static inline uint64_t CVMX_MIO_PTP_EVT_CNT_FUNC(void)
 #define CVMX_MIO_PTP_EVT_INT CVMX_MIO_PTP_EVT_INT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_EVT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MIO_PTP_EVT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F70ull);
 }
@@ -979,7 +1026,7 @@ static inline uint64_t CVMX_MIO_PTP_PHY_1PPS_IN_FUNC(void)
 #define CVMX_MIO_PTP_PPS_HI_INCR CVMX_MIO_PTP_PPS_HI_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_HI_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_HI_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F60ull);
 }
@@ -990,7 +1037,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_HI_INCR_FUNC(void)
 #define CVMX_MIO_PTP_PPS_LO_INCR CVMX_MIO_PTP_PPS_LO_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_LO_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_LO_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F68ull);
 }
@@ -1001,7 +1048,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_LO_INCR_FUNC(void)
 #define CVMX_MIO_PTP_PPS_THRESH_HI CVMX_MIO_PTP_PPS_THRESH_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_THRESH_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F58ull);
 }
@@ -1012,7 +1059,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_HI_FUNC(void)
 #define CVMX_MIO_PTP_PPS_THRESH_LO CVMX_MIO_PTP_PPS_THRESH_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_THRESH_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F50ull);
 }
@@ -1023,7 +1070,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_LO_FUNC(void)
 #define CVMX_MIO_PTP_TIMESTAMP CVMX_MIO_PTP_TIMESTAMP_FUNC()
 static inline uint64_t CVMX_MIO_PTP_TIMESTAMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MIO_PTP_TIMESTAMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F20ull);
 }
@@ -1155,6 +1202,7 @@ static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_INT(%lu) is invalid on this chip\n", offset);
@@ -1164,6 +1212,17 @@ static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 #define CVMX_MIO_TWSX_INT(offset) (CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 1) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_MIO_TWSX_INT_W1S(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_MIO_TWSX_INT_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512;
+}
+#else
+#define CVMX_MIO_TWSX_INT_W1S(offset) (CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
 {
 	if (!(
@@ -1179,6 +1238,7 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_SW_TWSI(%lu) is invalid on this chip\n", offset);
@@ -1203,6 +1263,7 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI_EXT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_SW_TWSI_EXT(%lu) is invalid on this chip\n", offset);
@@ -1227,6 +1288,7 @@ static inline uint64_t CVMX_MIO_TWSX_TWSI_SW(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_TWSX_TWSI_SW(%lu) is invalid on this chip\n", offset);
@@ -1526,6 +1588,7 @@ static inline uint64_t CVMX_MIO_UARTX_DLH(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_DLH(%lu) is invalid on this chip\n", offset);
@@ -1550,6 +1613,7 @@ static inline uint64_t CVMX_MIO_UARTX_DLL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_DLL(%lu) is invalid on this chip\n", offset);
@@ -1574,6 +1638,7 @@ static inline uint64_t CVMX_MIO_UARTX_FAR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_FAR(%lu) is invalid on this chip\n", offset);
@@ -1598,6 +1663,7 @@ static inline uint64_t CVMX_MIO_UARTX_FCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_FCR(%lu) is invalid on this chip\n", offset);
@@ -1622,6 +1688,7 @@ static inline uint64_t CVMX_MIO_UARTX_HTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_HTX(%lu) is invalid on this chip\n", offset);
@@ -1646,6 +1713,7 @@ static inline uint64_t CVMX_MIO_UARTX_IER(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_IER(%lu) is invalid on this chip\n", offset);
@@ -1670,6 +1738,7 @@ static inline uint64_t CVMX_MIO_UARTX_IIR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_IIR(%lu) is invalid on this chip\n", offset);
@@ -1694,6 +1763,7 @@ static inline uint64_t CVMX_MIO_UARTX_LCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_LCR(%lu) is invalid on this chip\n", offset);
@@ -1718,6 +1788,7 @@ static inline uint64_t CVMX_MIO_UARTX_LSR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_LSR(%lu) is invalid on this chip\n", offset);
@@ -1742,6 +1813,7 @@ static inline uint64_t CVMX_MIO_UARTX_MCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_MCR(%lu) is invalid on this chip\n", offset);
@@ -1766,6 +1838,7 @@ static inline uint64_t CVMX_MIO_UARTX_MSR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_MSR(%lu) is invalid on this chip\n", offset);
@@ -1790,6 +1863,7 @@ static inline uint64_t CVMX_MIO_UARTX_RBR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RBR(%lu) is invalid on this chip\n", offset);
@@ -1814,6 +1888,7 @@ static inline uint64_t CVMX_MIO_UARTX_RFL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RFL(%lu) is invalid on this chip\n", offset);
@@ -1838,6 +1913,7 @@ static inline uint64_t CVMX_MIO_UARTX_RFW(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_RFW(%lu) is invalid on this chip\n", offset);
@@ -1862,6 +1938,7 @@ static inline uint64_t CVMX_MIO_UARTX_SBCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SBCR(%lu) is invalid on this chip\n", offset);
@@ -1886,6 +1963,7 @@ static inline uint64_t CVMX_MIO_UARTX_SCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SCR(%lu) is invalid on this chip\n", offset);
@@ -1910,6 +1988,7 @@ static inline uint64_t CVMX_MIO_UARTX_SFE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SFE(%lu) is invalid on this chip\n", offset);
@@ -1934,6 +2013,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRR(%lu) is invalid on this chip\n", offset);
@@ -1958,6 +2038,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRT(%lu) is invalid on this chip\n", offset);
@@ -1982,6 +2063,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_SRTS(%lu) is invalid on this chip\n", offset);
@@ -2006,6 +2088,7 @@ static inline uint64_t CVMX_MIO_UARTX_STT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_STT(%lu) is invalid on this chip\n", offset);
@@ -2030,6 +2113,7 @@ static inline uint64_t CVMX_MIO_UARTX_TFL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_TFL(%lu) is invalid on this chip\n", offset);
@@ -2054,6 +2138,7 @@ static inline uint64_t CVMX_MIO_UARTX_TFR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_TFR(%lu) is invalid on this chip\n", offset);
@@ -2078,6 +2163,7 @@ static inline uint64_t CVMX_MIO_UARTX_THR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_THR(%lu) is invalid on this chip\n", offset);
@@ -2102,6 +2188,7 @@ static inline uint64_t CVMX_MIO_UARTX_USR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_UARTX_USR(%lu) is invalid on this chip\n", offset);
@@ -2251,6 +2338,7 @@ union cvmx_mio_boot_bist_stat {
 #endif
 	} cn70xx;
 	struct cvmx_mio_boot_bist_stat_cn70xx cn70xxp1;
+	struct cvmx_mio_boot_bist_stat_cn66xx cn73xx;
 	struct cvmx_mio_boot_bist_stat_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
@@ -2333,6 +2421,7 @@ union cvmx_mio_boot_comp {
 #endif
 	} cn70xx;
 	struct cvmx_mio_boot_comp_cn70xx      cn70xxp1;
+	struct cvmx_mio_boot_comp_cn70xx      cn73xx;
 	struct cvmx_mio_boot_comp_cn70xx      cn78xx;
 	struct cvmx_mio_boot_comp_cn61xx      cnf71xx;
 };
@@ -2394,6 +2483,7 @@ union cvmx_mio_boot_dma_adrx {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_mio_boot_dma_adrx_s       cn73xx;
 	struct cvmx_mio_boot_dma_adrx_s       cn78xx;
 };
 typedef union cvmx_mio_boot_dma_adrx cvmx_mio_boot_dma_adrx_t;
@@ -2449,7 +2539,7 @@ union cvmx_mio_boot_dma_cfgx {
 	struct cvmx_mio_boot_dma_cfgx_s       cn66xx;
 	struct cvmx_mio_boot_dma_cfgx_s       cn68xx;
 	struct cvmx_mio_boot_dma_cfgx_s       cn68xxp1;
-	struct cvmx_mio_boot_dma_cfgx_cn78xx {
+	struct cvmx_mio_boot_dma_cfgx_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t en                           : 1;  /**< DMA engine 0-1 enable. */
 	uint64_t rw                           : 1;  /**< DMA engine 0-1 R/W bit (0 = read, 1 = write). */
@@ -2479,7 +2569,8 @@ union cvmx_mio_boot_dma_cfgx {
 	uint64_t rw                           : 1;
 	uint64_t en                           : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mio_boot_dma_cfgx_cn73xx  cn78xx;
 	struct cvmx_mio_boot_dma_cfgx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_dma_cfgx cvmx_mio_boot_dma_cfgx_t;
@@ -2513,6 +2604,7 @@ union cvmx_mio_boot_dma_intx {
 	struct cvmx_mio_boot_dma_intx_s       cn66xx;
 	struct cvmx_mio_boot_dma_intx_s       cn68xx;
 	struct cvmx_mio_boot_dma_intx_s       cn68xxp1;
+	struct cvmx_mio_boot_dma_intx_s       cn73xx;
 	struct cvmx_mio_boot_dma_intx_s       cn78xx;
 	struct cvmx_mio_boot_dma_intx_s       cnf71xx;
 };
@@ -2552,6 +2644,29 @@ union cvmx_mio_boot_dma_int_enx {
 typedef union cvmx_mio_boot_dma_int_enx cvmx_mio_boot_dma_int_enx_t;
 
 /**
+ * cvmx_mio_boot_dma_int_w1s#
+ *
+ * This register sets MIO_BOOT_DMA_INT() interrupts.
+ *
+ */
+union cvmx_mio_boot_dma_int_w1sx {
+	uint64_t u64;
+	struct cvmx_mio_boot_dma_int_w1sx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t dmarq                        : 1;  /**< Reads MIO_BOOT_DMA_INT()[DMARQ]. */
+	uint64_t done                         : 1;  /**< Reads or sets MIO_BOOT_DMA_INT()[DONE]. */
+#else
+	uint64_t done                         : 1;
+	uint64_t dmarq                        : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_mio_boot_dma_int_w1sx_s   cn73xx;
+};
+typedef union cvmx_mio_boot_dma_int_w1sx cvmx_mio_boot_dma_int_w1sx_t;
+
+/**
  * cvmx_mio_boot_dma_tim#
  *
  * This is the DMA engine n timing register (one register for each of two engines).
@@ -2604,12 +2719,31 @@ union cvmx_mio_boot_dma_timx {
 	struct cvmx_mio_boot_dma_timx_s       cn66xx;
 	struct cvmx_mio_boot_dma_timx_s       cn68xx;
 	struct cvmx_mio_boot_dma_timx_s       cn68xxp1;
+	struct cvmx_mio_boot_dma_timx_s       cn73xx;
 	struct cvmx_mio_boot_dma_timx_s       cn78xx;
 	struct cvmx_mio_boot_dma_timx_s       cnf71xx;
 };
 typedef union cvmx_mio_boot_dma_timx cvmx_mio_boot_dma_timx_t;
 
 /**
+ * cvmx_mio_boot_eco
+ */
+union cvmx_mio_boot_eco {
+	uint64_t u64;
+	struct cvmx_mio_boot_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< ECO flops. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_mio_boot_eco_s            cn73xx;
+};
+typedef union cvmx_mio_boot_eco cvmx_mio_boot_eco_t;
+
+/**
  * cvmx_mio_boot_err
  *
  * The boot-error register contains the address decode error and wait mode error bits.
@@ -2647,6 +2781,7 @@ union cvmx_mio_boot_err {
 	struct cvmx_mio_boot_err_s            cn68xxp1;
 	struct cvmx_mio_boot_err_s            cn70xx;
 	struct cvmx_mio_boot_err_s            cn70xxp1;
+	struct cvmx_mio_boot_err_s            cn73xx;
 	struct cvmx_mio_boot_err_s            cn78xx;
 	struct cvmx_mio_boot_err_s            cnf71xx;
 };
@@ -2737,6 +2872,7 @@ union cvmx_mio_boot_loc_adr {
 	struct cvmx_mio_boot_loc_adr_s        cn68xxp1;
 	struct cvmx_mio_boot_loc_adr_s        cn70xx;
 	struct cvmx_mio_boot_loc_adr_s        cn70xxp1;
+	struct cvmx_mio_boot_loc_adr_s        cn73xx;
 	struct cvmx_mio_boot_loc_adr_s        cn78xx;
 	struct cvmx_mio_boot_loc_adr_s        cnf71xx;
 };
@@ -2785,6 +2921,7 @@ union cvmx_mio_boot_loc_cfgx {
 	struct cvmx_mio_boot_loc_cfgx_s       cn68xxp1;
 	struct cvmx_mio_boot_loc_cfgx_s       cn70xx;
 	struct cvmx_mio_boot_loc_cfgx_s       cn70xxp1;
+	struct cvmx_mio_boot_loc_cfgx_s       cn73xx;
 	struct cvmx_mio_boot_loc_cfgx_s       cn78xx;
 	struct cvmx_mio_boot_loc_cfgx_s       cnf71xx;
 };
@@ -2824,6 +2961,7 @@ union cvmx_mio_boot_loc_dat {
 	struct cvmx_mio_boot_loc_dat_s        cn68xxp1;
 	struct cvmx_mio_boot_loc_dat_s        cn70xx;
 	struct cvmx_mio_boot_loc_dat_s        cn70xxp1;
+	struct cvmx_mio_boot_loc_dat_s        cn73xx;
 	struct cvmx_mio_boot_loc_dat_s        cn78xx;
 	struct cvmx_mio_boot_loc_dat_s        cnf71xx;
 };
@@ -2963,6 +3101,66 @@ union cvmx_mio_boot_pin_defs {
 #endif
 	} cn70xx;
 	struct cvmx_mio_boot_pin_defs_cn70xx  cn70xxp1;
+	struct cvmx_mio_boot_pin_defs_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_56_63               : 8;
+	uint64_t rgm_supply                   : 2;  /**< RGMii power supply setting based on VDD_RGM_SUPPLY_SELECT pin:
+                                                         0x1 = 1.8V.
+                                                         0x2 = 2.5V.
+                                                         else Reserved. */
+	uint64_t smi_supply                   : 3;  /**< SMI power supply setting based on VDD_SMI_SUPPLY_SELECT pin:
+                                                         0x1 = 1.8V.
+                                                         0x2 = 2.5V.
+                                                         0x8 = 3.3V.
+                                                         else Reserved. */
+	uint64_t io_supply                    : 3;  /**< I/O power supply setting based on VDD_IO_SUPPLY_SELECT pin:
+                                                         0x1 = 1.8V.
+                                                         0x2 = 2.5V.
+                                                         0x8 = 3.3V.
+                                                         else Reserved. */
+	uint64_t reserved_33_47               : 15;
+	uint64_t vrm_disable                  : 1;  /**< VRM disabled. */
+	uint64_t user1                        : 13; /**< BOOT_AD<31:19> latched during power up. */
+	uint64_t device                       : 3;  /**< BOOT_AD<18:16> latched during power up. Indicates boot device:
+                                                         0x0 = Parallel NOR.
+                                                         0x1 = Reserved.
+                                                         0x2 = eMMC/SD.
+                                                         0x3 = Reserved.
+                                                         0x4 = SPI Boot (16-bit address).
+                                                         0x5 = SPI Boot (24-bit address).
+                                                         0x6 = SPI Boot (32-bit address).
+                                                         0x7 = Reserved. */
+	uint64_t ale                          : 1;  /**< Region 0 default ALE mode. */
+	uint64_t width                        : 1;  /**< Region 0 default bus width. */
+	uint64_t pcie2_dlm5                   : 1;  /**< PCIe2 QLM/DLM Selection at powerup:
+                                                         0 = PCIe2 is mapped to QLM2 (default).
+                                                         1 = PCIe2 is mapped to DLM5. */
+	uint64_t dmack_p1                     : 1;  /**< BOOT_DMACK<1> default polarity. */
+	uint64_t dmack_p0                     : 1;  /**< BOOT_DMACK<0> default polarity. */
+	uint64_t term                         : 2;  /**< Selects default boot-bus driver termination.
+                                                         0x0 = full strength.
+                                                         0x1 = 25ohm.
+                                                         0x2 = 50ohm.
+                                                         0x3 = 65ohm. */
+	uint64_t user0                        : 9;  /**< BOOT_AD<8:0> latched during power up. */
+#else
+	uint64_t user0                        : 9;
+	uint64_t term                         : 2;
+	uint64_t dmack_p0                     : 1;
+	uint64_t dmack_p1                     : 1;
+	uint64_t pcie2_dlm5                   : 1;
+	uint64_t width                        : 1;
+	uint64_t ale                          : 1;
+	uint64_t device                       : 3;
+	uint64_t user1                        : 13;
+	uint64_t vrm_disable                  : 1;
+	uint64_t reserved_33_47               : 15;
+	uint64_t io_supply                    : 3;
+	uint64_t smi_supply                   : 3;
+	uint64_t rgm_supply                   : 2;
+	uint64_t reserved_56_63               : 8;
+#endif
+	} cn73xx;
 	struct cvmx_mio_boot_pin_defs_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
@@ -3146,6 +3344,7 @@ union cvmx_mio_boot_reg_cfgx {
 	struct cvmx_mio_boot_reg_cfgx_s       cn68xxp1;
 	struct cvmx_mio_boot_reg_cfgx_s       cn70xx;
 	struct cvmx_mio_boot_reg_cfgx_s       cn70xxp1;
+	struct cvmx_mio_boot_reg_cfgx_s       cn73xx;
 	struct cvmx_mio_boot_reg_cfgx_s       cn78xx;
 	struct cvmx_mio_boot_reg_cfgx_s       cnf71xx;
 };
@@ -3239,6 +3438,7 @@ union cvmx_mio_boot_reg_timx {
 	struct cvmx_mio_boot_reg_timx_s       cn68xxp1;
 	struct cvmx_mio_boot_reg_timx_s       cn70xx;
 	struct cvmx_mio_boot_reg_timx_s       cn70xxp1;
+	struct cvmx_mio_boot_reg_timx_s       cn73xx;
 	struct cvmx_mio_boot_reg_timx_s       cn78xx;
 	struct cvmx_mio_boot_reg_timx_s       cnf71xx;
 };
@@ -3300,6 +3500,7 @@ union cvmx_mio_boot_thr {
 	struct cvmx_mio_boot_thr_s            cn68xxp1;
 	struct cvmx_mio_boot_thr_s            cn70xx;
 	struct cvmx_mio_boot_thr_s            cn70xxp1;
+	struct cvmx_mio_boot_thr_s            cn73xx;
 	struct cvmx_mio_boot_thr_s            cn78xx;
 	struct cvmx_mio_boot_thr_s            cnf71xx;
 };
@@ -3322,6 +3523,7 @@ union cvmx_mio_emm_access_wdog {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_mio_emm_access_wdog_s     cn73xx;
 	struct cvmx_mio_emm_access_wdog_s     cn78xx;
 };
 typedef union cvmx_mio_emm_access_wdog cvmx_mio_emm_access_wdog_t;
@@ -3345,6 +3547,7 @@ union cvmx_mio_emm_buf_dat {
 	struct cvmx_mio_emm_buf_dat_s         cn61xx;
 	struct cvmx_mio_emm_buf_dat_s         cn70xx;
 	struct cvmx_mio_emm_buf_dat_s         cn70xxp1;
+	struct cvmx_mio_emm_buf_dat_s         cn73xx;
 	struct cvmx_mio_emm_buf_dat_s         cn78xx;
 	struct cvmx_mio_emm_buf_dat_s         cnf71xx;
 };
@@ -3378,6 +3581,7 @@ union cvmx_mio_emm_buf_idx {
 	struct cvmx_mio_emm_buf_idx_s         cn61xx;
 	struct cvmx_mio_emm_buf_idx_s         cn70xx;
 	struct cvmx_mio_emm_buf_idx_s         cn70xxp1;
+	struct cvmx_mio_emm_buf_idx_s         cn73xx;
 	struct cvmx_mio_emm_buf_idx_s         cn78xx;
 	struct cvmx_mio_emm_buf_idx_s         cnf71xx;
 };
@@ -3429,6 +3633,7 @@ union cvmx_mio_emm_cfg {
 	struct cvmx_mio_emm_cfg_s             cn61xx;
 	struct cvmx_mio_emm_cfg_s             cn70xx;
 	struct cvmx_mio_emm_cfg_s             cn70xxp1;
+	struct cvmx_mio_emm_cfg_s             cn73xx;
 	struct cvmx_mio_emm_cfg_s             cn78xx;
 	struct cvmx_mio_emm_cfg_s             cnf71xx;
 };
@@ -3537,6 +3742,7 @@ union cvmx_mio_emm_cmd {
 	} cn61xx;
 	struct cvmx_mio_emm_cmd_cn61xx        cn70xx;
 	struct cvmx_mio_emm_cmd_cn61xx        cn70xxp1;
+	struct cvmx_mio_emm_cmd_s             cn73xx;
 	struct cvmx_mio_emm_cmd_s             cn78xx;
 	struct cvmx_mio_emm_cmd_cn61xx        cnf71xx;
 };
@@ -3637,6 +3843,7 @@ union cvmx_mio_emm_dma {
 	} cn61xx;
 	struct cvmx_mio_emm_dma_cn61xx        cn70xx;
 	struct cvmx_mio_emm_dma_cn61xx        cn70xxp1;
+	struct cvmx_mio_emm_dma_s             cn73xx;
 	struct cvmx_mio_emm_dma_s             cn78xx;
 	struct cvmx_mio_emm_dma_cn61xx        cnf71xx;
 };
@@ -3659,6 +3866,7 @@ union cvmx_mio_emm_dma_adr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_adr_s         cn73xx;
 	struct cvmx_mio_emm_dma_adr_s         cn78xx;
 };
 typedef union cvmx_mio_emm_dma_adr cvmx_mio_emm_dma_adr_t;
@@ -3697,6 +3905,7 @@ union cvmx_mio_emm_dma_cfg {
 	uint64_t en                           : 1;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_cfg_s         cn73xx;
 	struct cvmx_mio_emm_dma_cfg_s         cn78xx;
 };
 typedef union cvmx_mio_emm_dma_cfg cvmx_mio_emm_dma_cfg_t;
@@ -3721,6 +3930,7 @@ union cvmx_mio_emm_dma_fifo_adr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_fifo_adr_s    cn73xx;
 	struct cvmx_mio_emm_dma_fifo_adr_s    cn78xx;
 };
 typedef union cvmx_mio_emm_dma_fifo_adr cvmx_mio_emm_dma_fifo_adr_t;
@@ -3755,6 +3965,7 @@ union cvmx_mio_emm_dma_fifo_cfg {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_fifo_cfg_s    cn73xx;
 	struct cvmx_mio_emm_dma_fifo_cfg_s    cn78xx;
 };
 typedef union cvmx_mio_emm_dma_fifo_cfg cvmx_mio_emm_dma_fifo_cfg_t;
@@ -3797,6 +4008,7 @@ union cvmx_mio_emm_dma_fifo_cmd {
 	uint64_t reserved_63_63               : 1;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_fifo_cmd_s    cn73xx;
 	struct cvmx_mio_emm_dma_fifo_cmd_s    cn78xx;
 };
 typedef union cvmx_mio_emm_dma_fifo_cmd cvmx_mio_emm_dma_fifo_cmd_t;
@@ -3823,6 +4035,7 @@ union cvmx_mio_emm_dma_int {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_int_s         cn73xx;
 	struct cvmx_mio_emm_dma_int_s         cn78xx;
 };
 typedef union cvmx_mio_emm_dma_int cvmx_mio_emm_dma_int_t;
@@ -3846,6 +4059,7 @@ union cvmx_mio_emm_dma_int_w1s {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_mio_emm_dma_int_w1s_s     cn73xx;
 	struct cvmx_mio_emm_dma_int_w1s_s     cn78xx;
 };
 typedef union cvmx_mio_emm_dma_int_w1s cvmx_mio_emm_dma_int_w1s_t;
@@ -3887,6 +4101,7 @@ union cvmx_mio_emm_int {
 	struct cvmx_mio_emm_int_s             cn61xx;
 	struct cvmx_mio_emm_int_s             cn70xx;
 	struct cvmx_mio_emm_int_s             cn70xxp1;
+	struct cvmx_mio_emm_int_s             cn73xx;
 	struct cvmx_mio_emm_int_s             cn78xx;
 	struct cvmx_mio_emm_int_s             cnf71xx;
 };
@@ -3931,6 +4146,40 @@ union cvmx_mio_emm_int_en {
 typedef union cvmx_mio_emm_int_en cvmx_mio_emm_int_en_t;
 
 /**
+ * cvmx_mio_emm_int_w1s
+ */
+union cvmx_mio_emm_int_w1s {
+	uint64_t u64;
+	struct cvmx_mio_emm_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t switch_err                   : 1;  /**< Switch operation encountered an error. Throws MIO_EMM_INTSN_E::MIO_EMM_INT_SWITCH_ERR. */
+	uint64_t switch_done                  : 1;  /**< Switch operation completed successfully. Throws MIO_EMM_INTSN_E::MIO_EMM_INT_SWITCH_DONE. */
+	uint64_t dma_err                      : 1;  /**< DMA transfer encountered an error. See MIO_EMM_RSP_STS. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_DMA_ERR. */
+	uint64_t cmd_err                      : 1;  /**< Operation specified by MIO_EMM_CMD encountered an error. See MIO_EMM_RSP_STS. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_CMD_ERR. */
+	uint64_t dma_done                     : 1;  /**< DMA transfer completed successfully. Throws MIO_EMM_INTSN_E::MIO_EMM_INT_DMA_DONE. */
+	uint64_t cmd_done                     : 1;  /**< Operation specified by MIO_EMM_CMD completed successfully. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_CMD_DONE. */
+	uint64_t buf_done                     : 1;  /**< The next 512B block transfer of a multiblock transfer has completed. Throws
+                                                         MIO_EMM_INTSN_E::MIO_EMM_INT_BUF_DONE. */
+#else
+	uint64_t buf_done                     : 1;
+	uint64_t cmd_done                     : 1;
+	uint64_t dma_done                     : 1;
+	uint64_t cmd_err                      : 1;
+	uint64_t dma_err                      : 1;
+	uint64_t switch_done                  : 1;
+	uint64_t switch_err                   : 1;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} s;
+	struct cvmx_mio_emm_int_w1s_s         cn73xx;
+};
+typedef union cvmx_mio_emm_int_w1s cvmx_mio_emm_int_w1s_t;
+
+/**
  * cvmx_mio_emm_mode#
  *
  * MIO_EMM_MODE = MIO EMMC Operating mode Register
@@ -3975,6 +4224,7 @@ union cvmx_mio_emm_modex {
 	struct cvmx_mio_emm_modex_s           cn61xx;
 	struct cvmx_mio_emm_modex_s           cn70xx;
 	struct cvmx_mio_emm_modex_s           cn70xxp1;
+	struct cvmx_mio_emm_modex_s           cn73xx;
 	struct cvmx_mio_emm_modex_s           cn78xx;
 	struct cvmx_mio_emm_modex_s           cnf71xx;
 };
@@ -3999,6 +4249,7 @@ union cvmx_mio_emm_rca {
 	struct cvmx_mio_emm_rca_s             cn61xx;
 	struct cvmx_mio_emm_rca_s             cn70xx;
 	struct cvmx_mio_emm_rca_s             cn70xxp1;
+	struct cvmx_mio_emm_rca_s             cn73xx;
 	struct cvmx_mio_emm_rca_s             cn78xx;
 	struct cvmx_mio_emm_rca_s             cnf71xx;
 };
@@ -4028,6 +4279,7 @@ union cvmx_mio_emm_rsp_hi {
 	struct cvmx_mio_emm_rsp_hi_s          cn61xx;
 	struct cvmx_mio_emm_rsp_hi_s          cn70xx;
 	struct cvmx_mio_emm_rsp_hi_s          cn70xxp1;
+	struct cvmx_mio_emm_rsp_hi_s          cn73xx;
 	struct cvmx_mio_emm_rsp_hi_s          cn78xx;
 	struct cvmx_mio_emm_rsp_hi_s          cnf71xx;
 };
@@ -4089,6 +4341,7 @@ union cvmx_mio_emm_rsp_lo {
 	struct cvmx_mio_emm_rsp_lo_s          cn61xx;
 	struct cvmx_mio_emm_rsp_lo_s          cn70xx;
 	struct cvmx_mio_emm_rsp_lo_s          cn70xxp1;
+	struct cvmx_mio_emm_rsp_lo_s          cn73xx;
 	struct cvmx_mio_emm_rsp_lo_s          cn78xx;
 	struct cvmx_mio_emm_rsp_lo_s          cnf71xx;
 };
@@ -4258,6 +4511,7 @@ union cvmx_mio_emm_rsp_sts {
 	} cn61xx;
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cn70xx;
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cn70xxp1;
+	struct cvmx_mio_emm_rsp_sts_s         cn73xx;
 	struct cvmx_mio_emm_rsp_sts_s         cn78xx;
 	struct cvmx_mio_emm_rsp_sts_cn61xx    cnf71xx;
 };
@@ -4286,6 +4540,7 @@ union cvmx_mio_emm_sample {
 	struct cvmx_mio_emm_sample_s          cn61xx;
 	struct cvmx_mio_emm_sample_s          cn70xx;
 	struct cvmx_mio_emm_sample_s          cn70xxp1;
+	struct cvmx_mio_emm_sample_s          cn73xx;
 	struct cvmx_mio_emm_sample_s          cn78xx;
 	struct cvmx_mio_emm_sample_s          cnf71xx;
 };
@@ -4309,6 +4564,7 @@ union cvmx_mio_emm_sts_mask {
 	struct cvmx_mio_emm_sts_mask_s        cn61xx;
 	struct cvmx_mio_emm_sts_mask_s        cn70xx;
 	struct cvmx_mio_emm_sts_mask_s        cn70xxp1;
+	struct cvmx_mio_emm_sts_mask_s        cn73xx;
 	struct cvmx_mio_emm_sts_mask_s        cn78xx;
 	struct cvmx_mio_emm_sts_mask_s        cnf71xx;
 };
@@ -4379,6 +4635,7 @@ union cvmx_mio_emm_switch {
 	struct cvmx_mio_emm_switch_s          cn61xx;
 	struct cvmx_mio_emm_switch_s          cn70xx;
 	struct cvmx_mio_emm_switch_s          cn70xxp1;
+	struct cvmx_mio_emm_switch_s          cn73xx;
 	struct cvmx_mio_emm_switch_s          cn78xx;
 	struct cvmx_mio_emm_switch_s          cnf71xx;
 };
@@ -4428,6 +4685,7 @@ union cvmx_mio_emm_wdog {
 	struct cvmx_mio_emm_wdog_s            cn61xx;
 	struct cvmx_mio_emm_wdog_s            cn70xx;
 	struct cvmx_mio_emm_wdog_s            cn70xxp1;
+	struct cvmx_mio_emm_wdog_s            cn73xx;
 	struct cvmx_mio_emm_wdog_s            cn78xx;
 	struct cvmx_mio_emm_wdog_s            cnf71xx;
 };
@@ -4465,6 +4723,7 @@ union cvmx_mio_fus_bnk_datx {
 	struct cvmx_mio_fus_bnk_datx_s        cn68xxp1;
 	struct cvmx_mio_fus_bnk_datx_s        cn70xx;
 	struct cvmx_mio_fus_bnk_datx_s        cn70xxp1;
+	struct cvmx_mio_fus_bnk_datx_s        cn73xx;
 	struct cvmx_mio_fus_bnk_datx_s        cn78xx;
 	struct cvmx_mio_fus_bnk_datx_s        cnf71xx;
 };
@@ -4503,6 +4762,7 @@ union cvmx_mio_fus_dat0 {
 	struct cvmx_mio_fus_dat0_s            cn68xxp1;
 	struct cvmx_mio_fus_dat0_s            cn70xx;
 	struct cvmx_mio_fus_dat0_s            cn70xxp1;
+	struct cvmx_mio_fus_dat0_s            cn73xx;
 	struct cvmx_mio_fus_dat0_s            cn78xx;
 	struct cvmx_mio_fus_dat0_s            cnf71xx;
 };
@@ -4541,6 +4801,7 @@ union cvmx_mio_fus_dat1 {
 	struct cvmx_mio_fus_dat1_s            cn68xxp1;
 	struct cvmx_mio_fus_dat1_s            cn70xx;
 	struct cvmx_mio_fus_dat1_s            cn70xxp1;
+	struct cvmx_mio_fus_dat1_s            cn73xx;
 	struct cvmx_mio_fus_dat1_s            cn78xx;
 	struct cvmx_mio_fus_dat1_s            cnf71xx;
 };
@@ -4992,6 +5253,7 @@ union cvmx_mio_fus_dat2 {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_dat2_cn70xx       cn70xxp1;
+	struct cvmx_mio_fus_dat2_cn70xx       cn73xx;
 	struct cvmx_mio_fus_dat2_cn70xx       cn78xx;
 	struct cvmx_mio_fus_dat2_cn61xx       cnf71xx;
 };
@@ -5009,7 +5271,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - DFA information (DTE) */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - DFA information (Cluster mask) */
-	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. Added in pass 2. */
+	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. */
 	uint64_t reserved_38_39               : 2;
 	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown */
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown */
@@ -5308,6 +5570,66 @@ union cvmx_mio_fus_dat3 {
 	uint64_t ema0                         : 6;
 #endif
 	} cn70xxp1;
+	struct cvmx_mio_fus_dat3_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
+                                                         will XOR with this value. */
+	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
+	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
+	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
+	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. */
+	uint64_t pll_bwadj_denom              : 2;  /**< Select CLKF denominator for BWADJ value.
+                                                         0x0 = Selects CLKF/4.
+                                                         0x1 = Selects CLKF/2.
+                                                         0x2 = Selects CLKF/8. */
+	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t pll_half_dis                 : 1;  /**< Fuse information - Coprocessor-clock PLL control. */
+	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C cripple:
+                                                         0x0 = Full cache (16-way, 16 MB).
+                                                         0x1 = 3/4 ways (12-way, 12 MB).
+                                                         0x2 = 1/2 ways (8-way, 8 MB).
+                                                         0x3 = 1/4 ways (4-way, 4MB).
+                                                         0x4-0x7 = Reserved. */
+	uint64_t use_int_refclk               : 1;  /**< If set use the PLL output as the low-jitter reference clock to the rclk DLLs. Default is
+                                                         to use the external input reference clock. */
+	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information. */
+	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIe specification. */
+	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
+	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
+	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: Default value is 0x11. Soft or hard blow of these fuses
+                                                         will XOR with this value. */
+	uint64_t nohna_dte                    : 1;  /**< Fuse information - HNA disable (DTE). */
+	uint64_t hna_info_dte                 : 3;  /**< Fuse information - HNA information (DTE). */
+	uint64_t hna_info_clm                 : 4;  /**< Fuse information - HNA information (cluster mask). */
+	uint64_t reserved_0_9                 : 10;
+#else
+	uint64_t reserved_0_9                 : 10;
+	uint64_t hna_info_clm                 : 4;
+	uint64_t hna_info_dte                 : 3;
+	uint64_t nohna_dte                    : 1;
+	uint64_t ema1                         : 6;
+	uint64_t nodfa_dte                    : 1;
+	uint64_t nozip                        : 1;
+	uint64_t efus_ign                     : 1;
+	uint64_t efus_lck                     : 1;
+	uint64_t bar2_sz_conf                 : 1;
+	uint64_t zip_info                     : 2;
+	uint64_t use_int_refclk               : 1;
+	uint64_t l2c_crip                     : 3;
+	uint64_t pll_half_dis                 : 1;
+	uint64_t efus_lck_man                 : 1;
+	uint64_t efus_lck_rsv                 : 1;
+	uint64_t pll_bwadj_denom              : 2;
+	uint64_t pll_alt_matrix               : 1;
+	uint64_t dfa_info_clm                 : 4;
+	uint64_t dfa_info_dte                 : 3;
+	uint64_t pll_ctl                      : 10;
+	uint64_t ema0                         : 6;
+#endif
+	} cn73xx;
 	struct cvmx_mio_fus_dat3_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
@@ -5398,6 +5720,7 @@ union cvmx_mio_fus_dat4 {
 	} s;
 	struct cvmx_mio_fus_dat4_s            cn70xx;
 	struct cvmx_mio_fus_dat4_s            cn70xxp1;
+	struct cvmx_mio_fus_dat4_s            cn73xx;
 	struct cvmx_mio_fus_dat4_s            cn78xx;
 };
 typedef union cvmx_mio_fus_dat4 cvmx_mio_fus_dat4_t;
@@ -5466,6 +5789,7 @@ union cvmx_mio_fus_int {
 	} s;
 	struct cvmx_mio_fus_int_s             cn70xx;
 	struct cvmx_mio_fus_int_s             cn70xxp1;
+	struct cvmx_mio_fus_int_s             cn73xx;
 	struct cvmx_mio_fus_int_s             cn78xx;
 };
 typedef union cvmx_mio_fus_int cvmx_mio_fus_int_t;
@@ -5496,6 +5820,7 @@ union cvmx_mio_fus_pdf {
 	struct cvmx_mio_fus_pdf_s             cn68xxp1;
 	struct cvmx_mio_fus_pdf_s             cn70xx;
 	struct cvmx_mio_fus_pdf_s             cn70xxp1;
+	struct cvmx_mio_fus_pdf_s             cn73xx;
 	struct cvmx_mio_fus_pdf_s             cn78xx;
 	struct cvmx_mio_fus_pdf_s             cnf71xx;
 };
@@ -5657,6 +5982,7 @@ union cvmx_mio_fus_pll {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_pll_cn70xx        cn70xxp1;
+	struct cvmx_mio_fus_pll_cn70xx        cn73xx;
 	struct cvmx_mio_fus_pll_cn70xx        cn78xx;
 	struct cvmx_mio_fus_pll_cn61xx        cnf71xx;
 };
@@ -5745,6 +6071,7 @@ union cvmx_mio_fus_prog {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_prog_cn70xx       cn70xxp1;
+	struct cvmx_mio_fus_prog_cn70xx       cn73xx;
 	struct cvmx_mio_fus_prog_cn70xx       cn78xx;
 	struct cvmx_mio_fus_prog_cn61xx       cnf71xx;
 };
@@ -5876,6 +6203,7 @@ union cvmx_mio_fus_prog_times {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_prog_times_cn70xx cn70xxp1;
+	struct cvmx_mio_fus_prog_times_cn70xx cn73xx;
 	struct cvmx_mio_fus_prog_times_cn70xx cn78xx;
 	struct cvmx_mio_fus_prog_times_cn61xx cnf71xx;
 };
@@ -5979,6 +6307,7 @@ union cvmx_mio_fus_rcmd {
 	struct cvmx_mio_fus_rcmd_cn52xx       cn68xxp1;
 	struct cvmx_mio_fus_rcmd_s            cn70xx;
 	struct cvmx_mio_fus_rcmd_s            cn70xxp1;
+	struct cvmx_mio_fus_rcmd_s            cn73xx;
 	struct cvmx_mio_fus_rcmd_s            cn78xx;
 	struct cvmx_mio_fus_rcmd_cn52xx       cnf71xx;
 };
@@ -6091,6 +6420,7 @@ union cvmx_mio_fus_read_times {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_read_times_cn70xx cn70xxp1;
+	struct cvmx_mio_fus_read_times_cn70xx cn73xx;
 	struct cvmx_mio_fus_read_times_cn70xx cn78xx;
 	struct cvmx_mio_fus_read_times_cn61xx cnf71xx;
 };
@@ -6193,6 +6523,7 @@ union cvmx_mio_fus_rpr_datx {
 	} s;
 	struct cvmx_mio_fus_rpr_datx_s        cn70xx;
 	struct cvmx_mio_fus_rpr_datx_s        cn70xxp1;
+	struct cvmx_mio_fus_rpr_datx_s        cn73xx;
 	struct cvmx_mio_fus_rpr_datx_s        cn78xx;
 };
 typedef union cvmx_mio_fus_rpr_datx cvmx_mio_fus_rpr_datx_t;
@@ -6226,6 +6557,7 @@ union cvmx_mio_fus_soft_repair {
 	} s;
 	struct cvmx_mio_fus_soft_repair_s     cn70xx;
 	struct cvmx_mio_fus_soft_repair_s     cn70xxp1;
+	struct cvmx_mio_fus_soft_repair_s     cn73xx;
 	struct cvmx_mio_fus_soft_repair_s     cn78xx;
 };
 typedef union cvmx_mio_fus_soft_repair cvmx_mio_fus_soft_repair_t;
@@ -6361,6 +6693,7 @@ union cvmx_mio_fus_tgg {
 	struct cvmx_mio_fus_tgg_s             cn66xx;
 	struct cvmx_mio_fus_tgg_s             cn70xx;
 	struct cvmx_mio_fus_tgg_s             cn70xxp1;
+	struct cvmx_mio_fus_tgg_s             cn73xx;
 	struct cvmx_mio_fus_tgg_s             cn78xx;
 	struct cvmx_mio_fus_tgg_s             cnf71xx;
 };
@@ -6451,6 +6784,7 @@ union cvmx_mio_fus_wadr {
 #endif
 	} cn70xx;
 	struct cvmx_mio_fus_wadr_cn70xx       cn70xxp1;
+	struct cvmx_mio_fus_wadr_cn70xx       cn73xx;
 	struct cvmx_mio_fus_wadr_cn70xx       cn78xx;
 	struct cvmx_mio_fus_wadr_cn61xx       cnf71xx;
 };
@@ -6674,6 +7008,7 @@ union cvmx_mio_ptp_ckout_hi_incr {
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn68xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn70xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn70xxp1;
+	struct cvmx_mio_ptp_ckout_hi_incr_s   cn73xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cn78xx;
 	struct cvmx_mio_ptp_ckout_hi_incr_s   cnf71xx;
 };
@@ -6701,6 +7036,7 @@ union cvmx_mio_ptp_ckout_lo_incr {
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn68xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn70xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn70xxp1;
+	struct cvmx_mio_ptp_ckout_lo_incr_s   cn73xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cn78xx;
 	struct cvmx_mio_ptp_ckout_lo_incr_s   cnf71xx;
 };
@@ -6727,6 +7063,7 @@ union cvmx_mio_ptp_ckout_thresh_hi {
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn68xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn70xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn70xxp1;
+	struct cvmx_mio_ptp_ckout_thresh_hi_s cn73xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cn78xx;
 	struct cvmx_mio_ptp_ckout_thresh_hi_s cnf71xx;
 };
@@ -6754,6 +7091,7 @@ union cvmx_mio_ptp_ckout_thresh_lo {
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn68xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn70xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn70xxp1;
+	struct cvmx_mio_ptp_ckout_thresh_lo_s cn73xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cn78xx;
 	struct cvmx_mio_ptp_ckout_thresh_lo_s cnf71xx;
 };
@@ -7093,6 +7431,7 @@ union cvmx_mio_ptp_clock_cfg {
 #endif
 	} cn70xx;
 	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn70xxp1;
+	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn73xx;
 	struct cvmx_mio_ptp_clock_cfg_cn70xx  cn78xx;
 	struct cvmx_mio_ptp_clock_cfg_s       cnf71xx;
 };
@@ -7123,6 +7462,7 @@ union cvmx_mio_ptp_clock_comp {
 	struct cvmx_mio_ptp_clock_comp_s      cn68xxp1;
 	struct cvmx_mio_ptp_clock_comp_s      cn70xx;
 	struct cvmx_mio_ptp_clock_comp_s      cn70xxp1;
+	struct cvmx_mio_ptp_clock_comp_s      cn73xx;
 	struct cvmx_mio_ptp_clock_comp_s      cn78xx;
 	struct cvmx_mio_ptp_clock_comp_s      cnf71xx;
 };
@@ -7152,6 +7492,7 @@ union cvmx_mio_ptp_clock_hi {
 	struct cvmx_mio_ptp_clock_hi_s        cn68xxp1;
 	struct cvmx_mio_ptp_clock_hi_s        cn70xx;
 	struct cvmx_mio_ptp_clock_hi_s        cn70xxp1;
+	struct cvmx_mio_ptp_clock_hi_s        cn73xx;
 	struct cvmx_mio_ptp_clock_hi_s        cn78xx;
 	struct cvmx_mio_ptp_clock_hi_s        cnf71xx;
 };
@@ -7182,6 +7523,7 @@ union cvmx_mio_ptp_clock_lo {
 	struct cvmx_mio_ptp_clock_lo_s        cn68xxp1;
 	struct cvmx_mio_ptp_clock_lo_s        cn70xx;
 	struct cvmx_mio_ptp_clock_lo_s        cn70xxp1;
+	struct cvmx_mio_ptp_clock_lo_s        cn73xx;
 	struct cvmx_mio_ptp_clock_lo_s        cn78xx;
 	struct cvmx_mio_ptp_clock_lo_s        cnf71xx;
 };
@@ -7198,6 +7540,20 @@ union cvmx_mio_ptp_dpll_err_int {
 	struct cvmx_mio_ptp_dpll_err_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t n_sclk                       : 32; /**< Latest number of Digital PLL coprocessor clocks in one compensation period. */
+	uint64_t reserved_2_31                : 30;
+	uint64_t dpll_int_w1s                 : 1;  /**< Reads or sets [DPLL_INT]. */
+	uint64_t dpll_int                     : 1;  /**< Digital PLL error. Throws MIO_PTP_INTSN_E::MIO_PTP_DPLL_INT. */
+#else
+	uint64_t dpll_int                     : 1;
+	uint64_t dpll_int_w1s                 : 1;
+	uint64_t reserved_2_31                : 30;
+	uint64_t n_sclk                       : 32;
+#endif
+	} s;
+	struct cvmx_mio_ptp_dpll_err_int_s    cn73xx;
+	struct cvmx_mio_ptp_dpll_err_int_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t n_sclk                       : 32; /**< Latest number of Digital PLL coprocessor clocks in one compensation period. */
 	uint64_t reserved_1_31                : 31;
 	uint64_t dpll_int                     : 1;  /**< Digital PLL error. Throws MIO_PTP_INTSN_E::MIO_PTP_DPLL_INT. */
 #else
@@ -7205,8 +7561,7 @@ union cvmx_mio_ptp_dpll_err_int {
 	uint64_t reserved_1_31                : 31;
 	uint64_t n_sclk                       : 32;
 #endif
-	} s;
-	struct cvmx_mio_ptp_dpll_err_int_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_mio_ptp_dpll_err_int cvmx_mio_ptp_dpll_err_int_t;
 
@@ -7227,6 +7582,7 @@ union cvmx_mio_ptp_dpll_err_thresh {
 	uint64_t max                          : 32;
 #endif
 	} s;
+	struct cvmx_mio_ptp_dpll_err_thresh_s cn73xx;
 	struct cvmx_mio_ptp_dpll_err_thresh_s cn78xx;
 };
 typedef union cvmx_mio_ptp_dpll_err_thresh cvmx_mio_ptp_dpll_err_thresh_t;
@@ -7248,6 +7604,7 @@ union cvmx_mio_ptp_dpll_incr {
 	uint64_t nanosec                      : 32;
 #endif
 	} s;
+	struct cvmx_mio_ptp_dpll_incr_s       cn73xx;
 	struct cvmx_mio_ptp_dpll_incr_s       cn78xx;
 };
 typedef union cvmx_mio_ptp_dpll_incr cvmx_mio_ptp_dpll_incr_t;
@@ -7275,6 +7632,7 @@ union cvmx_mio_ptp_evt_cnt {
 	struct cvmx_mio_ptp_evt_cnt_s         cn68xxp1;
 	struct cvmx_mio_ptp_evt_cnt_s         cn70xx;
 	struct cvmx_mio_ptp_evt_cnt_s         cn70xxp1;
+	struct cvmx_mio_ptp_evt_cnt_s         cn73xx;
 	struct cvmx_mio_ptp_evt_cnt_s         cn78xx;
 	struct cvmx_mio_ptp_evt_cnt_s         cnf71xx;
 };
@@ -7290,14 +7648,25 @@ union cvmx_mio_ptp_evt_int {
 	uint64_t u64;
 	struct cvmx_mio_ptp_evt_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t evt_int_w1s                  : 1;  /**< Reads or sets [EVT_INT]. */
+	uint64_t evt_int                      : 1;  /**< PTP event observed. Throws MIO_PTP_INTSN_E::MIO_PTP_EVT_INT. */
+#else
+	uint64_t evt_int                      : 1;
+	uint64_t evt_int_w1s                  : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_mio_ptp_evt_int_s         cn73xx;
+	struct cvmx_mio_ptp_evt_int_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t evt_int                      : 1;  /**< PTP event observed. Throws MIO_PTP_INTSN_E::MIO_PTP_EVT_INT. */
 #else
 	uint64_t evt_int                      : 1;
 	uint64_t reserved_1_63                : 63;
 #endif
-	} s;
-	struct cvmx_mio_ptp_evt_int_s         cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_mio_ptp_evt_int cvmx_mio_ptp_evt_int_t;
 
@@ -7350,6 +7719,7 @@ union cvmx_mio_ptp_pps_hi_incr {
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn68xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn70xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn70xxp1;
+	struct cvmx_mio_ptp_pps_hi_incr_s     cn73xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cn78xx;
 	struct cvmx_mio_ptp_pps_hi_incr_s     cnf71xx;
 };
@@ -7377,6 +7747,7 @@ union cvmx_mio_ptp_pps_lo_incr {
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn68xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn70xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn70xxp1;
+	struct cvmx_mio_ptp_pps_lo_incr_s     cn73xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cn78xx;
 	struct cvmx_mio_ptp_pps_lo_incr_s     cnf71xx;
 };
@@ -7403,6 +7774,7 @@ union cvmx_mio_ptp_pps_thresh_hi {
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn68xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn70xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn70xxp1;
+	struct cvmx_mio_ptp_pps_thresh_hi_s   cn73xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cn78xx;
 	struct cvmx_mio_ptp_pps_thresh_hi_s   cnf71xx;
 };
@@ -7430,6 +7802,7 @@ union cvmx_mio_ptp_pps_thresh_lo {
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn68xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn70xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn70xxp1;
+	struct cvmx_mio_ptp_pps_thresh_lo_s   cn73xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cn78xx;
 	struct cvmx_mio_ptp_pps_thresh_lo_s   cnf71xx;
 };
@@ -7458,6 +7831,7 @@ union cvmx_mio_ptp_timestamp {
 	struct cvmx_mio_ptp_timestamp_s       cn68xxp1;
 	struct cvmx_mio_ptp_timestamp_s       cn70xx;
 	struct cvmx_mio_ptp_timestamp_s       cn70xxp1;
+	struct cvmx_mio_ptp_timestamp_s       cn73xx;
 	struct cvmx_mio_ptp_timestamp_s       cn78xx;
 	struct cvmx_mio_ptp_timestamp_s       cnf71xx;
 };
@@ -9018,7 +9392,7 @@ union cvmx_mio_twsx_int {
 	struct cvmx_mio_twsx_int_s            cn68xxp1;
 	struct cvmx_mio_twsx_int_s            cn70xx;
 	struct cvmx_mio_twsx_int_s            cn70xxp1;
-	struct cvmx_mio_twsx_int_cn78xx {
+	struct cvmx_mio_twsx_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t scl                          : 1;  /**< SCL signal. */
@@ -9047,12 +9421,35 @@ union cvmx_mio_twsx_int {
 	uint64_t scl                          : 1;
 	uint64_t reserved_12_63               : 52;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mio_twsx_int_cn73xx       cn78xx;
 	struct cvmx_mio_twsx_int_s            cnf71xx;
 };
 typedef union cvmx_mio_twsx_int cvmx_mio_twsx_int_t;
 
 /**
+ * cvmx_mio_tws#_int_w1s
+ */
+union cvmx_mio_twsx_int_w1s {
+	uint64_t u64;
+	struct cvmx_mio_twsx_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_3_63                : 61;
+	uint64_t core_int                     : 1;  /**< Reads MIO_TWS()_INT[CORE_INT]. */
+	uint64_t ts_int                       : 1;  /**< Reads or sets MIO_TWS()_INT[TS_INT]. */
+	uint64_t st_int                       : 1;  /**< Reads or sets MIO_TWS()_INT[ST_INT]. */
+#else
+	uint64_t st_int                       : 1;
+	uint64_t ts_int                       : 1;
+	uint64_t core_int                     : 1;
+	uint64_t reserved_3_63                : 61;
+#endif
+	} s;
+	struct cvmx_mio_twsx_int_w1s_s        cn73xx;
+};
+typedef union cvmx_mio_twsx_int_w1s cvmx_mio_twsx_int_w1s_t;
+
+/**
  * cvmx_mio_tws#_sw_twsi
  *
  * This register allows software to:
@@ -9186,6 +9583,7 @@ union cvmx_mio_twsx_sw_twsi {
 	struct cvmx_mio_twsx_sw_twsi_s        cn68xxp1;
 	struct cvmx_mio_twsx_sw_twsi_s        cn70xx;
 	struct cvmx_mio_twsx_sw_twsi_s        cn70xxp1;
+	struct cvmx_mio_twsx_sw_twsi_s        cn73xx;
 	struct cvmx_mio_twsx_sw_twsi_s        cn78xx;
 	struct cvmx_mio_twsx_sw_twsi_s        cnf71xx;
 };
@@ -9234,6 +9632,7 @@ union cvmx_mio_twsx_sw_twsi_ext {
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn68xxp1;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn70xx;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn70xxp1;
+	struct cvmx_mio_twsx_sw_twsi_ext_s    cn73xx;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cn78xx;
 	struct cvmx_mio_twsx_sw_twsi_ext_s    cnf71xx;
 };
@@ -9295,7 +9694,7 @@ union cvmx_mio_twsx_twsi_sw {
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cn68xxp1;
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cn70xx;
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cn70xxp1;
-	struct cvmx_mio_twsx_twsi_sw_cn78xx {
+	struct cvmx_mio_twsx_twsi_sw_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t v                            : 2;  /**< Valid bits. These bits are not directly writable. They are set to 11 on any write
                                                          operation by the TWSI device. They are cleared to 00 on any read operation by software. */
@@ -9306,7 +9705,8 @@ union cvmx_mio_twsx_twsi_sw {
 	uint64_t reserved_32_61               : 30;
 	uint64_t v                            : 2;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mio_twsx_twsi_sw_cn73xx   cn78xx;
 	struct cvmx_mio_twsx_twsi_sw_cn30xx   cnf71xx;
 };
 typedef union cvmx_mio_twsx_twsi_sw cvmx_mio_twsx_twsi_sw_t;
@@ -9354,6 +9754,7 @@ union cvmx_mio_uartx_dlh {
 	struct cvmx_mio_uartx_dlh_s           cn68xxp1;
 	struct cvmx_mio_uartx_dlh_s           cn70xx;
 	struct cvmx_mio_uartx_dlh_s           cn70xxp1;
+	struct cvmx_mio_uartx_dlh_s           cn73xx;
 	struct cvmx_mio_uartx_dlh_s           cn78xx;
 	struct cvmx_mio_uartx_dlh_s           cnf71xx;
 };
@@ -9403,6 +9804,7 @@ union cvmx_mio_uartx_dll {
 	struct cvmx_mio_uartx_dll_s           cn68xxp1;
 	struct cvmx_mio_uartx_dll_s           cn70xx;
 	struct cvmx_mio_uartx_dll_s           cn70xxp1;
+	struct cvmx_mio_uartx_dll_s           cn73xx;
 	struct cvmx_mio_uartx_dll_s           cn78xx;
 	struct cvmx_mio_uartx_dll_s           cnf71xx;
 };
@@ -9449,6 +9851,7 @@ union cvmx_mio_uartx_far {
 	struct cvmx_mio_uartx_far_s           cn68xxp1;
 	struct cvmx_mio_uartx_far_s           cn70xx;
 	struct cvmx_mio_uartx_far_s           cn70xxp1;
+	struct cvmx_mio_uartx_far_s           cn73xx;
 	struct cvmx_mio_uartx_far_s           cn78xx;
 	struct cvmx_mio_uartx_far_s           cnf71xx;
 };
@@ -9502,6 +9905,7 @@ union cvmx_mio_uartx_fcr {
 	struct cvmx_mio_uartx_fcr_s           cn68xxp1;
 	struct cvmx_mio_uartx_fcr_s           cn70xx;
 	struct cvmx_mio_uartx_fcr_s           cn70xxp1;
+	struct cvmx_mio_uartx_fcr_s           cn73xx;
 	struct cvmx_mio_uartx_fcr_s           cn78xx;
 	struct cvmx_mio_uartx_fcr_s           cnf71xx;
 };
@@ -9545,6 +9949,7 @@ union cvmx_mio_uartx_htx {
 	struct cvmx_mio_uartx_htx_s           cn68xxp1;
 	struct cvmx_mio_uartx_htx_s           cn70xx;
 	struct cvmx_mio_uartx_htx_s           cn70xxp1;
+	struct cvmx_mio_uartx_htx_s           cn73xx;
 	struct cvmx_mio_uartx_htx_s           cn78xx;
 	struct cvmx_mio_uartx_htx_s           cnf71xx;
 };
@@ -9603,6 +10008,7 @@ union cvmx_mio_uartx_ier {
 	struct cvmx_mio_uartx_ier_s           cn68xxp1;
 	struct cvmx_mio_uartx_ier_s           cn70xx;
 	struct cvmx_mio_uartx_ier_s           cn70xxp1;
+	struct cvmx_mio_uartx_ier_s           cn73xx;
 	struct cvmx_mio_uartx_ier_s           cn78xx;
 	struct cvmx_mio_uartx_ier_s           cnf71xx;
 };
@@ -9649,6 +10055,7 @@ union cvmx_mio_uartx_iir {
 	struct cvmx_mio_uartx_iir_s           cn68xxp1;
 	struct cvmx_mio_uartx_iir_s           cn70xx;
 	struct cvmx_mio_uartx_iir_s           cn70xxp1;
+	struct cvmx_mio_uartx_iir_s           cn73xx;
 	struct cvmx_mio_uartx_iir_s           cn78xx;
 	struct cvmx_mio_uartx_iir_s           cnf71xx;
 };
@@ -9703,6 +10110,7 @@ union cvmx_mio_uartx_lcr {
 	struct cvmx_mio_uartx_lcr_s           cn68xxp1;
 	struct cvmx_mio_uartx_lcr_s           cn70xx;
 	struct cvmx_mio_uartx_lcr_s           cn70xxp1;
+	struct cvmx_mio_uartx_lcr_s           cn73xx;
 	struct cvmx_mio_uartx_lcr_s           cn78xx;
 	struct cvmx_mio_uartx_lcr_s           cnf71xx;
 };
@@ -9759,6 +10167,7 @@ union cvmx_mio_uartx_lsr {
 	struct cvmx_mio_uartx_lsr_s           cn68xxp1;
 	struct cvmx_mio_uartx_lsr_s           cn70xx;
 	struct cvmx_mio_uartx_lsr_s           cn70xxp1;
+	struct cvmx_mio_uartx_lsr_s           cn73xx;
 	struct cvmx_mio_uartx_lsr_s           cn78xx;
 	struct cvmx_mio_uartx_lsr_s           cnf71xx;
 };
@@ -9812,6 +10221,7 @@ union cvmx_mio_uartx_mcr {
 	struct cvmx_mio_uartx_mcr_s           cn68xxp1;
 	struct cvmx_mio_uartx_mcr_s           cn70xx;
 	struct cvmx_mio_uartx_mcr_s           cn70xxp1;
+	struct cvmx_mio_uartx_mcr_s           cn73xx;
 	struct cvmx_mio_uartx_mcr_s           cn78xx;
 	struct cvmx_mio_uartx_mcr_s           cnf71xx;
 };
@@ -9868,6 +10278,7 @@ union cvmx_mio_uartx_msr {
 	struct cvmx_mio_uartx_msr_s           cn68xxp1;
 	struct cvmx_mio_uartx_msr_s           cn70xx;
 	struct cvmx_mio_uartx_msr_s           cn70xxp1;
+	struct cvmx_mio_uartx_msr_s           cn73xx;
 	struct cvmx_mio_uartx_msr_s           cn78xx;
 	struct cvmx_mio_uartx_msr_s           cnf71xx;
 };
@@ -9911,6 +10322,7 @@ union cvmx_mio_uartx_rbr {
 	struct cvmx_mio_uartx_rbr_s           cn68xxp1;
 	struct cvmx_mio_uartx_rbr_s           cn70xx;
 	struct cvmx_mio_uartx_rbr_s           cn70xxp1;
+	struct cvmx_mio_uartx_rbr_s           cn73xx;
 	struct cvmx_mio_uartx_rbr_s           cn78xx;
 	struct cvmx_mio_uartx_rbr_s           cnf71xx;
 };
@@ -9953,6 +10365,7 @@ union cvmx_mio_uartx_rfl {
 	struct cvmx_mio_uartx_rfl_s           cn68xxp1;
 	struct cvmx_mio_uartx_rfl_s           cn70xx;
 	struct cvmx_mio_uartx_rfl_s           cn70xxp1;
+	struct cvmx_mio_uartx_rfl_s           cn73xx;
 	struct cvmx_mio_uartx_rfl_s           cn78xx;
 	struct cvmx_mio_uartx_rfl_s           cnf71xx;
 };
@@ -9999,6 +10412,7 @@ union cvmx_mio_uartx_rfw {
 	struct cvmx_mio_uartx_rfw_s           cn68xxp1;
 	struct cvmx_mio_uartx_rfw_s           cn70xx;
 	struct cvmx_mio_uartx_rfw_s           cn70xxp1;
+	struct cvmx_mio_uartx_rfw_s           cn73xx;
 	struct cvmx_mio_uartx_rfw_s           cn78xx;
 	struct cvmx_mio_uartx_rfw_s           cnf71xx;
 };
@@ -10042,6 +10456,7 @@ union cvmx_mio_uartx_sbcr {
 	struct cvmx_mio_uartx_sbcr_s          cn68xxp1;
 	struct cvmx_mio_uartx_sbcr_s          cn70xx;
 	struct cvmx_mio_uartx_sbcr_s          cn70xxp1;
+	struct cvmx_mio_uartx_sbcr_s          cn73xx;
 	struct cvmx_mio_uartx_sbcr_s          cn78xx;
 	struct cvmx_mio_uartx_sbcr_s          cnf71xx;
 };
@@ -10084,6 +10499,7 @@ union cvmx_mio_uartx_scr {
 	struct cvmx_mio_uartx_scr_s           cn68xxp1;
 	struct cvmx_mio_uartx_scr_s           cn70xx;
 	struct cvmx_mio_uartx_scr_s           cn70xxp1;
+	struct cvmx_mio_uartx_scr_s           cn73xx;
 	struct cvmx_mio_uartx_scr_s           cn78xx;
 	struct cvmx_mio_uartx_scr_s           cnf71xx;
 };
@@ -10128,6 +10544,7 @@ union cvmx_mio_uartx_sfe {
 	struct cvmx_mio_uartx_sfe_s           cn68xxp1;
 	struct cvmx_mio_uartx_sfe_s           cn70xx;
 	struct cvmx_mio_uartx_sfe_s           cn70xxp1;
+	struct cvmx_mio_uartx_sfe_s           cn73xx;
 	struct cvmx_mio_uartx_sfe_s           cn78xx;
 	struct cvmx_mio_uartx_sfe_s           cnf71xx;
 };
@@ -10174,6 +10591,7 @@ union cvmx_mio_uartx_srr {
 	struct cvmx_mio_uartx_srr_s           cn68xxp1;
 	struct cvmx_mio_uartx_srr_s           cn70xx;
 	struct cvmx_mio_uartx_srr_s           cn70xxp1;
+	struct cvmx_mio_uartx_srr_s           cn73xx;
 	struct cvmx_mio_uartx_srr_s           cn78xx;
 	struct cvmx_mio_uartx_srr_s           cnf71xx;
 };
@@ -10218,6 +10636,7 @@ union cvmx_mio_uartx_srt {
 	struct cvmx_mio_uartx_srt_s           cn68xxp1;
 	struct cvmx_mio_uartx_srt_s           cn70xx;
 	struct cvmx_mio_uartx_srt_s           cn70xxp1;
+	struct cvmx_mio_uartx_srt_s           cn73xx;
 	struct cvmx_mio_uartx_srt_s           cn78xx;
 	struct cvmx_mio_uartx_srt_s           cnf71xx;
 };
@@ -10261,6 +10680,7 @@ union cvmx_mio_uartx_srts {
 	struct cvmx_mio_uartx_srts_s          cn68xxp1;
 	struct cvmx_mio_uartx_srts_s          cn70xx;
 	struct cvmx_mio_uartx_srts_s          cn70xxp1;
+	struct cvmx_mio_uartx_srts_s          cn73xx;
 	struct cvmx_mio_uartx_srts_s          cn78xx;
 	struct cvmx_mio_uartx_srts_s          cnf71xx;
 };
@@ -10305,6 +10725,7 @@ union cvmx_mio_uartx_stt {
 	struct cvmx_mio_uartx_stt_s           cn68xxp1;
 	struct cvmx_mio_uartx_stt_s           cn70xx;
 	struct cvmx_mio_uartx_stt_s           cn70xxp1;
+	struct cvmx_mio_uartx_stt_s           cn73xx;
 	struct cvmx_mio_uartx_stt_s           cn78xx;
 	struct cvmx_mio_uartx_stt_s           cnf71xx;
 };
@@ -10347,6 +10768,7 @@ union cvmx_mio_uartx_tfl {
 	struct cvmx_mio_uartx_tfl_s           cn68xxp1;
 	struct cvmx_mio_uartx_tfl_s           cn70xx;
 	struct cvmx_mio_uartx_tfl_s           cn70xxp1;
+	struct cvmx_mio_uartx_tfl_s           cn73xx;
 	struct cvmx_mio_uartx_tfl_s           cn78xx;
 	struct cvmx_mio_uartx_tfl_s           cnf71xx;
 };
@@ -10389,6 +10811,7 @@ union cvmx_mio_uartx_tfr {
 	struct cvmx_mio_uartx_tfr_s           cn68xxp1;
 	struct cvmx_mio_uartx_tfr_s           cn70xx;
 	struct cvmx_mio_uartx_tfr_s           cn70xxp1;
+	struct cvmx_mio_uartx_tfr_s           cn73xx;
 	struct cvmx_mio_uartx_tfr_s           cn78xx;
 	struct cvmx_mio_uartx_tfr_s           cnf71xx;
 };
@@ -10432,6 +10855,7 @@ union cvmx_mio_uartx_thr {
 	struct cvmx_mio_uartx_thr_s           cn68xxp1;
 	struct cvmx_mio_uartx_thr_s           cn70xx;
 	struct cvmx_mio_uartx_thr_s           cn70xxp1;
+	struct cvmx_mio_uartx_thr_s           cn73xx;
 	struct cvmx_mio_uartx_thr_s           cn78xx;
 	struct cvmx_mio_uartx_thr_s           cnf71xx;
 };
@@ -10482,6 +10906,7 @@ union cvmx_mio_uartx_usr {
 	struct cvmx_mio_uartx_usr_s           cn68xxp1;
 	struct cvmx_mio_uartx_usr_s           cn70xx;
 	struct cvmx_mio_uartx_usr_s           cn70xxp1;
+	struct cvmx_mio_uartx_usr_s           cn73xx;
 	struct cvmx_mio_uartx_usr_s           cn78xx;
 	struct cvmx_mio_uartx_usr_s           cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
index a43098c..5f8dd33 100644
--- a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
@@ -62,6 +62,7 @@ static inline uint64_t CVMX_MIXX_BIST(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_BIST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100078ull) + ((offset) & 1) * 2048;
@@ -79,6 +80,7 @@ static inline uint64_t CVMX_MIXX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100020ull) + ((offset) & 1) * 2048;
@@ -112,6 +114,7 @@ static inline uint64_t CVMX_MIXX_IRCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100030ull) + ((offset) & 1) * 2048;
@@ -129,6 +132,7 @@ static inline uint64_t CVMX_MIXX_IRHWM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRHWM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100028ull) + ((offset) & 1) * 2048;
@@ -146,6 +150,7 @@ static inline uint64_t CVMX_MIXX_IRING1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRING1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100010ull) + ((offset) & 1) * 2048;
@@ -163,6 +168,7 @@ static inline uint64_t CVMX_MIXX_IRING2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRING2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100018ull) + ((offset) & 1) * 2048;
@@ -180,6 +186,7 @@ static inline uint64_t CVMX_MIXX_ISR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ISR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100048ull) + ((offset) & 1) * 2048;
@@ -188,6 +195,17 @@ static inline uint64_t CVMX_MIXX_ISR(unsigned long offset)
 #define CVMX_MIXX_ISR(offset) (CVMX_ADD_IO_SEG(0x0001070000100048ull) + ((offset) & 1) * 2048)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_MIXX_ISR_W1S(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_MIXX_ISR_W1S(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070000100050ull) + ((offset) & 1) * 2048;
+}
+#else
+#define CVMX_MIXX_ISR_W1S(offset) (CVMX_ADD_IO_SEG(0x0001070000100050ull) + ((offset) & 1) * 2048)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIXX_ORCNT(unsigned long offset)
 {
 	if (!(
@@ -197,6 +215,7 @@ static inline uint64_t CVMX_MIXX_ORCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100040ull) + ((offset) & 1) * 2048;
@@ -214,6 +233,7 @@ static inline uint64_t CVMX_MIXX_ORHWM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORHWM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100038ull) + ((offset) & 1) * 2048;
@@ -231,6 +251,7 @@ static inline uint64_t CVMX_MIXX_ORING1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORING1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100000ull) + ((offset) & 1) * 2048;
@@ -248,6 +269,7 @@ static inline uint64_t CVMX_MIXX_ORING2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORING2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100008ull) + ((offset) & 1) * 2048;
@@ -265,6 +287,7 @@ static inline uint64_t CVMX_MIXX_REMCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_REMCNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100058ull) + ((offset) & 1) * 2048;
@@ -280,6 +303,7 @@ static inline uint64_t CVMX_MIXX_TSCTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_TSCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100068ull) + ((offset) & 1) * 2048;
@@ -295,6 +319,7 @@ static inline uint64_t CVMX_MIXX_TSTAMP(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_TSTAMP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000100060ull) + ((offset) & 1) * 2048;
@@ -362,6 +387,7 @@ union cvmx_mixx_bist {
 	struct cvmx_mixx_bist_s               cn66xx;
 	struct cvmx_mixx_bist_s               cn68xx;
 	struct cvmx_mixx_bist_s               cn68xxp1;
+	struct cvmx_mixx_bist_s               cn73xx;
 	struct cvmx_mixx_bist_s               cn78xx;
 };
 typedef union cvmx_mixx_bist cvmx_mixx_bist_t;
@@ -538,6 +564,7 @@ union cvmx_mixx_ctl {
 	struct cvmx_mixx_ctl_s                cn66xx;
 	struct cvmx_mixx_ctl_s                cn68xx;
 	struct cvmx_mixx_ctl_s                cn68xxp1;
+	struct cvmx_mixx_ctl_s                cn73xx;
 	struct cvmx_mixx_ctl_s                cn78xx;
 };
 typedef union cvmx_mixx_ctl cvmx_mixx_ctl_t;
@@ -710,6 +737,7 @@ union cvmx_mixx_ircnt {
 	struct cvmx_mixx_ircnt_s              cn66xx;
 	struct cvmx_mixx_ircnt_s              cn68xx;
 	struct cvmx_mixx_ircnt_s              cn68xxp1;
+	struct cvmx_mixx_ircnt_s              cn73xx;
 	struct cvmx_mixx_ircnt_s              cn78xx;
 };
 typedef union cvmx_mixx_ircnt cvmx_mixx_ircnt_t;
@@ -753,6 +781,7 @@ union cvmx_mixx_irhwm {
 	struct cvmx_mixx_irhwm_s              cn66xx;
 	struct cvmx_mixx_irhwm_s              cn68xx;
 	struct cvmx_mixx_irhwm_s              cn68xxp1;
+	struct cvmx_mixx_irhwm_s              cn73xx;
 	struct cvmx_mixx_irhwm_s              cn78xx;
 };
 typedef union cvmx_mixx_irhwm cvmx_mixx_irhwm_t;
@@ -823,7 +852,7 @@ union cvmx_mixx_iring1 {
 	struct cvmx_mixx_iring1_cn61xx        cn66xx;
 	struct cvmx_mixx_iring1_cn61xx        cn68xx;
 	struct cvmx_mixx_iring1_cn61xx        cn68xxp1;
-	struct cvmx_mixx_iring1_cn78xx {
+	struct cvmx_mixx_iring1_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t isize                        : 20; /**< Represents the inbound ring (I-Ring) buffer's size (in 8-byte words). The ring can be as
                                                          large as 1MB entries.
@@ -839,7 +868,8 @@ union cvmx_mixx_iring1 {
 	uint64_t reserved_42_43               : 2;
 	uint64_t isize                        : 20;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mixx_iring1_cn73xx        cn78xx;
 };
 typedef union cvmx_mixx_iring1 cvmx_mixx_iring1_t;
 
@@ -887,6 +917,7 @@ union cvmx_mixx_iring2 {
 	struct cvmx_mixx_iring2_s             cn66xx;
 	struct cvmx_mixx_iring2_s             cn68xx;
 	struct cvmx_mixx_iring2_s             cn68xxp1;
+	struct cvmx_mixx_iring2_s             cn73xx;
 	struct cvmx_mixx_iring2_s             cn78xx;
 };
 typedef union cvmx_mixx_iring2 cvmx_mixx_iring2_t;
@@ -1083,11 +1114,94 @@ union cvmx_mixx_isr {
 	struct cvmx_mixx_isr_s                cn66xx;
 	struct cvmx_mixx_isr_s                cn68xx;
 	struct cvmx_mixx_isr_s                cn68xxp1;
+	struct cvmx_mixx_isr_s                cn73xx;
 	struct cvmx_mixx_isr_s                cn78xx;
 };
 typedef union cvmx_mixx_isr cvmx_mixx_isr_t;
 
 /**
+ * cvmx_mix#_isr_w1s
+ */
+union cvmx_mixx_isr_w1s {
+	uint64_t u64;
+	struct cvmx_mixx_isr_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t ts                           : 1;  /**< Timestamp interrupt. Throws MIX_INTSN_E:MIX(0..1)_INT_TS. This bit is set and the
+                                                         interrupt generated when the number of pending timestamp interrupts
+                                                         (MIX(0..1)_TSCTL[TSCNT]) is greater than the timestamp interrupt threshold
+                                                         (MIX(0..1)_CTL[TS_THRESH]) value. */
+	uint64_t orun                         : 1;  /**< O-ring packet count underflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_ORUN. If
+                                                         software writes a larger value than what is currently in the MIX(0..1)_ORCNT[ORCNT], then
+                                                         hardware reports the underflow condition.
+                                                         The MIX(0..1)_ORCNT[IOCNT] will clamp to zero.
+                                                         If an ORUN underflow condition is detected, the integrity of the MIX hardware state has
+                                                         been compromised. To recover, software must issue a software reset sequence. (See
+                                                         MIX(0..1)_CTL[RESET.] */
+	uint64_t irun                         : 1;  /**< I-ring packet count underflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_IRUN. If
+                                                         software writes a larger value than what is currently in the MIX(0..1)_IRCNT[IRCNT], then
+                                                         hardware reports the underflow condition.
+                                                         The MIX(0..1)_IRCNT[IRCNT] will clamp to zero.
+                                                         If an IRUN underflow condition is detected, the integrity of the MIX hardware state has
+                                                         been compromised. To recover, software must issue a software reset sequence. (See
+                                                         MIX(0..1)_CTL[RESET]). */
+	uint64_t data_drp                     : 1;  /**< Data was dropped due to RX FIFO full. Throws MIX_INTSN_E::MIX(0..1)_INT_DATA_DRP. If this
+                                                         event does occur, DATA_DRP is set and the interrupt is generated. */
+	uint64_t irthresh                     : 1;  /**< Inbound ring packet threshold exceeded. Throws MIX_INTSN_E::MIX(0..1)_INT_IRTHRESH. When
+                                                         the pending number of inbound packets in system memory (IRCNT) has exceeded a programmable
+                                                         threshold (IRHWM), this bit is set and the interrupt is generated. To service this
+                                                         interrupt, the IRCNT must first be lowered below the IRHWM before the W1C to this field. */
+	uint64_t orthresh                     : 1;  /**< Outbound ring packet threshold exceeded. Throws MIX_INTSN_E::MIX(0..1)_INT_ORTHRESH. When
+                                                         the pending number of outbound packets in system memory (ORCNT) has exceeded a
+                                                         programmable threshold (ORHWM), this bit is set and the interrupt is generated. To service
+                                                         this interrupt, the ORCNT must first be lowered below the ORHWM before the W1C to this
+                                                         field. */
+	uint64_t idblovf                      : 1;  /**< Inbound doorbell (IDBELL) overflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_IDBLOVF.
+                                                         If software attempts to write to the MIX(0..1)_IRING2[IDBELL] with a value greater than
+                                                         the remaining number of I-Ring buffer entries (MIX(0..1)_REMCNT[IREMCNT]), then the
+                                                         following occurs:
+                                                         * The MIX(0..1)_IRING2[IDBELL] write is IGNORED.
+                                                         * IDBLOVF is set and the interrupt is generated.
+                                                         Software should keep track of the number of I-Ring entries in use (i.e. the cumulative
+                                                         number
+                                                         of IDBELL write operations), and ensure that future IDBELL write operations don't exceed
+                                                         the size of the I-Ring Buffer (MIX(0..1)_IRING2[ISIZE]). Software must reclaim I-Ring
+                                                         entries by keeping track of the number of I-Ring entries, and writing to the
+                                                         MIX(0..1)_IRCNT[IRCNT].
+                                                         The MIX(0..1)_IRCNT[IRCNT] register represents the total number of packets (not I-Ring
+                                                         entries) and software must further keep track of the number of I-Ring entries associated
+                                                         with each packet as they are processed.
+                                                         If an IDBLOVF occurs, it is an indication that software has overwritten the I-Ring buffer,
+                                                         and the only recourse for recovery is a hardware reset. */
+	uint64_t odblovf                      : 1;  /**< Outbound doorbell (ODBELL) overflow detected. Throws MIX_INTSN_E::MIX(0..1)_INT_ODBLOVF.
+                                                         If software attempts to write to MIX(0..1)_ORING2[ODBELL] with a value greater than the
+                                                         remaining number of O-Ring buffer entries (MIX(0..1)_REMCNT[OREMCNT]), then the following
+                                                         occurs:
+                                                         * The MIX(0..1)_IRING2[ODBELL] write operation is IGNORED.
+                                                         * ODBLOVF is set and the interrupt is generated.
+                                                         Software should keep track of the number of I-Ring entries in use (i.e. the cumulative
+                                                         number of ODBELL write operations), and ensure that future ODBELL write operations don't
+                                                         exceed the size of the O-Ring buffer (MIX(0..1)_ORING2[OSIZE]). Software must reclaim
+                                                         O-Ring entries by writing to MIX(0..1)_ORCNT[ORCNT].
+                                                         If an ODBLOVF occurs, it is an indication that software has overwritten the O-Ring buffer,
+                                                         and the only recourse for recovery is a hardware reset. */
+#else
+	uint64_t odblovf                      : 1;
+	uint64_t idblovf                      : 1;
+	uint64_t orthresh                     : 1;
+	uint64_t irthresh                     : 1;
+	uint64_t data_drp                     : 1;
+	uint64_t irun                         : 1;
+	uint64_t orun                         : 1;
+	uint64_t ts                           : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_mixx_isr_w1s_s            cn73xx;
+};
+typedef union cvmx_mixx_isr_w1s cvmx_mixx_isr_w1s_t;
+
+/**
  * cvmx_mix#_orcnt
  *
  * MIX_ORCNT = MIX O-Ring Packets Sent Counter
@@ -1126,6 +1240,7 @@ union cvmx_mixx_orcnt {
 	struct cvmx_mixx_orcnt_s              cn66xx;
 	struct cvmx_mixx_orcnt_s              cn68xx;
 	struct cvmx_mixx_orcnt_s              cn68xxp1;
+	struct cvmx_mixx_orcnt_s              cn73xx;
 	struct cvmx_mixx_orcnt_s              cn78xx;
 };
 typedef union cvmx_mixx_orcnt cvmx_mixx_orcnt_t;
@@ -1162,6 +1277,7 @@ union cvmx_mixx_orhwm {
 	struct cvmx_mixx_orhwm_s              cn66xx;
 	struct cvmx_mixx_orhwm_s              cn68xx;
 	struct cvmx_mixx_orhwm_s              cn68xxp1;
+	struct cvmx_mixx_orhwm_s              cn73xx;
 	struct cvmx_mixx_orhwm_s              cn78xx;
 };
 typedef union cvmx_mixx_orhwm cvmx_mixx_orhwm_t;
@@ -1232,7 +1348,7 @@ union cvmx_mixx_oring1 {
 	struct cvmx_mixx_oring1_cn61xx        cn66xx;
 	struct cvmx_mixx_oring1_cn61xx        cn68xx;
 	struct cvmx_mixx_oring1_cn61xx        cn68xxp1;
-	struct cvmx_mixx_oring1_cn78xx {
+	struct cvmx_mixx_oring1_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t osize                        : 20; /**< Represents the outbound ring (O-Ring) buffer's size (in 8-byte words). The ring can be as
                                                          large as 1MB entries.
@@ -1248,7 +1364,8 @@ union cvmx_mixx_oring1 {
 	uint64_t reserved_42_43               : 2;
 	uint64_t osize                        : 20;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mixx_oring1_cn73xx        cn78xx;
 };
 typedef union cvmx_mixx_oring1 cvmx_mixx_oring1_t;
 
@@ -1296,6 +1413,7 @@ union cvmx_mixx_oring2 {
 	struct cvmx_mixx_oring2_s             cn66xx;
 	struct cvmx_mixx_oring2_s             cn68xx;
 	struct cvmx_mixx_oring2_s             cn68xxp1;
+	struct cvmx_mixx_oring2_s             cn73xx;
 	struct cvmx_mixx_oring2_s             cn78xx;
 };
 typedef union cvmx_mixx_oring2 cvmx_mixx_oring2_t;
@@ -1345,6 +1463,7 @@ union cvmx_mixx_remcnt {
 	struct cvmx_mixx_remcnt_s             cn66xx;
 	struct cvmx_mixx_remcnt_s             cn68xx;
 	struct cvmx_mixx_remcnt_s             cn68xxp1;
+	struct cvmx_mixx_remcnt_s             cn73xx;
 	struct cvmx_mixx_remcnt_s             cn78xx;
 };
 typedef union cvmx_mixx_remcnt cvmx_mixx_remcnt_t;
@@ -1399,6 +1518,7 @@ union cvmx_mixx_tsctl {
 	struct cvmx_mixx_tsctl_s              cn66xx;
 	struct cvmx_mixx_tsctl_s              cn68xx;
 	struct cvmx_mixx_tsctl_s              cn68xxp1;
+	struct cvmx_mixx_tsctl_s              cn73xx;
 	struct cvmx_mixx_tsctl_s              cn78xx;
 };
 typedef union cvmx_mixx_tsctl cvmx_mixx_tsctl_t;
@@ -1447,6 +1567,7 @@ union cvmx_mixx_tstamp {
 	struct cvmx_mixx_tstamp_s             cn66xx;
 	struct cvmx_mixx_tstamp_s             cn68xx;
 	struct cvmx_mixx_tstamp_s             cn68xxp1;
+	struct cvmx_mixx_tstamp_s             cn73xx;
 	struct cvmx_mixx_tstamp_s             cn78xx;
 };
 typedef union cvmx_mixx_tstamp cvmx_mixx_tstamp_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
index e921c30..6e0251b 100644
--- a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_MPI_CFG CVMX_MPI_CFG_FUNC()
 static inline uint64_t CVMX_MPI_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001000ull);
 }
@@ -73,6 +73,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 8))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_MPI_DATX(%lu) is invalid on this chip\n", offset);
@@ -85,7 +86,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 #define CVMX_MPI_STS CVMX_MPI_STS_FUNC()
 static inline uint64_t CVMX_MPI_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001008ull);
 }
@@ -93,10 +94,21 @@ static inline uint64_t CVMX_MPI_STS_FUNC(void)
 #define CVMX_MPI_STS (CVMX_ADD_IO_SEG(0x0001070000001008ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_MPI_STS_W1S CVMX_MPI_STS_W1S_FUNC()
+static inline uint64_t CVMX_MPI_STS_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_MPI_STS_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070000001018ull);
+}
+#else
+#define CVMX_MPI_STS_W1S (CVMX_ADD_IO_SEG(0x0001070000001018ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_MPI_TX CVMX_MPI_TX_FUNC()
 static inline uint64_t CVMX_MPI_TX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_TX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001010ull);
 }
@@ -107,7 +119,7 @@ static inline uint64_t CVMX_MPI_TX_FUNC(void)
 #define CVMX_MPI_WIDE_DAT CVMX_MPI_WIDE_DAT_FUNC()
 static inline uint64_t CVMX_MPI_WIDE_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MPI_WIDE_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001040ull);
 }
@@ -511,7 +523,7 @@ union cvmx_mpi_cfg {
 #endif
 	} cn70xx;
 	struct cvmx_mpi_cfg_cn70xx            cn70xxp1;
-	struct cvmx_mpi_cfg_cn78xx {
+	struct cvmx_mpi_cfg_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
 	uint64_t clkdiv                       : 13; /**< Clock divisor.
@@ -579,7 +591,8 @@ union cvmx_mpi_cfg {
 	uint64_t clkdiv                       : 13;
 	uint64_t reserved_29_63               : 35;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_mpi_cfg_cn73xx            cn78xx;
 	struct cvmx_mpi_cfg_cn61xx            cnf71xx;
 };
 typedef union cvmx_mpi_cfg cvmx_mpi_cfg_t;
@@ -605,6 +618,7 @@ union cvmx_mpi_datx {
 	struct cvmx_mpi_datx_s                cn66xx;
 	struct cvmx_mpi_datx_s                cn70xx;
 	struct cvmx_mpi_datx_s                cn70xxp1;
+	struct cvmx_mpi_datx_s                cn73xx;
 	struct cvmx_mpi_datx_s                cn78xx;
 	struct cvmx_mpi_datx_s                cnf71xx;
 };
@@ -651,12 +665,36 @@ union cvmx_mpi_sts {
 	struct cvmx_mpi_sts_cn30xx            cn66xx;
 	struct cvmx_mpi_sts_cn30xx            cn70xx;
 	struct cvmx_mpi_sts_cn30xx            cn70xxp1;
+	struct cvmx_mpi_sts_s                 cn73xx;
 	struct cvmx_mpi_sts_s                 cn78xx;
 	struct cvmx_mpi_sts_cn30xx            cnf71xx;
 };
 typedef union cvmx_mpi_sts cvmx_mpi_sts_t;
 
 /**
+ * cvmx_mpi_sts_w1s
+ *
+ * This register sets MPI_STS() interrupts.
+ *
+ */
+union cvmx_mpi_sts_w1s {
+	uint64_t u64;
+	struct cvmx_mpi_sts_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t mpi_intr_w1s                 : 1;  /**< Reads or sets MPI_STS[MPI_INTR]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t mpi_intr_w1s                 : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_mpi_sts_w1s_s             cn73xx;
+};
+typedef union cvmx_mpi_sts_w1s cvmx_mpi_sts_w1s_t;
+
+/**
  * cvmx_mpi_tx
  */
 union cvmx_mpi_tx {
@@ -728,6 +766,7 @@ union cvmx_mpi_tx {
 	struct cvmx_mpi_tx_s                  cn66xx;
 	struct cvmx_mpi_tx_s                  cn70xx;
 	struct cvmx_mpi_tx_s                  cn70xxp1;
+	struct cvmx_mpi_tx_s                  cn73xx;
 	struct cvmx_mpi_tx_s                  cn78xx;
 	struct cvmx_mpi_tx_cn61xx             cnf71xx;
 };
@@ -750,6 +789,7 @@ union cvmx_mpi_wide_dat {
 	} s;
 	struct cvmx_mpi_wide_dat_s            cn70xx;
 	struct cvmx_mpi_wide_dat_s            cn70xxp1;
+	struct cvmx_mpi_wide_dat_s            cn73xx;
 	struct cvmx_mpi_wide_dat_s            cn78xx;
 };
 typedef union cvmx_mpi_wide_dat cvmx_mpi_wide_dat_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
index e1f3859..eb47b02 100644
--- a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_NDF_BT_PG_INFO CVMX_NDF_BT_PG_INFO_FUNC()
 static inline uint64_t CVMX_NDF_BT_PG_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_BT_PG_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_NDF_BT_PG_INFO_FUNC(void)
 #define CVMX_NDF_CMD CVMX_NDF_CMD_FUNC()
 static inline uint64_t CVMX_NDF_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000000ull);
 }
@@ -75,10 +75,32 @@ static inline uint64_t CVMX_NDF_CMD_FUNC(void)
 #define CVMX_NDF_CMD (CVMX_ADD_IO_SEG(0x0001070001000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_NDF_DMA_ADR CVMX_NDF_DMA_ADR_FUNC()
+static inline uint64_t CVMX_NDF_DMA_ADR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_NDF_DMA_ADR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070001000058ull);
+}
+#else
+#define CVMX_NDF_DMA_ADR (CVMX_ADD_IO_SEG(0x0001070001000058ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_NDF_DMA_CFG CVMX_NDF_DMA_CFG_FUNC()
+static inline uint64_t CVMX_NDF_DMA_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_NDF_DMA_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070001000050ull);
+}
+#else
+#define CVMX_NDF_DMA_CFG (CVMX_ADD_IO_SEG(0x0001070001000050ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_NDF_DRBELL CVMX_NDF_DRBELL_FUNC()
 static inline uint64_t CVMX_NDF_DRBELL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_DRBELL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000030ull);
 }
@@ -89,7 +111,7 @@ static inline uint64_t CVMX_NDF_DRBELL_FUNC(void)
 #define CVMX_NDF_ECC_CNT CVMX_NDF_ECC_CNT_FUNC()
 static inline uint64_t CVMX_NDF_ECC_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_ECC_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000010ull);
 }
@@ -100,12 +122,37 @@ static inline uint64_t CVMX_NDF_ECC_CNT_FUNC(void)
 #define CVMX_NDF_INT CVMX_NDF_INT_FUNC()
 static inline uint64_t CVMX_NDF_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
-		cvmx_warn("CVMX_NDF_INT not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001070001000020ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070001000040ull);
+			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070001000020ull);
+			break;
+	}
+	cvmx_warn("CVMX_NDF_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070001000040ull);
 }
 #else
-#define CVMX_NDF_INT (CVMX_ADD_IO_SEG(0x0001070001000020ull))
+#define CVMX_NDF_INT CVMX_NDF_INT_FUNC()
+static inline uint64_t CVMX_NDF_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070001000040ull);
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001070001000020ull);
+	}
+	return CVMX_ADD_IO_SEG(0x0001070001000040ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_NDF_INT_EN CVMX_NDF_INT_EN_FUNC()
@@ -119,10 +166,21 @@ static inline uint64_t CVMX_NDF_INT_EN_FUNC(void)
 #define CVMX_NDF_INT_EN (CVMX_ADD_IO_SEG(0x0001070001000028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_NDF_INT_W1S CVMX_NDF_INT_W1S_FUNC()
+static inline uint64_t CVMX_NDF_INT_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_NDF_INT_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001070001000048ull);
+}
+#else
+#define CVMX_NDF_INT_W1S (CVMX_ADD_IO_SEG(0x0001070001000048ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_NDF_MISC CVMX_NDF_MISC_FUNC()
 static inline uint64_t CVMX_NDF_MISC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_MISC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000008ull);
 }
@@ -133,7 +191,7 @@ static inline uint64_t CVMX_NDF_MISC_FUNC(void)
 #define CVMX_NDF_ST_REG CVMX_NDF_ST_REG_FUNC()
 static inline uint64_t CVMX_NDF_ST_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_NDF_ST_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070001000038ull);
 }
@@ -144,28 +202,33 @@ static inline uint64_t CVMX_NDF_ST_REG_FUNC(void)
 /**
  * cvmx_ndf_bt_pg_info
  *
- * NDF_BT_PG_INFO provides page size and number of column plus row address cycles information. SW
- * writes to this CSR
- *   during boot from Nand Flash. Additionally SW also writes the multiplier value for timing
- * parameters. This value is
- *   used during boot, in the SET_TM_PARAM command. This information is used only by the boot
- * load state machine and is
- *   otherwise a don't care, once boot is disabled. Also, boot dma's do not use this value.
- * Bytes per Nand Flash page = 2 ** (SIZE + 1) times 256 bytes.
- *   512, 1k, 2k, 4k, 8k, 16k, 32k and 64k are legal bytes per page values
- * Legal values for ADR_CYC field are 3 through 8. SW CSR writes with a value less than 3 will
- * write a 3 to this
- *   field, and a SW CSR write with a value greater than 8, will write an 8 to this field.
+ * This register provides the page size and the number of column-plus-row address-cycle
+ * information. Software writes to this register during a boot operation from a NAND flash
+ * device.
+ *
+ * Additionally, software also writes the multiplier value for timing parameters that is used
+ * during the boot process, in the SET_TM_PARAM command. The multiplier value is used only by the
+ * boot-load state machine during boot operations. Boot DMA operations do not use this value.
+ *
+ * Sixty-four-bit operations must be used to access this register.
  */
 union cvmx_ndf_bt_pg_info {
 	uint64_t u64;
 	struct cvmx_ndf_bt_pg_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_11_63               : 53;
-	uint64_t t_mult                       : 4;  /**< Boot time TIM_MULT[3:0] field of SET__TM_PAR[63:0]
-                                                         command */
-	uint64_t adr_cyc                      : 4;  /**< # of column address cycles */
-	uint64_t size                         : 3;  /**< bytes per page in the nand device */
+	uint64_t t_mult                       : 4;  /**< The boot-time TIM_MULT field of the SET_TM_PAR command. */
+	uint64_t adr_cyc                      : 4;  /**< Number of column-address cycles. Legal values are 0x3 - 0x8. Values written to this field
+                                                         smaller than 0x3 are converted to 0x3; values larger than 0x8 are converted to 0x8. */
+	uint64_t size                         : 3;  /**< Number of bytes per page in the NAND flash device = 2^SIZE+1 * 256.
+                                                         0x0 = 512 bytes/page.
+                                                         0x1 = 1 KB/page.
+                                                         0x2 = 2 KB/page.
+                                                         0x3 = 4 KB/page.
+                                                         0x4 = 8 KB/page.
+                                                         0x5 = 16 KB/page.
+                                                         0x6 = 32 KB/page.
+                                                         0x7 = 64 KB/page. */
 #else
 	uint64_t size                         : 3;
 	uint64_t adr_cyc                      : 4;
@@ -181,25 +244,27 @@ union cvmx_ndf_bt_pg_info {
 	struct cvmx_ndf_bt_pg_info_s          cn68xxp1;
 	struct cvmx_ndf_bt_pg_info_s          cn70xx;
 	struct cvmx_ndf_bt_pg_info_s          cn70xxp1;
+	struct cvmx_ndf_bt_pg_info_s          cn73xx;
 };
 typedef union cvmx_ndf_bt_pg_info cvmx_ndf_bt_pg_info_t;
 
 /**
  * cvmx_ndf_cmd
  *
- * When SW reads this csr, RD_VAL bit in NDF_MISC csr is cleared to 0. SW must always write all 8
- * bytes whenever it writes
- * this csr. If there are fewer than 8 bytes left in the command sequence that SW wants the NAND
- * flash controller to execute, it
- * must insert Idle (WAIT) commands to make up 8 bytes. SW also must ensure there is enough
- * vacancy in the command fifo to accept these
- * 8 bytes, by first reading the FR_BYT field in the NDF_MISC csr.
+ * When software reads this register, NDF_MISC[RD_VAL] is cleared to 0. Software must always
+ * write all eight bytes whenever it writes this register. If there are fewer than eight bytes
+ * left in the command sequence that software wants the NAND flash controller to execute, it must
+ * insert Idle (WAIT) commands to make up eight bytes. Software must also ensure that there is
+ * enough space in the NDF_CMD queue to accept these eight bytes by first reading
+ * NDF_MISC[FR_BYT].
+ *
+ * Sixty-four-bit operations must be used to access this register.
  */
 union cvmx_ndf_cmd {
 	uint64_t u64;
 	struct cvmx_ndf_cmd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t nf_cmd                       : 64; /**< 8 Command Bytes */
+	uint64_t nf_cmd                       : 64; /**< Eight NAND flash memory command bytes. */
 #else
 	uint64_t nf_cmd                       : 64;
 #endif
@@ -212,46 +277,104 @@ union cvmx_ndf_cmd {
 	struct cvmx_ndf_cmd_s                 cn68xxp1;
 	struct cvmx_ndf_cmd_s                 cn70xx;
 	struct cvmx_ndf_cmd_s                 cn70xxp1;
+	struct cvmx_ndf_cmd_s                 cn73xx;
 };
 typedef union cvmx_ndf_cmd cvmx_ndf_cmd_t;
 
 /**
+ * cvmx_ndf_dma_adr
+ *
+ * Sixty-four-bit operations must be used to access this register.
+ *
+ */
+union cvmx_ndf_dma_adr {
+	uint64_t u64;
+	struct cvmx_ndf_dma_adr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t adr                          : 39; /**< DMA engine address. 64-bit aligned. */
+	uint64_t reserved_0_2                 : 3;
+#else
+	uint64_t reserved_0_2                 : 3;
+	uint64_t adr                          : 39;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} s;
+	struct cvmx_ndf_dma_adr_s             cn73xx;
+};
+typedef union cvmx_ndf_dma_adr cvmx_ndf_dma_adr_t;
+
+/**
+ * cvmx_ndf_dma_cfg
+ *
+ * Sixty-four-bit operations must be used to access this register.
+ *
+ */
+union cvmx_ndf_dma_cfg {
+	uint64_t u64;
+	struct cvmx_ndf_dma_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t en                           : 1;  /**< DMA engine enable. */
+	uint64_t rw                           : 1;  /**< DMA engine R/W bit: 0 = read, 1 = write. */
+	uint64_t clr                          : 1;  /**< DMA engine clear EN. When set to 1, EN is cleared on a device-terminated burst. */
+	uint64_t reserved_60_60               : 1;
+	uint64_t swap32                       : 1;  /**< DMA engine 32-bit swap. */
+	uint64_t swap16                       : 1;  /**< DMA engine enable 16-bit swap. */
+	uint64_t swap8                        : 1;  /**< DMA engine enable 8-bit swap. */
+	uint64_t endian                       : 1;  /**< DMA engine endian mode: 0 = big-endian, 1 = little-endian. */
+	uint64_t size                         : 20; /**< DMA engine size. Specified in the number of 64-bit transfers (encoded in -1 notation). */
+	uint64_t reserved_0_35                : 36;
+#else
+	uint64_t reserved_0_35                : 36;
+	uint64_t size                         : 20;
+	uint64_t endian                       : 1;
+	uint64_t swap8                        : 1;
+	uint64_t swap16                       : 1;
+	uint64_t swap32                       : 1;
+	uint64_t reserved_60_60               : 1;
+	uint64_t clr                          : 1;
+	uint64_t rw                           : 1;
+	uint64_t en                           : 1;
+#endif
+	} s;
+	struct cvmx_ndf_dma_cfg_s             cn73xx;
+};
+typedef union cvmx_ndf_dma_cfg cvmx_ndf_dma_cfg_t;
+
+/**
  * cvmx_ndf_drbell
  *
- * SW csr writes will increment CNT by the signed 8 bit value being written. SW csr reads return
- * the current CNT value.
- * HW will also modify the value of the CNT field. Everytime HW executes a BUS_ACQ[15:0] command,
- * to arbitrate and win the
- * flash bus, it decrements the CNT field by 1. If the CNT field is already 0 or negative, HW
- * command execution unit will
- * stall when it fetches the new BUS_ACQ[15:0] command, from the command fifo. Only when the SW
- * writes to this CSR with a
- * non-zero data value, can the execution unit come out of the stalled condition, and resume
- * execution.
- * The intended use of this doorbell CSR is to control execution of the Nand Flash commands. The
- * NDF execution unit
- * has to arbitrate for the flash bus, before it can enable a Nand Flash device connected to the
- * Octeon chip, by
- * asserting the device's chip enable. Therefore SW should first load the command fifo, with a
- * full sequence of
- * commands to perform a Nand Flash device task. This command sequence will start with a bus
- * acquire command and
- * the last command in the sequence will be a bus release command. The execution unit will start
- * execution of
- * the sequence only if the [CNT] field is non-zero when it fetches the bus acquire command,
- * which is the first
- * command in this sequence. SW can also, load multiple such sequences, each starting with a chip
- * enable command
- * and ending with a chip disable command, and then write a non-zero data value to this csr to
- * increment the
- * CNT field by the number of the command sequences, loaded to the command fifo.
+ * This register is designed to control the execution of the NAND flash commands. The NDF
+ * command-execution unit must arbitrate for the boot bus before it can enable a NAND flash
+ * device connected to the CN78XX, which it then does by asserting the device's chip-enable
+ * signal. Therefore software must first load the NDF_CMD queue, with a full sequence of commands
+ * to perform a NAND flash device task.
+ *
+ * This command sequence starts with a BUS_ACQ command, and the last command in the sequence must
+ * be a BUS_REL command. The execution unit starts execution of the sequence only if the
+ * NDF_DRBELL[CNT] is non-zero when it fetches the BUS_ACQ command.
+ *
+ * Software can load multiple such sequences, each starting with a CHIP_EN command and ending
+ * with a CHIP_DIS command, and then write a data value to this register to increment the CNT
+ * field by the number of the command sequences loaded to the NDF_CMD queue.
+ *
+ * Software register-write operations increment CNT by the signed 8-bit value being written.
+ * Software register-read operations return the current CNT value.
+ *
+ * Hardware can also modifies the value of CNT. Every time hardware executes a BUS_ACQ command to
+ * arbitrate and win the boot bus, it decrements CNT by 1. If CNT is already 0 or negative, the
+ * hardware command-execution unit stalls when it fetches the new BUS_ACQ command from the
+ * NDF_CMD queue. Only when the software writes to this register with a non-zero data value can
+ * the execution unit come out of the stalled condition, and resume execution.
+ *
+ * Sixty-four-bit operations must be used to access this register.
  */
 union cvmx_ndf_drbell {
 	uint64_t u64;
 	struct cvmx_ndf_drbell_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t cnt                          : 8;  /**< Doorbell count register, 2's complement 8 bit value */
+	uint64_t cnt                          : 8;  /**< Doorbell count, in 2s-complement format. */
 #else
 	uint64_t cnt                          : 8;
 	uint64_t reserved_8_63                : 56;
@@ -265,28 +388,30 @@ union cvmx_ndf_drbell {
 	struct cvmx_ndf_drbell_s              cn68xxp1;
 	struct cvmx_ndf_drbell_s              cn70xx;
 	struct cvmx_ndf_drbell_s              cn70xxp1;
+	struct cvmx_ndf_drbell_s              cn73xx;
 };
 typedef union cvmx_ndf_drbell cvmx_ndf_drbell_t;
 
 /**
  * cvmx_ndf_ecc_cnt
  *
- * Notes:
- * XOR_ECC[31:8] = [ecc_gen_byt258, ecc_gen_byt257, ecc_gen_byt256] xor [ecc_258, ecc_257, ecc_256]
- *         ecc_258, ecc_257 and ecc_256 are bytes stored in Nand Flash and read out during boot
- *         ecc_gen_byt258, ecc_gen_byt257, ecc_gen_byt256 are generated from data read out from Nand Flash
+ * Sixty-four-bit operations must be used to access this register.
  *
- * Like all NDF_... registers, 64-bit operations must be used to access this register
  */
 union cvmx_ndf_ecc_cnt {
 	uint64_t u64;
 	struct cvmx_ndf_ecc_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t xor_ecc                      : 24; /**< result of XOR of ecc read bytes and ecc genarated
-                                                         bytes. The value pertains to the last 1 bit ecc err */
-	uint64_t ecc_err                      : 8;  /**< "Count = \# of 1 bit errors fixed during boot
-                                                         This count saturates instead of wrapping around." */
+	uint64_t xor_ecc                      : 24; /**< Result of XOR operation of ECC read bytes and ECC generated bytes. The value pertains to
+                                                         the last single-bit ECC error.
+                                                         _ XOR_ECC =[ECC_gen_byt258, ECC_gen_byt257, ECC_gen_byt256] ^
+                                                           [ECC_258, ECC_257, ECC_256]
+                                                         ECC_258, ECC_257 and ECC_256 are bytes stored in the NAND flash device and read out during
+                                                         boot.
+                                                         ECC_gen_byt258, ECC_gen_byt257, ECC_gen_byt256 are generated from data read out from the
+                                                         NAND flash device. */
+	uint64_t ecc_err                      : 8;  /**< ECC error count. The number of single-bit errors fixed during boot. */
 #else
 	uint64_t ecc_err                      : 8;
 	uint64_t xor_ecc                      : 24;
@@ -301,22 +426,45 @@ union cvmx_ndf_ecc_cnt {
 	struct cvmx_ndf_ecc_cnt_s             cn68xxp1;
 	struct cvmx_ndf_ecc_cnt_s             cn70xx;
 	struct cvmx_ndf_ecc_cnt_s             cn70xxp1;
+	struct cvmx_ndf_ecc_cnt_s             cn73xx;
 };
 typedef union cvmx_ndf_ecc_cnt cvmx_ndf_ecc_cnt_t;
 
 /**
  * cvmx_ndf_int
  *
- * FULL status is updated when the command fifo becomes full as a result of SW writing a new
- * command to it.
- * EMPTY status is updated when the command fifo becomes empty as a result of command execution
- * unit fetching the
- *   last instruction out of the command fifo.
+ * This register contains the bits that can trigger an error interrupt. Sixty-four-bit operations
+ * must be used to access this register.
  */
 union cvmx_ndf_int {
 	uint64_t u64;
 	struct cvmx_ndf_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t dma_done                     : 1;  /**< DMA engine request completion interrupt. */
+	uint64_t ovrf                         : 1;  /**< NDF_CMD write when FIFO is full. Generally a fatal error. */
+	uint64_t ecc_mult                     : 1;  /**< Multibit ECC error detected during boot. */
+	uint64_t ecc_1bit                     : 1;  /**< Single-bit ECC error detected and fixed during boot. */
+	uint64_t sm_bad                       : 1;  /**< One of the state machines is in a bad state, */
+	uint64_t wdog                         : 1;  /**< Watchdog timer expired during command execution. */
+	uint64_t full                         : 1;  /**< NDF_CMD queue is full. FULL status is updated when the NDF_CMD queue becomes full as a
+                                                         result of software writing a new command to it. */
+	uint64_t empty                        : 1;  /**< NDF_CMD queue is empty. EMPTY status is updated when the NDF_CMD queue becomes empty as a
+                                                         result of command execution unit fetching the last instruction out of the NDF_CMD queue. */
+#else
+	uint64_t empty                        : 1;
+	uint64_t full                         : 1;
+	uint64_t wdog                         : 1;
+	uint64_t sm_bad                       : 1;
+	uint64_t ecc_1bit                     : 1;
+	uint64_t ecc_mult                     : 1;
+	uint64_t ovrf                         : 1;
+	uint64_t dma_done                     : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_ndf_int_cn52xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
 	uint64_t ovrf                         : 1;  /**< NDF_CMD write when fifo is full. Generally a
                                                          fatal error. */
@@ -336,15 +484,15 @@ union cvmx_ndf_int {
 	uint64_t ovrf                         : 1;
 	uint64_t reserved_7_63                : 57;
 #endif
-	} s;
-	struct cvmx_ndf_int_s                 cn52xx;
-	struct cvmx_ndf_int_s                 cn63xx;
-	struct cvmx_ndf_int_s                 cn63xxp1;
-	struct cvmx_ndf_int_s                 cn66xx;
-	struct cvmx_ndf_int_s                 cn68xx;
-	struct cvmx_ndf_int_s                 cn68xxp1;
-	struct cvmx_ndf_int_s                 cn70xx;
-	struct cvmx_ndf_int_s                 cn70xxp1;
+	} cn52xx;
+	struct cvmx_ndf_int_cn52xx            cn63xx;
+	struct cvmx_ndf_int_cn52xx            cn63xxp1;
+	struct cvmx_ndf_int_cn52xx            cn66xx;
+	struct cvmx_ndf_int_cn52xx            cn68xx;
+	struct cvmx_ndf_int_cn52xx            cn68xxp1;
+	struct cvmx_ndf_int_cn52xx            cn70xx;
+	struct cvmx_ndf_int_cn52xx            cn70xxp1;
+	struct cvmx_ndf_int_s                 cn73xx;
 };
 typedef union cvmx_ndf_int cvmx_ndf_int_t;
 
@@ -390,76 +538,92 @@ union cvmx_ndf_int_en {
 typedef union cvmx_ndf_int_en cvmx_ndf_int_en_t;
 
 /**
+ * cvmx_ndf_int_w1s
+ */
+union cvmx_ndf_int_w1s {
+	uint64_t u64;
+	struct cvmx_ndf_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t dma_done                     : 1;  /**< DMA engine request completion interrupt. */
+	uint64_t ovrf                         : 1;  /**< NDF_CMD write when FIFO is full. Generally a fatal error. */
+	uint64_t ecc_mult                     : 1;  /**< Multibit ECC error detected during boot. */
+	uint64_t ecc_1bit                     : 1;  /**< Single-bit ECC error detected and fixed during boot. */
+	uint64_t sm_bad                       : 1;  /**< One of the state machines is in a bad state, */
+	uint64_t wdog                         : 1;  /**< Watchdog timer expired during command execution. */
+	uint64_t full                         : 1;  /**< NDF_CMD queue is full. FULL status is updated when the NDF_CMD queue becomes full as a
+                                                         result of software writing a new command to it. */
+	uint64_t empty                        : 1;  /**< NDF_CMD queue is empty. EMPTY status is updated when the NDF_CMD queue becomes empty as a
+                                                         result of command execution unit fetching the last instruction out of the NDF_CMD queue. */
+#else
+	uint64_t empty                        : 1;
+	uint64_t full                         : 1;
+	uint64_t wdog                         : 1;
+	uint64_t sm_bad                       : 1;
+	uint64_t ecc_1bit                     : 1;
+	uint64_t ecc_mult                     : 1;
+	uint64_t ovrf                         : 1;
+	uint64_t dma_done                     : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_ndf_int_w1s_s             cn73xx;
+};
+typedef union cvmx_ndf_int_w1s cvmx_ndf_int_w1s_t;
+
+/**
  * cvmx_ndf_misc
  *
- * "NBR_HWM this field specifies the high water mark for the NCB outbound load/store commands
- * receive fifo.
- *   the fifo size is 16 entries.
- * WAIT_CNT this field allows glitch filtering of the WAIT_n input to octeon, from Flash Memory.
- * The count
- *   represents number of eclk cycles.
- * FR_BYT  this field specifies \# of unfilled bytes in the command fifo. Bytes become unfilled as
- * commands
- *   complete execution and exit. (fifo is 256 bytes when BT_DIS=0,  and 1536 bytes when
- * BT_DIS=1)
- * RD_DONE this W1C bit is set to 1 by HW when it reads the last 8 bytes out of the command fifo,
- *   in response to RD_CMD bit being set to 1 by SW.
- * RD_VAL  this read only bit is set to 1 by HW when it reads next 8 bytes from command fifo in
- * response
- *   to RD_CMD bit being set to 1. A SW read of NDF_CMD csr clears this bit to 0.
- * RD_CMD  this R/W bit starts read out from the command fifo, 8 bytes at a time. SW should first
- * read the
- * RD_VAL bit in  this csr to see if next 8 bytes from the command fifo are available in the
- * NDF_CMD csr. All command fifo reads start and end on an 8 byte boundary. A RD_CMD in the
- *   middle of command execution will cause the execution to freeze until RD_DONE is set to 1.
- * RD_CMD
- *   bit will be cleared on any NDF_CMD csr write by SW.
- * BT_DMA  this indicates to the NAND flash boot control state machine that boot dma read can
- * begin.
- *   SW should set this bit to 1 after SW has loaded the command fifo. HW sets the bit to 0
- *   when boot dma command execution is complete. If chip enable 0 is not nand flash, this bit is
- *   permanently 1'b0 with SW writes ignored. Whenever BT_DIS=1, this bit will be 0.
- * BT_DIS  this R/W bit indicates to NAND flash boot control state machine that boot operation
- * has ended.
- *   whenever this bit changes from 0 to a 1, the command fifo is emptied as a side effect. This
- * bit must
- *   never be set when booting from nand flash and region zero is enabled.
- * EX_DIS  When 1, command execution stops after completing execution of all commands currently
- * in the command
- *   fifo. Once command execution has stopped, and then new commands are loaded into the command
- * fifo, execution
- *   will not resume as long as this bit is 1. When this bit is 0, command execution will resume
- * if command fifo
- *   is not empty. EX_DIS should be set to 1, during boot i.e. when BT_DIS = 0.
- * RST_FF  reset command fifo to make it empty, any command inflight is not aborted before
- * reseting
- *   the fifo. The fifo comes up empty at the end of power on reset."
+ * Sixty-four-bit operations must be used to access this register.
+ *
  */
 union cvmx_ndf_misc {
 	uint64_t u64;
 	struct cvmx_ndf_misc_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t mb_dis                       : 1;  /**< Disable multibit error hangs and allow boot loads
-                                                         or boot dma's proceed as if no multi bit errors
-                                                         occured. HW will fix single bit errors as usual */
-	uint64_t nbr_hwm                      : 3;  /**< Hi Water mark for NBR fifo or load/stores */
-	uint64_t wait_cnt                     : 6;  /**< WAIT input filter count */
-	uint64_t fr_byt                       : 11; /**< Number of unfilled Command fifo bytes */
-	uint64_t rd_done                      : 1;  /**< This W1C bit is set to 1 by HW when it completes
-                                                         command fifo read out, in response to RD_CMD */
-	uint64_t rd_val                       : 1;  /**< This RO bit is set to 1 by HW when it reads next 8
-                                                         bytes from Command fifo into the NDF_CMD csr
-                                                         SW reads NDF_CMD csr, HW clears this bit to 0 */
-	uint64_t rd_cmd                       : 1;  /**< When 1, HW reads out contents of the Command fifo 8
-                                                         bytes at a time into the NDF_CMD csr */
-	uint64_t bt_dma                       : 1;  /**< When set to 1, boot time dma is enabled */
-	uint64_t bt_dis                       : 1;  /**< When boot operation is over SW must set to 1
-                                                         causes boot state mchines to sleep */
-	uint64_t ex_dis                       : 1;  /**< When set to 1, suspends execution of commands at
-                                                         next command in the fifo. */
-	uint64_t rst_ff                       : 1;  /**< 1=reset command fifo to make it empty,
-                                                         0=normal operation */
+	uint64_t mb_dis                       : 1;  /**< Set to disable multi-bit error hangs. Allows boot loads and boot DMAs to proceed as if no
+                                                         multi-bit errors occurred. Hardware fixes single bit errors as usual. */
+	uint64_t nbr_hwm                      : 3;  /**< High watermark for NBR FIFO or load/store operations. This field specifies the high
+                                                         watermark for the IOI outbound load/store commands receive FIFO. The FIFO size is 16
+                                                         entries. */
+	uint64_t wait_cnt                     : 6;  /**< Wait input filter count. Represents the number of coprocessor-clock cycles for glitch
+                                                         filtering of BOOT_WAIT_L from the NAND flash device. */
+	uint64_t fr_byt                       : 11; /**< Unfilled NDF_CMD queue bytes. This field specifies the number of unfilled bytes in the
+                                                         NDF_CMD queue. Bytes become unfilled as commands complete execution and exit. (FIFO is 256
+                                                         bytes when BT_DIS = 0 and 1536 bytes when BT_DIS = 1.) */
+	uint64_t rd_done                      : 1;  /**< Read done. This bit is set to 1 by hardware when it reads the last eight bytes out of the
+                                                         NDF_CMD queue in response to RD_CMD being set to 1 by software. */
+	uint64_t rd_val                       : 1;  /**< This read-only bit is set to 1 by hardware when it reads the next eight bytes from NDF_CMD
+                                                         queue in response to RD_CMD being set to 1. A software read of NDF_CMD clears this bit to
+                                                         0. */
+	uint64_t rd_cmd                       : 1;  /**< Read command. When set to 1, the hardware reads the contents of the NDF_CMD queue eight
+                                                         bytes at a time and places the data into NDF_CMD. Software should first read RD_VAL to see
+                                                         if the next eight bytes from the NDF_CMD queue are available in NDF_CMD.
+                                                         All NDF_CMD queue read operations start and end on an eight-byte boundary. A RD_CMD
+                                                         command in the middle of command execution causes the execution to freeze until RD_DONE is
+                                                         set to 1.
+                                                         This bit is cleared on any NDF_CMD software write command. */
+	uint64_t bt_dma                       : 1;  /**< Boot-time DMA enable. When set to 1, boot-time DMA is enabled. This indicates to the NAND
+                                                         flash boot-control state machine that boot DMA read operations can begin. Software should
+                                                         set this bit to 1 after loading the NDF_CMD queue. Hardware sets the bit to 0 when boot
+                                                         DMA command execution is complete. If chip-enable 0 is not a NAND flash device, this bit
+                                                         is permanently 0 with software write operations ignored.
+                                                         When [BT_DIS] = 1, this bit is 0. */
+	uint64_t bt_dis                       : 1;  /**< Boot disable. When the boot operation is over, software must set this field to 1, which
+                                                         causes the boot-control state machines to sleep.
+                                                         This bit indicates to the NAND flash boot-control state machine that boot operation has
+                                                         ended. When this bit changes from 0 -> 1, the NDF_CMD queue is emptied as a side effect.
+                                                         This bit must never be set when booting from NAND flash and region zero is enabled. */
+	uint64_t ex_dis                       : 1;  /**< Execution disable. When set to 1, this bit stops command execution after completing the
+                                                         execution of all commands currently in the NDF_CMD queue. Once command execution has
+                                                         stopped and then new commands are loaded into the NDF_CMD queue, command execution does
+                                                         not resume while this bit is 1.
+                                                         When this bit is set to 0, execution resumes if the NDF_CMD queue is not empty. */
+	uint64_t rst_ff                       : 1;  /**< Reset FIFO.
+                                                         0 = Normal operation.
+                                                         1 = Reset NDF_CMD queue to empty it; any command in flight is not aborted before
+                                                         resetting. The FIFO comes up empty at the end of power on reset. */
 #else
 	uint64_t rst_ff                       : 1;
 	uint64_t ex_dis                       : 1;
@@ -516,30 +680,30 @@ union cvmx_ndf_misc {
 	struct cvmx_ndf_misc_s                cn68xxp1;
 	struct cvmx_ndf_misc_s                cn70xx;
 	struct cvmx_ndf_misc_s                cn70xxp1;
+	struct cvmx_ndf_misc_s                cn73xx;
 };
 typedef union cvmx_ndf_misc cvmx_ndf_misc_t;
 
 /**
  * cvmx_ndf_st_reg
  *
- * Notes:
- * This CSR aggregates all state machines used in nand flash controller for debug.
- * Like all NDF_... registers, 64-bit operations must be used to access this register
+ * This register aggregates all state machines used in NAND flash controller for debug purposes.
+ *
  */
 union cvmx_ndf_st_reg {
 	uint64_t u64;
 	struct cvmx_ndf_st_reg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t exe_idle                     : 1;  /**< Command Execution status 1=IDLE, 0=Busy
-                                                         1 means execution of command sequence is complete
-                                                         and command fifo is empty */
-	uint64_t exe_sm                       : 4;  /**< Command Execution State machine states */
-	uint64_t bt_sm                        : 4;  /**< Boot load and Boot dma State machine states */
-	uint64_t rd_ff_bad                    : 1;  /**< CMD fifo read back State machine in bad state */
-	uint64_t rd_ff                        : 2;  /**< CMD fifo read back State machine states */
-	uint64_t main_bad                     : 1;  /**< Main State machine in bad state */
-	uint64_t main_sm                      : 3;  /**< Main State machine states */
+	uint64_t exe_idle                     : 1;  /**< Command execution status
+                                                         0 = Busy.
+                                                         1 = Idle (execution of command sequence is complete and NDF_CMD queue is empty). */
+	uint64_t exe_sm                       : 4;  /**< Command-execution state-machine states. */
+	uint64_t bt_sm                        : 4;  /**< Boot-load and boot-DMA state-machine states. */
+	uint64_t rd_ff_bad                    : 1;  /**< The NDF_CMD-queue read-back state machine is in a 'bad' state. */
+	uint64_t rd_ff                        : 2;  /**< NDF_CMD-queue read-back state machine states. */
+	uint64_t main_bad                     : 1;  /**< The main state machine is in a 'bad' state. */
+	uint64_t main_sm                      : 3;  /**< Main state-machine states. */
 #else
 	uint64_t main_sm                      : 3;
 	uint64_t main_bad                     : 1;
@@ -559,6 +723,7 @@ union cvmx_ndf_st_reg {
 	struct cvmx_ndf_st_reg_s              cn68xxp1;
 	struct cvmx_ndf_st_reg_s              cn70xx;
 	struct cvmx_ndf_st_reg_s              cn70xxp1;
+	struct cvmx_ndf_st_reg_s              cn73xx;
 };
 typedef union cvmx_ndf_st_reg cvmx_ndf_st_reg_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index 2555c91..19faa6b 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -57,6 +57,7 @@ static inline uint64_t CVMX_OCLAX_BIST_RESULT(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_BIST_RESULT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000040ull) + ((block_id) & 7) * 0x1000000ull;
@@ -69,6 +70,7 @@ static inline uint64_t CVMX_OCLAX_CDHX_CTL(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_CDHX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000600ull) + (((offset) & 1) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -81,6 +83,7 @@ static inline uint64_t CVMX_OCLAX_CONST(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_CONST(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000000ull) + ((block_id) & 7) * 0x1000000ull;
@@ -93,6 +96,7 @@ static inline uint64_t CVMX_OCLAX_DATX(unsigned long offset, unsigned long block
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 8191)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 8191)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 8191)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8400000ull) + (((offset) & 8191) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -105,6 +109,7 @@ static inline uint64_t CVMX_OCLAX_DAT_POP(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_DAT_POP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000800ull) + ((block_id) & 7) * 0x1000000ull;
@@ -113,10 +118,23 @@ static inline uint64_t CVMX_OCLAX_DAT_POP(unsigned long block_id)
 #define CVMX_OCLAX_DAT_POP(block_id) (CVMX_ADD_IO_SEG(0x00011800A8000800ull) + ((block_id) & 7) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OCLAX_ECO(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2)))))
+		cvmx_warn("CVMX_OCLAX_ECO(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800A80000D0ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_OCLAX_ECO(block_id) (CVMX_ADD_IO_SEG(0x00011800A80000D0ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OCLAX_FIFO_DEPTH(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_DEPTH(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000200ull) + ((block_id) & 7) * 0x1000000ull;
@@ -129,6 +147,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_LIMIT(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_LIMIT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000240ull) + ((block_id) & 7) * 0x1000000ull;
@@ -141,6 +160,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_TAIL(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_TAIL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000260ull) + ((block_id) & 7) * 0x1000000ull;
@@ -153,6 +173,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_TRIG(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_TRIG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A80002A0ull) + ((block_id) & 7) * 0x1000000ull;
@@ -165,6 +186,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_WRAP(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_WRAP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000280ull) + ((block_id) & 7) * 0x1000000ull;
@@ -177,6 +199,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_ANDX_IX(unsigned long a, unsigned long b,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_ANDX_IX(%lu,%lu,%lu,%lu) is invalid on this chip\n", a, b, c, d);
 	return CVMX_ADD_IO_SEG(0x00011800A8300000ull) + ((a) << 24) + ((b) << 12) + ((c) << 4) + ((d) << 3);
@@ -189,6 +212,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_ORX(unsigned long a, unsigned long b, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_ORX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8310000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -201,6 +225,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_STATEX(unsigned long a, unsigned long b,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_STATEX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8320000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -213,6 +238,7 @@ static inline uint64_t CVMX_OCLAX_GEN_CTL(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_GEN_CTL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000060ull) + ((block_id) & 7) * 0x1000000ull;
@@ -225,6 +251,7 @@ static inline uint64_t CVMX_OCLAX_MATX_COUNT(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_COUNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8230000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -237,6 +264,7 @@ static inline uint64_t CVMX_OCLAX_MATX_CTL(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8200000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -249,6 +277,7 @@ static inline uint64_t CVMX_OCLAX_MATX_MASKX(unsigned long a, unsigned long b, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 3)) && ((c <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 3)) && ((c <= 1))))))
 		cvmx_warn("CVMX_OCLAX_MATX_MASKX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8220000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -261,6 +290,7 @@ static inline uint64_t CVMX_OCLAX_MATX_THRESH(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_MATX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8240000ull) + (((offset) & 3) + ((block_id) & 7) * 0x1000ull) * 4096;
@@ -273,6 +303,7 @@ static inline uint64_t CVMX_OCLAX_MATX_VALUEX(unsigned long a, unsigned long b,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 3)) && ((c <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 3)) && ((c <= 1))))))
 		cvmx_warn("CVMX_OCLAX_MATX_VALUEX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x00011800A8210000ull) + ((a) << 24) + ((b) << 12) + ((c) << 3);
@@ -285,6 +316,7 @@ static inline uint64_t CVMX_OCLAX_RAWX(unsigned long offset, unsigned long block
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_RAWX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000100ull) + (((offset) & 1) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -297,6 +329,7 @@ static inline uint64_t CVMX_OCLAX_SFT_RST(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_SFT_RST(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000020ull) + ((block_id) & 7) * 0x1000000ull;
@@ -309,6 +342,7 @@ static inline uint64_t CVMX_OCLAX_STACK_BASE(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_BASE(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000400ull) + ((block_id) & 7) * 0x1000000ull;
@@ -321,6 +355,7 @@ static inline uint64_t CVMX_OCLAX_STACK_CUR(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_CUR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000480ull) + ((block_id) & 7) * 0x1000000ull;
@@ -333,6 +368,7 @@ static inline uint64_t CVMX_OCLAX_STACK_STORE_CNT(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_STORE_CNT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000460ull) + ((block_id) & 7) * 0x1000000ull;
@@ -345,6 +381,7 @@ static inline uint64_t CVMX_OCLAX_STACK_TOP(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_TOP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000420ull) + ((block_id) & 7) * 0x1000000ull;
@@ -357,6 +394,7 @@ static inline uint64_t CVMX_OCLAX_STACK_WRAP(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STACK_WRAP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000440ull) + ((block_id) & 7) * 0x1000000ull;
@@ -369,6 +407,7 @@ static inline uint64_t CVMX_OCLAX_STAGEX(unsigned long offset, unsigned long blo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 71)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 71)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 71)) && ((block_id <= 4))))))
 		cvmx_warn("CVMX_OCLAX_STAGEX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8100000ull) + (((offset) & 127) + ((block_id) & 7) * 0x200000ull) * 8;
@@ -381,6 +420,7 @@ static inline uint64_t CVMX_OCLAX_STATE_INT(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STATE_INT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A8000080ull) + ((block_id) & 7) * 0x1000000ull;
@@ -393,6 +433,7 @@ static inline uint64_t CVMX_OCLAX_STATE_SET(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_STATE_SET(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A80000A0ull) + ((block_id) & 7) * 0x1000000ull;
@@ -405,6 +446,7 @@ static inline uint64_t CVMX_OCLAX_TIME(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 4)))))
 		cvmx_warn("CVMX_OCLAX_TIME(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800A80000C0ull) + ((block_id) & 7) * 0x1000000ull;
@@ -432,6 +474,7 @@ union cvmx_oclax_bist_result {
 	} s;
 	struct cvmx_oclax_bist_result_s       cn70xx;
 	struct cvmx_oclax_bist_result_s       cn70xxp1;
+	struct cvmx_oclax_bist_result_s       cn73xx;
 	struct cvmx_oclax_bist_result_s       cn78xx;
 };
 typedef union cvmx_oclax_bist_result cvmx_oclax_bist_result_t;
@@ -470,6 +513,7 @@ union cvmx_oclax_cdhx_ctl {
 	} s;
 	struct cvmx_oclax_cdhx_ctl_s          cn70xx;
 	struct cvmx_oclax_cdhx_ctl_s          cn70xxp1;
+	struct cvmx_oclax_cdhx_ctl_s          cn73xx;
 	struct cvmx_oclax_cdhx_ctl_s          cn78xx;
 };
 typedef union cvmx_oclax_cdhx_ctl cvmx_oclax_cdhx_ctl_t;
@@ -492,6 +536,7 @@ union cvmx_oclax_const {
 	} s;
 	struct cvmx_oclax_const_s             cn70xx;
 	struct cvmx_oclax_const_s             cn70xxp1;
+	struct cvmx_oclax_const_s             cn73xx;
 	struct cvmx_oclax_const_s             cn78xx;
 };
 typedef union cvmx_oclax_const cvmx_oclax_const_t;
@@ -512,6 +557,7 @@ union cvmx_oclax_datx {
 	} s;
 	struct cvmx_oclax_datx_s              cn70xx;
 	struct cvmx_oclax_datx_s              cn70xxp1;
+	struct cvmx_oclax_datx_s              cn73xx;
 	struct cvmx_oclax_datx_s              cn78xx;
 };
 typedef union cvmx_oclax_datx cvmx_oclax_datx_t;
@@ -542,11 +588,34 @@ union cvmx_oclax_dat_pop {
 	} s;
 	struct cvmx_oclax_dat_pop_s           cn70xx;
 	struct cvmx_oclax_dat_pop_s           cn70xxp1;
+	struct cvmx_oclax_dat_pop_s           cn73xx;
 	struct cvmx_oclax_dat_pop_s           cn78xx;
 };
 typedef union cvmx_oclax_dat_pop cvmx_oclax_dat_pop_t;
 
 /**
+ * cvmx_ocla#_eco
+ *
+ * Added in pass 2.
+ *
+ */
+union cvmx_oclax_eco {
+	uint64_t u64;
+	struct cvmx_oclax_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_oclax_eco_s               cn70xx;
+	struct cvmx_oclax_eco_s               cn73xx;
+};
+typedef union cvmx_oclax_eco cvmx_oclax_eco_t;
+
+/**
  * cvmx_ocla#_fifo_depth
  */
 union cvmx_oclax_fifo_depth {
@@ -562,6 +631,7 @@ union cvmx_oclax_fifo_depth {
 	} s;
 	struct cvmx_oclax_fifo_depth_s        cn70xx;
 	struct cvmx_oclax_fifo_depth_s        cn70xxp1;
+	struct cvmx_oclax_fifo_depth_s        cn73xx;
 	struct cvmx_oclax_fifo_depth_s        cn78xx;
 };
 typedef union cvmx_oclax_fifo_depth cvmx_oclax_fifo_depth_t;
@@ -593,6 +663,7 @@ union cvmx_oclax_fifo_limit {
 	} s;
 	struct cvmx_oclax_fifo_limit_s        cn70xx;
 	struct cvmx_oclax_fifo_limit_s        cn70xxp1;
+	struct cvmx_oclax_fifo_limit_s        cn73xx;
 	struct cvmx_oclax_fifo_limit_s        cn78xx;
 };
 typedef union cvmx_oclax_fifo_limit cvmx_oclax_fifo_limit_t;
@@ -613,6 +684,7 @@ union cvmx_oclax_fifo_tail {
 	} s;
 	struct cvmx_oclax_fifo_tail_s         cn70xx;
 	struct cvmx_oclax_fifo_tail_s         cn70xxp1;
+	struct cvmx_oclax_fifo_tail_s         cn73xx;
 	struct cvmx_oclax_fifo_tail_s         cn78xx;
 };
 typedef union cvmx_oclax_fifo_tail cvmx_oclax_fifo_tail_t;
@@ -637,6 +709,7 @@ union cvmx_oclax_fifo_trig {
 	} s;
 	struct cvmx_oclax_fifo_trig_s         cn70xx;
 	struct cvmx_oclax_fifo_trig_s         cn70xxp1;
+	struct cvmx_oclax_fifo_trig_s         cn73xx;
 	struct cvmx_oclax_fifo_trig_s         cn78xx;
 };
 typedef union cvmx_oclax_fifo_trig cvmx_oclax_fifo_trig_t;
@@ -659,6 +732,7 @@ union cvmx_oclax_fifo_wrap {
 	} s;
 	struct cvmx_oclax_fifo_wrap_s         cn70xx;
 	struct cvmx_oclax_fifo_wrap_s         cn70xxp1;
+	struct cvmx_oclax_fifo_wrap_s         cn73xx;
 	struct cvmx_oclax_fifo_wrap_s         cn78xx;
 };
 typedef union cvmx_oclax_fifo_wrap cvmx_oclax_fifo_wrap_t;
@@ -691,6 +765,7 @@ union cvmx_oclax_fsmx_andx_ix {
 	} s;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn70xx;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn70xxp1;
+	struct cvmx_oclax_fsmx_andx_ix_s      cn73xx;
 	struct cvmx_oclax_fsmx_andx_ix_s      cn78xx;
 };
 typedef union cvmx_oclax_fsmx_andx_ix cvmx_oclax_fsmx_andx_ix_t;
@@ -719,6 +794,7 @@ union cvmx_oclax_fsmx_orx {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} cn70xxp1;
+	struct cvmx_oclax_fsmx_orx_s          cn73xx;
 	struct cvmx_oclax_fsmx_orx_cn70xxp1   cn78xx;
 };
 typedef union cvmx_oclax_fsmx_orx cvmx_oclax_fsmx_orx_t;
@@ -763,6 +839,7 @@ union cvmx_oclax_fsmx_statex {
 	} s;
 	struct cvmx_oclax_fsmx_statex_s       cn70xx;
 	struct cvmx_oclax_fsmx_statex_s       cn70xxp1;
+	struct cvmx_oclax_fsmx_statex_s       cn73xx;
 	struct cvmx_oclax_fsmx_statex_s       cn78xx;
 };
 typedef union cvmx_oclax_fsmx_statex cvmx_oclax_fsmx_statex_t;
@@ -797,6 +874,7 @@ union cvmx_oclax_gen_ctl {
 	} s;
 	struct cvmx_oclax_gen_ctl_s           cn70xx;
 	struct cvmx_oclax_gen_ctl_s           cn70xxp1;
+	struct cvmx_oclax_gen_ctl_s           cn73xx;
 	struct cvmx_oclax_gen_ctl_s           cn78xx;
 };
 typedef union cvmx_oclax_gen_ctl cvmx_oclax_gen_ctl_t;
@@ -818,6 +896,7 @@ union cvmx_oclax_matx_count {
 	} s;
 	struct cvmx_oclax_matx_count_s        cn70xx;
 	struct cvmx_oclax_matx_count_s        cn70xxp1;
+	struct cvmx_oclax_matx_count_s        cn73xx;
 	struct cvmx_oclax_matx_count_s        cn78xx;
 };
 typedef union cvmx_oclax_matx_count cvmx_oclax_matx_count_t;
@@ -845,6 +924,7 @@ union cvmx_oclax_matx_ctl {
 	} s;
 	struct cvmx_oclax_matx_ctl_s          cn70xx;
 	struct cvmx_oclax_matx_ctl_s          cn70xxp1;
+	struct cvmx_oclax_matx_ctl_s          cn73xx;
 	struct cvmx_oclax_matx_ctl_s          cn78xx;
 };
 typedef union cvmx_oclax_matx_ctl cvmx_oclax_matx_ctl_t;
@@ -871,6 +951,7 @@ union cvmx_oclax_matx_maskx {
 	} s;
 	struct cvmx_oclax_matx_maskx_s        cn70xx;
 	struct cvmx_oclax_matx_maskx_s        cn70xxp1;
+	struct cvmx_oclax_matx_maskx_s        cn73xx;
 	struct cvmx_oclax_matx_maskx_s        cn78xx;
 };
 typedef union cvmx_oclax_matx_maskx cvmx_oclax_matx_maskx_t;
@@ -892,6 +973,7 @@ union cvmx_oclax_matx_thresh {
 	} s;
 	struct cvmx_oclax_matx_thresh_s       cn70xx;
 	struct cvmx_oclax_matx_thresh_s       cn70xxp1;
+	struct cvmx_oclax_matx_thresh_s       cn73xx;
 	struct cvmx_oclax_matx_thresh_s       cn78xx;
 };
 typedef union cvmx_oclax_matx_thresh cvmx_oclax_matx_thresh_t;
@@ -913,6 +995,7 @@ union cvmx_oclax_matx_valuex {
 	} s;
 	struct cvmx_oclax_matx_valuex_s       cn70xx;
 	struct cvmx_oclax_matx_valuex_s       cn70xxp1;
+	struct cvmx_oclax_matx_valuex_s       cn73xx;
 	struct cvmx_oclax_matx_valuex_s       cn78xx;
 };
 typedef union cvmx_oclax_matx_valuex cvmx_oclax_matx_valuex_t;
@@ -933,6 +1016,7 @@ union cvmx_oclax_rawx {
 	} s;
 	struct cvmx_oclax_rawx_s              cn70xx;
 	struct cvmx_oclax_rawx_s              cn70xxp1;
+	struct cvmx_oclax_rawx_s              cn73xx;
 	struct cvmx_oclax_rawx_s              cn78xx;
 };
 typedef union cvmx_oclax_rawx cvmx_oclax_rawx_t;
@@ -953,6 +1037,7 @@ union cvmx_oclax_sft_rst {
 	} s;
 	struct cvmx_oclax_sft_rst_s           cn70xx;
 	struct cvmx_oclax_sft_rst_s           cn70xxp1;
+	struct cvmx_oclax_sft_rst_s           cn73xx;
 	struct cvmx_oclax_sft_rst_s           cn78xx;
 };
 typedef union cvmx_oclax_sft_rst cvmx_oclax_sft_rst_t;
@@ -975,6 +1060,7 @@ union cvmx_oclax_stack_base {
 	} s;
 	struct cvmx_oclax_stack_base_s        cn70xx;
 	struct cvmx_oclax_stack_base_s        cn70xxp1;
+	struct cvmx_oclax_stack_base_s        cn73xx;
 	struct cvmx_oclax_stack_base_s        cn78xx;
 };
 typedef union cvmx_oclax_stack_base cvmx_oclax_stack_base_t;
@@ -999,6 +1085,7 @@ union cvmx_oclax_stack_cur {
 	} s;
 	struct cvmx_oclax_stack_cur_s         cn70xx;
 	struct cvmx_oclax_stack_cur_s         cn70xxp1;
+	struct cvmx_oclax_stack_cur_s         cn73xx;
 	struct cvmx_oclax_stack_cur_s         cn78xx;
 };
 typedef union cvmx_oclax_stack_cur cvmx_oclax_stack_cur_t;
@@ -1019,6 +1106,7 @@ union cvmx_oclax_stack_store_cnt {
 	} s;
 	struct cvmx_oclax_stack_store_cnt_s   cn70xx;
 	struct cvmx_oclax_stack_store_cnt_s   cn70xxp1;
+	struct cvmx_oclax_stack_store_cnt_s   cn73xx;
 	struct cvmx_oclax_stack_store_cnt_s   cn78xx;
 };
 typedef union cvmx_oclax_stack_store_cnt cvmx_oclax_stack_store_cnt_t;
@@ -1042,6 +1130,7 @@ union cvmx_oclax_stack_top {
 	} s;
 	struct cvmx_oclax_stack_top_s         cn70xx;
 	struct cvmx_oclax_stack_top_s         cn70xxp1;
+	struct cvmx_oclax_stack_top_s         cn73xx;
 	struct cvmx_oclax_stack_top_s         cn78xx;
 };
 typedef union cvmx_oclax_stack_top cvmx_oclax_stack_top_t;
@@ -1063,6 +1152,7 @@ union cvmx_oclax_stack_wrap {
 	} s;
 	struct cvmx_oclax_stack_wrap_s        cn70xx;
 	struct cvmx_oclax_stack_wrap_s        cn70xxp1;
+	struct cvmx_oclax_stack_wrap_s        cn73xx;
 	struct cvmx_oclax_stack_wrap_s        cn78xx;
 };
 typedef union cvmx_oclax_stack_wrap cvmx_oclax_stack_wrap_t;
@@ -1083,6 +1173,7 @@ union cvmx_oclax_stagex {
 	} s;
 	struct cvmx_oclax_stagex_s            cn70xx;
 	struct cvmx_oclax_stagex_s            cn70xxp1;
+	struct cvmx_oclax_stagex_s            cn73xx;
 	struct cvmx_oclax_stagex_s            cn78xx;
 };
 typedef union cvmx_oclax_stagex cvmx_oclax_stagex_t;
@@ -1146,6 +1237,7 @@ union cvmx_oclax_state_int {
 	} s;
 	struct cvmx_oclax_state_int_s         cn70xx;
 	struct cvmx_oclax_state_int_s         cn70xxp1;
+	struct cvmx_oclax_state_int_s         cn73xx;
 	struct cvmx_oclax_state_int_s         cn78xx;
 };
 typedef union cvmx_oclax_state_int cvmx_oclax_state_int_t;
@@ -1203,6 +1295,7 @@ union cvmx_oclax_state_set {
 	} s;
 	struct cvmx_oclax_state_set_s         cn70xx;
 	struct cvmx_oclax_state_set_s         cn70xxp1;
+	struct cvmx_oclax_state_set_s         cn73xx;
 	struct cvmx_oclax_state_set_s         cn78xx;
 };
 typedef union cvmx_oclax_state_set cvmx_oclax_state_set_t;
@@ -1230,6 +1323,7 @@ union cvmx_oclax_time {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} cn70xxp1;
+	struct cvmx_oclax_time_s              cn73xx;
 	struct cvmx_oclax_time_cn70xxp1       cn78xx;
 };
 typedef union cvmx_oclax_time cvmx_oclax_time_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-osm-defs.h b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
index 720d3c2..5f08d56 100644
--- a/arch/mips/include/asm/octeon/cvmx-osm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
@@ -66,68 +66,192 @@ static inline uint64_t CVMX_OSM_ASE_RATE_LIMIT_CTRL_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OSM_BANKX_CTRL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
-		cvmx_warn("CVMX_OSM_BANKX_CTRL(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001DC0000001000ull) + ((offset) & 31) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_OSM_BANKX_CTRL (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8;
 }
 #else
-#define CVMX_OSM_BANKX_CTRL(offset) (CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8)
+static inline uint64_t CVMX_OSM_BANKX_CTRL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000001000ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_OSM_CLK_CFG CVMX_OSM_CLK_CFG_FUNC()
+static inline uint64_t CVMX_OSM_CLK_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_OSM_CLK_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001DC0000000028ull);
+}
+#else
+#define CVMX_OSM_CLK_CFG (CVMX_ADD_IO_SEG(0x0001DC0000000028ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OSM_ECC_CTRL CVMX_OSM_ECC_CTRL_FUNC()
 static inline uint64_t CVMX_OSM_ECC_CTRL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_OSM_ECC_CTRL not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000020ull);
+			break;
+	}
+	cvmx_warn("CVMX_OSM_ECC_CTRL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
 }
 #else
-#define CVMX_OSM_ECC_CTRL (CVMX_ADD_IO_SEG(0x00011800DC000020ull))
+#define CVMX_OSM_ECC_CTRL CVMX_OSM_ECC_CTRL_FUNC()
+static inline uint64_t CVMX_OSM_ECC_CTRL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000020ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OSM_INT_INFO_ADDR CVMX_OSM_INT_INFO_ADDR_FUNC()
 static inline uint64_t CVMX_OSM_INT_INFO_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_OSM_INT_INFO_ADDR not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000018ull);
+			break;
+	}
+	cvmx_warn("CVMX_OSM_INT_INFO_ADDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
 }
 #else
-#define CVMX_OSM_INT_INFO_ADDR (CVMX_ADD_IO_SEG(0x00011800DC000018ull))
+#define CVMX_OSM_INT_INFO_ADDR CVMX_OSM_INT_INFO_ADDR_FUNC()
+static inline uint64_t CVMX_OSM_INT_INFO_ADDR_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000018ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OSM_INT_INFO_ECC CVMX_OSM_INT_INFO_ECC_FUNC()
 static inline uint64_t CVMX_OSM_INT_INFO_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_OSM_INT_INFO_ECC not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000010ull);
+			break;
+	}
+	cvmx_warn("CVMX_OSM_INT_INFO_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
 }
 #else
-#define CVMX_OSM_INT_INFO_ECC (CVMX_ADD_IO_SEG(0x00011800DC000010ull))
+#define CVMX_OSM_INT_INFO_ECC CVMX_OSM_INT_INFO_ECC_FUNC()
+static inline uint64_t CVMX_OSM_INT_INFO_ECC_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000010ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_OSM_INT_STAT CVMX_OSM_INT_STAT_FUNC()
 static inline uint64_t CVMX_OSM_INT_STAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_OSM_INT_STAT not supported on this chip\n");
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000008ull);
+			break;
+	}
+	cvmx_warn("CVMX_OSM_INT_STAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
 }
 #else
-#define CVMX_OSM_INT_STAT (CVMX_ADD_IO_SEG(0x00011800DC000008ull))
+#define CVMX_OSM_INT_STAT CVMX_OSM_INT_STAT_FUNC()
+static inline uint64_t CVMX_OSM_INT_STAT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000000008ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_OSM_MEMX_BIST_STATUS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
-		cvmx_warn("CVMX_OSM_MEMX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 7))
+				return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001DC0000002000ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_OSM_MEMX_BIST_STATUS (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8;
 }
 #else
-#define CVMX_OSM_MEMX_BIST_STATUS(offset) (CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8)
+static inline uint64_t CVMX_OSM_MEMX_BIST_STATUS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + (offset) * 8;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001DC0000002000ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_OSM_MEMX_DX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 16383))))))
+		cvmx_warn("CVMX_OSM_MEMX_DX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001DC0800000000ull) + (((offset) & 3) + ((block_id) & 16383) * 0x4ull) * 8;
+}
+#else
+#define CVMX_OSM_MEMX_DX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001DC0800000000ull) + (((offset) & 3) + ((block_id) & 16383) * 0x4ull) * 8)
 #endif
 
 /**
@@ -191,11 +315,33 @@ union cvmx_osm_bankx_ctrl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_osm_bankx_ctrl_s          cn73xx;
 	struct cvmx_osm_bankx_ctrl_s          cn78xx;
 };
 typedef union cvmx_osm_bankx_ctrl cvmx_osm_bankx_ctrl_t;
 
 /**
+ * cvmx_osm_clk_cfg
+ *
+ * This is the general configuration register for the OSM block.
+ *
+ */
+union cvmx_osm_clk_cfg {
+	uint64_t u64;
+	struct cvmx_osm_clk_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t clken                        : 1;  /**< Enable OSM clocks. Clear to disable clocking to disallow OSM accesses and save power. */
+#else
+	uint64_t clken                        : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_osm_clk_cfg_s             cn73xx;
+};
+typedef union cvmx_osm_clk_cfg cvmx_osm_clk_cfg_t;
+
+/**
  * cvmx_osm_ecc_ctrl
  *
  * ECC control register.
@@ -218,6 +364,7 @@ union cvmx_osm_ecc_ctrl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_osm_ecc_ctrl_s            cn73xx;
 	struct cvmx_osm_ecc_ctrl_s            cn78xx;
 };
 typedef union cvmx_osm_ecc_ctrl cvmx_osm_ecc_ctrl_t;
@@ -245,6 +392,7 @@ union cvmx_osm_int_info_addr {
 	uint64_t reserved_35_63               : 29;
 #endif
 	} s;
+	struct cvmx_osm_int_info_addr_s       cn73xx;
 	struct cvmx_osm_int_info_addr_s       cn78xx;
 };
 typedef union cvmx_osm_int_info_addr cvmx_osm_int_info_addr_t;
@@ -256,7 +404,7 @@ typedef union cvmx_osm_int_info_addr cvmx_osm_int_info_addr_t;
  * outstanding ECC errors indicated in OSM_INT_STAT and a new ECC error arrives. Prioritization
  * for multiple events occurring at the same time is indicated by the OSM_ECC_ERR_SOURCE_E
  * enumeration; highest encoded value has highest priority. For current bank assignment, see
- * OSM_BANK(0..63)_CTRL.
+ * OSM_BANK()_CTRL.
  */
 union cvmx_osm_int_info_ecc {
 	uint64_t u64;
@@ -273,6 +421,7 @@ union cvmx_osm_int_info_ecc {
 	uint64_t reserved_37_63               : 27;
 #endif
 	} s;
+	struct cvmx_osm_int_info_ecc_s        cn73xx;
 	struct cvmx_osm_int_info_ecc_s        cn78xx;
 };
 typedef union cvmx_osm_int_info_ecc cvmx_osm_int_info_ecc_t;
@@ -283,7 +432,7 @@ typedef union cvmx_osm_int_info_ecc cvmx_osm_int_info_ecc_t;
  * For debugging output for ECC DBE/SBEs, see OSM_INT_INFO_ECC. Address errors happen when a
  * requester attempts to access a bank that was not assigned to it. For example, Bank 0 is
  * assigned to HFA, and HNA attempts to access it. For debugging output for address errors, see
- * OSM_INT_INFO_ADDR. For current bank assignment, see OSM_BANK(0..63)_CTRL.
+ * OSM_INT_INFO_ADDR. For current bank assignment, see OSM_BANK()_CTRL.
  */
 union cvmx_osm_int_stat {
 	uint64_t u64;
@@ -340,6 +489,27 @@ union cvmx_osm_int_stat {
 	uint64_t reserved_23_63               : 41;
 #endif
 	} s;
+	struct cvmx_osm_int_stat_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_18_63               : 46;
+	uint64_t hna_addr_err                 : 1;  /**< HNA port illegal bank address error. */
+	uint64_t dfa_addr_err                 : 1;  /**< HFA port illegal bank address error. */
+	uint64_t reserved_4_15                : 12;
+	uint64_t hna_sbe                      : 1;  /**< HNA port single-bit error. */
+	uint64_t hna_dbe                      : 1;  /**< HNA port double-bit error. */
+	uint64_t dfa_sbe                      : 1;  /**< HFA port single-bit error. */
+	uint64_t dfa_dbe                      : 1;  /**< HFA port double-bit error. */
+#else
+	uint64_t dfa_dbe                      : 1;
+	uint64_t dfa_sbe                      : 1;
+	uint64_t hna_dbe                      : 1;
+	uint64_t hna_sbe                      : 1;
+	uint64_t reserved_4_15                : 12;
+	uint64_t dfa_addr_err                 : 1;
+	uint64_t hna_addr_err                 : 1;
+	uint64_t reserved_18_63               : 46;
+#endif
+	} cn73xx;
 	struct cvmx_osm_int_stat_s            cn78xx;
 };
 typedef union cvmx_osm_int_stat cvmx_osm_int_stat_t;
@@ -347,16 +517,16 @@ typedef union cvmx_osm_int_stat cvmx_osm_int_stat_t;
 /**
  * cvmx_osm_mem#_bist_status
  *
- * Results from BIST runs of OSM's memories. OSM_MEM is instantiated 8 times, each instance of
- * OSM_MEM has its own BIST_STATUS. Each OSM_MEM contains 32 BIST memory instances, so there are
- * 32 status bits per register.
+ * Results from BIST runs of OSM's memories. OSM_MEM is instantiated 2 times, each instance of
+ * OSM_MEM has its own BIST_STATUS. Each OSM_MEM contains 1 BIST memory instances, so there are
+ * 1 status bit per register.
  */
 union cvmx_osm_memx_bist_status {
 	uint64_t u64;
 	struct cvmx_osm_memx_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t bist_status                  : 32; /**< BIST status of BIST memory instance 31..0 in bits 31..0 respectively.
+	uint64_t bist_status                  : 32; /**< BIST status with one bit corresponding to each BIST memory instance.
                                                          INTERNAL: Each BIST Memory Instance (1 BIST engine + multiple physical memories) contains
                                                          2 physical memories. */
 #else
@@ -364,8 +534,41 @@ union cvmx_osm_memx_bist_status {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_osm_memx_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t bist_status                  : 1;  /**< BIST status with one bit corresponding to each BIST memory instance.
+                                                         INTERNAL: Each BIST Memory Instance (1 BIST engine + multiple physical memories) contains
+                                                         2 physical memories. */
+#else
+	uint64_t bist_status                  : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} cn73xx;
 	struct cvmx_osm_memx_bist_status_s    cn78xx;
 };
 typedef union cvmx_osm_memx_bist_status cvmx_osm_memx_bist_status_t;
 
+/**
+ * cvmx_osm_mem#_d#
+ */
+union cvmx_osm_memx_dx {
+	uint64_t u64;
+	struct cvmx_osm_memx_dx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t mem                          : 64; /**< OSM memory. THe last index in this memory corresponds to the row of data stored in OSM:
+                                                         D(0) = Data<63:0>.
+                                                         D(1) = Data<127:64>.
+                                                         D(2) = Data<191:128>.
+                                                         D(3) <63> = RAZ.
+                                                         D(3) <62:54> = ECC.(RO)
+                                                         D(3) <53:0> = Data<245:192>. */
+#else
+	uint64_t mem                          : 64;
+#endif
+	} s;
+	struct cvmx_osm_memx_dx_s             cn73xx;
+};
+typedef union cvmx_osm_memx_dx cvmx_osm_memx_dx_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 5d38c4b..2424017 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -56,6 +56,7 @@
 static inline uint64_t CVMX_PCIEEPVFX_CFG000(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG000(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000000ull + ((block_id) & 3) * 0x100000000ull;
@@ -67,6 +68,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG000(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG001(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG001(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000004ull + ((block_id) & 3) * 0x100000000ull;
@@ -78,6 +80,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG001(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG002(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG002(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000008ull + ((block_id) & 3) * 0x100000000ull;
@@ -89,6 +92,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG002(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG003(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG003(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000000Cull + ((block_id) & 3) * 0x100000000ull;
@@ -100,6 +104,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG003(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG004(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG004(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000010ull + ((block_id) & 3) * 0x100000000ull;
@@ -111,6 +116,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG004(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG005(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG005(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000014ull + ((block_id) & 3) * 0x100000000ull;
@@ -122,6 +128,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG005(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG006(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG006(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000018ull + ((block_id) & 3) * 0x100000000ull;
@@ -133,6 +140,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG006(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG007(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG007(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000001Cull + ((block_id) & 3) * 0x100000000ull;
@@ -144,6 +152,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG007(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG008(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG008(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000020ull + ((block_id) & 3) * 0x100000000ull;
@@ -155,6 +164,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG008(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG009(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG009(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000024ull + ((block_id) & 3) * 0x100000000ull;
@@ -166,6 +176,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG009(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG010(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG010(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000028ull + ((block_id) & 3) * 0x100000000ull;
@@ -177,6 +188,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG010(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG011(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG011(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000002Cull + ((block_id) & 3) * 0x100000000ull;
@@ -188,6 +200,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG011(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG012(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG012(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000030ull + ((block_id) & 3) * 0x100000000ull;
@@ -199,6 +212,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG012(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG013(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG013(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000034ull + ((block_id) & 3) * 0x100000000ull;
@@ -210,6 +224,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG013(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG015(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG015(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000003Cull + ((block_id) & 3) * 0x100000000ull;
@@ -221,6 +236,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG015(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG028(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG028(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000070ull + ((block_id) & 3) * 0x100000000ull;
@@ -232,6 +248,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG028(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG029(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG029(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000074ull + ((block_id) & 3) * 0x100000000ull;
@@ -243,6 +260,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG029(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG030(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG030(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000078ull + ((block_id) & 3) * 0x100000000ull;
@@ -254,6 +272,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG030(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG031(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG031(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000007Cull + ((block_id) & 3) * 0x100000000ull;
@@ -265,6 +284,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG031(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG032(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG032(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000080ull + ((block_id) & 3) * 0x100000000ull;
@@ -276,6 +296,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG032(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG037(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG037(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000094ull + ((block_id) & 3) * 0x100000000ull;
@@ -287,6 +308,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG037(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG038(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG038(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000098ull + ((block_id) & 3) * 0x100000000ull;
@@ -298,6 +320,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG038(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG039(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG039(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000009Cull + ((block_id) & 3) * 0x100000000ull;
@@ -309,6 +332,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG039(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG040(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG040(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000000A0ull + ((block_id) & 3) * 0x100000000ull;
@@ -320,6 +344,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG040(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG044(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG044(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000000B0ull + ((block_id) & 3) * 0x100000000ull;
@@ -331,6 +356,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG044(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG045(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG045(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000000B4ull + ((block_id) & 3) * 0x100000000ull;
@@ -342,6 +368,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG045(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG046(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG046(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000000B8ull + ((block_id) & 3) * 0x100000000ull;
@@ -353,6 +380,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG046(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG048(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG048(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000000C0ull + ((block_id) & 3) * 0x100000000ull;
@@ -364,6 +392,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG048(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG049(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG049(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000000C4ull + ((block_id) & 3) * 0x100000000ull;
@@ -375,6 +404,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG049(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG064(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG064(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000100ull + ((block_id) & 3) * 0x100000000ull;
@@ -386,6 +416,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG064(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG082(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG082(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000148ull + ((block_id) & 3) * 0x100000000ull;
@@ -397,6 +428,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG082(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG083(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG083(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000014Cull + ((block_id) & 3) * 0x100000000ull;
@@ -408,6 +440,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG083(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG448(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG448(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000700ull + ((block_id) & 3) * 0x100000000ull;
@@ -419,6 +452,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG448(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG449(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG449(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000704ull + ((block_id) & 3) * 0x100000000ull;
@@ -430,6 +464,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG449(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG450(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG450(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000708ull + ((block_id) & 3) * 0x100000000ull;
@@ -441,6 +476,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG450(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG451(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG451(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000070Cull + ((block_id) & 3) * 0x100000000ull;
@@ -452,6 +488,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG451(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG452(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG452(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000710ull + ((block_id) & 3) * 0x100000000ull;
@@ -463,6 +500,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG452(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG453(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG453(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000714ull + ((block_id) & 3) * 0x100000000ull;
@@ -474,6 +512,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG453(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG454(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG454(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000718ull + ((block_id) & 3) * 0x100000000ull;
@@ -485,6 +524,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG454(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG455(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG455(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000071Cull + ((block_id) & 3) * 0x100000000ull;
@@ -496,6 +536,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG455(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG456(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG456(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000720ull + ((block_id) & 3) * 0x100000000ull;
@@ -507,6 +548,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG456(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG458(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG458(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000728ull + ((block_id) & 3) * 0x100000000ull;
@@ -518,6 +560,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG458(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG459(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG459(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000072Cull + ((block_id) & 3) * 0x100000000ull;
@@ -529,6 +572,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG459(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG460(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG460(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000730ull + ((block_id) & 3) * 0x100000000ull;
@@ -540,6 +584,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG460(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG461(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG461(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000734ull + ((block_id) & 3) * 0x100000000ull;
@@ -551,6 +596,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG461(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG462(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG462(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000738ull + ((block_id) & 3) * 0x100000000ull;
@@ -562,6 +608,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG462(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG463(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG463(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000073Cull + ((block_id) & 3) * 0x100000000ull;
@@ -573,6 +620,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG463(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG464(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG464(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000740ull + ((block_id) & 3) * 0x100000000ull;
@@ -584,6 +632,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG464(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG465(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG465(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000744ull + ((block_id) & 3) * 0x100000000ull;
@@ -595,6 +644,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG465(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG466(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG466(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000748ull + ((block_id) & 3) * 0x100000000ull;
@@ -606,6 +656,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG466(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG467(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG467(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000074Cull + ((block_id) & 3) * 0x100000000ull;
@@ -617,6 +668,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG467(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG468(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG468(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000750ull + ((block_id) & 3) * 0x100000000ull;
@@ -628,6 +680,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG468(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG490(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG490(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000007A8ull + ((block_id) & 3) * 0x100000000ull;
@@ -639,6 +692,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG490(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG491(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG491(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000007ACull + ((block_id) & 3) * 0x100000000ull;
@@ -650,6 +704,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG491(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG492(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG492(%lu) is invalid on this chip\n", block_id);
 	return 0x00000500000007B0ull + ((block_id) & 3) * 0x100000000ull;
@@ -661,6 +716,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG492(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG515(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG515(%lu) is invalid on this chip\n", block_id);
 	return 0x000005000000080Cull + ((block_id) & 3) * 0x100000000ull;
@@ -672,6 +728,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG515(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG516(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG516(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000810ull + ((block_id) & 3) * 0x100000000ull;
@@ -683,6 +740,7 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG516(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPVFX_CFG517(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG517(%lu) is invalid on this chip\n", block_id);
 	return 0x0000050000000814ull + ((block_id) & 3) * 0x100000000ull;
@@ -708,6 +766,7 @@ union cvmx_pcieepvfx_cfg000 {
 	uint32_t devid                        : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg000_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg000_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg000 cvmx_pcieepvfx_cfg000_t;
@@ -773,6 +832,7 @@ union cvmx_pcieepvfx_cfg001 {
 	uint32_t dpe                          : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg001_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg001_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg001 cvmx_pcieepvfx_cfg001_t;
@@ -799,6 +859,7 @@ union cvmx_pcieepvfx_cfg002 {
 	uint32_t bcc                          : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg002_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg002_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg002 cvmx_pcieepvfx_cfg002_t;
@@ -829,6 +890,7 @@ union cvmx_pcieepvfx_cfg003 {
 	uint32_t bist                         : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg003_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg003_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg003 cvmx_pcieepvfx_cfg003_t;
@@ -848,6 +910,7 @@ union cvmx_pcieepvfx_cfg004 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg004_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg004_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg004 cvmx_pcieepvfx_cfg004_t;
@@ -867,6 +930,7 @@ union cvmx_pcieepvfx_cfg005 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg005_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg005_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg005 cvmx_pcieepvfx_cfg005_t;
@@ -886,6 +950,7 @@ union cvmx_pcieepvfx_cfg006 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg006_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg006_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg006 cvmx_pcieepvfx_cfg006_t;
@@ -905,6 +970,7 @@ union cvmx_pcieepvfx_cfg007 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg007_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg007_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg007 cvmx_pcieepvfx_cfg007_t;
@@ -924,6 +990,7 @@ union cvmx_pcieepvfx_cfg008 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg008_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg008_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg008 cvmx_pcieepvfx_cfg008_t;
@@ -943,6 +1010,7 @@ union cvmx_pcieepvfx_cfg009 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg009_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg009_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg009 cvmx_pcieepvfx_cfg009_t;
@@ -962,6 +1030,7 @@ union cvmx_pcieepvfx_cfg010 {
 	uint32_t cisp                         : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg010_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg010_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg010 cvmx_pcieepvfx_cfg010_t;
@@ -983,6 +1052,7 @@ union cvmx_pcieepvfx_cfg011 {
 	uint32_t ssid                         : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg011_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg011_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg011 cvmx_pcieepvfx_cfg011_t;
@@ -1006,6 +1076,7 @@ union cvmx_pcieepvfx_cfg012 {
 	uint32_t eraddr                       : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg012_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg012_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg012 cvmx_pcieepvfx_cfg012_t;
@@ -1027,6 +1098,7 @@ union cvmx_pcieepvfx_cfg013 {
 	uint32_t reserved_8_31                : 24;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg013_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg013_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg013 cvmx_pcieepvfx_cfg013_t;
@@ -1052,6 +1124,7 @@ union cvmx_pcieepvfx_cfg015 {
 	uint32_t ml                           : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg015_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg015_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg015 cvmx_pcieepvfx_cfg015_t;
@@ -1083,6 +1156,7 @@ union cvmx_pcieepvfx_cfg028 {
 	uint32_t reserved_30_31               : 2;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg028_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg028_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg028 cvmx_pcieepvfx_cfg028_t;
@@ -1124,6 +1198,7 @@ union cvmx_pcieepvfx_cfg029 {
 	uint32_t reserved_29_31               : 3;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg029_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg029_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg029 cvmx_pcieepvfx_cfg029_t;
@@ -1197,6 +1272,7 @@ union cvmx_pcieepvfx_cfg030 {
 	uint32_t reserved_22_31               : 10;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg030_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg030_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg030 cvmx_pcieepvfx_cfg030_t;
@@ -1252,6 +1328,7 @@ union cvmx_pcieepvfx_cfg031 {
 	uint32_t pnum                         : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg031_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg031_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg031 cvmx_pcieepvfx_cfg031_t;
@@ -1316,6 +1393,7 @@ union cvmx_pcieepvfx_cfg032 {
 	uint32_t lab                          : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg032_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg032_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg032 cvmx_pcieepvfx_cfg032_t;
@@ -1347,7 +1425,7 @@ union cvmx_pcieepvfx_cfg037 {
 	uint32_t atom64s                      : 1;  /**< 64-bit AtomicOp supported (not supported). */
 	uint32_t atom32s                      : 1;  /**< 32-bit AtomicOp supported (not supported). */
 	uint32_t atom_ops                     : 1;  /**< AtomicOp routing supported (not applicable for EP). */
-	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported. */
+	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not applicable for EP). */
 	uint32_t ctds                         : 1;  /**< Completion timeout disable supported. */
 	uint32_t ctrs                         : 4;  /**< Completion timeout ranges supported. */
 #else
@@ -1369,6 +1447,7 @@ union cvmx_pcieepvfx_cfg037 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg037_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg037_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg037 cvmx_pcieepvfx_cfg037_t;
@@ -1390,7 +1469,7 @@ union cvmx_pcieepvfx_cfg038 {
 	uint32_t id0_cp                       : 1;  /**< ID based ordering completion enable (not supported). */
 	uint32_t id0_rq                       : 1;  /**< ID based ordering request enable (not supported). */
 	uint32_t atom_op_eb                   : 1;  /**< AtomicOp egress blocking (not supported). */
-	uint32_t atom_op                      : 1;  /**< AtomicOp requester enable (not supported). */
+	uint32_t atom_op                      : 1;  /**< AtomicOp requester enable (not applicable for EP). */
 	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not supported). */
 	uint32_t ctd                          : 1;  /**< Completion timeout disable. */
 	uint32_t ctv                          : 4;  /**< Completion timeout value. Completion timeout programming is not supported. Completion
@@ -1409,6 +1488,7 @@ union cvmx_pcieepvfx_cfg038 {
 	uint32_t reserved_16_31               : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg038_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg038_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg038 cvmx_pcieepvfx_cfg038_t;
@@ -1445,6 +1525,7 @@ union cvmx_pcieepvfx_cfg039 {
 	uint32_t reserved_9_31                : 23;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg039_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg039_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg039 cvmx_pcieepvfx_cfg039_t;
@@ -1524,6 +1605,7 @@ union cvmx_pcieepvfx_cfg040 {
 	uint32_t reserved_17_31               : 15;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg040_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg040_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg040 cvmx_pcieepvfx_cfg040_t;
@@ -1556,6 +1638,7 @@ union cvmx_pcieepvfx_cfg044 {
 	uint32_t msixen                       : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg044_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg044_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg044 cvmx_pcieepvfx_cfg044_t;
@@ -1579,6 +1662,7 @@ union cvmx_pcieepvfx_cfg045 {
 	uint32_t msixtoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg045_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg045_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg045 cvmx_pcieepvfx_cfg045_t;
@@ -1603,6 +1687,7 @@ union cvmx_pcieepvfx_cfg046 {
 	uint32_t msixpoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg046_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg046_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg046 cvmx_pcieepvfx_cfg046_t;
@@ -1645,6 +1730,7 @@ union cvmx_pcieepvfx_cfg048 {
 	uint32_t pmes                         : 5;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg048_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg048_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg048 cvmx_pcieepvfx_cfg048_t;
@@ -1691,6 +1777,7 @@ union cvmx_pcieepvfx_cfg049 {
 	uint32_t pmdia                        : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg049_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg049_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg049 cvmx_pcieepvfx_cfg049_t;
@@ -1714,6 +1801,7 @@ union cvmx_pcieepvfx_cfg064 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg064_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg064_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg064 cvmx_pcieepvfx_cfg064_t;
@@ -1737,6 +1825,7 @@ union cvmx_pcieepvfx_cfg082 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg082_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg082_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg082 cvmx_pcieepvfx_cfg082_t;
@@ -1772,6 +1861,7 @@ union cvmx_pcieepvfx_cfg083 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg083_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg083_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg083 cvmx_pcieepvfx_cfg083_t;
@@ -1800,6 +1890,7 @@ union cvmx_pcieepvfx_cfg448 {
 	uint32_t rtl                          : 16;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg448_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg448_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg448 cvmx_pcieepvfx_cfg448_t;
@@ -1826,6 +1917,7 @@ union cvmx_pcieepvfx_cfg449 {
 	uint32_t omr                          : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg449_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg449_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg449 cvmx_pcieepvfx_cfg449_t;
@@ -1896,6 +1988,7 @@ union cvmx_pcieepvfx_cfg450 {
 	uint32_t lpec                         : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg450_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg450_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg450 cvmx_pcieepvfx_cfg450_t;
@@ -1952,6 +2045,7 @@ union cvmx_pcieepvfx_cfg451 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg451_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg451_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg451 cvmx_pcieepvfx_cfg451_t;
@@ -2016,6 +2110,7 @@ union cvmx_pcieepvfx_cfg452 {
 	uint32_t reserved_22_31               : 10;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg452_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg452_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg452 cvmx_pcieepvfx_cfg452_t;
@@ -2046,6 +2141,7 @@ union cvmx_pcieepvfx_cfg453 {
 	uint32_t dlld                         : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg453_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg453_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg453 cvmx_pcieepvfx_cfg453_t;
@@ -2079,6 +2175,7 @@ union cvmx_pcieepvfx_cfg454 {
 	uint32_t reserved_29_31               : 3;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg454_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg454_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg454 cvmx_pcieepvfx_cfg454_t;
@@ -2134,6 +2231,7 @@ union cvmx_pcieepvfx_cfg455 {
 	uint32_t m_cfg0_filt                  : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg455_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg455_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg455 cvmx_pcieepvfx_cfg455_t;
@@ -2161,6 +2259,7 @@ union cvmx_pcieepvfx_cfg456 {
 	uint32_t reserved_4_31                : 28;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg456_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg456_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg456 cvmx_pcieepvfx_cfg456_t;
@@ -2180,6 +2279,7 @@ union cvmx_pcieepvfx_cfg458 {
 	uint32_t dbg_info_l32                 : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg458_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg458_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg458 cvmx_pcieepvfx_cfg458_t;
@@ -2199,6 +2299,7 @@ union cvmx_pcieepvfx_cfg459 {
 	uint32_t dbg_info_u32                 : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg459_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg459_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg459 cvmx_pcieepvfx_cfg459_t;
@@ -2224,6 +2325,7 @@ union cvmx_pcieepvfx_cfg460 {
 	uint32_t reserved_20_31               : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg460_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg460_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg460 cvmx_pcieepvfx_cfg460_t;
@@ -2249,6 +2351,7 @@ union cvmx_pcieepvfx_cfg461 {
 	uint32_t reserved_20_31               : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg461_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg461_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg461 cvmx_pcieepvfx_cfg461_t;
@@ -2274,6 +2377,7 @@ union cvmx_pcieepvfx_cfg462 {
 	uint32_t reserved_20_31               : 12;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg462_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg462_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg462 cvmx_pcieepvfx_cfg462_t;
@@ -2312,6 +2416,7 @@ union cvmx_pcieepvfx_cfg463 {
 	uint32_t fcltoe                       : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg463_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg463_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg463 cvmx_pcieepvfx_cfg463_t;
@@ -2337,6 +2442,7 @@ union cvmx_pcieepvfx_cfg464 {
 	uint32_t wrr_vc3                      : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg464_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg464_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg464 cvmx_pcieepvfx_cfg464_t;
@@ -2362,6 +2468,7 @@ union cvmx_pcieepvfx_cfg465 {
 	uint32_t wrr_vc7                      : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg465_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg465_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg465 cvmx_pcieepvfx_cfg465_t;
@@ -2407,6 +2514,7 @@ union cvmx_pcieepvfx_cfg466 {
 	uint32_t rx_queue_order               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg466_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg466_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg466 cvmx_pcieepvfx_cfg466_t;
@@ -2444,6 +2552,7 @@ union cvmx_pcieepvfx_cfg467 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg467_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg467_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg467 cvmx_pcieepvfx_cfg467_t;
@@ -2482,6 +2591,7 @@ union cvmx_pcieepvfx_cfg468 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg468_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg468_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg468 cvmx_pcieepvfx_cfg468_t;
@@ -2509,6 +2619,7 @@ union cvmx_pcieepvfx_cfg490 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg490_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg490_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg490 cvmx_pcieepvfx_cfg490_t;
@@ -2536,6 +2647,7 @@ union cvmx_pcieepvfx_cfg491 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg491_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg491_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg491 cvmx_pcieepvfx_cfg491_t;
@@ -2563,6 +2675,7 @@ union cvmx_pcieepvfx_cfg492 {
 	uint32_t reserved_26_31               : 6;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg492_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg492_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg492 cvmx_pcieepvfx_cfg492_t;
@@ -2603,6 +2716,7 @@ union cvmx_pcieepvfx_cfg515 {
 	uint32_t reserved_21_31               : 11;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg515_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg515_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg515 cvmx_pcieepvfx_cfg515_t;
@@ -2622,6 +2736,7 @@ union cvmx_pcieepvfx_cfg516 {
 	uint32_t phy_stat                     : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg516_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg516_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg516 cvmx_pcieepvfx_cfg516_t;
@@ -2641,6 +2756,7 @@ union cvmx_pcieepvfx_cfg517 {
 	uint32_t phy_ctrl                     : 32;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg517_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg517_s        cn78xx;
 };
 typedef union cvmx_pcieepvfx_cfg517 cvmx_pcieepvfx_cfg517_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index c576d9d..cff1983 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -74,6 +74,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long block_id)
 				return 0x0000030000000000ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000000ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -97,6 +98,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000000ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000000ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000000ull;
@@ -124,6 +126,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long block_id)
 				return 0x0000030000000004ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000004ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -147,6 +150,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000004ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000004ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000004ull;
@@ -174,6 +178,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long block_id)
 				return 0x0000030000000008ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000008ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -197,6 +202,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000008ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000008ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000008ull;
@@ -224,6 +230,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long block_id)
 				return 0x000003000000000Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000000Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -247,6 +254,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000000Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000000Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000000Cull;
@@ -274,6 +282,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long block_id)
 				return 0x0000030000000010ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000010ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -297,6 +306,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000010ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000010ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000010ull;
@@ -324,6 +334,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long block_id)
 				return 0x0000030080000010ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030080000010ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -347,6 +358,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000010ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000010ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000080000010ull;
@@ -374,6 +386,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long block_id)
 				return 0x0000030000000014ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000014ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -397,6 +410,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000014ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000014ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000014ull;
@@ -424,6 +438,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long block_id)
 				return 0x0000030080000014ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030080000014ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -447,6 +462,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000014ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000014ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000080000014ull;
@@ -474,6 +490,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long block_id)
 				return 0x0000030000000018ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000018ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -497,6 +514,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000018ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000018ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000018ull;
@@ -524,6 +542,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long block_id)
 				return 0x0000030080000018ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030080000018ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -547,6 +566,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000018ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000018ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000080000018ull;
@@ -574,6 +594,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long block_id)
 				return 0x000003000000001Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000001Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -597,6 +618,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000001Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000001Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000001Cull;
@@ -624,6 +646,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long block_id)
 				return 0x000003008000001Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003008000001Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -647,6 +670,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003008000001Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003008000001Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000008000001Cull;
@@ -674,6 +698,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long block_id)
 				return 0x0000030000000020ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000020ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -697,6 +722,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000020ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000020ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000020ull;
@@ -724,6 +750,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long block_id)
 				return 0x0000030080000020ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030080000020ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -747,6 +774,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000020ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000020ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000080000020ull;
@@ -774,6 +802,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long block_id)
 				return 0x0000030000000024ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000024ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -797,6 +826,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000024ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000024ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000024ull;
@@ -824,6 +854,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long block_id)
 				return 0x0000030080000024ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030080000024ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -847,6 +878,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000024ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000024ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000080000024ull;
@@ -874,6 +906,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long block_id)
 				return 0x0000030000000028ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000028ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -897,6 +930,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000028ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000028ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000028ull;
@@ -924,6 +958,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long block_id)
 				return 0x000003000000002Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000002Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -947,6 +982,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000002Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000002Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000002Cull;
@@ -974,6 +1010,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long block_id)
 				return 0x0000030000000030ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000030ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -997,6 +1034,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000030ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000030ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000030ull;
@@ -1024,6 +1062,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long block_id)
 				return 0x0000030080000030ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030080000030ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1047,6 +1086,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000030ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000030ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000080000030ull;
@@ -1074,6 +1114,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long block_id)
 				return 0x0000030000000034ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000034ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1097,6 +1138,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000034ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000034ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000034ull;
@@ -1124,6 +1166,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long block_id)
 				return 0x000003000000003Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000003Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1147,6 +1190,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000003Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000003Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000003Cull;
@@ -1174,6 +1218,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long block_id)
 				return 0x0000030000000040ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000040ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1197,6 +1242,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000040ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000040ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000040ull;
@@ -1224,6 +1270,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long block_id)
 				return 0x0000030000000044ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000044ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1247,6 +1294,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000044ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000044ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000044ull;
@@ -1274,6 +1322,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long block_id)
 				return 0x0000030000000050ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000050ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1297,6 +1346,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000050ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000050ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000050ull;
@@ -1324,6 +1374,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long block_id)
 				return 0x0000030000000054ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000054ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1347,6 +1398,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000054ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000054ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000054ull;
@@ -1374,6 +1426,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long block_id)
 				return 0x0000030000000058ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000058ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1397,6 +1450,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000058ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000058ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000058ull;
@@ -1424,6 +1478,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long block_id)
 				return 0x000003000000005Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000005Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1447,6 +1502,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000005Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000005Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000005Cull;
@@ -1457,6 +1513,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG024(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG024(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000060ull + ((block_id) & 3) * 0x100000000ull;
@@ -1469,6 +1526,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG025(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG025(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000064ull + ((block_id) & 3) * 0x100000000ull;
@@ -1498,6 +1556,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long block_id)
 				return 0x0000030000000070ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000070ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1521,6 +1580,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000070ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000070ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000070ull;
@@ -1548,6 +1608,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long block_id)
 				return 0x0000030000000074ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000074ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1571,6 +1632,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000074ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000074ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000074ull;
@@ -1598,6 +1660,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long block_id)
 				return 0x0000030000000078ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000078ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1621,6 +1684,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000078ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000078ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000078ull;
@@ -1648,6 +1712,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long block_id)
 				return 0x000003000000007Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000007Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1671,6 +1736,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000007Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000007Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000007Cull;
@@ -1698,6 +1764,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long block_id)
 				return 0x0000030000000080ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000080ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1721,6 +1788,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000080ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000080ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000080ull;
@@ -1774,6 +1842,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long block_id)
 				return 0x0000030000000094ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000094ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1797,6 +1866,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000094ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000094ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000094ull;
@@ -1824,6 +1894,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long block_id)
 				return 0x0000030000000098ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000098ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1847,6 +1918,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000098ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000098ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000098ull;
@@ -1874,6 +1946,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long block_id)
 				return 0x000003000000009Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000009Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1897,6 +1970,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000009Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000009Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000009Cull;
@@ -1924,6 +1998,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long block_id)
 				return 0x00000300000000A0ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x00000300000000A0ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1947,6 +2022,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000300000000A0ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x00000300000000A0ull + (block_id) * 0x100000000ull;
 	}
 	return 0x00000000000000A0ull;
@@ -1982,6 +2058,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG042(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG044(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG044(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000000B0ull + ((block_id) & 3) * 0x100000000ull;
@@ -1993,6 +2070,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG044(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG045(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG045(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000000B4ull + ((block_id) & 3) * 0x100000000ull;
@@ -2004,6 +2082,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG045(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG046(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG046(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000000B8ull + ((block_id) & 3) * 0x100000000ull;
@@ -2033,6 +2112,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long block_id)
 				return 0x0000030000000100ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000100ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2056,6 +2136,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000100ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000100ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000100ull;
@@ -2083,6 +2164,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long block_id)
 				return 0x0000030000000104ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000104ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2106,6 +2188,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000104ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000104ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000104ull;
@@ -2133,6 +2216,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long block_id)
 				return 0x0000030000000108ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000108ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2156,6 +2240,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000108ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000108ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000108ull;
@@ -2183,6 +2268,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long block_id)
 				return 0x000003000000010Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000010Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2206,6 +2292,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000010Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000010Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000010Cull;
@@ -2233,6 +2320,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long block_id)
 				return 0x0000030000000110ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000110ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2256,6 +2344,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000110ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000110ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000110ull;
@@ -2283,6 +2372,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long block_id)
 				return 0x0000030000000114ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000114ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2306,6 +2396,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000114ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000114ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000114ull;
@@ -2333,6 +2424,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long block_id)
 				return 0x0000030000000118ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000118ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2356,6 +2448,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000118ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000118ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000118ull;
@@ -2383,6 +2476,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long block_id)
 				return 0x000003000000011Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000011Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2406,6 +2500,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000011Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000011Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000011Cull;
@@ -2433,6 +2528,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long block_id)
 				return 0x0000030000000120ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000120ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2456,6 +2552,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000120ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000120ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000120ull;
@@ -2483,6 +2580,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long block_id)
 				return 0x0000030000000124ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000124ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2506,6 +2604,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000124ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000124ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000124ull;
@@ -2533,6 +2632,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long block_id)
 				return 0x0000030000000128ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000128ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2556,6 +2656,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000128ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000128ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000128ull;
@@ -2565,6 +2666,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG078(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG078(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000138ull + ((block_id) & 3) * 0x100000000ull;
@@ -2577,6 +2679,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG082(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG082(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000148ull + ((block_id) & 3) * 0x100000000ull;
@@ -2589,6 +2692,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG083(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG083(%lu) is invalid on this chip\n", block_id);
 	return 0x000003000000014Cull + ((block_id) & 3) * 0x100000000ull;
@@ -2611,6 +2715,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG084(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG086(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG086(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000158ull + ((block_id) & 3) * 0x100000000ull;
@@ -2622,6 +2727,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG086(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG087(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG087(%lu) is invalid on this chip\n", block_id);
 	return 0x000003000000015Cull + ((block_id) & 3) * 0x100000000ull;
@@ -2633,6 +2739,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG087(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG088(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG088(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000160ull + ((block_id) & 3) * 0x100000000ull;
@@ -2644,6 +2751,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG088(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG089(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG089(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000164ull + ((block_id) & 3) * 0x100000000ull;
@@ -2655,6 +2763,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG089(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG090(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG090(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000168ull + ((block_id) & 3) * 0x100000000ull;
@@ -2666,6 +2775,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG090(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG091(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG091(%lu) is invalid on this chip\n", block_id);
 	return 0x000003000000016Cull + ((block_id) & 3) * 0x100000000ull;
@@ -2677,6 +2787,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG091(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG092(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG092(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000170ull + ((block_id) & 3) * 0x100000000ull;
@@ -2688,6 +2799,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG092(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG094(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG094(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000178ull + ((block_id) & 3) * 0x100000000ull;
@@ -2699,6 +2811,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG094(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG095(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG095(%lu) is invalid on this chip\n", block_id);
 	return 0x000003000000017Cull + ((block_id) & 3) * 0x100000000ull;
@@ -2710,6 +2823,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG095(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG096(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG096(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000180ull + ((block_id) & 3) * 0x100000000ull;
@@ -2721,6 +2835,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG096(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG097(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG097(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000184ull + ((block_id) & 3) * 0x100000000ull;
@@ -2732,6 +2847,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG097(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG098(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG098(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000188ull + ((block_id) & 3) * 0x100000000ull;
@@ -2743,6 +2859,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG098(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG099(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG099(%lu) is invalid on this chip\n", block_id);
 	return 0x000003000000018Cull + ((block_id) & 3) * 0x100000000ull;
@@ -2754,6 +2871,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG099(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG100(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG100(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000190ull + ((block_id) & 3) * 0x100000000ull;
@@ -2765,6 +2883,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG100(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG101(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG101(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000194ull + ((block_id) & 3) * 0x100000000ull;
@@ -2776,6 +2895,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG101(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG102(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG102(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000198ull + ((block_id) & 3) * 0x100000000ull;
@@ -2787,6 +2907,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG102(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG103(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG103(%lu) is invalid on this chip\n", block_id);
 	return 0x000003000000019Cull + ((block_id) & 3) * 0x100000000ull;
@@ -2798,6 +2919,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG103(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG104(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG104(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001A0ull + ((block_id) & 3) * 0x100000000ull;
@@ -2809,6 +2931,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG104(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG105(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG105(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001A4ull + ((block_id) & 3) * 0x100000000ull;
@@ -2820,6 +2943,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG105(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG106(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG106(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001A8ull + ((block_id) & 3) * 0x100000000ull;
@@ -2831,6 +2955,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG106(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG107(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG107(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001ACull + ((block_id) & 3) * 0x100000000ull;
@@ -2842,6 +2967,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG107(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG108(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG108(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001B0ull + ((block_id) & 3) * 0x100000000ull;
@@ -2853,6 +2979,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG108(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG109(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG109(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001B4ull + ((block_id) & 3) * 0x100000000ull;
@@ -2864,6 +2991,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG109(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG110(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG110(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001B8ull + ((block_id) & 3) * 0x100000000ull;
@@ -2875,6 +3003,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG110(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG111(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG111(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001BCull + ((block_id) & 3) * 0x100000000ull;
@@ -2886,6 +3015,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG111(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG112(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG112(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000001C0ull + ((block_id) & 3) * 0x100000000ull;
@@ -2915,6 +3045,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long block_id)
 				return 0x0000030000000700ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000700ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2938,6 +3069,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000700ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000700ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000700ull;
@@ -2965,6 +3097,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long block_id)
 				return 0x0000030000000704ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000704ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2988,6 +3121,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000704ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000704ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000704ull;
@@ -3015,6 +3149,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long block_id)
 				return 0x0000030000000708ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000708ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3038,6 +3173,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000708ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000708ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000708ull;
@@ -3065,6 +3201,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long block_id)
 				return 0x000003000000070Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000070Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3088,6 +3225,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000070Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000070Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000070Cull;
@@ -3115,6 +3253,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long block_id)
 				return 0x0000030000000710ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000710ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3138,6 +3277,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000710ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000710ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000710ull;
@@ -3165,6 +3305,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long block_id)
 				return 0x0000030000000714ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000714ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3188,6 +3329,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000714ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000714ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000714ull;
@@ -3215,6 +3357,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long block_id)
 				return 0x0000030000000718ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000718ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3238,6 +3381,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000718ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000718ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000718ull;
@@ -3265,6 +3409,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long block_id)
 				return 0x000003000000071Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000071Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3288,6 +3433,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000071Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000071Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000071Cull;
@@ -3315,6 +3461,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long block_id)
 				return 0x0000030000000720ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000720ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3338,6 +3485,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000720ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000720ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000720ull;
@@ -3365,6 +3513,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long block_id)
 				return 0x0000030000000728ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000728ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3388,6 +3537,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000728ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000728ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000728ull;
@@ -3415,6 +3565,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long block_id)
 				return 0x000003000000072Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000072Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3438,6 +3589,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000072Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000072Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000072Cull;
@@ -3465,6 +3617,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long block_id)
 				return 0x0000030000000730ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000730ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3488,6 +3641,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000730ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000730ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000730ull;
@@ -3515,6 +3669,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long block_id)
 				return 0x0000030000000734ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000734ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3538,6 +3693,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000734ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000734ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000734ull;
@@ -3565,6 +3721,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long block_id)
 				return 0x0000030000000738ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000738ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3588,6 +3745,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000738ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000738ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000738ull;
@@ -3615,6 +3773,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long block_id)
 				return 0x000003000000073Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000073Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3638,6 +3797,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000073Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000073Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000073Cull;
@@ -3665,6 +3825,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long block_id)
 				return 0x0000030000000740ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000740ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3688,6 +3849,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000740ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000740ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000740ull;
@@ -3715,6 +3877,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long block_id)
 				return 0x0000030000000744ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000744ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3738,6 +3901,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000744ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000744ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000744ull;
@@ -3765,6 +3929,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long block_id)
 				return 0x0000030000000748ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000748ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3788,6 +3953,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000748ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000748ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000748ull;
@@ -3815,6 +3981,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long block_id)
 				return 0x000003000000074Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000074Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3838,6 +4005,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000074Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000074Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000074Cull;
@@ -3865,6 +4033,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long block_id)
 				return 0x0000030000000750ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000750ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3888,6 +4057,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000750ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000750ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000750ull;
@@ -4042,6 +4212,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long block_id)
 				return 0x000003000000080Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000003000000080Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -4062,6 +4233,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000080Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000080Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000080Cull;
@@ -4089,6 +4261,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long block_id)
 				return 0x0000030000000810ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000810ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -4112,6 +4285,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000810ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000810ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000810ull;
@@ -4139,6 +4313,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long block_id)
 				return 0x0000030000000814ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000030000000814ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -4162,6 +4337,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000814ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000814ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000814ull;
@@ -4171,6 +4347,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG548(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG548(%lu) is invalid on this chip\n", block_id);
 	return 0x0000030000000890ull + ((block_id) & 3) * 0x100000000ull;
@@ -4182,6 +4359,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG548(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG554(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG554(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000008A8ull + ((block_id) & 3) * 0x100000000ull;
@@ -4193,6 +4371,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG554(unsigned long block_id)
 static inline uint64_t CVMX_PCIEEPX_CFG558(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG558(%lu) is invalid on this chip\n", block_id);
 	return 0x00000300000008B8ull + ((block_id) & 3) * 0x100000000ull;
@@ -4238,6 +4417,7 @@ union cvmx_pcieepx_cfg000 {
 	struct cvmx_pcieepx_cfg000_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg000_s          cn70xx;
 	struct cvmx_pcieepx_cfg000_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg000_s          cn73xx;
 	struct cvmx_pcieepx_cfg000_s          cn78xx;
 	struct cvmx_pcieepx_cfg000_s          cnf71xx;
 };
@@ -4326,6 +4506,7 @@ union cvmx_pcieepx_cfg001 {
 	struct cvmx_pcieepx_cfg001_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg001_s          cn70xx;
 	struct cvmx_pcieepx_cfg001_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg001_s          cn73xx;
 	struct cvmx_pcieepx_cfg001_s          cn78xx;
 	struct cvmx_pcieepx_cfg001_s          cnf71xx;
 };
@@ -4368,6 +4549,7 @@ union cvmx_pcieepx_cfg002 {
 	struct cvmx_pcieepx_cfg002_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg002_s          cn70xx;
 	struct cvmx_pcieepx_cfg002_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg002_s          cn73xx;
 	struct cvmx_pcieepx_cfg002_s          cn78xx;
 	struct cvmx_pcieepx_cfg002_s          cnf71xx;
 };
@@ -4419,6 +4601,7 @@ union cvmx_pcieepx_cfg003 {
 	struct cvmx_pcieepx_cfg003_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg003_s          cn70xx;
 	struct cvmx_pcieepx_cfg003_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg003_s          cn73xx;
 	struct cvmx_pcieepx_cfg003_s          cn78xx;
 	struct cvmx_pcieepx_cfg003_s          cnf71xx;
 };
@@ -4491,7 +4674,7 @@ union cvmx_pcieepx_cfg004 {
 	struct cvmx_pcieepx_cfg004_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg004_cn52xx     cn70xx;
 	struct cvmx_pcieepx_cfg004_cn52xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg004_cn78xx {
+	struct cvmx_pcieepx_cfg004_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t lbab                         : 17; /**< Lower bits of the BAR 0 base address. */
 	uint32_t reserved_4_14                : 11;
@@ -4514,7 +4697,8 @@ union cvmx_pcieepx_cfg004 {
 	uint32_t reserved_4_14                : 11;
 	uint32_t lbab                         : 17;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg004_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg004_cn52xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg004 cvmx_pcieepx_cfg004_t;
@@ -4554,6 +4738,7 @@ union cvmx_pcieepx_cfg004_mask {
 	struct cvmx_pcieepx_cfg004_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg004_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg004_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg004_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg004_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg004_mask_s     cnf71xx;
 };
@@ -4586,6 +4771,7 @@ union cvmx_pcieepx_cfg005 {
 	struct cvmx_pcieepx_cfg005_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg005_s          cn70xx;
 	struct cvmx_pcieepx_cfg005_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg005_s          cn73xx;
 	struct cvmx_pcieepx_cfg005_s          cn78xx;
 	struct cvmx_pcieepx_cfg005_s          cnf71xx;
 };
@@ -4618,6 +4804,7 @@ union cvmx_pcieepx_cfg005_mask {
 	struct cvmx_pcieepx_cfg005_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg005_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg005_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg005_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg005_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg005_mask_s     cnf71xx;
 };
@@ -4668,6 +4855,7 @@ union cvmx_pcieepx_cfg006 {
 	struct cvmx_pcieepx_cfg006_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg006_s          cn70xx;
 	struct cvmx_pcieepx_cfg006_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg006_s          cn73xx;
 	struct cvmx_pcieepx_cfg006_s          cn78xx;
 	struct cvmx_pcieepx_cfg006_s          cnf71xx;
 };
@@ -4708,6 +4896,7 @@ union cvmx_pcieepx_cfg006_mask {
 	struct cvmx_pcieepx_cfg006_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg006_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg006_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg006_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg006_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg006_mask_s     cnf71xx;
 };
@@ -4740,6 +4929,7 @@ union cvmx_pcieepx_cfg007 {
 	struct cvmx_pcieepx_cfg007_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg007_s          cn70xx;
 	struct cvmx_pcieepx_cfg007_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg007_s          cn73xx;
 	struct cvmx_pcieepx_cfg007_s          cn78xx;
 	struct cvmx_pcieepx_cfg007_s          cnf71xx;
 };
@@ -4772,6 +4962,7 @@ union cvmx_pcieepx_cfg007_mask {
 	struct cvmx_pcieepx_cfg007_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg007_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg007_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg007_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg007_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg007_mask_s     cnf71xx;
 };
@@ -4844,6 +5035,7 @@ union cvmx_pcieepx_cfg008 {
 	struct cvmx_pcieepx_cfg008_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg008_s          cn70xx;
 	struct cvmx_pcieepx_cfg008_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg008_s          cn73xx;
 	struct cvmx_pcieepx_cfg008_s          cn78xx;
 	struct cvmx_pcieepx_cfg008_cn52xx     cnf71xx;
 };
@@ -4884,6 +5076,7 @@ union cvmx_pcieepx_cfg008_mask {
 	struct cvmx_pcieepx_cfg008_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg008_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg008_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg008_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg008_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg008_mask_s     cnf71xx;
 };
@@ -4938,6 +5131,7 @@ union cvmx_pcieepx_cfg009 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg009_cn70xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg009_cn70xx     cn73xx;
 	struct cvmx_pcieepx_cfg009_cn70xx     cn78xx;
 	struct cvmx_pcieepx_cfg009_cn61xx     cnf71xx;
 };
@@ -4970,6 +5164,7 @@ union cvmx_pcieepx_cfg009_mask {
 	struct cvmx_pcieepx_cfg009_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg009_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg009_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg009_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg009_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg009_mask_s     cnf71xx;
 };
@@ -5003,6 +5198,7 @@ union cvmx_pcieepx_cfg010 {
 	struct cvmx_pcieepx_cfg010_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg010_s          cn70xx;
 	struct cvmx_pcieepx_cfg010_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg010_s          cn73xx;
 	struct cvmx_pcieepx_cfg010_s          cn78xx;
 	struct cvmx_pcieepx_cfg010_s          cnf71xx;
 };
@@ -5040,6 +5236,7 @@ union cvmx_pcieepx_cfg011 {
 	struct cvmx_pcieepx_cfg011_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg011_s          cn70xx;
 	struct cvmx_pcieepx_cfg011_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg011_s          cn73xx;
 	struct cvmx_pcieepx_cfg011_s          cn78xx;
 	struct cvmx_pcieepx_cfg011_s          cnf71xx;
 };
@@ -5076,6 +5273,7 @@ union cvmx_pcieepx_cfg012 {
 	struct cvmx_pcieepx_cfg012_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg012_s          cn70xx;
 	struct cvmx_pcieepx_cfg012_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg012_s          cn73xx;
 	struct cvmx_pcieepx_cfg012_s          cn78xx;
 	struct cvmx_pcieepx_cfg012_s          cnf71xx;
 };
@@ -5116,6 +5314,7 @@ union cvmx_pcieepx_cfg012_mask {
 	struct cvmx_pcieepx_cfg012_mask_s     cn68xxp1;
 	struct cvmx_pcieepx_cfg012_mask_s     cn70xx;
 	struct cvmx_pcieepx_cfg012_mask_s     cn70xxp1;
+	struct cvmx_pcieepx_cfg012_mask_s     cn73xx;
 	struct cvmx_pcieepx_cfg012_mask_s     cn78xx;
 	struct cvmx_pcieepx_cfg012_mask_s     cnf71xx;
 };
@@ -5153,6 +5352,7 @@ union cvmx_pcieepx_cfg013 {
 	struct cvmx_pcieepx_cfg013_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg013_s          cn70xx;
 	struct cvmx_pcieepx_cfg013_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg013_s          cn73xx;
 	struct cvmx_pcieepx_cfg013_s          cn78xx;
 	struct cvmx_pcieepx_cfg013_s          cnf71xx;
 };
@@ -5196,6 +5396,7 @@ union cvmx_pcieepx_cfg015 {
 	struct cvmx_pcieepx_cfg015_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg015_s          cn70xx;
 	struct cvmx_pcieepx_cfg015_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg015_s          cn73xx;
 	struct cvmx_pcieepx_cfg015_s          cn78xx;
 	struct cvmx_pcieepx_cfg015_s          cnf71xx;
 };
@@ -5261,6 +5462,7 @@ union cvmx_pcieepx_cfg016 {
 	struct cvmx_pcieepx_cfg016_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg016_s          cn70xx;
 	struct cvmx_pcieepx_cfg016_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg016_s          cn73xx;
 	struct cvmx_pcieepx_cfg016_s          cn78xx;
 	struct cvmx_pcieepx_cfg016_s          cnf71xx;
 };
@@ -5326,6 +5528,7 @@ union cvmx_pcieepx_cfg017 {
 	struct cvmx_pcieepx_cfg017_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg017_s          cn70xx;
 	struct cvmx_pcieepx_cfg017_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg017_s          cn73xx;
 	struct cvmx_pcieepx_cfg017_s          cn78xx;
 	struct cvmx_pcieepx_cfg017_s          cnf71xx;
 };
@@ -5408,6 +5611,7 @@ union cvmx_pcieepx_cfg020 {
 	struct cvmx_pcieepx_cfg020_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg020_s          cn70xx;
 	struct cvmx_pcieepx_cfg020_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg020_s          cn73xx;
 	struct cvmx_pcieepx_cfg020_s          cn78xx;
 	struct cvmx_pcieepx_cfg020_s          cnf71xx;
 };
@@ -5442,6 +5646,7 @@ union cvmx_pcieepx_cfg021 {
 	struct cvmx_pcieepx_cfg021_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg021_s          cn70xx;
 	struct cvmx_pcieepx_cfg021_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg021_s          cn73xx;
 	struct cvmx_pcieepx_cfg021_s          cn78xx;
 	struct cvmx_pcieepx_cfg021_s          cnf71xx;
 };
@@ -5474,6 +5679,7 @@ union cvmx_pcieepx_cfg022 {
 	struct cvmx_pcieepx_cfg022_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg022_s          cn70xx;
 	struct cvmx_pcieepx_cfg022_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg022_s          cn73xx;
 	struct cvmx_pcieepx_cfg022_s          cn78xx;
 	struct cvmx_pcieepx_cfg022_s          cnf71xx;
 };
@@ -5510,6 +5716,7 @@ union cvmx_pcieepx_cfg023 {
 	struct cvmx_pcieepx_cfg023_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg023_s          cn70xx;
 	struct cvmx_pcieepx_cfg023_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg023_s          cn73xx;
 	struct cvmx_pcieepx_cfg023_s          cn78xx;
 	struct cvmx_pcieepx_cfg023_s          cnf71xx;
 };
@@ -5533,6 +5740,7 @@ union cvmx_pcieepx_cfg024 {
 	} s;
 	struct cvmx_pcieepx_cfg024_s          cn70xx;
 	struct cvmx_pcieepx_cfg024_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg024_s          cn73xx;
 	struct cvmx_pcieepx_cfg024_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg024 cvmx_pcieepx_cfg024_t;
@@ -5554,6 +5762,7 @@ union cvmx_pcieepx_cfg025 {
 	} s;
 	struct cvmx_pcieepx_cfg025_s          cn70xx;
 	struct cvmx_pcieepx_cfg025_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg025_s          cn73xx;
 	struct cvmx_pcieepx_cfg025_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg025 cvmx_pcieepx_cfg025_t;
@@ -5605,6 +5814,7 @@ union cvmx_pcieepx_cfg028 {
 	struct cvmx_pcieepx_cfg028_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg028_s          cn70xx;
 	struct cvmx_pcieepx_cfg028_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg028_s          cn73xx;
 	struct cvmx_pcieepx_cfg028_s          cn78xx;
 	struct cvmx_pcieepx_cfg028_s          cnf71xx;
 };
@@ -5754,6 +5964,7 @@ union cvmx_pcieepx_cfg029 {
 	struct cvmx_pcieepx_cfg029_cn66xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg029_cn61xx     cn73xx;
 	struct cvmx_pcieepx_cfg029_cn61xx     cn78xx;
 	struct cvmx_pcieepx_cfg029_cn61xx     cnf71xx;
 };
@@ -5961,6 +6172,7 @@ union cvmx_pcieepx_cfg030 {
 	struct cvmx_pcieepx_cfg030_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg030_s          cn70xx;
 	struct cvmx_pcieepx_cfg030_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg030_s          cn73xx;
 	struct cvmx_pcieepx_cfg030_s          cn78xx;
 	struct cvmx_pcieepx_cfg030_s          cnf71xx;
 };
@@ -6090,6 +6302,7 @@ union cvmx_pcieepx_cfg031 {
 	struct cvmx_pcieepx_cfg031_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg031_s          cn70xx;
 	struct cvmx_pcieepx_cfg031_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg031_s          cn73xx;
 	struct cvmx_pcieepx_cfg031_s          cn78xx;
 	struct cvmx_pcieepx_cfg031_s          cnf71xx;
 };
@@ -6300,6 +6513,7 @@ union cvmx_pcieepx_cfg032 {
 	} cn68xxp1;
 	struct cvmx_pcieepx_cfg032_s          cn70xx;
 	struct cvmx_pcieepx_cfg032_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg032_s          cn73xx;
 	struct cvmx_pcieepx_cfg032_s          cn78xx;
 	struct cvmx_pcieepx_cfg032_s          cnf71xx;
 };
@@ -6546,7 +6760,7 @@ union cvmx_pcieepx_cfg037 {
 	struct cvmx_pcieepx_cfg037_cn61xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg037_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg037_cn61xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg037_cn78xx {
+	struct cvmx_pcieepx_cfg037_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
 	uint32_t meetp                        : 2;  /**< Max end-end TLP prefixes.
@@ -6565,7 +6779,7 @@ union cvmx_pcieepx_cfg037 {
 	uint32_t atom64s                      : 1;  /**< 64-bit AtomicOp supported. */
 	uint32_t atom32s                      : 1;  /**< 32-bit AtomicOp supported. */
 	uint32_t atom_ops                     : 1;  /**< AtomicOp routing supported (not applicable for EP). */
-	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not supported). */
+	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not applicable for EP). */
 	uint32_t ctds                         : 1;  /**< Completion timeout disable supported. */
 	uint32_t ctrs                         : 4;  /**< Completion timeout ranges supported. */
 #else
@@ -6586,7 +6800,8 @@ union cvmx_pcieepx_cfg037 {
 	uint32_t meetp                        : 2;
 	uint32_t reserved_24_31               : 8;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg037_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg037_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_20_31               : 12;
@@ -6727,6 +6942,7 @@ union cvmx_pcieepx_cfg038 {
 	struct cvmx_pcieepx_cfg038_cn61xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg038_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg038_cn61xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg038_s          cn73xx;
 	struct cvmx_pcieepx_cfg038_s          cn78xx;
 	struct cvmx_pcieepx_cfg038_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
@@ -6820,6 +7036,7 @@ union cvmx_pcieepx_cfg039 {
 	struct cvmx_pcieepx_cfg039_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg039_s          cn70xx;
 	struct cvmx_pcieepx_cfg039_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg039_s          cn73xx;
 	struct cvmx_pcieepx_cfg039_s          cn78xx;
 	struct cvmx_pcieepx_cfg039_s          cnf71xx;
 };
@@ -7040,6 +7257,7 @@ union cvmx_pcieepx_cfg040 {
 	struct cvmx_pcieepx_cfg040_cn61xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg040_cn61xx     cn70xx;
 	struct cvmx_pcieepx_cfg040_cn61xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg040_s          cn73xx;
 	struct cvmx_pcieepx_cfg040_s          cn78xx;
 	struct cvmx_pcieepx_cfg040_cn61xx     cnf71xx;
 };
@@ -7122,6 +7340,7 @@ union cvmx_pcieepx_cfg044 {
 	uint32_t msixen                       : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg044_s          cn73xx;
 	struct cvmx_pcieepx_cfg044_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg044 cvmx_pcieepx_cfg044_t;
@@ -7148,6 +7367,7 @@ union cvmx_pcieepx_cfg045 {
 	uint32_t msixtoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg045_s          cn73xx;
 	struct cvmx_pcieepx_cfg045_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg045 cvmx_pcieepx_cfg045_t;
@@ -7174,6 +7394,7 @@ union cvmx_pcieepx_cfg046 {
 	uint32_t msixpoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg046_s          cn73xx;
 	struct cvmx_pcieepx_cfg046_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg046 cvmx_pcieepx_cfg046_t;
@@ -7209,6 +7430,7 @@ union cvmx_pcieepx_cfg064 {
 	struct cvmx_pcieepx_cfg064_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg064_s          cn70xx;
 	struct cvmx_pcieepx_cfg064_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg064_s          cn73xx;
 	struct cvmx_pcieepx_cfg064_s          cn78xx;
 	struct cvmx_pcieepx_cfg064_s          cnf71xx;
 };
@@ -7385,7 +7607,7 @@ union cvmx_pcieepx_cfg065 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg065_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg065_cn78xx {
+	struct cvmx_pcieepx_cfg065_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbes                        : 1;  /**< Unsupported TLP prefix blocked error status. */
@@ -7425,7 +7647,8 @@ union cvmx_pcieepx_cfg065 {
 	uint32_t tpbes                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg065_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg065_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -7639,7 +7862,7 @@ union cvmx_pcieepx_cfg066 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg066_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg066_cn78xx {
+	struct cvmx_pcieepx_cfg066_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbem                        : 1;  /**< Unsupported TLP prefix blocked error mask. */
@@ -7679,7 +7902,8 @@ union cvmx_pcieepx_cfg066 {
 	uint32_t tpbem                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg066_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg066_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -7893,7 +8117,7 @@ union cvmx_pcieepx_cfg067 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg067_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg067_cn78xx {
+	struct cvmx_pcieepx_cfg067_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbes                        : 1;  /**< Unsupported TLP prefix blocked error severity. */
@@ -7933,7 +8157,8 @@ union cvmx_pcieepx_cfg067 {
 	uint32_t tpbes                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg067_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg067_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
@@ -8043,6 +8268,7 @@ union cvmx_pcieepx_cfg068 {
 	struct cvmx_pcieepx_cfg068_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg068_s          cn70xx;
 	struct cvmx_pcieepx_cfg068_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg068_s          cn73xx;
 	struct cvmx_pcieepx_cfg068_s          cn78xx;
 	struct cvmx_pcieepx_cfg068_s          cnf71xx;
 };
@@ -8115,6 +8341,7 @@ union cvmx_pcieepx_cfg069 {
 	struct cvmx_pcieepx_cfg069_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg069_s          cn70xx;
 	struct cvmx_pcieepx_cfg069_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg069_s          cn73xx;
 	struct cvmx_pcieepx_cfg069_s          cn78xx;
 	struct cvmx_pcieepx_cfg069_s          cnf71xx;
 };
@@ -8177,6 +8404,7 @@ union cvmx_pcieepx_cfg070 {
 	struct cvmx_pcieepx_cfg070_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg070_cn52xx     cn70xx;
 	struct cvmx_pcieepx_cfg070_cn52xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg070_s          cn73xx;
 	struct cvmx_pcieepx_cfg070_s          cn78xx;
 	struct cvmx_pcieepx_cfg070_cn52xx     cnf71xx;
 };
@@ -8209,6 +8437,7 @@ union cvmx_pcieepx_cfg071 {
 	struct cvmx_pcieepx_cfg071_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg071_s          cn70xx;
 	struct cvmx_pcieepx_cfg071_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg071_s          cn73xx;
 	struct cvmx_pcieepx_cfg071_s          cn78xx;
 	struct cvmx_pcieepx_cfg071_s          cnf71xx;
 };
@@ -8241,6 +8470,7 @@ union cvmx_pcieepx_cfg072 {
 	struct cvmx_pcieepx_cfg072_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg072_s          cn70xx;
 	struct cvmx_pcieepx_cfg072_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg072_s          cn73xx;
 	struct cvmx_pcieepx_cfg072_s          cn78xx;
 	struct cvmx_pcieepx_cfg072_s          cnf71xx;
 };
@@ -8273,6 +8503,7 @@ union cvmx_pcieepx_cfg073 {
 	struct cvmx_pcieepx_cfg073_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg073_s          cn70xx;
 	struct cvmx_pcieepx_cfg073_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg073_s          cn73xx;
 	struct cvmx_pcieepx_cfg073_s          cn78xx;
 	struct cvmx_pcieepx_cfg073_s          cnf71xx;
 };
@@ -8305,6 +8536,7 @@ union cvmx_pcieepx_cfg074 {
 	struct cvmx_pcieepx_cfg074_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg074_s          cn70xx;
 	struct cvmx_pcieepx_cfg074_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg074_s          cn73xx;
 	struct cvmx_pcieepx_cfg074_s          cn78xx;
 	struct cvmx_pcieepx_cfg074_s          cnf71xx;
 };
@@ -8325,6 +8557,7 @@ union cvmx_pcieepx_cfg078 {
 	uint32_t tlp_pfx_log                  : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg078_s          cn73xx;
 	struct cvmx_pcieepx_cfg078_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg078 cvmx_pcieepx_cfg078_t;
@@ -8360,7 +8593,7 @@ union cvmx_pcieepx_cfg082 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg082_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg082_cn78xx {
+	struct cvmx_pcieepx_cfg082_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t nco                          : 12; /**< Next capability offset. Points to the secondary PCI Express capabilities by default. */
 	uint32_t cv                           : 4;  /**< Capability version. */
@@ -8370,7 +8603,8 @@ union cvmx_pcieepx_cfg082 {
 	uint32_t cv                           : 4;
 	uint32_t nco                          : 12;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg082_cn73xx     cn78xx;
 };
 typedef union cvmx_pcieepx_cfg082 cvmx_pcieepx_cfg082_t;
 
@@ -8410,7 +8644,7 @@ union cvmx_pcieepx_cfg083 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg083_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg083_cn78xx {
+	struct cvmx_pcieepx_cfg083_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_23_31               : 9;
 	uint32_t fg                           : 3;  /**< Function group. */
@@ -8432,7 +8666,8 @@ union cvmx_pcieepx_cfg083 {
 	uint32_t fg                           : 3;
 	uint32_t reserved_23_31               : 9;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg083_cn73xx     cn78xx;
 };
 typedef union cvmx_pcieepx_cfg083 cvmx_pcieepx_cfg083_t;
 
@@ -8485,6 +8720,7 @@ union cvmx_pcieepx_cfg086 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg086_s          cn73xx;
 	struct cvmx_pcieepx_cfg086_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg086 cvmx_pcieepx_cfg086_t;
@@ -8508,6 +8744,7 @@ union cvmx_pcieepx_cfg087 {
 	uint32_t reserved_2_31                : 30;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg087_s          cn73xx;
 	struct cvmx_pcieepx_cfg087_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg087 cvmx_pcieepx_cfg087_t;
@@ -8529,6 +8766,7 @@ union cvmx_pcieepx_cfg088 {
 	uint32_t reserved_8_31                : 24;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg088_s          cn73xx;
 	struct cvmx_pcieepx_cfg088_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg088 cvmx_pcieepx_cfg088_t;
@@ -8564,6 +8802,7 @@ union cvmx_pcieepx_cfg089 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg089_s          cn73xx;
 	struct cvmx_pcieepx_cfg089_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg089 cvmx_pcieepx_cfg089_t;
@@ -8599,6 +8838,7 @@ union cvmx_pcieepx_cfg090 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg090_s          cn73xx;
 	struct cvmx_pcieepx_cfg090_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg090 cvmx_pcieepx_cfg090_t;
@@ -8634,6 +8874,7 @@ union cvmx_pcieepx_cfg091 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg091_s          cn73xx;
 	struct cvmx_pcieepx_cfg091_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg091 cvmx_pcieepx_cfg091_t;
@@ -8669,6 +8910,7 @@ union cvmx_pcieepx_cfg092 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg092_s          cn73xx;
 	struct cvmx_pcieepx_cfg092_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg092 cvmx_pcieepx_cfg092_t;
@@ -8692,6 +8934,7 @@ union cvmx_pcieepx_cfg094 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg094_s          cn73xx;
 	struct cvmx_pcieepx_cfg094_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg094 cvmx_pcieepx_cfg094_t;
@@ -8718,6 +8961,7 @@ union cvmx_pcieepx_cfg095 {
 	uint32_t vfmimn                       : 11;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg095_s          cn73xx;
 	struct cvmx_pcieepx_cfg095_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg095 cvmx_pcieepx_cfg095_t;
@@ -8754,6 +8998,7 @@ union cvmx_pcieepx_cfg096 {
 	uint32_t reserved_17_31               : 15;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg096_s          cn73xx;
 	struct cvmx_pcieepx_cfg096_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg096 cvmx_pcieepx_cfg096_t;
@@ -8775,6 +9020,7 @@ union cvmx_pcieepx_cfg097 {
 	uint32_t tvf                          : 16;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg097_s          cn73xx;
 	struct cvmx_pcieepx_cfg097_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg097 cvmx_pcieepx_cfg097_t;
@@ -8798,6 +9044,7 @@ union cvmx_pcieepx_cfg098 {
 	uint32_t reserved_24_31               : 8;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg098_s          cn73xx;
 	struct cvmx_pcieepx_cfg098_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg098 cvmx_pcieepx_cfg098_t;
@@ -8819,6 +9066,7 @@ union cvmx_pcieepx_cfg099 {
 	uint32_t vfs                          : 16;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg099_s          cn73xx;
 	struct cvmx_pcieepx_cfg099_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg099 cvmx_pcieepx_cfg099_t;
@@ -8840,6 +9088,7 @@ union cvmx_pcieepx_cfg100 {
 	uint32_t vfdev                        : 16;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg100_s          cn73xx;
 	struct cvmx_pcieepx_cfg100_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg100 cvmx_pcieepx_cfg100_t;
@@ -8859,6 +9108,7 @@ union cvmx_pcieepx_cfg101 {
 	uint32_t supps                        : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg101_s          cn73xx;
 	struct cvmx_pcieepx_cfg101_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg101 cvmx_pcieepx_cfg101_t;
@@ -8878,6 +9128,7 @@ union cvmx_pcieepx_cfg102 {
 	uint32_t ps                           : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg102_s          cn73xx;
 	struct cvmx_pcieepx_cfg102_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg102 cvmx_pcieepx_cfg102_t;
@@ -8909,6 +9160,7 @@ union cvmx_pcieepx_cfg103 {
 	uint32_t lbab                         : 17;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg103_s          cn73xx;
 	struct cvmx_pcieepx_cfg103_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg103 cvmx_pcieepx_cfg103_t;
@@ -8928,6 +9180,7 @@ union cvmx_pcieepx_cfg104 {
 	uint32_t ubab                         : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg104_s          cn73xx;
 	struct cvmx_pcieepx_cfg104_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg104 cvmx_pcieepx_cfg104_t;
@@ -8947,6 +9200,7 @@ union cvmx_pcieepx_cfg105 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg105_s          cn73xx;
 	struct cvmx_pcieepx_cfg105_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg105 cvmx_pcieepx_cfg105_t;
@@ -8966,6 +9220,7 @@ union cvmx_pcieepx_cfg106 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg106_s          cn73xx;
 	struct cvmx_pcieepx_cfg106_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg106 cvmx_pcieepx_cfg106_t;
@@ -8985,6 +9240,7 @@ union cvmx_pcieepx_cfg107 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg107_s          cn73xx;
 	struct cvmx_pcieepx_cfg107_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg107 cvmx_pcieepx_cfg107_t;
@@ -9004,6 +9260,7 @@ union cvmx_pcieepx_cfg108 {
 	uint32_t reserved_0_31                : 32;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg108_s          cn73xx;
 	struct cvmx_pcieepx_cfg108_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg108 cvmx_pcieepx_cfg108_t;
@@ -9025,6 +9282,7 @@ union cvmx_pcieepx_cfg109 {
 	uint32_t mso                          : 29;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg109_s          cn73xx;
 	struct cvmx_pcieepx_cfg109_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg109 cvmx_pcieepx_cfg109_t;
@@ -9048,6 +9306,7 @@ union cvmx_pcieepx_cfg110 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg110_s          cn73xx;
 	struct cvmx_pcieepx_cfg110_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg110 cvmx_pcieepx_cfg110_t;
@@ -9074,6 +9333,7 @@ union cvmx_pcieepx_cfg111 {
 	uint32_t reserved_30_31               : 2;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg111_s          cn73xx;
 	struct cvmx_pcieepx_cfg111_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg111 cvmx_pcieepx_cfg111_t;
@@ -9102,6 +9362,7 @@ union cvmx_pcieepx_cfg112 {
 	uint32_t reserved_13_31               : 19;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg112_s          cn73xx;
 	struct cvmx_pcieepx_cfg112_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg112 cvmx_pcieepx_cfg112_t;
@@ -9149,6 +9410,7 @@ union cvmx_pcieepx_cfg448 {
 	struct cvmx_pcieepx_cfg448_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg448_s          cn70xx;
 	struct cvmx_pcieepx_cfg448_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg448_s          cn73xx;
 	struct cvmx_pcieepx_cfg448_s          cn78xx;
 	struct cvmx_pcieepx_cfg448_s          cnf71xx;
 };
@@ -9192,6 +9454,7 @@ union cvmx_pcieepx_cfg449 {
 	struct cvmx_pcieepx_cfg449_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg449_s          cn70xx;
 	struct cvmx_pcieepx_cfg449_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg449_s          cn73xx;
 	struct cvmx_pcieepx_cfg449_s          cn78xx;
 	struct cvmx_pcieepx_cfg449_s          cnf71xx;
 };
@@ -9364,6 +9627,7 @@ union cvmx_pcieepx_cfg450 {
 	struct cvmx_pcieepx_cfg450_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg450_s          cn70xx;
 	struct cvmx_pcieepx_cfg450_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg450_cn52xx     cn73xx;
 	struct cvmx_pcieepx_cfg450_cn52xx     cn78xx;
 	struct cvmx_pcieepx_cfg450_cn52xx     cnf71xx;
 };
@@ -9488,6 +9752,7 @@ union cvmx_pcieepx_cfg451 {
 	struct cvmx_pcieepx_cfg451_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg451_s          cn70xx;
 	struct cvmx_pcieepx_cfg451_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg451_s          cn73xx;
 	struct cvmx_pcieepx_cfg451_s          cn78xx;
 	struct cvmx_pcieepx_cfg451_s          cnf71xx;
 };
@@ -9769,6 +10034,7 @@ union cvmx_pcieepx_cfg452 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg452_cn70xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg452_cn70xx     cn73xx;
 	struct cvmx_pcieepx_cfg452_cn70xx     cn78xx;
 	struct cvmx_pcieepx_cfg452_cn61xx     cnf71xx;
 };
@@ -9817,6 +10083,7 @@ union cvmx_pcieepx_cfg453 {
 	struct cvmx_pcieepx_cfg453_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg453_s          cn70xx;
 	struct cvmx_pcieepx_cfg453_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg453_s          cn73xx;
 	struct cvmx_pcieepx_cfg453_s          cn78xx;
 	struct cvmx_pcieepx_cfg453_s          cnf71xx;
 };
@@ -9939,7 +10206,7 @@ union cvmx_pcieepx_cfg454 {
 #endif
 	} cn70xx;
 	struct cvmx_pcieepx_cfg454_cn70xx     cn70xxp1;
-	struct cvmx_pcieepx_cfg454_cn78xx {
+	struct cvmx_pcieepx_cfg454_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_29_31               : 3;
 	uint32_t tmfcwt                       : 5;  /**< Used to be 'timer modifier for flow control watchdog timer.' This field is no longer used.
@@ -9959,7 +10226,8 @@ union cvmx_pcieepx_cfg454 {
 	uint32_t tmfcwt                       : 5;
 	uint32_t reserved_29_31               : 3;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pcieepx_cfg454_cn73xx     cn78xx;
 	struct cvmx_pcieepx_cfg454_cn61xx     cnf71xx;
 };
 typedef union cvmx_pcieepx_cfg454 cvmx_pcieepx_cfg454_t;
@@ -10028,6 +10296,7 @@ union cvmx_pcieepx_cfg455 {
 	struct cvmx_pcieepx_cfg455_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg455_s          cn70xx;
 	struct cvmx_pcieepx_cfg455_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg455_s          cn73xx;
 	struct cvmx_pcieepx_cfg455_s          cn78xx;
 	struct cvmx_pcieepx_cfg455_s          cnf71xx;
 };
@@ -10078,6 +10347,7 @@ union cvmx_pcieepx_cfg456 {
 	struct cvmx_pcieepx_cfg456_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg456_s          cn70xx;
 	struct cvmx_pcieepx_cfg456_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg456_s          cn73xx;
 	struct cvmx_pcieepx_cfg456_s          cn78xx;
 	struct cvmx_pcieepx_cfg456_s          cnf71xx;
 };
@@ -10110,6 +10380,7 @@ union cvmx_pcieepx_cfg458 {
 	struct cvmx_pcieepx_cfg458_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg458_s          cn70xx;
 	struct cvmx_pcieepx_cfg458_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg458_s          cn73xx;
 	struct cvmx_pcieepx_cfg458_s          cn78xx;
 	struct cvmx_pcieepx_cfg458_s          cnf71xx;
 };
@@ -10142,6 +10413,7 @@ union cvmx_pcieepx_cfg459 {
 	struct cvmx_pcieepx_cfg459_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg459_s          cn70xx;
 	struct cvmx_pcieepx_cfg459_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg459_s          cn73xx;
 	struct cvmx_pcieepx_cfg459_s          cn78xx;
 	struct cvmx_pcieepx_cfg459_s          cnf71xx;
 };
@@ -10182,6 +10454,7 @@ union cvmx_pcieepx_cfg460 {
 	struct cvmx_pcieepx_cfg460_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg460_s          cn70xx;
 	struct cvmx_pcieepx_cfg460_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg460_s          cn73xx;
 	struct cvmx_pcieepx_cfg460_s          cn78xx;
 	struct cvmx_pcieepx_cfg460_s          cnf71xx;
 };
@@ -10222,6 +10495,7 @@ union cvmx_pcieepx_cfg461 {
 	struct cvmx_pcieepx_cfg461_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg461_s          cn70xx;
 	struct cvmx_pcieepx_cfg461_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg461_s          cn73xx;
 	struct cvmx_pcieepx_cfg461_s          cn78xx;
 	struct cvmx_pcieepx_cfg461_s          cnf71xx;
 };
@@ -10262,6 +10536,7 @@ union cvmx_pcieepx_cfg462 {
 	struct cvmx_pcieepx_cfg462_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg462_s          cn70xx;
 	struct cvmx_pcieepx_cfg462_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg462_s          cn73xx;
 	struct cvmx_pcieepx_cfg462_s          cn78xx;
 	struct cvmx_pcieepx_cfg462_s          cnf71xx;
 };
@@ -10334,6 +10609,7 @@ union cvmx_pcieepx_cfg463 {
 	struct cvmx_pcieepx_cfg463_cn52xx     cn68xxp1;
 	struct cvmx_pcieepx_cfg463_cn52xx     cn70xx;
 	struct cvmx_pcieepx_cfg463_cn52xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg463_s          cn73xx;
 	struct cvmx_pcieepx_cfg463_s          cn78xx;
 	struct cvmx_pcieepx_cfg463_cn52xx     cnf71xx;
 };
@@ -10372,6 +10648,7 @@ union cvmx_pcieepx_cfg464 {
 	struct cvmx_pcieepx_cfg464_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg464_s          cn70xx;
 	struct cvmx_pcieepx_cfg464_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg464_s          cn73xx;
 	struct cvmx_pcieepx_cfg464_s          cn78xx;
 	struct cvmx_pcieepx_cfg464_s          cnf71xx;
 };
@@ -10410,6 +10687,7 @@ union cvmx_pcieepx_cfg465 {
 	struct cvmx_pcieepx_cfg465_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg465_s          cn70xx;
 	struct cvmx_pcieepx_cfg465_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg465_s          cn73xx;
 	struct cvmx_pcieepx_cfg465_s          cn78xx;
 	struct cvmx_pcieepx_cfg465_s          cnf71xx;
 };
@@ -10484,6 +10762,7 @@ union cvmx_pcieepx_cfg466 {
 	struct cvmx_pcieepx_cfg466_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg466_s          cn70xx;
 	struct cvmx_pcieepx_cfg466_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg466_s          cn73xx;
 	struct cvmx_pcieepx_cfg466_s          cn78xx;
 	struct cvmx_pcieepx_cfg466_s          cnf71xx;
 };
@@ -10540,6 +10819,7 @@ union cvmx_pcieepx_cfg467 {
 	struct cvmx_pcieepx_cfg467_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg467_s          cn70xx;
 	struct cvmx_pcieepx_cfg467_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg467_s          cn73xx;
 	struct cvmx_pcieepx_cfg467_s          cn78xx;
 	struct cvmx_pcieepx_cfg467_s          cnf71xx;
 };
@@ -10596,6 +10876,7 @@ union cvmx_pcieepx_cfg468 {
 	struct cvmx_pcieepx_cfg468_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg468_s          cn70xx;
 	struct cvmx_pcieepx_cfg468_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg468_s          cn73xx;
 	struct cvmx_pcieepx_cfg468_s          cn78xx;
 	struct cvmx_pcieepx_cfg468_s          cnf71xx;
 };
@@ -10791,6 +11072,7 @@ union cvmx_pcieepx_cfg515 {
 	struct cvmx_pcieepx_cfg515_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg515_s          cn70xx;
 	struct cvmx_pcieepx_cfg515_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg515_s          cn73xx;
 	struct cvmx_pcieepx_cfg515_s          cn78xx;
 	struct cvmx_pcieepx_cfg515_s          cnf71xx;
 };
@@ -10823,6 +11105,7 @@ union cvmx_pcieepx_cfg516 {
 	struct cvmx_pcieepx_cfg516_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg516_s          cn70xx;
 	struct cvmx_pcieepx_cfg516_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg516_s          cn73xx;
 	struct cvmx_pcieepx_cfg516_s          cn78xx;
 	struct cvmx_pcieepx_cfg516_s          cnf71xx;
 };
@@ -10855,6 +11138,7 @@ union cvmx_pcieepx_cfg517 {
 	struct cvmx_pcieepx_cfg517_s          cn68xxp1;
 	struct cvmx_pcieepx_cfg517_s          cn70xx;
 	struct cvmx_pcieepx_cfg517_s          cn70xxp1;
+	struct cvmx_pcieepx_cfg517_s          cn73xx;
 	struct cvmx_pcieepx_cfg517_s          cn78xx;
 	struct cvmx_pcieepx_cfg517_s          cnf71xx;
 };
@@ -10898,6 +11182,7 @@ union cvmx_pcieepx_cfg548 {
 	uint32_t reserved_19_31               : 13;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg548_s          cn73xx;
 	struct cvmx_pcieepx_cfg548_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg548 cvmx_pcieepx_cfg548_t;
@@ -10963,6 +11248,7 @@ union cvmx_pcieepx_cfg554 {
 	uint32_t reserved_25_31               : 7;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg554_s          cn73xx;
 	struct cvmx_pcieepx_cfg554_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg554 cvmx_pcieepx_cfg554_t;
@@ -10984,6 +11270,7 @@ union cvmx_pcieepx_cfg558 {
 	uint32_t ple                          : 1;
 #endif
 	} s;
+	struct cvmx_pcieepx_cfg558_s          cn73xx;
 	struct cvmx_pcieepx_cfg558_s          cn78xx;
 };
 typedef union cvmx_pcieepx_cfg558 cvmx_pcieepx_cfg558_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index 1ef13c1..44a6f27 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -71,6 +71,7 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long block_id)
 				return 0x0000020000000000ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000000ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -93,6 +94,7 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000000ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000000ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000000ull;
@@ -117,6 +119,7 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long block_id)
 				return 0x0000020000000004ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000004ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -139,6 +142,7 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000004ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000004ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000004ull;
@@ -163,6 +167,7 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long block_id)
 				return 0x0000020000000008ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000008ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -185,6 +190,7 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000008ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000008ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000008ull;
@@ -209,6 +215,7 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long block_id)
 				return 0x000002000000000Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000000Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -231,6 +238,7 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000000Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000000Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000000Cull;
@@ -255,6 +263,7 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long block_id)
 				return 0x0000020000000010ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000010ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -277,6 +286,7 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000010ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000010ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000010ull;
@@ -301,6 +311,7 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long block_id)
 				return 0x0000020000000014ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000014ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -323,6 +334,7 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000014ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000014ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000014ull;
@@ -347,6 +359,7 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long block_id)
 				return 0x0000020000000018ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000018ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -369,6 +382,7 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000018ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000018ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000018ull;
@@ -393,6 +407,7 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long block_id)
 				return 0x000002000000001Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000001Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -415,6 +430,7 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000001Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000001Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000001Cull;
@@ -439,6 +455,7 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long block_id)
 				return 0x0000020000000020ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000020ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -461,6 +478,7 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000020ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000020ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000020ull;
@@ -485,6 +503,7 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long block_id)
 				return 0x0000020000000024ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000024ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -507,6 +526,7 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000024ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000024ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000024ull;
@@ -531,6 +551,7 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long block_id)
 				return 0x0000020000000028ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000028ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -553,6 +574,7 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000028ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000028ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000028ull;
@@ -577,6 +599,7 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long block_id)
 				return 0x000002000000002Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000002Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -599,6 +622,7 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000002Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000002Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000002Cull;
@@ -623,6 +647,7 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long block_id)
 				return 0x0000020000000030ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000030ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -645,6 +670,7 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000030ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000030ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000030ull;
@@ -669,6 +695,7 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long block_id)
 				return 0x0000020000000034ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000034ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -691,6 +718,7 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000034ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000034ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000034ull;
@@ -715,6 +743,7 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long block_id)
 				return 0x0000020000000038ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000038ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -737,6 +766,7 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000038ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000038ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000038ull;
@@ -761,6 +791,7 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long block_id)
 				return 0x000002000000003Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000003Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -783,6 +814,7 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000003Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000003Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000003Cull;
@@ -807,6 +839,7 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long block_id)
 				return 0x0000020000000040ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000040ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -829,6 +862,7 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000040ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000040ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000040ull;
@@ -853,6 +887,7 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long block_id)
 				return 0x0000020000000044ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000044ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -875,6 +910,7 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000044ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000044ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000044ull;
@@ -899,6 +935,7 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long block_id)
 				return 0x0000020000000050ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000050ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -921,6 +958,7 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000050ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000050ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000050ull;
@@ -945,6 +983,7 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long block_id)
 				return 0x0000020000000054ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000054ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -967,6 +1006,7 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000054ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000054ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000054ull;
@@ -991,6 +1031,7 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long block_id)
 				return 0x0000020000000058ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000058ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1013,6 +1054,7 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000058ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000058ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000058ull;
@@ -1037,6 +1079,7 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long block_id)
 				return 0x000002000000005Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000005Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1059,6 +1102,7 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000005Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000005Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000005Cull;
@@ -1083,6 +1127,7 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long block_id)
 				return 0x0000020000000070ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000070ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1105,6 +1150,7 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000070ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000070ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000070ull;
@@ -1129,6 +1175,7 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long block_id)
 				return 0x0000020000000074ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000074ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1151,6 +1198,7 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000074ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000074ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000074ull;
@@ -1175,6 +1223,7 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long block_id)
 				return 0x0000020000000078ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000078ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1197,6 +1246,7 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000078ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000078ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000078ull;
@@ -1221,6 +1271,7 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long block_id)
 				return 0x000002000000007Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000007Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1243,6 +1294,7 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000007Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000007Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000007Cull;
@@ -1267,6 +1319,7 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long block_id)
 				return 0x0000020000000080ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000080ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1289,6 +1342,7 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000080ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000080ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000080ull;
@@ -1313,6 +1367,7 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long block_id)
 				return 0x0000020000000084ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000084ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1335,6 +1390,7 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000084ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000084ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000084ull;
@@ -1359,6 +1415,7 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long block_id)
 				return 0x0000020000000088ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000088ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1381,6 +1438,7 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000088ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000088ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000088ull;
@@ -1405,6 +1463,7 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long block_id)
 				return 0x000002000000008Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000008Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1427,6 +1486,7 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000008Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000008Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000008Cull;
@@ -1451,6 +1511,7 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long block_id)
 				return 0x0000020000000090ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000090ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1473,6 +1534,7 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000090ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000090ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000090ull;
@@ -1497,6 +1559,7 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long block_id)
 				return 0x0000020000000094ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000094ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1519,6 +1582,7 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000094ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000094ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000094ull;
@@ -1543,6 +1607,7 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long block_id)
 				return 0x0000020000000098ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000098ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1565,6 +1630,7 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000098ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000098ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000098ull;
@@ -1589,6 +1655,7 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long block_id)
 				return 0x000002000000009Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000009Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1611,6 +1678,7 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000009Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000009Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000009Cull;
@@ -1635,6 +1703,7 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long block_id)
 				return 0x00000200000000A0ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x00000200000000A0ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1657,6 +1726,7 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A0ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A0ull + (block_id) * 0x100000000ull;
 	}
 	return 0x00000000000000A0ull;
@@ -1681,6 +1751,7 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long block_id)
 				return 0x00000200000000A4ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x00000200000000A4ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1703,6 +1774,7 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A4ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A4ull + (block_id) * 0x100000000ull;
 	}
 	return 0x00000000000000A4ull;
@@ -1727,6 +1799,7 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long block_id)
 				return 0x00000200000000A8ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x00000200000000A8ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1749,6 +1822,7 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A8ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A8ull + (block_id) * 0x100000000ull;
 	}
 	return 0x00000000000000A8ull;
@@ -1758,6 +1832,7 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG044(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG044(%lu) is invalid on this chip\n", block_id);
 	return 0x00000200000000B0ull + ((block_id) & 3) * 0x100000000ull;
@@ -1769,6 +1844,7 @@ static inline uint64_t CVMX_PCIERCX_CFG044(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG045(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG045(%lu) is invalid on this chip\n", block_id);
 	return 0x00000200000000B4ull + ((block_id) & 3) * 0x100000000ull;
@@ -1780,6 +1856,7 @@ static inline uint64_t CVMX_PCIERCX_CFG045(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG046(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG046(%lu) is invalid on this chip\n", block_id);
 	return 0x00000200000000B8ull + ((block_id) & 3) * 0x100000000ull;
@@ -1806,6 +1883,7 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long block_id)
 				return 0x0000020000000100ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000100ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1828,6 +1906,7 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000100ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000100ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000100ull;
@@ -1852,6 +1931,7 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long block_id)
 				return 0x0000020000000104ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000104ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1874,6 +1954,7 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000104ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000104ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000104ull;
@@ -1898,6 +1979,7 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long block_id)
 				return 0x0000020000000108ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000108ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1920,6 +2002,7 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000108ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000108ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000108ull;
@@ -1944,6 +2027,7 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long block_id)
 				return 0x000002000000010Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000010Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -1966,6 +2050,7 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000010Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000010Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000010Cull;
@@ -1990,6 +2075,7 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long block_id)
 				return 0x0000020000000110ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000110ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2012,6 +2098,7 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000110ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000110ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000110ull;
@@ -2036,6 +2123,7 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long block_id)
 				return 0x0000020000000114ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000114ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2058,6 +2146,7 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000114ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000114ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000114ull;
@@ -2082,6 +2171,7 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long block_id)
 				return 0x0000020000000118ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000118ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2104,6 +2194,7 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000118ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000118ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000118ull;
@@ -2128,6 +2219,7 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long block_id)
 				return 0x000002000000011Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000011Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2150,6 +2242,7 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000011Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000011Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000011Cull;
@@ -2174,6 +2267,7 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long block_id)
 				return 0x0000020000000120ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000120ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2196,6 +2290,7 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000120ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000120ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000120ull;
@@ -2220,6 +2315,7 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long block_id)
 				return 0x0000020000000124ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000124ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2242,6 +2338,7 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000124ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000124ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000124ull;
@@ -2266,6 +2363,7 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long block_id)
 				return 0x0000020000000128ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000128ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2288,6 +2386,7 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000128ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000128ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000128ull;
@@ -2312,6 +2411,7 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long block_id)
 				return 0x000002000000012Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000012Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2334,6 +2434,7 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000012Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000012Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000012Cull;
@@ -2358,6 +2459,7 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long block_id)
 				return 0x0000020000000130ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000130ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2380,6 +2482,7 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000130ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000130ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000130ull;
@@ -2404,6 +2507,7 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long block_id)
 				return 0x0000020000000134ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000134ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2426,6 +2530,7 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000134ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000134ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000134ull;
@@ -2435,6 +2540,7 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG086(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG086(%lu) is invalid on this chip\n", block_id);
 	return 0x0000020000000158ull + ((block_id) & 3) * 0x100000000ull;
@@ -2446,6 +2552,7 @@ static inline uint64_t CVMX_PCIERCX_CFG086(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG087(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG087(%lu) is invalid on this chip\n", block_id);
 	return 0x000002000000015Cull + ((block_id) & 3) * 0x100000000ull;
@@ -2457,6 +2564,7 @@ static inline uint64_t CVMX_PCIERCX_CFG087(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG088(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG088(%lu) is invalid on this chip\n", block_id);
 	return 0x0000020000000160ull + ((block_id) & 3) * 0x100000000ull;
@@ -2468,6 +2576,7 @@ static inline uint64_t CVMX_PCIERCX_CFG088(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG089(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG089(%lu) is invalid on this chip\n", block_id);
 	return 0x0000020000000164ull + ((block_id) & 3) * 0x100000000ull;
@@ -2479,6 +2588,7 @@ static inline uint64_t CVMX_PCIERCX_CFG089(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG090(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG090(%lu) is invalid on this chip\n", block_id);
 	return 0x0000020000000168ull + ((block_id) & 3) * 0x100000000ull;
@@ -2490,6 +2600,7 @@ static inline uint64_t CVMX_PCIERCX_CFG090(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG091(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG091(%lu) is invalid on this chip\n", block_id);
 	return 0x000002000000016Cull + ((block_id) & 3) * 0x100000000ull;
@@ -2501,6 +2612,7 @@ static inline uint64_t CVMX_PCIERCX_CFG091(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG092(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG092(%lu) is invalid on this chip\n", block_id);
 	return 0x0000020000000170ull + ((block_id) & 3) * 0x100000000ull;
@@ -2527,6 +2639,7 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long block_id)
 				return 0x0000020000000700ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000700ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2549,6 +2662,7 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000700ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000700ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000700ull;
@@ -2573,6 +2687,7 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long block_id)
 				return 0x0000020000000704ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000704ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2595,6 +2710,7 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000704ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000704ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000704ull;
@@ -2619,6 +2735,7 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long block_id)
 				return 0x0000020000000708ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000708ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2641,6 +2758,7 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000708ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000708ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000708ull;
@@ -2665,6 +2783,7 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long block_id)
 				return 0x000002000000070Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000070Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2687,6 +2806,7 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000070Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000070Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000070Cull;
@@ -2711,6 +2831,7 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long block_id)
 				return 0x0000020000000710ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000710ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2733,6 +2854,7 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000710ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000710ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000710ull;
@@ -2757,6 +2879,7 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long block_id)
 				return 0x0000020000000714ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000714ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2779,6 +2902,7 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000714ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000714ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000714ull;
@@ -2803,6 +2927,7 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long block_id)
 				return 0x0000020000000718ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000718ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2825,6 +2950,7 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000718ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000718ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000718ull;
@@ -2849,6 +2975,7 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long block_id)
 				return 0x000002000000071Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000071Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2871,6 +2998,7 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000071Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000071Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000071Cull;
@@ -2895,6 +3023,7 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long block_id)
 				return 0x0000020000000720ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000720ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2917,6 +3046,7 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000720ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000720ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000720ull;
@@ -2941,6 +3071,7 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long block_id)
 				return 0x0000020000000728ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000728ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -2963,6 +3094,7 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000728ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000728ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000728ull;
@@ -2987,6 +3119,7 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long block_id)
 				return 0x000002000000072Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000072Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3009,6 +3142,7 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000072Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000072Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000072Cull;
@@ -3033,6 +3167,7 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long block_id)
 				return 0x0000020000000730ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000730ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3055,6 +3190,7 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000730ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000730ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000730ull;
@@ -3079,6 +3215,7 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long block_id)
 				return 0x0000020000000734ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000734ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3101,6 +3238,7 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000734ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000734ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000734ull;
@@ -3125,6 +3263,7 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long block_id)
 				return 0x0000020000000738ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000738ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3147,6 +3286,7 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000738ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000738ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000738ull;
@@ -3171,6 +3311,7 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long block_id)
 				return 0x000002000000073Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000073Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3193,6 +3334,7 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000073Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000073Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000073Cull;
@@ -3217,6 +3359,7 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long block_id)
 				return 0x0000020000000740ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000740ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3239,6 +3382,7 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000740ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000740ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000740ull;
@@ -3263,6 +3407,7 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long block_id)
 				return 0x0000020000000744ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000744ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3285,6 +3430,7 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000744ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000744ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000744ull;
@@ -3309,6 +3455,7 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long block_id)
 				return 0x0000020000000748ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000748ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3331,6 +3478,7 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000748ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000748ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000748ull;
@@ -3355,6 +3503,7 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long block_id)
 				return 0x000002000000074Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000074Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3377,6 +3526,7 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000074Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000074Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000074Cull;
@@ -3401,6 +3551,7 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long block_id)
 				return 0x0000020000000750ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000750ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3423,6 +3574,7 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000750ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000750ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000750ull;
@@ -3565,6 +3717,7 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long block_id)
 				return 0x000002000000080Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x000002000000080Cull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3585,6 +3738,7 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000080Cull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000080Cull + (block_id) * 0x100000000ull;
 	}
 	return 0x000000000000080Cull;
@@ -3609,6 +3763,7 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long block_id)
 				return 0x0000020000000810ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000810ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3631,6 +3786,7 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000810ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000810ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000810ull;
@@ -3655,6 +3811,7 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long block_id)
 				return 0x0000020000000814ull + ((block_id) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return 0x0000020000000814ull + ((block_id) & 3) * 0x100000000ull;
 			break;
@@ -3677,6 +3834,7 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000814ull + (block_id) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000814ull + (block_id) * 0x100000000ull;
 	}
 	return 0x0000000000000814ull;
@@ -3686,6 +3844,7 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG548(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG548(%lu) is invalid on this chip\n", block_id);
 	return 0x0000020000000890ull + ((block_id) & 3) * 0x100000000ull;
@@ -3697,6 +3856,7 @@ static inline uint64_t CVMX_PCIERCX_CFG548(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG554(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG554(%lu) is invalid on this chip\n", block_id);
 	return 0x00000200000008A8ull + ((block_id) & 3) * 0x100000000ull;
@@ -3708,6 +3868,7 @@ static inline uint64_t CVMX_PCIERCX_CFG554(unsigned long block_id)
 static inline uint64_t CVMX_PCIERCX_CFG558(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PCIERCX_CFG558(%lu) is invalid on this chip\n", block_id);
 	return 0x00000200000008B8ull + ((block_id) & 3) * 0x100000000ull;
@@ -3747,6 +3908,7 @@ union cvmx_pciercx_cfg000 {
 	struct cvmx_pciercx_cfg000_s          cn68xxp1;
 	struct cvmx_pciercx_cfg000_s          cn70xx;
 	struct cvmx_pciercx_cfg000_s          cn70xxp1;
+	struct cvmx_pciercx_cfg000_s          cn73xx;
 	struct cvmx_pciercx_cfg000_s          cn78xx;
 	struct cvmx_pciercx_cfg000_s          cnf71xx;
 };
@@ -3835,6 +3997,7 @@ union cvmx_pciercx_cfg001 {
 	struct cvmx_pciercx_cfg001_s          cn68xxp1;
 	struct cvmx_pciercx_cfg001_s          cn70xx;
 	struct cvmx_pciercx_cfg001_s          cn70xxp1;
+	struct cvmx_pciercx_cfg001_s          cn73xx;
 	struct cvmx_pciercx_cfg001_s          cn78xx;
 	struct cvmx_pciercx_cfg001_s          cnf71xx;
 };
@@ -3877,6 +4040,7 @@ union cvmx_pciercx_cfg002 {
 	struct cvmx_pciercx_cfg002_s          cn68xxp1;
 	struct cvmx_pciercx_cfg002_s          cn70xx;
 	struct cvmx_pciercx_cfg002_s          cn70xxp1;
+	struct cvmx_pciercx_cfg002_s          cn73xx;
 	struct cvmx_pciercx_cfg002_s          cn78xx;
 	struct cvmx_pciercx_cfg002_s          cnf71xx;
 };
@@ -3926,6 +4090,7 @@ union cvmx_pciercx_cfg003 {
 	struct cvmx_pciercx_cfg003_s          cn68xxp1;
 	struct cvmx_pciercx_cfg003_s          cn70xx;
 	struct cvmx_pciercx_cfg003_s          cn70xxp1;
+	struct cvmx_pciercx_cfg003_s          cn73xx;
 	struct cvmx_pciercx_cfg003_s          cn78xx;
 	struct cvmx_pciercx_cfg003_s          cnf71xx;
 };
@@ -3958,6 +4123,7 @@ union cvmx_pciercx_cfg004 {
 	struct cvmx_pciercx_cfg004_s          cn68xxp1;
 	struct cvmx_pciercx_cfg004_s          cn70xx;
 	struct cvmx_pciercx_cfg004_s          cn70xxp1;
+	struct cvmx_pciercx_cfg004_s          cn73xx;
 	struct cvmx_pciercx_cfg004_s          cn78xx;
 	struct cvmx_pciercx_cfg004_s          cnf71xx;
 };
@@ -3990,6 +4156,7 @@ union cvmx_pciercx_cfg005 {
 	struct cvmx_pciercx_cfg005_s          cn68xxp1;
 	struct cvmx_pciercx_cfg005_s          cn70xx;
 	struct cvmx_pciercx_cfg005_s          cn70xxp1;
+	struct cvmx_pciercx_cfg005_s          cn73xx;
 	struct cvmx_pciercx_cfg005_s          cn78xx;
 	struct cvmx_pciercx_cfg005_s          cnf71xx;
 };
@@ -4029,6 +4196,7 @@ union cvmx_pciercx_cfg006 {
 	struct cvmx_pciercx_cfg006_s          cn68xxp1;
 	struct cvmx_pciercx_cfg006_s          cn70xx;
 	struct cvmx_pciercx_cfg006_s          cn70xxp1;
+	struct cvmx_pciercx_cfg006_s          cn73xx;
 	struct cvmx_pciercx_cfg006_s          cn78xx;
 	struct cvmx_pciercx_cfg006_s          cnf71xx;
 };
@@ -4103,6 +4271,7 @@ union cvmx_pciercx_cfg007 {
 	struct cvmx_pciercx_cfg007_s          cn68xxp1;
 	struct cvmx_pciercx_cfg007_s          cn70xx;
 	struct cvmx_pciercx_cfg007_s          cn70xxp1;
+	struct cvmx_pciercx_cfg007_s          cn73xx;
 	struct cvmx_pciercx_cfg007_s          cn78xx;
 	struct cvmx_pciercx_cfg007_s          cnf71xx;
 };
@@ -4141,6 +4310,7 @@ union cvmx_pciercx_cfg008 {
 	struct cvmx_pciercx_cfg008_s          cn68xxp1;
 	struct cvmx_pciercx_cfg008_s          cn70xx;
 	struct cvmx_pciercx_cfg008_s          cn70xxp1;
+	struct cvmx_pciercx_cfg008_s          cn73xx;
 	struct cvmx_pciercx_cfg008_s          cn78xx;
 	struct cvmx_pciercx_cfg008_s          cnf71xx;
 };
@@ -4192,6 +4362,7 @@ union cvmx_pciercx_cfg009 {
 	struct cvmx_pciercx_cfg009_s          cn68xxp1;
 	struct cvmx_pciercx_cfg009_s          cn70xx;
 	struct cvmx_pciercx_cfg009_s          cn70xxp1;
+	struct cvmx_pciercx_cfg009_s          cn73xx;
 	struct cvmx_pciercx_cfg009_s          cn78xx;
 	struct cvmx_pciercx_cfg009_s          cnf71xx;
 };
@@ -4226,6 +4397,7 @@ union cvmx_pciercx_cfg010 {
 	struct cvmx_pciercx_cfg010_s          cn68xxp1;
 	struct cvmx_pciercx_cfg010_s          cn70xx;
 	struct cvmx_pciercx_cfg010_s          cn70xxp1;
+	struct cvmx_pciercx_cfg010_s          cn73xx;
 	struct cvmx_pciercx_cfg010_s          cn78xx;
 	struct cvmx_pciercx_cfg010_s          cnf71xx;
 };
@@ -4260,6 +4432,7 @@ union cvmx_pciercx_cfg011 {
 	struct cvmx_pciercx_cfg011_s          cn68xxp1;
 	struct cvmx_pciercx_cfg011_s          cn70xx;
 	struct cvmx_pciercx_cfg011_s          cn70xxp1;
+	struct cvmx_pciercx_cfg011_s          cn73xx;
 	struct cvmx_pciercx_cfg011_s          cn78xx;
 	struct cvmx_pciercx_cfg011_s          cnf71xx;
 };
@@ -4296,6 +4469,7 @@ union cvmx_pciercx_cfg012 {
 	struct cvmx_pciercx_cfg012_s          cn68xxp1;
 	struct cvmx_pciercx_cfg012_s          cn70xx;
 	struct cvmx_pciercx_cfg012_s          cn70xxp1;
+	struct cvmx_pciercx_cfg012_s          cn73xx;
 	struct cvmx_pciercx_cfg012_s          cn78xx;
 	struct cvmx_pciercx_cfg012_s          cnf71xx;
 };
@@ -4333,6 +4507,7 @@ union cvmx_pciercx_cfg013 {
 	struct cvmx_pciercx_cfg013_s          cn68xxp1;
 	struct cvmx_pciercx_cfg013_s          cn70xx;
 	struct cvmx_pciercx_cfg013_s          cn70xxp1;
+	struct cvmx_pciercx_cfg013_s          cn73xx;
 	struct cvmx_pciercx_cfg013_s          cn78xx;
 	struct cvmx_pciercx_cfg013_s          cnf71xx;
 };
@@ -4365,6 +4540,7 @@ union cvmx_pciercx_cfg014 {
 	struct cvmx_pciercx_cfg014_s          cn68xxp1;
 	struct cvmx_pciercx_cfg014_s          cn70xx;
 	struct cvmx_pciercx_cfg014_s          cn70xxp1;
+	struct cvmx_pciercx_cfg014_s          cn73xx;
 	struct cvmx_pciercx_cfg014_s          cn78xx;
 	struct cvmx_pciercx_cfg014_s          cnf71xx;
 };
@@ -4442,6 +4618,7 @@ union cvmx_pciercx_cfg015 {
 	struct cvmx_pciercx_cfg015_s          cn68xxp1;
 	struct cvmx_pciercx_cfg015_s          cn70xx;
 	struct cvmx_pciercx_cfg015_s          cn70xxp1;
+	struct cvmx_pciercx_cfg015_s          cn73xx;
 	struct cvmx_pciercx_cfg015_s          cn78xx;
 	struct cvmx_pciercx_cfg015_s          cnf71xx;
 };
@@ -4509,6 +4686,7 @@ union cvmx_pciercx_cfg016 {
 	struct cvmx_pciercx_cfg016_s          cn68xxp1;
 	struct cvmx_pciercx_cfg016_s          cn70xx;
 	struct cvmx_pciercx_cfg016_s          cn70xxp1;
+	struct cvmx_pciercx_cfg016_s          cn73xx;
 	struct cvmx_pciercx_cfg016_s          cn78xx;
 	struct cvmx_pciercx_cfg016_s          cnf71xx;
 };
@@ -4574,6 +4752,7 @@ union cvmx_pciercx_cfg017 {
 	struct cvmx_pciercx_cfg017_s          cn68xxp1;
 	struct cvmx_pciercx_cfg017_s          cn70xx;
 	struct cvmx_pciercx_cfg017_s          cn70xxp1;
+	struct cvmx_pciercx_cfg017_s          cn73xx;
 	struct cvmx_pciercx_cfg017_s          cn78xx;
 	struct cvmx_pciercx_cfg017_s          cnf71xx;
 };
@@ -4662,7 +4841,7 @@ union cvmx_pciercx_cfg020 {
 	struct cvmx_pciercx_cfg020_s          cn68xxp1;
 	struct cvmx_pciercx_cfg020_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg020_cn61xx     cn70xxp1;
-	struct cvmx_pciercx_cfg020_cn78xx {
+	struct cvmx_pciercx_cfg020_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_25_31               : 7;
 	uint32_t pvms                         : 1;  /**< Per-vector masking capable. */
@@ -4689,7 +4868,8 @@ union cvmx_pciercx_cfg020 {
 	uint32_t pvms                         : 1;
 	uint32_t reserved_25_31               : 7;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pciercx_cfg020_cn73xx     cn78xx;
 	struct cvmx_pciercx_cfg020_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg020 cvmx_pciercx_cfg020_t;
@@ -4723,6 +4903,7 @@ union cvmx_pciercx_cfg021 {
 	struct cvmx_pciercx_cfg021_s          cn68xxp1;
 	struct cvmx_pciercx_cfg021_s          cn70xx;
 	struct cvmx_pciercx_cfg021_s          cn70xxp1;
+	struct cvmx_pciercx_cfg021_s          cn73xx;
 	struct cvmx_pciercx_cfg021_s          cn78xx;
 	struct cvmx_pciercx_cfg021_s          cnf71xx;
 };
@@ -4755,6 +4936,7 @@ union cvmx_pciercx_cfg022 {
 	struct cvmx_pciercx_cfg022_s          cn68xxp1;
 	struct cvmx_pciercx_cfg022_s          cn70xx;
 	struct cvmx_pciercx_cfg022_s          cn70xxp1;
+	struct cvmx_pciercx_cfg022_s          cn73xx;
 	struct cvmx_pciercx_cfg022_s          cn78xx;
 	struct cvmx_pciercx_cfg022_s          cnf71xx;
 };
@@ -4791,6 +4973,7 @@ union cvmx_pciercx_cfg023 {
 	struct cvmx_pciercx_cfg023_s          cn68xxp1;
 	struct cvmx_pciercx_cfg023_s          cn70xx;
 	struct cvmx_pciercx_cfg023_s          cn70xxp1;
+	struct cvmx_pciercx_cfg023_s          cn73xx;
 	struct cvmx_pciercx_cfg023_s          cn78xx;
 	struct cvmx_pciercx_cfg023_s          cnf71xx;
 };
@@ -4843,6 +5026,7 @@ union cvmx_pciercx_cfg028 {
 	struct cvmx_pciercx_cfg028_s          cn68xxp1;
 	struct cvmx_pciercx_cfg028_s          cn70xx;
 	struct cvmx_pciercx_cfg028_s          cn70xxp1;
+	struct cvmx_pciercx_cfg028_s          cn73xx;
 	struct cvmx_pciercx_cfg028_s          cn78xx;
 	struct cvmx_pciercx_cfg028_s          cnf71xx;
 };
@@ -4908,6 +5092,7 @@ union cvmx_pciercx_cfg029 {
 	struct cvmx_pciercx_cfg029_s          cn68xxp1;
 	struct cvmx_pciercx_cfg029_s          cn70xx;
 	struct cvmx_pciercx_cfg029_s          cn70xxp1;
+	struct cvmx_pciercx_cfg029_s          cn73xx;
 	struct cvmx_pciercx_cfg029_s          cn78xx;
 	struct cvmx_pciercx_cfg029_s          cnf71xx;
 };
@@ -5025,6 +5210,7 @@ union cvmx_pciercx_cfg030 {
 	struct cvmx_pciercx_cfg030_s          cn68xxp1;
 	struct cvmx_pciercx_cfg030_s          cn70xx;
 	struct cvmx_pciercx_cfg030_s          cn70xxp1;
+	struct cvmx_pciercx_cfg030_s          cn73xx;
 	struct cvmx_pciercx_cfg030_s          cn78xx;
 	struct cvmx_pciercx_cfg030_s          cnf71xx;
 };
@@ -5156,6 +5342,7 @@ union cvmx_pciercx_cfg031 {
 	struct cvmx_pciercx_cfg031_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg031_s          cn70xx;
 	struct cvmx_pciercx_cfg031_s          cn70xxp1;
+	struct cvmx_pciercx_cfg031_s          cn73xx;
 	struct cvmx_pciercx_cfg031_s          cn78xx;
 	struct cvmx_pciercx_cfg031_s          cnf71xx;
 };
@@ -5259,6 +5446,7 @@ union cvmx_pciercx_cfg032 {
 	struct cvmx_pciercx_cfg032_s          cn68xxp1;
 	struct cvmx_pciercx_cfg032_s          cn70xx;
 	struct cvmx_pciercx_cfg032_s          cn70xxp1;
+	struct cvmx_pciercx_cfg032_s          cn73xx;
 	struct cvmx_pciercx_cfg032_s          cn78xx;
 	struct cvmx_pciercx_cfg032_s          cnf71xx;
 };
@@ -5323,6 +5511,7 @@ union cvmx_pciercx_cfg033 {
 	struct cvmx_pciercx_cfg033_s          cn68xxp1;
 	struct cvmx_pciercx_cfg033_s          cn70xx;
 	struct cvmx_pciercx_cfg033_s          cn70xxp1;
+	struct cvmx_pciercx_cfg033_s          cn73xx;
 	struct cvmx_pciercx_cfg033_s          cn78xx;
 	struct cvmx_pciercx_cfg033_s          cnf71xx;
 };
@@ -5397,6 +5586,7 @@ union cvmx_pciercx_cfg034 {
 	struct cvmx_pciercx_cfg034_s          cn68xxp1;
 	struct cvmx_pciercx_cfg034_s          cn70xx;
 	struct cvmx_pciercx_cfg034_s          cn70xxp1;
+	struct cvmx_pciercx_cfg034_s          cn73xx;
 	struct cvmx_pciercx_cfg034_s          cn78xx;
 	struct cvmx_pciercx_cfg034_s          cnf71xx;
 };
@@ -5445,6 +5635,7 @@ union cvmx_pciercx_cfg035 {
 	struct cvmx_pciercx_cfg035_s          cn68xxp1;
 	struct cvmx_pciercx_cfg035_s          cn70xx;
 	struct cvmx_pciercx_cfg035_s          cn70xxp1;
+	struct cvmx_pciercx_cfg035_s          cn73xx;
 	struct cvmx_pciercx_cfg035_s          cn78xx;
 	struct cvmx_pciercx_cfg035_s          cnf71xx;
 };
@@ -5483,6 +5674,7 @@ union cvmx_pciercx_cfg036 {
 	struct cvmx_pciercx_cfg036_s          cn68xxp1;
 	struct cvmx_pciercx_cfg036_s          cn70xx;
 	struct cvmx_pciercx_cfg036_s          cn70xxp1;
+	struct cvmx_pciercx_cfg036_s          cn73xx;
 	struct cvmx_pciercx_cfg036_s          cn78xx;
 	struct cvmx_pciercx_cfg036_s          cnf71xx;
 };
@@ -5636,7 +5828,7 @@ union cvmx_pciercx_cfg037 {
 	struct cvmx_pciercx_cfg037_cn66xx     cn68xxp1;
 	struct cvmx_pciercx_cfg037_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg037_cn61xx     cn70xxp1;
-	struct cvmx_pciercx_cfg037_cn78xx {
+	struct cvmx_pciercx_cfg037_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
 	uint32_t meetp                        : 2;  /**< Max end-end TLP prefixes.
@@ -5677,7 +5869,8 @@ union cvmx_pciercx_cfg037 {
 	uint32_t meetp                        : 2;
 	uint32_t reserved_24_31               : 8;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pciercx_cfg037_cn73xx     cn78xx;
 	struct cvmx_pciercx_cfg037_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_20_31               : 12;
@@ -5835,6 +6028,7 @@ union cvmx_pciercx_cfg038 {
 	struct cvmx_pciercx_cfg038_cn61xx     cn68xxp1;
 	struct cvmx_pciercx_cfg038_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg038_cn61xx     cn70xxp1;
+	struct cvmx_pciercx_cfg038_s          cn73xx;
 	struct cvmx_pciercx_cfg038_s          cn78xx;
 	struct cvmx_pciercx_cfg038_cnf71xx {
 #ifdef __BIG_ENDIAN_BITFIELD
@@ -5936,6 +6130,7 @@ union cvmx_pciercx_cfg039 {
 	struct cvmx_pciercx_cfg039_s          cn68xxp1;
 	struct cvmx_pciercx_cfg039_s          cn70xx;
 	struct cvmx_pciercx_cfg039_s          cn70xxp1;
+	struct cvmx_pciercx_cfg039_s          cn73xx;
 	struct cvmx_pciercx_cfg039_s          cn78xx;
 	struct cvmx_pciercx_cfg039_s          cnf71xx;
 };
@@ -6164,6 +6359,7 @@ union cvmx_pciercx_cfg040 {
 	struct cvmx_pciercx_cfg040_cn61xx     cn68xxp1;
 	struct cvmx_pciercx_cfg040_cn61xx     cn70xx;
 	struct cvmx_pciercx_cfg040_cn61xx     cn70xxp1;
+	struct cvmx_pciercx_cfg040_s          cn73xx;
 	struct cvmx_pciercx_cfg040_s          cn78xx;
 	struct cvmx_pciercx_cfg040_cn61xx     cnf71xx;
 };
@@ -6196,6 +6392,7 @@ union cvmx_pciercx_cfg041 {
 	struct cvmx_pciercx_cfg041_s          cn68xxp1;
 	struct cvmx_pciercx_cfg041_s          cn70xx;
 	struct cvmx_pciercx_cfg041_s          cn70xxp1;
+	struct cvmx_pciercx_cfg041_s          cn73xx;
 	struct cvmx_pciercx_cfg041_s          cn78xx;
 	struct cvmx_pciercx_cfg041_s          cnf71xx;
 };
@@ -6228,6 +6425,7 @@ union cvmx_pciercx_cfg042 {
 	struct cvmx_pciercx_cfg042_s          cn68xxp1;
 	struct cvmx_pciercx_cfg042_s          cn70xx;
 	struct cvmx_pciercx_cfg042_s          cn70xxp1;
+	struct cvmx_pciercx_cfg042_s          cn73xx;
 	struct cvmx_pciercx_cfg042_s          cn78xx;
 	struct cvmx_pciercx_cfg042_s          cnf71xx;
 };
@@ -6262,6 +6460,7 @@ union cvmx_pciercx_cfg044 {
 	uint32_t msixen                       : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg044_s          cn73xx;
 	struct cvmx_pciercx_cfg044_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg044 cvmx_pciercx_cfg044_t;
@@ -6287,6 +6486,7 @@ union cvmx_pciercx_cfg045 {
 	uint32_t msixtoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg045_s          cn73xx;
 	struct cvmx_pciercx_cfg045_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg045 cvmx_pciercx_cfg045_t;
@@ -6312,6 +6512,7 @@ union cvmx_pciercx_cfg046 {
 	uint32_t msixpoffs                    : 29;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg046_s          cn73xx;
 	struct cvmx_pciercx_cfg046_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg046 cvmx_pciercx_cfg046_t;
@@ -6347,6 +6548,7 @@ union cvmx_pciercx_cfg064 {
 	struct cvmx_pciercx_cfg064_s          cn68xxp1;
 	struct cvmx_pciercx_cfg064_s          cn70xx;
 	struct cvmx_pciercx_cfg064_s          cn70xxp1;
+	struct cvmx_pciercx_cfg064_s          cn73xx;
 	struct cvmx_pciercx_cfg064_s          cn78xx;
 	struct cvmx_pciercx_cfg064_s          cnf71xx;
 };
@@ -6523,6 +6725,7 @@ union cvmx_pciercx_cfg065 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg065_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg065_s          cn73xx;
 	struct cvmx_pciercx_cfg065_s          cn78xx;
 	struct cvmx_pciercx_cfg065_cn70xx     cnf71xx;
 };
@@ -6699,6 +6902,7 @@ union cvmx_pciercx_cfg066 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg066_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg066_s          cn73xx;
 	struct cvmx_pciercx_cfg066_s          cn78xx;
 	struct cvmx_pciercx_cfg066_cn70xx     cnf71xx;
 };
@@ -6871,7 +7075,7 @@ union cvmx_pciercx_cfg067 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg067_cn70xx     cn70xxp1;
-	struct cvmx_pciercx_cfg067_cn78xx {
+	struct cvmx_pciercx_cfg067_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_26_31               : 6;
 	uint32_t tpbes                        : 1;  /**< Unsupported TLP prefix blocked error severity. */
@@ -6909,7 +7113,8 @@ union cvmx_pciercx_cfg067 {
 	uint32_t tpbes                        : 1;
 	uint32_t reserved_26_31               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pciercx_cfg067_cn73xx     cn78xx;
 	struct cvmx_pciercx_cfg067_cn70xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg067 cvmx_pciercx_cfg067_t;
@@ -6981,6 +7186,7 @@ union cvmx_pciercx_cfg068 {
 	struct cvmx_pciercx_cfg068_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg068_s          cn70xx;
 	struct cvmx_pciercx_cfg068_s          cn70xxp1;
+	struct cvmx_pciercx_cfg068_s          cn73xx;
 	struct cvmx_pciercx_cfg068_s          cn78xx;
 	struct cvmx_pciercx_cfg068_s          cnf71xx;
 };
@@ -7053,6 +7259,7 @@ union cvmx_pciercx_cfg069 {
 	struct cvmx_pciercx_cfg069_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg069_s          cn70xx;
 	struct cvmx_pciercx_cfg069_s          cn70xxp1;
+	struct cvmx_pciercx_cfg069_s          cn73xx;
 	struct cvmx_pciercx_cfg069_s          cn78xx;
 	struct cvmx_pciercx_cfg069_s          cnf71xx;
 };
@@ -7115,6 +7322,7 @@ union cvmx_pciercx_cfg070 {
 	struct cvmx_pciercx_cfg070_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg070_cn52xx     cn70xx;
 	struct cvmx_pciercx_cfg070_cn52xx     cn70xxp1;
+	struct cvmx_pciercx_cfg070_s          cn73xx;
 	struct cvmx_pciercx_cfg070_s          cn78xx;
 	struct cvmx_pciercx_cfg070_cn52xx     cnf71xx;
 };
@@ -7147,6 +7355,7 @@ union cvmx_pciercx_cfg071 {
 	struct cvmx_pciercx_cfg071_s          cn68xxp1;
 	struct cvmx_pciercx_cfg071_s          cn70xx;
 	struct cvmx_pciercx_cfg071_s          cn70xxp1;
+	struct cvmx_pciercx_cfg071_s          cn73xx;
 	struct cvmx_pciercx_cfg071_s          cn78xx;
 	struct cvmx_pciercx_cfg071_s          cnf71xx;
 };
@@ -7179,6 +7388,7 @@ union cvmx_pciercx_cfg072 {
 	struct cvmx_pciercx_cfg072_s          cn68xxp1;
 	struct cvmx_pciercx_cfg072_s          cn70xx;
 	struct cvmx_pciercx_cfg072_s          cn70xxp1;
+	struct cvmx_pciercx_cfg072_s          cn73xx;
 	struct cvmx_pciercx_cfg072_s          cn78xx;
 	struct cvmx_pciercx_cfg072_s          cnf71xx;
 };
@@ -7211,6 +7421,7 @@ union cvmx_pciercx_cfg073 {
 	struct cvmx_pciercx_cfg073_s          cn68xxp1;
 	struct cvmx_pciercx_cfg073_s          cn70xx;
 	struct cvmx_pciercx_cfg073_s          cn70xxp1;
+	struct cvmx_pciercx_cfg073_s          cn73xx;
 	struct cvmx_pciercx_cfg073_s          cn78xx;
 	struct cvmx_pciercx_cfg073_s          cnf71xx;
 };
@@ -7243,6 +7454,7 @@ union cvmx_pciercx_cfg074 {
 	struct cvmx_pciercx_cfg074_s          cn68xxp1;
 	struct cvmx_pciercx_cfg074_s          cn70xx;
 	struct cvmx_pciercx_cfg074_s          cn70xxp1;
+	struct cvmx_pciercx_cfg074_s          cn73xx;
 	struct cvmx_pciercx_cfg074_s          cn78xx;
 	struct cvmx_pciercx_cfg074_s          cnf71xx;
 };
@@ -7281,6 +7493,7 @@ union cvmx_pciercx_cfg075 {
 	struct cvmx_pciercx_cfg075_s          cn68xxp1;
 	struct cvmx_pciercx_cfg075_s          cn70xx;
 	struct cvmx_pciercx_cfg075_s          cn70xxp1;
+	struct cvmx_pciercx_cfg075_s          cn73xx;
 	struct cvmx_pciercx_cfg075_s          cn78xx;
 	struct cvmx_pciercx_cfg075_s          cnf71xx;
 };
@@ -7330,6 +7543,7 @@ union cvmx_pciercx_cfg076 {
 	struct cvmx_pciercx_cfg076_s          cn68xxp1;
 	struct cvmx_pciercx_cfg076_s          cn70xx;
 	struct cvmx_pciercx_cfg076_s          cn70xxp1;
+	struct cvmx_pciercx_cfg076_s          cn73xx;
 	struct cvmx_pciercx_cfg076_s          cn78xx;
 	struct cvmx_pciercx_cfg076_s          cnf71xx;
 };
@@ -7364,6 +7578,7 @@ union cvmx_pciercx_cfg077 {
 	struct cvmx_pciercx_cfg077_s          cn68xxp1;
 	struct cvmx_pciercx_cfg077_s          cn70xx;
 	struct cvmx_pciercx_cfg077_s          cn70xxp1;
+	struct cvmx_pciercx_cfg077_s          cn73xx;
 	struct cvmx_pciercx_cfg077_s          cn78xx;
 	struct cvmx_pciercx_cfg077_s          cnf71xx;
 };
@@ -7388,6 +7603,7 @@ union cvmx_pciercx_cfg086 {
 	uint32_t nco                          : 12;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg086_s          cn73xx;
 	struct cvmx_pciercx_cfg086_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg086 cvmx_pciercx_cfg086_t;
@@ -7411,6 +7627,7 @@ union cvmx_pciercx_cfg087 {
 	uint32_t reserved_2_31                : 30;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg087_s          cn73xx;
 	struct cvmx_pciercx_cfg087_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg087 cvmx_pciercx_cfg087_t;
@@ -7432,6 +7649,7 @@ union cvmx_pciercx_cfg088 {
 	uint32_t reserved_8_31                : 24;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg088_s          cn73xx;
 	struct cvmx_pciercx_cfg088_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg088 cvmx_pciercx_cfg088_t;
@@ -7481,6 +7699,7 @@ union cvmx_pciercx_cfg089 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg089_s          cn73xx;
 	struct cvmx_pciercx_cfg089_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg089 cvmx_pciercx_cfg089_t;
@@ -7530,6 +7749,7 @@ union cvmx_pciercx_cfg090 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg090_s          cn73xx;
 	struct cvmx_pciercx_cfg090_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg090 cvmx_pciercx_cfg090_t;
@@ -7579,6 +7799,7 @@ union cvmx_pciercx_cfg091 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg091_s          cn73xx;
 	struct cvmx_pciercx_cfg091_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg091 cvmx_pciercx_cfg091_t;
@@ -7628,6 +7849,7 @@ union cvmx_pciercx_cfg092 {
 	uint32_t reserved_31_31               : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg092_s          cn73xx;
 	struct cvmx_pciercx_cfg092_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg092 cvmx_pciercx_cfg092_t;
@@ -7675,6 +7897,7 @@ union cvmx_pciercx_cfg448 {
 	struct cvmx_pciercx_cfg448_s          cn68xxp1;
 	struct cvmx_pciercx_cfg448_s          cn70xx;
 	struct cvmx_pciercx_cfg448_s          cn70xxp1;
+	struct cvmx_pciercx_cfg448_s          cn73xx;
 	struct cvmx_pciercx_cfg448_s          cn78xx;
 	struct cvmx_pciercx_cfg448_s          cnf71xx;
 };
@@ -7718,6 +7941,7 @@ union cvmx_pciercx_cfg449 {
 	struct cvmx_pciercx_cfg449_s          cn68xxp1;
 	struct cvmx_pciercx_cfg449_s          cn70xx;
 	struct cvmx_pciercx_cfg449_s          cn70xxp1;
+	struct cvmx_pciercx_cfg449_s          cn73xx;
 	struct cvmx_pciercx_cfg449_s          cn78xx;
 	struct cvmx_pciercx_cfg449_s          cnf71xx;
 };
@@ -7888,6 +8112,7 @@ union cvmx_pciercx_cfg450 {
 	struct cvmx_pciercx_cfg450_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg450_s          cn70xx;
 	struct cvmx_pciercx_cfg450_s          cn70xxp1;
+	struct cvmx_pciercx_cfg450_cn52xx     cn73xx;
 	struct cvmx_pciercx_cfg450_cn52xx     cn78xx;
 	struct cvmx_pciercx_cfg450_cn52xx     cnf71xx;
 };
@@ -8012,6 +8237,7 @@ union cvmx_pciercx_cfg451 {
 	struct cvmx_pciercx_cfg451_s          cn68xxp1;
 	struct cvmx_pciercx_cfg451_s          cn70xx;
 	struct cvmx_pciercx_cfg451_s          cn70xxp1;
+	struct cvmx_pciercx_cfg451_s          cn73xx;
 	struct cvmx_pciercx_cfg451_s          cn78xx;
 	struct cvmx_pciercx_cfg451_s          cnf71xx;
 };
@@ -8285,6 +8511,7 @@ union cvmx_pciercx_cfg452 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg452_cn70xx     cn70xxp1;
+	struct cvmx_pciercx_cfg452_cn70xx     cn73xx;
 	struct cvmx_pciercx_cfg452_cn70xx     cn78xx;
 	struct cvmx_pciercx_cfg452_cn61xx     cnf71xx;
 };
@@ -8333,6 +8560,7 @@ union cvmx_pciercx_cfg453 {
 	struct cvmx_pciercx_cfg453_s          cn68xxp1;
 	struct cvmx_pciercx_cfg453_s          cn70xx;
 	struct cvmx_pciercx_cfg453_s          cn70xxp1;
+	struct cvmx_pciercx_cfg453_s          cn73xx;
 	struct cvmx_pciercx_cfg453_s          cn78xx;
 	struct cvmx_pciercx_cfg453_s          cnf71xx;
 };
@@ -8455,7 +8683,7 @@ union cvmx_pciercx_cfg454 {
 #endif
 	} cn70xx;
 	struct cvmx_pciercx_cfg454_cn70xx     cn70xxp1;
-	struct cvmx_pciercx_cfg454_cn78xx {
+	struct cvmx_pciercx_cfg454_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_29_31               : 3;
 	uint32_t tmfcwt                       : 5;  /**< Used to be 'timer modifier for flow control watchdog timer.' This field is no longer used.
@@ -8475,7 +8703,8 @@ union cvmx_pciercx_cfg454 {
 	uint32_t tmfcwt                       : 5;
 	uint32_t reserved_29_31               : 3;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pciercx_cfg454_cn73xx     cn78xx;
 	struct cvmx_pciercx_cfg454_cn61xx     cnf71xx;
 };
 typedef union cvmx_pciercx_cfg454 cvmx_pciercx_cfg454_t;
@@ -8544,6 +8773,7 @@ union cvmx_pciercx_cfg455 {
 	struct cvmx_pciercx_cfg455_s          cn68xxp1;
 	struct cvmx_pciercx_cfg455_s          cn70xx;
 	struct cvmx_pciercx_cfg455_s          cn70xxp1;
+	struct cvmx_pciercx_cfg455_s          cn73xx;
 	struct cvmx_pciercx_cfg455_s          cn78xx;
 	struct cvmx_pciercx_cfg455_s          cnf71xx;
 };
@@ -8594,6 +8824,7 @@ union cvmx_pciercx_cfg456 {
 	struct cvmx_pciercx_cfg456_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg456_s          cn70xx;
 	struct cvmx_pciercx_cfg456_s          cn70xxp1;
+	struct cvmx_pciercx_cfg456_s          cn73xx;
 	struct cvmx_pciercx_cfg456_s          cn78xx;
 	struct cvmx_pciercx_cfg456_s          cnf71xx;
 };
@@ -8626,6 +8857,7 @@ union cvmx_pciercx_cfg458 {
 	struct cvmx_pciercx_cfg458_s          cn68xxp1;
 	struct cvmx_pciercx_cfg458_s          cn70xx;
 	struct cvmx_pciercx_cfg458_s          cn70xxp1;
+	struct cvmx_pciercx_cfg458_s          cn73xx;
 	struct cvmx_pciercx_cfg458_s          cn78xx;
 	struct cvmx_pciercx_cfg458_s          cnf71xx;
 };
@@ -8658,6 +8890,7 @@ union cvmx_pciercx_cfg459 {
 	struct cvmx_pciercx_cfg459_s          cn68xxp1;
 	struct cvmx_pciercx_cfg459_s          cn70xx;
 	struct cvmx_pciercx_cfg459_s          cn70xxp1;
+	struct cvmx_pciercx_cfg459_s          cn73xx;
 	struct cvmx_pciercx_cfg459_s          cn78xx;
 	struct cvmx_pciercx_cfg459_s          cnf71xx;
 };
@@ -8698,6 +8931,7 @@ union cvmx_pciercx_cfg460 {
 	struct cvmx_pciercx_cfg460_s          cn68xxp1;
 	struct cvmx_pciercx_cfg460_s          cn70xx;
 	struct cvmx_pciercx_cfg460_s          cn70xxp1;
+	struct cvmx_pciercx_cfg460_s          cn73xx;
 	struct cvmx_pciercx_cfg460_s          cn78xx;
 	struct cvmx_pciercx_cfg460_s          cnf71xx;
 };
@@ -8738,6 +8972,7 @@ union cvmx_pciercx_cfg461 {
 	struct cvmx_pciercx_cfg461_s          cn68xxp1;
 	struct cvmx_pciercx_cfg461_s          cn70xx;
 	struct cvmx_pciercx_cfg461_s          cn70xxp1;
+	struct cvmx_pciercx_cfg461_s          cn73xx;
 	struct cvmx_pciercx_cfg461_s          cn78xx;
 	struct cvmx_pciercx_cfg461_s          cnf71xx;
 };
@@ -8778,6 +9013,7 @@ union cvmx_pciercx_cfg462 {
 	struct cvmx_pciercx_cfg462_s          cn68xxp1;
 	struct cvmx_pciercx_cfg462_s          cn70xx;
 	struct cvmx_pciercx_cfg462_s          cn70xxp1;
+	struct cvmx_pciercx_cfg462_s          cn73xx;
 	struct cvmx_pciercx_cfg462_s          cn78xx;
 	struct cvmx_pciercx_cfg462_s          cnf71xx;
 };
@@ -8850,6 +9086,7 @@ union cvmx_pciercx_cfg463 {
 	struct cvmx_pciercx_cfg463_cn52xx     cn68xxp1;
 	struct cvmx_pciercx_cfg463_cn52xx     cn70xx;
 	struct cvmx_pciercx_cfg463_cn52xx     cn70xxp1;
+	struct cvmx_pciercx_cfg463_s          cn73xx;
 	struct cvmx_pciercx_cfg463_s          cn78xx;
 	struct cvmx_pciercx_cfg463_cn52xx     cnf71xx;
 };
@@ -8888,6 +9125,7 @@ union cvmx_pciercx_cfg464 {
 	struct cvmx_pciercx_cfg464_s          cn68xxp1;
 	struct cvmx_pciercx_cfg464_s          cn70xx;
 	struct cvmx_pciercx_cfg464_s          cn70xxp1;
+	struct cvmx_pciercx_cfg464_s          cn73xx;
 	struct cvmx_pciercx_cfg464_s          cn78xx;
 	struct cvmx_pciercx_cfg464_s          cnf71xx;
 };
@@ -8926,6 +9164,7 @@ union cvmx_pciercx_cfg465 {
 	struct cvmx_pciercx_cfg465_s          cn68xxp1;
 	struct cvmx_pciercx_cfg465_s          cn70xx;
 	struct cvmx_pciercx_cfg465_s          cn70xxp1;
+	struct cvmx_pciercx_cfg465_s          cn73xx;
 	struct cvmx_pciercx_cfg465_s          cn78xx;
 	struct cvmx_pciercx_cfg465_s          cnf71xx;
 };
@@ -9000,6 +9239,7 @@ union cvmx_pciercx_cfg466 {
 	struct cvmx_pciercx_cfg466_s          cn68xxp1;
 	struct cvmx_pciercx_cfg466_s          cn70xx;
 	struct cvmx_pciercx_cfg466_s          cn70xxp1;
+	struct cvmx_pciercx_cfg466_s          cn73xx;
 	struct cvmx_pciercx_cfg466_s          cn78xx;
 	struct cvmx_pciercx_cfg466_s          cnf71xx;
 };
@@ -9056,6 +9296,7 @@ union cvmx_pciercx_cfg467 {
 	struct cvmx_pciercx_cfg467_s          cn68xxp1;
 	struct cvmx_pciercx_cfg467_s          cn70xx;
 	struct cvmx_pciercx_cfg467_s          cn70xxp1;
+	struct cvmx_pciercx_cfg467_s          cn73xx;
 	struct cvmx_pciercx_cfg467_s          cn78xx;
 	struct cvmx_pciercx_cfg467_s          cnf71xx;
 };
@@ -9112,6 +9353,7 @@ union cvmx_pciercx_cfg468 {
 	struct cvmx_pciercx_cfg468_s          cn68xxp1;
 	struct cvmx_pciercx_cfg468_s          cn70xx;
 	struct cvmx_pciercx_cfg468_s          cn70xxp1;
+	struct cvmx_pciercx_cfg468_s          cn73xx;
 	struct cvmx_pciercx_cfg468_s          cn78xx;
 	struct cvmx_pciercx_cfg468_s          cnf71xx;
 };
@@ -9307,6 +9549,7 @@ union cvmx_pciercx_cfg515 {
 	struct cvmx_pciercx_cfg515_s          cn68xxp1;
 	struct cvmx_pciercx_cfg515_s          cn70xx;
 	struct cvmx_pciercx_cfg515_s          cn70xxp1;
+	struct cvmx_pciercx_cfg515_s          cn73xx;
 	struct cvmx_pciercx_cfg515_s          cn78xx;
 	struct cvmx_pciercx_cfg515_s          cnf71xx;
 };
@@ -9339,6 +9582,7 @@ union cvmx_pciercx_cfg516 {
 	struct cvmx_pciercx_cfg516_s          cn68xxp1;
 	struct cvmx_pciercx_cfg516_s          cn70xx;
 	struct cvmx_pciercx_cfg516_s          cn70xxp1;
+	struct cvmx_pciercx_cfg516_s          cn73xx;
 	struct cvmx_pciercx_cfg516_s          cn78xx;
 	struct cvmx_pciercx_cfg516_s          cnf71xx;
 };
@@ -9371,6 +9615,7 @@ union cvmx_pciercx_cfg517 {
 	struct cvmx_pciercx_cfg517_s          cn68xxp1;
 	struct cvmx_pciercx_cfg517_s          cn70xx;
 	struct cvmx_pciercx_cfg517_s          cn70xxp1;
+	struct cvmx_pciercx_cfg517_s          cn73xx;
 	struct cvmx_pciercx_cfg517_s          cn78xx;
 	struct cvmx_pciercx_cfg517_s          cnf71xx;
 };
@@ -9414,6 +9659,7 @@ union cvmx_pciercx_cfg548 {
 	uint32_t reserved_19_31               : 13;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg548_s          cn73xx;
 	struct cvmx_pciercx_cfg548_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg548 cvmx_pciercx_cfg548_t;
@@ -9479,6 +9725,7 @@ union cvmx_pciercx_cfg554 {
 	uint32_t reserved_25_31               : 7;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg554_s          cn73xx;
 	struct cvmx_pciercx_cfg554_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg554 cvmx_pciercx_cfg554_t;
@@ -9500,6 +9747,7 @@ union cvmx_pciercx_cfg558 {
 	uint32_t ple                          : 1;
 #endif
 	} s;
+	struct cvmx_pciercx_cfg558_s          cn73xx;
 	struct cvmx_pciercx_cfg558_s          cn78xx;
 };
 typedef union cvmx_pciercx_cfg558 cvmx_pciercx_cfg558_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 92883f8..740be5b 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -69,6 +69,7 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if (((offset <= 15)) && ((block_id <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
@@ -89,6 +90,7 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) + (block_id) * 0x200000ull) * 8;
@@ -110,6 +112,7 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
@@ -129,6 +132,7 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000130ull) + (block_id) * 0x1000000ull;
@@ -151,6 +155,7 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
@@ -171,6 +176,7 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000128ull) + (block_id) * 0x1000000ull;
@@ -193,6 +199,7 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
@@ -213,6 +220,7 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (block_id) * 0x1000000ull;
@@ -259,6 +267,7 @@ static inline uint64_t CVMX_PEMX_CFG(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PEMX_CFG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((block_id) & 3) * 0x1000000ull;
@@ -275,6 +284,7 @@ static inline uint64_t CVMX_PEMX_CFG_RD(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_CFG_RD(%lu) is invalid on this chip\n", block_id);
@@ -292,6 +302,7 @@ static inline uint64_t CVMX_PEMX_CFG_WR(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_CFG_WR(%lu) is invalid on this chip\n", block_id);
@@ -305,6 +316,7 @@ static inline uint64_t CVMX_PEMX_CLK_EN(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PEMX_CLK_EN(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000400ull) + ((block_id) & 3) * 0x1000000ull;
@@ -321,6 +333,7 @@ static inline uint64_t CVMX_PEMX_CPL_LUT_VALID(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_CPL_LUT_VALID(%lu) is invalid on this chip\n", block_id);
@@ -338,6 +351,7 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_CTL_STATUS(%lu) is invalid on this chip\n", block_id);
@@ -350,6 +364,7 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS(unsigned long block_id)
 static inline uint64_t CVMX_PEMX_CTL_STATUS2(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PEMX_CTL_STATUS2(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((block_id) & 3) * 0x1000000ull;
@@ -374,6 +389,7 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
@@ -394,6 +410,7 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + (block_id) * 0x1000000ull;
@@ -424,6 +441,7 @@ static inline uint64_t CVMX_PEMX_DIAG_STATUS(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_DIAG_STATUS(%lu) is invalid on this chip\n", block_id);
@@ -441,6 +459,7 @@ static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
@@ -455,6 +474,7 @@ static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (block_id) * 0x1000000ull;
@@ -469,6 +489,7 @@ static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
@@ -483,6 +504,7 @@ static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (block_id) * 0x1000000ull;
@@ -504,6 +526,7 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
@@ -523,6 +546,7 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000138ull) + (block_id) * 0x1000000ull;
@@ -617,6 +641,7 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long block_id)
 				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((block_id <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((block_id) & 3) * 0x1000000ull;
 			break;
@@ -637,6 +662,7 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long block_id)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (block_id) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (block_id) * 0x1000000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + (block_id) * 0x1000000ull;
@@ -647,6 +673,7 @@ static inline uint64_t CVMX_PEMX_ON(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PEMX_ON(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((block_id) & 3) * 0x1000000ull;
@@ -663,6 +690,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR0_START(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR0_START(%lu) is invalid on this chip\n", block_id);
@@ -680,6 +708,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR1_START(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR1_START(%lu) is invalid on this chip\n", block_id);
@@ -697,6 +726,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR2_START(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR2_START(%lu) is invalid on this chip\n", block_id);
@@ -712,6 +742,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_END(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_END(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000048ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16;
@@ -726,6 +757,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_START(unsigned long offset, unsigned l
 	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_START(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000040ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16;
@@ -737,6 +769,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_START(unsigned long offset, unsigned l
 static inline uint64_t CVMX_PEMX_QLM(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PEMX_QLM(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((block_id) & 3) * 0x1000000ull;
@@ -749,6 +782,7 @@ static inline uint64_t CVMX_PEMX_SPI_CTL(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PEMX_SPI_CTL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000180ull) + ((block_id) & 3) * 0x1000000ull;
@@ -761,6 +795,7 @@ static inline uint64_t CVMX_PEMX_SPI_DATA(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PEMX_SPI_DATA(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000188ull) + ((block_id) & 3) * 0x1000000ull;
@@ -773,6 +808,7 @@ static inline uint64_t CVMX_PEMX_STRAP(unsigned long block_id)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PEMX_STRAP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((block_id) & 3) * 0x1000000ull;
@@ -789,6 +825,7 @@ static inline uint64_t CVMX_PEMX_TLP_CREDITS(unsigned long block_id)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((block_id <= 1)))))
 		cvmx_warn("CVMX_PEMX_TLP_CREDITS(%lu) is invalid on this chip\n", block_id);
@@ -843,6 +880,7 @@ union cvmx_pemx_bar1_indexx {
 	struct cvmx_pemx_bar1_indexx_cn61xx   cn68xxp1;
 	struct cvmx_pemx_bar1_indexx_s        cn70xx;
 	struct cvmx_pemx_bar1_indexx_s        cn70xxp1;
+	struct cvmx_pemx_bar1_indexx_s        cn73xx;
 	struct cvmx_pemx_bar1_indexx_s        cn78xx;
 	struct cvmx_pemx_bar1_indexx_cn61xx   cnf71xx;
 };
@@ -885,6 +923,7 @@ union cvmx_pemx_bar2_mask {
 	struct cvmx_pemx_bar2_mask_cn61xx     cn68xxp1;
 	struct cvmx_pemx_bar2_mask_cn61xx     cn70xx;
 	struct cvmx_pemx_bar2_mask_cn61xx     cn70xxp1;
+	struct cvmx_pemx_bar2_mask_s          cn73xx;
 	struct cvmx_pemx_bar2_mask_s          cn78xx;
 	struct cvmx_pemx_bar2_mask_cn61xx     cnf71xx;
 };
@@ -927,6 +966,7 @@ union cvmx_pemx_bar_ctl {
 	struct cvmx_pemx_bar_ctl_s            cn68xxp1;
 	struct cvmx_pemx_bar_ctl_s            cn70xx;
 	struct cvmx_pemx_bar_ctl_s            cn70xxp1;
+	struct cvmx_pemx_bar_ctl_s            cn73xx;
 	struct cvmx_pemx_bar_ctl_s            cn78xx;
 	struct cvmx_pemx_bar_ctl_s            cnf71xx;
 };
@@ -1015,7 +1055,7 @@ union cvmx_pemx_bist_status {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_bist_status_cn70xx   cn70xxp1;
-	struct cvmx_pemx_bist_status_cn78xx {
+	struct cvmx_pemx_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_26_63               : 38;
 	uint64_t retryc                       : 1;  /**< Retry buffer memory C. */
@@ -1055,7 +1095,8 @@ union cvmx_pemx_bist_status {
 	uint64_t retryc                       : 1;
 	uint64_t reserved_26_63               : 38;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_bist_status_cn73xx   cn78xx;
 	struct cvmx_pemx_bist_status_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_bist_status cvmx_pemx_bist_status_t;
@@ -1219,7 +1260,7 @@ union cvmx_pemx_cfg {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_cfg_cn70xx           cn70xxp1;
-	struct cvmx_pemx_cfg_cn78xx {
+	struct cvmx_pemx_cfg_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t laneswap                     : 1;  /**< This field enables overwriting the value for lane swapping. The reset value is captured on
@@ -1252,7 +1293,8 @@ union cvmx_pemx_cfg {
 	uint64_t laneswap                     : 1;
 	uint64_t reserved_5_63                : 59;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_cfg_cn73xx           cn78xx;
 };
 typedef union cvmx_pemx_cfg cvmx_pemx_cfg_t;
 
@@ -1282,6 +1324,7 @@ union cvmx_pemx_cfg_rd {
 	struct cvmx_pemx_cfg_rd_s             cn68xxp1;
 	struct cvmx_pemx_cfg_rd_s             cn70xx;
 	struct cvmx_pemx_cfg_rd_s             cn70xxp1;
+	struct cvmx_pemx_cfg_rd_s             cn73xx;
 	struct cvmx_pemx_cfg_rd_s             cn78xx;
 	struct cvmx_pemx_cfg_rd_s             cnf71xx;
 };
@@ -1314,6 +1357,7 @@ union cvmx_pemx_cfg_wr {
 	struct cvmx_pemx_cfg_wr_s             cn68xxp1;
 	struct cvmx_pemx_cfg_wr_s             cn70xx;
 	struct cvmx_pemx_cfg_wr_s             cn70xxp1;
+	struct cvmx_pemx_cfg_wr_s             cn73xx;
 	struct cvmx_pemx_cfg_wr_s             cn78xx;
 	struct cvmx_pemx_cfg_wr_s             cnf71xx;
 };
@@ -1340,6 +1384,7 @@ union cvmx_pemx_clk_en {
 	} s;
 	struct cvmx_pemx_clk_en_s             cn70xx;
 	struct cvmx_pemx_clk_en_s             cn70xxp1;
+	struct cvmx_pemx_clk_en_s             cn73xx;
 	struct cvmx_pemx_clk_en_s             cn78xx;
 };
 typedef union cvmx_pemx_clk_en cvmx_pemx_clk_en_t;
@@ -1377,6 +1422,7 @@ union cvmx_pemx_cpl_lut_valid {
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cn68xxp1;
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cn70xx;
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cn70xxp1;
+	struct cvmx_pemx_cpl_lut_valid_s      cn73xx;
 	struct cvmx_pemx_cpl_lut_valid_s      cn78xx;
 	struct cvmx_pemx_cpl_lut_valid_cn61xx cnf71xx;
 };
@@ -1520,7 +1566,7 @@ union cvmx_pemx_ctl_status {
 	struct cvmx_pemx_ctl_status_cn61xx    cn68xxp1;
 	struct cvmx_pemx_ctl_status_s         cn70xx;
 	struct cvmx_pemx_ctl_status_s         cn70xxp1;
-	struct cvmx_pemx_ctl_status_cn78xx {
+	struct cvmx_pemx_ctl_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
 	uint64_t inv_dpar                     : 1;  /**< Invert the generated parity to be written into the most significant data queue buffer RAM
@@ -1571,7 +1617,8 @@ union cvmx_pemx_ctl_status {
 	uint64_t inv_dpar                     : 1;
 	uint64_t reserved_51_63               : 13;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_ctl_status_cn73xx    cn78xx;
 	struct cvmx_pemx_ctl_status_cn61xx    cnf71xx;
 };
 typedef union cvmx_pemx_ctl_status cvmx_pemx_ctl_status_t;
@@ -1598,6 +1645,7 @@ union cvmx_pemx_ctl_status2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pemx_ctl_status2_s        cn73xx;
 	struct cvmx_pemx_ctl_status2_s        cn78xx;
 };
 typedef union cvmx_pemx_ctl_status2 cvmx_pemx_ctl_status2_t;
@@ -2017,7 +2065,7 @@ union cvmx_pemx_dbg_info {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_dbg_info_cn70xx      cn70xxp1;
-	struct cvmx_pemx_dbg_info_cn78xx {
+	struct cvmx_pemx_dbg_info_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
 	uint64_t qhdr_b1_dbe                  : 1;  /**< Detected a core header queue bank1 double bit error. */
@@ -2147,7 +2195,8 @@ union cvmx_pemx_dbg_info {
 	uint64_t qhdr_b1_dbe                  : 1;
 	uint64_t reserved_58_63               : 6;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_dbg_info_cn73xx      cn78xx;
 	struct cvmx_pemx_dbg_info_cn61xx      cnf71xx;
 };
 typedef union cvmx_pemx_dbg_info cvmx_pemx_dbg_info_t;
@@ -2400,6 +2449,7 @@ union cvmx_pemx_diag_status {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_diag_status_cn70xx   cn70xxp1;
+	struct cvmx_pemx_diag_status_s        cn73xx;
 	struct cvmx_pemx_diag_status_s        cn78xx;
 	struct cvmx_pemx_diag_status_cn61xx   cnf71xx;
 };
@@ -2456,7 +2506,7 @@ union cvmx_pemx_ecc_ena {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_ecc_ena_cn70xx       cn70xxp1;
-	struct cvmx_pemx_ecc_ena_cn78xx {
+	struct cvmx_pemx_ecc_ena_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_35_63               : 29;
 	uint64_t qhdr_b1_ena                  : 1;  /**< ECC enable for Core's Q HDR Bank1 RAM. */
@@ -2488,7 +2538,8 @@ union cvmx_pemx_ecc_ena {
 	uint64_t qhdr_b1_ena                  : 1;
 	uint64_t reserved_35_63               : 29;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_ecc_ena_cn73xx       cn78xx;
 };
 typedef union cvmx_pemx_ecc_ena cvmx_pemx_ecc_ena_t;
 
@@ -2543,7 +2594,7 @@ union cvmx_pemx_ecc_synd_ctrl {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_ecc_synd_ctrl_cn70xx cn70xxp1;
-	struct cvmx_pemx_ecc_synd_ctrl_cn78xx {
+	struct cvmx_pemx_ecc_synd_ctrl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_38_63               : 26;
 	uint64_t qhdr_b1_syn                  : 2;  /**< Syndrome flip bits for Core's Q HDR Bank1 RAM. */
@@ -2575,7 +2626,8 @@ union cvmx_pemx_ecc_synd_ctrl {
 	uint64_t qhdr_b1_syn                  : 2;
 	uint64_t reserved_38_63               : 26;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_ecc_synd_ctrl_cn73xx cn78xx;
 };
 typedef union cvmx_pemx_ecc_synd_ctrl cvmx_pemx_ecc_synd_ctrl_t;
 
@@ -2613,6 +2665,7 @@ union cvmx_pemx_inb_read_credits {
 	struct cvmx_pemx_inb_read_credits_cn61xx cn68xx;
 	struct cvmx_pemx_inb_read_credits_cn61xx cn70xx;
 	struct cvmx_pemx_inb_read_credits_cn61xx cn70xxp1;
+	struct cvmx_pemx_inb_read_credits_s   cn73xx;
 	struct cvmx_pemx_inb_read_credits_s   cn78xx;
 	struct cvmx_pemx_inb_read_credits_cn61xx cnf71xx;
 };
@@ -2865,7 +2918,7 @@ union cvmx_pemx_int_sum {
 	struct cvmx_pemx_int_sum_cn61xx       cn68xxp1;
 	struct cvmx_pemx_int_sum_cn61xx       cn70xx;
 	struct cvmx_pemx_int_sum_cn61xx       cn70xxp1;
-	struct cvmx_pemx_int_sum_cn78xx {
+	struct cvmx_pemx_int_sum_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. This is a level-sensitive interrupt. */
 	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. This is a level-sensitive interrupt. */
@@ -2908,7 +2961,8 @@ union cvmx_pemx_int_sum {
 	uint64_t intc                         : 1;
 	uint64_t intd                         : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_int_sum_cn73xx       cn78xx;
 	struct cvmx_pemx_int_sum_cn61xx       cnf71xx;
 };
 typedef union cvmx_pemx_int_sum cvmx_pemx_int_sum_t;
@@ -2936,6 +2990,7 @@ union cvmx_pemx_on {
 	} s;
 	struct cvmx_pemx_on_s                 cn70xx;
 	struct cvmx_pemx_on_s                 cn70xxp1;
+	struct cvmx_pemx_on_s                 cn73xx;
 	struct cvmx_pemx_on_s                 cn78xx;
 };
 typedef union cvmx_pemx_on cvmx_pemx_on_t;
@@ -2950,6 +3005,13 @@ union cvmx_pemx_p2n_bar0_start {
 	uint64_t u64;
 	struct cvmx_pemx_p2n_bar0_start_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} s;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t addr                         : 50; /**< The starting address of the 16KB address space that
                                                          is the BAR0 address space. */
 	uint64_t reserved_0_13                : 14;
@@ -2957,17 +3019,25 @@ union cvmx_pemx_p2n_bar0_start {
 	uint64_t reserved_0_13                : 14;
 	uint64_t addr                         : 50;
 #endif
-	} s;
-	struct cvmx_pemx_p2n_bar0_start_s     cn61xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn63xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn63xxp1;
-	struct cvmx_pemx_p2n_bar0_start_s     cn66xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn68xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn68xxp1;
-	struct cvmx_pemx_p2n_bar0_start_s     cn70xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cn70xxp1;
-	struct cvmx_pemx_p2n_bar0_start_s     cn78xx;
-	struct cvmx_pemx_p2n_bar0_start_s     cnf71xx;
+	} cn61xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn63xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn63xxp1;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn66xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn68xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn68xxp1;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn70xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn70xxp1;
+	struct cvmx_pemx_p2n_bar0_start_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t addr                         : 49; /**< The starting address of the 32KB BAR0 address space. */
+	uint64_t reserved_0_14                : 15;
+#else
+	uint64_t reserved_0_14                : 15;
+	uint64_t addr                         : 49;
+#endif
+	} cn73xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cn78xx;
+	struct cvmx_pemx_p2n_bar0_start_cn61xx cnf71xx;
 };
 typedef union cvmx_pemx_p2n_bar0_start cvmx_pemx_p2n_bar0_start_t;
 
@@ -2997,6 +3067,7 @@ union cvmx_pemx_p2n_bar1_start {
 	struct cvmx_pemx_p2n_bar1_start_s     cn68xxp1;
 	struct cvmx_pemx_p2n_bar1_start_s     cn70xx;
 	struct cvmx_pemx_p2n_bar1_start_s     cn70xxp1;
+	struct cvmx_pemx_p2n_bar1_start_s     cn73xx;
 	struct cvmx_pemx_p2n_bar1_start_s     cn78xx;
 	struct cvmx_pemx_p2n_bar1_start_s     cnf71xx;
 };
@@ -3034,7 +3105,7 @@ union cvmx_pemx_p2n_bar2_start {
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cn68xxp1;
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cn70xx;
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cn70xxp1;
-	struct cvmx_pemx_p2n_bar2_start_cn78xx {
+	struct cvmx_pemx_p2n_bar2_start_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t addr                         : 19; /**< The starting address of the 2^45 BAR2 address space. */
 	uint64_t reserved_0_44                : 45;
@@ -3042,7 +3113,8 @@ union cvmx_pemx_p2n_bar2_start {
 	uint64_t reserved_0_44                : 45;
 	uint64_t addr                         : 19;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_p2n_bar2_start_cn73xx cn78xx;
 	struct cvmx_pemx_p2n_bar2_start_cn61xx cnf71xx;
 };
 typedef union cvmx_pemx_p2n_bar2_start cvmx_pemx_p2n_bar2_start_t;
@@ -3071,6 +3143,7 @@ union cvmx_pemx_p2p_barx_end {
 	struct cvmx_pemx_p2p_barx_end_s       cn66xx;
 	struct cvmx_pemx_p2p_barx_end_s       cn68xx;
 	struct cvmx_pemx_p2p_barx_end_s       cn68xxp1;
+	struct cvmx_pemx_p2p_barx_end_s       cn73xx;
 	struct cvmx_pemx_p2p_barx_end_s       cn78xx;
 };
 typedef union cvmx_pemx_p2p_barx_end cvmx_pemx_p2p_barx_end_t;
@@ -3114,6 +3187,7 @@ union cvmx_pemx_p2p_barx_start {
 	struct cvmx_pemx_p2p_barx_start_cn63xx cn66xx;
 	struct cvmx_pemx_p2p_barx_start_cn63xx cn68xx;
 	struct cvmx_pemx_p2p_barx_start_cn63xx cn68xxp1;
+	struct cvmx_pemx_p2p_barx_start_s     cn73xx;
 	struct cvmx_pemx_p2p_barx_start_s     cn78xx;
 };
 typedef union cvmx_pemx_p2p_barx_start cvmx_pemx_p2p_barx_start_t;
@@ -3139,6 +3213,7 @@ union cvmx_pemx_qlm {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pemx_qlm_s                cn73xx;
 	struct cvmx_pemx_qlm_s                cn78xx;
 };
 typedef union cvmx_pemx_qlm cvmx_pemx_qlm_t;
@@ -3169,6 +3244,7 @@ union cvmx_pemx_spi_ctl {
 	} s;
 	struct cvmx_pemx_spi_ctl_s            cn70xx;
 	struct cvmx_pemx_spi_ctl_s            cn70xxp1;
+	struct cvmx_pemx_spi_ctl_s            cn73xx;
 	struct cvmx_pemx_spi_ctl_s            cn78xx;
 };
 typedef union cvmx_pemx_spi_ctl cvmx_pemx_spi_ctl_t;
@@ -3198,6 +3274,7 @@ union cvmx_pemx_spi_data {
 	} s;
 	struct cvmx_pemx_spi_data_s           cn70xx;
 	struct cvmx_pemx_spi_data_s           cn70xxp1;
+	struct cvmx_pemx_spi_data_s           cn73xx;
 	struct cvmx_pemx_spi_data_s           cn78xx;
 };
 typedef union cvmx_pemx_spi_data cvmx_pemx_spi_data_t;
@@ -3235,7 +3312,7 @@ union cvmx_pemx_strap {
 #endif
 	} cn70xx;
 	struct cvmx_pemx_strap_cn70xx         cn70xxp1;
-	struct cvmx_pemx_strap_cn78xx {
+	struct cvmx_pemx_strap_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t pilaneswap                   : 1;  /**< The value of the pi_select_laneswap pin, which is captured on chip cold reset. It is not
@@ -3256,7 +3333,8 @@ union cvmx_pemx_strap {
 	uint64_t pilaneswap                   : 1;
 	uint64_t reserved_4_63                : 60;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_strap_cn73xx         cn78xx;
 };
 typedef union cvmx_pemx_strap cvmx_pemx_strap_t;
 
@@ -3326,24 +3404,77 @@ union cvmx_pemx_tlp_credits {
 	struct cvmx_pemx_tlp_credits_s        cn68xxp1;
 	struct cvmx_pemx_tlp_credits_cn61xx   cn70xx;
 	struct cvmx_pemx_tlp_credits_cn61xx   cn70xxp1;
-	struct cvmx_pemx_tlp_credits_cn78xx {
+	struct cvmx_pemx_tlp_credits_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t pem_cpl                      : 8;  /**< TLP 16B credits for completion TLPs in the peer. Legal values are 0x12 to 0x40. */
 	uint64_t pem_np                       : 8;  /**< TLP 16B credits for nonposted TLPs in the peer. Legal values are 0x4 to 0x8. */
 	uint64_t pem_p                        : 8;  /**< TLP 16B credits for posted TLPs in the peer. Legal values are 0x12 to 0x40. */
 	uint64_t sli_cpl                      : 8;  /**< TLP 8B credits for completion TLPs in the SLI. Legal values are 0x24 to
-                                                         0x80. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
+                                                         0xFF. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
                                                          SLI interface, while PEM(2) and PEM(3) share the other. When both PEMs of a pair
-                                                         are configured, the sum of both PEMs' SLI_CPL fields must not exceed 0x100. */
+                                                         are configured, the sum of both PEMs' SLI_CPL fields must not exceed 0x100. The
+                                                         reset value for this register assumes the minimum (e.g. 4-lane)
+                                                         configuration. This ensures that for configurations where the total number of
+                                                         lanes for a pair of PEMs exceeds 8, the total allocated credits does not
+                                                         oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0xFF
+                                                            2 4-ln PEMs    n    4             0x80
+                                                                          n+1   4             0x80
+                                                            1 4-ln PEM     n    4             0xFF
+                                                            1 8-ln PEM,    n    8             0xAA
+                                                            1 4-ln PEM    n+1   4             0x55
+                                                         </pre> */
 	uint64_t sli_np                       : 8;  /**< TLP 8B credits for nonposted TLPs in the SLI. Legal values are 0x4 to
                                                          0x20. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
                                                          SLI interface, while PEM(2) and PEM(3) share the other. When both PEMs of a pair
-                                                         are configured, the sum of both PEMs' SLI_NP fields must not exceed 0x20. */
+                                                         are configured, the sum of both PEMs' SLI_NP fields must not exceed 0x20. The
+                                                         reset value for this register assumes the minimum (e.g. 4-lane)
+                                                         configuration. This ensures that for configurations where the total number of
+                                                         lanes for a pair of PEMs exceeds 8, the total allocated credits does not
+                                                         oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0x20
+                                                            2 4-ln PEMs    n    4             0x10
+                                                                          n+1   4             0x10
+                                                            1 4-ln PEM     n    4             0x20
+                                                            1 8-ln PEM,    n    8             0x15
+                                                            1 4-ln PEM    n+1   4             0x0B
+                                                         </pre> */
 	uint64_t sli_p                        : 8;  /**< TLP 8B credits for Posted TLPs in the SLI. Legal values are 0x24 to 0xFF. Pairs
                                                          of PEMs share a single SLI interface. PEM(0) and PEM(1) share one SLI interface,
                                                          while PEM(2) and PEM(3) share the other. When both PEMs of a pair are
-                                                         configured, the sum of both PEMs' SLI_P fields must not exceed 0x100. */
+                                                         configured, the sum of both PEMs' SLI_P fields must not exceed 0x100. The reset
+                                                         value for this register assumes the minimum (e.g. 4-lane) configuration. This
+                                                         ensures that for configurations where the total number of lanes for a pair of
+                                                         PEMs exceeds 8, the total allocated credits does not oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0xFF
+                                                            2 4-ln PEMs    n    4             0x80
+                                                                          n+1   4             0x80
+                                                            1 4-ln PEM     n    4             0xFF
+                                                            1 8-ln PEM,    n    8             0xAA
+                                                            1 4-ln PEM    n+1   4             0x55
+                                                         </pre> */
 #else
 	uint64_t sli_p                        : 8;
 	uint64_t sli_np                       : 8;
@@ -3353,7 +3484,8 @@ union cvmx_pemx_tlp_credits {
 	uint64_t pem_cpl                      : 8;
 	uint64_t reserved_48_63               : 16;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pemx_tlp_credits_cn73xx   cn78xx;
 	struct cvmx_pemx_tlp_credits_cn61xx   cnf71xx;
 };
 typedef union cvmx_pemx_tlp_credits cvmx_pemx_tlp_credits_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
index f0ffd92..50c0f4c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
@@ -1152,7 +1152,7 @@ static inline uint64_t CVMX_PEXP_NPEI_WINDOW_CTL_FUNC(void)
 #define CVMX_PEXP_SLI_BIST_STATUS CVMX_PEXP_SLI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
 }
@@ -1168,6 +1168,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_CTL_PORTX(%lu) is invalid on this chip\n", offset);
@@ -1180,7 +1181,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 #define CVMX_PEXP_SLI_CTL_STATUS CVMX_PEXP_SLI_CTL_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_CTL_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
 }
@@ -1191,7 +1192,7 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 #define CVMX_PEXP_SLI_DATA_OUT_CNT CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_DATA_OUT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
 }
@@ -1229,6 +1230,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_CNT(%lu) is invalid on this chip\n", offset);
@@ -1246,6 +1248,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_INT_LEVEL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n", offset);
@@ -1263,6 +1266,7 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_TIM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_DMAX_TIM(%lu) is invalid on this chip\n", offset);
@@ -1291,6 +1295,7 @@ static inline uint64_t CVMX_PEXP_SLI_INT_ENB_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n", offset);
@@ -1303,7 +1308,7 @@ static inline uint64_t CVMX_PEXP_SLI_INT_ENB_PORTX(unsigned long offset)
 #define CVMX_PEXP_SLI_INT_SUM CVMX_PEXP_SLI_INT_SUM_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010330ull);
 }
@@ -1358,7 +1363,7 @@ static inline uint64_t CVMX_PEXP_SLI_LAST_WIN_RDATA3_FUNC(void)
 #define CVMX_PEXP_SLI_MAC_CREDIT_CNT CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
 }
@@ -1369,7 +1374,7 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 #define CVMX_PEXP_SLI_MAC_CREDIT_CNT2 CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
 }
@@ -1380,7 +1385,7 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 #define CVMX_PEXP_SLI_MEM_ACCESS_CTL CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
 }
@@ -1396,6 +1401,7 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset >= 12) && (offset <= 27)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset >= 12) && (offset <= 27))))))
 		cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n", offset);
@@ -1452,7 +1458,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_ENB3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV0 CVMX_PEXP_SLI_MSI_RCV0_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
 }
@@ -1463,7 +1469,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV1 CVMX_PEXP_SLI_MSI_RCV1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
 }
@@ -1474,7 +1480,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV2 CVMX_PEXP_SLI_MSI_RCV2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
 }
@@ -1485,7 +1491,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV3 CVMX_PEXP_SLI_MSI_RCV3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
 }
@@ -1496,7 +1502,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RD_MAP CVMX_PEXP_SLI_MSI_RD_MAP_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_RD_MAP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
 }
@@ -1595,7 +1601,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_W1S_ENB3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_WR_MAP CVMX_PEXP_SLI_MSI_WR_MAP_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_MSI_WR_MAP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
 }
@@ -1606,7 +1612,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
 }
@@ -1617,7 +1623,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
 }
@@ -1628,7 +1634,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
 }
@@ -1639,7 +1645,7 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
 }
@@ -1655,6 +1661,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_CNTS(%lu) is invalid on this chip\n", offset);
@@ -1672,6 +1679,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n", offset);
@@ -1689,6 +1697,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
@@ -1706,6 +1715,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
@@ -1754,6 +1764,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_OUT_SIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n", offset);
@@ -1771,6 +1782,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n", offset);
@@ -1788,6 +1800,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
@@ -1805,6 +1818,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
@@ -1817,7 +1831,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 #define CVMX_PEXP_SLI_PKT_CNT_INT CVMX_PEXP_SLI_PKT_CNT_INT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_CNT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_CNT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
 }
@@ -1905,7 +1919,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_INPUT_CONTROL_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_INSTR_ENB CVMX_PEXP_SLI_PKT_INSTR_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_INSTR_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_INSTR_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011000ull);
 }
@@ -1965,6 +1979,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n", offset);
@@ -1977,7 +1992,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 #define CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
 }
@@ -2010,7 +2025,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IPTR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUTPUT_WMARK CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
 }
@@ -2032,7 +2047,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BMODE_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011240ull);
 }
@@ -2043,7 +2058,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_ENB CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011010ull);
 }
@@ -2109,7 +2124,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_SLIST_ROR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_TIME_INT CVMX_PEXP_SLI_PKT_TIME_INT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_TIME_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_TIME_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
 }
@@ -2147,6 +2162,7 @@ static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n", offset);
@@ -2159,7 +2175,7 @@ static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 #define CVMX_PEXP_SLI_SCRATCH_1 CVMX_PEXP_SLI_SCRATCH_1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_SCRATCH_1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
 }
@@ -2170,7 +2186,7 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 #define CVMX_PEXP_SLI_SCRATCH_2 CVMX_PEXP_SLI_SCRATCH_2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_SCRATCH_2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
 }
@@ -2181,7 +2197,7 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 #define CVMX_PEXP_SLI_STATE1 CVMX_PEXP_SLI_STATE1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
 }
@@ -2192,7 +2208,7 @@ static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 #define CVMX_PEXP_SLI_STATE2 CVMX_PEXP_SLI_STATE2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
 }
@@ -2203,7 +2219,7 @@ static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 #define CVMX_PEXP_SLI_STATE3 CVMX_PEXP_SLI_STATE3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_STATE3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
 }
@@ -2225,7 +2241,7 @@ static inline uint64_t CVMX_PEXP_SLI_TX_PIPE_FUNC(void)
 #define CVMX_PEXP_SLI_WINDOW_CTL CVMX_PEXP_SLI_WINDOW_CTL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_WINDOW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_WINDOW_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 0a6bc39..5c1826e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_PKI_ACTIVE0 CVMX_PKI_ACTIVE0_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000220ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
 #define CVMX_PKI_ACTIVE1 CVMX_PKI_ACTIVE1_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000230ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
 #define CVMX_PKI_ACTIVE2 CVMX_PKI_ACTIVE2_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000240ull);
 }
@@ -89,6 +89,7 @@ static inline uint64_t CVMX_PKI_ACTIVE2_FUNC(void)
 static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_AURAX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044900000ull) + ((offset) & 1023) * 8;
@@ -100,7 +101,7 @@ static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 #define CVMX_PKI_BIST_STATUS0 CVMX_PKI_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000080ull);
 }
@@ -111,7 +112,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS0_FUNC(void)
 #define CVMX_PKI_BIST_STATUS1 CVMX_PKI_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000088ull);
 }
@@ -122,7 +123,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS1_FUNC(void)
 #define CVMX_PKI_BIST_STATUS2 CVMX_PKI_BIST_STATUS2_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000090ull);
 }
@@ -133,6 +134,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS2_FUNC(void)
 static inline uint64_t CVMX_PKI_BPIDX_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKI_BPIDX_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044B00000ull) + ((offset) & 1023) * 8;
@@ -144,7 +146,7 @@ static inline uint64_t CVMX_PKI_BPIDX_STATE(unsigned long offset)
 #define CVMX_PKI_BUF_CTL CVMX_PKI_BUF_CTL_FUNC()
 static inline uint64_t CVMX_PKI_BUF_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_BUF_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000100ull);
 }
@@ -155,6 +157,7 @@ static inline uint64_t CVMX_PKI_BUF_CTL_FUNC(void)
 static inline uint64_t CVMX_PKI_CHANX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_PKI_CHANX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044A00000ull) + ((offset) & 4095) * 8;
@@ -166,7 +169,7 @@ static inline uint64_t CVMX_PKI_CHANX_CFG(unsigned long offset)
 #define CVMX_PKI_CLKEN CVMX_PKI_CLKEN_FUNC()
 static inline uint64_t CVMX_PKI_CLKEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_CLKEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000410ull);
 }
@@ -177,6 +180,7 @@ static inline uint64_t CVMX_PKI_CLKEN_FUNC(void)
 static inline uint64_t CVMX_PKI_CLX_ECC_CTL(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PKI_CLX_ECC_CTL(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x000118004400C020ull) + ((block_id) & 3) * 0x10000ull;
@@ -188,6 +192,7 @@ static inline uint64_t CVMX_PKI_CLX_ECC_CTL(unsigned long block_id)
 static inline uint64_t CVMX_PKI_CLX_ECC_INT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PKI_CLX_ECC_INT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x000118004400C010ull) + ((block_id) & 3) * 0x10000ull;
@@ -199,6 +204,7 @@ static inline uint64_t CVMX_PKI_CLX_ECC_INT(unsigned long block_id)
 static inline uint64_t CVMX_PKI_CLX_INT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PKI_CLX_INT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x000118004400C000ull) + ((block_id) & 3) * 0x10000ull;
@@ -210,6 +216,7 @@ static inline uint64_t CVMX_PKI_CLX_INT(unsigned long block_id)
 static inline uint64_t CVMX_PKI_CLX_PCAMX_ACTIONX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_ACTIONX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044708000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -221,6 +228,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_ACTIONX(unsigned long a, unsigned long
 static inline uint64_t CVMX_PKI_CLX_PCAMX_MATCHX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_MATCHX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044704000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -232,6 +240,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_MATCHX(unsigned long a, unsigned long
 static inline uint64_t CVMX_PKI_CLX_PCAMX_TERMX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_TERMX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044700000ull) + ((a) << 16) + ((b) << 12) + ((c) << 3);
@@ -243,6 +252,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_TERMX(unsigned long a, unsigned long b
 static inline uint64_t CVMX_PKI_CLX_PKINDX_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300040ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -254,6 +264,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_CFG(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_PKI_CLX_PKINDX_KMEMX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 63)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 63)) && ((c <= 15))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_KMEMX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001180044200000ull) + ((a) << 16) + ((b) << 8) + ((c) << 3);
@@ -265,6 +276,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_KMEMX(unsigned long a, unsigned long
 static inline uint64_t CVMX_PKI_CLX_PKINDX_L2_CUSTOM(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_L2_CUSTOM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300058ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -276,6 +288,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_L2_CUSTOM(unsigned long offset, unsig
 static inline uint64_t CVMX_PKI_CLX_PKINDX_LG_CUSTOM(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_LG_CUSTOM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300060ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -287,6 +300,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_LG_CUSTOM(unsigned long offset, unsig
 static inline uint64_t CVMX_PKI_CLX_PKINDX_SKIP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_SKIP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300050ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -298,6 +312,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_SKIP(unsigned long offset, unsigned l
 static inline uint64_t CVMX_PKI_CLX_PKINDX_STYLE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_STYLE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044300048ull) + (((offset) & 63) + ((block_id) & 3) * 0x100ull) * 256;
@@ -309,6 +324,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_STYLE(unsigned long offset, unsigned
 static inline uint64_t CVMX_PKI_CLX_SMEMX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 2047)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 2047)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_SMEMX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044400000ull) + (((offset) & 2047) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -320,6 +336,7 @@ static inline uint64_t CVMX_PKI_CLX_SMEMX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_PKI_CLX_START(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
 		cvmx_warn("CVMX_PKI_CLX_START(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x000118004400C030ull) + ((block_id) & 3) * 0x10000ull;
@@ -331,6 +348,7 @@ static inline uint64_t CVMX_PKI_CLX_START(unsigned long block_id)
 static inline uint64_t CVMX_PKI_CLX_STYLEX_ALG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_ALG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044501000ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -342,6 +360,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_ALG(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044500000ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -353,6 +372,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_CFG2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180044500800ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8;
@@ -361,10 +381,65 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG2(unsigned long offset, unsigned l
 #define CVMX_PKI_CLX_STYLEX_CFG2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180044500800ull) + (((offset) & 63) + ((block_id) & 3) * 0x2000ull) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT0(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00000ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT0(offset) (CVMX_ADD_IO_SEG(0x0001180044C00000ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT1(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00008ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT1(offset) (CVMX_ADD_IO_SEG(0x0001180044C00008ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT2(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00010ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT2(offset) (CVMX_ADD_IO_SEG(0x0001180044C00010ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT3(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00018ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT3(offset) (CVMX_ADD_IO_SEG(0x0001180044C00018ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_DSTATX_STAT4(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023)))))
+		cvmx_warn("CVMX_PKI_DSTATX_STAT4(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044C00020ull) + ((offset) & 1023) * 64;
+}
+#else
+#define CVMX_PKI_DSTATX_STAT4(offset) (CVMX_ADD_IO_SEG(0x0001180044C00020ull) + ((offset) & 1023) * 64)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKI_ECC_CTL0 CVMX_PKI_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000060ull);
 }
@@ -375,7 +450,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL0_FUNC(void)
 #define CVMX_PKI_ECC_CTL1 CVMX_PKI_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000068ull);
 }
@@ -386,7 +461,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL1_FUNC(void)
 #define CVMX_PKI_ECC_CTL2 CVMX_PKI_ECC_CTL2_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000070ull);
 }
@@ -397,7 +472,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL2_FUNC(void)
 #define CVMX_PKI_ECC_INT0 CVMX_PKI_ECC_INT0_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000040ull);
 }
@@ -408,7 +483,7 @@ static inline uint64_t CVMX_PKI_ECC_INT0_FUNC(void)
 #define CVMX_PKI_ECC_INT1 CVMX_PKI_ECC_INT1_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000048ull);
 }
@@ -419,7 +494,7 @@ static inline uint64_t CVMX_PKI_ECC_INT1_FUNC(void)
 #define CVMX_PKI_ECC_INT2 CVMX_PKI_ECC_INT2_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000050ull);
 }
@@ -430,6 +505,7 @@ static inline uint64_t CVMX_PKI_ECC_INT2_FUNC(void)
 static inline uint64_t CVMX_PKI_FRM_LEN_CHKX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_FRM_LEN_CHKX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044004000ull) + ((offset) & 1) * 8;
@@ -441,7 +517,7 @@ static inline uint64_t CVMX_PKI_FRM_LEN_CHKX(unsigned long offset)
 #define CVMX_PKI_GBL_PEN CVMX_PKI_GBL_PEN_FUNC()
 static inline uint64_t CVMX_PKI_GBL_PEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_GBL_PEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000200ull);
 }
@@ -452,7 +528,7 @@ static inline uint64_t CVMX_PKI_GBL_PEN_FUNC(void)
 #define CVMX_PKI_GEN_INT CVMX_PKI_GEN_INT_FUNC()
 static inline uint64_t CVMX_PKI_GEN_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_GEN_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000020ull);
 }
@@ -463,6 +539,7 @@ static inline uint64_t CVMX_PKI_GEN_INT_FUNC(void)
 static inline uint64_t CVMX_PKI_ICGX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PKI_ICGX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118004400A000ull) + ((offset) & 3) * 8;
@@ -474,6 +551,7 @@ static inline uint64_t CVMX_PKI_ICGX_CFG(unsigned long offset)
 static inline uint64_t CVMX_PKI_IMEMX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_IMEMX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044100000ull) + ((offset) & 2047) * 8;
@@ -485,6 +563,7 @@ static inline uint64_t CVMX_PKI_IMEMX(unsigned long offset)
 static inline uint64_t CVMX_PKI_LTYPEX_MAP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_LTYPEX_MAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044005000ull) + ((offset) & 31) * 8;
@@ -493,10 +572,21 @@ static inline uint64_t CVMX_PKI_LTYPEX_MAP(unsigned long offset)
 #define CVMX_PKI_LTYPEX_MAP(offset) (CVMX_ADD_IO_SEG(0x0001180044005000ull) + ((offset) & 31) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PBE_ECO CVMX_PKI_PBE_ECO_FUNC()
+static inline uint64_t CVMX_PKI_PBE_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKI_PBE_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000710ull);
+}
+#else
+#define CVMX_PKI_PBE_ECO (CVMX_ADD_IO_SEG(0x0001180044000710ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKI_PCAM_LOOKUP CVMX_PKI_PCAM_LOOKUP_FUNC()
 static inline uint64_t CVMX_PKI_PCAM_LOOKUP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PCAM_LOOKUP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000500ull);
 }
@@ -507,7 +597,7 @@ static inline uint64_t CVMX_PKI_PCAM_LOOKUP_FUNC(void)
 #define CVMX_PKI_PCAM_RESULT CVMX_PKI_PCAM_RESULT_FUNC()
 static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PCAM_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000510ull);
 }
@@ -518,7 +608,7 @@ static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 #define CVMX_PKI_PFE_DIAG CVMX_PKI_PFE_DIAG_FUNC()
 static inline uint64_t CVMX_PKI_PFE_DIAG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PFE_DIAG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000560ull);
 }
@@ -526,10 +616,21 @@ static inline uint64_t CVMX_PKI_PFE_DIAG_FUNC(void)
 #define CVMX_PKI_PFE_DIAG (CVMX_ADD_IO_SEG(0x0001180044000560ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PFE_ECO CVMX_PKI_PFE_ECO_FUNC()
+static inline uint64_t CVMX_PKI_PFE_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKI_PFE_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000720ull);
+}
+#else
+#define CVMX_PKI_PFE_ECO (CVMX_ADD_IO_SEG(0x0001180044000720ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKI_PIX_CLKEN CVMX_PKI_PIX_CLKEN_FUNC()
 static inline uint64_t CVMX_PKI_PIX_CLKEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PIX_CLKEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000600ull);
 }
@@ -540,7 +641,7 @@ static inline uint64_t CVMX_PKI_PIX_CLKEN_FUNC(void)
 #define CVMX_PKI_PIX_DIAG CVMX_PKI_PIX_DIAG_FUNC()
 static inline uint64_t CVMX_PKI_PIX_DIAG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PIX_DIAG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000580ull);
 }
@@ -548,9 +649,21 @@ static inline uint64_t CVMX_PKI_PIX_DIAG_FUNC(void)
 #define CVMX_PKI_PIX_DIAG (CVMX_ADD_IO_SEG(0x0001180044000580ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKI_PIX_ECO CVMX_PKI_PIX_ECO_FUNC()
+static inline uint64_t CVMX_PKI_PIX_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKI_PIX_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180044000700ull);
+}
+#else
+#define CVMX_PKI_PIX_ECO (CVMX_ADD_IO_SEG(0x0001180044000700ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_PKINDX_ICGSEL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKINDX_ICGSEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044010000ull) + ((offset) & 63) * 8;
@@ -562,6 +675,7 @@ static inline uint64_t CVMX_PKI_PKINDX_ICGSEL(unsigned long offset)
 static inline uint64_t CVMX_PKI_PKNDX_INB_STAT0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00000ull) + ((offset) & 63) * 256;
@@ -573,6 +687,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT0(unsigned long offset)
 static inline uint64_t CVMX_PKI_PKNDX_INB_STAT1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00008ull) + ((offset) & 63) * 256;
@@ -584,6 +699,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT1(unsigned long offset)
 static inline uint64_t CVMX_PKI_PKNDX_INB_STAT2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044F00010ull) + ((offset) & 63) * 256;
@@ -595,7 +711,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT2(unsigned long offset)
 #define CVMX_PKI_PKT_ERR CVMX_PKI_PKT_ERR_FUNC()
 static inline uint64_t CVMX_PKI_PKT_ERR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_PKT_ERR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000030ull);
 }
@@ -603,9 +719,21 @@ static inline uint64_t CVMX_PKI_PKT_ERR_FUNC(void)
 #define CVMX_PKI_PKT_ERR (CVMX_ADD_IO_SEG(0x0001180044000030ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKI_QPG_TBLBX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047)))))
+		cvmx_warn("CVMX_PKI_QPG_TBLBX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180044820000ull) + ((offset) & 2047) * 8;
+}
+#else
+#define CVMX_PKI_QPG_TBLBX(offset) (CVMX_ADD_IO_SEG(0x0001180044820000ull) + ((offset) & 2047) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_QPG_TBLX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_QPG_TBLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044800000ull) + ((offset) & 2047) * 8;
@@ -617,6 +745,7 @@ static inline uint64_t CVMX_PKI_QPG_TBLX(unsigned long offset)
 static inline uint64_t CVMX_PKI_REASM_SOPX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_REASM_SOPX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044006000ull) + ((offset) & 1) * 8;
@@ -628,7 +757,7 @@ static inline uint64_t CVMX_PKI_REASM_SOPX(unsigned long offset)
 #define CVMX_PKI_REQ_WGT CVMX_PKI_REQ_WGT_FUNC()
 static inline uint64_t CVMX_PKI_REQ_WGT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_REQ_WGT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000120ull);
 }
@@ -639,7 +768,7 @@ static inline uint64_t CVMX_PKI_REQ_WGT_FUNC(void)
 #define CVMX_PKI_SFT_RST CVMX_PKI_SFT_RST_FUNC()
 static inline uint64_t CVMX_PKI_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000010ull);
 }
@@ -650,6 +779,7 @@ static inline uint64_t CVMX_PKI_SFT_RST_FUNC(void)
 static inline uint64_t CVMX_PKI_STATX_HIST0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00000ull) + ((offset) & 63) * 256;
@@ -661,6 +791,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST0(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00008ull) + ((offset) & 63) * 256;
@@ -672,6 +803,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST1(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00010ull) + ((offset) & 63) * 256;
@@ -683,6 +815,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST2(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00018ull) + ((offset) & 63) * 256;
@@ -694,6 +827,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST3(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00020ull) + ((offset) & 63) * 256;
@@ -705,6 +839,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST4(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST5(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00028ull) + ((offset) & 63) * 256;
@@ -716,6 +851,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST5(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_HIST6(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00030ull) + ((offset) & 63) * 256;
@@ -727,6 +863,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST6(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00038ull) + ((offset) & 63) * 256;
@@ -738,6 +875,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT0(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00040ull) + ((offset) & 63) * 256;
@@ -749,6 +887,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT1(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT10(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT10(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00088ull) + ((offset) & 63) * 256;
@@ -760,6 +899,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT10(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT11(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT11(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00090ull) + ((offset) & 63) * 256;
@@ -771,6 +911,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT11(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT12(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT12(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00098ull) + ((offset) & 63) * 256;
@@ -782,6 +923,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT12(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT13(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT13(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000A0ull) + ((offset) & 63) * 256;
@@ -793,6 +935,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT13(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT14(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT14(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000A8ull) + ((offset) & 63) * 256;
@@ -804,6 +947,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT14(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT15(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT15(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000B0ull) + ((offset) & 63) * 256;
@@ -815,6 +959,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT15(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT16(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT16(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000B8ull) + ((offset) & 63) * 256;
@@ -826,6 +971,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT16(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT17(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT17(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000C0ull) + ((offset) & 63) * 256;
@@ -837,6 +983,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT17(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT18(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT18(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E000C8ull) + ((offset) & 63) * 256;
@@ -848,6 +995,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT18(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00048ull) + ((offset) & 63) * 256;
@@ -859,6 +1007,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT2(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00050ull) + ((offset) & 63) * 256;
@@ -870,6 +1019,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT3(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00058ull) + ((offset) & 63) * 256;
@@ -881,6 +1031,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT4(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT5(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00060ull) + ((offset) & 63) * 256;
@@ -892,6 +1043,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT5(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT6(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00068ull) + ((offset) & 63) * 256;
@@ -903,6 +1055,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT6(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT7(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00070ull) + ((offset) & 63) * 256;
@@ -914,6 +1067,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT7(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT8(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00078ull) + ((offset) & 63) * 256;
@@ -925,6 +1079,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT8(unsigned long offset)
 static inline uint64_t CVMX_PKI_STATX_STAT9(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT9(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044E00080ull) + ((offset) & 63) * 256;
@@ -936,7 +1091,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT9(unsigned long offset)
 #define CVMX_PKI_STAT_CTL CVMX_PKI_STAT_CTL_FUNC()
 static inline uint64_t CVMX_PKI_STAT_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_STAT_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000110ull);
 }
@@ -947,6 +1102,7 @@ static inline uint64_t CVMX_PKI_STAT_CTL_FUNC(void)
 static inline uint64_t CVMX_PKI_STYLEX_BUF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_BUF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044024000ull) + ((offset) & 63) * 8;
@@ -958,6 +1114,7 @@ static inline uint64_t CVMX_PKI_STYLEX_BUF(unsigned long offset)
 static inline uint64_t CVMX_PKI_STYLEX_TAG_MASK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_TAG_MASK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044021000ull) + ((offset) & 63) * 8;
@@ -969,6 +1126,7 @@ static inline uint64_t CVMX_PKI_STYLEX_TAG_MASK(unsigned long offset)
 static inline uint64_t CVMX_PKI_STYLEX_TAG_SEL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_TAG_SEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044020000ull) + ((offset) & 63) * 8;
@@ -980,6 +1138,7 @@ static inline uint64_t CVMX_PKI_STYLEX_TAG_SEL(unsigned long offset)
 static inline uint64_t CVMX_PKI_STYLEX_WQ2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_WQ2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044022000ull) + ((offset) & 63) * 8;
@@ -991,6 +1150,7 @@ static inline uint64_t CVMX_PKI_STYLEX_WQ2(unsigned long offset)
 static inline uint64_t CVMX_PKI_STYLEX_WQ4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_WQ4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044023000ull) + ((offset) & 63) * 8;
@@ -1002,6 +1162,7 @@ static inline uint64_t CVMX_PKI_STYLEX_WQ4(unsigned long offset)
 static inline uint64_t CVMX_PKI_TAG_INCX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_TAG_INCX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044007000ull) + ((offset) & 31) * 8;
@@ -1013,6 +1174,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_CTL(unsigned long offset)
 static inline uint64_t CVMX_PKI_TAG_INCX_MASK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_TAG_INCX_MASK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180044008000ull) + ((offset) & 31) * 8;
@@ -1024,7 +1186,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_MASK(unsigned long offset)
 #define CVMX_PKI_TAG_SECRET CVMX_PKI_TAG_SECRET_FUNC()
 static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_TAG_SECRET not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000430ull);
 }
@@ -1035,7 +1197,7 @@ static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 #define CVMX_PKI_X2P_REQ_OFL CVMX_PKI_X2P_REQ_OFL_FUNC()
 static inline uint64_t CVMX_PKI_X2P_REQ_OFL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKI_X2P_REQ_OFL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000038ull);
 }
@@ -1057,6 +1219,7 @@ union cvmx_pki_active0 {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pki_active0_s             cn73xx;
 	struct cvmx_pki_active0_s             cn78xx;
 };
 typedef union cvmx_pki_active0 cvmx_pki_active0_t;
@@ -1081,6 +1244,7 @@ union cvmx_pki_active1 {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pki_active1_s             cn73xx;
 	struct cvmx_pki_active1_s             cn78xx;
 };
 typedef union cvmx_pki_active1 cvmx_pki_active1_t;
@@ -1099,6 +1263,7 @@ union cvmx_pki_active2 {
 	uint64_t reserved_5_63                : 59;
 #endif
 	} s;
+	struct cvmx_pki_active2_s             cn73xx;
 	struct cvmx_pki_active2_s             cn78xx;
 };
 typedef union cvmx_pki_active2 cvmx_pki_active2_t;
@@ -1140,6 +1305,7 @@ union cvmx_pki_aurax_cfg {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_aurax_cfg_s           cn73xx;
 	struct cvmx_pki_aurax_cfg_s           cn78xx;
 };
 typedef union cvmx_pki_aurax_cfg cvmx_pki_aurax_cfg_t;
@@ -1175,6 +1341,7 @@ union cvmx_pki_bist_status0 {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_pki_bist_status0_s        cn73xx;
 	struct cvmx_pki_bist_status0_s        cn78xx;
 };
 typedef union cvmx_pki_bist_status0 cvmx_pki_bist_status0_t;
@@ -1189,6 +1356,35 @@ union cvmx_pki_bist_status1 {
 	uint64_t u64;
 	struct cvmx_pki_bist_status1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_26_63               : 38;
+	uint64_t bist                         : 26; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
+                                                         register collects status for PKI_PBE.
+                                                         <20> = STATS_MEM0.
+                                                         <19> = STATS_MEM1.
+                                                         <18> = STATS_MEM2.
+                                                         <17> = STATS_MEM3.
+                                                         <16> = SWS.
+                                                         <15> = WQEOUT.
+                                                         <14> = DOA.
+                                                         <13> = BPID.
+                                                         <12 =10> = Reserved.
+                                                         <9> = PLC.
+                                                         <8> = PKTWQ.
+                                                         <7 =6> = Reserved.
+                                                         <5> = TAG.
+                                                         <4> = AURA.
+                                                         <3> = CHAN.
+                                                         <2> = PBTAG.
+                                                         <1> = STYLEWQ.
+                                                         <0> = QPG. */
+#else
+	uint64_t bist                         : 26;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} s;
+	struct cvmx_pki_bist_status1_s        cn73xx;
+	struct cvmx_pki_bist_status1_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_21_63               : 43;
 	uint64_t bist                         : 21; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
                                                          register collects status for PKI_PBE.
@@ -1214,8 +1410,7 @@ union cvmx_pki_bist_status1 {
 	uint64_t bist                         : 21;
 	uint64_t reserved_21_63               : 43;
 #endif
-	} s;
-	struct cvmx_pki_bist_status1_s        cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pki_bist_status1 cvmx_pki_bist_status1_t;
 
@@ -1250,6 +1445,7 @@ union cvmx_pki_bist_status2 {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pki_bist_status2_s        cn73xx;
 	struct cvmx_pki_bist_status2_s        cn78xx;
 };
 typedef union cvmx_pki_bist_status2 cvmx_pki_bist_status2_t;
@@ -1271,6 +1467,7 @@ union cvmx_pki_bpidx_state {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pki_bpidx_state_s         cn73xx;
 	struct cvmx_pki_bpidx_state_s         cn78xx;
 };
 typedef union cvmx_pki_bpidx_state cvmx_pki_bpidx_state_t;
@@ -1315,6 +1512,7 @@ union cvmx_pki_buf_ctl {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_pki_buf_ctl_s             cn73xx;
 	struct cvmx_pki_buf_ctl_s             cn78xx;
 };
 typedef union cvmx_pki_buf_ctl cvmx_pki_buf_ctl_t;
@@ -1345,6 +1543,7 @@ union cvmx_pki_chanx_cfg {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_pki_chanx_cfg_s           cn73xx;
 	struct cvmx_pki_chanx_cfg_s           cn78xx;
 };
 typedef union cvmx_pki_chanx_cfg cvmx_pki_chanx_cfg_t;
@@ -1386,6 +1585,7 @@ union cvmx_pki_clx_ecc_ctl {
 	uint64_t pcam_en                      : 1;
 #endif
 	} s;
+	struct cvmx_pki_clx_ecc_ctl_s         cn73xx;
 	struct cvmx_pki_clx_ecc_ctl_s         cn78xx;
 };
 typedef union cvmx_pki_clx_ecc_ctl cvmx_pki_clx_ecc_ctl_t;
@@ -1418,6 +1618,7 @@ union cvmx_pki_clx_ecc_int {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_pki_clx_ecc_int_s         cn73xx;
 	struct cvmx_pki_clx_ecc_int_s         cn78xx;
 };
 typedef union cvmx_pki_clx_ecc_int cvmx_pki_clx_ecc_int_t;
@@ -1447,6 +1648,7 @@ union cvmx_pki_clx_int {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pki_clx_int_s             cn73xx;
 	struct cvmx_pki_clx_int_s             cn78xx;
 };
 typedef union cvmx_pki_clx_int cvmx_pki_clx_int_t;
@@ -1519,6 +1721,7 @@ union cvmx_pki_clx_pcamx_actionx {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_pki_clx_pcamx_actionx_s   cn73xx;
 	struct cvmx_pki_clx_pcamx_actionx_s   cn78xx;
 };
 typedef union cvmx_pki_clx_pcamx_actionx cvmx_pki_clx_pcamx_actionx_t;
@@ -1544,6 +1747,7 @@ union cvmx_pki_clx_pcamx_matchx {
 	uint64_t data1                        : 32;
 #endif
 	} s;
+	struct cvmx_pki_clx_pcamx_matchx_s    cn73xx;
 	struct cvmx_pki_clx_pcamx_matchx_s    cn78xx;
 };
 typedef union cvmx_pki_clx_pcamx_matchx cvmx_pki_clx_pcamx_matchx_t;
@@ -1584,6 +1788,7 @@ union cvmx_pki_clx_pcamx_termx {
 	uint64_t valid                        : 1;
 #endif
 	} s;
+	struct cvmx_pki_clx_pcamx_termx_s     cn73xx;
 	struct cvmx_pki_clx_pcamx_termx_s     cn78xx;
 };
 typedef union cvmx_pki_clx_pcamx_termx cvmx_pki_clx_pcamx_termx_t;
@@ -1637,6 +1842,7 @@ union cvmx_pki_clx_pkindx_cfg {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_cfg_s      cn73xx;
 	struct cvmx_pki_clx_pkindx_cfg_s      cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_cfg cvmx_pki_clx_pkindx_cfg_t;
@@ -1661,6 +1867,7 @@ union cvmx_pki_clx_pkindx_kmemx {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_kmemx_s    cn73xx;
 	struct cvmx_pki_clx_pkindx_kmemx_s    cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_kmemx cvmx_pki_clx_pkindx_kmemx_t;
@@ -1688,6 +1895,7 @@ union cvmx_pki_clx_pkindx_l2_custom {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_l2_custom_s cn73xx;
 	struct cvmx_pki_clx_pkindx_l2_custom_s cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_l2_custom cvmx_pki_clx_pkindx_l2_custom_t;
@@ -1707,6 +1915,7 @@ union cvmx_pki_clx_pkindx_lg_custom {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_lg_custom_s cn73xx;
 	struct cvmx_pki_clx_pkindx_lg_custom_s cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_lg_custom cvmx_pki_clx_pkindx_lg_custom_t;
@@ -1733,6 +1942,7 @@ union cvmx_pki_clx_pkindx_skip {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_skip_s     cn73xx;
 	struct cvmx_pki_clx_pkindx_skip_s     cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_skip cvmx_pki_clx_pkindx_skip_t;
@@ -1769,6 +1979,7 @@ union cvmx_pki_clx_pkindx_style {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_pki_clx_pkindx_style_s    cn73xx;
 	struct cvmx_pki_clx_pkindx_style_s    cn78xx;
 };
 typedef union cvmx_pki_clx_pkindx_style cvmx_pki_clx_pkindx_style_t;
@@ -1791,6 +2002,7 @@ union cvmx_pki_clx_smemx {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_clx_smemx_s           cn73xx;
 	struct cvmx_pki_clx_smemx_s           cn78xx;
 };
 typedef union cvmx_pki_clx_smemx cvmx_pki_clx_smemx_t;
@@ -1809,6 +2021,7 @@ union cvmx_pki_clx_start {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_pki_clx_start_s           cn73xx;
 	struct cvmx_pki_clx_start_s           cn78xx;
 };
 typedef union cvmx_pki_clx_start cvmx_pki_clx_start_t;
@@ -1831,7 +2044,7 @@ union cvmx_pki_clx_stylex_alg {
                                                          8 = Include port<7:0>.
                                                          else Reserved. */
 	uint64_t reserved_11_16               : 6;
-	uint64_t tag_vni                      : 1;  /**< When VXLAN is found, include VNI in tag generation. When NVGRE is found, include TNI. */
+	uint64_t tag_vni                      : 1;  /**< When NVGRE/VXLAN/GENEVE is found, include VNI in tag generation. When NVGRE is found, include TNI. */
 	uint64_t tag_gtp                      : 1;  /**< When GTP is parsed, include GTP's TEID in tag generation. */
 	uint64_t tag_spi                      : 1;  /**< Include AH/GRE in tag generation.
                                                          0 = Exclude AH/GRE in tag generation.
@@ -1870,6 +2083,7 @@ union cvmx_pki_clx_stylex_alg {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_clx_stylex_alg_s      cn73xx;
 	struct cvmx_pki_clx_stylex_alg_s      cn78xx;
 };
 typedef union cvmx_pki_clx_stylex_alg cvmx_pki_clx_stylex_alg_t;
@@ -1942,6 +2156,7 @@ union cvmx_pki_clx_stylex_cfg {
 	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
+	struct cvmx_pki_clx_stylex_cfg_s      cn73xx;
 	struct cvmx_pki_clx_stylex_cfg_s      cn78xx;
 };
 typedef union cvmx_pki_clx_stylex_cfg cvmx_pki_clx_stylex_cfg_t;
@@ -2017,6 +2232,7 @@ union cvmx_pki_clx_stylex_cfg2 {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_clx_stylex_cfg2_s     cn73xx;
 	struct cvmx_pki_clx_stylex_cfg2_s     cn78xx;
 };
 typedef union cvmx_pki_clx_stylex_cfg2 cvmx_pki_clx_stylex_cfg2_t;
@@ -2037,11 +2253,125 @@ union cvmx_pki_clken {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pki_clken_s               cn73xx;
 	struct cvmx_pki_clken_s               cn78xx;
 };
 typedef union cvmx_pki_clken cvmx_pki_clken_t;
 
 /**
+ * cvmx_pki_dstat#_stat0
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat0 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t pkts                         : 32; /**< Number of non-dropped packets processed by PKI.
+                                                         The corresponding wide statistic is PKI_STAT()_STAT0. */
+#else
+	uint64_t pkts                         : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat0_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat0 cvmx_pki_dstatx_stat0_t;
+
+/**
+ * cvmx_pki_dstat#_stat1
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat1 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t octs                         : 40; /**< Number of non-dropped octets received by PKI (good and bad).
+                                                         The corresponding wide statistic is PKI_STAT()_STAT1. */
+#else
+	uint64_t octs                         : 40;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat1_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat1 cvmx_pki_dstatx_stat1_t;
+
+/**
+ * cvmx_pki_dstat#_stat2
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat2 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t err_pkts                     : 32; /**< Number of packets with errors, including length < minimum, length > maximum, FCS
+                                                         errors, or WQE[ERRLEV]==RE or L2.
+                                                         This corresponds to a sum across the wide statistics PKI_STAT()_STAT7, PKI_STAT()_STAT7,
+                                                         PKI_STAT()_STAT8, PKI_STAT()_STAT9, PKI_STAT()_STAT10, PKI_STAT()_STAT11, and
+                                                         PKI_STAT()_STAT12. */
+#else
+	uint64_t err_pkts                     : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat2_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat2 cvmx_pki_dstatx_stat2_t;
+
+/**
+ * cvmx_pki_dstat#_stat3
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat3 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t drp_pkts                     : 32; /**< Inbound packets dropped by RED, buffer exhaustion, or PKI_CL()_STYLE()_CFG[DROP].
+                                                         The corresponding wide statistic is PKI_STAT()_STAT3. */
+#else
+	uint64_t drp_pkts                     : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat3_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat3 cvmx_pki_dstatx_stat3_t;
+
+/**
+ * cvmx_pki_dstat#_stat4
+ *
+ * This register contains statistics indexed by PKI_QPG_TBLB()[DSTAT_ID].
+ *
+ */
+union cvmx_pki_dstatx_stat4 {
+	uint64_t u64;
+	struct cvmx_pki_dstatx_stat4_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t drp_octs                     : 40; /**< Inbound octets dropped by RED, buffer exhaustion, or PKI_CL()_STYLE()_CFG[DROP].
+                                                         The corresponding wide statistic is PKI_STAT()_STAT4. */
+#else
+	uint64_t drp_octs                     : 40;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} s;
+	struct cvmx_pki_dstatx_stat4_s        cn73xx;
+};
+typedef union cvmx_pki_dstatx_stat4 cvmx_pki_dstatx_stat4_t;
+
+/**
  * cvmx_pki_ecc_ctl0
  *
  * This register allows inserting ECC errors for testing.
@@ -2096,6 +2426,7 @@ union cvmx_pki_ecc_ctl0 {
 	uint64_t reserved_24_63               : 40;
 #endif
 	} s;
+	struct cvmx_pki_ecc_ctl0_s            cn73xx;
 	struct cvmx_pki_ecc_ctl0_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_ctl0 cvmx_pki_ecc_ctl0_t;
@@ -2167,6 +2498,7 @@ union cvmx_pki_ecc_ctl1 {
 	uint64_t reserved_51_63               : 13;
 #endif
 	} s;
+	struct cvmx_pki_ecc_ctl1_s            cn73xx;
 	struct cvmx_pki_ecc_ctl1_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_ctl1 cvmx_pki_ecc_ctl1_t;
@@ -2191,6 +2523,7 @@ union cvmx_pki_ecc_ctl2 {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_pki_ecc_ctl2_s            cn73xx;
 	struct cvmx_pki_ecc_ctl2_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_ctl2 cvmx_pki_ecc_ctl2_t;
@@ -2239,6 +2572,7 @@ union cvmx_pki_ecc_int0 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_ecc_int0_s            cn73xx;
 	struct cvmx_pki_ecc_int0_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_int0 cvmx_pki_ecc_int0_t;
@@ -2307,6 +2641,7 @@ union cvmx_pki_ecc_int1 {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_pki_ecc_int1_s            cn73xx;
 	struct cvmx_pki_ecc_int1_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_int1 cvmx_pki_ecc_int1_t;
@@ -2327,6 +2662,7 @@ union cvmx_pki_ecc_int2 {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pki_ecc_int2_s            cn73xx;
 	struct cvmx_pki_ecc_int2_s            cn78xx;
 };
 typedef union cvmx_pki_ecc_int2 cvmx_pki_ecc_int2_t;
@@ -2347,6 +2683,7 @@ union cvmx_pki_frm_len_chkx {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pki_frm_len_chkx_s        cn73xx;
 	struct cvmx_pki_frm_len_chkx_s        cn78xx;
 };
 typedef union cvmx_pki_frm_len_chkx cvmx_pki_frm_len_chkx_t;
@@ -2360,9 +2697,9 @@ union cvmx_pki_gbl_pen {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t virt_pen                     : 1;  /**< Virtualization parsing enable.
-                                                         0 = VXLAN/NVGRE is never used in any style. This enables internal power and latency
-                                                         reductions.
-                                                         1 = VXLAN/NVGRE parsing may be used. */
+                                                         0 = VXLAN/NVGRE/GENEVE is never used in any style. This enables internal power
+                                                         and latency reductions.
+                                                         1 = VXLAN/NVGRE/GENEVE parsing may be used. */
 	uint64_t clg_pen                      : 1;  /**< Custom LG parsing enable.
                                                          0 = Custom LG is never used in any style; i.e. PKI_CL()_PKIND()_CFG[LG_CUSTOM] is
                                                          zero for all indices. This enables internal power and latency reductions.
@@ -2414,6 +2751,7 @@ union cvmx_pki_gbl_pen {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_pki_gbl_pen_s             cn73xx;
 	struct cvmx_pki_gbl_pen_s             cn78xx;
 };
 typedef union cvmx_pki_gbl_pen cvmx_pki_gbl_pen_t;
@@ -2425,6 +2763,49 @@ union cvmx_pki_gen_int {
 	uint64_t u64;
 	struct cvmx_pki_gen_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t bufs_oflow                   : 1;  /**< Set when PKI receives a packet that exceeds 256 buffers.
+                                                         Throws PKI_INTSN_E::PKI_GEN_BUFS_OFLOW. */
+	uint64_t pkt_size_oflow               : 1;  /**< Set when PKI receives a packet that exceeds 64 KB.
+                                                         Throws PKI_INTSN_E::PKI_GEN_PKT_SIZE_OFLOW. */
+	uint64_t x2p_req_ofl                  : 1;  /**< Set when a device attempts to have more than the allocated requests outstanding to PKI.
+                                                         Throws PKI_INTSN_E::PKI_GEN_X2P_REQ_OFL. */
+	uint64_t drp_noavail                  : 1;  /**< Set when packet dropped due to no FPA pointers available for the aura the packet
+                                                         requested. Throws PKI_INTSN_E::PKI_GEN_DRP_NOAVAIL. */
+	uint64_t dat                          : 1;  /**< Set when data arrives before a SOP for the same reasm-id for a packet. The first detected
+                                                         error associated with bits [DAT,SOP,EOP] of this register is only set here. A new bit can
+                                                         be set when the previous reported bit is cleared. Throws PKI_INTSN_E::PKI_GEN_DAT. */
+	uint64_t eop                          : 1;  /**< Set when an EOP is followed by an EOP for the same reasm-id for a packet. The first
+                                                         detected error associated with bits [DAT,EOP,SOP] of this register is only set here. A new
+                                                         bit can be set when the previous reported bit is cleared. Also see PKI_PKT_ERR. Throws
+                                                         PKI_INTSN_E::PKI_GEN_EOP. */
+	uint64_t sop                          : 1;  /**< Set when a SOP is followed by an SOP for the same reasm-id for a packet. The first
+                                                         detected error associated with bits [DAT,EOP,SOP] of this register is only set here. A new
+                                                         bit can be set when the previous reported bit is cleared. Also see PKI_PKT_ERR. Throws
+                                                         PKI_INTSN_E::PKI_GEN_SOP. */
+	uint64_t bckprs                       : 1;  /**< PKI asserted backpressure. Set when PKI was unable to accept the next valid data from
+                                                         BGX/DPI/ILK etc. over X2P due to all internal resources being used up, and PKI will
+                                                         backpressure X2P. Throws PKI_INTSN_E::PKI_GEN_BCKPRS. */
+	uint64_t crcerr                       : 1;  /**< PKI calculated bad CRC in the L2 frame. Throws PKI_INTSN_E::PKI_GEN_CRCERR. */
+	uint64_t pktdrp                       : 1;  /**< Packet dropped due to QOS. If the QOS algorithm decides to drop a packet, PKI asserts this
+                                                         interrupt. Throws PKI_INTSN_E::PKI_GEN_PKTDRP. */
+#else
+	uint64_t pktdrp                       : 1;
+	uint64_t crcerr                       : 1;
+	uint64_t bckprs                       : 1;
+	uint64_t sop                          : 1;
+	uint64_t eop                          : 1;
+	uint64_t dat                          : 1;
+	uint64_t drp_noavail                  : 1;
+	uint64_t x2p_req_ofl                  : 1;
+	uint64_t pkt_size_oflow               : 1;
+	uint64_t bufs_oflow                   : 1;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_pki_gen_int_s             cn73xx;
+	struct cvmx_pki_gen_int_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t x2p_req_ofl                  : 1;  /**< Set when a device attempts to have more than the allocated requests outstanding to PKI.
                                                          Throws PKI_INTSN_E::PKI_GEN_X2P_REQ_OFL. */
@@ -2458,8 +2839,7 @@ union cvmx_pki_gen_int {
 	uint64_t x2p_req_ofl                  : 1;
 	uint64_t reserved_8_63                : 56;
 #endif
-	} s;
-	struct cvmx_pki_gen_int_s             cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pki_gen_int cvmx_pki_gen_int_t;
 
@@ -2517,6 +2897,7 @@ union cvmx_pki_icgx_cfg {
 	uint64_t reserved_53_63               : 11;
 #endif
 	} s;
+	struct cvmx_pki_icgx_cfg_s            cn73xx;
 	struct cvmx_pki_icgx_cfg_s            cn78xx;
 };
 typedef union cvmx_pki_icgx_cfg cvmx_pki_icgx_cfg_t;
@@ -2533,6 +2914,7 @@ union cvmx_pki_imemx {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_pki_imemx_s               cn73xx;
 	struct cvmx_pki_imemx_s               cn78xx;
 };
 typedef union cvmx_pki_imemx cvmx_pki_imemx_t;
@@ -2553,11 +2935,30 @@ union cvmx_pki_ltypex_map {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_pki_ltypex_map_s          cn73xx;
 	struct cvmx_pki_ltypex_map_s          cn78xx;
 };
 typedef union cvmx_pki_ltypex_map cvmx_pki_ltypex_map_t;
 
 /**
+ * cvmx_pki_pbe_eco
+ */
+union cvmx_pki_pbe_eco {
+	uint64_t u64;
+	struct cvmx_pki_pbe_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_pbe_eco_s             cn73xx;
+};
+typedef union cvmx_pki_pbe_eco cvmx_pki_pbe_eco_t;
+
+/**
  * cvmx_pki_pcam_lookup
  *
  * For diagnostic use only, perform a PCAM lookup against the provided cluster and PCAM instance
@@ -2584,6 +2985,7 @@ union cvmx_pki_pcam_lookup {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
+	struct cvmx_pki_pcam_lookup_s         cn73xx;
 	struct cvmx_pki_pcam_lookup_s         cn78xx;
 };
 typedef union cvmx_pki_pcam_lookup cvmx_pki_pcam_lookup_t;
@@ -2607,7 +3009,7 @@ union cvmx_pki_pcam_result {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
-	struct cvmx_pki_pcam_result_cn78xx {
+	struct cvmx_pki_pcam_result_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t conflict                     : 1;  /**< Conflict. The lookup resulted in multiple entries matching PKI_PCAM_LOOKUP[DATA], [TERM]
                                                          and [STYLE], or zero if no conflict. */
@@ -2623,7 +3025,8 @@ union cvmx_pki_pcam_result {
 	uint64_t reserved_41_62               : 22;
 	uint64_t conflict                     : 1;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_pki_pcam_result_cn73xx    cn78xx;
 };
 typedef union cvmx_pki_pcam_result cvmx_pki_pcam_result_t;
 
@@ -2641,11 +3044,30 @@ union cvmx_pki_pfe_diag {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pki_pfe_diag_s            cn73xx;
 	struct cvmx_pki_pfe_diag_s            cn78xx;
 };
 typedef union cvmx_pki_pfe_diag cvmx_pki_pfe_diag_t;
 
 /**
+ * cvmx_pki_pfe_eco
+ */
+union cvmx_pki_pfe_eco {
+	uint64_t u64;
+	struct cvmx_pki_pfe_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_pfe_eco_s             cn73xx;
+};
+typedef union cvmx_pki_pfe_eco cvmx_pki_pfe_eco_t;
+
+/**
  * cvmx_pki_pix_clken
  */
 union cvmx_pki_pix_clken {
@@ -2663,6 +3085,7 @@ union cvmx_pki_pix_clken {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_pki_pix_clken_s           cn73xx;
 	struct cvmx_pki_pix_clken_s           cn78xx;
 };
 typedef union cvmx_pki_pix_clken cvmx_pki_pix_clken_t;
@@ -2681,11 +3104,30 @@ union cvmx_pki_pix_diag {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pki_pix_diag_s            cn73xx;
 	struct cvmx_pki_pix_diag_s            cn78xx;
 };
 typedef union cvmx_pki_pix_diag cvmx_pki_pix_diag_t;
 
 /**
+ * cvmx_pki_pix_eco
+ */
+union cvmx_pki_pix_eco {
+	uint64_t u64;
+	struct cvmx_pki_pix_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pki_pix_eco_s             cn73xx;
+};
+typedef union cvmx_pki_pix_eco cvmx_pki_pix_eco_t;
+
+/**
  * cvmx_pki_pkind#_icgsel
  */
 union cvmx_pki_pkindx_icgsel {
@@ -2700,6 +3142,7 @@ union cvmx_pki_pkindx_icgsel {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pki_pkindx_icgsel_s       cn73xx;
 	struct cvmx_pki_pkindx_icgsel_s       cn78xx;
 };
 typedef union cvmx_pki_pkindx_icgsel cvmx_pki_pkindx_icgsel_t;
@@ -2721,6 +3164,7 @@ union cvmx_pki_pkndx_inb_stat0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_pkndx_inb_stat0_s     cn73xx;
 	struct cvmx_pki_pkndx_inb_stat0_s     cn78xx;
 };
 typedef union cvmx_pki_pkndx_inb_stat0 cvmx_pki_pkndx_inb_stat0_t;
@@ -2742,6 +3186,7 @@ union cvmx_pki_pkndx_inb_stat1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_pkndx_inb_stat1_s     cn73xx;
 	struct cvmx_pki_pkndx_inb_stat1_s     cn78xx;
 };
 typedef union cvmx_pki_pkndx_inb_stat1 cvmx_pki_pkndx_inb_stat1_t;
@@ -2763,6 +3208,7 @@ union cvmx_pki_pkndx_inb_stat2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_pkndx_inb_stat2_s     cn73xx;
 	struct cvmx_pki_pkndx_inb_stat2_s     cn78xx;
 };
 typedef union cvmx_pki_pkndx_inb_stat2 cvmx_pki_pkndx_inb_stat2_t;
@@ -2782,6 +3228,7 @@ union cvmx_pki_pkt_err {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_pki_pkt_err_s             cn73xx;
 	struct cvmx_pki_pkt_err_s             cn78xx;
 };
 typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
@@ -2791,7 +3238,8 @@ typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
  *
  * The QPG table is used to indirectly calculate the Portadd/Aura/Group from the Diffsrv, HiGig
  * or VLAN information as described in QPG.
- * See also PKI_QPG_TBL2().
+ * See also PKI_QPG_TBLB().
+ * INTERNAL: This register is outside SMEM due to opcode detection.
  */
 union cvmx_pki_qpg_tblx {
 	uint64_t u64;
@@ -2824,11 +3272,36 @@ union cvmx_pki_qpg_tblx {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pki_qpg_tblx_s            cn73xx;
 	struct cvmx_pki_qpg_tblx_s            cn78xx;
 };
 typedef union cvmx_pki_qpg_tblx cvmx_pki_qpg_tblx_t;
 
 /**
+ * cvmx_pki_qpg_tblb#
+ *
+ * This register configures the QPG table. See also PKI_QPG_TBL().
+ *
+ */
+union cvmx_pki_qpg_tblbx {
+	uint64_t u64;
+	struct cvmx_pki_qpg_tblbx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t dstat_id                     : 10; /**< Deep statistic bucket to use for traffic to this QPG. This determines which
+                                                         index of PKI_DSTAT()_STAT0..PKI_DSTAT()_STAT4 will increment. Additionally, if
+                                                         PKI_STAT_CTL[MODE] = 0x2, then DSTAT_ID values 0-63 will increment
+                                                         PKI_STAT()_STAT0..PKI_STAT()_STAT18 and PKI_STAT()_HIST0..PKI_STAT()_HIST6. */
+#else
+	uint64_t dstat_id                     : 10;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_pki_qpg_tblbx_s           cn73xx;
+};
+typedef union cvmx_pki_qpg_tblbx cvmx_pki_qpg_tblbx_t;
+
+/**
  * cvmx_pki_reasm_sop#
  *
  * Set when a SOP is detected on a Reasm-Id, where the Reasm-ID value sets the bit vector of this
@@ -2844,6 +3317,7 @@ union cvmx_pki_reasm_sopx {
 	uint64_t sop                          : 64;
 #endif
 	} s;
+	struct cvmx_pki_reasm_sopx_s          cn73xx;
 	struct cvmx_pki_reasm_sopx_s          cn78xx;
 };
 typedef union cvmx_pki_reasm_sopx cvmx_pki_reasm_sopx_t;
@@ -2881,6 +3355,7 @@ union cvmx_pki_req_wgt {
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_pki_req_wgt_s             cn73xx;
 	struct cvmx_pki_req_wgt_s             cn78xx;
 };
 typedef union cvmx_pki_req_wgt cvmx_pki_req_wgt_t;
@@ -2912,6 +3387,7 @@ union cvmx_pki_sft_rst {
 	uint64_t busy                         : 1;
 #endif
 	} s;
+	struct cvmx_pki_sft_rst_s             cn73xx;
 	struct cvmx_pki_sft_rst_s             cn78xx;
 };
 typedef union cvmx_pki_sft_rst cvmx_pki_sft_rst_t;
@@ -2931,6 +3407,7 @@ union cvmx_pki_statx_hist0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist0_s         cn73xx;
 	struct cvmx_pki_statx_hist0_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist0 cvmx_pki_statx_hist0_t;
@@ -2949,6 +3426,7 @@ union cvmx_pki_statx_hist1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist1_s         cn73xx;
 	struct cvmx_pki_statx_hist1_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist1 cvmx_pki_statx_hist1_t;
@@ -2967,6 +3445,7 @@ union cvmx_pki_statx_hist2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist2_s         cn73xx;
 	struct cvmx_pki_statx_hist2_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist2 cvmx_pki_statx_hist2_t;
@@ -2985,6 +3464,7 @@ union cvmx_pki_statx_hist3 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist3_s         cn73xx;
 	struct cvmx_pki_statx_hist3_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist3 cvmx_pki_statx_hist3_t;
@@ -3003,6 +3483,7 @@ union cvmx_pki_statx_hist4 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist4_s         cn73xx;
 	struct cvmx_pki_statx_hist4_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist4 cvmx_pki_statx_hist4_t;
@@ -3021,6 +3502,7 @@ union cvmx_pki_statx_hist5 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist5_s         cn73xx;
 	struct cvmx_pki_statx_hist5_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist5 cvmx_pki_statx_hist5_t;
@@ -3039,6 +3521,7 @@ union cvmx_pki_statx_hist6 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_hist6_s         cn73xx;
 	struct cvmx_pki_statx_hist6_s         cn78xx;
 };
 typedef union cvmx_pki_statx_hist6 cvmx_pki_statx_hist6_t;
@@ -3057,6 +3540,7 @@ union cvmx_pki_statx_stat0 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat0_s         cn73xx;
 	struct cvmx_pki_statx_stat0_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat0 cvmx_pki_statx_stat0_t;
@@ -3075,6 +3559,7 @@ union cvmx_pki_statx_stat1 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat1_s         cn73xx;
 	struct cvmx_pki_statx_stat1_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat1 cvmx_pki_statx_stat1_t;
@@ -3093,6 +3578,7 @@ union cvmx_pki_statx_stat10 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat10_s        cn73xx;
 	struct cvmx_pki_statx_stat10_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat10 cvmx_pki_statx_stat10_t;
@@ -3111,6 +3597,7 @@ union cvmx_pki_statx_stat11 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat11_s        cn73xx;
 	struct cvmx_pki_statx_stat11_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat11 cvmx_pki_statx_stat11_t;
@@ -3130,6 +3617,7 @@ union cvmx_pki_statx_stat12 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat12_s        cn73xx;
 	struct cvmx_pki_statx_stat12_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat12 cvmx_pki_statx_stat12_t;
@@ -3150,6 +3638,7 @@ union cvmx_pki_statx_stat13 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat13_s        cn73xx;
 	struct cvmx_pki_statx_stat13_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat13 cvmx_pki_statx_stat13_t;
@@ -3169,6 +3658,7 @@ union cvmx_pki_statx_stat14 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat14_s        cn73xx;
 	struct cvmx_pki_statx_stat14_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat14 cvmx_pki_statx_stat14_t;
@@ -3188,6 +3678,7 @@ union cvmx_pki_statx_stat15 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat15_s        cn73xx;
 	struct cvmx_pki_statx_stat15_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat15 cvmx_pki_statx_stat15_t;
@@ -3207,6 +3698,7 @@ union cvmx_pki_statx_stat16 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat16_s        cn73xx;
 	struct cvmx_pki_statx_stat16_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat16 cvmx_pki_statx_stat16_t;
@@ -3226,6 +3718,7 @@ union cvmx_pki_statx_stat17 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat17_s        cn73xx;
 	struct cvmx_pki_statx_stat17_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat17 cvmx_pki_statx_stat17_t;
@@ -3245,6 +3738,7 @@ union cvmx_pki_statx_stat18 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat18_s        cn73xx;
 	struct cvmx_pki_statx_stat18_s        cn78xx;
 };
 typedef union cvmx_pki_statx_stat18 cvmx_pki_statx_stat18_t;
@@ -3263,6 +3757,7 @@ union cvmx_pki_statx_stat2 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat2_s         cn73xx;
 	struct cvmx_pki_statx_stat2_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat2 cvmx_pki_statx_stat2_t;
@@ -3281,6 +3776,7 @@ union cvmx_pki_statx_stat3 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat3_s         cn73xx;
 	struct cvmx_pki_statx_stat3_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat3 cvmx_pki_statx_stat3_t;
@@ -3299,6 +3795,7 @@ union cvmx_pki_statx_stat4 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat4_s         cn73xx;
 	struct cvmx_pki_statx_stat4_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat4 cvmx_pki_statx_stat4_t;
@@ -3318,6 +3815,7 @@ union cvmx_pki_statx_stat5 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat5_s         cn73xx;
 	struct cvmx_pki_statx_stat5_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat5 cvmx_pki_statx_stat5_t;
@@ -3337,6 +3835,7 @@ union cvmx_pki_statx_stat6 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat6_s         cn73xx;
 	struct cvmx_pki_statx_stat6_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat6 cvmx_pki_statx_stat6_t;
@@ -3355,6 +3854,7 @@ union cvmx_pki_statx_stat7 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat7_s         cn73xx;
 	struct cvmx_pki_statx_stat7_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat7 cvmx_pki_statx_stat7_t;
@@ -3373,6 +3873,7 @@ union cvmx_pki_statx_stat8 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat8_s         cn73xx;
 	struct cvmx_pki_statx_stat8_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat8 cvmx_pki_statx_stat8_t;
@@ -3391,6 +3892,7 @@ union cvmx_pki_statx_stat9 {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pki_statx_stat9_s         cn73xx;
 	struct cvmx_pki_statx_stat9_s         cn78xx;
 };
 typedef union cvmx_pki_statx_stat9 cvmx_pki_statx_stat9_t;
@@ -3410,7 +3912,7 @@ union cvmx_pki_stat_ctl {
                                                          (Does not apply to the PKI_STAT_INB* nor PKI_DSTAT_* registers.)
                                                          _ 0x0 = X represents the packet's pkind.
                                                          _ 0x1 = X represents the low 6-bits of packet's final style.
-                                                         _ 0x2 = X represents the packet's PKI_QPG_TBL2()[DSTAT_ID].
+                                                         _ 0x2 = X represents the packet's PKI_QPG_TBLB()[DSTAT_ID].
                                                            PKI_STAT()_STAT0..PKI_STAT()_STAT18 and PKI_STAT()_HIST0..PKI_STAT()_HIST6 will only
                                                            be incremented if the DSTAT_ID is less than 64; i.e. fits in the index of the
                                                            PKI_STAT()_STAT0 etc. Added in pass 2.
@@ -3420,6 +3922,7 @@ union cvmx_pki_stat_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pki_stat_ctl_s            cn73xx;
 	struct cvmx_pki_stat_ctl_s            cn78xx;
 };
 typedef union cvmx_pki_stat_ctl cvmx_pki_stat_ctl_t;
@@ -3501,6 +4004,7 @@ union cvmx_pki_stylex_buf {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_pki_stylex_buf_s          cn73xx;
 	struct cvmx_pki_stylex_buf_s          cn78xx;
 };
 typedef union cvmx_pki_stylex_buf cvmx_pki_stylex_buf_t;
@@ -3521,6 +4025,7 @@ union cvmx_pki_stylex_tag_mask {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pki_stylex_tag_mask_s     cn73xx;
 	struct cvmx_pki_stylex_tag_mask_s     cn78xx;
 };
 typedef union cvmx_pki_stylex_tag_mask cvmx_pki_stylex_tag_mask_t;
@@ -3552,6 +4057,7 @@ union cvmx_pki_stylex_tag_sel {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_pki_stylex_tag_sel_s      cn73xx;
 	struct cvmx_pki_stylex_tag_sel_s      cn78xx;
 };
 typedef union cvmx_pki_stylex_tag_sel cvmx_pki_stylex_tag_sel_t;
@@ -3570,6 +4076,7 @@ union cvmx_pki_stylex_wq2 {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_pki_stylex_wq2_s          cn73xx;
 	struct cvmx_pki_stylex_wq2_s          cn78xx;
 };
 typedef union cvmx_pki_stylex_wq2 cvmx_pki_stylex_wq2_t;
@@ -3588,6 +4095,7 @@ union cvmx_pki_stylex_wq4 {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_pki_stylex_wq4_s          cn73xx;
 	struct cvmx_pki_stylex_wq4_s          cn78xx;
 };
 typedef union cvmx_pki_stylex_wq4 cvmx_pki_stylex_wq4_t;
@@ -3628,6 +4136,7 @@ union cvmx_pki_tag_incx_ctl {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_pki_tag_incx_ctl_s        cn73xx;
 	struct cvmx_pki_tag_incx_ctl_s        cn78xx;
 };
 typedef union cvmx_pki_tag_incx_ctl cvmx_pki_tag_incx_ctl_t;
@@ -3645,6 +4154,7 @@ union cvmx_pki_tag_incx_mask {
 	uint64_t en                           : 64;
 #endif
 	} s;
+	struct cvmx_pki_tag_incx_mask_s       cn73xx;
 	struct cvmx_pki_tag_incx_mask_s       cn78xx;
 };
 typedef union cvmx_pki_tag_incx_mask cvmx_pki_tag_incx_mask_t;
@@ -3674,6 +4184,7 @@ union cvmx_pki_tag_secret {
 	uint64_t dst6                         : 16;
 #endif
 	} s;
+	struct cvmx_pki_tag_secret_s          cn73xx;
 	struct cvmx_pki_tag_secret_s          cn78xx;
 };
 typedef union cvmx_pki_tag_secret cvmx_pki_tag_secret_t;
@@ -3693,6 +4204,7 @@ union cvmx_pki_x2p_req_ofl {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pki_x2p_req_ofl_s         cn73xx;
 	struct cvmx_pki_x2p_req_ofl_s         cn78xx;
 };
 typedef union cvmx_pki_x2p_req_ofl cvmx_pki_x2p_req_ofl_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 2c0d8a4..3a1c1ac 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_PKO_CHANNEL_LEVEL CVMX_PKO_CHANNEL_LEVEL_FUNC()
 static inline uint64_t CVMX_PKO_CHANNEL_LEVEL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_CHANNEL_LEVEL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000800F0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_PKO_CHANNEL_LEVEL_FUNC(void)
 #define CVMX_PKO_DPFI_ENA CVMX_PKO_DPFI_ENA_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_ENA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_ENA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00018ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_PKO_DPFI_ENA_FUNC(void)
 #define CVMX_PKO_DPFI_FLUSH CVMX_PKO_DPFI_FLUSH_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_FLUSH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_FLUSH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00008ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_PKO_DPFI_FLUSH_FUNC(void)
 #define CVMX_PKO_DPFI_FPA_AURA CVMX_PKO_DPFI_FPA_AURA_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_FPA_AURA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_FPA_AURA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00010ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_PKO_DPFI_FPA_AURA_FUNC(void)
 #define CVMX_PKO_DPFI_STATUS CVMX_PKO_DPFI_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DPFI_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00000ull);
 }
@@ -111,6 +111,7 @@ static inline uint64_t CVMX_PKO_DPFI_STATUS_FUNC(void)
 static inline uint64_t CVMX_PKO_DQX_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000D8ull) + ((offset) & 1023) * 512;
@@ -122,6 +123,7 @@ static inline uint64_t CVMX_PKO_DQX_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280018ull) + ((offset) & 1023) * 512;
@@ -133,6 +135,7 @@ static inline uint64_t CVMX_PKO_DQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_DROPPED_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_DROPPED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000C8ull) + ((offset) & 1023) * 512;
@@ -144,6 +147,7 @@ static inline uint64_t CVMX_PKO_DQX_DROPPED_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_DROPPED_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_DROPPED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000C0ull) + ((offset) & 1023) * 512;
@@ -155,6 +159,7 @@ static inline uint64_t CVMX_PKO_DQX_DROPPED_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_FIFO(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_FIFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300078ull) + ((offset) & 1023) * 512;
@@ -166,6 +171,7 @@ static inline uint64_t CVMX_PKO_DQX_FIFO(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000D0ull) + ((offset) & 1023) * 512;
@@ -177,6 +183,7 @@ static inline uint64_t CVMX_PKO_DQX_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300070ull) + ((offset) & 1023) * 512;
@@ -188,6 +195,7 @@ static inline uint64_t CVMX_PKO_DQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_PIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280020ull) + ((offset) & 1023) * 512;
@@ -199,6 +207,7 @@ static inline uint64_t CVMX_PKO_DQX_PIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_POINTERS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280078ull) + ((offset) & 1023) * 512;
@@ -210,6 +219,7 @@ static inline uint64_t CVMX_PKO_DQX_POINTERS(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280008ull) + ((offset) & 1023) * 512;
@@ -221,6 +231,7 @@ static inline uint64_t CVMX_PKO_DQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280028ull) + ((offset) & 1023) * 512;
@@ -232,6 +243,7 @@ static inline uint64_t CVMX_PKO_DQX_SCHED_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280010ull) + ((offset) & 1023) * 512;
@@ -243,6 +255,7 @@ static inline uint64_t CVMX_PKO_DQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280030ull) + ((offset) & 1023) * 512;
@@ -254,6 +267,7 @@ static inline uint64_t CVMX_PKO_DQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400002800E0ull) + ((offset) & 1023) * 512;
@@ -265,6 +279,7 @@ static inline uint64_t CVMX_PKO_DQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000300000ull) + ((offset) & 1023) * 512;
@@ -276,6 +291,7 @@ static inline uint64_t CVMX_PKO_DQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_BUF_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000E8ull) + ((offset) & 1023) * 512;
@@ -287,6 +303,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CNT(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000F0ull) + ((offset) & 1023) * 512;
@@ -298,6 +315,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL_W1C(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008000F8ull) + ((offset) & 1023) * 512;
@@ -309,6 +327,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL_W1C(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000050ull) + ((offset) & 1023) * 512;
@@ -320,6 +339,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CNT(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000040ull) + ((offset) & 1023) * 512;
@@ -331,6 +351,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL(unsigned long offset)
 static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CTL_W1C(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000048ull) + ((offset) & 1023) * 512;
@@ -342,7 +363,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 #define CVMX_PKO_DQ_CSR_BUS_DEBUG CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400003001F8ull);
 }
@@ -353,7 +374,7 @@ static inline uint64_t CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_DQ_DEBUG CVMX_PKO_DQ_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DQ_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300128ull);
 }
@@ -364,7 +385,7 @@ static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
 #define CVMX_PKO_DRAIN_IRQ CVMX_PKO_DRAIN_IRQ_FUNC()
 static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_DRAIN_IRQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000140ull);
 }
@@ -375,7 +396,7 @@ static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
 #define CVMX_PKO_ENABLE CVMX_PKO_ENABLE_FUNC()
 static inline uint64_t CVMX_PKO_ENABLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_ENABLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000D00008ull);
 }
@@ -386,6 +407,7 @@ static inline uint64_t CVMX_PKO_ENABLE_FUNC(void)
 static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_PKO_FORMATX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900800ull) + ((offset) & 127) * 8;
@@ -397,7 +419,7 @@ static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 #define CVMX_PKO_L1_SQA_DEBUG CVMX_PKO_L1_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080128ull);
 }
@@ -408,7 +430,7 @@ static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L1_SQB_DEBUG CVMX_PKO_L1_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080130ull);
 }
@@ -419,6 +441,7 @@ static inline uint64_t CVMX_PKO_L1_SQB_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L1_SQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000018ull) + ((offset) & 31) * 512;
@@ -430,6 +453,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_DROPPED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000088ull) + ((offset) & 31) * 512;
@@ -441,6 +465,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_DROPPED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000080ull) + ((offset) & 31) * 512;
@@ -452,6 +477,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_GREEN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080058ull) + ((offset) & 31) * 512;
@@ -463,6 +489,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_GREEN_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000B8ull) + ((offset) & 31) * 512;
@@ -474,6 +501,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_GREEN_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000B0ull) + ((offset) & 31) * 512;
@@ -485,6 +513,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_LINK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_LINK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000038ull) + ((offset) & 31) * 512;
@@ -496,6 +525,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_LINK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080070ull) + ((offset) & 31) * 512;
@@ -507,6 +537,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_RED(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080068ull) + ((offset) & 31) * 512;
@@ -518,6 +549,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_RED_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000098ull) + ((offset) & 31) * 512;
@@ -529,6 +561,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_RED_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000090ull) + ((offset) & 31) * 512;
@@ -540,6 +573,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED_PACKETS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000008ull) + ((offset) & 31) * 512;
@@ -551,6 +585,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000010ull) + ((offset) & 31) * 512;
@@ -562,6 +597,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000000030ull) + ((offset) & 31) * 512;
@@ -573,6 +609,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000E0ull) + ((offset) & 31) * 512;
@@ -584,6 +621,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080000ull) + ((offset) & 31) * 512;
@@ -595,6 +633,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080060ull) + ((offset) & 31) * 512;
@@ -606,6 +645,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_BYTES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW_BYTES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000A8ull) + ((offset) & 31) * 512;
@@ -617,6 +657,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_BYTES(unsigned long offset)
 static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW_PACKETS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000000A0ull) + ((offset) & 31) * 512;
@@ -628,7 +669,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 #define CVMX_PKO_L1_SQ_CSR_BUS_DEBUG CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L1_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000801F8ull);
 }
@@ -639,7 +680,7 @@ static inline uint64_t CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_L2_SQA_DEBUG CVMX_PKO_L2_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100128ull);
 }
@@ -650,7 +691,7 @@ static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L2_SQB_DEBUG CVMX_PKO_L2_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100130ull);
 }
@@ -661,6 +702,7 @@ static inline uint64_t CVMX_PKO_L2_SQB_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L2_SQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080018ull) + ((offset) & 511) * 512;
@@ -672,6 +714,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_GREEN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100058ull) + ((offset) & 511) * 512;
@@ -683,6 +726,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_GREEN(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100070ull) + ((offset) & 511) * 512;
@@ -694,6 +738,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_PIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080020ull) + ((offset) & 511) * 512;
@@ -705,6 +750,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_PIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080078ull) + ((offset) & 511) * 512;
@@ -716,6 +762,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_POINTERS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_RED(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100068ull) + ((offset) & 511) * 512;
@@ -727,6 +774,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_RED(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080008ull) + ((offset) & 511) * 512;
@@ -738,6 +786,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080028ull) + ((offset) & 511) * 512;
@@ -749,6 +798,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SCHED_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080010ull) + ((offset) & 511) * 512;
@@ -760,6 +810,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080030ull) + ((offset) & 511) * 512;
@@ -771,6 +822,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400000800E0ull) + ((offset) & 511) * 512;
@@ -782,6 +834,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100000ull) + ((offset) & 511) * 512;
@@ -793,6 +846,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_L2_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100060ull) + ((offset) & 511) * 512;
@@ -804,7 +858,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L2_SQ_CSR_BUS_DEBUG CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L2_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400001001F8ull);
 }
@@ -815,6 +869,7 @@ static inline uint64_t CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_L2_SQX_CHANNEL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000080038ull) + ((offset) & 511) * 512;
@@ -826,7 +881,7 @@ static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 #define CVMX_PKO_L3_SQA_DEBUG CVMX_PKO_L3_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180128ull);
 }
@@ -837,7 +892,7 @@ static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L3_SQB_DEBUG CVMX_PKO_L3_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180130ull);
 }
@@ -848,6 +903,7 @@ static inline uint64_t CVMX_PKO_L3_SQB_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L3_SQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100018ull) + ((offset) & 511) * 512;
@@ -859,6 +915,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_GREEN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180058ull) + ((offset) & 511) * 512;
@@ -870,6 +927,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_GREEN(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180070ull) + ((offset) & 511) * 512;
@@ -881,6 +939,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_PIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100020ull) + ((offset) & 511) * 512;
@@ -892,6 +951,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_PIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100078ull) + ((offset) & 511) * 512;
@@ -903,6 +963,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_POINTERS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_RED(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180068ull) + ((offset) & 511) * 512;
@@ -914,6 +975,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_RED(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100008ull) + ((offset) & 511) * 512;
@@ -925,6 +987,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100028ull) + ((offset) & 511) * 512;
@@ -936,6 +999,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SCHED_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100010ull) + ((offset) & 511) * 512;
@@ -947,6 +1011,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000100030ull) + ((offset) & 511) * 512;
@@ -958,6 +1023,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400001000E0ull) + ((offset) & 511) * 512;
@@ -969,6 +1035,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180000ull) + ((offset) & 511) * 512;
@@ -980,6 +1047,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180060ull) + ((offset) & 511) * 512;
@@ -991,7 +1059,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L3_SQ_CSR_BUS_DEBUG CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_L3_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400001801F8ull);
 }
@@ -1354,6 +1422,7 @@ static inline uint64_t CVMX_PKO_L5_SQ_CSR_BUS_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 383))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_LUTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000B00000ull) + ((offset) & 1023) * 8;
@@ -1365,7 +1434,7 @@ static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 #define CVMX_PKO_LUT_BIST_STATUS CVMX_PKO_LUT_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000B02018ull);
 }
@@ -1376,7 +1445,7 @@ static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_LUT_ECC_CTL0 CVMX_PKO_LUT_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFD0ull);
 }
@@ -1387,7 +1456,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_DBE_STS0 CVMX_PKO_LUT_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFF0ull);
 }
@@ -1398,7 +1467,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_DBE_STS_CMB0 CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFD8ull);
 }
@@ -1409,7 +1478,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_SBE_STS0 CVMX_PKO_LUT_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFF8ull);
 }
@@ -1420,7 +1489,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_SBE_STS_CMB0 CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFE8ull);
 }
@@ -1431,6 +1500,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC(void)
 static inline uint64_t CVMX_PKO_MACX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MACX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900000ull) + ((offset) & 31) * 8;
@@ -1464,6 +1534,7 @@ static inline uint64_t CVMX_PKO_MCI0_MAX_CREDX(unsigned long offset)
 static inline uint64_t CVMX_PKO_MCI1_CRED_CNTX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MCI1_CRED_CNTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000A80100ull) + ((offset) & 31) * 8;
@@ -1475,6 +1546,7 @@ static inline uint64_t CVMX_PKO_MCI1_CRED_CNTX(unsigned long offset)
 static inline uint64_t CVMX_PKO_MCI1_MAX_CREDX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MCI1_MAX_CREDX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000A80000ull) + ((offset) & 31) * 8;
@@ -1645,7 +1717,7 @@ static inline uint64_t CVMX_PKO_MEM_THROTTLE_PIPE_FUNC(void)
 #define CVMX_PKO_NCB_BIST_STATUS CVMX_PKO_NCB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_NCB_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFF00ull);
 }
@@ -1656,7 +1728,7 @@ static inline uint64_t CVMX_PKO_NCB_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_NCB_ECC_CTL0 CVMX_PKO_NCB_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFD0ull);
 }
@@ -1667,7 +1739,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_DBE_STS0 CVMX_PKO_NCB_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFF0ull);
 }
@@ -1678,7 +1750,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_DBE_STS_CMB0 CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFD8ull);
 }
@@ -1689,7 +1761,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_SBE_STS0 CVMX_PKO_NCB_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFF8ull);
 }
@@ -1700,7 +1772,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_SBE_STS_CMB0 CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFE8ull);
 }
@@ -1711,7 +1783,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_NCB_INT CVMX_PKO_NCB_INT_FUNC()
 static inline uint64_t CVMX_PKO_NCB_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00010ull);
 }
@@ -1722,7 +1794,7 @@ static inline uint64_t CVMX_PKO_NCB_INT_FUNC(void)
 #define CVMX_PKO_NCB_TX_ERR_INFO CVMX_PKO_NCB_TX_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_NCB_TX_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_TX_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00008ull);
 }
@@ -1733,7 +1805,7 @@ static inline uint64_t CVMX_PKO_NCB_TX_ERR_INFO_FUNC(void)
 #define CVMX_PKO_NCB_TX_ERR_WORD CVMX_PKO_NCB_TX_ERR_WORD_FUNC()
 static inline uint64_t CVMX_PKO_NCB_TX_ERR_WORD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_NCB_TX_ERR_WORD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00000ull);
 }
@@ -1744,7 +1816,7 @@ static inline uint64_t CVMX_PKO_NCB_TX_ERR_WORD_FUNC(void)
 #define CVMX_PKO_PDM_BIST_STATUS CVMX_PKO_PDM_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFF00ull);
 }
@@ -1755,7 +1827,7 @@ static inline uint64_t CVMX_PKO_PDM_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PDM_CFG CVMX_PKO_PDM_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800000ull);
 }
@@ -1766,7 +1838,7 @@ static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 #define CVMX_PKO_PDM_CFG_DBG CVMX_PKO_PDM_CFG_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CFG_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800FF8ull);
 }
@@ -1777,7 +1849,7 @@ static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 #define CVMX_PKO_PDM_CP_DBG CVMX_PKO_PDM_CP_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CP_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_CP_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800190ull);
 }
@@ -1788,6 +1860,7 @@ static inline uint64_t CVMX_PKO_PDM_CP_DBG_FUNC(void)
 static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_PDM_DQX_MINPAD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400008F0000ull) + ((offset) & 1023) * 8;
@@ -1799,7 +1872,7 @@ static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 #define CVMX_PKO_PDM_DRPBUF_DBG CVMX_PKO_PDM_DRPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_DRPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_DRPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000B0ull);
 }
@@ -1810,7 +1883,7 @@ static inline uint64_t CVMX_PKO_PDM_DRPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_DWPBUF_DBG CVMX_PKO_PDM_DWPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_DWPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_DWPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000A8ull);
 }
@@ -1821,7 +1894,7 @@ static inline uint64_t CVMX_PKO_PDM_DWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL0 CVMX_PKO_PDM_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFD0ull);
 }
@@ -1832,7 +1905,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL1 CVMX_PKO_PDM_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFD8ull);
 }
@@ -1843,7 +1916,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
 #define CVMX_PKO_PDM_ECC_DBE_STS0 CVMX_PKO_PDM_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFF0ull);
 }
@@ -1854,7 +1927,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_DBE_STS_CMB0 CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFE0ull);
 }
@@ -1865,7 +1938,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_SBE_STS0 CVMX_PKO_PDM_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFF8ull);
 }
@@ -1876,7 +1949,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_SBE_STS_CMB0 CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFE8ull);
 }
@@ -1887,7 +1960,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG0 CVMX_PKO_PDM_FILLB_DBG0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002A0ull);
 }
@@ -1898,7 +1971,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG0_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG1 CVMX_PKO_PDM_FILLB_DBG1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002A8ull);
 }
@@ -1909,7 +1982,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG1_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG2 CVMX_PKO_PDM_FILLB_DBG2_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002B0ull);
 }
@@ -1920,7 +1993,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG2_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG0 CVMX_PKO_PDM_FLSHB_DBG0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FLSHB_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002B8ull);
 }
@@ -1931,7 +2004,7 @@ static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG0_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG1 CVMX_PKO_PDM_FLSHB_DBG1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_FLSHB_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002C0ull);
 }
@@ -1939,10 +2012,21 @@ static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG1_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG1 (CVMX_ADD_IO_SEG(0x00015400008002C0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PDM_INTF_DBG_RD CVMX_PKO_PDM_INTF_DBG_RD_FUNC()
+static inline uint64_t CVMX_PKO_PDM_INTF_DBG_RD_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKO_PDM_INTF_DBG_RD not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000900F20ull);
+}
+#else
+#define CVMX_PKO_PDM_INTF_DBG_RD (CVMX_ADD_IO_SEG(0x0001540000900F20ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PDM_ISRD_DBG CVMX_PKO_PDM_ISRD_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800090ull);
 }
@@ -1953,7 +2037,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRD_DBG_DQ CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG_DQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800290ull);
 }
@@ -1964,7 +2048,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG CVMX_PKO_PDM_ISRM_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800098ull);
 }
@@ -1975,7 +2059,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG_DQ CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG_DQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800298ull);
 }
@@ -1986,7 +2070,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
 #define CVMX_PKO_PDM_MEM_ADDR CVMX_PKO_PDM_MEM_ADDR_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_ADDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800018ull);
 }
@@ -1997,7 +2081,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 #define CVMX_PKO_PDM_MEM_DATA CVMX_PKO_PDM_MEM_DATA_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800010ull);
 }
@@ -2008,7 +2092,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_DATA_FUNC(void)
 #define CVMX_PKO_PDM_MEM_RW_CTL CVMX_PKO_PDM_MEM_RW_CTL_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_RW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_RW_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800020ull);
 }
@@ -2019,7 +2103,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_RW_CTL_FUNC(void)
 #define CVMX_PKO_PDM_MEM_RW_STS CVMX_PKO_PDM_MEM_RW_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_RW_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_RW_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800028ull);
 }
@@ -2030,7 +2114,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_RW_STS_FUNC(void)
 #define CVMX_PKO_PDM_MWPBUF_DBG CVMX_PKO_PDM_MWPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_MWPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000A0ull);
 }
@@ -2041,7 +2125,7 @@ static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_STS CVMX_PKO_PDM_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PDM_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800008ull);
 }
@@ -2052,7 +2136,7 @@ static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 #define CVMX_PKO_PEB_BIST_STATUS CVMX_PKO_PEB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900D00ull);
 }
@@ -2063,7 +2147,7 @@ static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PEB_ECC_CTL0 CVMX_PKO_PEB_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFD0ull);
 }
@@ -2074,7 +2158,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_CTL1 CVMX_PKO_PEB_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFA8ull);
 }
@@ -2085,7 +2169,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_CTL1_FUNC(void)
 #define CVMX_PKO_PEB_ECC_DBE_STS0 CVMX_PKO_PEB_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFF0ull);
 }
@@ -2096,7 +2180,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_DBE_STS_CMB0 CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFD8ull);
 }
@@ -2107,7 +2191,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS0 CVMX_PKO_PEB_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFF8ull);
 }
@@ -2118,7 +2202,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS_CMB0 CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFE8ull);
 }
@@ -2126,10 +2210,21 @@ static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS_CMB0 (CVMX_ADD_IO_SEG(0x00015400009FFFE8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PEB_ECO CVMX_PKO_PEB_ECO_FUNC()
+static inline uint64_t CVMX_PKO_PEB_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_PKO_PEB_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000901000ull);
+}
+#else
+#define CVMX_PKO_PEB_ECO (CVMX_ADD_IO_SEG(0x0001540000901000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PEB_ERR_INT CVMX_PKO_PEB_ERR_INT_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C00ull);
 }
@@ -2140,7 +2235,7 @@ static inline uint64_t CVMX_PKO_PEB_ERR_INT_FUNC(void)
 #define CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C08ull);
 }
@@ -2151,7 +2246,7 @@ static inline uint64_t CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_FCS_SOP_ERR_INFO CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_FCS_SOP_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C18ull);
 }
@@ -2162,7 +2257,7 @@ static inline uint64_t CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_JUMP_DEF_ERR_INFO CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_JUMP_DEF_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C10ull);
 }
@@ -2173,7 +2268,7 @@ static inline uint64_t CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C50ull);
 }
@@ -2184,7 +2279,7 @@ static inline uint64_t CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_MAX_LINK_ERR_INFO CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_MAX_LINK_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C48ull);
 }
@@ -2195,7 +2290,7 @@ static inline uint64_t CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_NCB_CFG CVMX_PKO_PEB_NCB_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PEB_NCB_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_NCB_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900308ull);
 }
@@ -2206,7 +2301,7 @@ static inline uint64_t CVMX_PKO_PEB_NCB_CFG_FUNC(void)
 #define CVMX_PKO_PEB_PAD_ERR_INFO CVMX_PKO_PEB_PAD_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_PAD_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_PAD_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C28ull);
 }
@@ -2217,7 +2312,7 @@ static inline uint64_t CVMX_PKO_PEB_PAD_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_PSE_FIFO_ERR_INFO CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_PSE_FIFO_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C20ull);
 }
@@ -2228,7 +2323,7 @@ static inline uint64_t CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C38ull);
 }
@@ -2239,7 +2334,7 @@ static inline uint64_t CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C40ull);
 }
@@ -2250,7 +2345,7 @@ static inline uint64_t CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TRUNC_ERR_INFO CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_TRUNC_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C30ull);
 }
@@ -2261,7 +2356,7 @@ static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TSO_CFG CVMX_PKO_PEB_TSO_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PEB_TSO_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900310ull);
 }
@@ -2272,7 +2367,7 @@ static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
 #define CVMX_PKO_PQA_DEBUG CVMX_PKO_PQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000128ull);
 }
@@ -2283,7 +2378,7 @@ static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 #define CVMX_PKO_PQB_DEBUG CVMX_PKO_PQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000130ull);
 }
@@ -2294,7 +2389,7 @@ static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
 #define CVMX_PKO_PQ_CSR_BUS_DEBUG CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000001F8ull);
 }
@@ -2305,7 +2400,7 @@ static inline uint64_t CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_GREEN CVMX_PKO_PQ_DEBUG_GREEN_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_GREEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000058ull);
 }
@@ -2316,7 +2411,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_LINKS CVMX_PKO_PQ_DEBUG_LINKS_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_LINKS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000068ull);
 }
@@ -2327,7 +2422,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_YELLOW CVMX_PKO_PQ_DEBUG_YELLOW_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_YELLOW not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000060ull);
 }
@@ -2338,7 +2433,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
 #define CVMX_PKO_PSE_DQ_BIST_STATUS CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300138ull);
 }
@@ -2349,7 +2444,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_CTL0 CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300100ull);
 }
@@ -2360,7 +2455,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_DBE_STS0 CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300118ull);
 }
@@ -2371,7 +2466,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300120ull);
 }
@@ -2382,7 +2477,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS0 CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300108ull);
 }
@@ -2393,7 +2488,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300110ull);
 }
@@ -2404,7 +2499,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_BIST_STATUS CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000138ull);
 }
@@ -2415,7 +2510,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_CTL0 CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000100ull);
 }
@@ -2426,7 +2521,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_DBE_STS0 CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000118ull);
 }
@@ -2437,7 +2532,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000120ull);
 }
@@ -2448,7 +2543,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS0 CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000108ull);
 }
@@ -2459,7 +2554,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000110ull);
 }
@@ -2470,7 +2565,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_BIST_STATUS CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080138ull);
 }
@@ -2481,7 +2576,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_CTL0 CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080100ull);
 }
@@ -2492,7 +2587,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_DBE_STS0 CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080118ull);
 }
@@ -2503,7 +2598,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080120ull);
 }
@@ -2514,7 +2609,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS0 CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080108ull);
 }
@@ -2525,7 +2620,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080110ull);
 }
@@ -2536,7 +2631,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_BIST_STATUS CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100138ull);
 }
@@ -2547,7 +2642,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_CTL0 CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100100ull);
 }
@@ -2558,7 +2653,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_DBE_STS0 CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100118ull);
 }
@@ -2569,7 +2664,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100120ull);
 }
@@ -2580,7 +2675,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS0 CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100108ull);
 }
@@ -2591,7 +2686,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100110ull);
 }
@@ -2602,7 +2697,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_BIST_STATUS CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180138ull);
 }
@@ -2613,7 +2708,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_CTL0 CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180100ull);
 }
@@ -2624,7 +2719,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_DBE_STS0 CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180118ull);
 }
@@ -2635,7 +2730,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180120ull);
 }
@@ -2646,7 +2741,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS0 CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180108ull);
 }
@@ -2657,7 +2752,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180110ull);
 }
@@ -2800,6 +2895,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_SBE_STS_CMB0_FUNC(void)
 static inline uint64_t CVMX_PKO_PTFX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_PTFX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900100ull) + ((offset) & 31) * 8;
@@ -2811,7 +2907,7 @@ static inline uint64_t CVMX_PKO_PTFX_STATUS(unsigned long offset)
 #define CVMX_PKO_PTF_IOBP_CFG CVMX_PKO_PTF_IOBP_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PTF_IOBP_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_PTF_IOBP_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900300ull);
 }
@@ -2822,6 +2918,7 @@ static inline uint64_t CVMX_PKO_PTF_IOBP_CFG_FUNC(void)
 static inline uint64_t CVMX_PKO_PTGFX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_PKO_PTGFX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000900200ull) + ((offset) & 7) * 8;
@@ -3063,7 +3160,7 @@ static inline uint64_t CVMX_PKO_REG_TIMESTAMP_FUNC(void)
 #define CVMX_PKO_SHAPER_CFG CVMX_PKO_SHAPER_CFG_FUNC()
 static inline uint64_t CVMX_PKO_SHAPER_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_SHAPER_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000800F8ull);
 }
@@ -3071,16 +3168,38 @@ static inline uint64_t CVMX_PKO_SHAPER_CFG_FUNC(void)
 #define CVMX_PKO_SHAPER_CFG (CVMX_ADD_IO_SEG(0x00015400000800F8ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKO_STATE_UID_IN_USEX_RD(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PKO_STATE_UID_IN_USEX_RD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001540000900F00ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_PKO_STATE_UID_IN_USEX_RD(offset) (CVMX_ADD_IO_SEG(0x0001540000900F00ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_STATUS CVMX_PKO_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_PKO_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000D00000ull);
 }
 #else
 #define CVMX_PKO_STATUS (CVMX_ADD_IO_SEG(0x0001540000D00000ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PKO_TXFX_PKT_CNT_RD(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15)))))
+		cvmx_warn("CVMX_PKO_TXFX_PKT_CNT_RD(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001540000900E00ull) + ((offset) & 15) * 8;
+}
+#else
+#define CVMX_PKO_TXFX_PKT_CNT_RD(offset) (CVMX_ADD_IO_SEG(0x0001540000900E00ull) + ((offset) & 15) * 8)
+#endif
 
 /**
  * cvmx_pko_channel_level
@@ -3098,6 +3217,7 @@ union cvmx_pko_channel_level {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_channel_level_s       cn73xx;
 	struct cvmx_pko_channel_level_s       cn78xx;
 };
 typedef union cvmx_pko_channel_level cvmx_pko_channel_level_t;
@@ -3118,6 +3238,7 @@ union cvmx_pko_dpfi_ena {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_dpfi_ena_s            cn73xx;
 	struct cvmx_pko_dpfi_ena_s            cn78xx;
 };
 typedef union cvmx_pko_dpfi_ena cvmx_pko_dpfi_ena_t;
@@ -3140,6 +3261,7 @@ union cvmx_pko_dpfi_flush {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_dpfi_flush_s          cn73xx;
 	struct cvmx_pko_dpfi_flush_s          cn78xx;
 };
 typedef union cvmx_pko_dpfi_flush cvmx_pko_dpfi_flush_t;
@@ -3153,16 +3275,16 @@ union cvmx_pko_dpfi_fpa_aura {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t node                         : 2;  /**< Node number of current chip, to ensure that the aura is on the local node. */
-	uint64_t laura                        : 10; /**< Local aura to use for PKO command buffering. Must be on local CCPI node.
-                                                         The FPA aura selected by LAURA must select an FPA pool whose
-                                                         FPA_POOL()_CFG[NAT_ALIGN]=1, and
-                                                         (FPA_POOL()_CFG[BUF_SIZE] - FPA_POOL()_CFG[BUF_OFFSET]) >= 4 KB/128. */
+	uint64_t laura                        : 10; /**< FPA local-node aura to use for PKO command buffering allocations and frees. The
+                                                         FPA aura selected by LAURA must correspond to a pool where the buffers (after
+                                                         any FPA_POOL()_CFG[BUF_OFFSET]) are at least 4 KB. */
 #else
 	uint64_t laura                        : 10;
 	uint64_t node                         : 2;
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_pko_dpfi_fpa_aura_s       cn73xx;
 	struct cvmx_pko_dpfi_fpa_aura_s       cn78xx;
 };
 typedef union cvmx_pko_dpfi_fpa_aura cvmx_pko_dpfi_fpa_aura_t;
@@ -3213,6 +3335,7 @@ union cvmx_pko_dpfi_status {
 	uint64_t ptr_cnt                      : 32;
 #endif
 	} s;
+	struct cvmx_pko_dpfi_status_s         cn73xx;
 	struct cvmx_pko_dpfi_status_s         cn78xx;
 };
 typedef union cvmx_pko_dpfi_status cvmx_pko_dpfi_status_t;
@@ -3234,6 +3357,7 @@ union cvmx_pko_dqx_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_dqx_bytes_s           cn73xx;
 	struct cvmx_pko_dqx_bytes_s           cn78xx;
 };
 typedef union cvmx_pko_dqx_bytes cvmx_pko_dqx_bytes_t;
@@ -3262,10 +3386,12 @@ union cvmx_pko_dqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -3280,6 +3406,7 @@ union cvmx_pko_dqx_cir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_dqx_cir_s             cn73xx;
 	struct cvmx_pko_dqx_cir_s             cn78xx;
 };
 typedef union cvmx_pko_dqx_cir cvmx_pko_dqx_cir_t;
@@ -3287,7 +3414,7 @@ typedef union cvmx_pko_dqx_cir cvmx_pko_dqx_cir_t;
 /**
  * cvmx_pko_dq#_dropped_bytes
  *
- * This register has the same bit fields as PKO_L1_SQ()_GREEN_BYTES.
+ * This register has the same bit fields as PKO_L1_SQ)_GREEN_BYTES.
  *
  */
 union cvmx_pko_dqx_dropped_bytes {
@@ -3301,6 +3428,7 @@ union cvmx_pko_dqx_dropped_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_dqx_dropped_bytes_s   cn73xx;
 	struct cvmx_pko_dqx_dropped_bytes_s   cn78xx;
 };
 typedef union cvmx_pko_dqx_dropped_bytes cvmx_pko_dqx_dropped_bytes_t;
@@ -3322,6 +3450,7 @@ union cvmx_pko_dqx_dropped_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_dqx_dropped_packets_s cn73xx;
 	struct cvmx_pko_dqx_dropped_packets_s cn78xx;
 };
 typedef union cvmx_pko_dqx_dropped_packets cvmx_pko_dqx_dropped_packets_t;
@@ -3344,6 +3473,7 @@ union cvmx_pko_dqx_fifo {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_pko_dqx_fifo_s            cn73xx;
 	struct cvmx_pko_dqx_fifo_s            cn78xx;
 };
 typedef union cvmx_pko_dqx_fifo cvmx_pko_dqx_fifo_t;
@@ -3365,6 +3495,7 @@ union cvmx_pko_dqx_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_dqx_packets_s         cn73xx;
 	struct cvmx_pko_dqx_packets_s         cn78xx;
 };
 typedef union cvmx_pko_dqx_packets cvmx_pko_dqx_packets_t;
@@ -3372,8 +3503,8 @@ typedef union cvmx_pko_dqx_packets cvmx_pko_dqx_packets_t;
 /**
  * cvmx_pko_dq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the DQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_dqx_pick {
 	uint64_t u64;
@@ -3391,8 +3522,10 @@ union cvmx_pko_dqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -3429,6 +3562,7 @@ union cvmx_pko_dqx_pick {
 	uint64_t dq                           : 10;
 #endif
 	} s;
+	struct cvmx_pko_dqx_pick_s            cn73xx;
 	struct cvmx_pko_dqx_pick_s            cn78xx;
 };
 typedef union cvmx_pko_dqx_pick cvmx_pko_dqx_pick_t;
@@ -3457,10 +3591,12 @@ union cvmx_pko_dqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -3475,6 +3611,7 @@ union cvmx_pko_dqx_pir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_dqx_pir_s             cn73xx;
 	struct cvmx_pko_dqx_pir_s             cn78xx;
 };
 typedef union cvmx_pko_dqx_pir cvmx_pko_dqx_pir_t;
@@ -3482,7 +3619,7 @@ typedef union cvmx_pko_dqx_pir cvmx_pko_dqx_pir_t;
 /**
  * cvmx_pko_dq#_pointers
  *
- * This register has the same bit fields as PKO_L4_SQ()_POINTERS.
+ * This register has the same bit fields as PKO_L3_SQ(0..255)_POINTERS.
  *
  */
 union cvmx_pko_dqx_pointers {
@@ -3500,6 +3637,19 @@ union cvmx_pko_dqx_pointers {
 	uint64_t reserved_26_63               : 38;
 #endif
 	} s;
+	struct cvmx_pko_dqx_pointers_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t prev                         : 8;  /**< Previous pointer. The linked-list previous pointer. */
+	uint64_t reserved_8_15                : 8;
+	uint64_t next                         : 8;  /**< Next pointer. The linked-list next pointer. */
+#else
+	uint64_t next                         : 8;
+	uint64_t reserved_8_15                : 8;
+	uint64_t prev                         : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_dqx_pointers_s        cn78xx;
 };
 typedef union cvmx_pko_dqx_pointers cvmx_pko_dqx_pointers_t;
@@ -3521,6 +3671,7 @@ union cvmx_pko_dqx_sched_state {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_dqx_sched_state_s     cn73xx;
 	struct cvmx_pko_dqx_sched_state_s     cn78xx;
 };
 typedef union cvmx_pko_dqx_sched_state cvmx_pko_dqx_sched_state_t;
@@ -3560,6 +3711,7 @@ union cvmx_pko_dqx_schedule {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_pko_dqx_schedule_s        cn73xx;
 	struct cvmx_pko_dqx_schedule_s        cn78xx;
 };
 typedef union cvmx_pko_dqx_schedule cvmx_pko_dqx_schedule_t;
@@ -3567,7 +3719,7 @@ typedef union cvmx_pko_dqx_schedule cvmx_pko_dqx_schedule_t;
 /**
  * cvmx_pko_dq#_shape
  *
- * This register has the same bit fields as PKO_L5_SQ()_SHAPE.
+ * This register has the same bit fields as PKO_L3_SQ()_SHAPE.
  *
  */
 union cvmx_pko_dqx_shape {
@@ -3592,6 +3744,7 @@ union cvmx_pko_dqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_dqx_shape_s           cn73xx;
 	struct cvmx_pko_dqx_shape_s           cn78xx;
 };
 typedef union cvmx_pko_dqx_shape cvmx_pko_dqx_shape_t;
@@ -3623,6 +3776,7 @@ union cvmx_pko_dqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pko_dqx_shape_state_s     cn73xx;
 	struct cvmx_pko_dqx_shape_state_s     cn78xx;
 };
 typedef union cvmx_pko_dqx_shape_state cvmx_pko_dqx_shape_state_t;
@@ -3638,18 +3792,30 @@ union cvmx_pko_dqx_sw_xoff {
 	struct cvmx_pko_dqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -3658,6 +3824,7 @@ union cvmx_pko_dqx_sw_xoff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pko_dqx_sw_xoff_s         cn73xx;
 	struct cvmx_pko_dqx_sw_xoff_s         cn78xx;
 };
 typedef union cvmx_pko_dqx_sw_xoff cvmx_pko_dqx_sw_xoff_t;
@@ -3678,6 +3845,17 @@ union cvmx_pko_dqx_topology {
 	uint64_t reserved_26_63               : 38;
 #endif
 	} s;
+	struct cvmx_pko_dqx_topology_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t parent                       : 8;  /**< See PKO_L2_SQ()_TOPOLOGY[PARENT]. */
+	uint64_t reserved_0_15                : 16;
+#else
+	uint64_t reserved_0_15                : 16;
+	uint64_t parent                       : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_dqx_topology_s        cn78xx;
 };
 typedef union cvmx_pko_dqx_topology cvmx_pko_dqx_topology_t;
@@ -3690,12 +3868,13 @@ union cvmx_pko_dqx_wm_buf_cnt {
 	struct cvmx_pko_dqx_wm_buf_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t count                        : 36; /**< Watermark buffer count. The running value of the buffer counter. */
+	uint64_t count                        : 36; /**< Reserved. */
 #else
 	uint64_t count                        : 36;
 	uint64_t reserved_36_63               : 28;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_buf_cnt_s      cn73xx;
 	struct cvmx_pko_dqx_wm_buf_cnt_s      cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_buf_cnt cvmx_pko_dqx_wm_buf_cnt_t;
@@ -3708,16 +3887,11 @@ union cvmx_pko_dqx_wm_buf_ctl {
 	struct cvmx_pko_dqx_wm_buf_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t enable                       : 1;  /**< Watermark enable. */
+	uint64_t enable                       : 1;  /**< Reserved. */
 	uint64_t reserved_49_49               : 1;
-	uint64_t intr                         : 1;  /**< Watermark Buffer Interrupt. The interrupt bit is asserted and an interrupt message to the
-                                                         CIU is
-                                                         generated when the specified threshold is reached or crossed. Subsequent interrupt
-                                                         messages are only generated after this bit has been cleared. */
+	uint64_t intr                         : 1;  /**< Reserved. */
 	uint64_t reserved_36_47               : 12;
-	uint64_t threshold                    : 36; /**< Watermark Buffer Threshold. This threshold is compared to the watermark count of
-                                                         PKO_DQ()_WM_BUF_CNT[COUNT] and an interrupt is generated when the count reaches or
-                                                         crosses the threshold. */
+	uint64_t threshold                    : 36; /**< Reserved. */
 #else
 	uint64_t threshold                    : 36;
 	uint64_t reserved_36_47               : 12;
@@ -3727,6 +3901,7 @@ union cvmx_pko_dqx_wm_buf_ctl {
 	uint64_t reserved_51_63               : 13;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_buf_ctl_s      cn73xx;
 	struct cvmx_pko_dqx_wm_buf_ctl_s      cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_buf_ctl cvmx_pko_dqx_wm_buf_ctl_t;
@@ -3739,9 +3914,7 @@ union cvmx_pko_dqx_wm_buf_ctl_w1c {
 	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_49_63               : 15;
-	uint64_t intr                         : 1;  /**< Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is generated
-                                                         when the specified threshold is crossed. Subsequent interrupt messages are only generated
-                                                         after this bit has been cleared by writing 1. Throws PKO_INTSN_E::PKO_DQ()_WM_BUF. */
+	uint64_t intr                         : 1;  /**< Reserved. */
 	uint64_t reserved_0_47                : 48;
 #else
 	uint64_t reserved_0_47                : 48;
@@ -3749,6 +3922,7 @@ union cvmx_pko_dqx_wm_buf_ctl_w1c {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn73xx;
 	struct cvmx_pko_dqx_wm_buf_ctl_w1c_s  cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_buf_ctl_w1c cvmx_pko_dqx_wm_buf_ctl_w1c_t;
@@ -3762,12 +3936,18 @@ union cvmx_pko_dqx_wm_cnt {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t count                        : 48; /**< Watermark count. The running value of the watermark counter. This value is a count of
-                                                         bytes or packets as specified in PKO_DQ()_WM_CTL[KIND]. */
+                                                         bytes or packets as specified by PKO_DQ()_WM_CTL[KIND]. [COUNT] covers all descriptors
+                                                         in the DQ between when the PKO SEND LMTDMA/LMTST enqueues the descriptor until
+                                                         PKO PEB (i.e. the packet engines and FIFO's) first receives the meta descriptor.
+                                                         It includes all descriptors whose meta's are held in either L2/DRAM for the DQ
+                                                         (i.e. whose metas are held in PKO PDM) or any DQ or SQ (i.e. whose metas are held
+                                                         in PKO PSE). */
 #else
 	uint64_t count                        : 48;
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_cnt_s          cn73xx;
 	struct cvmx_pko_dqx_wm_cnt_s          cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_cnt cvmx_pko_dqx_wm_cnt_t;
@@ -3779,10 +3959,40 @@ union cvmx_pko_dqx_wm_ctl {
 	uint64_t u64;
 	struct cvmx_pko_dqx_wm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_52_63               : 12;
+	uint64_t ncb_query_rsp                : 1;  /**< NCB query response.  Specifies what value is returned in the
+                                                         PKO_QUERY_RTN_S[DEPTH] field.  When set to '0', the value held in
+                                                         PKO_DQ()_WM_CNT[COUNT] is returned.  When set to '1 the value held
+                                                         in PKO_DQ()_WM_BUF_CNT[COUNT] is returned. */
+	uint64_t enable                       : 1;  /**< Watermark enable. */
+	uint64_t kind                         : 1;  /**< Selects the contents of PKO_DQ()_WM_CNT[COUNT].
+                                                         If [KIND] is clear, PKO_DQ()_WM_CNT[COUNT] is the byte count in the DQ - the
+                                                         sum of the Meta[LENGTH]'s in the DQ, where Meta[LENGTH] is the Meta packet length.
+                                                         If [KIND] is set, PKO_DQ()_WM_CNT[COUNT] is the number of descriptors in the DQ. */
+	uint64_t intr                         : 1;  /**< Watermark Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is
+                                                         generated when the specified threshold is reached or crossed. Subsequent interrupt
+                                                         messages are only generated after this bit has been cleared. */
+	uint64_t threshold                    : 48; /**< Watermark Threshold. This threshold is compared to the watermark count of
+                                                         PKO_DQ()_WM_CNT[COUNT] and an interrupt is generated when the count reaches or
+                                                         crosses the threshold. */
+#else
+	uint64_t threshold                    : 48;
+	uint64_t intr                         : 1;
+	uint64_t kind                         : 1;
+	uint64_t enable                       : 1;
+	uint64_t ncb_query_rsp                : 1;
+	uint64_t reserved_52_63               : 12;
+#endif
+	} s;
+	struct cvmx_pko_dqx_wm_ctl_s          cn73xx;
+	struct cvmx_pko_dqx_wm_ctl_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
 	uint64_t enable                       : 1;  /**< Watermark enable. */
-	uint64_t kind                         : 1;  /**< Watermark kind. The watermark logic can use a byte count or packet count. 0 = Byte count;
-                                                         1 = Packet count. */
+	uint64_t kind                         : 1;  /**< Selects the contents of PKO_DQ()_WM_CNT[COUNT].
+                                                         If [KIND] is clear, PKO_DQ()_WM_CNT[COUNT] is the byte count in the DQ - the
+                                                         sum of the Meta[LENGTH]'s in the DQ, where Meta[LENGTH] is the Meta packet length.
+                                                         If [KIND] is set, PKO_DQ()_WM_CNT[COUNT] is the number of descriptors in the DQ. */
 	uint64_t intr                         : 1;  /**< Watermark Interrupt. The interrupt bit is asserted and an interrupt message to the CIU is
                                                          generated when the specified threshold is reached or crossed. Subsequent interrupt
                                                          messages are only generated after this bit has been cleared. */
@@ -3796,8 +4006,7 @@ union cvmx_pko_dqx_wm_ctl {
 	uint64_t enable                       : 1;
 	uint64_t reserved_51_63               : 13;
 #endif
-	} s;
-	struct cvmx_pko_dqx_wm_ctl_s          cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_ctl cvmx_pko_dqx_wm_ctl_t;
 
@@ -3819,6 +4028,7 @@ union cvmx_pko_dqx_wm_ctl_w1c {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
+	struct cvmx_pko_dqx_wm_ctl_w1c_s      cn73xx;
 	struct cvmx_pko_dqx_wm_ctl_w1c_s      cn78xx;
 };
 typedef union cvmx_pko_dqx_wm_ctl_w1c cvmx_pko_dqx_wm_ctl_w1c_t;
@@ -3835,6 +4045,7 @@ union cvmx_pko_dq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_dq_csr_bus_debug_s    cn73xx;
 	struct cvmx_pko_dq_csr_bus_debug_s    cn78xx;
 };
 typedef union cvmx_pko_dq_csr_bus_debug cvmx_pko_dq_csr_bus_debug_t;
@@ -3851,6 +4062,7 @@ union cvmx_pko_dq_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_dq_debug_s            cn73xx;
 	struct cvmx_pko_dq_debug_s            cn78xx;
 };
 typedef union cvmx_pko_dq_debug cvmx_pko_dq_debug_t;
@@ -3872,6 +4084,7 @@ union cvmx_pko_drain_irq {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_drain_irq_s           cn73xx;
 	struct cvmx_pko_drain_irq_s           cn78xx;
 };
 typedef union cvmx_pko_drain_irq cvmx_pko_drain_irq_t;
@@ -3890,6 +4103,7 @@ union cvmx_pko_enable {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_enable_s              cn73xx;
 	struct cvmx_pko_enable_s              cn78xx;
 };
 typedef union cvmx_pko_enable cvmx_pko_enable_t;
@@ -3904,18 +4118,15 @@ typedef union cvmx_pko_enable cvmx_pko_enable_t;
  *
  * For example, if MARKPTR is 3 and [OFFSET] is 5 and the packet is YELLOW,
  * the PKO marking hardware would do this:
- *
- * _  byte[3]<2:0> |=   Y_VAL<3:1>
- * _  byte[3]<2:0> &= ~Y_MASK<3:1>
- * _  byte[4]<7>   |=   Y_VAL<0>
- * _  byte[4]<7>   &= ~Y_MASK<0>
- *
+ *    byte[3]<2:0> |=   Y_VAL<3:1>
+ *    byte[3]<2:0> &= ~Y_MASK<3:1>
+ *    byte[4]<7>   |=   Y_VAL<0>
+ *    byte[4]<7>   &= ~Y_MASK<0>
  * where byte[3] is the 3rd byte in the packet, and byte[4] the 4th.
  *
  * For another example, if MARKPTR is 3 and [OFFSET] is 0 and the packet is RED_SEND,
- *
- * _   byte[3]<7:4> |=   R_VAL<3:0>
- * _   byte[3]<7:4> &= ~R_MASK<3:0>
+ *    byte[3]<7:4> |=   R_VAL<3:0>
+ *    byte[3]<7:4> &= ~R_MASK<3:0>
  */
 union cvmx_pko_formatx_ctl {
 	uint64_t u64;
@@ -3942,6 +4153,7 @@ union cvmx_pko_formatx_ctl {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_pko_formatx_ctl_s         cn73xx;
 	struct cvmx_pko_formatx_ctl_s         cn78xx;
 };
 typedef union cvmx_pko_formatx_ctl cvmx_pko_formatx_ctl_t;
@@ -3967,10 +4179,12 @@ union cvmx_pko_l1_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -3985,6 +4199,7 @@ union cvmx_pko_l1_sqx_cir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_cir_s          cn73xx;
 	struct cvmx_pko_l1_sqx_cir_s          cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_cir cvmx_pko_l1_sqx_cir_t;
@@ -4006,6 +4221,7 @@ union cvmx_pko_l1_sqx_dropped_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_dropped_bytes_s cn73xx;
 	struct cvmx_pko_l1_sqx_dropped_bytes_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_dropped_bytes cvmx_pko_l1_sqx_dropped_bytes_t;
@@ -4027,6 +4243,7 @@ union cvmx_pko_l1_sqx_dropped_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_dropped_packets_s cn73xx;
 	struct cvmx_pko_l1_sqx_dropped_packets_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_dropped_packets cvmx_pko_l1_sqx_dropped_packets_t;
@@ -4060,6 +4277,7 @@ union cvmx_pko_l1_sqx_green {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_green_s        cn73xx;
 	struct cvmx_pko_l1_sqx_green_s        cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_green cvmx_pko_l1_sqx_green_t;
@@ -4078,6 +4296,7 @@ union cvmx_pko_l1_sqx_green_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_green_bytes_s  cn73xx;
 	struct cvmx_pko_l1_sqx_green_bytes_s  cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_green_bytes cvmx_pko_l1_sqx_green_bytes_t;
@@ -4096,6 +4315,7 @@ union cvmx_pko_l1_sqx_green_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_green_packets_s cn73xx;
 	struct cvmx_pko_l1_sqx_green_packets_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_green_packets cvmx_pko_l1_sqx_green_packets_t;
@@ -4134,12 +4354,44 @@ union cvmx_pko_l1_sqx_link {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_link_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t link                         : 4;  /**< Link index. Must match PKO_L1_SQ()_TOPOLOGY[LINK]. */
+	uint64_t reserved_32_43               : 12;
+	uint64_t cc_word_cnt                  : 20; /**< Channel credit word count. This value, plus 1 MTU, represents the maximum outstanding
+                                                         aggregate word count (words are 16 bytes) for all channels feeding into this PQ. Note that
+                                                         this 20-bit field represents a signed value that decrements towards zero as credits are
+                                                         used. Packets are not allowed to flow when the count is less than zero. As such, the most
+                                                         significant bit should normally be programmed as zero (positive count). This gives a
+                                                         maximum value for this field of 2^19 - 1. */
+	uint64_t cc_packet_cnt                : 10; /**< Channel credit packet count. This value, plus 1, represents the maximum outstanding
+                                                         aggregate packet count for all channels feeding into this PQ. Note that this 10-bit field
+                                                         represents a signed value that decrements towards zero as credits are used. Packets are
+                                                         not allowed to flow when the count is less than zero. As such the most significant bit
+                                                         should normally be programmed as zero (positive count). This gives a maximum value for
+                                                         this field of 2^9 - 1. */
+	uint64_t cc_enable                    : 1;  /**< Channel credit enable. Enables CC_WORD_CNT and CC_PACKET_CNT aggregate credit processing. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t cc_enable                    : 1;
+	uint64_t cc_packet_cnt                : 10;
+	uint64_t cc_word_cnt                  : 20;
+	uint64_t reserved_32_43               : 12;
+	uint64_t link                         : 4;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l1_sqx_link_s         cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_link cvmx_pko_l1_sqx_link_t;
 
 /**
  * cvmx_pko_l1_sq#_pick
+ *
+ * This CSR contains the meta for the L1 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l1_sqx_pick {
 	uint64_t u64;
@@ -4157,8 +4409,10 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -4195,6 +4449,7 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t dq                           : 10;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_pick_s         cn73xx;
 	struct cvmx_pko_l1_sqx_pick_s         cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_pick cvmx_pko_l1_sqx_pick_t;
@@ -4220,6 +4475,7 @@ union cvmx_pko_l1_sqx_red {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_red_s          cn73xx;
 	struct cvmx_pko_l1_sqx_red_s          cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_red cvmx_pko_l1_sqx_red_t;
@@ -4241,6 +4497,7 @@ union cvmx_pko_l1_sqx_red_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_red_bytes_s    cn73xx;
 	struct cvmx_pko_l1_sqx_red_bytes_s    cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_red_bytes cvmx_pko_l1_sqx_red_bytes_t;
@@ -4262,6 +4519,7 @@ union cvmx_pko_l1_sqx_red_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_red_packets_s  cn73xx;
 	struct cvmx_pko_l1_sqx_red_packets_s  cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_red_packets cvmx_pko_l1_sqx_red_packets_t;
@@ -4280,6 +4538,18 @@ union cvmx_pko_l1_sqx_schedule {
 	uint64_t dummy                        : 40;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_schedule_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
+                                                         integer).
+                                                         Typically [RR_QUANTUM] should be at or near the MTU or more (to limit or prevent
+                                                         negative accumulations of the deficit count). */
+#else
+	uint64_t rr_quantum                   : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l1_sqx_schedule_s     cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_schedule cvmx_pko_l1_sqx_schedule_t;
@@ -4306,6 +4576,27 @@ union cvmx_pko_l1_sqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_shape_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
+	uint64_t reserved_17_23               : 7;
+	uint64_t link                         : 4;  /**< Link index. Must match PKO_L1_SQ()_TOPOLOGY[LINK]. */
+	uint64_t reserved_9_12                : 4;
+	uint64_t adjust                       : 9;  /**< Shaping and scheduling calculation adjustment. This 9-bit signed value
+                                                         allows -255 .. 255 bytes to be added to the packet length for rate
+                                                         limiting and scheduling calculations. [ADJUST] value 0x100 should
+                                                         not be used. */
+#else
+	uint64_t adjust                       : 9;
+	uint64_t reserved_9_12                : 4;
+	uint64_t link                         : 4;
+	uint64_t reserved_17_23               : 7;
+	uint64_t length_disable               : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l1_sqx_shape_s        cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_shape cvmx_pko_l1_sqx_shape_t;
@@ -4334,6 +4625,7 @@ union cvmx_pko_l1_sqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_shape_state_s  cn73xx;
 	struct cvmx_pko_l1_sqx_shape_state_s  cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_shape_state cvmx_pko_l1_sqx_shape_state_t;
@@ -4346,18 +4638,30 @@ union cvmx_pko_l1_sqx_sw_xoff {
 	struct cvmx_pko_l1_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -4366,6 +4670,7 @@ union cvmx_pko_l1_sqx_sw_xoff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_sw_xoff_s      cn73xx;
 	struct cvmx_pko_l1_sqx_sw_xoff_s      cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_sw_xoff cvmx_pko_l1_sqx_sw_xoff_t;
@@ -4435,6 +4740,65 @@ union cvmx_pko_l1_sqx_topology {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_topology_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t prio_anchor                  : 8;  /**< Priority Anchor. The base index positioning the static priority child queues of this
+                                                         shaper. A higher-level queue is a child queue of this shaper when its
+                                                         PKO_*_TOPOLOGY[PARENT] selects this shaper, and it further is a static priority child
+                                                         queue when its PKO_*_SQn_SCHEDULE[PRIO] does not equal RR_PRIO. A static priority child
+                                                         queue with priority PRIO must be located at n=PRIO_ANCHOR+PRIO, where
+                                                         PRIO=PKO_*_SQn_SCHEDULE[PRIO]. There can be at most one static priority child queue at
+                                                         each priority. When there are no static priority child queues attached at any priority, or
+                                                         if this shaper isn't used, the hardware does not use PRIO_ANCHOR. In this case, we
+                                                         recommend PRIO_ANCHOR be zero. Note that there are 10 available priorities, 0 through 9,
+                                                         with priority 0 being the highest and priority 9 being the lowest. */
+	uint64_t reserved_20_31               : 12;
+	uint64_t link                         : 4;  /**< Link index. Selects the MAC or NULL FIFO used by the L1 SQ.
+                                                         Legal [LINK] values:
+                                                         <pre>
+                                                                          Relevant
+                                                           [LINK]    PKO_MAC()_CFG CSR    Description
+                                                          -------------------------------------------------
+                                                             0         PKO_MAC0_CFG      LBK loopback
+                                                             1         PKO_MAC1_CFG      DPI packet output
+                                                             2         PKO_MAC2_CFG      BGX0 logical MAC 0
+                                                             3         PKO_MAC3_CFG      BGX0 logical MAC 1
+                                                             4         PKO_MAC4_CFG      BGX0 logical MAC 2
+                                                             5         PKO_MAC5_CFG      BGX0 logical MAC 3
+                                                             6         PKO_MAC6_CFG      BGX1 logical MAC 0
+                                                             7         PKO_MAC7_CFG      BGX1 logical MAC 1
+                                                             8         PKO_MAC8_CFG      BGX1 logical MAC 2
+                                                             9         PKO_MAC9_CFG      BGX1 logical MAC 3
+                                                            10         PKO_MAC10_CFG     BGX2 logical MAC 0
+                                                            11         PKO_MAC11_CFG     BGX2 logical MAC 1
+                                                            12         PKO_MAC12_CFG     BGX2 logical MAC 2
+                                                            13         PKO_MAC13_CFG     BGX2 logical MAC 3
+                                                            14            None           NULL FIFO
+                                                         </pre>
+                                                         When a MAC is used by the L1 SQ, [LINK] must be unique relative to
+                                                         other [LINK]'s. [LINK] should be 14 when the L1 SQ is not used. */
+	uint64_t reserved_5_15                : 11;
+	uint64_t rr_prio                      : 4;  /**< Round-robin priority. The priority assigned to the round-robin scheduler. A higher-level
+                                                         queue is a child queue of this shaper when its PKO_*_TOPOLOGY[PARENT] selects this shaper,
+                                                         and it further is a round robin child queue when its PKO_*_SQn_SCHEDULE[PRIO] equals
+                                                         RR_PRIO. All round-robin queues attached to this shaper must have the same priority. But
+                                                         the number of round-robin child queues attached (at this priority) is limited only by the
+                                                         number of higher-level queues. When this shaper is not used, we recommend RR_PRIO be zero.
+                                                         When a shaper is used, RR_PRIO should be 0xF when there are no priorities with more than
+                                                         one child queue (i.e. when there are no round-robin child queues), and should otherwise be
+                                                         a legal priority (values 0-9). */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t rr_prio                      : 4;
+	uint64_t reserved_5_15                : 11;
+	uint64_t link                         : 4;
+	uint64_t reserved_20_31               : 12;
+	uint64_t prio_anchor                  : 8;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l1_sqx_topology_s     cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_topology cvmx_pko_l1_sqx_topology_t;
@@ -4457,6 +4821,7 @@ union cvmx_pko_l1_sqx_yellow {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_yellow_s       cn73xx;
 	struct cvmx_pko_l1_sqx_yellow_s       cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_yellow cvmx_pko_l1_sqx_yellow_t;
@@ -4478,6 +4843,7 @@ union cvmx_pko_l1_sqx_yellow_bytes {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_yellow_bytes_s cn73xx;
 	struct cvmx_pko_l1_sqx_yellow_bytes_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_yellow_bytes cvmx_pko_l1_sqx_yellow_bytes_t;
@@ -4499,6 +4865,7 @@ union cvmx_pko_l1_sqx_yellow_packets {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqx_yellow_packets_s cn73xx;
 	struct cvmx_pko_l1_sqx_yellow_packets_s cn78xx;
 };
 typedef union cvmx_pko_l1_sqx_yellow_packets cvmx_pko_l1_sqx_yellow_packets_t;
@@ -4515,6 +4882,7 @@ union cvmx_pko_l1_sq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_l1_sq_csr_bus_debug_s cn73xx;
 	struct cvmx_pko_l1_sq_csr_bus_debug_s cn78xx;
 };
 typedef union cvmx_pko_l1_sq_csr_bus_debug cvmx_pko_l1_sq_csr_bus_debug_t;
@@ -4534,6 +4902,7 @@ union cvmx_pko_l1_sqa_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqa_debug_s        cn73xx;
 	struct cvmx_pko_l1_sqa_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l1_sqa_debug cvmx_pko_l1_sqa_debug_t;
@@ -4553,6 +4922,7 @@ union cvmx_pko_l1_sqb_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l1_sqb_debug_s        cn73xx;
 	struct cvmx_pko_l1_sqb_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l1_sqb_debug cvmx_pko_l1_sqb_debug_t;
@@ -4581,10 +4951,12 @@ union cvmx_pko_l2_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -4599,6 +4971,7 @@ union cvmx_pko_l2_sqx_cir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_cir_s          cn73xx;
 	struct cvmx_pko_l2_sqx_cir_s          cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_cir cvmx_pko_l2_sqx_cir_t;
@@ -4635,6 +5008,7 @@ union cvmx_pko_l2_sqx_green {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_green_s        cn73xx;
 	struct cvmx_pko_l2_sqx_green_s        cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_green cvmx_pko_l2_sqx_green_t;
@@ -4642,8 +5016,8 @@ typedef union cvmx_pko_l2_sqx_green cvmx_pko_l2_sqx_green_t;
 /**
  * cvmx_pko_l2_sq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the L2 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l2_sqx_pick {
 	uint64_t u64;
@@ -4661,8 +5035,10 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -4699,6 +5075,7 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t dq                           : 10;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_pick_s         cn73xx;
 	struct cvmx_pko_l2_sqx_pick_s         cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_pick cvmx_pko_l2_sqx_pick_t;
@@ -4727,10 +5104,12 @@ union cvmx_pko_l2_sqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -4745,6 +5124,7 @@ union cvmx_pko_l2_sqx_pir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_pir_s          cn73xx;
 	struct cvmx_pko_l2_sqx_pir_s          cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_pir cvmx_pko_l2_sqx_pir_t;
@@ -4767,8 +5147,21 @@ union cvmx_pko_l2_sqx_pointers {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
-	struct cvmx_pko_l2_sqx_pointers_s     cn78xx;
-};
+	struct cvmx_pko_l2_sqx_pointers_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t prev                         : 8;  /**< Previous pointer. The linked-list previous pointer. */
+	uint64_t reserved_8_15                : 8;
+	uint64_t next                         : 8;  /**< Next pointer. The linked-list next pointer. */
+#else
+	uint64_t next                         : 8;
+	uint64_t reserved_8_15                : 8;
+	uint64_t prev                         : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
+	struct cvmx_pko_l2_sqx_pointers_s     cn78xx;
+};
 typedef union cvmx_pko_l2_sqx_pointers cvmx_pko_l2_sqx_pointers_t;
 
 /**
@@ -4792,6 +5185,7 @@ union cvmx_pko_l2_sqx_red {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_red_s          cn73xx;
 	struct cvmx_pko_l2_sqx_red_s          cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_red cvmx_pko_l2_sqx_red_t;
@@ -4810,6 +5204,7 @@ union cvmx_pko_l2_sqx_sched_state {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_sched_state_s  cn73xx;
 	struct cvmx_pko_l2_sqx_sched_state_s  cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_sched_state cvmx_pko_l2_sqx_sched_state_t;
@@ -4846,6 +5241,7 @@ union cvmx_pko_l2_sqx_schedule {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_schedule_s     cn73xx;
 	struct cvmx_pko_l2_sqx_schedule_s     cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_schedule cvmx_pko_l2_sqx_schedule_t;
@@ -4892,8 +5288,8 @@ union cvmx_pko_l2_sqx_shape {
                                                                affecting any RR_COUNT, CIR_ACCUM, or PIR_ACCUM state, and are then
                                                                discarded by PKO. See also PKO_REDALG_E::DISCARD. */
 	uint64_t adjust                       : 9;  /**< Shaping and scheduling calculation adjustment. This 9-bit signed value allows
-                                                         +/- 256 bytes to be added to the packet length for shaping and scheduling
-                                                         calculations. */
+                                                         -255 .. 255 bytes to be added to the packet length for shaping and scheduling
+                                                         calculations. [ADJUST] value 0x100 should not be used. */
 #else
 	uint64_t adjust                       : 9;
 	uint64_t red_algo                     : 2;
@@ -4904,6 +5300,7 @@ union cvmx_pko_l2_sqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_shape_s        cn73xx;
 	struct cvmx_pko_l2_sqx_shape_s        cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_shape cvmx_pko_l2_sqx_shape_t;
@@ -4932,6 +5329,7 @@ union cvmx_pko_l2_sqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_shape_state_s  cn73xx;
 	struct cvmx_pko_l2_sqx_shape_state_s  cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_shape_state cvmx_pko_l2_sqx_shape_state_t;
@@ -4947,18 +5345,30 @@ union cvmx_pko_l2_sqx_sw_xoff {
 	struct cvmx_pko_l2_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -4967,6 +5377,7 @@ union cvmx_pko_l2_sqx_sw_xoff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_sw_xoff_s      cn73xx;
 	struct cvmx_pko_l2_sqx_sw_xoff_s      cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_sw_xoff cvmx_pko_l2_sqx_sw_xoff_t;
@@ -4999,6 +5410,29 @@ union cvmx_pko_l2_sqx_topology {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_topology_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t prio_anchor                  : 8;  /**< See PKO_L1_SQ()_TOPOLOGY[PRIO_ANCHOR]. */
+	uint64_t reserved_20_31               : 12;
+	uint64_t parent                       : 4;  /**< Parent queue index. The index of the shaping element at the next lower hierarchical level
+                                                         that accepts this shaping element's outputs. Refer to the PKO_*_SQn_TOPOLOGY
+                                                         [PRIO_ANCHOR,RR_PRIO] descriptions for constraints on which child queues can attach to
+                                                         which shapers at the next lower level. When this shaper is unused, we recommend that
+                                                         PARENT be zero. */
+	uint64_t reserved_5_15                : 11;
+	uint64_t rr_prio                      : 4;  /**< See PKO_L1_SQ()_TOPOLOGY[RR_PRIO]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t rr_prio                      : 4;
+	uint64_t reserved_5_15                : 11;
+	uint64_t parent                       : 4;
+	uint64_t reserved_20_31               : 12;
+	uint64_t prio_anchor                  : 8;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l2_sqx_topology_s     cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_topology cvmx_pko_l2_sqx_topology_t;
@@ -5024,6 +5458,7 @@ union cvmx_pko_l2_sqx_yellow {
 	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqx_yellow_s       cn73xx;
 	struct cvmx_pko_l2_sqx_yellow_s       cn78xx;
 };
 typedef union cvmx_pko_l2_sqx_yellow cvmx_pko_l2_sqx_yellow_t;
@@ -5040,6 +5475,7 @@ union cvmx_pko_l2_sq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_l2_sq_csr_bus_debug_s cn73xx;
 	struct cvmx_pko_l2_sq_csr_bus_debug_s cn78xx;
 };
 typedef union cvmx_pko_l2_sq_csr_bus_debug cvmx_pko_l2_sq_csr_bus_debug_t;
@@ -5059,6 +5495,7 @@ union cvmx_pko_l2_sqa_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqa_debug_s        cn73xx;
 	struct cvmx_pko_l2_sqa_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l2_sqa_debug cvmx_pko_l2_sqa_debug_t;
@@ -5078,6 +5515,7 @@ union cvmx_pko_l2_sqb_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l2_sqb_debug_s        cn73xx;
 	struct cvmx_pko_l2_sqb_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l2_sqb_debug cvmx_pko_l2_sqb_debug_t;
@@ -5103,8 +5541,10 @@ union cvmx_pko_l3_l2_sqx_channel {
                                                          count is less than zero. As such the most significant bit should normally be programmed as
                                                          zero (positive count). This gives a maximum value for this field of 2^9 - 1. */
 	uint64_t cc_enable                    : 1;  /**< Channel credit enable. Enables CC_WORD_CNT and CC_PACKET_CNT credit processing. */
-	uint64_t hw_xoff                      : 1;  /**< Hardware XOFF status. The status of hardware XON/XOFF. This is writable to get around LUT
-                                                         issues and for reconfiguration. */
+	uint64_t hw_xoff                      : 1;  /**< Hardware XOFF status. The status of hardware XON/XOFF (i.e. hardware channel
+                                                         backpressure).  This is writable to get around LUT issues and for reconfiguration.
+                                                         [HW_XOFF] should only be set when there is a valid PKO_LUT entry pointing to the SQ
+                                                         which is being backpressured. */
 #else
 	uint64_t hw_xoff                      : 1;
 	uint64_t cc_enable                    : 1;
@@ -5114,6 +5554,7 @@ union cvmx_pko_l3_l2_sqx_channel {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_l3_l2_sqx_channel_s   cn73xx;
 	struct cvmx_pko_l3_l2_sqx_channel_s   cn78xx;
 };
 typedef union cvmx_pko_l3_l2_sqx_channel cvmx_pko_l3_l2_sqx_channel_t;
@@ -5142,10 +5583,12 @@ union cvmx_pko_l3_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -5160,6 +5603,7 @@ union cvmx_pko_l3_sqx_cir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_cir_s          cn73xx;
 	struct cvmx_pko_l3_sqx_cir_s          cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_cir cvmx_pko_l3_sqx_cir_t;
@@ -5185,6 +5629,26 @@ union cvmx_pko_l3_sqx_green {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_green_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_41_63               : 23;
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
+                                                         scheduling queue are active. For internal use only. */
+	uint64_t reserved_18_19               : 2;
+	uint64_t head                         : 8;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t reserved_8_9                 : 2;
+	uint64_t tail                         : 8;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
+#else
+	uint64_t tail                         : 8;
+	uint64_t reserved_8_9                 : 2;
+	uint64_t head                         : 8;
+	uint64_t reserved_18_19               : 2;
+	uint64_t active_vec                   : 20;
+	uint64_t rr_active                    : 1;
+	uint64_t reserved_41_63               : 23;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_green_s        cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_green cvmx_pko_l3_sqx_green_t;
@@ -5192,8 +5656,8 @@ typedef union cvmx_pko_l3_sqx_green cvmx_pko_l3_sqx_green_t;
 /**
  * cvmx_pko_l3_sq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the L3 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l3_sqx_pick {
 	uint64_t u64;
@@ -5211,8 +5675,10 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -5249,6 +5715,7 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t dq                           : 10;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_pick_s         cn73xx;
 	struct cvmx_pko_l3_sqx_pick_s         cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_pick cvmx_pko_l3_sqx_pick_t;
@@ -5256,7 +5723,7 @@ typedef union cvmx_pko_l3_sqx_pick cvmx_pko_l3_sqx_pick_t;
 /**
  * cvmx_pko_l3_sq#_pir
  *
- * This register has the same bit fields as PKO_L1_SQ()_CIR.
+ * This register has the same bit fields as PKO_L1_SQ(0..15)_CIR.
  *
  */
 union cvmx_pko_l3_sqx_pir {
@@ -5277,10 +5744,12 @@ union cvmx_pko_l3_sqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -5295,6 +5764,7 @@ union cvmx_pko_l3_sqx_pir {
 	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_pir_s          cn73xx;
 	struct cvmx_pko_l3_sqx_pir_s          cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_pir cvmx_pko_l3_sqx_pir_t;
@@ -5320,6 +5790,19 @@ union cvmx_pko_l3_sqx_pointers {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_pointers_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t prev                         : 8;  /**< Previous pointer. The linked-list previous pointer. */
+	uint64_t reserved_8_15                : 8;
+	uint64_t next                         : 8;  /**< Next pointer. The linked-list next pointer. */
+#else
+	uint64_t next                         : 8;
+	uint64_t reserved_8_15                : 8;
+	uint64_t prev                         : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_pointers_s     cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_pointers cvmx_pko_l3_sqx_pointers_t;
@@ -5343,6 +5826,19 @@ union cvmx_pko_l3_sqx_red {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_red_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_18_63               : 46;
+	uint64_t head                         : 8;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t reserved_8_9                 : 2;
+	uint64_t tail                         : 8;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
+#else
+	uint64_t tail                         : 8;
+	uint64_t reserved_8_9                 : 2;
+	uint64_t head                         : 8;
+	uint64_t reserved_18_63               : 46;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_red_s          cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_red cvmx_pko_l3_sqx_red_t;
@@ -5350,7 +5846,7 @@ typedef union cvmx_pko_l3_sqx_red cvmx_pko_l3_sqx_red_t;
 /**
  * cvmx_pko_l3_sq#_sched_state
  *
- * This register has the same bit fields as PKO_L2_SQ()_SCHED_STATE.
+ * This register has the same bit fields as PKO_L2_SQ(0..255)_SCHED_STATE.
  *
  */
 union cvmx_pko_l3_sqx_sched_state {
@@ -5364,6 +5860,7 @@ union cvmx_pko_l3_sqx_sched_state {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_sched_state_s  cn73xx;
 	struct cvmx_pko_l3_sqx_sched_state_s  cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_sched_state cvmx_pko_l3_sqx_sched_state_t;
@@ -5403,6 +5900,7 @@ union cvmx_pko_l3_sqx_schedule {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_schedule_s     cn73xx;
 	struct cvmx_pko_l3_sqx_schedule_s     cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_schedule cvmx_pko_l3_sqx_schedule_t;
@@ -5432,6 +5930,7 @@ union cvmx_pko_l3_sqx_shape {
 	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_shape_s        cn73xx;
 	struct cvmx_pko_l3_sqx_shape_s        cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_shape cvmx_pko_l3_sqx_shape_t;
@@ -5463,6 +5962,7 @@ union cvmx_pko_l3_sqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_shape_state_s  cn73xx;
 	struct cvmx_pko_l3_sqx_shape_state_s  cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_shape_state cvmx_pko_l3_sqx_shape_state_t;
@@ -5478,18 +5978,30 @@ union cvmx_pko_l3_sqx_sw_xoff {
 	struct cvmx_pko_l3_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -5498,6 +6010,7 @@ union cvmx_pko_l3_sqx_sw_xoff {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_sw_xoff_s      cn73xx;
 	struct cvmx_pko_l3_sqx_sw_xoff_s      cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_sw_xoff cvmx_pko_l3_sqx_sw_xoff_t;
@@ -5526,6 +6039,25 @@ union cvmx_pko_l3_sqx_topology {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_topology_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t prio_anchor                  : 8;  /**< See PKO_L1_SQ()_TOPOLOGY[PRIO_ANCHOR]. */
+	uint64_t reserved_24_31               : 8;
+	uint64_t parent                       : 8;  /**< See PKO_L2_SQ()_TOPOLOGY[PARENT]. */
+	uint64_t reserved_5_15                : 11;
+	uint64_t rr_prio                      : 4;  /**< See PKO_L1_SQ()_TOPOLOGY[RR_PRIO]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t rr_prio                      : 4;
+	uint64_t reserved_5_15                : 11;
+	uint64_t parent                       : 8;
+	uint64_t reserved_24_31               : 8;
+	uint64_t prio_anchor                  : 8;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_topology_s     cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_topology cvmx_pko_l3_sqx_topology_t;
@@ -5546,6 +6078,19 @@ union cvmx_pko_l3_sqx_yellow {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqx_yellow_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_18_63               : 46;
+	uint64_t head                         : 8;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
+	uint64_t reserved_8_9                 : 2;
+	uint64_t tail                         : 8;  /**< Tail pointer. The index of round-robin linked-list tail. For internal use only. */
+#else
+	uint64_t tail                         : 8;
+	uint64_t reserved_8_9                 : 2;
+	uint64_t head                         : 8;
+	uint64_t reserved_18_63               : 46;
+#endif
+	} cn73xx;
 	struct cvmx_pko_l3_sqx_yellow_s       cn78xx;
 };
 typedef union cvmx_pko_l3_sqx_yellow cvmx_pko_l3_sqx_yellow_t;
@@ -5562,6 +6107,7 @@ union cvmx_pko_l3_sq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_l3_sq_csr_bus_debug_s cn73xx;
 	struct cvmx_pko_l3_sq_csr_bus_debug_s cn78xx;
 };
 typedef union cvmx_pko_l3_sq_csr_bus_debug cvmx_pko_l3_sq_csr_bus_debug_t;
@@ -5581,6 +6127,7 @@ union cvmx_pko_l3_sqa_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqa_debug_s        cn73xx;
 	struct cvmx_pko_l3_sqa_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l3_sqa_debug cvmx_pko_l3_sqa_debug_t;
@@ -5600,6 +6147,7 @@ union cvmx_pko_l3_sqb_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_l3_sqb_debug_s        cn73xx;
 	struct cvmx_pko_l3_sqb_debug_s        cn78xx;
 };
 typedef union cvmx_pko_l3_sqb_debug cvmx_pko_l3_sqb_debug_t;
@@ -5628,10 +6176,12 @@ union cvmx_pko_l4_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -5681,8 +6231,8 @@ typedef union cvmx_pko_l4_sqx_green cvmx_pko_l4_sqx_green_t;
 /**
  * cvmx_pko_l4_sq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the L4 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l4_sqx_pick {
 	uint64_t u64;
@@ -5700,8 +6250,10 @@ union cvmx_pko_l4_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -5766,10 +6318,12 @@ union cvmx_pko_l4_sqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -5967,18 +6521,30 @@ union cvmx_pko_l4_sqx_sw_xoff {
 	struct cvmx_pko_l4_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -6120,10 +6686,12 @@ union cvmx_pko_l5_sqx_cir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -6173,8 +6741,8 @@ typedef union cvmx_pko_l5_sqx_green cvmx_pko_l5_sqx_green_t;
 /**
  * cvmx_pko_l5_sq#_pick
  *
- * This register has the same bit fields as PKO_L1_SQ()_PICK.
- *
+ * This CSR contains the meta for the L5 SQ, and is for debug and reconfiguration
+ * only and should never be written.
  */
 union cvmx_pko_l5_sqx_pick {
 	uint64_t u64;
@@ -6192,8 +6760,10 @@ union cvmx_pko_l5_sqx_pick {
 	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
 	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
 	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Should always be zero. */
-	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
-                                                         the corresponding descriptor. */
+	uint64_t adjust                       : 9;  /**< When [ADJUST] is 0x100, it indicates that this CSR does not contain a valid meta,
+                                                         and all other fields in this CSR are invalid and shouldn't be used.
+                                                         When [ADJUST] is not 0x100, it is the PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero
+                                                         if a PKO_SEND_EXT_S is not present in the corresponding descriptor. */
 	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
                                                          (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
                                                          corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
@@ -6258,10 +6828,12 @@ union cvmx_pko_l5_sqx_pir {
                                                          RATE_DIVIDER_EXPONENT is 0 to 12. Programmed values greater than 12 are treated as 12.
                                                          Note that for the L1-SQs, a time-wheel turn is 96 clocks (SCLK). For the other levels a
                                                          time-wheel turn is 768 clocks (SCLK).
-                                                         For L1_SQ: RATE = (SCLK_FREQUENCY / 96) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 <<RATE_DIVIDER_EXPONENT)
-                                                         For L[5:2]_SQ: RATE = (SCLK_FREQUENCY / 768) * (1.RATE_MANTISSA << RATE_EXPONENT) /
-                                                         (1 << RATE_DIVIDER_EXPONENT) */
+                                                         For L1_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 96) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1
+                                                         <<RATE_DIVIDER_EXPONENT)
+                                                         For L[5:2]_SQ: RATE (bytes/second) =
+                                                           (SCLK_FREQUENCY / 768) * ((1.RATE_MANTISSA) << RATE_EXPONENT) / (1 <<
+                                                         RATE_DIVIDER_EXPONENT) */
 	uint64_t rate_exponent                : 4;  /**< Rate exponent. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t rate_mantissa                : 8;  /**< Rate mantissa. The rate is specified as 1.RATE_MANTISSA << RATE_EXPONENT. */
 	uint64_t enable                       : 1;  /**< Enable. Enables CIR shaping. */
@@ -6459,18 +7031,30 @@ union cvmx_pko_l5_sqx_sw_xoff {
 	struct cvmx_pko_l5_sqx_sw_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed. */
-	uint64_t drain_null_link              : 1;  /**< "Drain null link. Conditions the drain path to drain through the null link (i.e. link
-                                                         28). As such, channel credits, HW_XOFF, and shaping are disabled on the draining path
-                                                         until the path has drained." */
+	uint64_t drain_irq                    : 1;  /**< Drain IRQ. Enables an interrupt that fires when the drain operation has completed.
+                                                         [DRAIN_IRQ] should be set whenever [DRAIN] is, and must not be set
+                                                         when [DRAIN] isn't set. */
+	uint64_t drain_null_link              : 1;  /**< Drain null link. This setting only has effect when the L1 node is
+                                                         mapped to the NULL FIFO.  Conditions the drain path to drain through
+                                                         the NULL FIFO (i.e. link 14). As such, channel credits, HW_XOFF, and
+                                                         shaping are disabled on the draining path until the path has drained.
+                                                         [DRAIN_NULL_LINK] must not be set when [DRAIN] isn't set. */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
-	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
-                                                         register field. Writing to this register field before the associated
-                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
-                                                         XOFF state of the wrong SQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. [DRAIN] need never be
+                                                         set for the SQ1 level, but is useful at all other levels, including the DQ level.
+                                                         PKO_DRAIN_IRQ[INTR] should be clear prior to initiating a [DRAIN]=1 write to this CSR.
+                                                         After [DRAIN] is set for an SQ/DQ, it should not be set again, for this or any other
+                                                         SQ/DQ, until after a 0->1 transition has been observed on PKO_DRAIN_IRQ[INTR]
+                                                         (and/or the PKO_INTSN_E::PKO_PSE_PQ_DRAIN CIU interrupt has occured) and
+                                                         PKO_DRAIN_IRQ[INTR] has been cleared. */
+	uint64_t xoff                         : 1;  /**< XOFF. Stops meta flow out of the SQ/DQ. When [XOFF] is set, the corresponding
+                                                         PKO_*_PICK (i.e. the meta) in the SQ/DQ cannot be transferred to the
+                                                         next level. The corresponding PKO_*_PICK may become valid while [XOFF] is set,
+                                                         but it cannot change from valid to invalid while [XOFF] is set.
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] should normally be configured before
+                                                         [XOFF] is set. Setting [XOFF] before the associated PKO_*_TOPOLOGY[LINK/PARENT]
+                                                         value is configured can result in modifying the software XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
 	uint64_t drain                        : 1;
@@ -6599,25 +7183,20 @@ typedef union cvmx_pko_l5_sqb_debug cvmx_pko_l5_sqb_debug_t;
  *   LINK/   PKI_CHAN_E    Corresponding
  * MAC_NUM   Range         PKO_LUT index   Description
  * -------   -----------   -------------   -----------------
- *    0      0x000-0x03F   0x3C0-0x3FF     LBK Loopback
- *    1      0x100-0x13F   0x380-0x3BF     DPI packet output
- *    2      0x400-0x4FF   0x000-0x0FF     ILK link 0
- *    3      0x500-0x5FF   0x100-0x1FF     ILK link 1
- *    4      0x800-0x80F   0x200-0x20F     BGX0 Logical MAC 0
- *    5      0x810-0x81F   0x210-0x21F     BGX0 Logical MAC 1
- *    6      0x820-0x82F   0x220-0x22F     BGX0 Logical MAC 2
- *    7      0x830-0x83F   0x230-0x23F     BGX0 Logical MAC 3
- *    8      0x900-0x90F   0x240-0x24F     BGX1 Logical MAC 0
- *    9      0x910-0x91F   0x250-0x25F     BGX1 Logical MAC 1
- *   10      0x920-0x92F   0x260-0x26F     BGX1 Logical MAC 2
- *   11      0x930-0x93F   0x270-0x27F     BGX1 Logical MAC 3
- *   12      0xA00-0xA0F   0x280-0x28F     BGX2 Logical MAC 0
- *   13      0xA10-0xA1F   0x290-0x29F     BGX2 Logical MAC 1
- *   ...         ...           ...               ...
- *   24      0xD00-0xD0F   0x340-0x34F     BGX5 Logical MAC 0
- *   25      0xD10-0xD1F   0x350-0x35F     BGX5 Logical MAC 1
- *   26      0xD20-0xD2F   0x360-0x36F     BGX5 Logical MAC 2
- *   27      0xD30-0xD3F   0x370-0x37F     BGX5 Logical MAC 3
+ *     0     0x000-0x03F   0x0C0-0x0FF     LBK Loopback
+ *     1     0x100-0x17F   0x100-0x17F     DPI packet output
+ *     2     0x800-0x80F   0x000-0x00F     BGX0 Logical MAC 0
+ *     3     0x810-0x81F   0x010-0x01F     BGX0 Logical MAC 1
+ *     4     0x820-0x82F   0x020-0x02F     BGX0 Logical MAC 2
+ *     5     0x830-0x83F   0x030-0x03F     BGX0 Logical MAC 3
+ *     6     0x900-0x90F   0x040-0x04F     BGX1 Logical MAC 0
+ *     7     0x910-0x91F   0x050-0x05F     BGX1 Logical MAC 1
+ *     8     0x920-0x92F   0x060-0x06F     BGX1 Logical MAC 2
+ *     9     0x930-0x93F   0x070-0x07F     BGX1 Logical MAC 3
+ *    10     0xA00-0xA0F   0x080-0x08F     BGX2 Logical MAC 0
+ *    11     0xA10-0xA1F   0x090-0x09F     BGX2 Logical MAC 1
+ *    12     0xA20-0xA2F   0x0A0-0x0AF     BGX2 Logical MAC 2
+ *    13     0xA30-0xA3F   0x0B0-0x0BF     BGX2 Logical MAC 3
  * </pre>
  */
 union cvmx_pko_lutx {
@@ -6637,6 +7216,23 @@ union cvmx_pko_lutx {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pko_lutx_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t valid                        : 1;  /**< Declares if the index in the LUT is valid. */
+	uint64_t reserved_13_14               : 2;
+	uint64_t pq_idx                       : 4;  /**< PQ index for channel return processing in the PSE. */
+	uint64_t reserved_8_8                 : 1;
+	uint64_t queue_number                 : 8;  /**< Mapping from this channel to the programmed queue number. */
+#else
+	uint64_t queue_number                 : 8;
+	uint64_t reserved_8_8                 : 1;
+	uint64_t pq_idx                       : 4;
+	uint64_t reserved_13_14               : 2;
+	uint64_t valid                        : 1;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_pko_lutx_s                cn78xx;
 };
 typedef union cvmx_pko_lutx cvmx_pko_lutx_t;
@@ -6655,6 +7251,7 @@ union cvmx_pko_lut_bist_status {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_lut_bist_status_s     cn73xx;
 	struct cvmx_pko_lut_bist_status_s     cn78xx;
 };
 typedef union cvmx_pko_lut_bist_status cvmx_pko_lut_bist_status_t;
@@ -6675,6 +7272,7 @@ union cvmx_pko_lut_ecc_ctl0 {
 	uint64_t c2q_lut_ram_flip             : 2;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_ctl0_s        cn73xx;
 	struct cvmx_pko_lut_ecc_ctl0_s        cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_ctl0 cvmx_pko_lut_ecc_ctl0_t;
@@ -6694,6 +7292,7 @@ union cvmx_pko_lut_ecc_dbe_sts0 {
 	uint64_t c2q_lut_ram_dbe              : 1;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_dbe_sts0_s    cn73xx;
 	struct cvmx_pko_lut_ecc_dbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_dbe_sts0 cvmx_pko_lut_ecc_dbe_sts0_t;
@@ -6716,6 +7315,7 @@ union cvmx_pko_lut_ecc_dbe_sts_cmb0 {
 	uint64_t lut_dbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_lut_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_dbe_sts_cmb0 cvmx_pko_lut_ecc_dbe_sts_cmb0_t;
@@ -6735,6 +7335,7 @@ union cvmx_pko_lut_ecc_sbe_sts0 {
 	uint64_t c2q_lut_ram_sbe              : 1;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_sbe_sts0_s    cn73xx;
 	struct cvmx_pko_lut_ecc_sbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_sbe_sts0 cvmx_pko_lut_ecc_sbe_sts0_t;
@@ -6757,6 +7358,7 @@ union cvmx_pko_lut_ecc_sbe_sts_cmb0 {
 	uint64_t lut_sbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_lut_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_lut_ecc_sbe_sts_cmb0 cvmx_pko_lut_ecc_sbe_sts_cmb0_t;
@@ -6773,19 +7375,18 @@ typedef union cvmx_pko_lut_ecc_sbe_sts_cmb0 cvmx_pko_lut_ecc_sbe_sts_cmb0_t;
  *   ---------------------------------
  *   PKO_MAC0_CFG   LBK loopback
  *   PKO_MAC1_CFG   DPI packet output
- *   PKO_MAC2_CFG   ILK link 0
- *   PKO_MAC3_CFG   ILK link 1
- *   PKO_MAC4_CFG   BGX0 logical MAC 0
- *   PKO_MAC5_CFG   BGX0 logical MAC 1
- *   PKO_MAC6_CFG   BGX0 logical MAC 2
- *   PKO_MAC7_CFG   BGX0 logical MAC 3
- *   PKO_MAC8_CFG   BGX1 logical MAC 0
- *   PKO_MAC9_CFG   BGX1 logical MAC 1
- *   PKO_MAC10_CFG  BGX1 logical MAC 2
- *   PKO_MAC11_CFG  BGX1 logical MAC 3
- *   PKO_MAC12_CFG  BGX2 logical MAC 0
- *   - ...
- *   PKO_MAC27_CFG  BGX5 logical MAC 3
+ *   PKO_MAC2_CFG   BGX0 logical MAC 0
+ *   PKO_MAC3_CFG   BGX0 logical MAC 1
+ *   PKO_MAC4_CFG   BGX0 logical MAC 2
+ *   PKO_MAC5_CFG   BGX0 logical MAC 3
+ *   PKO_MAC6_CFG   BGX1 logical MAC 0
+ *   PKO_MAC7_CFG   BGX1 logical MAC 1
+ *   PKO_MAC8_CFG   BGX1 logical MAC 2
+ *   PKO_MAC9_CFG   BGX1 logical MAC 3
+ *   PKO_MAC10_CFG  BGX2 logical MAC 0
+ *   PKO_MAC11_CFG  BGX2 logical MAC 1
+ *   PKO_MAC12_CFG  BGX2 logical MAC 2
+ *   PKO_MAC13_CFG  BGX2 logical MAC 3
  * </pre>
  */
 union cvmx_pko_macx_cfg {
@@ -6813,6 +7414,7 @@ union cvmx_pko_macx_cfg {
 	uint64_t reserved_17_63               : 47;
 #endif
 	} s;
+	struct cvmx_pko_macx_cfg_s            cn73xx;
 	struct cvmx_pko_macx_cfg_s            cn78xx;
 };
 typedef union cvmx_pko_macx_cfg cvmx_pko_macx_cfg_t;
@@ -6869,6 +7471,7 @@ union cvmx_pko_mci1_cred_cntx {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_pko_mci1_cred_cntx_s      cn73xx;
 	struct cvmx_pko_mci1_cred_cntx_s      cn78xx;
 };
 typedef union cvmx_pko_mci1_cred_cntx cvmx_pko_mci1_cred_cntx_t;
@@ -6888,6 +7491,7 @@ union cvmx_pko_mci1_max_credx {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_pko_mci1_max_credx_s      cn73xx;
 	struct cvmx_pko_mci1_max_credx_s      cn78xx;
 };
 typedef union cvmx_pko_mci1_max_credx cvmx_pko_mci1_max_credx_t;
@@ -8963,9 +9567,11 @@ union cvmx_pko_ncb_bist_status {
 	uint64_t ncbo_pdm_cmd_dat_ram_bist_status : 1;/**< BIST status for NCBO_PDM_CMD_DAT_RAM. */
 	uint64_t ncbi_l2_pdm_pref_ram_bist_status : 1;/**< BIST status for NCBI_L2_PDM_PREF_RAM. */
 	uint64_t ncbo_pp_fif_ram_bist_status  : 1;  /**< BIST status for NCBO_PP_FIF_RAM. */
-	uint64_t reserved_0_58                : 59;
+	uint64_t ncbo_skid_fif_ram_bist_status : 1; /**< Reserved. */
+	uint64_t reserved_0_57                : 58;
 #else
-	uint64_t reserved_0_58                : 59;
+	uint64_t reserved_0_57                : 58;
+	uint64_t ncbo_skid_fif_ram_bist_status : 1;
 	uint64_t ncbo_pp_fif_ram_bist_status  : 1;
 	uint64_t ncbi_l2_pdm_pref_ram_bist_status : 1;
 	uint64_t ncbo_pdm_cmd_dat_ram_bist_status : 1;
@@ -8973,6 +9579,7 @@ union cvmx_pko_ncb_bist_status {
 	uint64_t ncbi_l2_out_ram_bist_status  : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_bist_status_s     cn73xx;
 	struct cvmx_pko_ncb_bist_status_s     cn78xx;
 };
 typedef union cvmx_pko_ncb_bist_status cvmx_pko_ncb_bist_status_t;
@@ -8994,9 +9601,13 @@ union cvmx_pko_ncb_ecc_ctl0 {
 	uint64_t ncbi_l2_pdm_pref_ram_cdis    : 1;  /**< NCBI_L2_PDM_PREF_RAM ECC correction disable. */
 	uint64_t ncbo_pp_fif_ram_flip         : 2;  /**< NCBO_PP_FIF_RAM flip syndrome bits on write. */
 	uint64_t ncbo_pp_fif_ram_cdis         : 1;  /**< NCBO_PP_FIF_RAM ECC correction disable. */
-	uint64_t reserved_0_48                : 49;
+	uint64_t ncbo_skid_fif_ram_flip       : 2;  /**< Reserved. */
+	uint64_t ncbo_skid_fif_ram_cdis       : 1;  /**< Reserved. */
+	uint64_t reserved_0_45                : 46;
 #else
-	uint64_t reserved_0_48                : 49;
+	uint64_t reserved_0_45                : 46;
+	uint64_t ncbo_skid_fif_ram_cdis       : 1;
+	uint64_t ncbo_skid_fif_ram_flip       : 2;
 	uint64_t ncbo_pp_fif_ram_cdis         : 1;
 	uint64_t ncbo_pp_fif_ram_flip         : 2;
 	uint64_t ncbi_l2_pdm_pref_ram_cdis    : 1;
@@ -9009,6 +9620,7 @@ union cvmx_pko_ncb_ecc_ctl0 {
 	uint64_t ncbi_l2_out_ram_flip         : 2;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_ctl0_s        cn73xx;
 	struct cvmx_pko_ncb_ecc_ctl0_s        cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_ctl0 cvmx_pko_ncb_ecc_ctl0_t;
@@ -9030,9 +9642,11 @@ union cvmx_pko_ncb_ecc_dbe_sts0 {
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
 	uint64_t ncbo_pp_fif_ram_dbe          : 1;  /**< Double-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
-	uint64_t reserved_0_58                : 59;
+	uint64_t ncbo_skid_fif_ram_dbe        : 1;  /**< Reserved. */
+	uint64_t reserved_0_57                : 58;
 #else
-	uint64_t reserved_0_58                : 59;
+	uint64_t reserved_0_57                : 58;
+	uint64_t ncbo_skid_fif_ram_dbe        : 1;
 	uint64_t ncbo_pp_fif_ram_dbe          : 1;
 	uint64_t ncbi_l2_pdm_pref_ram_dbe     : 1;
 	uint64_t ncbo_pdm_cmd_dat_ram_dbe     : 1;
@@ -9040,6 +9654,7 @@ union cvmx_pko_ncb_ecc_dbe_sts0 {
 	uint64_t ncbi_l2_out_ram_dbe          : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_dbe_sts0_s    cn73xx;
 	struct cvmx_pko_ncb_ecc_dbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_dbe_sts0 cvmx_pko_ncb_ecc_dbe_sts0_t;
@@ -9054,7 +9669,8 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
 	uint64_t ncb_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_DBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_NCB_ECC_DBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0. INTERNAL: Instances:
+                                                         is set. Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0.
+                                                         INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
@@ -9066,6 +9682,7 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
 	uint64_t ncb_dbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_ncb_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_dbe_sts_cmb0 cvmx_pko_ncb_ecc_dbe_sts_cmb0_t;
@@ -9087,9 +9704,11 @@ union cvmx_pko_ncb_ecc_sbe_sts0 {
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
 	uint64_t ncbo_pp_fif_ram_sbe          : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
-	uint64_t reserved_0_58                : 59;
+	uint64_t ncbo_skid_fif_ram_sbe        : 1;  /**< Reserved. */
+	uint64_t reserved_0_57                : 58;
 #else
-	uint64_t reserved_0_58                : 59;
+	uint64_t reserved_0_57                : 58;
+	uint64_t ncbo_skid_fif_ram_sbe        : 1;
 	uint64_t ncbo_pp_fif_ram_sbe          : 1;
 	uint64_t ncbi_l2_pdm_pref_ram_sbe     : 1;
 	uint64_t ncbo_pdm_cmd_dat_ram_sbe     : 1;
@@ -9097,6 +9716,7 @@ union cvmx_pko_ncb_ecc_sbe_sts0 {
 	uint64_t ncbi_l2_out_ram_sbe          : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_sbe_sts0_s    cn73xx;
 	struct cvmx_pko_ncb_ecc_sbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_sbe_sts0 cvmx_pko_ncb_ecc_sbe_sts0_t;
@@ -9111,7 +9731,8 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
 	uint64_t ncb_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_SBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_NCB_ECC_SBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0. INTERNAL: Instances:
+                                                         is set. Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0.
+                                                         INTERNAL: Instances:
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
                                                          pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
@@ -9123,6 +9744,7 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
 	uint64_t ncb_sbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_ncb_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_ncb_ecc_sbe_sts_cmb0 cvmx_pko_ncb_ecc_sbe_sts_cmb0_t;
@@ -9156,6 +9778,7 @@ union cvmx_pko_ncb_int {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pko_ncb_int_s             cn73xx;
 	struct cvmx_pko_ncb_int_s             cn78xx;
 };
 typedef union cvmx_pko_ncb_int cvmx_pko_ncb_int_t;
@@ -9186,6 +9809,7 @@ union cvmx_pko_ncb_tx_err_info {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pko_ncb_tx_err_info_s     cn73xx;
 	struct cvmx_pko_ncb_tx_err_info_s     cn78xx;
 };
 typedef union cvmx_pko_ncb_tx_err_info cvmx_pko_ncb_tx_err_info_t;
@@ -9204,6 +9828,7 @@ union cvmx_pko_ncb_tx_err_word {
 	uint64_t err_word                     : 64;
 #endif
 	} s;
+	struct cvmx_pko_ncb_tx_err_word_s     cn73xx;
 	struct cvmx_pko_ncb_tx_err_word_s     cn78xx;
 };
 typedef union cvmx_pko_ncb_tx_err_word cvmx_pko_ncb_tx_err_word_t;
@@ -9281,6 +9906,7 @@ union cvmx_pko_pdm_bist_status {
 	uint64_t flshb_cache_lo_ram_bist_status : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_bist_status_s     cn73xx;
 	struct cvmx_pko_pdm_bist_status_s     cn78xx;
 };
 typedef union cvmx_pko_pdm_bist_status cvmx_pko_pdm_bist_status_t;
@@ -9317,6 +9943,7 @@ union cvmx_pko_pdm_cfg {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} s;
+	struct cvmx_pko_pdm_cfg_s             cn73xx;
 	struct cvmx_pko_pdm_cfg_s             cn78xx;
 };
 typedef union cvmx_pko_pdm_cfg cvmx_pko_pdm_cfg_t;
@@ -9338,6 +9965,7 @@ union cvmx_pko_pdm_cfg_dbg {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_pko_pdm_cfg_dbg_s         cn73xx;
 	struct cvmx_pko_pdm_cfg_dbg_s         cn78xx;
 };
 typedef union cvmx_pko_pdm_cfg_dbg cvmx_pko_pdm_cfg_dbg_t;
@@ -9365,6 +9993,7 @@ union cvmx_pko_pdm_cp_dbg {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_pko_pdm_cp_dbg_s          cn73xx;
 	struct cvmx_pko_pdm_cp_dbg_s          cn78xx;
 };
 typedef union cvmx_pko_pdm_cp_dbg cvmx_pko_pdm_cp_dbg_t;
@@ -9387,6 +10016,7 @@ union cvmx_pko_pdm_dqx_minpad {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_pdm_dqx_minpad_s      cn73xx;
 	struct cvmx_pko_pdm_dqx_minpad_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_dqx_minpad cvmx_pko_pdm_dqx_minpad_t;
@@ -9427,6 +10057,7 @@ union cvmx_pko_pdm_drpbuf_dbg {
 	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
+	struct cvmx_pko_pdm_drpbuf_dbg_s      cn73xx;
 	struct cvmx_pko_pdm_drpbuf_dbg_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_drpbuf_dbg cvmx_pko_pdm_drpbuf_dbg_t;
@@ -9481,6 +10112,47 @@ union cvmx_pko_pdm_dwpbuf_dbg {
 	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
+	struct cvmx_pko_pdm_dwpbuf_dbg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t cmd_proc                     : 1;  /**< Command process signal. */
+	uint64_t reserved_46_46               : 1;
+	uint64_t mem_data_val                 : 1;  /**< Memory data valid. */
+	uint64_t insert_np                    : 1;  /**< Next pointer insertion signal. */
+	uint64_t reserved_43_43               : 1;
+	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
+	uint64_t load_val                     : 1;  /**< Load valid signal. */
+	uint64_t rdy                          : 1;  /**< Ready signal. */
+	uint64_t reserved_37_39               : 3;
+	uint64_t mem_rdy                      : 1;  /**< Memory stage ready signal. */
+	uint64_t reserved_19_35               : 17;
+	uint64_t insert_dp                    : 2;  /**< Descriptor insertion signals. */
+	uint64_t reserved_15_16               : 2;
+	uint64_t mem_addr                     : 11; /**< Memory address for pbuf ram. */
+	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
+                                                         0x3 = Low wen.
+                                                         0x2 = Low cen.
+                                                         0x1 = High wen.
+                                                         0x0 = High cen. */
+#else
+	uint64_t mem_en                       : 4;
+	uint64_t mem_addr                     : 11;
+	uint64_t reserved_15_16               : 2;
+	uint64_t insert_dp                    : 2;
+	uint64_t reserved_19_35               : 17;
+	uint64_t mem_rdy                      : 1;
+	uint64_t reserved_37_39               : 3;
+	uint64_t rdy                          : 1;
+	uint64_t load_val                     : 1;
+	uint64_t sel_nxt_ptr                  : 1;
+	uint64_t reserved_43_43               : 1;
+	uint64_t insert_np                    : 1;
+	uint64_t mem_data_val                 : 1;
+	uint64_t reserved_46_46               : 1;
+	uint64_t cmd_proc                     : 1;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pdm_dwpbuf_dbg_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_dwpbuf_dbg cvmx_pko_pdm_dwpbuf_dbg_t;
@@ -9581,6 +10253,91 @@ union cvmx_pko_pdm_ecc_ctl0 {
 	uint64_t flshb_cache_lo_ram_flip      : 2;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t flshb_cache_lo_ram_flip      : 2;  /**< FLSHB_CACHE_LO_RAM flip syndrome bits on write. */
+	uint64_t flshb_cache_lo_ram_cdis      : 1;  /**< FLSHB_CACHE_LO_RAM ECC correction disable. */
+	uint64_t flshb_cache_hi_ram_flip      : 2;  /**< FLSHB_CACHE_HI_RAM flip syndrome bits on write. */
+	uint64_t flshb_cache_hi_ram_cdis      : 1;  /**< FLSHB_CACHE_HI_RAM ECC correction disable. */
+	uint64_t isrm_ca_iinst_ram_flip       : 2;  /**< ISRM_CA_IINST_RAM flip syndrome bits on write. */
+	uint64_t isrm_ca_iinst_ram_cdis       : 1;  /**< ISRM_CA_IINST_RAM ECC correction disable. */
+	uint64_t isrm_ca_cm_ram_flip          : 2;  /**< ISRM_CA_CM_RAM flip syndrome bits on write. */
+	uint64_t isrm_ca_cm_ram_cdis          : 1;  /**< ISRM_CA_CM_RAM ECC correction disable. */
+	uint64_t isrm_st_ram2_flip            : 2;  /**< ISRM_ST_RAM2 flip syndrome bits on write. */
+	uint64_t isrm_st_ram2_cdis            : 1;  /**< ISRM_ST_RAM2 ECC correction disable. */
+	uint64_t isrm_st_ram1_flip            : 2;  /**< ISRM_ST_RAM1 flip syndrome bits on write. */
+	uint64_t isrm_st_ram1_cdis            : 1;  /**< ISRM_ST_RAM1 ECC correction disable. */
+	uint64_t isrm_st_ram0_flip            : 2;  /**< ISRM_ST_RAM0 flip syndrome bits on write. */
+	uint64_t isrm_st_ram0_cdis            : 1;  /**< ISRM_ST_RAM0 ECC correction disable. */
+	uint64_t isrd_st_ram3_flip            : 2;  /**< ISRD_ST_RAM3 flip syndrome bits on write. */
+	uint64_t isrd_st_ram3_cdis            : 1;  /**< ISRD_ST_RAM3 ECC correction disable. */
+	uint64_t isrd_st_ram2_flip            : 2;  /**< ISRD_ST_RAM2 flip syndrome bits on write. */
+	uint64_t isrd_st_ram2_cdis            : 1;  /**< ISRD_ST_RAM2 ECC correction disable. */
+	uint64_t isrd_st_ram1_flip            : 2;  /**< ISRD_ST_RAM1 flip syndrome bits on write. */
+	uint64_t isrd_st_ram1_cdis            : 1;  /**< ISRD_ST_RAM1 ECC correction disable. */
+	uint64_t isrd_st_ram0_flip            : 2;  /**< ISRD_ST_RAM0 flip syndrome bits on write. */
+	uint64_t isrd_st_ram0_cdis            : 1;  /**< ISRD_ST_RAM0 ECC correction disable. */
+	uint64_t drp_hi_ram_flip              : 2;  /**< DRP_HI_RAM flip syndrome bits on write. */
+	uint64_t drp_hi_ram_cdis              : 1;  /**< DRP_HI_RAM ECC correction disable. */
+	uint64_t drp_lo_ram_flip              : 2;  /**< DRP_LO_RAM flip syndrome bits on write. */
+	uint64_t drp_lo_ram_cdis              : 1;  /**< DRP_LO_RAM ECC correction disable. */
+	uint64_t dwp_hi_ram_flip              : 2;  /**< DWP_HI_RAM flip syndrome bits on write. */
+	uint64_t dwp_hi_ram_cdis              : 1;  /**< DWP_HI_RAM ECC correction disable. */
+	uint64_t dwp_lo_ram_flip              : 2;  /**< DWP_LO_RAM flip syndrome bits on write. */
+	uint64_t dwp_lo_ram_cdis              : 1;  /**< DWP_LO_RAM ECC correction disable. */
+	uint64_t reserved_13_18               : 6;
+	uint64_t fillb_m_rsp_ram_hi_flip      : 2;  /**< FILLB_M_RSP_RAM_HI flip syndrome bits on write. */
+	uint64_t fillb_m_rsp_ram_hi_cdis      : 1;  /**< FILLB_M_RSP_RAM_HI ECC correction disable. */
+	uint64_t fillb_m_rsp_ram_lo_flip      : 2;  /**< FILLB_M_RSP_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_m_rsp_ram_lo_cdis      : 1;  /**< FILLB_M_RSP_RAM_LO ECC correction disable. */
+	uint64_t fillb_d_rsp_ram_hi_flip      : 2;  /**< FILLB_D_RSP_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_d_rsp_ram_hi_cdis      : 1;  /**< FILLB_D_RSP_RAM_HI ECC correction disable. */
+	uint64_t fillb_d_rsp_ram_lo_flip      : 2;  /**< FILLB_D_DAT_RAM_LO flip syndrome bits on write. */
+	uint64_t fillb_d_rsp_ram_lo_cdis      : 1;  /**< FILLB_D_RSP_RAM_LO ECC correction disable. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t fillb_d_rsp_ram_lo_cdis      : 1;
+	uint64_t fillb_d_rsp_ram_lo_flip      : 2;
+	uint64_t fillb_d_rsp_ram_hi_cdis      : 1;
+	uint64_t fillb_d_rsp_ram_hi_flip      : 2;
+	uint64_t fillb_m_rsp_ram_lo_cdis      : 1;
+	uint64_t fillb_m_rsp_ram_lo_flip      : 2;
+	uint64_t fillb_m_rsp_ram_hi_cdis      : 1;
+	uint64_t fillb_m_rsp_ram_hi_flip      : 2;
+	uint64_t reserved_13_18               : 6;
+	uint64_t dwp_lo_ram_cdis              : 1;
+	uint64_t dwp_lo_ram_flip              : 2;
+	uint64_t dwp_hi_ram_cdis              : 1;
+	uint64_t dwp_hi_ram_flip              : 2;
+	uint64_t drp_lo_ram_cdis              : 1;
+	uint64_t drp_lo_ram_flip              : 2;
+	uint64_t drp_hi_ram_cdis              : 1;
+	uint64_t drp_hi_ram_flip              : 2;
+	uint64_t isrd_st_ram0_cdis            : 1;
+	uint64_t isrd_st_ram0_flip            : 2;
+	uint64_t isrd_st_ram1_cdis            : 1;
+	uint64_t isrd_st_ram1_flip            : 2;
+	uint64_t isrd_st_ram2_cdis            : 1;
+	uint64_t isrd_st_ram2_flip            : 2;
+	uint64_t isrd_st_ram3_cdis            : 1;
+	uint64_t isrd_st_ram3_flip            : 2;
+	uint64_t isrm_st_ram0_cdis            : 1;
+	uint64_t isrm_st_ram0_flip            : 2;
+	uint64_t isrm_st_ram1_cdis            : 1;
+	uint64_t isrm_st_ram1_flip            : 2;
+	uint64_t isrm_st_ram2_cdis            : 1;
+	uint64_t isrm_st_ram2_flip            : 2;
+	uint64_t isrm_ca_cm_ram_cdis          : 1;
+	uint64_t isrm_ca_cm_ram_flip          : 2;
+	uint64_t isrm_ca_iinst_ram_cdis       : 1;
+	uint64_t isrm_ca_iinst_ram_flip       : 2;
+	uint64_t flshb_cache_hi_ram_cdis      : 1;
+	uint64_t flshb_cache_hi_ram_flip      : 2;
+	uint64_t flshb_cache_lo_ram_cdis      : 1;
+	uint64_t flshb_cache_lo_ram_flip      : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pdm_ecc_ctl0_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_ctl0 cvmx_pko_pdm_ecc_ctl0_t;
@@ -9615,6 +10372,7 @@ union cvmx_pko_pdm_ecc_ctl1 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_ctl1_s        cn73xx;
 	struct cvmx_pko_pdm_ecc_ctl1_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_ctl1 cvmx_pko_pdm_ecc_ctl1_t;
@@ -9702,6 +10460,7 @@ union cvmx_pko_pdm_ecc_dbe_sts0 {
 	uint64_t flshb_cache_lo_ram_dbe       : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_dbe_sts0_s    cn73xx;
 	struct cvmx_pko_pdm_ecc_dbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_dbe_sts0 cvmx_pko_pdm_ecc_dbe_sts0_t;
@@ -9744,6 +10503,7 @@ union cvmx_pko_pdm_ecc_dbe_sts_cmb0 {
 	uint64_t pdm_dbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pdm_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_dbe_sts_cmb0 cvmx_pko_pdm_ecc_dbe_sts_cmb0_t;
@@ -9831,6 +10591,7 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
 	uint64_t flshb_cache_lo_ram_sbe       : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_sbe_sts0_s    cn73xx;
 	struct cvmx_pko_pdm_ecc_sbe_sts0_s    cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_sbe_sts0 cvmx_pko_pdm_ecc_sbe_sts0_t;
@@ -9873,6 +10634,7 @@ union cvmx_pko_pdm_ecc_sbe_sts_cmb0 {
 	uint64_t pdm_sbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pdm_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pdm_ecc_sbe_sts_cmb0 cvmx_pko_pdm_ecc_sbe_sts_cmb0_t;
@@ -9913,6 +10675,7 @@ union cvmx_pko_pdm_fillb_dbg0 {
 	uint64_t reserved_57_63               : 7;
 #endif
 	} s;
+	struct cvmx_pko_pdm_fillb_dbg0_s      cn73xx;
 	struct cvmx_pko_pdm_fillb_dbg0_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_fillb_dbg0 cvmx_pko_pdm_fillb_dbg0_t;
@@ -9953,6 +10716,7 @@ union cvmx_pko_pdm_fillb_dbg1 {
 	uint64_t reserved_57_63               : 7;
 #endif
 	} s;
+	struct cvmx_pko_pdm_fillb_dbg1_s      cn73xx;
 	struct cvmx_pko_pdm_fillb_dbg1_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_fillb_dbg1 cvmx_pko_pdm_fillb_dbg1_t;
@@ -9975,6 +10739,7 @@ union cvmx_pko_pdm_fillb_dbg2 {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_pko_pdm_fillb_dbg2_s      cn73xx;
 	struct cvmx_pko_pdm_fillb_dbg2_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_fillb_dbg2 cvmx_pko_pdm_fillb_dbg2_t;
@@ -10007,6 +10772,7 @@ union cvmx_pko_pdm_flshb_dbg0 {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_pdm_flshb_dbg0_s      cn73xx;
 	struct cvmx_pko_pdm_flshb_dbg0_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_flshb_dbg0 cvmx_pko_pdm_flshb_dbg0_t;
@@ -10025,11 +10791,43 @@ union cvmx_pko_pdm_flshb_dbg1 {
 	uint64_t cam_stdn                     : 32;
 #endif
 	} s;
+	struct cvmx_pko_pdm_flshb_dbg1_s      cn73xx;
 	struct cvmx_pko_pdm_flshb_dbg1_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_flshb_dbg1 cvmx_pko_pdm_flshb_dbg1_t;
 
 /**
+ * cvmx_pko_pdm_intf_dbg_rd
+ *
+ * For diagnostic use only.
+ *
+ */
+union cvmx_pko_pdm_intf_dbg_rd {
+	uint64_t u64;
+	struct cvmx_pko_pdm_intf_dbg_rd_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t in_flight                    : 8;  /**< Number of packets in-flight to PDM. */
+	uint64_t pdm_req_cred_cnt             : 8;  /**< PDM req/ack credit counter. */
+	uint64_t pse_buf_waddr                : 8;  /**< PSE buffer write address. */
+	uint64_t pse_buf_raddr                : 8;  /**< PSE buffer read address. */
+	uint64_t resp_buf_waddr               : 8;  /**< Interface buffer write address. */
+	uint64_t resp_buf_raddr               : 8;  /**< Interface buffer read address. */
+#else
+	uint64_t resp_buf_raddr               : 8;
+	uint64_t resp_buf_waddr               : 8;
+	uint64_t pse_buf_raddr                : 8;
+	uint64_t pse_buf_waddr                : 8;
+	uint64_t pdm_req_cred_cnt             : 8;
+	uint64_t in_flight                    : 8;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_pko_pdm_intf_dbg_rd_s     cn73xx;
+};
+typedef union cvmx_pko_pdm_intf_dbg_rd cvmx_pko_pdm_intf_dbg_rd_t;
+
+/**
  * cvmx_pko_pdm_isrd_dbg
  */
 union cvmx_pko_pdm_isrd_dbg {
@@ -10101,6 +10899,7 @@ union cvmx_pko_pdm_isrd_dbg {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_pdm_isrd_dbg_s        cn73xx;
 	struct cvmx_pko_pdm_isrd_dbg_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_isrd_dbg cvmx_pko_pdm_isrd_dbg_t;
@@ -10131,6 +10930,7 @@ union cvmx_pko_pdm_isrd_dbg_dq {
 	uint64_t reserved_46_63               : 18;
 #endif
 	} s;
+	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn73xx;
 	struct cvmx_pko_pdm_isrd_dbg_dq_s     cn78xx;
 };
 typedef union cvmx_pko_pdm_isrd_dbg_dq cvmx_pko_pdm_isrd_dbg_dq_t;
@@ -10197,6 +10997,7 @@ union cvmx_pko_pdm_isrm_dbg {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_pko_pdm_isrm_dbg_s        cn73xx;
 	struct cvmx_pko_pdm_isrm_dbg_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_isrm_dbg cvmx_pko_pdm_isrm_dbg_t;
@@ -10223,6 +11024,7 @@ union cvmx_pko_pdm_isrm_dbg_dq {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn73xx;
 	struct cvmx_pko_pdm_isrm_dbg_dq_s     cn78xx;
 };
 typedef union cvmx_pko_pdm_isrm_dbg_dq cvmx_pko_pdm_isrm_dbg_dq_t;
@@ -10255,6 +11057,7 @@ union cvmx_pko_pdm_mem_addr {
 	uint64_t memsel                       : 3;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mem_addr_s        cn73xx;
 	struct cvmx_pko_pdm_mem_addr_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_mem_addr cvmx_pko_pdm_mem_addr_t;
@@ -10273,6 +11076,7 @@ union cvmx_pko_pdm_mem_data {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mem_data_s        cn73xx;
 	struct cvmx_pko_pdm_mem_data_s        cn78xx;
 };
 typedef union cvmx_pko_pdm_mem_data cvmx_pko_pdm_mem_data_t;
@@ -10293,6 +11097,7 @@ union cvmx_pko_pdm_mem_rw_ctl {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mem_rw_ctl_s      cn73xx;
 	struct cvmx_pko_pdm_mem_rw_ctl_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_mem_rw_ctl cvmx_pko_pdm_mem_rw_ctl_t;
@@ -10311,6 +11116,7 @@ union cvmx_pko_pdm_mem_rw_sts {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mem_rw_sts_s      cn73xx;
 	struct cvmx_pko_pdm_mem_rw_sts_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_mem_rw_sts cvmx_pko_pdm_mem_rw_sts_t;
@@ -10367,6 +11173,58 @@ union cvmx_pko_pdm_mwpbuf_dbg {
 	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
+	struct cvmx_pko_pdm_mwpbuf_dbg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_49_63               : 15;
+	uint64_t str_proc                     : 1;  /**< Stream process for data streaming. */
+	uint64_t cmd_proc                     : 1;  /**< Command process for memory-type instruction. */
+	uint64_t str_val                      : 1;  /**< streaming valid. */
+	uint64_t mem_data_val                 : 1;  /**< Memory data valid. */
+	uint64_t insert_np                    : 1;  /**< Next pointer insertion. */
+	uint64_t insert_mp                    : 1;  /**< Meta-packet insertion. */
+	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
+	uint64_t load_val                     : 1;  /**< Load valid signal. */
+	uint64_t rdy                          : 1;  /**< Ready signal. */
+	uint64_t cur_state                    : 3;  /**< Stall count value. */
+	uint64_t mem_rdy                      : 1;  /**< Memory stage ready. */
+	uint64_t str_rdy                      : 1;  /**< Streaming logic ready. */
+	uint64_t contention_type              : 2;  /**< Contention detected and type mwpbuf__csr_conflict[1:0] bit 0 - a streamFill followed by a
+                                                         flush (same dq, same dst) bit 1 - a flush followed by a stream (same dq, same dst) */
+	uint64_t reserved_21_32               : 12;
+	uint64_t mem_wen                      : 4;  /**< Memory write enable signals. The order of the bits is:
+                                                         0x3 = wen mem3.
+                                                         0x2 = wen mem2.
+                                                         0x1 = wen mem1.
+                                                         0x0 = wen mem0. */
+	uint64_t reserved_15_16               : 2;
+	uint64_t mem_addr                     : 11; /**< Memory address for pbuf ram. */
+	uint64_t mem_en                       : 4;  /**< Memory chip enable signals. The order of the bits is:
+                                                         0x3 = cen mem3.
+                                                         0x2 = cen mem2.
+                                                         0x1 = cen mem1.
+                                                         0x0 = cen mem0. */
+#else
+	uint64_t mem_en                       : 4;
+	uint64_t mem_addr                     : 11;
+	uint64_t reserved_15_16               : 2;
+	uint64_t mem_wen                      : 4;
+	uint64_t reserved_21_32               : 12;
+	uint64_t contention_type              : 2;
+	uint64_t str_rdy                      : 1;
+	uint64_t mem_rdy                      : 1;
+	uint64_t cur_state                    : 3;
+	uint64_t rdy                          : 1;
+	uint64_t load_val                     : 1;
+	uint64_t sel_nxt_ptr                  : 1;
+	uint64_t insert_mp                    : 1;
+	uint64_t insert_np                    : 1;
+	uint64_t mem_data_val                 : 1;
+	uint64_t str_val                      : 1;
+	uint64_t cmd_proc                     : 1;
+	uint64_t str_proc                     : 1;
+	uint64_t reserved_49_63               : 15;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pdm_mwpbuf_dbg_s      cn78xx;
 };
 typedef union cvmx_pko_pdm_mwpbuf_dbg cvmx_pko_pdm_mwpbuf_dbg_t;
@@ -10459,6 +11317,7 @@ union cvmx_pko_pdm_sts {
 	uint64_t reserved_38_63               : 26;
 #endif
 	} s;
+	struct cvmx_pko_pdm_sts_s             cn73xx;
 	struct cvmx_pko_pdm_sts_s             cn78xx;
 };
 typedef union cvmx_pko_pdm_sts cvmx_pko_pdm_sts_t;
@@ -10528,41 +11387,96 @@ union cvmx_pko_peb_bist_status {
 	uint64_t reserved_26_63               : 38;
 #endif
 	} s;
-	struct cvmx_pko_peb_bist_status_s     cn78xx;
-};
-typedef union cvmx_pko_peb_bist_status cvmx_pko_peb_bist_status_t;
-
-/**
- * cvmx_pko_peb_ecc_ctl0
- */
-union cvmx_pko_peb_ecc_ctl0 {
-	uint64_t u64;
-	struct cvmx_pko_peb_ecc_ctl0_s {
+	struct cvmx_pko_peb_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_flip      : 2;  /**< IOBP1_UID_FIFO_RAM flip syndrome bits on write. */
-	uint64_t iobp1_uid_fifo_ram_cdis      : 1;  /**< IOBP1_UID_FIFO_RAM ECC correction disable. */
-	uint64_t iobp0_fifo_ram_flip          : 2;  /**< IOBP0_FIFO_RAM flip syndrome bits on write. */
-	uint64_t iobp0_fifo_ram_cdis          : 1;  /**< IOBP0_FIFO_RAM ECC correction disable. */
-	uint64_t iobp1_fifo_ram_flip          : 2;  /**< IOBP1_FIFO_RAM flip syndrome bits on write. */
-	uint64_t iobp1_fifo_ram_cdis          : 1;  /**< IOBP1_FIFO_RAM ECC correction disable. */
-	uint64_t pdm_resp_buf_ram_flip        : 2;  /**< PDM_RESP_BUF_RAM flip syndrome bits on write. */
-	uint64_t pdm_resp_buf_ram_cdis        : 1;  /**< PDM_RESP_BUF_RAM ECC correction disable. */
-	uint64_t pdm_pse_buf_ram_flip         : 2;  /**< PDM_PSE_BUF_RAM flip syndrome bits on write. */
-	uint64_t pdm_pse_buf_ram_cdis         : 1;  /**< PDM_PSE_BUF_RAM ECC correction disable. */
-	uint64_t peb_sm_jmp_ram_flip          : 2;  /**< PEB_SM_JMP_RAM flip syndrome bits on write. */
-	uint64_t peb_sm_jmp_ram_cdis          : 1;  /**< PEB_SM_JMP_RAM ECC correction disable. */
-	uint64_t peb_st_inf_ram_flip          : 2;  /**< PEB_ST_INF_RAM flip syndrome bits on write. */
-	uint64_t peb_st_inf_ram_cdis          : 1;  /**< PEB_ST_INF_RAM ECC correction disable. */
-	uint64_t pd_bank3_ram_flip            : 2;  /**< PD_BANK3_RAM flip syndrome bits on write. */
-	uint64_t pd_bank3_ram_cdis            : 1;  /**< PD_BANK3_RAM ECC correction disable. */
-	uint64_t pd_bank2_ram_flip            : 2;  /**< PD_BANK2_RAM flip syndrome bits on write (pass 1 only). */
-	uint64_t pd_bank2_ram_cdis            : 1;  /**< PD_BANK2_RAM ECC correction disable (pass 1 only). */
-	uint64_t pd_bank1_ram_flip            : 2;  /**< PD_BANK1_RAM flip syndrome bits on write (pass 1 only). */
-	uint64_t pd_bank1_ram_cdis            : 1;  /**< PD_BANK1_RAM ECC correction disable (pass 1 only). */
-	uint64_t pd_bank0_ram_flip            : 2;  /**< PD_BANK0_RAM flip syndrome bits on write. */
-	uint64_t pd_bank0_ram_cdis            : 1;  /**< PD_BANK0_RAM ECC correction disable. */
-	uint64_t pd_var_bank_ram_flip         : 2;  /**< PD_VAR_BANK_RAM flip syndrome bits on write. */
-	uint64_t pd_var_bank_ram_cdis         : 1;  /**< PD_VAR_BANK_RAM ECC correction disable. */
+	uint64_t reserved_26_63               : 38;
+	uint64_t add_work_fifo                : 1;  /**< ADD_WORK_FIFO RAM BIST status. */
+	uint64_t pdm_pse_buf_ram              : 1;  /**< PDM_PSE_BUF RAM BIST status. */
+	uint64_t iobp0_fifo_ram               : 1;  /**< IOBP0_FIFO RAM BIST status. */
+	uint64_t iobp1_fifo_ram               : 1;  /**< IOBP1_FIFO RAM BIST status. */
+	uint64_t state_mem0                   : 1;  /**< STATE_MEM0 RAM BIST status. */
+	uint64_t reserved_19_20               : 2;
+	uint64_t state_mem3                   : 1;  /**< STATE_MEM3 RAM BIST status. */
+	uint64_t iobp1_uid_fifo_ram           : 1;  /**< IOBP1_UID_FIFO RAM BIST status. */
+	uint64_t nxt_link_ptr_ram             : 1;  /**< NXT_LINK_PTR RAM BIST status. */
+	uint64_t pd_bank0_ram                 : 1;  /**< PD_BANK0 RAM BIST status. */
+	uint64_t reserved_13_14               : 2;
+	uint64_t pd_bank3_ram                 : 1;  /**< PD_BANK3 RAM BIST status. */
+	uint64_t pd_var_bank_ram              : 1;  /**< PD_VAR_BANK RAM BIST status. */
+	uint64_t pdm_resp_buf_ram             : 1;  /**< PDM_RESP_BUF RAM BIST status. */
+	uint64_t tx_fifo_pkt_ram              : 1;  /**< TX_FIFO_PKT RAM BIST status. */
+	uint64_t tx_fifo_hdr_ram              : 1;  /**< TX_FIFO_HDR RAM BIST status. */
+	uint64_t tx_fifo_crc_ram              : 1;  /**< TX_FIFO_CRC RAM BIST status. */
+	uint64_t ts_addwork_ram               : 1;  /**< TS_ADDWORK RAM BIST status. */
+	uint64_t send_mem_ts_fifo             : 1;  /**< SEND_MEM_TS_FIFO RAM BIST status. */
+	uint64_t send_mem_stdn_fifo           : 1;  /**< SEND_MEM_STDN_FIFO RAM BIST status. */
+	uint64_t send_mem_fifo                : 1;  /**< SEND_MEM_FIFO RAM BIST status. */
+	uint64_t pkt_mrk_ram                  : 1;  /**< PKT_MRK RAM BIST status. */
+	uint64_t peb_st_inf_ram               : 1;  /**< PEB_ST_INF RAM BIST status. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t peb_st_inf_ram               : 1;
+	uint64_t pkt_mrk_ram                  : 1;
+	uint64_t send_mem_fifo                : 1;
+	uint64_t send_mem_stdn_fifo           : 1;
+	uint64_t send_mem_ts_fifo             : 1;
+	uint64_t ts_addwork_ram               : 1;
+	uint64_t tx_fifo_crc_ram              : 1;
+	uint64_t tx_fifo_hdr_ram              : 1;
+	uint64_t tx_fifo_pkt_ram              : 1;
+	uint64_t pdm_resp_buf_ram             : 1;
+	uint64_t pd_var_bank_ram              : 1;
+	uint64_t pd_bank3_ram                 : 1;
+	uint64_t reserved_13_14               : 2;
+	uint64_t pd_bank0_ram                 : 1;
+	uint64_t nxt_link_ptr_ram             : 1;
+	uint64_t iobp1_uid_fifo_ram           : 1;
+	uint64_t state_mem3                   : 1;
+	uint64_t reserved_19_20               : 2;
+	uint64_t state_mem0                   : 1;
+	uint64_t iobp1_fifo_ram               : 1;
+	uint64_t iobp0_fifo_ram               : 1;
+	uint64_t pdm_pse_buf_ram              : 1;
+	uint64_t add_work_fifo                : 1;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} cn73xx;
+	struct cvmx_pko_peb_bist_status_s     cn78xx;
+};
+typedef union cvmx_pko_peb_bist_status cvmx_pko_peb_bist_status_t;
+
+/**
+ * cvmx_pko_peb_ecc_ctl0
+ */
+union cvmx_pko_peb_ecc_ctl0 {
+	uint64_t u64;
+	struct cvmx_pko_peb_ecc_ctl0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_flip      : 2;  /**< IOBP1_UID_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp1_uid_fifo_ram_cdis      : 1;  /**< IOBP1_UID_FIFO_RAM ECC correction disable. */
+	uint64_t iobp0_fifo_ram_flip          : 2;  /**< IOBP0_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp0_fifo_ram_cdis          : 1;  /**< IOBP0_FIFO_RAM ECC correction disable. */
+	uint64_t iobp1_fifo_ram_flip          : 2;  /**< IOBP1_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp1_fifo_ram_cdis          : 1;  /**< IOBP1_FIFO_RAM ECC correction disable. */
+	uint64_t pdm_resp_buf_ram_flip        : 2;  /**< PDM_RESP_BUF_RAM flip syndrome bits on write. */
+	uint64_t pdm_resp_buf_ram_cdis        : 1;  /**< PDM_RESP_BUF_RAM ECC correction disable. */
+	uint64_t pdm_pse_buf_ram_flip         : 2;  /**< PDM_PSE_BUF_RAM flip syndrome bits on write. */
+	uint64_t pdm_pse_buf_ram_cdis         : 1;  /**< PDM_PSE_BUF_RAM ECC correction disable. */
+	uint64_t peb_sm_jmp_ram_flip          : 2;  /**< PEB_SM_JMP_RAM flip syndrome bits on write. */
+	uint64_t peb_sm_jmp_ram_cdis          : 1;  /**< PEB_SM_JMP_RAM ECC correction disable. */
+	uint64_t peb_st_inf_ram_flip          : 2;  /**< PEB_ST_INF_RAM flip syndrome bits on write. */
+	uint64_t peb_st_inf_ram_cdis          : 1;  /**< PEB_ST_INF_RAM ECC correction disable. */
+	uint64_t pd_bank3_ram_flip            : 2;  /**< PD_BANK3_RAM flip syndrome bits on write. */
+	uint64_t pd_bank3_ram_cdis            : 1;  /**< PD_BANK3_RAM ECC correction disable. */
+	uint64_t pd_bank2_ram_flip            : 2;  /**< PD_BANK2_RAM flip syndrome bits on write (pass 1 only). */
+	uint64_t pd_bank2_ram_cdis            : 1;  /**< PD_BANK2_RAM ECC correction disable (pass 1 only). */
+	uint64_t pd_bank1_ram_flip            : 2;  /**< PD_BANK1_RAM flip syndrome bits on write (pass 1 only). */
+	uint64_t pd_bank1_ram_cdis            : 1;  /**< PD_BANK1_RAM ECC correction disable (pass 1 only). */
+	uint64_t pd_bank0_ram_flip            : 2;  /**< PD_BANK0_RAM flip syndrome bits on write. */
+	uint64_t pd_bank0_ram_cdis            : 1;  /**< PD_BANK0_RAM ECC correction disable. */
+	uint64_t pd_var_bank_ram_flip         : 2;  /**< PD_VAR_BANK_RAM flip syndrome bits on write. */
+	uint64_t pd_var_bank_ram_cdis         : 1;  /**< PD_VAR_BANK_RAM ECC correction disable. */
 	uint64_t tx_fifo_crc_ram_flip         : 2;  /**< TX_FIFO_CRC_RAM flip syndrome bits on write. */
 	uint64_t tx_fifo_crc_ram_cdis         : 1;  /**< TX_FIFO_CRC_RAM ECC correction disable. */
 	uint64_t tx_fifo_hdr_ram_flip         : 2;  /**< TX_FIFO_HDR_RAM flip syndrome bits on write. */
@@ -10628,6 +11542,89 @@ union cvmx_pko_peb_ecc_ctl0 {
 	uint64_t iobp1_uid_fifo_ram_flip      : 2;
 #endif
 	} s;
+	struct cvmx_pko_peb_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_flip      : 2;  /**< IOBP1_UID_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp1_uid_fifo_ram_cdis      : 1;  /**< IOBP1_UID_FIFO_RAM ECC correction disable. */
+	uint64_t iobp0_fifo_ram_flip          : 2;  /**< IOBP0_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp0_fifo_ram_cdis          : 1;  /**< IOBP0_FIFO_RAM ECC correction disable. */
+	uint64_t iobp1_fifo_ram_flip          : 2;  /**< IOBP1_FIFO_RAM flip syndrome bits on write. */
+	uint64_t iobp1_fifo_ram_cdis          : 1;  /**< IOBP1_FIFO_RAM ECC correction disable. */
+	uint64_t pdm_resp_buf_ram_flip        : 2;  /**< PDM_RESP_BUF_RAM flip syndrome bits on write. */
+	uint64_t pdm_resp_buf_ram_cdis        : 1;  /**< PDM_RESP_BUF_RAM ECC correction disable. */
+	uint64_t pdm_pse_buf_ram_flip         : 2;  /**< PDM_PSE_BUF_RAM flip syndrome bits on write. */
+	uint64_t pdm_pse_buf_ram_cdis         : 1;  /**< PDM_PSE_BUF_RAM ECC correction disable. */
+	uint64_t reserved_46_48               : 3;
+	uint64_t peb_st_inf_ram_flip          : 2;  /**< PEB_ST_INF_RAM flip syndrome bits on write. */
+	uint64_t peb_st_inf_ram_cdis          : 1;  /**< PEB_ST_INF_RAM ECC correction disable. */
+	uint64_t pd_bank3_ram_flip            : 2;  /**< PD_BANK3_RAM flip syndrome bits on write. */
+	uint64_t pd_bank3_ram_cdis            : 1;  /**< PD_BANK3_RAM ECC correction disable. */
+	uint64_t reserved_34_39               : 6;
+	uint64_t pd_bank0_ram_flip            : 2;  /**< PD_BANK0_RAM flip syndrome bits on write. */
+	uint64_t pd_bank0_ram_cdis            : 1;  /**< PD_BANK0_RAM ECC correction disable. */
+	uint64_t pd_var_bank_ram_flip         : 2;  /**< PD_VAR_BANK_RAM flip syndrome bits on write. */
+	uint64_t pd_var_bank_ram_cdis         : 1;  /**< PD_VAR_BANK_RAM ECC correction disable. */
+	uint64_t tx_fifo_crc_ram_flip         : 2;  /**< TX_FIFO_CRC_RAM flip syndrome bits on write. */
+	uint64_t tx_fifo_crc_ram_cdis         : 1;  /**< TX_FIFO_CRC_RAM ECC correction disable. */
+	uint64_t tx_fifo_hdr_ram_flip         : 2;  /**< TX_FIFO_HDR_RAM flip syndrome bits on write. */
+	uint64_t tx_fifo_hdr_ram_cdis         : 1;  /**< TX_FIFO_HDR_RAM ECC correction disable. */
+	uint64_t tx_fifo_pkt_ram_flip         : 2;  /**< TX_FIFO_PKT_RAM flip syndrome bits on write. */
+	uint64_t tx_fifo_pkt_ram_cdis         : 1;  /**< TX_FIFO_PKT_RAM ECC correction disable. */
+	uint64_t add_work_fifo_flip           : 2;  /**< ADD_WORK_FIFO flip syndrome bits on write. */
+	uint64_t add_work_fifo_cdis           : 1;  /**< ADD_WORK_FIFO ECC correction disable. */
+	uint64_t send_mem_fifo_flip           : 2;  /**< SEND_MEM_FIFO flip syndrome bits on write. */
+	uint64_t send_mem_fifo_cdis           : 1;  /**< SEND_MEM_FIFO ECC correction disable. */
+	uint64_t send_mem_stdn_fifo_flip      : 2;  /**< SEND_MEM_STDN_FIFO flip syndrome bits on write. */
+	uint64_t send_mem_stdn_fifo_cdis      : 1;  /**< SEND_MEM_STDN_FIFO ECC correction disable. */
+	uint64_t send_mem_ts_fifo_flip        : 2;  /**< SEND_MEM_TS_FIFO flip syndrome bits on write. */
+	uint64_t send_mem_ts_fifo_cdis        : 1;  /**< SEND_MEM_TS_FIFO ECC correction disable. */
+	uint64_t nxt_link_ptr_ram_flip        : 2;  /**< NXT_LINK_PTR_RAM flip syndrome bits on write. */
+	uint64_t nxt_link_ptr_ram_cdis        : 1;  /**< NXT_LINK_PTR_RAM ECC correction disable. */
+	uint64_t pkt_mrk_ram_flip             : 2;  /**< PKT_MRK_RAM flip syndrome bits on write. */
+	uint64_t pkt_mrk_ram_cdis             : 1;  /**< PKT_MRK_RAM ECC correction disable. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t pkt_mrk_ram_cdis             : 1;
+	uint64_t pkt_mrk_ram_flip             : 2;
+	uint64_t nxt_link_ptr_ram_cdis        : 1;
+	uint64_t nxt_link_ptr_ram_flip        : 2;
+	uint64_t send_mem_ts_fifo_cdis        : 1;
+	uint64_t send_mem_ts_fifo_flip        : 2;
+	uint64_t send_mem_stdn_fifo_cdis      : 1;
+	uint64_t send_mem_stdn_fifo_flip      : 2;
+	uint64_t send_mem_fifo_cdis           : 1;
+	uint64_t send_mem_fifo_flip           : 2;
+	uint64_t add_work_fifo_cdis           : 1;
+	uint64_t add_work_fifo_flip           : 2;
+	uint64_t tx_fifo_pkt_ram_cdis         : 1;
+	uint64_t tx_fifo_pkt_ram_flip         : 2;
+	uint64_t tx_fifo_hdr_ram_cdis         : 1;
+	uint64_t tx_fifo_hdr_ram_flip         : 2;
+	uint64_t tx_fifo_crc_ram_cdis         : 1;
+	uint64_t tx_fifo_crc_ram_flip         : 2;
+	uint64_t pd_var_bank_ram_cdis         : 1;
+	uint64_t pd_var_bank_ram_flip         : 2;
+	uint64_t pd_bank0_ram_cdis            : 1;
+	uint64_t pd_bank0_ram_flip            : 2;
+	uint64_t reserved_34_39               : 6;
+	uint64_t pd_bank3_ram_cdis            : 1;
+	uint64_t pd_bank3_ram_flip            : 2;
+	uint64_t peb_st_inf_ram_cdis          : 1;
+	uint64_t peb_st_inf_ram_flip          : 2;
+	uint64_t reserved_46_48               : 3;
+	uint64_t pdm_pse_buf_ram_cdis         : 1;
+	uint64_t pdm_pse_buf_ram_flip         : 2;
+	uint64_t pdm_resp_buf_ram_cdis        : 1;
+	uint64_t pdm_resp_buf_ram_flip        : 2;
+	uint64_t iobp1_fifo_ram_cdis          : 1;
+	uint64_t iobp1_fifo_ram_flip          : 2;
+	uint64_t iobp0_fifo_ram_cdis          : 1;
+	uint64_t iobp0_fifo_ram_flip          : 2;
+	uint64_t iobp1_uid_fifo_ram_cdis      : 1;
+	uint64_t iobp1_uid_fifo_ram_flip      : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_peb_ecc_ctl0_s        cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_ctl0 cvmx_pko_peb_ecc_ctl0_t;
@@ -10641,14 +11638,35 @@ union cvmx_pko_peb_ecc_ctl1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ts_addwork_ram_flip          : 2;  /**< TS_ADDWORK_RAM flip syndrome bits on write. */
 	uint64_t ts_addwork_ram_cdis          : 1;  /**< TS_ADDWORK_RAM ECC correction disable. */
+	uint64_t state_mem0_flip              : 2;  /**< STATE_MEM0 flip syndrome bits on write. */
+	uint64_t state_mem0_cdis              : 1;  /**< STATE_MEM0 ECC correction disable. */
+	uint64_t reserved_52_57               : 6;
+	uint64_t state_mem3_flip              : 2;  /**< STATE_MEM3 flip syndrome bits on write. */
+	uint64_t state_mem3_cdis              : 1;  /**< STATE_MEM3 ECC correction disable. */
+	uint64_t reserved_0_48                : 49;
+#else
+	uint64_t reserved_0_48                : 49;
+	uint64_t state_mem3_cdis              : 1;
+	uint64_t state_mem3_flip              : 2;
+	uint64_t reserved_52_57               : 6;
+	uint64_t state_mem0_cdis              : 1;
+	uint64_t state_mem0_flip              : 2;
+	uint64_t ts_addwork_ram_cdis          : 1;
+	uint64_t ts_addwork_ram_flip          : 2;
+#endif
+	} s;
+	struct cvmx_pko_peb_ecc_ctl1_s        cn73xx;
+	struct cvmx_pko_peb_ecc_ctl1_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ts_addwork_ram_flip          : 2;  /**< TS_ADDWORK_RAM flip syndrome bits on write. */
+	uint64_t ts_addwork_ram_cdis          : 1;  /**< TS_ADDWORK_RAM ECC correction disable. */
 	uint64_t reserved_0_60                : 61;
 #else
 	uint64_t reserved_0_60                : 61;
 	uint64_t ts_addwork_ram_cdis          : 1;
 	uint64_t ts_addwork_ram_flip          : 2;
 #endif
-	} s;
-	struct cvmx_pko_peb_ecc_ctl1_s        cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_ctl1 cvmx_pko_peb_ecc_ctl1_t;
 
@@ -10703,6 +11721,163 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
 	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t state_mem0_dbe               : 1;  /**< Double-bit error for STATE_MEM0. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem3_dbe               : 1;  /**< Double-bit error for STATE_MEM3. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t reserved_0_37                : 38;
+#else
+	uint64_t reserved_0_37                : 38;
+	uint64_t state_mem3_dbe               : 1;
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem0_dbe               : 1;
+	uint64_t ts_addwork_ram_dbe           : 1;
+	uint64_t pkt_mrk_ram_dbe              : 1;
+	uint64_t nxt_link_ptr_ram_dbe         : 1;
+	uint64_t send_mem_ts_fifo_dbe         : 1;
+	uint64_t send_mem_stdn_fifo_dbe       : 1;
+	uint64_t send_mem_fifo_dbe            : 1;
+	uint64_t add_work_fifo_dbe            : 1;
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;
+	uint64_t tx_fifo_crc_ram_dbe          : 1;
+	uint64_t pd_var_bank_ram_dbe          : 1;
+	uint64_t pd_bank0_ram_dbe             : 1;
+	uint64_t pd_bank1_ram_dbe             : 1;
+	uint64_t pd_bank2_ram_dbe             : 1;
+	uint64_t pd_bank3_ram_dbe             : 1;
+	uint64_t peb_st_inf_ram_dbe           : 1;
+	uint64_t peb_sm_jmp_ram_dbe           : 1;
+	uint64_t pdm_pse_buf_ram_dbe          : 1;
+	uint64_t pdm_resp_buf_ram_dbe         : 1;
+	uint64_t iobp1_fifo_ram_dbe           : 1;
+	uint64_t iobp0_fifo_ram_dbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
+#endif
+	} s;
+	struct cvmx_pko_peb_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t reserved_58_58               : 1;
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t state_mem0_dbe               : 1;  /**< Double-bit error for STATE_MEM0. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem3_dbe               : 1;  /**< Double-bit error for STATE_MEM3. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t reserved_0_37                : 38;
+#else
+	uint64_t reserved_0_37                : 38;
+	uint64_t state_mem3_dbe               : 1;
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem0_dbe               : 1;
+	uint64_t ts_addwork_ram_dbe           : 1;
+	uint64_t pkt_mrk_ram_dbe              : 1;
+	uint64_t nxt_link_ptr_ram_dbe         : 1;
+	uint64_t send_mem_ts_fifo_dbe         : 1;
+	uint64_t send_mem_stdn_fifo_dbe       : 1;
+	uint64_t send_mem_fifo_dbe            : 1;
+	uint64_t add_work_fifo_dbe            : 1;
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;
+	uint64_t tx_fifo_crc_ram_dbe          : 1;
+	uint64_t pd_var_bank_ram_dbe          : 1;
+	uint64_t pd_bank0_ram_dbe             : 1;
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank3_ram_dbe             : 1;
+	uint64_t peb_st_inf_ram_dbe           : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t pdm_pse_buf_ram_dbe          : 1;
+	uint64_t pdm_resp_buf_ram_dbe         : 1;
+	uint64_t iobp1_fifo_ram_dbe           : 1;
+	uint64_t iobp0_fifo_ram_dbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
+#endif
+	} cn73xx;
+	struct cvmx_pko_peb_ecc_dbe_sts0_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t pd_bank2_ram_dbe             : 1;  /**< Double-bit error for PD_BANK2_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
+	uint64_t pd_bank1_ram_dbe             : 1;  /**< Double-bit error for PD_BANK1_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
 	uint64_t reserved_0_41                : 42;
 #else
 	uint64_t reserved_0_41                : 42;
@@ -10729,8 +11904,7 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	uint64_t iobp0_fifo_ram_dbe           : 1;
 	uint64_t iobp1_uid_fifo_ram_dbe       : 1;
 #endif
-	} s;
-	struct cvmx_pko_peb_ecc_dbe_sts0_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_dbe_sts0 cvmx_pko_peb_ecc_dbe_sts0_t;
 
@@ -10766,22 +11940,180 @@ union cvmx_pko_peb_ecc_dbe_sts_cmb0 {
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
-	uint64_t reserved_0_62                : 63;
-#else
-	uint64_t reserved_0_62                : 63;
-	uint64_t peb_dbe_cmb0                 : 1;
+	uint64_t reserved_0_62                : 63;
+#else
+	uint64_t reserved_0_62                : 63;
+	uint64_t peb_dbe_cmb0                 : 1;
+#endif
+	} s;
+	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn78xx;
+};
+typedef union cvmx_pko_peb_ecc_dbe_sts_cmb0 cvmx_pko_peb_ecc_dbe_sts_cmb0_t;
+
+/**
+ * cvmx_pko_peb_ecc_sbe_sts0
+ */
+union cvmx_pko_peb_ecc_sbe_sts0 {
+	uint64_t u64;
+	struct cvmx_pko_peb_ecc_sbe_sts0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t pd_bank2_ram_sbe             : 1;  /**< Single-bit error for PD_BANK2_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
+	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t state_mem0_sbe               : 1;  /**< Single-bit error for STATE_MEM0. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem3_sbe               : 1;  /**< Single-bit error for STATE_MEM3. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t reserved_0_37                : 38;
+#else
+	uint64_t reserved_0_37                : 38;
+	uint64_t state_mem3_sbe               : 1;
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem0_sbe               : 1;
+	uint64_t ts_addwork_ram_sbe           : 1;
+	uint64_t pkt_mrk_ram_sbe              : 1;
+	uint64_t nxt_link_ptr_ram_sbe         : 1;
+	uint64_t send_mem_ts_fifo_sbe         : 1;
+	uint64_t send_mem_stdn_fifo_sbe       : 1;
+	uint64_t send_mem_fifo_sbe            : 1;
+	uint64_t add_work_fifo_sbe            : 1;
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;
+	uint64_t tx_fifo_crc_ram_sbe          : 1;
+	uint64_t pd_var_bank_ram_sbe          : 1;
+	uint64_t pd_bank0_ram_sbe             : 1;
+	uint64_t pd_bank1_ram_sbe             : 1;
+	uint64_t pd_bank2_ram_sbe             : 1;
+	uint64_t pd_bank3_ram_sbe             : 1;
+	uint64_t peb_st_inf_ram_sbe           : 1;
+	uint64_t peb_sm_jmp_ram_sbe           : 1;
+	uint64_t pdm_pse_buf_ram_sbe          : 1;
+	uint64_t pdm_resp_buf_ram_sbe         : 1;
+	uint64_t iobp1_fifo_ram_sbe           : 1;
+	uint64_t iobp0_fifo_ram_sbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
+#endif
+	} s;
+	struct cvmx_pko_peb_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t reserved_58_58               : 1;
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t state_mem0_sbe               : 1;  /**< Single-bit error for STATE_MEM0. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem3_sbe               : 1;  /**< Single-bit error for STATE_MEM3. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t reserved_0_37                : 38;
+#else
+	uint64_t reserved_0_37                : 38;
+	uint64_t state_mem3_sbe               : 1;
+	uint64_t reserved_39_40               : 2;
+	uint64_t state_mem0_sbe               : 1;
+	uint64_t ts_addwork_ram_sbe           : 1;
+	uint64_t pkt_mrk_ram_sbe              : 1;
+	uint64_t nxt_link_ptr_ram_sbe         : 1;
+	uint64_t send_mem_ts_fifo_sbe         : 1;
+	uint64_t send_mem_stdn_fifo_sbe       : 1;
+	uint64_t send_mem_fifo_sbe            : 1;
+	uint64_t add_work_fifo_sbe            : 1;
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;
+	uint64_t tx_fifo_crc_ram_sbe          : 1;
+	uint64_t pd_var_bank_ram_sbe          : 1;
+	uint64_t pd_bank0_ram_sbe             : 1;
+	uint64_t reserved_54_55               : 2;
+	uint64_t pd_bank3_ram_sbe             : 1;
+	uint64_t peb_st_inf_ram_sbe           : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t pdm_pse_buf_ram_sbe          : 1;
+	uint64_t pdm_resp_buf_ram_sbe         : 1;
+	uint64_t iobp1_fifo_ram_sbe           : 1;
+	uint64_t iobp0_fifo_ram_sbe           : 1;
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
 #endif
-	} s;
-	struct cvmx_pko_peb_ecc_dbe_sts_cmb0_s cn78xx;
-};
-typedef union cvmx_pko_peb_ecc_dbe_sts_cmb0 cvmx_pko_peb_ecc_dbe_sts_cmb0_t;
-
-/**
- * cvmx_pko_peb_ecc_sbe_sts0
- */
-union cvmx_pko_peb_ecc_sbe_sts0 {
-	uint64_t u64;
-	struct cvmx_pko_peb_ecc_sbe_sts0_s {
+	} cn73xx;
+	struct cvmx_pko_peb_ecc_sbe_sts0_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
@@ -10853,8 +12185,7 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	uint64_t iobp0_fifo_ram_sbe           : 1;
 	uint64_t iobp1_uid_fifo_ram_sbe       : 1;
 #endif
-	} s;
-	struct cvmx_pko_peb_ecc_sbe_sts0_s    cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_sbe_sts0 cvmx_pko_peb_ecc_sbe_sts0_t;
 
@@ -10896,11 +12227,30 @@ union cvmx_pko_peb_ecc_sbe_sts_cmb0 {
 	uint64_t peb_sbe_cmb0                 : 1;
 #endif
 	} s;
+	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_peb_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_peb_ecc_sbe_sts_cmb0 cvmx_pko_peb_ecc_sbe_sts_cmb0_t;
 
 /**
+ * cvmx_pko_peb_eco
+ */
+union cvmx_pko_peb_eco {
+	uint64_t u64;
+	struct cvmx_pko_peb_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_pko_peb_eco_s             cn73xx;
+};
+typedef union cvmx_pko_peb_eco cvmx_pko_peb_eco_t;
+
+/**
  * cvmx_pko_peb_err_int
  */
 union cvmx_pko_peb_err_int {
@@ -10941,6 +12291,7 @@ union cvmx_pko_peb_err_int {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_pko_peb_err_int_s         cn73xx;
 	struct cvmx_pko_peb_err_int_s         cn78xx;
 };
 typedef union cvmx_pko_peb_err_int cvmx_pko_peb_err_int_t;
@@ -10963,6 +12314,7 @@ union cvmx_pko_peb_ext_hdr_def_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_ext_hdr_def_err_info_s cn73xx;
 	struct cvmx_pko_peb_ext_hdr_def_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_ext_hdr_def_err_info cvmx_pko_peb_ext_hdr_def_err_info_t;
@@ -10985,6 +12337,7 @@ union cvmx_pko_peb_fcs_sop_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_fcs_sop_err_info_s cn73xx;
 	struct cvmx_pko_peb_fcs_sop_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_fcs_sop_err_info cvmx_pko_peb_fcs_sop_err_info_t;
@@ -11007,6 +12360,7 @@ union cvmx_pko_peb_jump_def_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_jump_def_err_info_s cn73xx;
 	struct cvmx_pko_peb_jump_def_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_jump_def_err_info cvmx_pko_peb_jump_def_err_info_t;
@@ -11027,6 +12381,7 @@ union cvmx_pko_peb_macx_cfg_wr_err_info {
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
+	struct cvmx_pko_peb_macx_cfg_wr_err_info_s cn73xx;
 	struct cvmx_pko_peb_macx_cfg_wr_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_macx_cfg_wr_err_info cvmx_pko_peb_macx_cfg_wr_err_info_t;
@@ -11049,6 +12404,7 @@ union cvmx_pko_peb_max_link_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_max_link_err_info_s cn73xx;
 	struct cvmx_pko_peb_max_link_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_max_link_err_info cvmx_pko_peb_max_link_err_info_t;
@@ -11067,6 +12423,7 @@ union cvmx_pko_peb_ncb_cfg {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pko_peb_ncb_cfg_s         cn73xx;
 	struct cvmx_pko_peb_ncb_cfg_s         cn78xx;
 };
 typedef union cvmx_pko_peb_ncb_cfg cvmx_pko_peb_ncb_cfg_t;
@@ -11089,6 +12446,7 @@ union cvmx_pko_peb_pad_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_pad_err_info_s    cn73xx;
 	struct cvmx_pko_peb_pad_err_info_s    cn78xx;
 };
 typedef union cvmx_pko_peb_pad_err_info cvmx_pko_peb_pad_err_info_t;
@@ -11111,6 +12469,7 @@ union cvmx_pko_peb_pse_fifo_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_pse_fifo_err_info_s cn73xx;
 	struct cvmx_pko_peb_pse_fifo_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_pse_fifo_err_info cvmx_pko_peb_pse_fifo_err_info_t;
@@ -11133,6 +12492,7 @@ union cvmx_pko_peb_subd_addr_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_subd_addr_err_info_s cn73xx;
 	struct cvmx_pko_peb_subd_addr_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_subd_addr_err_info cvmx_pko_peb_subd_addr_err_info_t;
@@ -11155,6 +12515,7 @@ union cvmx_pko_peb_subd_size_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_subd_size_err_info_s cn73xx;
 	struct cvmx_pko_peb_subd_size_err_info_s cn78xx;
 };
 typedef union cvmx_pko_peb_subd_size_err_info cvmx_pko_peb_subd_size_err_info_t;
@@ -11177,6 +12538,7 @@ union cvmx_pko_peb_trunc_err_info {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_peb_trunc_err_info_s  cn73xx;
 	struct cvmx_pko_peb_trunc_err_info_s  cn78xx;
 };
 typedef union cvmx_pko_peb_trunc_err_info cvmx_pko_peb_trunc_err_info_t;
@@ -11203,6 +12565,7 @@ union cvmx_pko_peb_tso_cfg {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_pko_peb_tso_cfg_s         cn73xx;
 	struct cvmx_pko_peb_tso_cfg_s         cn78xx;
 };
 typedef union cvmx_pko_peb_tso_cfg cvmx_pko_peb_tso_cfg_t;
@@ -11219,6 +12582,7 @@ union cvmx_pko_pq_csr_bus_debug {
 	uint64_t csr_bus_debug                : 64;
 #endif
 	} s;
+	struct cvmx_pko_pq_csr_bus_debug_s    cn73xx;
 	struct cvmx_pko_pq_csr_bus_debug_s    cn78xx;
 };
 typedef union cvmx_pko_pq_csr_bus_debug cvmx_pko_pq_csr_bus_debug_t;
@@ -11237,6 +12601,7 @@ union cvmx_pko_pq_debug_green {
 	uint64_t g_valid                      : 32;
 #endif
 	} s;
+	struct cvmx_pko_pq_debug_green_s      cn73xx;
 	struct cvmx_pko_pq_debug_green_s      cn78xx;
 };
 typedef union cvmx_pko_pq_debug_green cvmx_pko_pq_debug_green_t;
@@ -11255,6 +12620,7 @@ union cvmx_pko_pq_debug_links {
 	uint64_t links_ready                  : 32;
 #endif
 	} s;
+	struct cvmx_pko_pq_debug_links_s      cn73xx;
 	struct cvmx_pko_pq_debug_links_s      cn78xx;
 };
 typedef union cvmx_pko_pq_debug_links cvmx_pko_pq_debug_links_t;
@@ -11275,6 +12641,7 @@ union cvmx_pko_pq_debug_yellow {
 	uint64_t y_valid                      : 32;
 #endif
 	} s;
+	struct cvmx_pko_pq_debug_yellow_s     cn73xx;
 	struct cvmx_pko_pq_debug_yellow_s     cn78xx;
 };
 typedef union cvmx_pko_pq_debug_yellow cvmx_pko_pq_debug_yellow_t;
@@ -11291,6 +12658,7 @@ union cvmx_pko_pqa_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_pqa_debug_s           cn73xx;
 	struct cvmx_pko_pqa_debug_s           cn78xx;
 };
 typedef union cvmx_pko_pqa_debug cvmx_pko_pqa_debug_t;
@@ -11310,6 +12678,7 @@ union cvmx_pko_pqb_debug {
 	uint64_t dbg_vec                      : 64;
 #endif
 	} s;
+	struct cvmx_pko_pqb_debug_s           cn73xx;
 	struct cvmx_pko_pqb_debug_s           cn78xx;
 };
 typedef union cvmx_pko_pqb_debug cvmx_pko_pqb_debug_t;
@@ -11324,6 +12693,44 @@ union cvmx_pko_pse_dq_bist_status {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t rt7_sram                     : 1;  /**< Result table 7 - DQ FIFO[1023:896]. */
+	uint64_t rt6_sram                     : 1;  /**< Result table 6 - DQ FIFO[895:768]. */
+	uint64_t rt5_sram                     : 1;  /**< Result table 5 - DQ FIFO[767:640]. */
+	uint64_t reserved_4_4                 : 1;
+	uint64_t rt3_sram                     : 1;  /**< Result table 3 - DQ FIFO[511:384]. */
+	uint64_t rt2_sram                     : 1;  /**< Result table 2 - DQ FIFO[383:256]. */
+	uint64_t rt1_sram                     : 1;  /**< Result table 1 - DQ FIFO[255:128]. */
+	uint64_t rt0_sram                     : 1;  /**< Result table 0 - DQ FIFO[127:0]. */
+#else
+	uint64_t rt0_sram                     : 1;
+	uint64_t rt1_sram                     : 1;
+	uint64_t rt2_sram                     : 1;
+	uint64_t rt3_sram                     : 1;
+	uint64_t reserved_4_4                 : 1;
+	uint64_t rt5_sram                     : 1;
+	uint64_t rt6_sram                     : 1;
+	uint64_t rt7_sram                     : 1;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_pko_pse_dq_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t wt_sram                      : 1;  /**< Work table. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t rt1_sram                     : 1;  /**< Result table 1 - DQ FIFO[255:128]. */
+	uint64_t rt0_sram                     : 1;  /**< Result table 0 - DQ FIFO[127:0]. */
+#else
+	uint64_t rt0_sram                     : 1;
+	uint64_t rt1_sram                     : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t wt_sram                      : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} cn73xx;
+	struct cvmx_pko_pse_dq_bist_status_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t wt_sram                      : 1;  /**< Work table. */
 	uint64_t rt7_sram                     : 1;  /**< Result table 7 - DQ FIFO[1023:896]. */
@@ -11346,8 +12753,7 @@ union cvmx_pko_pse_dq_bist_status {
 	uint64_t wt_sram                      : 1;
 	uint64_t reserved_9_63                : 55;
 #endif
-	} s;
-	struct cvmx_pko_pse_dq_bist_status_s  cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_pko_pse_dq_bist_status cvmx_pko_pse_dq_bist_status_t;
 
@@ -11399,6 +12805,27 @@ union cvmx_pko_pse_dq_ecc_ctl0 {
 	uint64_t dq_wt_ram_flip               : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dq_wt_ram_flip               : 2;  /**< DQ_WT_RAM flip syndrome bits on write. */
+	uint64_t dq_wt_ram_cdis               : 1;  /**< DQ_WT_RAM ECC correction disable. */
+	uint64_t reserved_43_60               : 18;
+	uint64_t dq_rt1_flip                  : 2;  /**< DQ_RT1 flip syndrome bits on write. */
+	uint64_t dq_rt1_cdis                  : 1;  /**< DQ_RT1 ECC correction disable. */
+	uint64_t dq_rt0_flip                  : 2;  /**< DQ_RT0 flip syndrome bits on write. */
+	uint64_t dq_rt0_cdis                  : 1;  /**< DQ_RT0 ECC correction disable. */
+	uint64_t reserved_0_36                : 37;
+#else
+	uint64_t reserved_0_36                : 37;
+	uint64_t dq_rt0_cdis                  : 1;
+	uint64_t dq_rt0_flip                  : 2;
+	uint64_t dq_rt1_cdis                  : 1;
+	uint64_t dq_rt1_flip                  : 2;
+	uint64_t reserved_43_60               : 18;
+	uint64_t dq_wt_ram_cdis               : 1;
+	uint64_t dq_wt_ram_flip               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_dq_ecc_ctl0_s     cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_ctl0 cvmx_pko_pse_dq_ecc_ctl0_t;
@@ -11433,6 +12860,21 @@ union cvmx_pko_pse_dq_ecc_dbe_sts0 {
 	uint64_t dq_wt_ram_dbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dq_wt_ram_dbe                : 1;  /**< Double-bit error for DQ_WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.wt_sram */
+	uint64_t reserved_57_62               : 6;
+	uint64_t dq_rt1_dbe                   : 1;  /**< Double-bit error for DQ_RT1_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt1 */
+	uint64_t dq_rt0_dbe                   : 1;  /**< Double-bit error for DQ_RT0_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt0 */
+	uint64_t reserved_0_54                : 55;
+#else
+	uint64_t reserved_0_54                : 55;
+	uint64_t dq_rt0_dbe                   : 1;
+	uint64_t dq_rt1_dbe                   : 1;
+	uint64_t reserved_57_62               : 6;
+	uint64_t dq_wt_ram_dbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_dbe_sts0 cvmx_pko_pse_dq_ecc_dbe_sts0_t;
@@ -11464,6 +12906,7 @@ union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 {
 	uint64_t pse_dq_dbe_cmb0              : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 cvmx_pko_pse_dq_ecc_dbe_sts_cmb0_t;
@@ -11498,6 +12941,21 @@ union cvmx_pko_pse_dq_ecc_sbe_sts0 {
 	uint64_t dq_wt_ram_sbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dq_wt_ram_sbe                : 1;  /**< Single-bit error for DQ_WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.wt_sram */
+	uint64_t reserved_57_62               : 6;
+	uint64_t dq_rt1_sbe                   : 1;  /**< Single-bit error for DQ_RT1_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt1 */
+	uint64_t dq_rt0_sbe                   : 1;  /**< Single-bit error for DQ_RT0_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt0 */
+	uint64_t reserved_0_54                : 55;
+#else
+	uint64_t reserved_0_54                : 55;
+	uint64_t dq_rt0_sbe                   : 1;
+	uint64_t dq_rt1_sbe                   : 1;
+	uint64_t reserved_57_62               : 6;
+	uint64_t dq_wt_ram_sbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_sbe_sts0 cvmx_pko_pse_dq_ecc_sbe_sts0_t;
@@ -11529,6 +12987,7 @@ union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 {
 	uint64_t pse_dq_sbe_cmb0              : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 cvmx_pko_pse_dq_ecc_sbe_sts_cmb0_t;
@@ -11578,6 +13037,43 @@ union cvmx_pko_pse_pq_bist_status {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t tp_sram                      : 1;  /**< Topology parent - pko_pse_pq_srf32x5e */
+	uint64_t reserved_13_13               : 1;
+	uint64_t wmd_sram                     : 1;  /**< Dynamic watermark state - pko_pse_wmd_srf1024x49e */
+	uint64_t reserved_11_11               : 1;
+	uint64_t cxd_sram                     : 1;  /**< Dynamic channel state - pko_pse_cxd_srf32x31e */
+	uint64_t dqd_sram                     : 1;  /**< DQ dropped stats - pko_pse_stats_srf1024x88 */
+	uint64_t dqs_sram                     : 1;  /**< DQ sent stats - pko_pse_stats_srf1024x88 */
+	uint64_t pqd_sram                     : 1;  /**< PQ dropped stats - pko_pse_stats_srf32x88 */
+	uint64_t pqr_sram                     : 1;  /**< PQ read stats - pko_pse_stats_srf32x88 */
+	uint64_t pqy_sram                     : 1;  /**< PQ yellow stats - pko_pse_stats_srf32x88 */
+	uint64_t pqg_sram                     : 1;  /**< PQ green stats - pko_pse_stats_srf32x88 */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state - pko_pse_std_srf32x105e */
+	uint64_t st_sram                      : 1;  /**< Static shaping configuration - pko_pse_sts_srf32x74e */
+	uint64_t reserved_1_1                 : 1;
+	uint64_t cxs_sram                     : 1;  /**< Static channel credit configuration - pko_pse_cx0_srf32x6e */
+#else
+	uint64_t cxs_sram                     : 1;
+	uint64_t reserved_1_1                 : 1;
+	uint64_t st_sram                      : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t pqg_sram                     : 1;
+	uint64_t pqy_sram                     : 1;
+	uint64_t pqr_sram                     : 1;
+	uint64_t pqd_sram                     : 1;
+	uint64_t dqs_sram                     : 1;
+	uint64_t dqd_sram                     : 1;
+	uint64_t cxd_sram                     : 1;
+	uint64_t reserved_11_11               : 1;
+	uint64_t wmd_sram                     : 1;
+	uint64_t reserved_13_13               : 1;
+	uint64_t tp_sram                      : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_pq_bist_status_s  cn78xx;
 };
 typedef union cvmx_pko_pse_pq_bist_status cvmx_pko_pse_pq_bist_status_t;
@@ -11626,6 +13122,39 @@ union cvmx_pko_pse_pq_ecc_ctl0 {
 	uint64_t pq_cxs_ram_flip              : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pq_cxs_ram_flip              : 2;  /**< PQ_CXS_RAM flip syndrome bits on write. */
+	uint64_t pq_cxs_ram_cdis              : 1;  /**< PQ_CXS_RAM ECC correction disable. */
+	uint64_t pq_cxd_ram_flip              : 2;  /**< PQ_CXD_RAM flip syndrome bits on write. */
+	uint64_t pq_cxd_ram_cdis              : 1;  /**< PQ_CXD_RAM ECC correction disable. */
+	uint64_t reserved_55_57               : 3;
+	uint64_t tp_sram_flip                 : 2;  /**< TP_SRAM flip syndrome bits on write. */
+	uint64_t tp_sram_cdis                 : 1;  /**< TP_SRAM ECC correction disable. */
+	uint64_t pq_std_ram_flip              : 2;  /**< PQ_STD_RAM flip syndrome bits on write. */
+	uint64_t pq_std_ram_cdis              : 1;  /**< PQ_STD_RAM ECC correction disable. */
+	uint64_t pq_st_ram_flip               : 2;  /**< PQ_ST_RAM flip syndrome bits on write. */
+	uint64_t pq_st_ram_cdis               : 1;  /**< PQ_ST_RAM ECC correction disable. */
+	uint64_t pq_wmd_ram_flip              : 2;  /**< PQ_WMD_RAM flip syndrome bits on write. */
+	uint64_t pq_wmd_ram_cdis              : 1;  /**< PQ_WMD_RAM ECC correction disable. */
+	uint64_t reserved_0_42                : 43;
+#else
+	uint64_t reserved_0_42                : 43;
+	uint64_t pq_wmd_ram_cdis              : 1;
+	uint64_t pq_wmd_ram_flip              : 2;
+	uint64_t pq_st_ram_cdis               : 1;
+	uint64_t pq_st_ram_flip               : 2;
+	uint64_t pq_std_ram_cdis              : 1;
+	uint64_t pq_std_ram_flip              : 2;
+	uint64_t tp_sram_cdis                 : 1;
+	uint64_t tp_sram_flip                 : 2;
+	uint64_t reserved_55_57               : 3;
+	uint64_t pq_cxd_ram_cdis              : 1;
+	uint64_t pq_cxd_ram_flip              : 2;
+	uint64_t pq_cxs_ram_cdis              : 1;
+	uint64_t pq_cxs_ram_flip              : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_pq_ecc_ctl0_s     cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_ctl0 cvmx_pko_pse_pq_ecc_ctl0_t;
@@ -11665,6 +13194,32 @@ union cvmx_pko_pse_pq_ecc_dbe_sts0 {
 	uint64_t pq_cxs_ram_dbe               : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pq_cxs_ram_dbe               : 1;  /**< Double-bit error for PQ_CXS_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram */
+	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram */
+	uint64_t reserved_61_61               : 1;
+	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram */
+	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram */
+	uint64_t pq_st_ram_dbe                : 1;  /**< Double-bit error for PQ_ST_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram */
+	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+	uint64_t reserved_0_56                : 57;
+#else
+	uint64_t reserved_0_56                : 57;
+	uint64_t pq_wmd_ram_dbe               : 1;
+	uint64_t pq_st_ram_dbe                : 1;
+	uint64_t pq_std_ram_dbe               : 1;
+	uint64_t tp_sram_dbe                  : 1;
+	uint64_t reserved_61_61               : 1;
+	uint64_t pq_cxd_ram_dbe               : 1;
+	uint64_t pq_cxs_ram_dbe               : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_dbe_sts0 cvmx_pko_pse_pq_ecc_dbe_sts0_t;
@@ -11683,18 +13238,19 @@ union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 {
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram (chip_pass: "o78<2.0")
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram (chip_pass: "o78<2.0") */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
 	uint64_t pse_pq_dbe_cmb0              : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 cvmx_pko_pse_pq_ecc_dbe_sts_cmb0_t;
@@ -11734,6 +13290,32 @@ union cvmx_pko_pse_pq_ecc_sbe_sts0 {
 	uint64_t pq_cxs_ram_sbe               : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pq_cxs_ram_sbe               : 1;  /**< Single-bit error for PQ_CXS_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram */
+	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram */
+	uint64_t reserved_61_61               : 1;
+	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram */
+	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram */
+	uint64_t pq_st_ram_sbe                : 1;  /**< Single-bit error for PQ_ST_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram */
+	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+	uint64_t reserved_0_56                : 57;
+#else
+	uint64_t reserved_0_56                : 57;
+	uint64_t pq_wmd_ram_sbe               : 1;
+	uint64_t pq_st_ram_sbe                : 1;
+	uint64_t pq_std_ram_sbe               : 1;
+	uint64_t tp_sram_sbe                  : 1;
+	uint64_t reserved_61_61               : 1;
+	uint64_t pq_cxd_ram_sbe               : 1;
+	uint64_t pq_cxs_ram_sbe               : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_pq_ecc_sbe_sts0 cvmx_pko_pse_pq_ecc_sbe_sts0_t;
@@ -11752,31 +13334,81 @@ union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 {
                                                          INTERNAL: Instances:
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxs_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.cxd_sram
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.irq_fifo_sram (chip_pass: "o78<2.0")
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.tp_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.std_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.st_sram
                                                          pko_pnr2.pko_pse.pse_sq2_pq.pq.wmd_sram
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram */
+                                                         pko_pnr2.pko_pse.pse_sq2_pq.pq.wms_sram (chip_pass: "o78<2.0") */
+	uint64_t reserved_0_62                : 63;
+#else
 	uint64_t reserved_0_62                : 63;
+	uint64_t pse_pq_sbe_cmb0              : 1;
+#endif
+	} s;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn73xx;
+	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn78xx;
+};
+typedef union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_t;
+
+/**
+ * cvmx_pko_pse_sq1_bist_status
+ *
+ * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
+ *
+ */
+union cvmx_pko_pse_sq1_bist_status {
+	uint64_t u64;
+	struct cvmx_pko_pse_sq1_bist_status_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< SQ[5:1] scheduling configuration */
+	uint64_t pc_sram                      : 1;  /**< SQ[1] physical channel - pko_pse_pc_srf32x12e */
+	uint64_t xon_sram                     : 1;  /**< XON SRAM */
+	uint64_t cc_sram                      : 1;  /**< SQ[1] channel credit OK state array */
+	uint64_t vc1_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
+	uint64_t vc0_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
+	uint64_t reserved_21_22               : 2;
+	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t xo_sram                      : 1;  /**< XOFF SRAM */
+	uint64_t rt_sram                      : 1;  /**< Result table */
+	uint64_t reserved_9_16                : 8;
+	uint64_t tw1_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 1 command FIFO SRAM */
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM */
+	uint64_t cxd_sram                     : 1;  /**< SQ[1] dynamic channel credit state */
+	uint64_t cxs_sram                     : 1;  /**< SQ[1] static channel credit configuration */
+	uint64_t nt_sram                      : 1;  /**< SQ[5:1] next pointer table */
+	uint64_t pt_sram                      : 1;  /**< SQ[5:1] previous pointer table */
+	uint64_t wt_sram                      : 1;  /**< SQ[5:1] work table */
 #else
-	uint64_t reserved_0_62                : 63;
-	uint64_t pse_pq_sbe_cmb0              : 1;
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t cxs_sram                     : 1;
+	uint64_t cxd_sram                     : 1;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t tw1_cmd_fifo                 : 1;
+	uint64_t reserved_9_16                : 8;
+	uint64_t rt_sram                      : 1;
+	uint64_t xo_sram                      : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t tp1_sram                     : 1;
+	uint64_t reserved_21_22               : 2;
+	uint64_t vc0_sram                     : 1;
+	uint64_t vc1_sram                     : 1;
+	uint64_t cc_sram                      : 1;
+	uint64_t xon_sram                     : 1;
+	uint64_t pc_sram                      : 1;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
-	struct cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_s cn78xx;
-};
-typedef union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 cvmx_pko_pse_pq_ecc_sbe_sts_cmb0_t;
-
-/**
- * cvmx_pko_pse_sq1_bist_status
- *
- * Each bit is the BIST result of an individual memory (per bit, 0 = pass and 1 = fail).
- *
- */
-union cvmx_pko_pse_sq1_bist_status {
-	uint64_t u64;
-	struct cvmx_pko_pse_sq1_bist_status_s {
+	struct cvmx_pko_pse_sq1_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
 	uint64_t sc_sram                      : 1;  /**< SQ[5:1] scheduling configuration */
@@ -11785,8 +13417,7 @@ union cvmx_pko_pse_sq1_bist_status {
 	uint64_t cc_sram                      : 1;  /**< SQ[1] channel credit OK state array */
 	uint64_t vc1_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
 	uint64_t vc0_sram                     : 1;  /**< SQ[1] virtual channel - pko_pse_sq1_vc_srf256x9e */
-	uint64_t reserved_21_22               : 2;
-	uint64_t tp1_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t reserved_20_22               : 3;
 	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
 	uint64_t xo_sram                      : 1;  /**< XOFF SRAM */
 	uint64_t rt_sram                      : 1;  /**< Result table */
@@ -11814,8 +13445,7 @@ union cvmx_pko_pse_sq1_bist_status {
 	uint64_t rt_sram                      : 1;
 	uint64_t xo_sram                      : 1;
 	uint64_t tp0_sram                     : 1;
-	uint64_t tp1_sram                     : 1;
-	uint64_t reserved_21_22               : 2;
+	uint64_t reserved_20_22               : 3;
 	uint64_t vc0_sram                     : 1;
 	uint64_t vc1_sram                     : 1;
 	uint64_t cc_sram                      : 1;
@@ -11824,7 +13454,7 @@ union cvmx_pko_pse_sq1_bist_status {
 	uint64_t sc_sram                      : 1;
 	uint64_t reserved_29_63               : 35;
 #endif
-	} s;
+	} cn73xx;
 	struct cvmx_pko_pse_sq1_bist_status_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_bist_status cvmx_pko_pse_sq1_bist_status_t;
@@ -11913,6 +13543,75 @@ union cvmx_pko_pse_sq1_ecc_ctl0 {
 	uint64_t cxs_ram_flip                 : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cxs_ram_flip                 : 2;  /**< CXS_RAM flip syndrome bits on write. */
+	uint64_t cxs_ram_cdis                 : 1;  /**< CXS_RAM ECC correction disable. */
+	uint64_t cxd_ram_flip                 : 2;  /**< CXD_RAM flip syndrome bits on write. */
+	uint64_t cxd_ram_cdis                 : 1;  /**< CXD_RAM ECC correction disable. */
+	uint64_t reserved_55_57               : 3;
+	uint64_t vc0_sram_flip                : 2;  /**< VC0_SRAM flip syndrome bits on write. */
+	uint64_t vc0_sram_cdis                : 1;  /**< VC0_SRAM ECC correction disable. */
+	uint64_t sq_pt_ram_flip               : 2;  /**< SQ_PT_RAM flip syndrome bits on write. */
+	uint64_t sq_pt_ram_cdis               : 1;  /**< SQ_PT_RAM ECC correction disable. */
+	uint64_t sq_nt_ram_flip               : 2;  /**< SQ_NT_RAM flip syndrome bits on write. */
+	uint64_t sq_nt_ram_cdis               : 1;  /**< SQ_NT_RAM ECC correction disable. */
+	uint64_t rt_ram_flip                  : 2;  /**< RT_RAM flip syndrome bits on write. */
+	uint64_t rt_ram_cdis                  : 1;  /**< RT_RAM ECC correction disable. */
+	uint64_t pc_ram_flip                  : 2;  /**< PC_RAM flip syndrome bits on write. */
+	uint64_t pc_ram_cdis                  : 1;  /**< PC_RAM ECC correction disable. */
+	uint64_t reserved_37_39               : 3;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;  /**< TW0_CMD_FIFO_RAM flip syndrome bits on write. */
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;  /**< TW0_CMD_FIFO_RAM ECC correction disable. */
+	uint64_t reserved_31_33               : 3;
+	uint64_t tp0_sram_flip                : 2;  /**< TP0_SRAM flip syndrome bits on write. */
+	uint64_t tp0_sram_cdis                : 1;  /**< TP0_SRAM ECC correction disable. */
+	uint64_t reserved_25_27               : 3;
+	uint64_t sts0_ram_flip                : 2;  /**< STS0_RAM flip syndrome bits on write. */
+	uint64_t sts0_ram_cdis                : 1;  /**< STS0_RAM ECC correction disable. */
+	uint64_t reserved_19_21               : 3;
+	uint64_t std0_ram_flip                : 2;  /**< STD0_RAM flip syndrome bits on write. */
+	uint64_t std0_ram_cdis                : 1;  /**< STD0_RAM ECC correction disable. */
+	uint64_t wt_ram_flip                  : 2;  /**< WT_RAM flip syndrome bits on write. */
+	uint64_t wt_ram_cdis                  : 1;  /**< WT_RAM ECC correction disable. */
+	uint64_t sc_ram_flip                  : 2;  /**< SC_RAM flip syndrome bits on write. */
+	uint64_t sc_ram_cdis                  : 1;  /**< SC_RAM ECC correction disable. */
+	uint64_t reserved_0_9                 : 10;
+#else
+	uint64_t reserved_0_9                 : 10;
+	uint64_t sc_ram_cdis                  : 1;
+	uint64_t sc_ram_flip                  : 2;
+	uint64_t wt_ram_cdis                  : 1;
+	uint64_t wt_ram_flip                  : 2;
+	uint64_t std0_ram_cdis                : 1;
+	uint64_t std0_ram_flip                : 2;
+	uint64_t reserved_19_21               : 3;
+	uint64_t sts0_ram_cdis                : 1;
+	uint64_t sts0_ram_flip                : 2;
+	uint64_t reserved_25_27               : 3;
+	uint64_t tp0_sram_cdis                : 1;
+	uint64_t tp0_sram_flip                : 2;
+	uint64_t reserved_31_33               : 3;
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;
+	uint64_t reserved_37_39               : 3;
+	uint64_t pc_ram_cdis                  : 1;
+	uint64_t pc_ram_flip                  : 2;
+	uint64_t rt_ram_cdis                  : 1;
+	uint64_t rt_ram_flip                  : 2;
+	uint64_t sq_nt_ram_cdis               : 1;
+	uint64_t sq_nt_ram_flip               : 2;
+	uint64_t sq_pt_ram_cdis               : 1;
+	uint64_t sq_pt_ram_flip               : 2;
+	uint64_t vc0_sram_cdis                : 1;
+	uint64_t vc0_sram_flip                : 2;
+	uint64_t reserved_55_57               : 3;
+	uint64_t cxd_ram_cdis                 : 1;
+	uint64_t cxd_ram_flip                 : 2;
+	uint64_t cxs_ram_cdis                 : 1;
+	uint64_t cxs_ram_flip                 : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_ctl0_s    cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_ctl0 cvmx_pko_pse_sq1_ecc_ctl0_t;
@@ -11979,6 +13678,58 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts0 {
 	uint64_t cxs_ram_dbe                  : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cxs_ram_dbe                  : 1;  /**< Double-bit error for CXS_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram */
+	uint64_t cxd_ram_dbe                  : 1;  /**< Double-bit error for CXD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram */
+	uint64_t reserved_61_61               : 1;
+	uint64_t vc0_sram_dbe                 : 1;  /**< Double-bit error for VC0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc0_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram */
+	uint64_t pc_ram_dbe                   : 1;  /**< Double-bit error for PC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram */
+	uint64_t reserved_55_55               : 1;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_1.sq_fifo_sram */
+	uint64_t reserved_53_53               : 1;
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram */
+	uint64_t reserved_51_51               : 1;
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts0_sram */
+	uint64_t reserved_49_49               : 1;
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+	uint64_t reserved_0_45                : 46;
+#else
+	uint64_t reserved_0_45                : 46;
+	uint64_t sc_ram_dbe                   : 1;
+	uint64_t wt_ram_dbe                   : 1;
+	uint64_t std0_ram_dbe                 : 1;
+	uint64_t reserved_49_49               : 1;
+	uint64_t sts0_ram_dbe                 : 1;
+	uint64_t reserved_51_51               : 1;
+	uint64_t tp0_sram_dbe                 : 1;
+	uint64_t reserved_53_53               : 1;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;
+	uint64_t reserved_55_55               : 1;
+	uint64_t pc_ram_dbe                   : 1;
+	uint64_t rt_ram_dbe                   : 1;
+	uint64_t sq_nt_ram_dbe                : 1;
+	uint64_t sq_pt_ram_dbe                : 1;
+	uint64_t vc0_sram_dbe                 : 1;
+	uint64_t reserved_61_61               : 1;
+	uint64_t cxd_ram_dbe                  : 1;
+	uint64_t cxs_ram_dbe                  : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_dbe_sts0 cvmx_pko_pse_sq1_ecc_dbe_sts0_t;
@@ -12019,6 +13770,7 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq1_dbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0_t;
@@ -12085,6 +13837,58 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts0 {
 	uint64_t cxs_ram_sbe                  : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cxs_ram_sbe                  : 1;  /**< Single-bit error for CXS_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram */
+	uint64_t cxd_ram_sbe                  : 1;  /**< Single-bit error for CXD_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram */
+	uint64_t reserved_61_61               : 1;
+	uint64_t vc0_sram_sbe                 : 1;  /**< Single-bit error for VC0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc1_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram */
+	uint64_t pc_ram_sbe                   : 1;  /**< Single-bit error for PC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram */
+	uint64_t reserved_55_55               : 1;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_1.sq_fifo_sram */
+	uint64_t reserved_53_53               : 1;
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram */
+	uint64_t reserved_51_51               : 1;
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts1_sram */
+	uint64_t reserved_49_49               : 1;
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std1_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+	uint64_t reserved_0_45                : 46;
+#else
+	uint64_t reserved_0_45                : 46;
+	uint64_t sc_ram_sbe                   : 1;
+	uint64_t wt_ram_sbe                   : 1;
+	uint64_t std0_ram_sbe                 : 1;
+	uint64_t reserved_49_49               : 1;
+	uint64_t sts0_ram_sbe                 : 1;
+	uint64_t reserved_51_51               : 1;
+	uint64_t tp0_sram_sbe                 : 1;
+	uint64_t reserved_53_53               : 1;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;
+	uint64_t reserved_55_55               : 1;
+	uint64_t pc_ram_sbe                   : 1;
+	uint64_t rt_ram_sbe                   : 1;
+	uint64_t sq_nt_ram_sbe                : 1;
+	uint64_t sq_pt_ram_sbe                : 1;
+	uint64_t vc0_sram_sbe                 : 1;
+	uint64_t reserved_61_61               : 1;
+	uint64_t cxd_ram_sbe                  : 1;
+	uint64_t cxs_ram_sbe                  : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_sbe_sts0 cvmx_pko_pse_sq1_ecc_sbe_sts0_t;
@@ -12125,6 +13929,7 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq1_sbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0_t;
@@ -12174,16 +13979,108 @@ union cvmx_pko_pse_sq2_bist_status {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
-	struct cvmx_pko_pse_sq2_bist_status_s cn78xx;
-};
-typedef union cvmx_pko_pse_sq2_bist_status cvmx_pko_pse_sq2_bist_status_t;
-
-/**
- * cvmx_pko_pse_sq2_ecc_ctl0
- */
-union cvmx_pko_pse_sq2_ecc_ctl0 {
-	uint64_t u64;
-	struct cvmx_pko_pse_sq2_ecc_ctl0_s {
+	struct cvmx_pko_pse_sq2_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< Scheduling configuration. */
+	uint64_t reserved_20_27               : 8;
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration. */
+	uint64_t reserved_18_18               : 1;
+	uint64_t rt_sram                      : 1;  /**< Result table. */
+	uint64_t reserved_8_16                : 9;
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration. */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM. */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t nt_sram                      : 1;  /**< Next pointer table. */
+	uint64_t pt_sram                      : 1;  /**< Previous pointer table. */
+	uint64_t wt_sram                      : 1;  /**< Work table. */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t reserved_8_16                : 9;
+	uint64_t rt_sram                      : 1;
+	uint64_t reserved_18_18               : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t reserved_20_27               : 8;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} cn73xx;
+	struct cvmx_pko_pse_sq2_bist_status_s cn78xx;
+};
+typedef union cvmx_pko_pse_sq2_bist_status cvmx_pko_pse_sq2_bist_status_t;
+
+/**
+ * cvmx_pko_pse_sq2_ecc_ctl0
+ */
+union cvmx_pko_pse_sq2_ecc_ctl0 {
+	uint64_t u64;
+	struct cvmx_pko_pse_sq2_ecc_ctl0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_flip               : 2;  /**< SQ_PT_RAM flip syndrome bits on write. */
+	uint64_t sq_pt_ram_cdis               : 1;  /**< SQ_PT_RAM ECC correction disable. */
+	uint64_t sq_nt_ram_flip               : 2;  /**< SQ_NT_RAM flip syndrome bits on write. */
+	uint64_t sq_nt_ram_cdis               : 1;  /**< SQ_NT_RAM ECC correction disable. */
+	uint64_t rt_ram_flip                  : 2;  /**< RT_RAM flip syndrome bits on write. */
+	uint64_t rt_ram_cdis                  : 1;  /**< RT_RAM ECC correction disable. */
+	uint64_t tw1_cmd_fifo_ram_flip        : 2;  /**< TW1_CMD_FIFO_RAM flip syndrome bits on write. */
+	uint64_t tw1_cmd_fifo_ram_cdis        : 1;  /**< TW1_CMD_FIFO_RAM ECC correction disable. */
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;  /**< TW0_CMD_FIFO_RAM flip syndrome bits on write. */
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;  /**< TW0_CMD_FIFO_RAM ECC correction disable. */
+	uint64_t tp1_sram_flip                : 2;  /**< TP1_SRAM flip syndrome bits on write. */
+	uint64_t tp1_sram_cdis                : 1;  /**< TP1_SRAM ECC correction disable. */
+	uint64_t tp0_sram_flip                : 2;  /**< TP0_SRAM flip syndrome bits on write. */
+	uint64_t tp0_sram_cdis                : 1;  /**< TP0_SRAM ECC correction disable. */
+	uint64_t sts1_ram_flip                : 2;  /**< STS1_RAM flip syndrome bits on write. */
+	uint64_t sts1_ram_cdis                : 1;  /**< STS1_RAM ECC correction disable. */
+	uint64_t sts0_ram_flip                : 2;  /**< STS0_RAM flip syndrome bits on write. */
+	uint64_t sts0_ram_cdis                : 1;  /**< STS0_RAM ECC correction disable. */
+	uint64_t std1_ram_flip                : 2;  /**< STD1_RAM flip syndrome bits on write. */
+	uint64_t std1_ram_cdis                : 1;  /**< STD1_RAM ECC correction disable. */
+	uint64_t std0_ram_flip                : 2;  /**< STD0_RAM flip syndrome bits on write. */
+	uint64_t std0_ram_cdis                : 1;  /**< STD0_RAM ECC correction disable. */
+	uint64_t wt_ram_flip                  : 2;  /**< WT_RAM flip syndrome bits on write. */
+	uint64_t wt_ram_cdis                  : 1;  /**< WT_RAM ECC correction disable. */
+	uint64_t sc_ram_flip                  : 2;  /**< SC_RAM flip syndrome bits on write. */
+	uint64_t sc_ram_cdis                  : 1;  /**< SC_RAM ECC correction disable. */
+	uint64_t reserved_0_24                : 25;
+#else
+	uint64_t reserved_0_24                : 25;
+	uint64_t sc_ram_cdis                  : 1;
+	uint64_t sc_ram_flip                  : 2;
+	uint64_t wt_ram_cdis                  : 1;
+	uint64_t wt_ram_flip                  : 2;
+	uint64_t std0_ram_cdis                : 1;
+	uint64_t std0_ram_flip                : 2;
+	uint64_t std1_ram_cdis                : 1;
+	uint64_t std1_ram_flip                : 2;
+	uint64_t sts0_ram_cdis                : 1;
+	uint64_t sts0_ram_flip                : 2;
+	uint64_t sts1_ram_cdis                : 1;
+	uint64_t sts1_ram_flip                : 2;
+	uint64_t tp0_sram_cdis                : 1;
+	uint64_t tp0_sram_flip                : 2;
+	uint64_t tp1_sram_cdis                : 1;
+	uint64_t tp1_sram_flip                : 2;
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;
+	uint64_t tw1_cmd_fifo_ram_cdis        : 1;
+	uint64_t tw1_cmd_fifo_ram_flip        : 2;
+	uint64_t rt_ram_cdis                  : 1;
+	uint64_t rt_ram_flip                  : 2;
+	uint64_t sq_nt_ram_cdis               : 1;
+	uint64_t sq_nt_ram_flip               : 2;
+	uint64_t sq_pt_ram_cdis               : 1;
+	uint64_t sq_pt_ram_flip               : 2;
+#endif
+	} s;
+	struct cvmx_pko_pse_sq2_ecc_ctl0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t sq_pt_ram_flip               : 2;  /**< SQ_PT_RAM flip syndrome bits on write. */
 	uint64_t sq_pt_ram_cdis               : 1;  /**< SQ_PT_RAM ECC correction disable. */
@@ -12191,20 +14088,16 @@ union cvmx_pko_pse_sq2_ecc_ctl0 {
 	uint64_t sq_nt_ram_cdis               : 1;  /**< SQ_NT_RAM ECC correction disable. */
 	uint64_t rt_ram_flip                  : 2;  /**< RT_RAM flip syndrome bits on write. */
 	uint64_t rt_ram_cdis                  : 1;  /**< RT_RAM ECC correction disable. */
-	uint64_t tw1_cmd_fifo_ram_flip        : 2;  /**< TW1_CMD_FIFO_RAM flip syndrome bits on write. */
-	uint64_t tw1_cmd_fifo_ram_cdis        : 1;  /**< TW1_CMD_FIFO_RAM ECC correction disable. */
+	uint64_t reserved_52_54               : 3;
 	uint64_t tw0_cmd_fifo_ram_flip        : 2;  /**< TW0_CMD_FIFO_RAM flip syndrome bits on write. */
 	uint64_t tw0_cmd_fifo_ram_cdis        : 1;  /**< TW0_CMD_FIFO_RAM ECC correction disable. */
-	uint64_t tp1_sram_flip                : 2;  /**< TP1_SRAM flip syndrome bits on write. */
-	uint64_t tp1_sram_cdis                : 1;  /**< TP1_SRAM ECC correction disable. */
+	uint64_t reserved_46_48               : 3;
 	uint64_t tp0_sram_flip                : 2;  /**< TP0_SRAM flip syndrome bits on write. */
 	uint64_t tp0_sram_cdis                : 1;  /**< TP0_SRAM ECC correction disable. */
-	uint64_t sts1_ram_flip                : 2;  /**< STS1_RAM flip syndrome bits on write. */
-	uint64_t sts1_ram_cdis                : 1;  /**< STS1_RAM ECC correction disable. */
+	uint64_t reserved_40_42               : 3;
 	uint64_t sts0_ram_flip                : 2;  /**< STS0_RAM flip syndrome bits on write. */
 	uint64_t sts0_ram_cdis                : 1;  /**< STS0_RAM ECC correction disable. */
-	uint64_t std1_ram_flip                : 2;  /**< STD1_RAM flip syndrome bits on write. */
-	uint64_t std1_ram_cdis                : 1;  /**< STD1_RAM ECC correction disable. */
+	uint64_t reserved_34_36               : 3;
 	uint64_t std0_ram_flip                : 2;  /**< STD0_RAM flip syndrome bits on write. */
 	uint64_t std0_ram_cdis                : 1;  /**< STD0_RAM ECC correction disable. */
 	uint64_t wt_ram_flip                  : 2;  /**< WT_RAM flip syndrome bits on write. */
@@ -12220,20 +14113,16 @@ union cvmx_pko_pse_sq2_ecc_ctl0 {
 	uint64_t wt_ram_flip                  : 2;
 	uint64_t std0_ram_cdis                : 1;
 	uint64_t std0_ram_flip                : 2;
-	uint64_t std1_ram_cdis                : 1;
-	uint64_t std1_ram_flip                : 2;
+	uint64_t reserved_34_36               : 3;
 	uint64_t sts0_ram_cdis                : 1;
 	uint64_t sts0_ram_flip                : 2;
-	uint64_t sts1_ram_cdis                : 1;
-	uint64_t sts1_ram_flip                : 2;
+	uint64_t reserved_40_42               : 3;
 	uint64_t tp0_sram_cdis                : 1;
 	uint64_t tp0_sram_flip                : 2;
-	uint64_t tp1_sram_cdis                : 1;
-	uint64_t tp1_sram_flip                : 2;
+	uint64_t reserved_46_48               : 3;
 	uint64_t tw0_cmd_fifo_ram_cdis        : 1;
 	uint64_t tw0_cmd_fifo_ram_flip        : 2;
-	uint64_t tw1_cmd_fifo_ram_cdis        : 1;
-	uint64_t tw1_cmd_fifo_ram_flip        : 2;
+	uint64_t reserved_52_54               : 3;
 	uint64_t rt_ram_cdis                  : 1;
 	uint64_t rt_ram_flip                  : 2;
 	uint64_t sq_nt_ram_cdis               : 1;
@@ -12241,7 +14130,7 @@ union cvmx_pko_pse_sq2_ecc_ctl0 {
 	uint64_t sq_pt_ram_cdis               : 1;
 	uint64_t sq_pt_ram_flip               : 2;
 #endif
-	} s;
+	} cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_ctl0_s    cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_ctl0 cvmx_pko_pse_sq2_ecc_ctl0_t;
@@ -12294,6 +14183,45 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts0 {
 	uint64_t sq_pt_ram_dbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram */
+	uint64_t reserved_60_60               : 1;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram */
+	uint64_t reserved_58_58               : 1;
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram */
+	uint64_t reserved_56_56               : 1;
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram */
+	uint64_t reserved_54_54               : 1;
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+	uint64_t reserved_0_50                : 51;
+#else
+	uint64_t reserved_0_50                : 51;
+	uint64_t sc_ram_dbe                   : 1;
+	uint64_t wt_ram_dbe                   : 1;
+	uint64_t std0_ram_dbe                 : 1;
+	uint64_t reserved_54_54               : 1;
+	uint64_t sts0_ram_dbe                 : 1;
+	uint64_t reserved_56_56               : 1;
+	uint64_t tp0_sram_dbe                 : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;
+	uint64_t reserved_60_60               : 1;
+	uint64_t rt_ram_dbe                   : 1;
+	uint64_t sq_nt_ram_dbe                : 1;
+	uint64_t sq_pt_ram_dbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_dbe_sts0 cvmx_pko_pse_sq2_ecc_dbe_sts0_t;
@@ -12329,6 +14257,7 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq2_dbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0_t;
@@ -12381,6 +14310,45 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts0 {
 	uint64_t sq_pt_ram_sbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram */
+	uint64_t reserved_60_60               : 1;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram */
+	uint64_t reserved_58_58               : 1;
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram */
+	uint64_t reserved_56_56               : 1;
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram */
+	uint64_t reserved_54_54               : 1;
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+	uint64_t reserved_0_50                : 51;
+#else
+	uint64_t reserved_0_50                : 51;
+	uint64_t sc_ram_sbe                   : 1;
+	uint64_t wt_ram_sbe                   : 1;
+	uint64_t std0_ram_sbe                 : 1;
+	uint64_t reserved_54_54               : 1;
+	uint64_t sts0_ram_sbe                 : 1;
+	uint64_t reserved_56_56               : 1;
+	uint64_t tp0_sram_sbe                 : 1;
+	uint64_t reserved_58_58               : 1;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;
+	uint64_t reserved_60_60               : 1;
+	uint64_t rt_ram_sbe                   : 1;
+	uint64_t sq_nt_ram_sbe                : 1;
+	uint64_t sq_pt_ram_sbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_sbe_sts0 cvmx_pko_pse_sq2_ecc_sbe_sts0_t;
@@ -12416,6 +14384,7 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq2_sbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0_t;
@@ -12477,6 +14446,39 @@ union cvmx_pko_pse_sq3_bist_status {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_bist_status_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t sc_sram                      : 1;  /**< Scheduling configuration */
+	uint64_t reserved_20_27               : 8;
+	uint64_t tp0_sram                     : 1;  /**< SQ[5:1] topology parent configuration */
+	uint64_t reserved_18_18               : 1;
+	uint64_t rt_sram                      : 1;  /**< Result table */
+	uint64_t reserved_8_16                : 9;
+	uint64_t std_sram                     : 1;  /**< Dynamic shaping state */
+	uint64_t sts_sram                     : 1;  /**< Static shaping configuration */
+	uint64_t tw0_cmd_fifo                 : 1;  /**< SQ[5:1] time wheel 0 command FIFO SRAM */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t nt_sram                      : 1;  /**< Next pointer table */
+	uint64_t pt_sram                      : 1;  /**< Previous pointer table */
+	uint64_t wt_sram                      : 1;  /**< Work table */
+#else
+	uint64_t wt_sram                      : 1;
+	uint64_t pt_sram                      : 1;
+	uint64_t nt_sram                      : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t tw0_cmd_fifo                 : 1;
+	uint64_t sts_sram                     : 1;
+	uint64_t std_sram                     : 1;
+	uint64_t reserved_8_16                : 9;
+	uint64_t rt_sram                      : 1;
+	uint64_t reserved_18_18               : 1;
+	uint64_t tp0_sram                     : 1;
+	uint64_t reserved_20_27               : 8;
+	uint64_t sc_sram                      : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq3_bist_status_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_bist_status cvmx_pko_pse_sq3_bist_status_t;
@@ -12577,6 +14579,57 @@ union cvmx_pko_pse_sq3_ecc_ctl0 {
 	uint64_t sq_pt_ram_flip               : 2;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_ctl0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_flip               : 2;  /**< SQ_PT_RAM flip syndrome bits on write. */
+	uint64_t sq_pt_ram_cdis               : 1;  /**< SQ_PT_RAM ECC correction disable. */
+	uint64_t sq_nt_ram_flip               : 2;  /**< SQ_NT_RAM flip syndrome bits on write. */
+	uint64_t sq_nt_ram_cdis               : 1;  /**< SQ_NT_RAM ECC correction disable. */
+	uint64_t rt_ram_flip                  : 2;  /**< RT_RAM flip syndrome bits on write. */
+	uint64_t rt_ram_cdis                  : 1;  /**< RT_RAM ECC correction disable. */
+	uint64_t reserved_46_54               : 9;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;  /**< TW0_CMD_FIFO_RAM flip syndrome bits on write. */
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;  /**< TW0_CMD_FIFO_RAM ECC correction disable. */
+	uint64_t reserved_34_42               : 9;
+	uint64_t tp0_sram_flip                : 2;  /**< TP0_SRAM flip syndrome bits on write. */
+	uint64_t tp0_sram_cdis                : 1;  /**< TP0_SRAM ECC correction disable. */
+	uint64_t reserved_22_30               : 9;
+	uint64_t sts0_ram_flip                : 2;  /**< STS0_RAM flip syndrome bits on write. */
+	uint64_t sts0_ram_cdis                : 1;  /**< STS0_RAM ECC correction disable. */
+	uint64_t reserved_10_18               : 9;
+	uint64_t std0_ram_flip                : 2;  /**< STD0_RAM flip syndrome bits on write. */
+	uint64_t std0_ram_cdis                : 1;  /**< STD0_RAM ECC correction disable. */
+	uint64_t wt_ram_flip                  : 2;  /**< WT_RAM flip syndrome bits on write. */
+	uint64_t wt_ram_cdis                  : 1;  /**< WT_RAM ECC correction disable. */
+	uint64_t sc_ram_flip                  : 2;  /**< SC_RAM flip syndrome bits on write. */
+	uint64_t sc_ram_cdis                  : 1;  /**< SC_RAM ECC correction disable. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t sc_ram_cdis                  : 1;
+	uint64_t sc_ram_flip                  : 2;
+	uint64_t wt_ram_cdis                  : 1;
+	uint64_t wt_ram_flip                  : 2;
+	uint64_t std0_ram_cdis                : 1;
+	uint64_t std0_ram_flip                : 2;
+	uint64_t reserved_10_18               : 9;
+	uint64_t sts0_ram_cdis                : 1;
+	uint64_t sts0_ram_flip                : 2;
+	uint64_t reserved_22_30               : 9;
+	uint64_t tp0_sram_cdis                : 1;
+	uint64_t tp0_sram_flip                : 2;
+	uint64_t reserved_34_42               : 9;
+	uint64_t tw0_cmd_fifo_ram_cdis        : 1;
+	uint64_t tw0_cmd_fifo_ram_flip        : 2;
+	uint64_t reserved_46_54               : 9;
+	uint64_t rt_ram_cdis                  : 1;
+	uint64_t rt_ram_flip                  : 2;
+	uint64_t sq_nt_ram_cdis               : 1;
+	uint64_t sq_nt_ram_flip               : 2;
+	uint64_t sq_pt_ram_cdis               : 1;
+	uint64_t sq_pt_ram_flip               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_ctl0_s    cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_ctl0 cvmx_pko_pse_sq3_ecc_ctl0_t;
@@ -12653,6 +14706,45 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts0 {
 	uint64_t sq_pt_ram_dbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
+	uint64_t reserved_58_60               : 3;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
+	uint64_t reserved_54_56               : 3;
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
+	uint64_t reserved_50_52               : 3;
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
+	uint64_t reserved_46_48               : 3;
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+	uint64_t reserved_0_42                : 43;
+#else
+	uint64_t reserved_0_42                : 43;
+	uint64_t sc_ram_dbe                   : 1;
+	uint64_t wt_ram_dbe                   : 1;
+	uint64_t std0_ram_dbe                 : 1;
+	uint64_t reserved_46_48               : 3;
+	uint64_t sts0_ram_dbe                 : 1;
+	uint64_t reserved_50_52               : 3;
+	uint64_t tp0_sram_dbe                 : 1;
+	uint64_t reserved_54_56               : 3;
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;
+	uint64_t reserved_58_60               : 3;
+	uint64_t rt_ram_dbe                   : 1;
+	uint64_t sq_nt_ram_dbe                : 1;
+	uint64_t sq_pt_ram_dbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_dbe_sts0 cvmx_pko_pse_sq3_ecc_dbe_sts0_t;
@@ -12696,6 +14788,7 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq3_dbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0_t;
@@ -12772,6 +14865,45 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts0 {
 	uint64_t sq_pt_ram_sbe                : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
+	uint64_t reserved_58_60               : 3;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
+	uint64_t reserved_54_56               : 3;
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
+	uint64_t reserved_50_52               : 3;
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
+	uint64_t reserved_46_48               : 3;
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
+                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+	uint64_t reserved_0_42                : 43;
+#else
+	uint64_t reserved_0_42                : 43;
+	uint64_t sc_ram_sbe                   : 1;
+	uint64_t wt_ram_sbe                   : 1;
+	uint64_t std0_ram_sbe                 : 1;
+	uint64_t reserved_46_48               : 3;
+	uint64_t sts0_ram_sbe                 : 1;
+	uint64_t reserved_50_52               : 3;
+	uint64_t tp0_sram_sbe                 : 1;
+	uint64_t reserved_54_56               : 3;
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;
+	uint64_t reserved_58_60               : 3;
+	uint64_t rt_ram_sbe                   : 1;
+	uint64_t sq_nt_ram_sbe                : 1;
+	uint64_t sq_pt_ram_sbe                : 1;
+#endif
+	} cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_sbe_sts0 cvmx_pko_pse_sq3_ecc_sbe_sts0_t;
@@ -12815,6 +14947,7 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq3_sbe_cmb0             : 1;
 #endif
 	} s;
+	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s cn73xx;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_s cn78xx;
 };
 typedef union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0_t;
@@ -13639,6 +15772,7 @@ union cvmx_pko_ptfx_status {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_pko_ptfx_status_s         cn73xx;
 	struct cvmx_pko_ptfx_status_s         cn78xx;
 };
 typedef union cvmx_pko_ptfx_status cvmx_pko_ptfx_status_t;
@@ -13661,6 +15795,7 @@ union cvmx_pko_ptf_iobp_cfg {
 	uint64_t reserved_43_63               : 21;
 #endif
 	} s;
+	struct cvmx_pko_ptf_iobp_cfg_s        cn73xx;
 	struct cvmx_pko_ptf_iobp_cfg_s        cn78xx;
 };
 typedef union cvmx_pko_ptf_iobp_cfg cvmx_pko_ptf_iobp_cfg_t;
@@ -13668,20 +15803,19 @@ typedef union cvmx_pko_ptf_iobp_cfg cvmx_pko_ptf_iobp_cfg_t;
 /**
  * cvmx_pko_ptgf#_cfg
  *
- * This register configures a PKO TX FIFO group. PKO supports up to 29 independent
- * TX FIFOs, where 0-27 are physical and 28 is Virtual/NULL. (PKO drops packets
+ * This register configures a PKO TX FIFO group. PKO supports up to 17 independent
+ * TX FIFOs, where 0-15 are physical and 16 is Virtual/NULL. (PKO drops packets
  * targeting the NULL FIFO, returning their buffers to the FPA.) PKO puts each
- * FIFO into one of eight groups:
+ * FIFO into one of five groups:
  *
  * <pre>
- *   CSR Name       FIFO's in FIFO Group
- *   -----------------------------------
+ *    CSR Name       FIFO's in FIFO Group
+ *   ------------------------------------
  *   PKO_PTGF0_CFG      0,  1,  2,  3
  *   PKO_PTGF1_CFG      4,  5,  6,  7
  *   PKO_PTGF2_CFG      8,  9, 10, 11
- *   - ...
- *   PKO_PTGF6_CFG     24, 25, 26, 27
- *   PKO_PTGF7_CFG      Virtual/NULL
+ *   PKO_PTGF3_CFG     12, 13, 14, 15
+ *   PKO_PTGF4_CFG      Virtual/NULL
  * </pre>
  */
 union cvmx_pko_ptgfx_cfg {
@@ -13742,6 +15876,61 @@ union cvmx_pko_ptgfx_cfg {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_pko_ptgfx_cfg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_7_63                : 57;
+	uint64_t reset                        : 1;  /**< This bit resets the address pointers for the FIFOs in this group. This should only be
+                                                         performed when a PTGF is empty and the SIZE field is to be changed. */
+	uint64_t reserved_5_5                 : 1;
+	uint64_t rate                         : 2;  /**< The rate / number of inflight packets allowed for the FIFO's in this group.
+                                                         An individual FIFO can support up to 50 Gbit/sec (i.e. up to 32 inflight packets).
+                                                         The total aggregate rate across all FIFOs (including the NULL) should never exceed
+                                                         125 Gbit/sec (i.e. up to 80 inflight packets). This field represents the rate for
+                                                         each active FIFO in in the group; thus the calculation for throughput is a function
+                                                         of the SIZE field and whether or not the FIFO's in the group are assigned to a MAC
+                                                         in PKO_MAC()_CFG.
+                                                         Encoding:
+                                                         0x0 = up to   6.25 Gbit/sec (i.e. up to  4 inflight packets)
+                                                         0x1 = up to  12.5  Gbit/sec (i.e. up to  8 inflight packets)
+                                                         0x2 = up to  25    Gbit/sec (i.e. up to 16 inflight packets)
+                                                         0x3 = up to  50    Gbit/sec (i.e. up to 32 inflight packets)
+                                                         [RATE] applies to all FIFO groups including the NULL. */
+	uint64_t size                         : 3;  /**< Determines the size and availability of the FIFO's in the FIFO group.
+                                                         10KB total storage is available to the FIFO group. Two or
+                                                         four FIFOs can be combined to produce a larger FIFO if desired.
+                                                         The supported SIZE values:
+                                                         <pre>
+                                                                   FIFO0   FIFO1   FIFO2   FIFO3
+                                                            SIZE   Size    Size    Size    Size
+                                                           --------------------------------------
+                                                             0     2.5KB   2.5KB   2.5KB   2.5KB
+                                                             1     5.0KB    N/A    2.5KB   2.5KB
+                                                             2     2.5KB   2.5KB   5.0KB    N/A
+                                                             3     5.0KB    N/A    5.0KB    N/A
+                                                             4    10.0KB    N/A     N/A     N/A
+                                                         </pre>
+                                                         Note: 5-7 are illegal SIZE values and should not be used.
+                                                         A FIFO labelled N/A in the above table must not be used, and no
+                                                         PKO_MAC()_CFG[FIFO_NUM] should select it. For example,
+                                                         if PKO_PTGF(2)_CFG[SIZE]=4, FIFO_NUM 8 is available (with
+                                                         10KB), but FIFO_NUMs 9, 10, and 11 are not valid and should
+                                                         not be used.
+                                                         Modifications to this field require two writes. The first
+                                                         write must not modify [SIZE], and must assert [RESET] to
+                                                         reset the address pointers for the FIFOs in this group.
+                                                         The second write has the new [SIZE] value, and should clear
+                                                         [RESET].
+                                                         PKO_PTGF(4)_CFG[SIZE] should not change from its reset value
+                                                         of zero. (The NULL FIFO has no real storage, and the SIZE table
+                                                         above does not apply to the NULL FIFO.) */
+#else
+	uint64_t size                         : 3;
+	uint64_t rate                         : 2;
+	uint64_t reserved_5_5                 : 1;
+	uint64_t reset                        : 1;
+	uint64_t reserved_7_63                : 57;
+#endif
+	} cn73xx;
 	struct cvmx_pko_ptgfx_cfg_s           cn78xx;
 };
 typedef union cvmx_pko_ptgfx_cfg cvmx_pko_ptgfx_cfg_t;
@@ -15419,11 +17608,31 @@ union cvmx_pko_shaper_cfg {
 	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
+	struct cvmx_pko_shaper_cfg_s          cn73xx;
 	struct cvmx_pko_shaper_cfg_s          cn78xx;
 };
 typedef union cvmx_pko_shaper_cfg cvmx_pko_shaper_cfg_t;
 
 /**
+ * cvmx_pko_state_uid_in_use#_rd
+ *
+ * For diagnostic use only.
+ *
+ */
+union cvmx_pko_state_uid_in_usex_rd {
+	uint64_t u64;
+	struct cvmx_pko_state_uid_in_usex_rd_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t in_use                       : 64; /**< When set, a state memory bucket (aka UID) is assigned. */
+#else
+	uint64_t in_use                       : 64;
+#endif
+	} s;
+	struct cvmx_pko_state_uid_in_usex_rd_s cn73xx;
+};
+typedef union cvmx_pko_state_uid_in_usex_rd cvmx_pko_state_uid_in_usex_rd_t;
+
+/**
  * cvmx_pko_status
  */
 union cvmx_pko_status {
@@ -15465,8 +17674,27 @@ union cvmx_pko_status {
 	uint64_t pko_rdy                      : 1;
 #endif
 	} s;
+	struct cvmx_pko_status_s              cn73xx;
 	struct cvmx_pko_status_s              cn78xx;
 };
 typedef union cvmx_pko_status cvmx_pko_status_t;
 
+/**
+ * cvmx_pko_txf#_pkt_cnt_rd
+ */
+union cvmx_pko_txfx_pkt_cnt_rd {
+	uint64_t u64;
+	struct cvmx_pko_txfx_pkt_cnt_rd_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t cnt                          : 8;  /**< Number of packets currently sitting in the given TX FIFO. */
+#else
+	uint64_t cnt                          : 8;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_pko_txfx_pkt_cnt_rd_s     cn73xx;
+};
+typedef union cvmx_pko_txfx_pkt_cnt_rd cvmx_pko_txfx_pkt_cnt_rd_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pow.h b/arch/mips/include/asm/octeon/cvmx-pow.h
index 12c6ec6..ab6420d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow.h
@@ -2391,7 +2391,7 @@ static inline void cvmx_pow_work_submit(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow
 		xgrp = (grp & 0x1f) << 3 ;
 		xgrp |= (qos & 7);
 		xgrp |= 0x300 & (node << 8);
- 
+
 		wqp->word1.cn78xx.rsvd_0 = 0;
 		wqp->word1.cn78xx.rsvd_1 = 0;
 		wqp->word1.cn78xx.tag = tag;
@@ -2464,7 +2464,7 @@ static inline void cvmx_pow_work_submit(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow
  * Note that the tag provided is for the work queue entry submitted,
  * and is unrelated to the tag that the core currently holds.
  *
- * @param wqp pointer to work queue entry to submit. 
+ * @param wqp pointer to work queue entry to submit.
  * This entry is updated to match the other parameters
  * @param tag tag value to be assigned to work queue entry
  * @param tag_type type of tag
@@ -2490,7 +2490,7 @@ static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvm
 
 		gxgrp = xgrp & 0xff;
 		gxgrp |= node << 8;
- 
+
 		wqp->word1.cn78xx.rsvd_0 = 0;
 		wqp->word1.cn78xx.rsvd_1 = 0;
 		wqp->word1.cn78xx.tag = tag;
@@ -2593,7 +2593,7 @@ static inline void cvmx_pow_set_group_mask(uint64_t core_num, uint64_t mask)
 
 		node = cvmx_coremask_core_to_node(core_num);
 		core = cvmx_coremask_core_on_node(core_num);
-	
+
 		/* 256 groups divided into 4 X 64 bit registers */
 		for (rix = 0; rix < (CVMX_SSO_NUM_XGRP >> 6); rix ++ ) {
 			grp_msk.u64 = 0;
@@ -2660,7 +2660,7 @@ static inline void cvmx_pow_set_xgrp_mask( uint64_t core_num,
 
 	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_dprintf(
-			"ERROR: %s is not supported on this chip)\n", 
+			"ERROR: %s is not supported on this chip)\n",
 			__FUNCTION__);
 		return;
 	}
@@ -2705,7 +2705,7 @@ static inline void cvmx_pow_set_xgrp_mask( uint64_t core_num,
  * 			<mask_set> values range from 0 to 3, where
  * 			each of the two bits represents a mask set.
  * 			Cores will be added to the mask set whith corresponding
- * 			bit set, and removed from the mask set with 
+ * 			bit set, and removed from the mask set with
  * 			corresponding bit clear.
  *
  * Note: cores can only accept work from SSO groups on the same node,
@@ -2722,7 +2722,7 @@ static inline void cvmx_sso_set_group_core_affinity(cvmx_xgrp_t xgrp,
 
 	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_dprintf(
-			"ERROR: %s is not supported on this chip)\n", 
+			"ERROR: %s is not supported on this chip)\n",
 			__FUNCTION__);
 		return;
 	}
@@ -2737,21 +2737,21 @@ static inline void cvmx_sso_set_group_core_affinity(cvmx_xgrp_t xgrp,
 		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(ncore, 0, grp_index);
 		grp_msk.u64 = cvmx_read_csr_node(node, reg_addr);
 
-		if(mask_set & 1) 
+		if(mask_set & 1)
 			grp_msk.s.grp_msk |= (1ull << bit_pos);
 		else
 			grp_msk.s.grp_msk &= ~(1ull << bit_pos);
-		
+
 		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
 
 		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(ncore, 1, grp_index);
 		grp_msk.u64 = cvmx_read_csr_node(node, reg_addr);
 
-		if(mask_set & 2) 
+		if(mask_set & 2)
 			grp_msk.s.grp_msk |= (1ull << bit_pos);
 		else
 			grp_msk.s.grp_msk &= ~(1ull << bit_pos);
-		
+
 		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
 	}
 }
@@ -2785,7 +2785,7 @@ static inline void cvmx_sso_set_group_priority(int node, cvmx_xgrp_t xgrp,
 
 	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_dprintf(
-			"ERROR: %s is not supported on this chip)\n", 
+			"ERROR: %s is not supported on this chip)\n",
 			__FUNCTION__);
 		return;
 	}
@@ -3153,22 +3153,26 @@ static inline uint32_t cvmx_pow_tag_get_hw_bits(uint64_t tag)
 	return (tag & cvmx_build_mask(32 - CVMX_TAG_SW_BITS));
 }
 
-static inline uint64_t cvmx_sso_get_total_wqe_count(void)
+static inline uint64_t cvmx_sso_get_total_wqe_count_78xx(int node)
 {
+	cvmx_sso_grpx_aq_cnt_t aq_cnt;
+	int grp = 0;
+	uint64_t cnt = 0;
+
+	for( grp = 0; grp < CVMX_SSO_NUM_XGRP; grp++) {
+		aq_cnt.u64 = cvmx_read_csr_node(node,
+				CVMX_SSO_GRPX_AQ_CNT(grp));
+		cnt += aq_cnt.s.aq_cnt;
+	}
+	return cnt;
+}
 
+static inline uint64_t cvmx_sso_get_total_wqe_count(void)
+{
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
 	{
-		cvmx_sso_grpx_aq_cnt_t aq_cnt;
 		int node = cvmx_get_node_num();
-		int grp = 0;
-		uint64_t cnt = 0;
-
-		for( grp = 0; grp < CVMX_SSO_NUM_XGRP; grp++) {
-			aq_cnt.u64 = cvmx_read_csr_node(node,
-					CVMX_SSO_GRPX_AQ_CNT(grp));
-			cnt += aq_cnt.s.aq_cnt;
-		}
-		return cnt;
+		return cvmx_sso_get_total_wqe_count_78xx(node);
 	}
 	else if (OCTEON_IS_MODEL(OCTEON_CN68XX))
 	{
diff --git a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
index b1bbfb5..f107e20 100644
--- a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
@@ -58,7 +58,7 @@
 #define CVMX_RNM_EER_DBG CVMX_RNM_EER_DBG_FUNC()
 static inline uint64_t CVMX_RNM_EER_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_EER_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000018ull);
 }
@@ -69,7 +69,7 @@ static inline uint64_t CVMX_RNM_EER_DBG_FUNC(void)
 #define CVMX_RNM_EER_KEY CVMX_RNM_EER_KEY_FUNC()
 static inline uint64_t CVMX_RNM_EER_KEY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_EER_KEY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000010ull);
 }
@@ -80,7 +80,7 @@ static inline uint64_t CVMX_RNM_EER_KEY_FUNC(void)
 #define CVMX_RNM_SERIAL_NUM CVMX_RNM_SERIAL_NUM_FUNC()
 static inline uint64_t CVMX_RNM_SERIAL_NUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_RNM_SERIAL_NUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000020ull);
 }
@@ -126,6 +126,7 @@ union cvmx_rnm_bist_status {
 	struct cvmx_rnm_bist_status_s         cn68xxp1;
 	struct cvmx_rnm_bist_status_s         cn70xx;
 	struct cvmx_rnm_bist_status_s         cn70xxp1;
+	struct cvmx_rnm_bist_status_s         cn73xx;
 	struct cvmx_rnm_bist_status_s         cn78xx;
 	struct cvmx_rnm_bist_status_s         cnf71xx;
 };
@@ -241,6 +242,7 @@ union cvmx_rnm_ctl_status {
 	struct cvmx_rnm_ctl_status_cn63xx     cn68xxp1;
 	struct cvmx_rnm_ctl_status_s          cn70xx;
 	struct cvmx_rnm_ctl_status_s          cn70xxp1;
+	struct cvmx_rnm_ctl_status_s          cn73xx;
 	struct cvmx_rnm_ctl_status_s          cn78xx;
 	struct cvmx_rnm_ctl_status_s          cnf71xx;
 };
@@ -269,6 +271,7 @@ union cvmx_rnm_eer_dbg {
 	struct cvmx_rnm_eer_dbg_s             cn68xxp1;
 	struct cvmx_rnm_eer_dbg_s             cn70xx;
 	struct cvmx_rnm_eer_dbg_s             cn70xxp1;
+	struct cvmx_rnm_eer_dbg_s             cn73xx;
 	struct cvmx_rnm_eer_dbg_s             cn78xx;
 	struct cvmx_rnm_eer_dbg_s             cnf71xx;
 };
@@ -299,6 +302,7 @@ union cvmx_rnm_eer_key {
 	struct cvmx_rnm_eer_key_s             cn68xxp1;
 	struct cvmx_rnm_eer_key_s             cn70xx;
 	struct cvmx_rnm_eer_key_s             cn70xxp1;
+	struct cvmx_rnm_eer_key_s             cn73xx;
 	struct cvmx_rnm_eer_key_s             cn78xx;
 	struct cvmx_rnm_eer_key_s             cnf71xx;
 };
@@ -331,6 +335,7 @@ union cvmx_rnm_serial_num {
 	struct cvmx_rnm_serial_num_s          cn68xxp1;
 	struct cvmx_rnm_serial_num_s          cn70xx;
 	struct cvmx_rnm_serial_num_s          cn70xxp1;
+	struct cvmx_rnm_serial_num_s          cn73xx;
 	struct cvmx_rnm_serial_num_s          cn78xx;
 	struct cvmx_rnm_serial_num_s          cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 17d74dc..873e9f0 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -53,10 +53,21 @@
 #define __CVMX_RST_DEFS_H__
 
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_BIST_TIMER CVMX_RST_BIST_TIMER_FUNC()
+static inline uint64_t CVMX_RST_BIST_TIMER_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_BIST_TIMER not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001760ull);
+}
+#else
+#define CVMX_RST_BIST_TIMER (CVMX_ADD_IO_SEG(0x0001180006001760ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_RST_BOOT CVMX_RST_BOOT_FUNC()
 static inline uint64_t CVMX_RST_BOOT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_BOOT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001600ull);
 }
@@ -67,7 +78,7 @@ static inline uint64_t CVMX_RST_BOOT_FUNC(void)
 #define CVMX_RST_CFG CVMX_RST_CFG_FUNC()
 static inline uint64_t CVMX_RST_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001610ull);
 }
@@ -78,7 +89,7 @@ static inline uint64_t CVMX_RST_CFG_FUNC(void)
 #define CVMX_RST_CKILL CVMX_RST_CKILL_FUNC()
 static inline uint64_t CVMX_RST_CKILL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_CKILL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001638ull);
 }
@@ -86,10 +97,22 @@ static inline uint64_t CVMX_RST_CKILL_FUNC(void)
 #define CVMX_RST_CKILL (CVMX_ADD_IO_SEG(0x0001180006001638ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_RST_COLD_DATAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_RST_COLD_DATAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800060017C0ull) + ((offset) & 3) * 8;
+}
+#else
+#define CVMX_RST_COLD_DATAX(offset) (CVMX_ADD_IO_SEG(0x00011800060017C0ull) + ((offset) & 3) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_RST_CTLX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_CTLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180006001640ull) + ((offset) & 3) * 8;
@@ -101,7 +124,7 @@ static inline uint64_t CVMX_RST_CTLX(unsigned long offset)
 #define CVMX_RST_DELAY CVMX_RST_DELAY_FUNC()
 static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_DELAY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001608ull);
 }
@@ -112,7 +135,7 @@ static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 #define CVMX_RST_ECO CVMX_RST_ECO_FUNC()
 static inline uint64_t CVMX_RST_ECO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800060017B8ull);
 }
@@ -123,7 +146,7 @@ static inline uint64_t CVMX_RST_ECO_FUNC(void)
 #define CVMX_RST_INT CVMX_RST_INT_FUNC()
 static inline uint64_t CVMX_RST_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001628ull);
 }
@@ -131,6 +154,17 @@ static inline uint64_t CVMX_RST_INT_FUNC(void)
 #define CVMX_RST_INT (CVMX_ADD_IO_SEG(0x0001180006001628ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_INT_W1S CVMX_RST_INT_W1S_FUNC()
+static inline uint64_t CVMX_RST_INT_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_INT_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001630ull);
+}
+#else
+#define CVMX_RST_INT_W1S (CVMX_ADD_IO_SEG(0x0001180006001630ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_RST_OCX CVMX_RST_OCX_FUNC()
 static inline uint64_t CVMX_RST_OCX_FUNC(void)
 {
@@ -142,10 +176,21 @@ static inline uint64_t CVMX_RST_OCX_FUNC(void)
 #define CVMX_RST_OCX (CVMX_ADD_IO_SEG(0x0001180006001618ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_OUT_CTL CVMX_RST_OUT_CTL_FUNC()
+static inline uint64_t CVMX_RST_OUT_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_OUT_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001688ull);
+}
+#else
+#define CVMX_RST_OUT_CTL (CVMX_ADD_IO_SEG(0x0001180006001688ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_RST_POWER_DBG CVMX_RST_POWER_DBG_FUNC()
 static inline uint64_t CVMX_RST_POWER_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_POWER_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001708ull);
 }
@@ -156,7 +201,7 @@ static inline uint64_t CVMX_RST_POWER_DBG_FUNC(void)
 #define CVMX_RST_PP_POWER CVMX_RST_PP_POWER_FUNC()
 static inline uint64_t CVMX_RST_PP_POWER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_PP_POWER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001700ull);
 }
@@ -164,10 +209,22 @@ static inline uint64_t CVMX_RST_PP_POWER_FUNC(void)
 #define CVMX_RST_PP_POWER (CVMX_ADD_IO_SEG(0x0001180006001700ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_REF_CNTR CVMX_RST_REF_CNTR_FUNC()
+static inline uint64_t CVMX_RST_REF_CNTR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_REF_CNTR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001758ull);
+}
+#else
+#define CVMX_RST_REF_CNTR (CVMX_ADD_IO_SEG(0x0001180006001758ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_RST_SOFT_PRSTX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_SOFT_PRSTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800060016C0ull) + ((offset) & 3) * 8;
@@ -179,13 +236,44 @@ static inline uint64_t CVMX_RST_SOFT_PRSTX(unsigned long offset)
 #define CVMX_RST_SOFT_RST CVMX_RST_SOFT_RST_FUNC()
 static inline uint64_t CVMX_RST_SOFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_RST_SOFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001680ull);
 }
 #else
 #define CVMX_RST_SOFT_RST (CVMX_ADD_IO_SEG(0x0001180006001680ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_THERMAL_ALERT CVMX_RST_THERMAL_ALERT_FUNC()
+static inline uint64_t CVMX_RST_THERMAL_ALERT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_RST_THERMAL_ALERT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180006001690ull);
+}
+#else
+#define CVMX_RST_THERMAL_ALERT (CVMX_ADD_IO_SEG(0x0001180006001690ull))
+#endif
+
+/**
+ * cvmx_rst_bist_timer
+ */
+union cvmx_rst_bist_timer {
+	uint64_t u64;
+	struct cvmx_rst_bist_timer_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t count                        : 29; /**< Number of 50 Mhz reference clocks that have elapsed during bist and repair during the last
+                                                         reset.
+                                                         If MSB is set the BIST chain did not complete as expected. */
+#else
+	uint64_t count                        : 29;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_rst_bist_timer_s          cn73xx;
+};
+typedef union cvmx_rst_bist_timer cvmx_rst_bist_timer_t;
 
 /**
  * cvmx_rst_boot
@@ -261,6 +349,7 @@ union cvmx_rst_boot {
 	} s;
 	struct cvmx_rst_boot_s                cn70xx;
 	struct cvmx_rst_boot_s                cn70xxp1;
+	struct cvmx_rst_boot_s                cn73xx;
 	struct cvmx_rst_boot_s                cn78xx;
 };
 typedef union cvmx_rst_boot cvmx_rst_boot_t;
@@ -278,6 +367,23 @@ union cvmx_rst_cfg {
                                                          will not change this field. */
 	uint64_t warm_clr_bist                : 1;  /**< Perform clear BIST during warm reset, instead of a full BIST. A warm/soft reset does not
                                                          change this field. Note that a cold reset always performs a full BIST. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t warm_clr_bist                : 1;
+	uint64_t cntl_clr_bist                : 1;
+	uint64_t reserved_3_5                 : 3;
+	uint64_t bist_delay                   : 58;
+#endif
+	} s;
+	struct cvmx_rst_cfg_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t bist_delay                   : 58; /**< Reserved. */
+	uint64_t reserved_3_5                 : 3;
+	uint64_t cntl_clr_bist                : 1;  /**< Perform clear BIST during control-only reset, instead of a full BIST. A warm/soft reset
+                                                         will not change this field. */
+	uint64_t warm_clr_bist                : 1;  /**< Perform clear BIST during warm reset, instead of a full BIST. A warm/soft reset does not
+                                                         change this field. Note that a cold reset always performs a full BIST. */
 	uint64_t soft_clr_bist                : 1;  /**< Perform clear BIST during soft reset, instead of a full BIST. A warm/soft reset does not
                                                          change this field. Note that a cold reset always performs a full BIST. */
 #else
@@ -287,10 +393,21 @@ union cvmx_rst_cfg {
 	uint64_t reserved_3_5                 : 3;
 	uint64_t bist_delay                   : 58;
 #endif
-	} s;
-	struct cvmx_rst_cfg_s                 cn70xx;
-	struct cvmx_rst_cfg_s                 cn70xxp1;
-	struct cvmx_rst_cfg_s                 cn78xx;
+	} cn70xx;
+	struct cvmx_rst_cfg_cn70xx            cn70xxp1;
+	struct cvmx_rst_cfg_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t bist_delay                   : 58; /**< Reserved. */
+	uint64_t reserved_1_5                 : 5;
+	uint64_t clr_bist                     : 1;  /**< Perform clear BIST during a reset, instead of a full BIST. A warm/soft reset does not
+                                                         change this field. Note that a cold reset always performs a full BIST. */
+#else
+	uint64_t clr_bist                     : 1;
+	uint64_t reserved_1_5                 : 5;
+	uint64_t bist_delay                   : 58;
+#endif
+	} cn73xx;
+	struct cvmx_rst_cfg_cn70xx            cn78xx;
 };
 typedef union cvmx_rst_cfg cvmx_rst_cfg_t;
 
@@ -311,11 +428,29 @@ union cvmx_rst_ckill {
 	} s;
 	struct cvmx_rst_ckill_s               cn70xx;
 	struct cvmx_rst_ckill_s               cn70xxp1;
+	struct cvmx_rst_ckill_s               cn73xx;
 	struct cvmx_rst_ckill_s               cn78xx;
 };
 typedef union cvmx_rst_ckill cvmx_rst_ckill_t;
 
 /**
+ * cvmx_rst_cold_data#
+ */
+union cvmx_rst_cold_datax {
+	uint64_t u64;
+	struct cvmx_rst_cold_datax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t data                         : 64; /**< Scratch data registers preserved through warm reset.
+                                                         Reset to 0x0 on cold reset. */
+#else
+	uint64_t data                         : 64;
+#endif
+	} s;
+	struct cvmx_rst_cold_datax_s          cn73xx;
+};
+typedef union cvmx_rst_cold_datax cvmx_rst_cold_datax_t;
+
+/**
  * cvmx_rst_ctl#
  */
 union cvmx_rst_ctlx {
@@ -381,6 +516,7 @@ union cvmx_rst_ctlx {
 	} s;
 	struct cvmx_rst_ctlx_s                cn70xx;
 	struct cvmx_rst_ctlx_s                cn70xxp1;
+	struct cvmx_rst_ctlx_s                cn73xx;
 	struct cvmx_rst_ctlx_s                cn78xx;
 };
 typedef union cvmx_rst_ctlx cvmx_rst_ctlx_t;
@@ -409,6 +545,7 @@ union cvmx_rst_delay {
 	} s;
 	struct cvmx_rst_delay_s               cn70xx;
 	struct cvmx_rst_delay_s               cn70xxp1;
+	struct cvmx_rst_delay_s               cn73xx;
 	struct cvmx_rst_delay_s               cn78xx;
 };
 typedef union cvmx_rst_delay cvmx_rst_delay_t;
@@ -427,6 +564,7 @@ union cvmx_rst_eco {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_rst_eco_s                 cn73xx;
 	struct cvmx_rst_eco_s                 cn78xx;
 };
 typedef union cvmx_rst_eco cvmx_rst_eco_t;
@@ -467,11 +605,36 @@ union cvmx_rst_int {
 #endif
 	} cn70xx;
 	struct cvmx_rst_int_cn70xx            cn70xxp1;
+	struct cvmx_rst_int_s                 cn73xx;
 	struct cvmx_rst_int_s                 cn78xx;
 };
 typedef union cvmx_rst_int cvmx_rst_int_t;
 
 /**
+ * cvmx_rst_int_w1s
+ */
+union cvmx_rst_int_w1s {
+	uint64_t u64;
+	struct cvmx_rst_int_w1s_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t perst                        : 4;  /**< PERST*_L asserted while RST_CTL()[RST_RCV] = 1 and RST_CTL()[RST_CHIP] = 0. One bit
+                                                         corresponds to each controller. */
+	uint64_t reserved_4_7                 : 4;
+	uint64_t rst_link                     : 4;  /**< A controller link-down/hot-reset occurred while RST_CTL()[RST_LINK] = 0. Software must
+                                                         assert then deassert RST_SOFT_PRST()[SOFT_PRST]. One bit corresponds to each controller. */
+#else
+	uint64_t rst_link                     : 4;
+	uint64_t reserved_4_7                 : 4;
+	uint64_t perst                        : 4;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_rst_int_w1s_s             cn73xx;
+};
+typedef union cvmx_rst_int_w1s cvmx_rst_int_w1s_t;
+
+/**
  * cvmx_rst_ocx
  */
 union cvmx_rst_ocx {
@@ -493,6 +656,27 @@ union cvmx_rst_ocx {
 typedef union cvmx_rst_ocx cvmx_rst_ocx_t;
 
 /**
+ * cvmx_rst_out_ctl
+ */
+union cvmx_rst_out_ctl {
+	uint64_t u64;
+	struct cvmx_rst_out_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t soft_rst                     : 1;  /**< Soft reset. When set to 1 by software, this field drives the RST_OUT_N pin
+                                                         active low. In this case the field must also be cleared by software to deassert
+                                                         the pin. The pin is also automatically asserted and deasserted by hardware
+                                                         during a cold/warm/soft reset. */
+#else
+	uint64_t soft_rst                     : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_rst_out_ctl_s             cn73xx;
+};
+typedef union cvmx_rst_out_ctl cvmx_rst_out_ctl_t;
+
+/**
  * cvmx_rst_power_dbg
  */
 union cvmx_rst_power_dbg {
@@ -506,6 +690,7 @@ union cvmx_rst_power_dbg {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} s;
+	struct cvmx_rst_power_dbg_s           cn73xx;
 	struct cvmx_rst_power_dbg_s           cn78xx;
 };
 typedef union cvmx_rst_power_dbg cvmx_rst_power_dbg_t;
@@ -540,11 +725,41 @@ union cvmx_rst_pp_power {
 #endif
 	} cn70xx;
 	struct cvmx_rst_pp_power_cn70xx       cn70xxp1;
+	struct cvmx_rst_pp_power_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t gate                         : 16; /**< Powerdown enable. When both a bit and the corresponding CIU_PP_RST bit are set, the core
+                                                         has voltage removed to save power. In typical operation these bits are setup during
+                                                         initialization and PP resets are controlled through CIU_PP_RST. These bits may only be
+                                                         changed when the corresponding core is in reset using CIU_PP_RST. */
+#else
+	uint64_t gate                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} cn73xx;
 	struct cvmx_rst_pp_power_s            cn78xx;
 };
 typedef union cvmx_rst_pp_power cvmx_rst_pp_power_t;
 
 /**
+ * cvmx_rst_ref_cntr
+ */
+union cvmx_rst_ref_cntr {
+	uint64_t u64;
+	struct cvmx_rst_ref_cntr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t cnt                          : 64; /**< Count. The counter is initialized to 0x0 during a cold reset and is otherwise continiously
+                                                         running.
+                                                         CNT is incremented every reference clock cycle (i.e. at 50 MHz). */
+#else
+	uint64_t cnt                          : 64;
+#endif
+	} s;
+	struct cvmx_rst_ref_cntr_s            cn73xx;
+};
+typedef union cvmx_rst_ref_cntr cvmx_rst_ref_cntr_t;
+
+/**
  * cvmx_rst_soft_prst#
  */
 union cvmx_rst_soft_prstx {
@@ -565,6 +780,7 @@ union cvmx_rst_soft_prstx {
 	} s;
 	struct cvmx_rst_soft_prstx_s          cn70xx;
 	struct cvmx_rst_soft_prstx_s          cn70xxp1;
+	struct cvmx_rst_soft_prstx_s          cn73xx;
 	struct cvmx_rst_soft_prstx_s          cn78xx;
 };
 typedef union cvmx_rst_soft_prstx cvmx_rst_soft_prstx_t;
@@ -586,8 +802,39 @@ union cvmx_rst_soft_rst {
 	} s;
 	struct cvmx_rst_soft_rst_s            cn70xx;
 	struct cvmx_rst_soft_rst_s            cn70xxp1;
+	struct cvmx_rst_soft_rst_s            cn73xx;
 	struct cvmx_rst_soft_rst_s            cn78xx;
 };
 typedef union cvmx_rst_soft_rst cvmx_rst_soft_rst_t;
 
+/**
+ * cvmx_rst_thermal_alert
+ */
+union cvmx_rst_thermal_alert {
+	uint64_t u64;
+	struct cvmx_rst_thermal_alert_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t trip                         : 1;  /**< This field is set by the onboard temperature sensor. For diagnostic use
+                                                         only. The bit can only be cleared by a deassertion of the PLL_DC_OK pin which
+                                                         completely resets the chip.
+                                                         INTERNAL: Not committed-to in 73xx HRM.
+                                                         Thermal trip pin. When set to 1, drives the THERMAL_TRIP_N pin active low. This field is
+                                                         set by the onboard temperature sensor reaching a failure threshold or writing this bit.
+                                                         The bit can only be cleared by a deassertion of the PLL_DC_OK pin which completely resets
+                                                         the chip. */
+	uint64_t reserved_1_7                 : 7;
+	uint64_t alert                        : 1;  /**< Thermal alert status. When set to 1, indicates the temperature sensor is currently at the
+                                                         failure threshold. */
+#else
+	uint64_t alert                        : 1;
+	uint64_t reserved_1_7                 : 7;
+	uint64_t trip                         : 1;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} s;
+	struct cvmx_rst_thermal_alert_s       cn73xx;
+};
+typedef union cvmx_rst_thermal_alert cvmx_rst_thermal_alert_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-sata-defs.h b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
index fe5b884..d109d3a 100644
--- a/arch/mips/include/asm/octeon/cvmx-sata-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
@@ -64,10 +64,21 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTAFR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_BISTAFR (CVMX_ADD_IO_SEG(0x00016C00000000A0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UAHC_GBL_BISTAFR_RXECNT CVMX_SATA_UAHC_GBL_BISTAFR_RXECNT_FUNC()
+static inline uint64_t CVMX_SATA_UAHC_GBL_BISTAFR_RXECNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTAFR_RXECNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00016C00000000A0ull);
+}
+#else
+#define CVMX_SATA_UAHC_GBL_BISTAFR_RXECNT (CVMX_ADD_IO_SEG(0x00016C00000000A0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SATA_UAHC_GBL_BISTCR CVMX_SATA_UAHC_GBL_BISTCR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_BISTCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000A4ull);
 }
@@ -86,10 +97,21 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTDECR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_BISTDECR (CVMX_ADD_IO_SEG(0x00016C00000000B0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UAHC_GBL_BISTDECR_FBSCN CVMX_SATA_UAHC_GBL_BISTDECR_FBSCN_FUNC()
+static inline uint64_t CVMX_SATA_UAHC_GBL_BISTDECR_FBSCN_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTDECR_FBSCN not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00016C00000000B0ull);
+}
+#else
+#define CVMX_SATA_UAHC_GBL_BISTDECR_FBSCN (CVMX_ADD_IO_SEG(0x00016C00000000B0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SATA_UAHC_GBL_BISTFCTR CVMX_SATA_UAHC_GBL_BISTFCTR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_BISTFCTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTFCTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000A8ull);
 }
@@ -100,7 +122,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTFCTR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_BISTSR CVMX_SATA_UAHC_GBL_BISTSR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_BISTSR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_BISTSR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000ACull);
 }
@@ -111,7 +133,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_BISTSR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_CAP CVMX_SATA_UAHC_GBL_CAP_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_CAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_CAP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000000ull);
 }
@@ -122,7 +144,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_CAP_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_CAP2 CVMX_SATA_UAHC_GBL_CAP2_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_CAP2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_CAP2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000024ull);
 }
@@ -133,7 +155,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_CAP2_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_CCC_CTL CVMX_SATA_UAHC_GBL_CCC_CTL_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_CCC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_CCC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000014ull);
 }
@@ -144,7 +166,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_CCC_CTL_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_CCC_PORTS CVMX_SATA_UAHC_GBL_CCC_PORTS_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_CCC_PORTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_CCC_PORTS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000018ull);
 }
@@ -155,7 +177,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_CCC_PORTS_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_GHC CVMX_SATA_UAHC_GBL_GHC_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_GHC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_GHC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000004ull);
 }
@@ -166,7 +188,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_GHC_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_GPARAM1R CVMX_SATA_UAHC_GBL_GPARAM1R_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_GPARAM1R_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_GPARAM1R not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000E8ull);
 }
@@ -177,7 +199,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_GPARAM1R_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_GPARAM2R CVMX_SATA_UAHC_GBL_GPARAM2R_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_GPARAM2R_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_GPARAM2R not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000ECull);
 }
@@ -188,7 +210,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_GPARAM2R_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_IDR CVMX_SATA_UAHC_GBL_IDR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_IDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_IDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000FCull);
 }
@@ -199,7 +221,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_IDR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_IS CVMX_SATA_UAHC_GBL_IS_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_IS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_IS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000008ull);
 }
@@ -210,7 +232,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_IS_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_OOBR CVMX_SATA_UAHC_GBL_OOBR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_OOBR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_OOBR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000BCull);
 }
@@ -221,7 +243,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_OOBR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_PI CVMX_SATA_UAHC_GBL_PI_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_PI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_PI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C000000000Cull);
 }
@@ -232,7 +254,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_PI_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_PPARAMR CVMX_SATA_UAHC_GBL_PPARAMR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_PPARAMR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_PPARAMR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000F0ull);
 }
@@ -243,7 +265,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_PPARAMR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_TESTR CVMX_SATA_UAHC_GBL_TESTR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_TESTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_TESTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000F4ull);
 }
@@ -254,7 +276,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_TESTR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_TIMER1MS CVMX_SATA_UAHC_GBL_TIMER1MS_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_TIMER1MS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_TIMER1MS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000E0ull);
 }
@@ -265,7 +287,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_TIMER1MS_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_VERSIONR CVMX_SATA_UAHC_GBL_VERSIONR_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_VERSIONR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_VERSIONR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C00000000F8ull);
 }
@@ -276,7 +298,7 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_VERSIONR_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_VS CVMX_SATA_UAHC_GBL_VS_FUNC()
 static inline uint64_t CVMX_SATA_UAHC_GBL_VS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UAHC_GBL_VS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016C0000000010ull);
 }
@@ -284,10 +306,33 @@ static inline uint64_t CVMX_SATA_UAHC_GBL_VS_FUNC(void)
 #define CVMX_SATA_UAHC_GBL_VS (CVMX_ADD_IO_SEG(0x00016C0000000010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UAHC_MEMDPCR CVMX_SATA_UAHC_MEMDPCR_FUNC()
+static inline uint64_t CVMX_SATA_UAHC_MEMDPCR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UAHC_MEMDPCR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00016C00000000E4ull);
+}
+#else
+#define CVMX_SATA_UAHC_MEMDPCR (CVMX_ADD_IO_SEG(0x00016C00000000E4ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UAHC_MEMEDERRINJ CVMX_SATA_UAHC_MEMEDERRINJ_FUNC()
+static inline uint64_t CVMX_SATA_UAHC_MEMEDERRINJ_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UAHC_MEMEDERRINJ not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00016C00000000B8ull);
+}
+#else
+#define CVMX_SATA_UAHC_MEMEDERRINJ (CVMX_ADD_IO_SEG(0x00016C00000000B8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SATA_UAHC_PX_CI(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_CI(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000138ull) + ((offset) & 1) * 128;
 }
@@ -298,7 +343,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_CI(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_CLB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_CLB(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000100ull) + ((offset) & 1) * 128;
 }
@@ -309,7 +355,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_CLB(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_CMD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_CMD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000118ull) + ((offset) & 1) * 128;
 }
@@ -320,7 +367,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_CMD(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_DMACR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_DMACR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000170ull) + ((offset) & 1) * 128;
 }
@@ -331,7 +379,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_DMACR(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_FB(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_FB(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000108ull) + ((offset) & 1) * 128;
 }
@@ -342,7 +391,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_FB(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_FBS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_FBS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000140ull) + ((offset) & 1) * 128;
 }
@@ -353,7 +403,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_FBS(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_IE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_IE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000114ull) + ((offset) & 1) * 128;
 }
@@ -364,7 +415,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_IE(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_IS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_IS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000110ull) + ((offset) & 1) * 128;
 }
@@ -375,7 +427,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_IS(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_PHYCR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_PHYCR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000178ull) + ((offset) & 1) * 128;
 }
@@ -386,7 +439,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_PHYCR(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_PHYSR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_PHYSR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C000000017Cull) + ((offset) & 1) * 128;
 }
@@ -397,7 +451,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_PHYSR(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SACT(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SACT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000134ull) + ((offset) & 1) * 128;
 }
@@ -408,7 +463,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SACT(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SCTL(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C000000012Cull) + ((offset) & 1) * 128;
 }
@@ -419,7 +475,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SCTL(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SERR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000130ull) + ((offset) & 1) * 128;
 }
@@ -430,7 +487,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SERR(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000124ull) + ((offset) & 1) * 128;
 }
@@ -441,7 +499,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SIG(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SNTF(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SNTF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C000000013Cull) + ((offset) & 1) * 128;
 }
@@ -452,7 +511,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SNTF(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_SSTS(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_SSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000128ull) + ((offset) & 1) * 128;
 }
@@ -463,7 +523,8 @@ static inline uint64_t CVMX_SATA_UAHC_PX_SSTS(unsigned long offset)
 static inline uint64_t CVMX_SATA_UAHC_PX_TFD(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SATA_UAHC_PX_TFD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016C0000000120ull) + ((offset) & 1) * 128;
 }
@@ -474,7 +535,7 @@ static inline uint64_t CVMX_SATA_UAHC_PX_TFD(unsigned long offset)
 #define CVMX_SATA_UCTL_BIST_STATUS CVMX_SATA_UCTL_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UCTL_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118006C000008ull);
 }
@@ -485,7 +546,7 @@ static inline uint64_t CVMX_SATA_UCTL_BIST_STATUS_FUNC(void)
 #define CVMX_SATA_UCTL_CTL CVMX_SATA_UCTL_CTL_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UCTL_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118006C000000ull);
 }
@@ -493,10 +554,21 @@ static inline uint64_t CVMX_SATA_UCTL_CTL_FUNC(void)
 #define CVMX_SATA_UCTL_CTL (CVMX_ADD_IO_SEG(0x000118006C000000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UCTL_ECC CVMX_SATA_UCTL_ECC_FUNC()
+static inline uint64_t CVMX_SATA_UCTL_ECC_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UCTL_ECC not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x000118006C0000F0ull);
+}
+#else
+#define CVMX_SATA_UCTL_ECC (CVMX_ADD_IO_SEG(0x000118006C0000F0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SATA_UCTL_INTSTAT CVMX_SATA_UCTL_INTSTAT_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_INTSTAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UCTL_INTSTAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118006C000030ull);
 }
@@ -507,7 +579,7 @@ static inline uint64_t CVMX_SATA_UCTL_INTSTAT_FUNC(void)
 #define CVMX_SATA_UCTL_SHIM_CFG CVMX_SATA_UCTL_SHIM_CFG_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_SHIM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SATA_UCTL_SHIM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118006C0000E8ull);
 }
@@ -526,6 +598,17 @@ static inline uint64_t CVMX_SATA_UCTL_SPARE0_FUNC(void)
 #define CVMX_SATA_UCTL_SPARE0 (CVMX_ADD_IO_SEG(0x000118006C000010ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UCTL_SPARE0_ECO CVMX_SATA_UCTL_SPARE0_ECO_FUNC()
+static inline uint64_t CVMX_SATA_UCTL_SPARE0_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UCTL_SPARE0_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x000118006C000010ull);
+}
+#else
+#define CVMX_SATA_UCTL_SPARE0_ECO (CVMX_ADD_IO_SEG(0x000118006C000010ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SATA_UCTL_SPARE1 CVMX_SATA_UCTL_SPARE1_FUNC()
 static inline uint64_t CVMX_SATA_UCTL_SPARE1_FUNC(void)
 {
@@ -536,6 +619,17 @@ static inline uint64_t CVMX_SATA_UCTL_SPARE1_FUNC(void)
 #else
 #define CVMX_SATA_UCTL_SPARE1 (CVMX_ADD_IO_SEG(0x000118006C0000F8ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SATA_UCTL_SPARE1_ECO CVMX_SATA_UCTL_SPARE1_ECO_FUNC()
+static inline uint64_t CVMX_SATA_UCTL_SPARE1_ECO_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+		cvmx_warn("CVMX_SATA_UCTL_SPARE1_ECO not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x000118006C0000F8ull);
+}
+#else
+#define CVMX_SATA_UCTL_SPARE1_ECO (CVMX_ADD_IO_SEG(0x000118006C0000F8ull))
+#endif
 
 /**
  * cvmx_sata_uahc_gbl_bistafr
@@ -579,6 +673,62 @@ union cvmx_sata_uahc_gbl_bistafr {
 typedef union cvmx_sata_uahc_gbl_bistafr cvmx_sata_uahc_gbl_bistafr_t;
 
 /**
+ * cvmx_sata_uahc_gbl_bistafr_rxecnt
+ *
+ * INTERNAL: See DWC_ahsata databook v4.10a
+ * This register has two functions depending on the value of SATA_UAHC_GBL_TESTR[BSEL]
+ * If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+ *    This register is shared between SATA ports.  Before accessing this
+ *    register, first select the required port by writing the port number
+ *    to the SATA_UAHC_GBL_TESTR[PSEL] field.
+ *    This register contains the pattern definition (bits 23:16 of the
+ *    first DWORD) and the data pattern (bits 7:0 of the second DWORD)
+ *    fields of the received BIST activate FIS.
+ * If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+ *    This is read-only per-port ECC/Parity RX FIFO RAM Data error count register. The
+ * uncorrectable error
+ *    counter (bits[7:0]) increments when there are uncorrectable errors detected during read of
+ * the data stored in
+ *    the RX FIFO RAM. The correctable error counter (bits[15:8]) increments when there are
+ * correctable errors
+ *    detected during read of the data stored in the RX FIFO RAM.
+ */
+union cvmx_sata_uahc_gbl_bistafr_rxecnt {
+	uint32_t u32;
+	struct cvmx_sata_uahc_gbl_bistafr_rxecnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_16_31               : 16;
+	uint32_t ncp_or_mem_rxf_corr_err      : 8;  /**< If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+                                                            Bits 7:0 of the second DWORD of BIST activate FIS.
+                                                            0xF1 = low transition density pattern (LTDP)
+                                                            0xB5 = high transition density pattern (HTDP)
+                                                            0xAB = low frequency spectral component pattern (LFSCP)
+                                                            0x7F = simultaneous switching outputs pattern (SSOP)
+                                                            0x78 = mid frequency test pattern (MFTP)
+                                                            0x4A = high frequency test pattern (HFTP)
+                                                            0x7E = low frequency test pattern (LFTP)
+                                                            All other values = lone bit pattern (LBP)
+                                                         If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+                                                            RX FIFO Corrected RAM Data error count. */
+	uint32_t pd_or_mem_rxf_uncorr_err     : 8;  /**< If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+                                                            Bits 23:16 of the first DWORD of the BIST activate FIS. Only the following values are
+                                                            supported:
+                                                            0x10 = Far-end retimed
+                                                            0xC0 = Far-end transmit only
+                                                            0xE0 = Far-end transmit only with scrambler bypassed
+                                                         If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+                                                            RX FIFO Uncorrected RAM Data error count. */
+#else
+	uint32_t pd_or_mem_rxf_uncorr_err     : 8;
+	uint32_t ncp_or_mem_rxf_corr_err      : 8;
+	uint32_t reserved_16_31               : 16;
+#endif
+	} s;
+	struct cvmx_sata_uahc_gbl_bistafr_rxecnt_s cn73xx;
+};
+typedef union cvmx_sata_uahc_gbl_bistafr_rxecnt cvmx_sata_uahc_gbl_bistafr_rxecnt_t;
+
+/**
  * cvmx_sata_uahc_gbl_bistcr
  *
  * INTERNAL: See DWC_ahsata databook v4.10a
@@ -638,6 +788,7 @@ union cvmx_sata_uahc_gbl_bistcr {
 	} s;
 	struct cvmx_sata_uahc_gbl_bistcr_s    cn70xx;
 	struct cvmx_sata_uahc_gbl_bistcr_s    cn70xxp1;
+	struct cvmx_sata_uahc_gbl_bistcr_s    cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_bistcr cvmx_sata_uahc_gbl_bistcr_t;
 
@@ -664,24 +815,103 @@ union cvmx_sata_uahc_gbl_bistdecr {
 typedef union cvmx_sata_uahc_gbl_bistdecr cvmx_sata_uahc_gbl_bistdecr_t;
 
 /**
+ * cvmx_sata_uahc_gbl_bistdecr_fbscn
+ *
+ * INTERNAL: See DWC_ahsata databook v4.10a
+ * This register has two functions depending on the value of SATA_UAHC_GBL_TESTR[BSEL]
+ * If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+ *    This register is shared between SATA ports.  Before accessing this
+ *    register, first select the required port by writing the port number
+ *    to the SATA_UAHC_GBL_TESTR[PSEL] field.
+ * If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+ *    This is read-only per-port ECC/Parity FBS FIFO RAM Data error count register. The
+ * uncorrectable error
+ *    counter (bits[7:0]) increments when there are uncorrectable errors detected during read of
+ * the data stored in
+ *    the FBS FIFO RAM. The correctable error counter (bits[15:8]) increments when there are
+ * correctable errors
+ *    detected during read of the data stored in the FBS FIFO RAM.
+ */
+union cvmx_sata_uahc_gbl_bistdecr_fbscn {
+	uint32_t u32;
+	struct cvmx_sata_uahc_gbl_bistdecr_fbscn_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t dwerr                        : 16; /**< DWORD error count bits 31:16. */
+	uint32_t dwer_or_mem_fbs_corr_err_cnt : 8;  /**< If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+                                                            DWORD error count bits 15:8.
+                                                         If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+                                                            FBS Corrected RAM Data Error Count */
+	uint32_t dwer_or_mem_fbs_uncorr_err_cnt : 8;/**< If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+                                                            DWORD error count bits 7:0.
+                                                         If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+                                                            FBS Uncorrected RAM Data Error Count */
+#else
+	uint32_t dwer_or_mem_fbs_uncorr_err_cnt : 8;
+	uint32_t dwer_or_mem_fbs_corr_err_cnt : 8;
+	uint32_t dwerr                        : 16;
+#endif
+	} s;
+	struct cvmx_sata_uahc_gbl_bistdecr_fbscn_s cn73xx;
+};
+typedef union cvmx_sata_uahc_gbl_bistdecr_fbscn cvmx_sata_uahc_gbl_bistdecr_fbscn_t;
+
+/**
  * cvmx_sata_uahc_gbl_bistfctr
  *
  * INTERNAL: See DWC_ahsata databook v4.10a
- * This register is shared between SATA ports.  Before accessing this
- * register, first select the required port by writing the port number
- * to the SATA_UAHC_GBL_TESTR[PSEL] field.
+ * This register has two functions depending on the value of SATA_UAHC_GBL_TESTR[BSEL]
+ * If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+ *    This register is shared between SATA ports.  Before accessing this
+ *    register, first select the required port by writing the port number
+ *    to the SATA_UAHC_GBL_TESTR[PSEL] field.
+ * If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+ *    This is read-only per-port ECC/Parity TX FIFO RAM Data error count register. The
+ * uncorrectable error
+ *    counter (bits[7:0]) increments when there are uncorrectable errors detected during read of
+ * the data stored in
+ *    the TX FIFO RAM. The correctable error counter (bits[15:8]) increments when there are
+ * correctable errors
+ *    detected during read of the data stored in the TX FIFO RAM.
  */
 union cvmx_sata_uahc_gbl_bistfctr {
 	uint32_t u32;
 	struct cvmx_sata_uahc_gbl_bistfctr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_0_31                : 32;
+#else
+	uint32_t reserved_0_31                : 32;
+#endif
+	} s;
+	struct cvmx_sata_uahc_gbl_bistfctr_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t count                        : 32; /**< Received BIST FIS count. */
 #else
 	uint32_t count                        : 32;
 #endif
-	} s;
-	struct cvmx_sata_uahc_gbl_bistfctr_s  cn70xx;
-	struct cvmx_sata_uahc_gbl_bistfctr_s  cn70xxp1;
+	} cn70xx;
+	struct cvmx_sata_uahc_gbl_bistfctr_cn70xx cn70xxp1;
+	struct cvmx_sata_uahc_gbl_bistfctr_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t count                        : 16; /**< If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+                                                            Received BIST FIS count bits 31:16
+                                                         If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+                                                            N/A */
+	uint32_t mem_txf_corr_err_count       : 8;  /**< If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+                                                            Received BIST FIS count bits 15:8
+                                                         If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+                                                            TX FIFO Corrected RAM Data error count
+                                                            N/A */
+	uint32_t mem_txf_uncorr_err_count     : 8;  /**< If SATA_UAHC_GBL_TESTR[BSEL] == 0:
+                                                            Received BIST FIS count bits 7:0
+                                                         If SATA_UAHC_GBL_TESTR[BSEL] == 1:
+                                                            TX FIFO Uncorrected RAM Data error count
+                                                            N/A */
+#else
+	uint32_t mem_txf_uncorr_err_count     : 8;
+	uint32_t mem_txf_corr_err_count       : 8;
+	uint32_t count                        : 16;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_bistfctr cvmx_sata_uahc_gbl_bistfctr_t;
 
@@ -706,6 +936,7 @@ union cvmx_sata_uahc_gbl_bistsr {
 	} s;
 	struct cvmx_sata_uahc_gbl_bistsr_s    cn70xx;
 	struct cvmx_sata_uahc_gbl_bistsr_s    cn70xxp1;
+	struct cvmx_sata_uahc_gbl_bistsr_s    cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_bistsr cvmx_sata_uahc_gbl_bistsr_t;
 
@@ -766,6 +997,7 @@ union cvmx_sata_uahc_gbl_cap {
 	} s;
 	struct cvmx_sata_uahc_gbl_cap_s       cn70xx;
 	struct cvmx_sata_uahc_gbl_cap_s       cn70xxp1;
+	struct cvmx_sata_uahc_gbl_cap_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_cap cvmx_sata_uahc_gbl_cap_t;
 
@@ -798,6 +1030,7 @@ union cvmx_sata_uahc_gbl_cap2 {
 	} s;
 	struct cvmx_sata_uahc_gbl_cap2_s      cn70xx;
 	struct cvmx_sata_uahc_gbl_cap2_s      cn70xxp1;
+	struct cvmx_sata_uahc_gbl_cap2_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_cap2 cvmx_sata_uahc_gbl_cap2_t;
 
@@ -826,6 +1059,7 @@ union cvmx_sata_uahc_gbl_ccc_ctl {
 	} s;
 	struct cvmx_sata_uahc_gbl_ccc_ctl_s   cn70xx;
 	struct cvmx_sata_uahc_gbl_ccc_ctl_s   cn70xxp1;
+	struct cvmx_sata_uahc_gbl_ccc_ctl_s   cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_ccc_ctl cvmx_sata_uahc_gbl_ccc_ctl_t;
 
@@ -848,6 +1082,7 @@ union cvmx_sata_uahc_gbl_ccc_ports {
 	} s;
 	struct cvmx_sata_uahc_gbl_ccc_ports_s cn70xx;
 	struct cvmx_sata_uahc_gbl_ccc_ports_s cn70xxp1;
+	struct cvmx_sata_uahc_gbl_ccc_ports_s cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_ccc_ports cvmx_sata_uahc_gbl_ccc_ports_t;
 
@@ -874,6 +1109,7 @@ union cvmx_sata_uahc_gbl_ghc {
 	} s;
 	struct cvmx_sata_uahc_gbl_ghc_s       cn70xx;
 	struct cvmx_sata_uahc_gbl_ghc_s       cn70xxp1;
+	struct cvmx_sata_uahc_gbl_ghc_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_ghc cvmx_sata_uahc_gbl_ghc_t;
 
@@ -920,6 +1156,7 @@ union cvmx_sata_uahc_gbl_gparam1r {
 	} s;
 	struct cvmx_sata_uahc_gbl_gparam1r_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_gparam1r_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_gparam1r_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_gparam1r cvmx_sata_uahc_gbl_gparam1r_t;
 
@@ -962,6 +1199,7 @@ union cvmx_sata_uahc_gbl_gparam2r {
 	} s;
 	struct cvmx_sata_uahc_gbl_gparam2r_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_gparam2r_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_gparam2r_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_gparam2r cvmx_sata_uahc_gbl_gparam2r_t;
 
@@ -982,6 +1220,7 @@ union cvmx_sata_uahc_gbl_idr {
 	} s;
 	struct cvmx_sata_uahc_gbl_idr_s       cn70xx;
 	struct cvmx_sata_uahc_gbl_idr_s       cn70xxp1;
+	struct cvmx_sata_uahc_gbl_idr_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_idr cvmx_sata_uahc_gbl_idr_t;
 
@@ -1004,6 +1243,7 @@ union cvmx_sata_uahc_gbl_is {
 	} s;
 	struct cvmx_sata_uahc_gbl_is_s        cn70xx;
 	struct cvmx_sata_uahc_gbl_is_s        cn70xxp1;
+	struct cvmx_sata_uahc_gbl_is_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_is cvmx_sata_uahc_gbl_is_t;
 
@@ -1034,6 +1274,7 @@ union cvmx_sata_uahc_gbl_oobr {
 	} s;
 	struct cvmx_sata_uahc_gbl_oobr_s      cn70xx;
 	struct cvmx_sata_uahc_gbl_oobr_s      cn70xxp1;
+	struct cvmx_sata_uahc_gbl_oobr_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_oobr cvmx_sata_uahc_gbl_oobr_t;
 
@@ -1056,6 +1297,7 @@ union cvmx_sata_uahc_gbl_pi {
 	} s;
 	struct cvmx_sata_uahc_gbl_pi_s        cn70xx;
 	struct cvmx_sata_uahc_gbl_pi_s        cn70xxp1;
+	struct cvmx_sata_uahc_gbl_pi_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_pi cvmx_sata_uahc_gbl_pi_t;
 
@@ -1088,6 +1330,7 @@ union cvmx_sata_uahc_gbl_pparamr {
 	} s;
 	struct cvmx_sata_uahc_gbl_pparamr_s   cn70xx;
 	struct cvmx_sata_uahc_gbl_pparamr_s   cn70xxp1;
+	struct cvmx_sata_uahc_gbl_pparamr_s   cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_pparamr cvmx_sata_uahc_gbl_pparamr_t;
 
@@ -1101,6 +1344,26 @@ union cvmx_sata_uahc_gbl_testr {
 	uint32_t u32;
 	struct cvmx_sata_uahc_gbl_testr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_25_31               : 7;
+	uint32_t bsel                         : 1;  /**< This field is used to select a bank for BIST or Data Protection
+                                                         operation. The options for this field are:
+                                                         0x0 - BIST registers selected
+                                                         0x1 - Data Protection registers selected */
+	uint32_t reserved_19_23               : 5;
+	uint32_t psel                         : 3;  /**< Port select. */
+	uint32_t reserved_1_15                : 15;
+	uint32_t test_if                      : 1;  /**< Test interface. */
+#else
+	uint32_t test_if                      : 1;
+	uint32_t reserved_1_15                : 15;
+	uint32_t psel                         : 3;
+	uint32_t reserved_19_23               : 5;
+	uint32_t bsel                         : 1;
+	uint32_t reserved_25_31               : 7;
+#endif
+	} s;
+	struct cvmx_sata_uahc_gbl_testr_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_19_31               : 13;
 	uint32_t psel                         : 3;  /**< Port select. */
 	uint32_t reserved_1_15                : 15;
@@ -1111,9 +1374,9 @@ union cvmx_sata_uahc_gbl_testr {
 	uint32_t psel                         : 3;
 	uint32_t reserved_19_31               : 13;
 #endif
-	} s;
-	struct cvmx_sata_uahc_gbl_testr_s     cn70xx;
-	struct cvmx_sata_uahc_gbl_testr_s     cn70xxp1;
+	} cn70xx;
+	struct cvmx_sata_uahc_gbl_testr_cn70xx cn70xxp1;
+	struct cvmx_sata_uahc_gbl_testr_s     cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_testr cvmx_sata_uahc_gbl_testr_t;
 
@@ -1136,6 +1399,7 @@ union cvmx_sata_uahc_gbl_timer1ms {
 	} s;
 	struct cvmx_sata_uahc_gbl_timer1ms_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_timer1ms_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_timer1ms_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_timer1ms cvmx_sata_uahc_gbl_timer1ms_t;
 
@@ -1156,6 +1420,7 @@ union cvmx_sata_uahc_gbl_versionr {
 	} s;
 	struct cvmx_sata_uahc_gbl_versionr_s  cn70xx;
 	struct cvmx_sata_uahc_gbl_versionr_s  cn70xxp1;
+	struct cvmx_sata_uahc_gbl_versionr_s  cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_versionr cvmx_sata_uahc_gbl_versionr_t;
 
@@ -1178,10 +1443,119 @@ union cvmx_sata_uahc_gbl_vs {
 	} s;
 	struct cvmx_sata_uahc_gbl_vs_s        cn70xx;
 	struct cvmx_sata_uahc_gbl_vs_s        cn70xxp1;
+	struct cvmx_sata_uahc_gbl_vs_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_vs cvmx_sata_uahc_gbl_vs_t;
 
 /**
+ * cvmx_sata_uahc_memdpcr
+ *
+ * INTERNAL: See DWC_ahsata databook v4.20a
+ *
+ */
+union cvmx_sata_uahc_memdpcr {
+	uint32_t u32;
+	struct cvmx_sata_uahc_memdpcr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_8_31                : 24;
+	uint32_t mem_ed_log_clr_en            : 1;  /**< Determines when to clear error
+                                                          detection and correction registers:
+                                                         - 0: All error detection and correction
+                                                          logging registers are cleared by Global
+                                                          or COMRESET
+                                                         - 1: All error detection and correction
+                                                          logging registers are cleared only when
+                                                          SATA_UAHC_MEMDPCR[EM_ED_LOG_CLR] is set */
+	uint32_t mem_ed_log_clr               : 1;  /**< Clears all error detection and correction
+                                                         logging registers when written. Bit
+                                                         clears itself a cycle after written. */
+	uint32_t mem_ed_log_dis               : 1;  /**< Disables error detection and correction
+                                                         logging registers when set. */
+	uint32_t mem_ed_ce_en                 : 1;  /**< Enables correctable error detection
+                                                         interrupt (INFS)
+                                                         (Diagnostic purposes only) */
+	uint32_t mem_ed_pdmaf_dis             : 1;  /**< Disables PDMA from entering fatal error
+                                                         state when an uncorrectable error is
+                                                         detected. (Diagnostic purposes only) */
+	uint32_t mem_ed_ifs_dis               : 1;  /**< Disables setting IFS interrupt register
+                                                         bit (interface fatal error status interrupt)
+                                                         when an uncorrectable error is detected
+                                                         when MEM_DP_TYPE selects ECC, or
+                                                         a Parity error is detected when
+                                                         MEM_DP_TYPE selects Parity. */
+	uint32_t mem_ec_single_dis            : 1;  /**< Error correction disable. When set,
+                                                         disables the single error correcting
+                                                         features everywhere, and all errors are
+                                                         reported as "uncorrectable". Has no
+                                                         effect when MEM_DP_TYPE = Parity or
+                                                         when MEM_DP_EN = 0. */
+	uint32_t mem_ec_all_dis               : 1;  /**< Global ECC/Parity Control signal. All
+                                                         ECC/Parity error detection, correction,
+                                                         interrupt generation and Fatal error
+                                                         state transitions are disabled when this
+                                                         bit is set to 1. Has no effect when the
+                                                         hardware parameter MEM_DP_EN = 0. */
+#else
+	uint32_t mem_ec_all_dis               : 1;
+	uint32_t mem_ec_single_dis            : 1;
+	uint32_t mem_ed_ifs_dis               : 1;
+	uint32_t mem_ed_pdmaf_dis             : 1;
+	uint32_t mem_ed_ce_en                 : 1;
+	uint32_t mem_ed_log_dis               : 1;
+	uint32_t mem_ed_log_clr               : 1;
+	uint32_t mem_ed_log_clr_en            : 1;
+	uint32_t reserved_8_31                : 24;
+#endif
+	} s;
+	struct cvmx_sata_uahc_memdpcr_s       cn73xx;
+};
+typedef union cvmx_sata_uahc_memdpcr cvmx_sata_uahc_memdpcr_t;
+
+/**
+ * cvmx_sata_uahc_memederrinj
+ *
+ * This per-port register controls the ECC/Parity error injection functionality. Single-bit and
+ * double-bit
+ * pseudo-random errors can be injected in each of the three memory interfaces (RX FIFO RAM, TX
+ * FIFO
+ * RAM, FBS RAM). The register allows for just one memory element to be injected with an error or
+ * for
+ * continuous error injection in each memory element.
+ */
+union cvmx_sata_uahc_memederrinj {
+	uint32_t u32;
+	struct cvmx_sata_uahc_memederrinj_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_18_31               : 14;
+	uint32_t uncorrerrdet                 : 1;  /**< Indicates a single bit uncorrected, or multiple bit error was detected */
+	uint32_t correrrdet                   : 1;  /**< Indicates a single bit corrected */
+	uint32_t reserved_5_15                : 11;
+	uint32_t ecc_1b_2b                    : 1;  /**< Selects 'single-bit'(0) or 'two-bit'(1) errors */
+	uint32_t cont                         : 1;  /**< Selects 'one-shot'(0) or 'continuous'(1) errors */
+	uint32_t mem_sel                      : 2;  /**< Selects memory location to inject error:
+                                                         2'b00: All three memory interfaces
+                                                         2'b01: RX FIFO Memory
+                                                         2'b10: TX FIFO Memory
+                                                         2'b11: FBS RAM */
+	uint32_t err_inj_valid                : 1;  /**< Error injection valid signal
+                                                         The values in the rest of the fields of this register
+                                                         are valid only when this bit is set to 1. */
+#else
+	uint32_t err_inj_valid                : 1;
+	uint32_t mem_sel                      : 2;
+	uint32_t cont                         : 1;
+	uint32_t ecc_1b_2b                    : 1;
+	uint32_t reserved_5_15                : 11;
+	uint32_t correrrdet                   : 1;
+	uint32_t uncorrerrdet                 : 1;
+	uint32_t reserved_18_31               : 14;
+#endif
+	} s;
+	struct cvmx_sata_uahc_memederrinj_s   cn73xx;
+};
+typedef union cvmx_sata_uahc_memederrinj cvmx_sata_uahc_memederrinj_t;
+
+/**
  * cvmx_sata_uahc_p#_ci
  *
  * INTERNAL: See DWC_ahsata databook v4.10a
@@ -1198,6 +1572,7 @@ union cvmx_sata_uahc_px_ci {
 	} s;
 	struct cvmx_sata_uahc_px_ci_s         cn70xx;
 	struct cvmx_sata_uahc_px_ci_s         cn70xxp1;
+	struct cvmx_sata_uahc_px_ci_s         cn73xx;
 };
 typedef union cvmx_sata_uahc_px_ci cvmx_sata_uahc_px_ci_t;
 
@@ -1220,6 +1595,7 @@ union cvmx_sata_uahc_px_clb {
 	} s;
 	struct cvmx_sata_uahc_px_clb_s        cn70xx;
 	struct cvmx_sata_uahc_px_clb_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_clb_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_clb cvmx_sata_uahc_px_clb_t;
 
@@ -1285,6 +1661,7 @@ union cvmx_sata_uahc_px_cmd {
 	} s;
 	struct cvmx_sata_uahc_px_cmd_s        cn70xx;
 	struct cvmx_sata_uahc_px_cmd_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_cmd_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_cmd cvmx_sata_uahc_px_cmd_t;
 
@@ -1311,6 +1688,7 @@ union cvmx_sata_uahc_px_dmacr {
 	} s;
 	struct cvmx_sata_uahc_px_dmacr_s      cn70xx;
 	struct cvmx_sata_uahc_px_dmacr_s      cn70xxp1;
+	struct cvmx_sata_uahc_px_dmacr_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_px_dmacr cvmx_sata_uahc_px_dmacr_t;
 
@@ -1333,6 +1711,7 @@ union cvmx_sata_uahc_px_fb {
 	} s;
 	struct cvmx_sata_uahc_px_fb_s         cn70xx;
 	struct cvmx_sata_uahc_px_fb_s         cn70xxp1;
+	struct cvmx_sata_uahc_px_fb_s         cn73xx;
 };
 typedef union cvmx_sata_uahc_px_fb cvmx_sata_uahc_px_fb_t;
 
@@ -1367,6 +1746,7 @@ union cvmx_sata_uahc_px_fbs {
 	} s;
 	struct cvmx_sata_uahc_px_fbs_s        cn70xx;
 	struct cvmx_sata_uahc_px_fbs_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_fbs_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_fbs cvmx_sata_uahc_px_fbs_t;
 
@@ -1423,6 +1803,7 @@ union cvmx_sata_uahc_px_ie {
 	} s;
 	struct cvmx_sata_uahc_px_ie_s         cn70xx;
 	struct cvmx_sata_uahc_px_ie_s         cn70xxp1;
+	struct cvmx_sata_uahc_px_ie_s         cn73xx;
 };
 typedef union cvmx_sata_uahc_px_ie cvmx_sata_uahc_px_ie_t;
 
@@ -1479,6 +1860,7 @@ union cvmx_sata_uahc_px_is {
 	} s;
 	struct cvmx_sata_uahc_px_is_s         cn70xx;
 	struct cvmx_sata_uahc_px_is_s         cn70xxp1;
+	struct cvmx_sata_uahc_px_is_s         cn73xx;
 };
 typedef union cvmx_sata_uahc_px_is cvmx_sata_uahc_px_is_t;
 
@@ -1499,6 +1881,7 @@ union cvmx_sata_uahc_px_phycr {
 	} s;
 	struct cvmx_sata_uahc_px_phycr_s      cn70xx;
 	struct cvmx_sata_uahc_px_phycr_s      cn70xxp1;
+	struct cvmx_sata_uahc_px_phycr_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_px_phycr cvmx_sata_uahc_px_phycr_t;
 
@@ -1519,6 +1902,7 @@ union cvmx_sata_uahc_px_physr {
 	} s;
 	struct cvmx_sata_uahc_px_physr_s      cn70xx;
 	struct cvmx_sata_uahc_px_physr_s      cn70xxp1;
+	struct cvmx_sata_uahc_px_physr_s      cn73xx;
 };
 typedef union cvmx_sata_uahc_px_physr cvmx_sata_uahc_px_physr_t;
 
@@ -1539,6 +1923,7 @@ union cvmx_sata_uahc_px_sact {
 	} s;
 	struct cvmx_sata_uahc_px_sact_s       cn70xx;
 	struct cvmx_sata_uahc_px_sact_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_sact_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_sact cvmx_sata_uahc_px_sact_t;
 
@@ -1569,6 +1954,7 @@ union cvmx_sata_uahc_px_sctl {
 	} s;
 	struct cvmx_sata_uahc_px_sctl_s       cn70xx;
 	struct cvmx_sata_uahc_px_sctl_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_sctl_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_sctl cvmx_sata_uahc_px_sctl_t;
 
@@ -1627,6 +2013,7 @@ union cvmx_sata_uahc_px_serr {
 	} s;
 	struct cvmx_sata_uahc_px_serr_s       cn70xx;
 	struct cvmx_sata_uahc_px_serr_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_serr_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_serr cvmx_sata_uahc_px_serr_t;
 
@@ -1647,6 +2034,7 @@ union cvmx_sata_uahc_px_sig {
 	} s;
 	struct cvmx_sata_uahc_px_sig_s        cn70xx;
 	struct cvmx_sata_uahc_px_sig_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_sig_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_sig cvmx_sata_uahc_px_sig_t;
 
@@ -1669,6 +2057,7 @@ union cvmx_sata_uahc_px_sntf {
 	} s;
 	struct cvmx_sata_uahc_px_sntf_s       cn70xx;
 	struct cvmx_sata_uahc_px_sntf_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_sntf_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_sntf cvmx_sata_uahc_px_sntf_t;
 
@@ -1695,6 +2084,7 @@ union cvmx_sata_uahc_px_ssts {
 	} s;
 	struct cvmx_sata_uahc_px_ssts_s       cn70xx;
 	struct cvmx_sata_uahc_px_ssts_s       cn70xxp1;
+	struct cvmx_sata_uahc_px_ssts_s       cn73xx;
 };
 typedef union cvmx_sata_uahc_px_ssts cvmx_sata_uahc_px_ssts_t;
 
@@ -1719,6 +2109,7 @@ union cvmx_sata_uahc_px_tfd {
 	} s;
 	struct cvmx_sata_uahc_px_tfd_s        cn70xx;
 	struct cvmx_sata_uahc_px_tfd_s        cn70xxp1;
+	struct cvmx_sata_uahc_px_tfd_s        cn73xx;
 };
 typedef union cvmx_sata_uahc_px_tfd cvmx_sata_uahc_px_tfd_t;
 
@@ -1771,6 +2162,7 @@ union cvmx_sata_uctl_bist_status {
 	} s;
 	struct cvmx_sata_uctl_bist_status_s   cn70xx;
 	struct cvmx_sata_uctl_bist_status_s   cn70xxp1;
+	struct cvmx_sata_uctl_bist_status_s   cn73xx;
 };
 typedef union cvmx_sata_uctl_bist_status cvmx_sata_uctl_bist_status_t;
 
@@ -1826,7 +2218,7 @@ union cvmx_sata_uctl_ctl {
                                                          0x2 = divide by 3 0x6 = divide by 16
                                                          0x3 = divide by 4 0x7 = divide by 24 */
 	uint64_t reserved_5_23                : 19;
-	uint64_t csclk_en                     : 1;  /**< Turns on the USB UCTL interface clock (coprocessor clock). This enables access to UAHC
+	uint64_t csclk_en                     : 1;  /**< Turns on the SATA UCTL interface clock (coprocessor clock). This enables access to UAHC
                                                          registers via the IOI, as well as UCTL registers starting from 0x30 via the RSL bus. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t sata_uahc_rst                : 1;  /**< Software reset; resets UAHC; active-high.
@@ -1857,10 +2249,77 @@ union cvmx_sata_uctl_ctl {
 	} s;
 	struct cvmx_sata_uctl_ctl_s           cn70xx;
 	struct cvmx_sata_uctl_ctl_s           cn70xxp1;
+	struct cvmx_sata_uctl_ctl_s           cn73xx;
 };
 typedef union cvmx_sata_uctl_ctl cvmx_sata_uctl_ctl_t;
 
 /**
+ * cvmx_sata_uctl_ecc
+ *
+ * This register can be used to disable ECC correction, insert ECC errors, and debug ECC
+ * failures.
+ * * The ECC_ERR* fields are captured when there are no outstanding ECC errors indicated in
+ * INTSTAT and a new ECC error arrives. Prioritization for multiple events occurring on the same
+ * cycle is indicated by the ECC_ERR_SOURCE enumeration: highest encoded value has highest
+ * priority.
+ * * The *ECC_*_DIS fields disable ECC correction; SBE and DBE errors are still reported. If
+ * *ECC_*_DIS = 0x1, then no data-correction occurs.
+ * * The *ECC_FLIP_SYND fields flip the syndrome<1:0> bits to generate single-bit/double-bit
+ * error for testing.
+ *
+ * 0x0 = normal operation.
+ * 0x1 = SBE on bit[0].
+ * 0x2 = SBE on bit[1].
+ * 0x3 = DBE on bit[1:0].
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
+ */
+union cvmx_sata_uctl_ecc {
+	uint64_t u64;
+	struct cvmx_sata_uctl_ecc_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t ecc_err_source               : 4;  /**< Source of ECC error, see UCTL_ECC_ERR_SOURCE_E. */
+	uint64_t ecc_err_syndrome             : 8;  /**< Syndrome bits of the ECC error. */
+	uint64_t ecc_err_address              : 16; /**< RAM address of the ECC error. */
+	uint64_t reserved_21_31               : 11;
+	uint64_t uctl_xm_r_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uctl_xm_r_ecc_cor_dis        : 1;  /**< Enables ECC correction on UCTL AxiMaster read-data FIFO. */
+	uint64_t uctl_xm_w_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uctl_xm_w_ecc_cor_dis        : 1;  /**< Enables ECC correction on UCTL AxiMaster write-data FIFO. */
+	uint64_t reserved_9_14                : 6;
+	uint64_t uahc_ram2_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram2_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC RxFIFO RAMs (RAM2). */
+	uint64_t uahc_ram1_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram1_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC TxFIFO RAMs (RAM1). */
+	uint64_t uahc_ram0_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram0_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC Desc/Reg cache (RAM0). */
+#else
+	uint64_t uahc_ram0_ecc_cor_dis        : 1;
+	uint64_t uahc_ram0_ecc_flip_synd      : 2;
+	uint64_t uahc_ram1_ecc_cor_dis        : 1;
+	uint64_t uahc_ram1_ecc_flip_synd      : 2;
+	uint64_t uahc_ram2_ecc_cor_dis        : 1;
+	uint64_t uahc_ram2_ecc_flip_synd      : 2;
+	uint64_t reserved_9_14                : 6;
+	uint64_t uctl_xm_w_ecc_cor_dis        : 1;
+	uint64_t uctl_xm_w_ecc_flip_synd      : 2;
+	uint64_t uctl_xm_r_ecc_cor_dis        : 1;
+	uint64_t uctl_xm_r_ecc_flip_synd      : 2;
+	uint64_t reserved_21_31               : 11;
+	uint64_t ecc_err_address              : 16;
+	uint64_t ecc_err_syndrome             : 8;
+	uint64_t ecc_err_source               : 4;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} s;
+	struct cvmx_sata_uctl_ecc_s           cn73xx;
+};
+typedef union cvmx_sata_uctl_ecc cvmx_sata_uctl_ecc_t;
+
+/**
  * cvmx_sata_uctl_intstat
  *
  * Accessible by: always
@@ -1871,6 +2330,38 @@ union cvmx_sata_uctl_intstat {
 	uint64_t u64;
 	struct cvmx_sata_uctl_intstat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_30_63               : 34;
+	uint64_t xm_r_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_r_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_w_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t xm_w_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t reserved_3_25                : 23;
+	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. The error information is logged in
+                                                         SATA_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates the
+                                                         assumptions made by the AXI-to-IOI shim. Such scenarios include: illegal length/size
+                                                         combinations and address out-of-bounds.
+                                                         For more information on exact failures, see description in
+                                                         SATA_UCTL_SHIM_CFG[XM_BAD_DMA_TYPE].
+                                                         The hardware does not translate the request correctly and results may violate IOI
+                                                         protocols. */
+	uint64_t xs_ncb_oob                   : 1;  /**< Detected out-of-bound register access to UAHC over IOI. The UAHC defines 1MB of register
+                                                         space, starting at offset 0x0. Any accesses outside of this register space cause this bit
+                                                         to be set to 1. The error information is logged in SATA_UCTL_SHIM_CFG[XS_NCB_OOB_*]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t xs_ncb_oob                   : 1;
+	uint64_t xm_bad_dma                   : 1;
+	uint64_t reserved_3_25                : 23;
+	uint64_t xm_w_sbe                     : 1;
+	uint64_t xm_w_dbe                     : 1;
+	uint64_t xm_r_sbe                     : 1;
+	uint64_t xm_r_dbe                     : 1;
+	uint64_t reserved_30_63               : 34;
+#endif
+	} s;
+	struct cvmx_sata_uctl_intstat_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
 	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. The error information is logged in
                                                          SATA_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates the
@@ -1890,9 +2381,9 @@ union cvmx_sata_uctl_intstat {
 	uint64_t xm_bad_dma                   : 1;
 	uint64_t reserved_3_63                : 61;
 #endif
-	} s;
-	struct cvmx_sata_uctl_intstat_s       cn70xx;
-	struct cvmx_sata_uctl_intstat_s       cn70xxp1;
+	} cn70xx;
+	struct cvmx_sata_uctl_intstat_cn70xx  cn70xxp1;
+	struct cvmx_sata_uctl_intstat_s       cn73xx;
 };
 typedef union cvmx_sata_uctl_intstat cvmx_sata_uctl_intstat_t;
 
@@ -1922,6 +2413,41 @@ union cvmx_sata_uctl_shim_cfg {
                                                          (error largest encoded value has priority). See SATA_UCTL_XM_BAD_DMA_TYPE_E. */
 	uint64_t reserved_13_39               : 27;
 	uint64_t dma_read_cmd                 : 1;  /**< Selects the IOI read command used by DMA accesses. See SATA_UCTL_DMA_READ_CMD_E. */
+	uint64_t reserved_11_11               : 1;
+	uint64_t dma_write_cmd                : 1;  /**< Selects the NCB write command used by DMA accesses. See UCTL_DMA_WRITE_CMD_E. */
+	uint64_t dma_endian_mode              : 2;  /**< Selects the endian format for DMA accesses to the L2C. See SATA_UCTL_ENDIAN_MODE_E. */
+	uint64_t reserved_2_7                 : 6;
+	uint64_t csr_endian_mode              : 2;  /**< Selects the endian format for IOI CSR accesses to the UAHC. Note that when UAHC CSRs are
+                                                         accessed via RSL, they are returned as big-endian. See SATA_UCTL_ENDIAN_MODE_E. */
+#else
+	uint64_t csr_endian_mode              : 2;
+	uint64_t reserved_2_7                 : 6;
+	uint64_t dma_endian_mode              : 2;
+	uint64_t dma_write_cmd                : 1;
+	uint64_t reserved_11_11               : 1;
+	uint64_t dma_read_cmd                 : 1;
+	uint64_t reserved_13_39               : 27;
+	uint64_t xm_bad_dma_type              : 4;
+	uint64_t reserved_44_46               : 3;
+	uint64_t xm_bad_dma_wrn               : 1;
+	uint64_t xs_ncb_oob_osrc              : 9;
+	uint64_t reserved_57_62               : 6;
+	uint64_t xs_ncb_oob_wrn               : 1;
+#endif
+	} s;
+	struct cvmx_sata_uctl_shim_cfg_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t xs_ncb_oob_wrn               : 1;  /**< Read/write error log for out-of-bound UAHC register access.
+                                                         0 = read, 1 = write. */
+	uint64_t reserved_57_62               : 6;
+	uint64_t xs_ncb_oob_osrc              : 9;  /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB error. */
+	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
+                                                         0 = read error log, 1 = write error log. */
+	uint64_t reserved_44_46               : 3;
+	uint64_t xm_bad_dma_type              : 4;  /**< ErrType error log for bad DMA access from UAHC. Encodes the type of error encountered
+                                                         (error largest encoded value has priority). See SATA_UCTL_XM_BAD_DMA_TYPE_E. */
+	uint64_t reserved_13_39               : 27;
+	uint64_t dma_read_cmd                 : 1;  /**< Selects the IOI read command used by DMA accesses. See SATA_UCTL_DMA_READ_CMD_E. */
 	uint64_t reserved_10_11               : 2;
 	uint64_t dma_endian_mode              : 2;  /**< Selects the endian format for DMA accesses to the L2C. See SATA_UCTL_ENDIAN_MODE_E. */
 	uint64_t reserved_2_7                 : 6;
@@ -1941,9 +2467,9 @@ union cvmx_sata_uctl_shim_cfg {
 	uint64_t reserved_57_62               : 6;
 	uint64_t xs_ncb_oob_wrn               : 1;
 #endif
-	} s;
-	struct cvmx_sata_uctl_shim_cfg_s      cn70xx;
-	struct cvmx_sata_uctl_shim_cfg_s      cn70xxp1;
+	} cn70xx;
+	struct cvmx_sata_uctl_shim_cfg_cn70xx cn70xxp1;
+	struct cvmx_sata_uctl_shim_cfg_s      cn73xx;
 };
 typedef union cvmx_sata_uctl_shim_cfg cvmx_sata_uctl_shim_cfg_t;
 
@@ -1969,6 +2495,28 @@ union cvmx_sata_uctl_spare0 {
 typedef union cvmx_sata_uctl_spare0 cvmx_sata_uctl_spare0_t;
 
 /**
+ * cvmx_sata_uctl_spare0_eco
+ *
+ * Accessible by: always
+ * Reset by: IOI reset (srst_n)
+ * This register is spare.
+ */
+union cvmx_sata_uctl_spare0_eco {
+	uint64_t u64;
+	struct cvmx_sata_uctl_spare0_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< Spare. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_sata_uctl_spare0_eco_s    cn73xx;
+};
+typedef union cvmx_sata_uctl_spare0_eco cvmx_sata_uctl_spare0_eco_t;
+
+/**
  * cvmx_sata_uctl_spare1
  *
  * Accessible by: only when A_CLKDIV_EN
@@ -1989,4 +2537,26 @@ union cvmx_sata_uctl_spare1 {
 };
 typedef union cvmx_sata_uctl_spare1 cvmx_sata_uctl_spare1_t;
 
+/**
+ * cvmx_sata_uctl_spare1_eco
+ *
+ * Accessible by: only when A_CLKDIV_EN
+ * Reset by: IOI reset (srst_n) or SATA_UCTL_CTL[SATA_UCTL_RST]
+ * This register is spare.
+ */
+union cvmx_sata_uctl_spare1_eco {
+	uint64_t u64;
+	struct cvmx_sata_uctl_spare1_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_sata_uctl_spare1_eco_s    cn73xx;
+};
+typedef union cvmx_sata_uctl_spare1_eco cvmx_sata_uctl_spare1_eco_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 2fdddcd..d158718 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_SLI_BIST_STATUS CVMX_SLI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_BIST_STATUS not supported on this chip\n");
 	return 0x0000000000000580ull;
 }
@@ -72,6 +72,7 @@ static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_CTL_PORTX(%lu) is invalid on this chip\n", offset);
@@ -84,7 +85,7 @@ static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 #define CVMX_SLI_CTL_STATUS CVMX_SLI_CTL_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_CTL_STATUS not supported on this chip\n");
 	return 0x0000000000000570ull;
 }
@@ -95,7 +96,7 @@ static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 #define CVMX_SLI_DATA_OUT_CNT CVMX_SLI_DATA_OUT_CNT_FUNC()
 static inline uint64_t CVMX_SLI_DATA_OUT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_DATA_OUT_CNT not supported on this chip\n");
 	return 0x00000000000005F0ull;
 }
@@ -133,6 +134,7 @@ static inline uint64_t CVMX_SLI_DMAX_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_CNT(%lu) is invalid on this chip\n", offset);
@@ -150,6 +152,7 @@ static inline uint64_t CVMX_SLI_DMAX_INT_LEVEL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n", offset);
@@ -167,6 +170,7 @@ static inline uint64_t CVMX_SLI_DMAX_TIM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_DMAX_TIM(%lu) is invalid on this chip\n", offset);
@@ -195,6 +199,7 @@ static inline uint64_t CVMX_SLI_INT_ENB_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n", offset);
@@ -207,7 +212,7 @@ static inline uint64_t CVMX_SLI_INT_ENB_PORTX(unsigned long offset)
 #define CVMX_SLI_INT_SUM CVMX_SLI_INT_SUM_FUNC()
 static inline uint64_t CVMX_SLI_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_INT_SUM not supported on this chip\n");
 	return 0x0000000000000330ull;
 }
@@ -262,7 +267,7 @@ static inline uint64_t CVMX_SLI_LAST_WIN_RDATA3_FUNC(void)
 #define CVMX_SLI_MAC_CREDIT_CNT CVMX_SLI_MAC_CREDIT_CNT_FUNC()
 static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT not supported on this chip\n");
 	return 0x0000000000003D70ull;
 }
@@ -273,7 +278,7 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 #define CVMX_SLI_MAC_CREDIT_CNT2 CVMX_SLI_MAC_CREDIT_CNT2_FUNC()
 static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
 	return 0x0000000000003E10ull;
 }
@@ -284,7 +289,7 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 #define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
 static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MAC_NUMBER not supported on this chip\n");
 	return 0x0000000000003E00ull;
 }
@@ -295,7 +300,7 @@ static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 #define CVMX_SLI_MEM_ACCESS_CTL CVMX_SLI_MEM_ACCESS_CTL_FUNC()
 static inline uint64_t CVMX_SLI_MEM_ACCESS_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MEM_ACCESS_CTL not supported on this chip\n");
 	return 0x00000000000002F0ull;
 }
@@ -311,6 +316,7 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset >= 12) && (offset <= 27)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 12) && (offset <= 27)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset >= 12) && (offset <= 27))))))
 		cvmx_warn("CVMX_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n", offset);
@@ -323,7 +329,7 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 #define CVMX_SLI_MEM_CTL CVMX_SLI_MEM_CTL_FUNC()
 static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_MEM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
 }
@@ -334,7 +340,7 @@ static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 #define CVMX_SLI_MEM_INT_SUM CVMX_SLI_MEM_INT_SUM_FUNC()
 static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_MEM_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
 }
@@ -345,6 +351,7 @@ static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 64))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 64)))))
 		cvmx_warn("CVMX_SLI_MSIXX_TABLE_ADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + ((offset) & 127) * 16;
@@ -356,6 +363,7 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 64))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 64)))))
 		cvmx_warn("CVMX_SLI_MSIXX_TABLE_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16;
@@ -367,6 +375,7 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000017C00ull) + ((offset) & 3) * 16;
@@ -378,6 +387,7 @@ static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000017C08ull) + ((offset) & 3) * 16;
@@ -389,7 +399,7 @@ static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(unsigned long offset)
 #define CVMX_SLI_MSIX_PBA0 CVMX_SLI_MSIX_PBA0_FUNC()
 static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_MSIX_PBA0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
 }
@@ -400,7 +410,7 @@ static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 #define CVMX_SLI_MSIX_PBA1 CVMX_SLI_MSIX_PBA1_FUNC()
 static inline uint64_t CVMX_SLI_MSIX_PBA1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_MSIX_PBA1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
 }
@@ -455,7 +465,7 @@ static inline uint64_t CVMX_SLI_MSI_ENB3_FUNC(void)
 #define CVMX_SLI_MSI_RCV0 CVMX_SLI_MSI_RCV0_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV0 not supported on this chip\n");
 	return 0x0000000000003C10ull;
 }
@@ -466,7 +476,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 #define CVMX_SLI_MSI_RCV1 CVMX_SLI_MSI_RCV1_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV1 not supported on this chip\n");
 	return 0x0000000000003C20ull;
 }
@@ -477,7 +487,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 #define CVMX_SLI_MSI_RCV2 CVMX_SLI_MSI_RCV2_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV2 not supported on this chip\n");
 	return 0x0000000000003C30ull;
 }
@@ -488,7 +498,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 #define CVMX_SLI_MSI_RCV3 CVMX_SLI_MSI_RCV3_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RCV3 not supported on this chip\n");
 	return 0x0000000000003C40ull;
 }
@@ -499,7 +509,7 @@ static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 #define CVMX_SLI_MSI_RD_MAP CVMX_SLI_MSI_RD_MAP_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_RD_MAP not supported on this chip\n");
 	return 0x0000000000003CA0ull;
 }
@@ -598,7 +608,7 @@ static inline uint64_t CVMX_SLI_MSI_W1S_ENB3_FUNC(void)
 #define CVMX_SLI_MSI_WR_MAP CVMX_SLI_MSI_WR_MAP_FUNC()
 static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_MSI_WR_MAP not supported on this chip\n");
 	return 0x0000000000003C90ull;
 }
@@ -609,7 +619,7 @@ static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV CVMX_SLI_PCIE_MSI_RCV_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV not supported on this chip\n");
 	return 0x0000000000003CB0ull;
 }
@@ -620,7 +630,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B1 CVMX_SLI_PCIE_MSI_RCV_B1_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
 	return 0x0000000000000650ull;
 }
@@ -631,7 +641,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B2 CVMX_SLI_PCIE_MSI_RCV_B2_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
 	return 0x0000000000000660ull;
 }
@@ -642,7 +652,7 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV_B3 CVMX_SLI_PCIE_MSI_RCV_B3_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
 	return 0x0000000000000670ull;
 }
@@ -658,6 +668,7 @@ static inline uint64_t CVMX_SLI_PKTX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_CNTS(%lu) is invalid on this chip\n", offset);
@@ -670,6 +681,7 @@ static inline uint64_t CVMX_SLI_PKTX_CNTS(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SLI_PKTX_INPUT_CONTROL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + ((offset) & 63) * 16;
@@ -686,6 +698,7 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n", offset);
@@ -703,6 +716,7 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
@@ -720,6 +734,7 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
@@ -748,6 +763,7 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_HEADER(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_INT_LEVELS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SLI_PKTX_INT_LEVELS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + ((offset) & 63) * 16;
@@ -774,6 +790,7 @@ static inline uint64_t CVMX_SLI_PKTX_IN_BP(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SLI_PKTX_OUTPUT_CONTROL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + ((offset) & 63) * 16;
@@ -790,6 +807,7 @@ static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n", offset);
@@ -807,6 +825,7 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n", offset);
@@ -824,6 +843,7 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
@@ -841,6 +861,7 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
@@ -853,6 +874,7 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_VF_SIG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SLI_PKTX_VF_SIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000014C00ull) + ((offset) & 63) * 16;
@@ -864,7 +886,7 @@ static inline uint64_t CVMX_SLI_PKTX_VF_SIG(unsigned long offset)
 #define CVMX_SLI_PKT_CNT_INT CVMX_SLI_PKT_CNT_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_CNT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_CNT_INT not supported on this chip\n");
 	return 0x0000000000001130ull;
 }
@@ -952,7 +974,7 @@ static inline uint64_t CVMX_SLI_PKT_INPUT_CONTROL_FUNC(void)
 #define CVMX_SLI_PKT_INSTR_ENB CVMX_SLI_PKT_INSTR_ENB_FUNC()
 static inline uint64_t CVMX_SLI_PKT_INSTR_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_INSTR_ENB not supported on this chip\n");
 	return 0x0000000000001000ull;
 }
@@ -985,7 +1007,7 @@ static inline uint64_t CVMX_SLI_PKT_INSTR_SIZE_FUNC(void)
 #define CVMX_SLI_PKT_INT CVMX_SLI_PKT_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
 }
@@ -1023,6 +1045,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n", offset);
@@ -1035,7 +1058,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 #define CVMX_SLI_PKT_IN_INSTR_COUNTS CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC()
 static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
 	return 0x0000000000001200ull;
 }
@@ -1046,7 +1069,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 #define CVMX_SLI_PKT_IN_INT CVMX_SLI_PKT_IN_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_IN_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
 }
@@ -1079,7 +1102,7 @@ static inline uint64_t CVMX_SLI_PKT_IPTR_FUNC(void)
 #define CVMX_SLI_PKT_MAC0_SIG0 CVMX_SLI_PKT_MAC0_SIG0_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MAC0_SIG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MAC0_SIG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011300ull);
 }
@@ -1090,7 +1113,7 @@ static inline uint64_t CVMX_SLI_PKT_MAC0_SIG0_FUNC(void)
 #define CVMX_SLI_PKT_MAC0_SIG1 CVMX_SLI_PKT_MAC0_SIG1_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MAC0_SIG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MAC0_SIG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011310ull);
 }
@@ -1101,7 +1124,7 @@ static inline uint64_t CVMX_SLI_PKT_MAC0_SIG1_FUNC(void)
 #define CVMX_SLI_PKT_MAC1_SIG0 CVMX_SLI_PKT_MAC1_SIG0_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MAC1_SIG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MAC1_SIG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011320ull);
 }
@@ -1112,7 +1135,7 @@ static inline uint64_t CVMX_SLI_PKT_MAC1_SIG0_FUNC(void)
 #define CVMX_SLI_PKT_MAC1_SIG1 CVMX_SLI_PKT_MAC1_SIG1_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MAC1_SIG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MAC1_SIG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011330ull);
 }
@@ -1123,6 +1146,7 @@ static inline uint64_t CVMX_SLI_PKT_MAC1_SIG1_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_MACX_RINFO(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_SLI_PKT_MACX_RINFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000011030ull) + ((offset) & 3) * 16;
@@ -1134,7 +1158,7 @@ static inline uint64_t CVMX_SLI_PKT_MACX_RINFO(unsigned long offset)
 #define CVMX_SLI_PKT_MEM_CTL CVMX_SLI_PKT_MEM_CTL_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MEM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
 }
@@ -1145,7 +1169,7 @@ static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 #define CVMX_SLI_PKT_OUTPUT_WMARK CVMX_SLI_PKT_OUTPUT_WMARK_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
 	return 0x0000000000001180ull;
 }
@@ -1167,7 +1191,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BMODE_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN CVMX_SLI_PKT_OUT_BP_EN_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN not supported on this chip\n");
 	return 0x0000000000001240ull;
 }
@@ -1178,7 +1202,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_SLI_PKT_OUT_ENB CVMX_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_ENB not supported on this chip\n");
 	return 0x0000000000001010ull;
 }
@@ -1211,7 +1235,7 @@ static inline uint64_t CVMX_SLI_PKT_PORT_IN_RST_FUNC(void)
 #define CVMX_SLI_PKT_RING_RST CVMX_SLI_PKT_RING_RST_FUNC()
 static inline uint64_t CVMX_SLI_PKT_RING_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_RING_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
 }
@@ -1255,7 +1279,7 @@ static inline uint64_t CVMX_SLI_PKT_SLIST_ROR_FUNC(void)
 #define CVMX_SLI_PKT_TIME_INT CVMX_SLI_PKT_TIME_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_TIME_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_TIME_INT not supported on this chip\n");
 	return 0x0000000000001140ull;
 }
@@ -1288,7 +1312,7 @@ static inline uint64_t CVMX_SLI_PORTX_PKIND(unsigned long offset)
 #define CVMX_SLI_S2C_END_MERGE CVMX_SLI_S2C_END_MERGE_FUNC()
 static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_S2C_END_MERGE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
 }
@@ -1304,6 +1328,7 @@ static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1316,7 +1341,7 @@ static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 #define CVMX_SLI_SCRATCH_1 CVMX_SLI_SCRATCH_1_FUNC()
 static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_SCRATCH_1 not supported on this chip\n");
 	return 0x00000000000003C0ull;
 }
@@ -1327,7 +1352,7 @@ static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 #define CVMX_SLI_SCRATCH_2 CVMX_SLI_SCRATCH_2_FUNC()
 static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_SCRATCH_2 not supported on this chip\n");
 	return 0x00000000000003D0ull;
 }
@@ -1338,7 +1363,7 @@ static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 #define CVMX_SLI_STATE1 CVMX_SLI_STATE1_FUNC()
 static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE1 not supported on this chip\n");
 	return 0x0000000000000620ull;
 }
@@ -1349,7 +1374,7 @@ static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 #define CVMX_SLI_STATE2 CVMX_SLI_STATE2_FUNC()
 static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE2 not supported on this chip\n");
 	return 0x0000000000000630ull;
 }
@@ -1360,7 +1385,7 @@ static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 #define CVMX_SLI_STATE3 CVMX_SLI_STATE3_FUNC()
 static inline uint64_t CVMX_SLI_STATE3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_STATE3 not supported on this chip\n");
 	return 0x0000000000000640ull;
 }
@@ -1382,7 +1407,7 @@ static inline uint64_t CVMX_SLI_TX_PIPE_FUNC(void)
 #define CVMX_SLI_WINDOW_CTL CVMX_SLI_WINDOW_CTL_FUNC()
 static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_WINDOW_CTL not supported on this chip\n");
 	return 0x00000000000002E0ull;
 }
@@ -1393,7 +1418,7 @@ static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
 #define CVMX_SLI_WIN_RD_ADDR CVMX_SLI_WIN_RD_ADDR_FUNC()
 static inline uint64_t CVMX_SLI_WIN_RD_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_WIN_RD_ADDR not supported on this chip\n");
 	return 0x0000000000000010ull;
 }
@@ -1404,7 +1429,7 @@ static inline uint64_t CVMX_SLI_WIN_RD_ADDR_FUNC(void)
 #define CVMX_SLI_WIN_RD_DATA CVMX_SLI_WIN_RD_DATA_FUNC()
 static inline uint64_t CVMX_SLI_WIN_RD_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_WIN_RD_DATA not supported on this chip\n");
 	return 0x0000000000000040ull;
 }
@@ -1415,7 +1440,7 @@ static inline uint64_t CVMX_SLI_WIN_RD_DATA_FUNC(void)
 #define CVMX_SLI_WIN_WR_ADDR CVMX_SLI_WIN_WR_ADDR_FUNC()
 static inline uint64_t CVMX_SLI_WIN_WR_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_WIN_WR_ADDR not supported on this chip\n");
 	return 0x0000000000000000ull;
 }
@@ -1426,7 +1451,7 @@ static inline uint64_t CVMX_SLI_WIN_WR_ADDR_FUNC(void)
 #define CVMX_SLI_WIN_WR_DATA CVMX_SLI_WIN_WR_DATA_FUNC()
 static inline uint64_t CVMX_SLI_WIN_WR_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_WIN_WR_DATA not supported on this chip\n");
 	return 0x0000000000000020ull;
 }
@@ -1437,7 +1462,7 @@ static inline uint64_t CVMX_SLI_WIN_WR_DATA_FUNC(void)
 #define CVMX_SLI_WIN_WR_MASK CVMX_SLI_WIN_WR_MASK_FUNC()
 static inline uint64_t CVMX_SLI_WIN_WR_MASK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_WIN_WR_MASK not supported on this chip\n");
 	return 0x0000000000000030ull;
 }
@@ -1674,6 +1699,7 @@ union cvmx_sli_bist_status {
 #endif
 	} cn70xx;
 	struct cvmx_sli_bist_status_cn70xx    cn70xxp1;
+	struct cvmx_sli_bist_status_s         cn73xx;
 	struct cvmx_sli_bist_status_s         cn78xx;
 	struct cvmx_sli_bist_status_cn61xx    cnf71xx;
 };
@@ -1754,7 +1780,7 @@ union cvmx_sli_ctl_portx {
 	struct cvmx_sli_ctl_portx_s           cn68xxp1;
 	struct cvmx_sli_ctl_portx_s           cn70xx;
 	struct cvmx_sli_ctl_portx_s           cn70xxp1;
-	struct cvmx_sli_ctl_portx_cn78xx {
+	struct cvmx_sli_ctl_portx_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t dis_port                     : 1;  /**< When set, the output to the MAC is disabled. This occurs when the MAC reset line
@@ -1786,7 +1812,8 @@ union cvmx_sli_ctl_portx {
 	uint64_t dis_port                     : 1;
 	uint64_t reserved_18_63               : 46;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_ctl_portx_cn73xx      cn78xx;
 	struct cvmx_sli_ctl_portx_s           cnf71xx;
 };
 typedef union cvmx_sli_ctl_portx cvmx_sli_ctl_portx_t;
@@ -1879,6 +1906,7 @@ union cvmx_sli_ctl_status {
 	struct cvmx_sli_ctl_status_cn63xx     cn68xxp1;
 	struct cvmx_sli_ctl_status_cn63xx     cn70xx;
 	struct cvmx_sli_ctl_status_cn63xx     cn70xxp1;
+	struct cvmx_sli_ctl_status_s          cn73xx;
 	struct cvmx_sli_ctl_status_s          cn78xx;
 	struct cvmx_sli_ctl_status_cn61xx     cnf71xx;
 };
@@ -1923,6 +1951,7 @@ union cvmx_sli_data_out_cnt {
 	struct cvmx_sli_data_out_cnt_s        cn68xxp1;
 	struct cvmx_sli_data_out_cnt_s        cn70xx;
 	struct cvmx_sli_data_out_cnt_s        cn70xxp1;
+	struct cvmx_sli_data_out_cnt_s        cn73xx;
 	struct cvmx_sli_data_out_cnt_s        cn78xx;
 	struct cvmx_sli_data_out_cnt_s        cnf71xx;
 };
@@ -2034,6 +2063,7 @@ union cvmx_sli_dmax_cnt {
 	struct cvmx_sli_dmax_cnt_s            cn68xxp1;
 	struct cvmx_sli_dmax_cnt_s            cn70xx;
 	struct cvmx_sli_dmax_cnt_s            cn70xxp1;
+	struct cvmx_sli_dmax_cnt_s            cn73xx;
 	struct cvmx_sli_dmax_cnt_s            cn78xx;
 	struct cvmx_sli_dmax_cnt_s            cnf71xx;
 };
@@ -2070,6 +2100,7 @@ union cvmx_sli_dmax_int_level {
 	struct cvmx_sli_dmax_int_level_s      cn68xxp1;
 	struct cvmx_sli_dmax_int_level_s      cn70xx;
 	struct cvmx_sli_dmax_int_level_s      cn70xxp1;
+	struct cvmx_sli_dmax_int_level_s      cn73xx;
 	struct cvmx_sli_dmax_int_level_s      cn78xx;
 	struct cvmx_sli_dmax_int_level_s      cnf71xx;
 };
@@ -2102,6 +2133,7 @@ union cvmx_sli_dmax_tim {
 	struct cvmx_sli_dmax_tim_s            cn68xxp1;
 	struct cvmx_sli_dmax_tim_s            cn70xx;
 	struct cvmx_sli_dmax_tim_s            cn70xxp1;
+	struct cvmx_sli_dmax_tim_s            cn73xx;
 	struct cvmx_sli_dmax_tim_s            cn78xx;
 	struct cvmx_sli_dmax_tim_s            cnf71xx;
 };
@@ -3261,7 +3293,7 @@ union cvmx_sli_int_enb_portx {
 #endif
 	} cn70xx;
 	struct cvmx_sli_int_enb_portx_cn70xx  cn70xxp1;
-	struct cvmx_sli_int_enb_portx_cn78xx {
+	struct cvmx_sli_int_enb_portx_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t sprt3_err                    : 1;  /**< Enables SLI_INT_SUM[SPRT3_ERR] to generate an interrupt to the MAC core for MSI/INTA. */
@@ -3353,7 +3385,8 @@ union cvmx_sli_int_enb_portx {
 	uint64_t sprt3_err                    : 1;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_int_enb_portx_cn73xx  cn78xx;
 	struct cvmx_sli_int_enb_portx_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_int_enb_portx cvmx_sli_int_enb_portx_t;
@@ -3362,7 +3395,8 @@ typedef union cvmx_sli_int_enb_portx cvmx_sli_int_enb_portx_t;
  * cvmx_sli_int_sum
  *
  * The fields in this register are set when an interrupt condition occurs; write 1 to clear. All
- * fields of the CSR are valid when a PF reads the CSR. Not available to VF's, and writes by the
+ * fields of the register are valid when a PF reads the register. Not available to VF's, and
+ * writes by the
  * VF do not modify the register.
  */
 union cvmx_sli_int_sum {
@@ -3456,7 +3490,8 @@ union cvmx_sli_int_sum {
 	uint64_t m0_up_b0                     : 1;  /**< Received Unsupported P-TLP for Bar0 from MAC 0.
                                                          This occurs when the BAR 0 address space is
                                                          disabeled. */
-	uint64_t mio_int3                     : 1;  /**< Interrupt from MIO for Port 3. Throws SLI_INTSN_E::SLI_INT_MIO_INT3. */
+	uint64_t mio_int3                     : 1;  /**< CIU interrupt output for MAC 3. A copy of CIU3_DEST(x)_IO_INT[INTR],
+                                                         where x=CIU_DEST_IO_E::PEM(3) (i.e. x=4). */
 	uint64_t reserved_6_6                 : 1;
 	uint64_t ptime                        : 1;  /**< Packet Timer has an interrupt. Which rings can
                                                          be found in SLI_PKT_TIME_INT. */
@@ -4086,7 +4121,7 @@ union cvmx_sli_int_sum {
 #endif
 	} cn70xx;
 	struct cvmx_sli_int_sum_cn70xx        cn70xxp1;
-	struct cvmx_sli_int_sum_cn78xx {
+	struct cvmx_sli_int_sum_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t sprt3_err                    : 1;  /**< SLI port 3 error. When an error response is received on SLI port 3, this bit is set.
@@ -4172,9 +4207,7 @@ union cvmx_sli_int_sum {
                                                          Throws SLI_INTSN_E::SLI_INT_PCNT. */
 	uint64_t reserved_1_3                 : 3;
 	uint64_t rml_to                       : 1;  /**< A read or write transfer to a RSL that did not complete within
-                                                         SLI_WINDOW_CTL[TIME] coprocessor-clock cycles, or a notification from the CCPI
-                                                         that is has sent a previously written command and can take another within
-                                                         SLI_WINDOW_CTL[OCX_TIME].
+                                                         SLI_WINDOW_CTL[TIME] coprocessor-clock cycles.
                                                          Throws SLI_INTSN_E::SLI_INT_RML_TO. */
 #else
 	uint64_t rml_to                       : 1;
@@ -4221,7 +4254,8 @@ union cvmx_sli_int_sum {
 	uint64_t sprt3_err                    : 1;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_int_sum_cn73xx        cn78xx;
 	struct cvmx_sli_int_sum_cn61xx        cnf71xx;
 };
 typedef union cvmx_sli_int_sum cvmx_sli_int_sum_t;
@@ -4405,6 +4439,7 @@ union cvmx_sli_mac_credit_cnt {
 	struct cvmx_sli_mac_credit_cnt_s      cn68xxp1;
 	struct cvmx_sli_mac_credit_cnt_s      cn70xx;
 	struct cvmx_sli_mac_credit_cnt_s      cn70xxp1;
+	struct cvmx_sli_mac_credit_cnt_s      cn73xx;
 	struct cvmx_sli_mac_credit_cnt_s      cn78xx;
 	struct cvmx_sli_mac_credit_cnt_s      cnf71xx;
 };
@@ -4461,6 +4496,7 @@ union cvmx_sli_mac_credit_cnt2 {
 	struct cvmx_sli_mac_credit_cnt2_s     cn66xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cn70xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cn70xxp1;
+	struct cvmx_sli_mac_credit_cnt2_s     cn73xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cn78xx;
 	struct cvmx_sli_mac_credit_cnt2_s     cnf71xx;
 };
@@ -4500,6 +4536,7 @@ union cvmx_sli_mac_number {
 	struct cvmx_sli_mac_number_cn63xx     cn68xxp1;
 	struct cvmx_sli_mac_number_s          cn70xx;
 	struct cvmx_sli_mac_number_s          cn70xxp1;
+	struct cvmx_sli_mac_number_s          cn73xx;
 	struct cvmx_sli_mac_number_s          cn78xx;
 	struct cvmx_sli_mac_number_s          cnf71xx;
 };
@@ -4538,6 +4575,7 @@ union cvmx_sli_mem_access_ctl {
 	struct cvmx_sli_mem_access_ctl_s      cn68xxp1;
 	struct cvmx_sli_mem_access_ctl_s      cn70xx;
 	struct cvmx_sli_mem_access_ctl_s      cn70xxp1;
+	struct cvmx_sli_mem_access_ctl_s      cn73xx;
 	struct cvmx_sli_mem_access_ctl_s      cn78xx;
 	struct cvmx_sli_mem_access_ctl_s      cnf71xx;
 };
@@ -4684,6 +4722,7 @@ union cvmx_sli_mem_access_subidx {
 	struct cvmx_sli_mem_access_subidx_cn68xx cn68xxp1;
 	struct cvmx_sli_mem_access_subidx_cn61xx cn70xx;
 	struct cvmx_sli_mem_access_subidx_cn61xx cn70xxp1;
+	struct cvmx_sli_mem_access_subidx_cn61xx cn73xx;
 	struct cvmx_sli_mem_access_subidx_cn61xx cn78xx;
 	struct cvmx_sli_mem_access_subidx_cn61xx cnf71xx;
 };
@@ -4740,6 +4779,7 @@ union cvmx_sli_mem_ctl {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_sli_mem_ctl_s             cn73xx;
 	struct cvmx_sli_mem_ctl_s             cn78xx;
 };
 typedef union cvmx_sli_mem_ctl cvmx_sli_mem_ctl_t;
@@ -4795,6 +4835,7 @@ union cvmx_sli_mem_int_sum {
 	uint64_t reserved_18_63               : 46;
 #endif
 	} s;
+	struct cvmx_sli_mem_int_sum_s         cn73xx;
 	struct cvmx_sli_mem_int_sum_s         cn78xx;
 };
 typedef union cvmx_sli_mem_int_sum cvmx_sli_mem_int_sum_t;
@@ -4930,6 +4971,7 @@ union cvmx_sli_msi_rcv0 {
 	struct cvmx_sli_msi_rcv0_s            cn68xxp1;
 	struct cvmx_sli_msi_rcv0_s            cn70xx;
 	struct cvmx_sli_msi_rcv0_s            cn70xxp1;
+	struct cvmx_sli_msi_rcv0_s            cn73xx;
 	struct cvmx_sli_msi_rcv0_s            cn78xx;
 	struct cvmx_sli_msi_rcv0_s            cnf71xx;
 };
@@ -4958,6 +5000,7 @@ union cvmx_sli_msi_rcv1 {
 	struct cvmx_sli_msi_rcv1_s            cn68xxp1;
 	struct cvmx_sli_msi_rcv1_s            cn70xx;
 	struct cvmx_sli_msi_rcv1_s            cn70xxp1;
+	struct cvmx_sli_msi_rcv1_s            cn73xx;
 	struct cvmx_sli_msi_rcv1_s            cn78xx;
 	struct cvmx_sli_msi_rcv1_s            cnf71xx;
 };
@@ -4986,6 +5029,7 @@ union cvmx_sli_msi_rcv2 {
 	struct cvmx_sli_msi_rcv2_s            cn68xxp1;
 	struct cvmx_sli_msi_rcv2_s            cn70xx;
 	struct cvmx_sli_msi_rcv2_s            cn70xxp1;
+	struct cvmx_sli_msi_rcv2_s            cn73xx;
 	struct cvmx_sli_msi_rcv2_s            cn78xx;
 	struct cvmx_sli_msi_rcv2_s            cnf71xx;
 };
@@ -5014,6 +5058,7 @@ union cvmx_sli_msi_rcv3 {
 	struct cvmx_sli_msi_rcv3_s            cn68xxp1;
 	struct cvmx_sli_msi_rcv3_s            cn70xx;
 	struct cvmx_sli_msi_rcv3_s            cn70xxp1;
+	struct cvmx_sli_msi_rcv3_s            cn73xx;
 	struct cvmx_sli_msi_rcv3_s            cn78xx;
 	struct cvmx_sli_msi_rcv3_s            cnf71xx;
 };
@@ -5048,6 +5093,7 @@ union cvmx_sli_msi_rd_map {
 	struct cvmx_sli_msi_rd_map_s          cn68xxp1;
 	struct cvmx_sli_msi_rd_map_s          cn70xx;
 	struct cvmx_sli_msi_rd_map_s          cn70xxp1;
+	struct cvmx_sli_msi_rd_map_s          cn73xx;
 	struct cvmx_sli_msi_rd_map_s          cn78xx;
 	struct cvmx_sli_msi_rd_map_s          cnf71xx;
 };
@@ -5317,6 +5363,7 @@ union cvmx_sli_msi_wr_map {
 	struct cvmx_sli_msi_wr_map_s          cn68xxp1;
 	struct cvmx_sli_msi_wr_map_s          cn70xx;
 	struct cvmx_sli_msi_wr_map_s          cn70xxp1;
+	struct cvmx_sli_msi_wr_map_s          cn73xx;
 	struct cvmx_sli_msi_wr_map_s          cn78xx;
 	struct cvmx_sli_msi_wr_map_s          cnf71xx;
 };
@@ -5366,6 +5413,7 @@ union cvmx_sli_msixx_table_addr {
 	uint64_t addr                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_msixx_table_addr_s    cn73xx;
 	struct cvmx_sli_msixx_table_addr_s    cn78xx;
 };
 typedef union cvmx_sli_msixx_table_addr cvmx_sli_msixx_table_addr_t;
@@ -5389,6 +5437,7 @@ union cvmx_sli_msixx_table_data {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_sli_msixx_table_data_s    cn73xx;
 	struct cvmx_sli_msixx_table_data_s    cn78xx;
 };
 typedef union cvmx_sli_msixx_table_data cvmx_sli_msixx_table_data_t;
@@ -5408,6 +5457,7 @@ union cvmx_sli_msix_macx_pf_table_addr {
 	uint64_t addr                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_msix_macx_pf_table_addr_s cn73xx;
 	struct cvmx_sli_msix_macx_pf_table_addr_s cn78xx;
 };
 typedef union cvmx_sli_msix_macx_pf_table_addr cvmx_sli_msix_macx_pf_table_addr_t;
@@ -5431,6 +5481,7 @@ union cvmx_sli_msix_macx_pf_table_data {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_sli_msix_macx_pf_table_data_s cn73xx;
 	struct cvmx_sli_msix_macx_pf_table_data_s cn78xx;
 };
 typedef union cvmx_sli_msix_macx_pf_table_data cvmx_sli_msix_macx_pf_table_data_t;
@@ -5466,14 +5517,14 @@ typedef union cvmx_sli_msix_macx_pf_table_data cvmx_sli_msix_macx_pf_table_data_
  * In PF Mode there is no virtual function support, but the PF can configure up to 65
  * entries (up to 64 DPI Packet Rings plus 1 PF ring) for itself.
  *
- * In PF Mode, if SLI_PEM()_TNR=63 (i.e. 64 total DPI Packet Rings configured), a PF will
- * find its pending completion interrupts in bit positions [63:0]. When SLI_PEM()_TNR=63,
+ * In PF Mode, if SLI_PEM()_TNR=64 (i.e. 64 total DPI Packet Rings configured), a PF will
+ * find its pending completion interrupts in bit positions [63:0]. When SLI_PEM()_TNR=64,
  * the PF will find its PCIe error interrupt in SLI_MSIX_PBA1, bit position 0.
  *
- * If SLI_PEM()_TNR<63 (i.e. 1, 2, 4, 8, 16, or 32 rings configured), a PF will find its
+ * If SLI_PEM()_TNR < 64 (i.e. 1, 2, 4, 8, 16, or 32 rings configured), a PF will find its
  * ring pending completion interrupts in bit positions [TNR:0]. It will find its PCIe
  * error interrupt in bit position [(TNR+1)]. Bits [63:(TNR+2)] are returned as zero.
- * When SLI_PEM()_TNR<63 in PF Mode, SLI_MSIX_PBA1 is not used and returns zeros."
+ * When SLI_PEM()_TNR < 64 in PF Mode, SLI_MSIX_PBA1 is not used and returns zeros."
  */
 union cvmx_sli_msix_pba0 {
 	uint64_t u64;
@@ -5484,6 +5535,7 @@ union cvmx_sli_msix_pba0 {
 	uint64_t msg_pnd                      : 64;
 #endif
 	} s;
+	struct cvmx_sli_msix_pba0_s           cn73xx;
 	struct cvmx_sli_msix_pba0_s           cn78xx;
 };
 typedef union cvmx_sli_msix_pba0 cvmx_sli_msix_pba0_t;
@@ -5513,6 +5565,7 @@ union cvmx_sli_msix_pba1 {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_sli_msix_pba1_s           cn73xx;
 	struct cvmx_sli_msix_pba1_s           cn78xx;
 };
 typedef union cvmx_sli_msix_pba1 cvmx_sli_msix_pba1_t;
@@ -5546,6 +5599,7 @@ union cvmx_sli_pcie_msi_rcv {
 	struct cvmx_sli_pcie_msi_rcv_s        cn68xxp1;
 	struct cvmx_sli_pcie_msi_rcv_s        cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_s        cn70xxp1;
+	struct cvmx_sli_pcie_msi_rcv_s        cn73xx;
 	struct cvmx_sli_pcie_msi_rcv_s        cn78xx;
 	struct cvmx_sli_pcie_msi_rcv_s        cnf71xx;
 };
@@ -5554,7 +5608,8 @@ typedef union cvmx_sli_pcie_msi_rcv cvmx_sli_pcie_msi_rcv_t;
 /**
  * cvmx_sli_pcie_msi_rcv_b1
  *
- * This register is where MSI write operations are directed from the MAC. This CSR can be used by
+ * This register is where MSI write operations are directed from the MAC. This register can be
+ * used by
  * the PCIe MACs.
  */
 union cvmx_sli_pcie_msi_rcv_b1 {
@@ -5582,6 +5637,7 @@ union cvmx_sli_pcie_msi_rcv_b1 {
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn68xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn70xxp1;
+	struct cvmx_sli_pcie_msi_rcv_b1_s     cn73xx;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cn78xx;
 	struct cvmx_sli_pcie_msi_rcv_b1_s     cnf71xx;
 };
@@ -5590,7 +5646,8 @@ typedef union cvmx_sli_pcie_msi_rcv_b1 cvmx_sli_pcie_msi_rcv_b1_t;
 /**
  * cvmx_sli_pcie_msi_rcv_b2
  *
- * This register is where MSI write operations are directed from the MAC.  This CSR can be used
+ * This register is where MSI write operations are directed from the MAC.  This register can be
+ * used
  * by PCIe MACs.
  */
 union cvmx_sli_pcie_msi_rcv_b2 {
@@ -5618,6 +5675,7 @@ union cvmx_sli_pcie_msi_rcv_b2 {
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn68xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn70xxp1;
+	struct cvmx_sli_pcie_msi_rcv_b2_s     cn73xx;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cn78xx;
 	struct cvmx_sli_pcie_msi_rcv_b2_s     cnf71xx;
 };
@@ -5626,7 +5684,8 @@ typedef union cvmx_sli_pcie_msi_rcv_b2 cvmx_sli_pcie_msi_rcv_b2_t;
 /**
  * cvmx_sli_pcie_msi_rcv_b3
  *
- * This register is where MSI write operations are directed from the MAC. This CSR can be used by
+ * This register is where MSI write operations are directed from the MAC. This register can be
+ * used by
  * PCIe MACs.
  */
 union cvmx_sli_pcie_msi_rcv_b3 {
@@ -5654,6 +5713,7 @@ union cvmx_sli_pcie_msi_rcv_b3 {
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn68xxp1;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn70xx;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn70xxp1;
+	struct cvmx_sli_pcie_msi_rcv_b3_s     cn73xx;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cn78xx;
 	struct cvmx_sli_pcie_msi_rcv_b3_s     cnf71xx;
 };
@@ -5735,6 +5795,7 @@ union cvmx_sli_pktx_cnts {
 	struct cvmx_sli_pktx_cnts_cn61xx      cn68xxp1;
 	struct cvmx_sli_pktx_cnts_cn61xx      cn70xx;
 	struct cvmx_sli_pktx_cnts_cn61xx      cn70xxp1;
+	struct cvmx_sli_pktx_cnts_s           cn73xx;
 	struct cvmx_sli_pktx_cnts_s           cn78xx;
 	struct cvmx_sli_pktx_cnts_cn61xx      cnf71xx;
 };
@@ -5790,13 +5851,20 @@ union cvmx_sli_pktx_input_control {
 	struct cvmx_sli_pktx_input_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_39_63               : 25;
-	uint64_t vf_num                       : 7;  /**< The VF number that this ring belongs to. A value of 0 means that this ring belongs to the
-                                                         PF. The VF number is the value sent to and received from the MAC. This means that if ring
-                                                         x belongs to MAC0 and ring y belongs to MAC1, they both could have a VF_NUM of 1. Legal
-                                                         value are 0-64. */
+	uint64_t vf_num                       : 7;  /**< The function number that the ring belongs to. When [VF_NUM]==0, the physical
+                                                         function controls the ring. When [VF_NUM]!=0, it must correctly indicate the
+                                                         virtual function number that controls the ring. ([VF_NUM]==1 selects the first
+                                                         virtual function within the selected physical function, [VF_NUM]==2 selects
+                                                         the second virtual function within the selected physical function ...)
+                                                         Legal values are 0..64.
+                                                         [VF_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [VF_NUM] applies to both this input ring and to the output ring of the same
+                                                         index. */
 	uint64_t reserved_31_31               : 1;
-	uint64_t mac_num                      : 2;  /**< The MAC that the ring belongs to. Legal value are 0-3. This applies for both
-                                                         input and output rings. */
+	uint64_t mac_num                      : 2;  /**< The MAC (PEM) that the physical function belongs to. Legal value are 0-3.
+                                                         [MAC_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [MAC_NUM] applies to both this input ring and to the output ring of the same
+                                                         index. */
 	uint64_t reserved_27_28               : 2;
 	uint64_t rdsize                       : 2;  /**< Number of instructions to be read in one MAC read request for the 4 ports, 16 rings. Two
                                                          bit value are:
@@ -5805,55 +5873,50 @@ union cvmx_sli_pktx_input_control {
                                                          0x2 = 3 Instructions.
                                                          0x3 = 4 Instructions. */
 	uint64_t is_64b                       : 1;  /**< When IS_64B=1, instruction input ring i uses 64B. */
-	uint64_t rst                          : 1;  /**< Packet reset. This bit is set for a ring when the ring enters the reset state. This can be
-                                                         done by writing a 1 to the field, when a FLR associated with the ring occurs, or when an
-                                                         error response is received for a read done by the ring. This applies for both
-                                                         input and output rings. See SLI_INT_SUM[PGL_ERR]. When
-                                                         receiving a PGL_ERR interrupt, software should:
-                                                         1. Wait 2ms to allow any outstanding reads to return or be timed out.
-                                                         2. Write a 0 to this bit.
-                                                         3. Start up the packet input/output again (all previous CSR setting of the packet-
-                                                         input/output will be lost).
+	uint64_t rst                          : 1;  /**< Packet reset. When [RST]==1, the rings are in reset. [RST] can be set
+                                                         by software writing a 1 to the field, by hardware upon receipt of an
+                                                         FLR to an associated function, or by hardware when it receives an error
+                                                         response for a read associated with the rings.
+                                                         [MAC_NUM] applies to both this input ring and to the output ring of the same
+                                                         index.
+                                                         Software should not clear [RST] from 1->0 until [RST] has been asserted
+                                                         for at least 2ms. A ring reset may clear all state associated with the
+                                                         input and output rings, so software must completely re-initialize both
+                                                         before reusing them.
                                                          See also SLI_PKT_RING_RST[RST]. */
-	uint64_t enb                          : 1;  /**< Packet output enable. When ENB<i>=1, packet output ring i is enabled.
-                                                         When the ring is in reset, caused by a failing read associated with the ring, the ring
-                                                         being put into
-                                                         reset by writing the reset bit associated with a ring, a FLR or the MAC the ring is
-                                                         associated with
-                                                         being in reset, will cause this bit to clear and be able to be set again till the reset
-                                                         condition is removed. */
-	uint64_t pbp_dhi                      : 13; /**< PBP_DHI replaces address bits that are used for parse mode and skip-length when
-                                                         SLI_PKTi_INSTR_HEADER[PBP] = 1. PBP_DHI becomes either MACADD<63:55> or MACADD<59:51> for
-                                                         the instruction DPTR read operations in this case. The instruction DPTR read operations
-                                                         are called first direct or first indirect. When PBP = 1, if first direct and USE_CSR = 0,
-                                                         PBP_DHI becomes MACADD<59:51>, else MACADD<63:55>. */
-	uint64_t d_nsr                        : 1;  /**< ADDRTYPE<1> or MACADD<61> for packet input data read operations. D_NSR becomes either
-                                                         ADDRTYPE<1> or MACADD<61> for MAC memory space read operations of packet input data
-                                                         fetched for any packet input ring. ADDRTYPE<1> if USE_CSR = 1, else MACADD<61>. In the
-                                                         latter case, ADDRTYPE<1> comes from DPTR<61>. ADDRTYPE<1> is the no-snoop attribute for
-                                                         PCIe. */
-	uint64_t d_esr                        : 2;  /**< ES<1:0> or MACADD<63:62> for packet input data read operations. D_ESR becomes either
-                                                         ES<1:0> or MACADD<63:62> for MAC memory space read operations of packet input data fetched
-                                                         for any packet input ring. ES<1:0> if USE_CSR = 1, else MACADD<63:62>. In the latter case,
-                                                         ES<1:0> comes from DPTR<63:62>. ES<1:0> is the endian-swap attribute for these MAC memory
-                                                         space read operations. */
-	uint64_t d_ror                        : 1;  /**< ADDRTYPE<0> or MACADD<60> for packet input data read operations. D_ROR becomes either
-                                                         ADDRTYPE<0> or MACADD<60> for MAC memory space read operations of packet input data
-                                                         fetched for any packet input ring. ADDRTYPE<0> if USE_CSR = 1, else MACADD<60>. In the
-                                                         latter case, ADDRTYPE<0> comes from DPTR<60>. ADDRTYPE<0> is the relaxed-order attribute
-                                                         for PCIe. */
-	uint64_t use_csr                      : 1;  /**< When set to 1, the CSR value is used for ROR, ESR, and NSR. When clear to 0, the value in
-                                                         DPTR is used. In turn, the bits not used for ROR, ESR, and NSR are used for bits [63:60]
-                                                         of the address used to fetch packet data. */
-	uint64_t nsr                          : 1;  /**< ADDRTYPE<1> for packet input instruction read operations and gather list (i.e. DPI
-                                                         component) read operations from MAC memory space. ADDRTYPE<1> is the no-snoop attribute
-                                                         for PCIe. */
-	uint64_t esr                          : 2;  /**< ES<1:0> for packet input instruction read operations and gather list (i.e. DPI component)
-                                                         read operations from MAC memory space. ES<1:0> is the endian-swap attribute for these MAC
-                                                         memory space read operations. */
-	uint64_t ror                          : 1;  /**< ADDRTYPE<0> for packet input instruction read operations and gather list (i.e. DPI
-                                                         component) read operations from MAC memory space. ADDRTYPE<0> is the relaxed-order
-                                                         attribute for PCIe. */
+	uint64_t enb                          : 1;  /**< Enable for the input ring i. Whenever [RST] is set, hardware forces
+                                                         [ENB] clear.
+                                                         In the PF, [ENB] is also SLI_PKT_INSTR_ENB<i>. */
+	uint64_t pbp_dhi                      : 13; /**< Not used by hardware, but may be cleared by hardware when [RST] is set. */
+	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]==1, [D_NSR] is ADDRTYPE<1> for First Direct and Gather DPTR
+                                                         reads. ADDRTYPE<1> is the no-snoop attribute for PCIe. (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<61> for First Direct and Gather DPTR
+                                                         reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t d_esr                        : 2;  /**< If [USE_CSR]==1, [D_ESR] is ES<1:0> for First Direct and Gather DPTR reads.
+                                                         ES<1:0> is the endian-swap attribute for these MAC memory space reads.
+                                                         (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<63:62> for First Direct and Gather DPTR
+                                                         reads. (ES<1:0> comes from DPTR<63:62> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t d_ror                        : 1;  /**< If [USE_CSR]==1, [D_ROR] is ADDRTYPE<0> for First Direct and Gather DPTR
+                                                         reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. (DPTR Format 0)
+                                                         If [USE_CSR]==0, [D_NSR] is MACADD<60> for First Direct and Gather DPTR
+                                                         reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when [USE_CSR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t use_csr                      : 1;  /**< When set to 1, [D_ROR], [D_ESR], and [D_NSR] are used for ROR, ESR, and NSR,
+                                                         respectively. (DPTR Format 0) When clear to 0, <63:60> from a First Direct
+                                                         or Gather DPTR are used. (DPTR Format 1) The bits not used for ROR, ESR,
+                                                         and NSR become bits <63:60> of the address used to fetch packet data. */
+	uint64_t nsr                          : 1;  /**< [NSR] is ADDRTYPE<1> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ADDRTYPE<1>
+                                                         is the no-snoop attribute for PCIe. */
+	uint64_t esr                          : 2;  /**< [ESR] is ES<1:0> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ES<1:0> is
+                                                         the endian-swap attribute for these MAC memory space reads. */
+	uint64_t ror                          : 1;  /**< [ROR] is ADDRTYPE<0> for input instruction reads (from
+                                                         SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads.
+                                                         ADDRTYPE<0> is the relaxed-order attribute for PCIe. */
 #else
 	uint64_t ror                          : 1;
 	uint64_t esr                          : 2;
@@ -5874,6 +5937,7 @@ union cvmx_sli_pktx_input_control {
 	uint64_t reserved_39_63               : 25;
 #endif
 	} s;
+	struct cvmx_sli_pktx_input_control_s  cn73xx;
 	struct cvmx_sli_pktx_input_control_s  cn78xx;
 };
 typedef union cvmx_sli_pktx_input_control cvmx_sli_pktx_input_control_t;
@@ -5903,6 +5967,7 @@ union cvmx_sli_pktx_instr_baddr {
 	struct cvmx_sli_pktx_instr_baddr_s    cn68xxp1;
 	struct cvmx_sli_pktx_instr_baddr_s    cn70xx;
 	struct cvmx_sli_pktx_instr_baddr_s    cn70xxp1;
+	struct cvmx_sli_pktx_instr_baddr_s    cn73xx;
 	struct cvmx_sli_pktx_instr_baddr_s    cn78xx;
 	struct cvmx_sli_pktx_instr_baddr_s    cnf71xx;
 };
@@ -5937,6 +6002,7 @@ union cvmx_sli_pktx_instr_baoff_dbell {
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn68xxp1;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn70xx;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn70xxp1;
+	struct cvmx_sli_pktx_instr_baoff_dbell_s cn73xx;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cn78xx;
 	struct cvmx_sli_pktx_instr_baoff_dbell_s cnf71xx;
 };
@@ -5973,6 +6039,7 @@ union cvmx_sli_pktx_instr_fifo_rsize {
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn68xxp1;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn70xx;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn70xxp1;
+	struct cvmx_sli_pktx_instr_fifo_rsize_s cn73xx;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cn78xx;
 	struct cvmx_sli_pktx_instr_fifo_rsize_s cnf71xx;
 };
@@ -6146,13 +6213,13 @@ union cvmx_sli_pktx_int_levels {
                                                          (and SLI_PKT_TIME_INT<i> and SLI_PKT_INT<i>), and may cause an MSI-X, MSI, or
                                                          INTA/B/C/D interrupt, whenever SLI_PKT(i)_CNTS[TIMER] > [TIME].
                                                          Whenever software changes the value of [TIME], it should also subsequently write
-                                                         the corresponding SLI_PKT()_CNTS CSR (with a value of zero if desired)
+                                                         the corresponding SLI_PKT()_CNTS register (with a value of zero if desired)
                                                          to ensure that the hardware correspondingly updates SLI_PKT(i)_CNTS[PO_INT]. */
 	uint64_t cnt                          : 32; /**< Output ring counter interrupt threshold. SLI sets SLI_PKT(i)_CNTS[PO_INT]
                                                          (and SLI_PKT_CNT_INT<i> and SLI_PKT_INT<i>), and may cause an MSI-X, MSI, or
                                                          INTA/B/C/D interrupt, whenever SLI_PKT(i)_CNTS[CNT] > [CNT].
                                                          Whenever software changes the value of [TIME], it should also subsequently write
-                                                         the corresponding SLI_PKT()_CNTS CSR (with a value of zero if desired)
+                                                         the corresponding SLI_PKT()_CNTS register (with a value of zero if desired)
                                                          to ensure that the hardware correspondingly updates SLI_PKT(i)_CNTS[PO_INT]. */
 #else
 	uint64_t cnt                          : 32;
@@ -6160,6 +6227,7 @@ union cvmx_sli_pktx_int_levels {
 	uint64_t reserved_54_63               : 10;
 #endif
 	} s;
+	struct cvmx_sli_pktx_int_levels_s     cn73xx;
 	struct cvmx_sli_pktx_int_levels_s     cn78xx;
 };
 typedef union cvmx_sli_pktx_int_levels cvmx_sli_pktx_int_levels_t;
@@ -6192,6 +6260,7 @@ union cvmx_sli_pktx_out_size {
 	struct cvmx_sli_pktx_out_size_s       cn68xxp1;
 	struct cvmx_sli_pktx_out_size_s       cn70xx;
 	struct cvmx_sli_pktx_out_size_s       cn70xxp1;
+	struct cvmx_sli_pktx_out_size_s       cn73xx;
 	struct cvmx_sli_pktx_out_size_s       cn78xx;
 	struct cvmx_sli_pktx_out_size_s       cnf71xx;
 };
@@ -6208,55 +6277,61 @@ union cvmx_sli_pktx_output_control {
 	struct cvmx_sli_pktx_output_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t tenb                         : 1;  /**< Output ring packet timer interrupt enable. When both TENB and corresponding
-                                                         SLI_PKT_TIME_INT[PORT<i>] are set, for any i, SLI_INT_SUM[PTIME] is set, which can cause
-                                                         an interrupt. */
-	uint64_t cenb                         : 1;  /**< Output ring packet counter interrupt enable. When both CENB and corresponding
-                                                         SLI_PKT_CNT_INT[PORT<i>] are set, for any i, SLI_INT_SUM[PCNT] is set, which can cause an
-                                                         interrupt. */
+	uint64_t tenb                         : 1;  /**< SLI_INT_SUM[PTIME] interrupt enable for this ring i. When [TENB] is set and
+                                                         (SLI_PKT(i)_CNTS[TIMER] > SLI_PKT(i)_INT_LEVELS[TIME]), SLI_INT_SUM[PTIME]
+                                                         will be set, and SLI_INT_SUM interrupts can occur if SLI_INT_SUM[PTIME]
+                                                         is enabled to generate interrupts.
+                                                         When [TENB] is clear, SLI_INT_SUM[PTIME] will never assert due to ring i.
+                                                         [TENB] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [TENB] has no effect on SLI_PKT_TIME_INT or SLI_PKT_INT, and
+                                                         has no effect on any non-SLI_INT_SUM interrupt. */
+	uint64_t cenb                         : 1;  /**< SLI_INT_SUM[PCNT] interrupt enable for this ring i. When [CENB] is set and
+                                                         (SLI_PKT(i)_CNTS[TIMER] > SLI_PKT(i)_INT_LEVELS[TIME]), SLI_INT_SUM[PCNT]
+                                                         will be set, and SLI_INT_SUM interrupts can occur if SLI_INT_SUM[PCNT]
+                                                         is enabled to generate interrupts.
+                                                         When [CENB] is clear, SLI_INT_SUM[PCNT] will never assert due to ring i.
+                                                         [CENB] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
+                                                         [CENB] has no effect on SLI_PKT_CNT_INT or SLI_PKT_INT, and
+                                                         has no effect on any non-SLI_INT_SUM interrupt. */
 	uint64_t iptr                         : 1;  /**< When IPTR=1, packet output ring is in info-pointer mode; otherwise the packet output ring
                                                          is in buffer-pointer-only mode. */
-	uint64_t es                           : 2;  /**< ES or MACADD<63:62> for buffer/info write operations to buffer/info pair MAC memory space
-                                                         addresses fetched from packet output ring. ES<1:0> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1,
-                                                         else MACADD<63:62>. In the latter case, ES<1:0> comes from DPTR<63:62>. ES<1:0> is the
-                                                         endian-swap attribute for these MAC memory space writes. */
-	uint64_t nsr                          : 1;  /**< ADDRTYPE<1> or MACADD<61> for buffer/info write operations. NSR    becomes either
-                                                         ADDRTYPE<1> or MACADD<61> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<1> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1, else
-                                                         MACADD<61>. In the latter case, ADDRTYPE<1> comes from DPTR<61>. ADDRTYPE<1> is the no-
-                                                         snoop attribute for PCIe. */
-	uint64_t ror                          : 1;  /**< ADDRTYPE<0> or MACADD<60> for buffer/info write operations. ROR    becomes either
-                                                         ADDRTYPE<0> or MACADD<60> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<0> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1, else
-                                                         MACADD<60>. In the latter case, ADDRTYPE<0> comes from DPTR<60>. ADDRTYPE<0> is the
-                                                         relaxed-order attribute for PCIe. */
-	uint64_t dptr                         : 1;  /**< Determines whether buffer/info pointers are DPTR format 0 or DPTR format 1. When DPTR=1,
-                                                         the buffer/info pointers fetched from packet output ring are DPTR format 0. When DPTR=0,
-                                                         the buffer/info pointers fetched from packet output ring i are DPTR format 1. (Replace
-                                                         SLI_PKT()_INPUT_CONTROL[D_ESR,D_NSR,D_ROR] in the descriptions of DPTR format 0/1 in
-                                                         DPI Instruction Input Initialization with SLI_PKT()_OUTPUT_CONTROL[ES],
-                                                         SLI_PKT()_OUTPUT_CONTROL[NSR], and SLI_PKT()_OUTPUT_CONTROL[ROR], respectively, though.) */
+	uint64_t es                           : 2;  /**< If [DPTR]==1, [ES] is ES<1:0> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. ES<1:0> is the
+                                                         endian-swap attribute for these MAC memory space writes. (DPTR Format 0)
+                                                         If [DPTR]==0, [ES] is MACADD<63:62> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. (<63:62> of the
+                                                         buffer or info pointer is ES<1:0> for the writes in this case when [DPTR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t nsr                          : 1;  /**< If [DPTR]==1, [NSR] is ADDRTYPE<1> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. ADDRTYPE<1> is
+                                                         the no-snoop attribute for PCIe. (DPTR Format 0)
+                                                         If [DPTR]==0, [NSR] is MACADD<61> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. (<61> of the
+                                                         buffer or info pointer is ADDRTYPE<1> for the writes in this case when [DPTR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t ror                          : 1;  /**< If [DPTR]==1, [ROR] is ADDRTYPE<0> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. ADDRTYPE<0> is
+                                                         the relaxed-order attribute for PCIe. (DPTR Format 0)
+                                                         If [DPTR]==0, [ROR] is MACADD<60> for buffer/info write operations to buffer/info
+                                                         pair MAC memory space addresses fetched from packet output ring. (<60> of the
+                                                         buffer or info pointer is ADDRTYPE<0> for the writes in this case when [DPTR]==0.)
+                                                         (DPTR Format 1) */
+	uint64_t dptr                         : 1;  /**< Determines [ES,NSR,ROR] usage and the format of buffer/info pointers. When set,
+                                                         buffer/info pointers are DPTR format 0. When clear, buffer/info pointers
+                                                         are DPTR format 1. */
 	uint64_t bmode                        : 1;  /**< Determines whether SLI_PKT()_CNTS[CNT] is a byte or packet counter. When BMODE=1,
                                                          SLI_PKT()_CNTS[CNT] is a byte counter, else SLI_PKT()_CNTS[CNT] is a packet counter. */
-	uint64_t es_p                         : 2;  /**< ES<1:0> for the packet output ring reads that fetch buffer/info pointer pairs. ES<1:0> is
-                                                         the endian-swap attribute for these MAC memory space reads. */
-	uint64_t nsr_p                        : 1;  /**< ADDRTYPE<1> or MACADD<61> for buffer/info write operations. NSR    becomes either
-                                                         ADDRTYPE<1> or MACADD<61> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<1> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1,
-                                                         else MACADD<61>. In the latter case, ADDRTYPE<1> comes from DPTR<61>. ADDRTYPE<1> is the
-                                                         no-snoop attribute for PCIe. */
-	uint64_t ror_p                        : 1;  /**< ADDRTYPE<0> for the packet output ring reads that fetch buffer/info pointer pairs. ROR
-                                                         becomes ADDRTYPE<0> in DPI/SLI reads that fetch buffer/info pairs from packet output ring
-                                                         (from address SLI_PKT()_SLIST_BADDR+ in MAC memory space.) ADDRTYPE<0> is the relaxed-
-                                                         order
-                                                         attribute for PCIe. */
-	uint64_t enb                          : 1;  /**< Packet output enable. When ENB=1, packet output ring is enabled. When the ring is in
-                                                         reset,
-                                                         caused by a failing read associated with the ring, the ring being put into reset by
-                                                         writing the reset bit associated with a ring, a FLR or the MAC the ring is associated with
-                                                         being in reset, will cause this bit to clear and be able to be set again till the reset
-                                                         condition is removed. This is a mirror of SLI_PKT_OUT_ENB (setting a bit here will set a
-                                                         bit in that CSR). */
+	uint64_t es_p                         : 2;  /**< [ES_P] is ES<1:0> for the packet output ring reads that fetch buffer/info pointer pairs
+                                                         (from SLI_PKT()_SLIST_BADDR[ADDR]+). ES<1:0> is the endian-swap attribute for these
+                                                         MAC memory space reads. */
+	uint64_t nsr_p                        : 1;  /**< [NSR_P] is ADDRTYPE<1> for the packet output ring reads that fetch buffer/info pointer
+                                                         pairs (from SLI_PKT()_SLIST_BADDR[ADDR]+). ADDRTYPE<1> is the no-snoop attribute for PCIe. */
+	uint64_t ror_p                        : 1;  /**< [ROR_P] is ADDRTYPE<0> for the packet output ring reads that fetch buffer/info pointer
+                                                         pairs (from SLI_PKT()_SLIST_BADDR[ADDR]+). ADDRTYPE<0> is the relaxed-order attribute
+                                                         for PCIe. */
+	uint64_t enb                          : 1;  /**< Enable for the output ring i. Whenever SLI_PKT(i)_INPUT_CONTROL[RST] is set, hardware
+                                                         forces [ENB] clear.
+                                                         In the PF, [ENB] is also SLI_PKT_OUT_ENB<i>. */
 #else
 	uint64_t enb                          : 1;
 	uint64_t ror_p                        : 1;
@@ -6273,6 +6348,7 @@ union cvmx_sli_pktx_output_control {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_sli_pktx_output_control_s cn73xx;
 	struct cvmx_sli_pktx_output_control_s cn78xx;
 };
 typedef union cvmx_sli_pktx_output_control cvmx_sli_pktx_output_control_t;
@@ -6302,6 +6378,7 @@ union cvmx_sli_pktx_slist_baddr {
 	struct cvmx_sli_pktx_slist_baddr_s    cn68xxp1;
 	struct cvmx_sli_pktx_slist_baddr_s    cn70xx;
 	struct cvmx_sli_pktx_slist_baddr_s    cn70xxp1;
+	struct cvmx_sli_pktx_slist_baddr_s    cn73xx;
 	struct cvmx_sli_pktx_slist_baddr_s    cn78xx;
 	struct cvmx_sli_pktx_slist_baddr_s    cnf71xx;
 };
@@ -6340,6 +6417,7 @@ union cvmx_sli_pktx_slist_baoff_dbell {
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn68xxp1;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn70xx;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn70xxp1;
+	struct cvmx_sli_pktx_slist_baoff_dbell_s cn73xx;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cn78xx;
 	struct cvmx_sli_pktx_slist_baoff_dbell_s cnf71xx;
 };
@@ -6371,6 +6449,7 @@ union cvmx_sli_pktx_slist_fifo_rsize {
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cn68xxp1;
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cn70xx;
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cn70xxp1;
+	struct cvmx_sli_pktx_slist_fifo_rsize_s cn73xx;
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cn78xx;
 	struct cvmx_sli_pktx_slist_fifo_rsize_s cnf71xx;
 };
@@ -6379,7 +6458,7 @@ typedef union cvmx_sli_pktx_slist_fifo_rsize cvmx_sli_pktx_slist_fifo_rsize_t;
 /**
  * cvmx_sli_pkt#_vf_sig
  *
- * This register is used to signal between PF/VF. These 64 CSRs are index by VF number.
+ * This register is used to signal between PF/VF. These 64 registers are index by VF number.
  *
  */
 union cvmx_sli_pktx_vf_sig {
@@ -6391,6 +6470,7 @@ union cvmx_sli_pktx_vf_sig {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pktx_vf_sig_s         cn73xx;
 	struct cvmx_sli_pktx_vf_sig_s         cn78xx;
 };
 typedef union cvmx_sli_pktx_vf_sig cvmx_sli_pktx_vf_sig_t;
@@ -6433,7 +6513,7 @@ union cvmx_sli_pkt_cnt_int {
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cn68xxp1;
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cn70xx;
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cn70xxp1;
-	struct cvmx_sli_pkt_cnt_int_cn78xx {
+	struct cvmx_sli_pkt_cnt_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ring                         : 64; /**< Multi-ring output ring packet counter interrupt bits. RING<i> is one
                                                          whenever SLI_PKT(i)_CNTS[CNT] > SLI_PKT(i)_INT_LEVELS[CNT].
@@ -6445,7 +6525,8 @@ union cvmx_sli_pkt_cnt_int {
 #else
 	uint64_t ring                         : 64;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_pkt_cnt_int_cn73xx    cn78xx;
 	struct cvmx_sli_pkt_cnt_int_cn61xx    cnf71xx;
 };
 typedef union cvmx_sli_pkt_cnt_int cvmx_sli_pkt_cnt_int_t;
@@ -6754,6 +6835,7 @@ union cvmx_sli_pkt_in_donex_cnts {
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cn68xxp1;
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cn70xx;
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cn70xxp1;
+	struct cvmx_sli_pkt_in_donex_cnts_s   cn73xx;
 	struct cvmx_sli_pkt_in_donex_cnts_s   cn78xx;
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cnf71xx;
 };
@@ -6786,6 +6868,7 @@ union cvmx_sli_pkt_in_instr_counts {
 	struct cvmx_sli_pkt_in_instr_counts_s cn68xxp1;
 	struct cvmx_sli_pkt_in_instr_counts_s cn70xx;
 	struct cvmx_sli_pkt_in_instr_counts_s cn70xxp1;
+	struct cvmx_sli_pkt_in_instr_counts_s cn73xx;
 	struct cvmx_sli_pkt_in_instr_counts_s cn78xx;
 	struct cvmx_sli_pkt_in_instr_counts_s cnf71xx;
 };
@@ -6811,6 +6894,7 @@ union cvmx_sli_pkt_in_int {
 	uint64_t ring                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_in_int_s          cn73xx;
 	struct cvmx_sli_pkt_in_int_s          cn78xx;
 };
 typedef union cvmx_sli_pkt_in_int cvmx_sli_pkt_in_int_t;
@@ -7070,6 +7154,7 @@ union cvmx_sli_pkt_instr_enb {
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn68xxp1;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn70xx;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn70xxp1;
+	struct cvmx_sli_pkt_instr_enb_s       cn73xx;
 	struct cvmx_sli_pkt_instr_enb_s       cn78xx;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cnf71xx;
 };
@@ -7164,11 +7249,13 @@ union cvmx_sli_pkt_int {
                                                           * SLI_PKT_IN_DONE(i)_CNTS[PI_INT] (i.e. SLI_PKT_IN_INT<i>) is set.
                                                          Any of these three conditions can cause an MSI-X interrupt, but only
                                                          the first two (i.e. SLI_PKT_CNT_INT and SLI_PKT_TIME_INT) can cause
-                                                         INTA/B/C/D and MSI interrupts. */
+                                                         INTA/B/C/D and MSI interrupts.
+                                                         SLI_PKT(i)_OUTPUT_CONTROL[CENB,TENB] have no effect on RING<i>. */
 #else
 	uint64_t ring                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_int_s             cn73xx;
 	struct cvmx_sli_pkt_int_s             cn78xx;
 };
 typedef union cvmx_sli_pkt_int cvmx_sli_pkt_int_t;
@@ -7263,6 +7350,7 @@ union cvmx_sli_pkt_macx_rinfo {
 	uint64_t reserved_40_63               : 24;
 #endif
 	} s;
+	struct cvmx_sli_pkt_macx_rinfo_s      cn73xx;
 	struct cvmx_sli_pkt_macx_rinfo_s      cn78xx;
 };
 typedef union cvmx_sli_pkt_macx_rinfo cvmx_sli_pkt_macx_rinfo_t;
@@ -7270,8 +7358,8 @@ typedef union cvmx_sli_pkt_macx_rinfo cvmx_sli_pkt_macx_rinfo_t;
 /**
  * cvmx_sli_pkt_mac0_sig0
  *
- * This register is used to signal between PF/VF. This CSR can be R/W by the PF from MAC0 and any VF.
- *
+ * This register is used to signal between PF/VF. This register can be R/W by the PF from MAC0
+ * and any VF.
  */
 union cvmx_sli_pkt_mac0_sig0 {
 	uint64_t u64;
@@ -7282,6 +7370,7 @@ union cvmx_sli_pkt_mac0_sig0 {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_mac0_sig0_s       cn73xx;
 	struct cvmx_sli_pkt_mac0_sig0_s       cn78xx;
 };
 typedef union cvmx_sli_pkt_mac0_sig0 cvmx_sli_pkt_mac0_sig0_t;
@@ -7289,8 +7378,8 @@ typedef union cvmx_sli_pkt_mac0_sig0 cvmx_sli_pkt_mac0_sig0_t;
 /**
  * cvmx_sli_pkt_mac0_sig1
  *
- * This register is used to signal between PF/VF. This CSR can be R/W by the PF from MAC0 and any VF.
- *
+ * This register is used to signal between PF/VF. This register can be R/W by the PF from MAC0
+ * and any VF.
  */
 union cvmx_sli_pkt_mac0_sig1 {
 	uint64_t u64;
@@ -7301,6 +7390,7 @@ union cvmx_sli_pkt_mac0_sig1 {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_mac0_sig1_s       cn73xx;
 	struct cvmx_sli_pkt_mac0_sig1_s       cn78xx;
 };
 typedef union cvmx_sli_pkt_mac0_sig1 cvmx_sli_pkt_mac0_sig1_t;
@@ -7308,8 +7398,8 @@ typedef union cvmx_sli_pkt_mac0_sig1 cvmx_sli_pkt_mac0_sig1_t;
 /**
  * cvmx_sli_pkt_mac1_sig0
  *
- * This register is used to signal between PF/VF. This CSR can be R/W by the PF from MAC1 and any VF.
- *
+ * This register is used to signal between PF/VF. This register can be R/W by the PF from MAC1
+ * and any VF.
  */
 union cvmx_sli_pkt_mac1_sig0 {
 	uint64_t u64;
@@ -7320,6 +7410,7 @@ union cvmx_sli_pkt_mac1_sig0 {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_mac1_sig0_s       cn73xx;
 	struct cvmx_sli_pkt_mac1_sig0_s       cn78xx;
 };
 typedef union cvmx_sli_pkt_mac1_sig0 cvmx_sli_pkt_mac1_sig0_t;
@@ -7327,8 +7418,8 @@ typedef union cvmx_sli_pkt_mac1_sig0 cvmx_sli_pkt_mac1_sig0_t;
 /**
  * cvmx_sli_pkt_mac1_sig1
  *
- * This register is used to signal between PF/VF. This CSR can be R/W by the PF from MAC1 and any VF.
- *
+ * This register is used to signal between PF/VF. This register can be R/W by the PF from MAC1
+ * and any VF.
  */
 union cvmx_sli_pkt_mac1_sig1 {
 	uint64_t u64;
@@ -7339,6 +7430,7 @@ union cvmx_sli_pkt_mac1_sig1 {
 	uint64_t data                         : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_mac1_sig1_s       cn73xx;
 	struct cvmx_sli_pkt_mac1_sig1_s       cn78xx;
 };
 typedef union cvmx_sli_pkt_mac1_sig1 cvmx_sli_pkt_mac1_sig1_t;
@@ -7416,6 +7508,7 @@ union cvmx_sli_pkt_mem_ctl {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} s;
+	struct cvmx_sli_pkt_mem_ctl_s         cn73xx;
 	struct cvmx_sli_pkt_mem_ctl_s         cn78xx;
 };
 typedef union cvmx_sli_pkt_mem_ctl cvmx_sli_pkt_mem_ctl_t;
@@ -7464,7 +7557,7 @@ union cvmx_sli_pkt_out_bp_en {
 	struct cvmx_sli_pkt_out_bp_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t bp_en                        : 64; /**< When set, enable the channel-level backpressure to be sent to PKO. Backpressure is sent to
-                                                         the PKO on the channels 0x100-0x13F. */
+                                                         the PKO on the channels 0x100-0x13F. See SLI_PKT_OUTPUT_WMARK[WMARK]. */
 #else
 	uint64_t bp_en                        : 64;
 #endif
@@ -7482,6 +7575,7 @@ union cvmx_sli_pkt_out_bp_en {
 #endif
 	} cn68xx;
 	struct cvmx_sli_pkt_out_bp_en_cn68xx  cn68xxp1;
+	struct cvmx_sli_pkt_out_bp_en_s       cn73xx;
 	struct cvmx_sli_pkt_out_bp_en_s       cn78xx;
 };
 typedef union cvmx_sli_pkt_out_bp_en cvmx_sli_pkt_out_bp_en_t;
@@ -7523,6 +7617,7 @@ union cvmx_sli_pkt_out_enb {
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn68xxp1;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn70xx;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn70xxp1;
+	struct cvmx_sli_pkt_out_enb_s         cn73xx;
 	struct cvmx_sli_pkt_out_enb_s         cn78xx;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cnf71xx;
 };
@@ -7555,6 +7650,7 @@ union cvmx_sli_pkt_output_wmark {
 	struct cvmx_sli_pkt_output_wmark_s    cn68xxp1;
 	struct cvmx_sli_pkt_output_wmark_s    cn70xx;
 	struct cvmx_sli_pkt_output_wmark_s    cn70xxp1;
+	struct cvmx_sli_pkt_output_wmark_s    cn73xx;
 	struct cvmx_sli_pkt_output_wmark_s    cn78xx;
 	struct cvmx_sli_pkt_output_wmark_s    cnf71xx;
 };
@@ -7632,11 +7728,12 @@ union cvmx_sli_pkt_ring_rst {
 	uint64_t u64;
 	struct cvmx_sli_pkt_ring_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t rst                          : 64; /**< Ring in reset. When asserted 1, the vector bit corresponding to the packet ring is in reset. */
+	uint64_t rst                          : 64; /**< RST<i> is a RO copy of SLI_PKT(i)_INPUT_CONTROL[RST]. */
 #else
 	uint64_t rst                          : 64;
 #endif
 	} s;
+	struct cvmx_sli_pkt_ring_rst_s        cn73xx;
 	struct cvmx_sli_pkt_ring_rst_s        cn78xx;
 };
 typedef union cvmx_sli_pkt_ring_rst cvmx_sli_pkt_ring_rst_t;
@@ -7785,7 +7882,7 @@ union cvmx_sli_pkt_time_int {
 	struct cvmx_sli_pkt_time_int_cn61xx   cn68xxp1;
 	struct cvmx_sli_pkt_time_int_cn61xx   cn70xx;
 	struct cvmx_sli_pkt_time_int_cn61xx   cn70xxp1;
-	struct cvmx_sli_pkt_time_int_cn78xx {
+	struct cvmx_sli_pkt_time_int_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ring                         : 64; /**< Multi-ring output ring packet time interrupt bits. RING<i> reads as one
                                                          whenever SLI_PKT(i)_CNTS[TIMER] > SLI_PKT(i)_INT_LEVELS[TIME].
@@ -7797,7 +7894,8 @@ union cvmx_sli_pkt_time_int {
 #else
 	uint64_t ring                         : 64;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_pkt_time_int_cn73xx   cn78xx;
 	struct cvmx_sli_pkt_time_int_cn61xx   cnf71xx;
 };
 typedef union cvmx_sli_pkt_time_int cvmx_sli_pkt_time_int_t;
@@ -7899,7 +7997,7 @@ typedef union cvmx_sli_portx_pkind cvmx_sli_portx_pkind_t;
 /**
  * cvmx_sli_s2c_end_merge
  *
- * Writing this CSR will cause a merge to end.
+ * Writing this register will cause a merge to end.
  *
  */
 union cvmx_sli_s2c_end_merge {
@@ -7911,6 +8009,7 @@ union cvmx_sli_s2c_end_merge {
 	uint64_t reserved_0_63                : 64;
 #endif
 	} s;
+	struct cvmx_sli_s2c_end_merge_s       cn73xx;
 	struct cvmx_sli_s2c_end_merge_s       cn78xx;
 };
 typedef union cvmx_sli_s2c_end_merge cvmx_sli_s2c_end_merge_t;
@@ -7929,7 +8028,7 @@ union cvmx_sli_s2m_portx_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
 	uint64_t lcl_node                     : 1;  /**< Local CCPI node. When set to 1, all window access is treated as local CCPI
-                                                         access. Normally, if address bits [37:36] of the window address CSRs are not
+                                                         access. Normally, if address bits [37:36] of the window address registers are not
                                                          equal to the chip's CCPI value, the window operation is sent to the CCPI for
                                                          remote chip access. This field, when set, disables this and treats all access to
                                                          be for the local CCPI. */
@@ -7993,14 +8092,10 @@ union cvmx_sli_s2m_portx_ctl {
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cn68xxp1;
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cn70xx;
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cn70xxp1;
-	struct cvmx_sli_s2m_portx_ctl_cn78xx {
+	struct cvmx_sli_s2m_portx_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
-	uint64_t lcl_node                     : 1;  /**< Local CCPI node. When set to 1, all window access is treated as local CCPI
-                                                         access. Normally, if address bits [37:36] of the window address CSRs are not
-                                                         equal to the chip's CCPI value, the window operation is sent to the CCPI for
-                                                         remote chip access. This field, when set, disables this and treats all access to
-                                                         be for the local CCPI. */
+	uint64_t lcl_node                     : 1;  /**< Reserved. */
 	uint64_t wind_d                       : 1;  /**< Window disable. When set to 1, disables access to the window registers from the MAC port. */
 	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set to 1, disables access from the MAC to BAR0 for the following
                                                          address offsets:
@@ -8022,7 +8117,8 @@ union cvmx_sli_s2m_portx_ctl {
 	uint64_t lcl_node                     : 1;
 	uint64_t reserved_6_63                : 58;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_s2m_portx_ctl_cn73xx  cn78xx;
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_s2m_portx_ctl cvmx_sli_s2m_portx_ctl_t;
@@ -8050,6 +8146,7 @@ union cvmx_sli_scratch_1 {
 	struct cvmx_sli_scratch_1_s           cn68xxp1;
 	struct cvmx_sli_scratch_1_s           cn70xx;
 	struct cvmx_sli_scratch_1_s           cn70xxp1;
+	struct cvmx_sli_scratch_1_s           cn73xx;
 	struct cvmx_sli_scratch_1_s           cn78xx;
 	struct cvmx_sli_scratch_1_s           cnf71xx;
 };
@@ -8078,6 +8175,7 @@ union cvmx_sli_scratch_2 {
 	struct cvmx_sli_scratch_2_s           cn68xxp1;
 	struct cvmx_sli_scratch_2_s           cn70xx;
 	struct cvmx_sli_scratch_2_s           cn70xxp1;
+	struct cvmx_sli_scratch_2_s           cn73xx;
 	struct cvmx_sli_scratch_2_s           cn78xx;
 	struct cvmx_sli_scratch_2_s           cnf71xx;
 };
@@ -8112,6 +8210,7 @@ union cvmx_sli_state1 {
 	struct cvmx_sli_state1_s              cn68xxp1;
 	struct cvmx_sli_state1_s              cn70xx;
 	struct cvmx_sli_state1_s              cn70xxp1;
+	struct cvmx_sli_state1_s              cn73xx;
 	struct cvmx_sli_state1_s              cn78xx;
 	struct cvmx_sli_state1_s              cnf71xx;
 };
@@ -8160,7 +8259,7 @@ union cvmx_sli_state2 {
 	struct cvmx_sli_state2_cn61xx         cn68xxp1;
 	struct cvmx_sli_state2_cn61xx         cn70xx;
 	struct cvmx_sli_state2_cn61xx         cn70xxp1;
-	struct cvmx_sli_state2_cn78xx {
+	struct cvmx_sli_state2_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_57_63               : 7;
 	uint64_t nnp1                         : 8;  /**< NNP1 state. */
@@ -8180,7 +8279,8 @@ union cvmx_sli_state2 {
 	uint64_t nnp1                         : 8;
 	uint64_t reserved_57_63               : 7;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_state2_cn73xx         cn78xx;
 	struct cvmx_sli_state2_cn61xx         cnf71xx;
 };
 typedef union cvmx_sli_state2 cvmx_sli_state2_t;
@@ -8222,7 +8322,7 @@ union cvmx_sli_state3 {
 	struct cvmx_sli_state3_cn61xx         cn68xxp1;
 	struct cvmx_sli_state3_cn61xx         cn70xx;
 	struct cvmx_sli_state3_cn61xx         cn70xxp1;
-	struct cvmx_sli_state3_cn78xx {
+	struct cvmx_sli_state3_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t psm1                         : 15; /**< PSM1 state. */
@@ -8236,7 +8336,8 @@ union cvmx_sli_state3 {
 	uint64_t psm1                         : 15;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sli_state3_cn73xx         cn78xx;
 	struct cvmx_sli_state3_cn61xx         cnf71xx;
 };
 typedef union cvmx_sli_state3 cvmx_sli_state3_t;
@@ -8290,12 +8391,11 @@ typedef union cvmx_sli_tx_pipe cvmx_sli_tx_pipe_t;
 /**
  * cvmx_sli_win_rd_addr
  *
- * When the LSB of this CSR is written, the address in this CSR will be read. The data returned
- * from this read will be placed in the WIN_RD_DATA CSR. This CSR should NOT be used to read
+ * When the LSB of this register is written, the address in this register will be read. The data
+ * returned
+ * from this read will be placed in the WIN_RD_DATA register. This register should NOT be used to
+ * read
  * SLI_* registers.
- *
- * If SLI_S2M_PORT()_CTL[LCL_NODE] the MAC that it is set for will not be able to write
- * SLI_WIN_RD_ADDR[37:36] which will always be written with the chips CCPI-ID.
  */
 union cvmx_sli_win_rd_addr {
 	uint64_t u64;
@@ -8329,6 +8429,7 @@ union cvmx_sli_win_rd_addr {
 	struct cvmx_sli_win_rd_addr_s         cn68xxp1;
 	struct cvmx_sli_win_rd_addr_s         cn70xx;
 	struct cvmx_sli_win_rd_addr_s         cn70xxp1;
+	struct cvmx_sli_win_rd_addr_s         cn73xx;
 	struct cvmx_sli_win_rd_addr_s         cn78xx;
 	struct cvmx_sli_win_rd_addr_s         cnf71xx;
 };
@@ -8337,8 +8438,8 @@ typedef union cvmx_sli_win_rd_addr cvmx_sli_win_rd_addr_t;
 /**
  * cvmx_sli_win_rd_data
  *
- * This CSR holds the data returned when a read operation is started by the writing of the
- * SLI_WIN_RD_ADDR CSR.
+ * This register holds the data returned when a read operation is started by the writing of the
+ * SLI_WIN_RD_ADDR register.
  */
 union cvmx_sli_win_rd_data {
 	uint64_t u64;
@@ -8357,6 +8458,7 @@ union cvmx_sli_win_rd_data {
 	struct cvmx_sli_win_rd_data_s         cn68xxp1;
 	struct cvmx_sli_win_rd_data_s         cn70xx;
 	struct cvmx_sli_win_rd_data_s         cn70xxp1;
+	struct cvmx_sli_win_rd_data_s         cn73xx;
 	struct cvmx_sli_win_rd_data_s         cn78xx;
 	struct cvmx_sli_win_rd_data_s         cnf71xx;
 };
@@ -8377,9 +8479,6 @@ typedef union cvmx_sli_win_rd_data cvmx_sli_win_rd_data_t;
  * writing the SLI_WIN_WR_DATA register. This register should not be used to write SLI_*
  *
  * This register should NOT be used to write SLI_* registers.
- *
- * If SLI_S2M_PORT()_CTL[LCL_NODE] the MAC that it is set for will not be able to write
- * SLI_WIN_WR_ADDR[37:36] which will always be written with the chips CCPI-ID.
  */
 union cvmx_sli_win_wr_addr {
 	uint64_t u64;
@@ -8412,6 +8511,7 @@ union cvmx_sli_win_wr_addr {
 	struct cvmx_sli_win_wr_addr_s         cn68xxp1;
 	struct cvmx_sli_win_wr_addr_s         cn70xx;
 	struct cvmx_sli_win_wr_addr_s         cn70xxp1;
+	struct cvmx_sli_win_wr_addr_s         cn73xx;
 	struct cvmx_sli_win_wr_addr_s         cn78xx;
 	struct cvmx_sli_win_wr_addr_s         cnf71xx;
 };
@@ -8443,6 +8543,7 @@ union cvmx_sli_win_wr_data {
 	struct cvmx_sli_win_wr_data_s         cn68xxp1;
 	struct cvmx_sli_win_wr_data_s         cn70xx;
 	struct cvmx_sli_win_wr_data_s         cn70xxp1;
+	struct cvmx_sli_win_wr_data_s         cn73xx;
 	struct cvmx_sli_win_wr_data_s         cn78xx;
 	struct cvmx_sli_win_wr_data_s         cnf71xx;
 };
@@ -8477,6 +8578,7 @@ union cvmx_sli_win_wr_mask {
 	struct cvmx_sli_win_wr_mask_s         cn68xxp1;
 	struct cvmx_sli_win_wr_mask_s         cn70xx;
 	struct cvmx_sli_win_wr_mask_s         cn70xxp1;
+	struct cvmx_sli_win_wr_mask_s         cn73xx;
 	struct cvmx_sli_win_wr_mask_s         cn78xx;
 	struct cvmx_sli_win_wr_mask_s         cnf71xx;
 };
@@ -8525,6 +8627,7 @@ union cvmx_sli_window_ctl {
 	struct cvmx_sli_window_ctl_cn61xx     cn68xxp1;
 	struct cvmx_sli_window_ctl_cn61xx     cn70xx;
 	struct cvmx_sli_window_ctl_cn61xx     cn70xxp1;
+	struct cvmx_sli_window_ctl_s          cn73xx;
 	struct cvmx_sli_window_ctl_s          cn78xx;
 	struct cvmx_sli_window_ctl_cn61xx     cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-smix-defs.h b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
index 5583676..dfcb582 100644
--- a/arch/mips/include/asm/octeon/cvmx-smix-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
@@ -79,6 +79,10 @@ static inline uint64_t CVMX_SMIX_CLK(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_CLK (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001818ull) + ((offset) & 1) * 256;
@@ -104,6 +108,8 @@ static inline uint64_t CVMX_SMIX_CLK(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001818ull) + (offset) * 256;
 }
@@ -135,6 +141,10 @@ static inline uint64_t CVMX_SMIX_CMD(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_CMD (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001800ull) + ((offset) & 1) * 256;
@@ -160,6 +170,8 @@ static inline uint64_t CVMX_SMIX_CMD(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001800ull) + (offset) * 256;
 }
@@ -191,6 +203,10 @@ static inline uint64_t CVMX_SMIX_EN(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_EN (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001820ull) + ((offset) & 1) * 256;
@@ -216,6 +232,8 @@ static inline uint64_t CVMX_SMIX_EN(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001820ull) + (offset) * 256;
 }
@@ -247,6 +265,10 @@ static inline uint64_t CVMX_SMIX_RD_DAT(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_RD_DAT (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001810ull) + ((offset) & 1) * 256;
@@ -272,6 +294,8 @@ static inline uint64_t CVMX_SMIX_RD_DAT(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001810ull) + (offset) * 256;
 }
@@ -303,6 +327,10 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 3) * 128;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 1) * 128;
+			break;
 	}
 	cvmx_warn("CVMX_SMIX_WR_DAT (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180000001808ull) + ((offset) & 1) * 256;
@@ -328,6 +356,8 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001808ull) + (offset) * 256;
 }
@@ -440,6 +470,7 @@ union cvmx_smix_clk {
 	struct cvmx_smix_clk_s                cn68xxp1;
 	struct cvmx_smix_clk_s                cn70xx;
 	struct cvmx_smix_clk_s                cn70xxp1;
+	struct cvmx_smix_clk_s                cn73xx;
 	struct cvmx_smix_clk_s                cn78xx;
 	struct cvmx_smix_clk_s                cnf71xx;
 };
@@ -516,6 +547,7 @@ union cvmx_smix_cmd {
 	struct cvmx_smix_cmd_s                cn68xxp1;
 	struct cvmx_smix_cmd_s                cn70xx;
 	struct cvmx_smix_cmd_s                cn70xxp1;
+	struct cvmx_smix_cmd_s                cn73xx;
 	struct cvmx_smix_cmd_s                cn78xx;
 	struct cvmx_smix_cmd_s                cnf71xx;
 };
@@ -559,6 +591,7 @@ union cvmx_smix_en {
 	struct cvmx_smix_en_s                 cn68xxp1;
 	struct cvmx_smix_en_s                 cn70xx;
 	struct cvmx_smix_en_s                 cn70xxp1;
+	struct cvmx_smix_en_s                 cn73xx;
 	struct cvmx_smix_en_s                 cn78xx;
 	struct cvmx_smix_en_s                 cnf71xx;
 };
@@ -604,6 +637,7 @@ union cvmx_smix_rd_dat {
 	struct cvmx_smix_rd_dat_s             cn68xxp1;
 	struct cvmx_smix_rd_dat_s             cn70xx;
 	struct cvmx_smix_rd_dat_s             cn70xxp1;
+	struct cvmx_smix_rd_dat_s             cn73xx;
 	struct cvmx_smix_rd_dat_s             cn78xx;
 	struct cvmx_smix_rd_dat_s             cnf71xx;
 };
@@ -649,6 +683,7 @@ union cvmx_smix_wr_dat {
 	struct cvmx_smix_wr_dat_s             cn68xxp1;
 	struct cvmx_smix_wr_dat_s             cn70xx;
 	struct cvmx_smix_wr_dat_s             cn70xxp1;
+	struct cvmx_smix_wr_dat_s             cn73xx;
 	struct cvmx_smix_wr_dat_s             cn78xx;
 	struct cvmx_smix_wr_dat_s             cnf71xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index 5eca181..99a69de 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -67,6 +67,7 @@ static inline uint64_t CVMX_SSO_ACTIVE_CYCLES_FUNC(void)
 static inline uint64_t CVMX_SSO_ACTIVE_CYCLESX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_SSO_ACTIVE_CYCLESX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000001100ull) + ((offset) & 3) * 8;
@@ -78,7 +79,7 @@ static inline uint64_t CVMX_SSO_ACTIVE_CYCLESX(unsigned long offset)
 #define CVMX_SSO_AW_ADD CVMX_SSO_AW_ADD_FUNC()
 static inline uint64_t CVMX_SSO_AW_ADD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_ADD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002080ull);
 }
@@ -89,7 +90,7 @@ static inline uint64_t CVMX_SSO_AW_ADD_FUNC(void)
 #define CVMX_SSO_AW_CFG CVMX_SSO_AW_CFG_FUNC()
 static inline uint64_t CVMX_SSO_AW_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010F0ull);
 }
@@ -100,7 +101,7 @@ static inline uint64_t CVMX_SSO_AW_CFG_FUNC(void)
 #define CVMX_SSO_AW_READ_ARB CVMX_SSO_AW_READ_ARB_FUNC()
 static inline uint64_t CVMX_SSO_AW_READ_ARB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_READ_ARB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002090ull);
 }
@@ -111,7 +112,7 @@ static inline uint64_t CVMX_SSO_AW_READ_ARB_FUNC(void)
 #define CVMX_SSO_AW_STATUS CVMX_SSO_AW_STATUS_FUNC()
 static inline uint64_t CVMX_SSO_AW_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010E0ull);
 }
@@ -122,7 +123,7 @@ static inline uint64_t CVMX_SSO_AW_STATUS_FUNC(void)
 #define CVMX_SSO_AW_TAG_LATENCY_PC CVMX_SSO_AW_TAG_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_SSO_AW_TAG_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_TAG_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020A8ull);
 }
@@ -133,7 +134,7 @@ static inline uint64_t CVMX_SSO_AW_TAG_LATENCY_PC_FUNC(void)
 #define CVMX_SSO_AW_TAG_REQ_PC CVMX_SSO_AW_TAG_REQ_PC_FUNC()
 static inline uint64_t CVMX_SSO_AW_TAG_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_TAG_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020A0ull);
 }
@@ -144,7 +145,7 @@ static inline uint64_t CVMX_SSO_AW_TAG_REQ_PC_FUNC(void)
 #define CVMX_SSO_AW_WE CVMX_SSO_AW_WE_FUNC()
 static inline uint64_t CVMX_SSO_AW_WE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_AW_WE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001080ull);
 }
@@ -166,7 +167,7 @@ static inline uint64_t CVMX_SSO_BIST_STAT_FUNC(void)
 #define CVMX_SSO_BIST_STATUS0 CVMX_SSO_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001200ull);
 }
@@ -177,7 +178,7 @@ static inline uint64_t CVMX_SSO_BIST_STATUS0_FUNC(void)
 #define CVMX_SSO_BIST_STATUS1 CVMX_SSO_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001208ull);
 }
@@ -188,7 +189,7 @@ static inline uint64_t CVMX_SSO_BIST_STATUS1_FUNC(void)
 #define CVMX_SSO_BIST_STATUS2 CVMX_SSO_BIST_STATUS2_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001210ull);
 }
@@ -221,7 +222,7 @@ static inline uint64_t CVMX_SSO_DS_PC_FUNC(void)
 #define CVMX_SSO_ECC_CTL0 CVMX_SSO_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001280ull);
 }
@@ -232,7 +233,7 @@ static inline uint64_t CVMX_SSO_ECC_CTL0_FUNC(void)
 #define CVMX_SSO_ECC_CTL1 CVMX_SSO_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001288ull);
 }
@@ -243,7 +244,7 @@ static inline uint64_t CVMX_SSO_ECC_CTL1_FUNC(void)
 #define CVMX_SSO_ECC_CTL2 CVMX_SSO_ECC_CTL2_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001290ull);
 }
@@ -265,7 +266,7 @@ static inline uint64_t CVMX_SSO_ERR_FUNC(void)
 #define CVMX_SSO_ERR0 CVMX_SSO_ERR0_FUNC()
 static inline uint64_t CVMX_SSO_ERR0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001240ull);
 }
@@ -276,7 +277,7 @@ static inline uint64_t CVMX_SSO_ERR0_FUNC(void)
 #define CVMX_SSO_ERR1 CVMX_SSO_ERR1_FUNC()
 static inline uint64_t CVMX_SSO_ERR1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001248ull);
 }
@@ -287,7 +288,7 @@ static inline uint64_t CVMX_SSO_ERR1_FUNC(void)
 #define CVMX_SSO_ERR2 CVMX_SSO_ERR2_FUNC()
 static inline uint64_t CVMX_SSO_ERR2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_ERR2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001250ull);
 }
@@ -342,6 +343,7 @@ static inline uint64_t CVMX_SSO_FPAGE_CNT_FUNC(void)
 static inline uint64_t CVMX_SSO_GRPX_AQ_CNT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_AQ_CNT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020000700ull) + ((block_id) & 255) * 0x10000ull;
@@ -353,6 +355,7 @@ static inline uint64_t CVMX_SSO_GRPX_AQ_CNT(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_AQ_THR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_AQ_THR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020000800ull) + ((block_id) & 255) * 0x10000ull;
@@ -364,6 +367,7 @@ static inline uint64_t CVMX_SSO_GRPX_AQ_THR(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_DS_PC(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_DS_PC(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020001400ull) + ((block_id) & 255) * 0x10000ull;
@@ -375,6 +379,7 @@ static inline uint64_t CVMX_SSO_GRPX_DS_PC(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_EXT_PC(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_EXT_PC(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020001100ull) + ((block_id) & 255) * 0x10000ull;
@@ -386,6 +391,7 @@ static inline uint64_t CVMX_SSO_GRPX_EXT_PC(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_IAQ_THR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_IAQ_THR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020000000ull) + ((block_id) & 255) * 0x10000ull;
@@ -397,6 +403,7 @@ static inline uint64_t CVMX_SSO_GRPX_IAQ_THR(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_INT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020000400ull) + ((block_id) & 255) * 0x10000ull;
@@ -408,6 +415,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_INT_CNT(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT_CNT(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020000600ull) + ((block_id) & 255) * 0x10000ull;
@@ -419,6 +427,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT_CNT(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_INT_THR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT_THR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020000500ull) + ((block_id) & 255) * 0x10000ull;
@@ -430,6 +439,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT_THR(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_PRI(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_PRI(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020000200ull) + ((block_id) & 255) * 0x10000ull;
@@ -441,6 +451,7 @@ static inline uint64_t CVMX_SSO_GRPX_PRI(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_TAQ_THR(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_TAQ_THR(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020000100ull) + ((block_id) & 255) * 0x10000ull;
@@ -452,6 +463,7 @@ static inline uint64_t CVMX_SSO_GRPX_TAQ_THR(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_TS_PC(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_TS_PC(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020001300ull) + ((block_id) & 255) * 0x10000ull;
@@ -463,6 +475,7 @@ static inline uint64_t CVMX_SSO_GRPX_TS_PC(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_WA_PC(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_WA_PC(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020001200ull) + ((block_id) & 255) * 0x10000ull;
@@ -474,6 +487,7 @@ static inline uint64_t CVMX_SSO_GRPX_WA_PC(unsigned long block_id)
 static inline uint64_t CVMX_SSO_GRPX_WS_PC(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 255)))))
 		cvmx_warn("CVMX_SSO_GRPX_WS_PC(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670020001000ull) + ((block_id) & 255) * 0x10000ull;
@@ -485,7 +499,7 @@ static inline uint64_t CVMX_SSO_GRPX_WS_PC(unsigned long block_id)
 #define CVMX_SSO_GWE_CFG CVMX_SSO_GWE_CFG_FUNC()
 static inline uint64_t CVMX_SSO_GWE_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_GWE_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001098ull);
 }
@@ -496,7 +510,7 @@ static inline uint64_t CVMX_SSO_GWE_CFG_FUNC(void)
 #define CVMX_SSO_GWE_RANDOM CVMX_SSO_GWE_RANDOM_FUNC()
 static inline uint64_t CVMX_SSO_GWE_RANDOM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_GWE_RANDOM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010B0ull);
 }
@@ -529,6 +543,7 @@ static inline uint64_t CVMX_SSO_IDX_ECC_ST_FUNC(void)
 static inline uint64_t CVMX_SSO_IENTX_LINKS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_LINKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0060000ull) + ((offset) & 4095) * 8;
@@ -540,6 +555,7 @@ static inline uint64_t CVMX_SSO_IENTX_LINKS(unsigned long offset)
 static inline uint64_t CVMX_SSO_IENTX_PENDTAG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_PENDTAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0040000ull) + ((offset) & 4095) * 8;
@@ -551,6 +567,7 @@ static inline uint64_t CVMX_SSO_IENTX_PENDTAG(unsigned long offset)
 static inline uint64_t CVMX_SSO_IENTX_QLINKS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_QLINKS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0080000ull) + ((offset) & 4095) * 8;
@@ -562,6 +579,7 @@ static inline uint64_t CVMX_SSO_IENTX_QLINKS(unsigned long offset)
 static inline uint64_t CVMX_SSO_IENTX_TAG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_TAG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0000000ull) + ((offset) & 4095) * 8;
@@ -573,6 +591,7 @@ static inline uint64_t CVMX_SSO_IENTX_TAG(unsigned long offset)
 static inline uint64_t CVMX_SSO_IENTX_WQPGRP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_SSO_IENTX_WQPGRP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700A0020000ull) + ((offset) & 4095) * 8;
@@ -584,6 +603,7 @@ static inline uint64_t CVMX_SSO_IENTX_WQPGRP(unsigned long offset)
 static inline uint64_t CVMX_SSO_IPL_CONFX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_CONFX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080080000ull) + ((offset) & 255) * 8;
@@ -595,6 +615,7 @@ static inline uint64_t CVMX_SSO_IPL_CONFX(unsigned long offset)
 static inline uint64_t CVMX_SSO_IPL_DESCHEDX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_DESCHEDX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080060000ull) + ((offset) & 255) * 8;
@@ -606,6 +627,7 @@ static inline uint64_t CVMX_SSO_IPL_DESCHEDX(unsigned long offset)
 static inline uint64_t CVMX_SSO_IPL_FREEX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_SSO_IPL_FREEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080000000ull) + ((offset) & 7) * 8;
@@ -617,6 +639,7 @@ static inline uint64_t CVMX_SSO_IPL_FREEX(unsigned long offset)
 static inline uint64_t CVMX_SSO_IPL_IAQX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_IPL_IAQX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670080040000ull) + ((offset) & 255) * 8;
@@ -683,7 +706,7 @@ static inline uint64_t CVMX_SSO_IQ_THRX(unsigned long offset)
 #define CVMX_SSO_NOS_CNT CVMX_SSO_NOS_CNT_FUNC()
 static inline uint64_t CVMX_SSO_NOS_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_NOS_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001040ull);
 }
@@ -694,7 +717,7 @@ static inline uint64_t CVMX_SSO_NOS_CNT_FUNC(void)
 #define CVMX_SSO_NW_TIM CVMX_SSO_NW_TIM_FUNC()
 static inline uint64_t CVMX_SSO_NW_TIM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_NW_TIM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001028ull);
 }
@@ -727,7 +750,7 @@ static inline uint64_t CVMX_SSO_OTH_ECC_ST_FUNC(void)
 #define CVMX_SSO_PAGE_CNT CVMX_SSO_PAGE_CNT_FUNC()
 static inline uint64_t CVMX_SSO_PAGE_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_PAGE_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001090ull);
 }
@@ -760,6 +783,7 @@ static inline uint64_t CVMX_SSO_PND_ECC_ST_FUNC(void)
 static inline uint64_t CVMX_SSO_PPX_ARB(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
 		cvmx_warn("CVMX_SSO_PPX_ARB(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670040000000ull) + ((block_id) & 63) * 0x10000ull;
@@ -793,6 +817,7 @@ static inline uint64_t CVMX_SSO_PPX_QOS_PRI(unsigned long offset)
 static inline uint64_t CVMX_SSO_PPX_SX_GRPMSKX(unsigned long a, unsigned long b, unsigned long c)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 15)) && ((b <= 1)) && ((c == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 47)) && ((b <= 1)) && ((c <= 3))))))
 		cvmx_warn("CVMX_SSO_PPX_SX_GRPMSKX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
 	return CVMX_ADD_IO_SEG(0x0001670040001000ull) + ((a) << 16) + ((b) << 5) + ((c) << 3);
@@ -850,6 +875,7 @@ static inline uint64_t CVMX_SSO_RESET_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
@@ -865,6 +891,7 @@ static inline uint64_t CVMX_SSO_RESET_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F0ull);
@@ -920,6 +947,7 @@ static inline uint64_t CVMX_SSO_RWQ_TAIL_PTRX(unsigned long offset)
 static inline uint64_t CVMX_SSO_SL_PPX_LINKS(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_LINKS(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670060000040ull) + ((block_id) & 63) * 0x10000ull;
@@ -931,6 +959,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_LINKS(unsigned long block_id)
 static inline uint64_t CVMX_SSO_SL_PPX_PENDTAG(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_PENDTAG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670060000000ull) + ((block_id) & 63) * 0x10000ull;
@@ -942,6 +971,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_PENDTAG(unsigned long block_id)
 static inline uint64_t CVMX_SSO_SL_PPX_PENDWQP(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_PENDWQP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670060000010ull) + ((block_id) & 63) * 0x10000ull;
@@ -953,6 +983,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_PENDWQP(unsigned long block_id)
 static inline uint64_t CVMX_SSO_SL_PPX_TAG(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_TAG(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670060000020ull) + ((block_id) & 63) * 0x10000ull;
@@ -964,6 +995,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_TAG(unsigned long block_id)
 static inline uint64_t CVMX_SSO_SL_PPX_WQP(unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 47)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_WQP(%lu) is invalid on this chip\n", block_id);
 	return CVMX_ADD_IO_SEG(0x0001670060000030ull) + ((block_id) & 63) * 0x10000ull;
@@ -975,6 +1007,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_WQP(unsigned long block_id)
 static inline uint64_t CVMX_SSO_TAQX_LINK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 319))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1279)))))
 		cvmx_warn("CVMX_SSO_TAQX_LINK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700C0000000ull) + ((offset) & 2047) * 4096;
@@ -986,6 +1019,7 @@ static inline uint64_t CVMX_SSO_TAQX_LINK(unsigned long offset)
 static inline uint64_t CVMX_SSO_TAQX_WAEX_TAG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 1279))))))
 		cvmx_warn("CVMX_SSO_TAQX_WAEX_TAG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00016700D0000000ull) + (((offset) & 15) + ((block_id) & 2047) * 0x100ull) * 16;
@@ -997,6 +1031,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_TAG(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_SSO_TAQX_WAEX_WQP(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 1279))))))
 		cvmx_warn("CVMX_SSO_TAQX_WAEX_WQP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00016700D0000008ull) + (((offset) & 15) + ((block_id) & 2047) * 0x100ull) * 16;
@@ -1008,7 +1043,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_WQP(unsigned long offset, unsigned lon
 #define CVMX_SSO_TAQ_ADD CVMX_SSO_TAQ_ADD_FUNC()
 static inline uint64_t CVMX_SSO_TAQ_ADD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_TAQ_ADD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020E0ull);
 }
@@ -1019,7 +1054,7 @@ static inline uint64_t CVMX_SSO_TAQ_ADD_FUNC(void)
 #define CVMX_SSO_TAQ_CNT CVMX_SSO_TAQ_CNT_FUNC()
 static inline uint64_t CVMX_SSO_TAQ_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_TAQ_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020C0ull);
 }
@@ -1030,6 +1065,7 @@ static inline uint64_t CVMX_SSO_TAQ_CNT_FUNC(void)
 static inline uint64_t CVMX_SSO_TIAQX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_TIAQX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000C0000ull) + ((offset) & 255) * 8;
@@ -1041,6 +1077,7 @@ static inline uint64_t CVMX_SSO_TIAQX_STATUS(unsigned long offset)
 static inline uint64_t CVMX_SSO_TOAQX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_TOAQX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000D0000ull) + ((offset) & 255) * 8;
@@ -1107,7 +1144,7 @@ static inline uint64_t CVMX_SSO_WQ_INT_CNTX(unsigned long offset)
 #define CVMX_SSO_WQ_INT_PC CVMX_SSO_WQ_INT_PC_FUNC()
 static inline uint64_t CVMX_SSO_WQ_INT_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_WQ_INT_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001020ull);
 }
@@ -1140,7 +1177,7 @@ static inline uint64_t CVMX_SSO_WQ_IQ_DIS_FUNC(void)
 #define CVMX_SSO_WS_CFG CVMX_SSO_WS_CFG_FUNC()
 static inline uint64_t CVMX_SSO_WS_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_WS_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001088ull);
 }
@@ -1162,6 +1199,7 @@ static inline uint64_t CVMX_SSO_WS_PCX(unsigned long offset)
 static inline uint64_t CVMX_SSO_XAQX_HEAD_NEXT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_HEAD_NEXT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000A0000ull) + ((offset) & 255) * 8;
@@ -1173,6 +1211,7 @@ static inline uint64_t CVMX_SSO_XAQX_HEAD_NEXT(unsigned long offset)
 static inline uint64_t CVMX_SSO_XAQX_HEAD_PTR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_HEAD_PTR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000080000ull) + ((offset) & 255) * 8;
@@ -1184,6 +1223,7 @@ static inline uint64_t CVMX_SSO_XAQX_HEAD_PTR(unsigned long offset)
 static inline uint64_t CVMX_SSO_XAQX_TAIL_NEXT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_TAIL_NEXT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016700000B0000ull) + ((offset) & 255) * 8;
@@ -1195,6 +1235,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_NEXT(unsigned long offset)
 static inline uint64_t CVMX_SSO_XAQX_TAIL_PTR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_SSO_XAQX_TAIL_PTR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001670000090000ull) + ((offset) & 255) * 8;
@@ -1206,7 +1247,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_PTR(unsigned long offset)
 #define CVMX_SSO_XAQ_AURA CVMX_SSO_XAQ_AURA_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_AURA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_AURA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002100ull);
 }
@@ -1217,7 +1258,7 @@ static inline uint64_t CVMX_SSO_XAQ_AURA_FUNC(void)
 #define CVMX_SSO_XAQ_LATENCY_PC CVMX_SSO_XAQ_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020B8ull);
 }
@@ -1228,7 +1269,7 @@ static inline uint64_t CVMX_SSO_XAQ_LATENCY_PC_FUNC(void)
 #define CVMX_SSO_XAQ_REQ_PC CVMX_SSO_XAQ_REQ_PC_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SSO_XAQ_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020B0ull);
 }
@@ -1272,6 +1313,7 @@ union cvmx_sso_active_cyclesx {
 	uint64_t act_cyc                      : 64;
 #endif
 	} s;
+	struct cvmx_sso_active_cyclesx_s      cn73xx;
 	struct cvmx_sso_active_cyclesx_s      cn78xx;
 };
 typedef union cvmx_sso_active_cyclesx cvmx_sso_active_cyclesx_t;
@@ -1293,6 +1335,7 @@ union cvmx_sso_aw_add {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_sso_aw_add_s              cn73xx;
 	struct cvmx_sso_aw_add_s              cn78xx;
 };
 typedef union cvmx_sso_aw_add cvmx_sso_aw_add_t;
@@ -1333,6 +1376,7 @@ union cvmx_sso_aw_cfg {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_sso_aw_cfg_s              cn73xx;
 	struct cvmx_sso_aw_cfg_s              cn78xx;
 };
 typedef union cvmx_sso_aw_cfg cvmx_sso_aw_cfg_t;
@@ -1367,6 +1411,7 @@ union cvmx_sso_aw_read_arb {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_sso_aw_read_arb_s         cn73xx;
 	struct cvmx_sso_aw_read_arb_s         cn78xx;
 };
 typedef union cvmx_sso_aw_read_arb cvmx_sso_aw_read_arb_t;
@@ -1388,6 +1433,7 @@ union cvmx_sso_aw_status {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} s;
+	struct cvmx_sso_aw_status_s           cn73xx;
 	struct cvmx_sso_aw_status_s           cn78xx;
 };
 typedef union cvmx_sso_aw_status cvmx_sso_aw_status_t;
@@ -1405,6 +1451,7 @@ union cvmx_sso_aw_tag_latency_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_sso_aw_tag_latency_pc_s   cn73xx;
 	struct cvmx_sso_aw_tag_latency_pc_s   cn78xx;
 };
 typedef union cvmx_sso_aw_tag_latency_pc cvmx_sso_aw_tag_latency_pc_t;
@@ -1421,6 +1468,7 @@ union cvmx_sso_aw_tag_req_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_sso_aw_tag_req_pc_s       cn73xx;
 	struct cvmx_sso_aw_tag_req_pc_s       cn78xx;
 };
 typedef union cvmx_sso_aw_tag_req_pc cvmx_sso_aw_tag_req_pc_t;
@@ -1447,6 +1495,7 @@ union cvmx_sso_aw_we {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
+	struct cvmx_sso_aw_we_s               cn73xx;
 	struct cvmx_sso_aw_we_s               cn78xx;
 };
 typedef union cvmx_sso_aw_we cvmx_sso_aw_we_t;
@@ -1585,6 +1634,7 @@ union cvmx_sso_bist_status0 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
+	struct cvmx_sso_bist_status0_s        cn73xx;
 	struct cvmx_sso_bist_status0_s        cn78xx;
 };
 typedef union cvmx_sso_bist_status0 cvmx_sso_bist_status0_t;
@@ -1613,6 +1663,7 @@ union cvmx_sso_bist_status1 {
 	uint64_t reserved_7_63                : 57;
 #endif
 	} s;
+	struct cvmx_sso_bist_status1_s        cn73xx;
 	struct cvmx_sso_bist_status1_s        cn78xx;
 };
 typedef union cvmx_sso_bist_status1 cvmx_sso_bist_status1_t;
@@ -1643,6 +1694,7 @@ union cvmx_sso_bist_status2 {
 	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
+	struct cvmx_sso_bist_status2_s        cn73xx;
 	struct cvmx_sso_bist_status2_s        cn78xx;
 };
 typedef union cvmx_sso_bist_status2 cvmx_sso_bist_status2_t;
@@ -1810,6 +1862,7 @@ union cvmx_sso_ecc_ctl0 {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_sso_ecc_ctl0_s            cn73xx;
 	struct cvmx_sso_ecc_ctl0_s            cn78xx;
 };
 typedef union cvmx_sso_ecc_ctl0 cvmx_sso_ecc_ctl0_t;
@@ -1855,6 +1908,7 @@ union cvmx_sso_ecc_ctl1 {
 	uint64_t reserved_21_63               : 43;
 #endif
 	} s;
+	struct cvmx_sso_ecc_ctl1_s            cn73xx;
 	struct cvmx_sso_ecc_ctl1_s            cn78xx;
 };
 typedef union cvmx_sso_ecc_ctl1 cvmx_sso_ecc_ctl1_t;
@@ -1892,6 +1946,7 @@ union cvmx_sso_ecc_ctl2 {
 	uint64_t reserved_15_63               : 49;
 #endif
 	} s;
+	struct cvmx_sso_ecc_ctl2_s            cn73xx;
 	struct cvmx_sso_ecc_ctl2_s            cn78xx;
 };
 typedef union cvmx_sso_ecc_ctl2 cvmx_sso_ecc_ctl2_t;
@@ -2055,6 +2110,7 @@ union cvmx_sso_err0 {
 	uint64_t reserved_52_63               : 12;
 #endif
 	} s;
+	struct cvmx_sso_err0_s                cn73xx;
 	struct cvmx_sso_err0_s                cn78xx;
 };
 typedef union cvmx_sso_err0 cvmx_sso_err0_t;
@@ -2102,6 +2158,7 @@ union cvmx_sso_err1 {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
+	struct cvmx_sso_err1_s                cn73xx;
 	struct cvmx_sso_err1_s                cn78xx;
 };
 typedef union cvmx_sso_err1 cvmx_sso_err1_t;
@@ -2163,6 +2220,7 @@ union cvmx_sso_err2 {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_err2_s                cn73xx;
 	struct cvmx_sso_err2_s                cn78xx;
 };
 typedef union cvmx_sso_err2 cvmx_sso_err2_t;
@@ -2319,6 +2377,7 @@ union cvmx_sso_grpx_aq_cnt {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_sso_grpx_aq_cnt_s         cn73xx;
 	struct cvmx_sso_grpx_aq_cnt_s         cn78xx;
 };
 typedef union cvmx_sso_grpx_aq_cnt cvmx_sso_grpx_aq_cnt_t;
@@ -2338,6 +2397,7 @@ union cvmx_sso_grpx_aq_thr {
 	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
+	struct cvmx_sso_grpx_aq_thr_s         cn73xx;
 	struct cvmx_sso_grpx_aq_thr_s         cn78xx;
 };
 typedef union cvmx_sso_grpx_aq_thr cvmx_sso_grpx_aq_thr_t;
@@ -2358,6 +2418,7 @@ union cvmx_sso_grpx_ds_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_ds_pc_s          cn73xx;
 	struct cvmx_sso_grpx_ds_pc_s          cn78xx;
 };
 typedef union cvmx_sso_grpx_ds_pc cvmx_sso_grpx_ds_pc_t;
@@ -2379,6 +2440,7 @@ union cvmx_sso_grpx_ext_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_ext_pc_s         cn73xx;
 	struct cvmx_sso_grpx_ext_pc_s         cn78xx;
 };
 typedef union cvmx_sso_grpx_ext_pc cvmx_sso_grpx_ext_pc_t;
@@ -2415,6 +2477,7 @@ union cvmx_sso_grpx_iaq_thr {
 	uint64_t reserved_61_63               : 3;
 #endif
 	} s;
+	struct cvmx_sso_grpx_iaq_thr_s        cn73xx;
 	struct cvmx_sso_grpx_iaq_thr_s        cn78xx;
 };
 typedef union cvmx_sso_grpx_iaq_thr cvmx_sso_grpx_iaq_thr_t;
@@ -2458,6 +2521,7 @@ union cvmx_sso_grpx_int {
 	uint64_t exe_dis                      : 1;
 #endif
 	} s;
+	struct cvmx_sso_grpx_int_s            cn73xx;
 	struct cvmx_sso_grpx_int_s            cn78xx;
 };
 typedef union cvmx_sso_grpx_int cvmx_sso_grpx_int_t;
@@ -2499,6 +2563,7 @@ union cvmx_sso_grpx_int_cnt {
 	uint64_t reserved_61_63               : 3;
 #endif
 	} s;
+	struct cvmx_sso_grpx_int_cnt_s        cn73xx;
 	struct cvmx_sso_grpx_int_cnt_s        cn78xx;
 };
 typedef union cvmx_sso_grpx_int_cnt cvmx_sso_grpx_int_cnt_t;
@@ -2542,6 +2607,7 @@ union cvmx_sso_grpx_int_thr {
 	uint64_t tc_en                        : 1;
 #endif
 	} s;
+	struct cvmx_sso_grpx_int_thr_s        cn73xx;
 	struct cvmx_sso_grpx_int_thr_s        cn78xx;
 };
 typedef union cvmx_sso_grpx_int_thr cvmx_sso_grpx_int_thr_t;
@@ -2582,6 +2648,7 @@ union cvmx_sso_grpx_pri {
 	uint64_t reserved_30_63               : 34;
 #endif
 	} s;
+	struct cvmx_sso_grpx_pri_s            cn73xx;
 	struct cvmx_sso_grpx_pri_s            cn78xx;
 };
 typedef union cvmx_sso_grpx_pri cvmx_sso_grpx_pri_t;
@@ -2617,6 +2684,7 @@ union cvmx_sso_grpx_taq_thr {
 	uint64_t reserved_59_63               : 5;
 #endif
 	} s;
+	struct cvmx_sso_grpx_taq_thr_s        cn73xx;
 	struct cvmx_sso_grpx_taq_thr_s        cn78xx;
 };
 typedef union cvmx_sso_grpx_taq_thr cvmx_sso_grpx_taq_thr_t;
@@ -2637,6 +2705,7 @@ union cvmx_sso_grpx_ts_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_ts_pc_s          cn73xx;
 	struct cvmx_sso_grpx_ts_pc_s          cn78xx;
 };
 typedef union cvmx_sso_grpx_ts_pc cvmx_sso_grpx_ts_pc_t;
@@ -2658,6 +2727,7 @@ union cvmx_sso_grpx_wa_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_wa_pc_s          cn73xx;
 	struct cvmx_sso_grpx_wa_pc_s          cn78xx;
 };
 typedef union cvmx_sso_grpx_wa_pc cvmx_sso_grpx_wa_pc_t;
@@ -2678,6 +2748,7 @@ union cvmx_sso_grpx_ws_pc {
 	uint64_t cnt                          : 64;
 #endif
 	} s;
+	struct cvmx_sso_grpx_ws_pc_s          cn73xx;
 	struct cvmx_sso_grpx_ws_pc_s          cn78xx;
 };
 typedef union cvmx_sso_grpx_ws_pc cvmx_sso_grpx_ws_pc_t;
@@ -2760,19 +2831,19 @@ union cvmx_sso_gwe_cfg {
 	uint64_t reserved_4_63                : 60;
 #endif
 	} cn68xxp1;
-	struct cvmx_sso_gwe_cfg_cn78xx {
+	struct cvmx_sso_gwe_cfg_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t dis_wgt_credit               : 1;  /**< Disable group weight credits. When set, groups have infinite weight credit. */
 	uint64_t ws_retries                   : 8;  /**< Work slot retries. When a given work-slot performs this number of retries without
-                                                         successfully finding work then NO_WORK will be returned. Zero disables the retry counter.
-                                                         Values 1, 2, 3 are reserved. */
+                                                         successfully finding work then NO_WORK will be returned. Values 0, 1, 2, 3 are reserved. */
 #else
 	uint64_t ws_retries                   : 8;
 	uint64_t dis_wgt_credit               : 1;
 	uint64_t reserved_9_63                : 55;
 #endif
-	} cn78xx;
+	} cn73xx;
+	struct cvmx_sso_gwe_cfg_cn73xx        cn78xx;
 };
 typedef union cvmx_sso_gwe_cfg cvmx_sso_gwe_cfg_t;
 
@@ -2806,6 +2877,7 @@ union cvmx_sso_gwe_random {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_sso_gwe_random_s          cn73xx;
 	struct cvmx_sso_gwe_random_s          cn78xx;
 };
 typedef union cvmx_sso_gwe_random cvmx_sso_gwe_random_t;
@@ -2879,6 +2951,35 @@ union cvmx_sso_ientx_links {
 	uint64_t reserved_28_63               : 36;
 	uint64_t prev_index                   : 12; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
                                                          or the head of a conflicted tag chain. */
+	uint64_t reserved_0_15                : 16;
+#else
+	uint64_t reserved_0_15                : 16;
+	uint64_t prev_index                   : 12;
+	uint64_t reserved_28_63               : 36;
+#endif
+	} s;
+	struct cvmx_sso_ientx_links_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_26_63               : 38;
+	uint64_t prev_index                   : 10; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
+                                                         or the head of a conflicted tag chain. */
+	uint64_t reserved_11_15               : 5;
+	uint64_t next_index_vld               : 1;  /**< The NEXT_INDEX is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
+	uint64_t next_index                   : 10; /**< The next entry in the tag chain or conflicted tag chain. Unpredictable if the entry is at
+                                                         the tail of the list. */
+#else
+	uint64_t next_index                   : 10;
+	uint64_t next_index_vld               : 1;
+	uint64_t reserved_11_15               : 5;
+	uint64_t prev_index                   : 10;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} cn73xx;
+	struct cvmx_sso_ientx_links_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_28_63               : 36;
+	uint64_t prev_index                   : 12; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
+                                                         or the head of a conflicted tag chain. */
 	uint64_t reserved_13_15               : 3;
 	uint64_t next_index_vld               : 1;  /**< The NEXT_INDEX is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
 	uint64_t next_index                   : 12; /**< The next entry in the tag chain or conflicted tag chain. Unpredictable if the entry is at
@@ -2890,8 +2991,7 @@ union cvmx_sso_ientx_links {
 	uint64_t prev_index                   : 12;
 	uint64_t reserved_28_63               : 36;
 #endif
-	} s;
-	struct cvmx_sso_ientx_links_s         cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_sso_ientx_links cvmx_sso_ientx_links_t;
 
@@ -2919,6 +3019,7 @@ union cvmx_sso_ientx_pendtag {
 	uint64_t reserved_38_63               : 26;
 #endif
 	} s;
+	struct cvmx_sso_ientx_pendtag_s       cn73xx;
 	struct cvmx_sso_ientx_pendtag_s       cn78xx;
 };
 typedef union cvmx_sso_ientx_pendtag cvmx_sso_ientx_pendtag_t;
@@ -2940,6 +3041,7 @@ union cvmx_sso_ientx_qlinks {
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_sso_ientx_qlinks_s        cn73xx;
 	struct cvmx_sso_ientx_qlinks_s        cn78xx;
 };
 typedef union cvmx_sso_ientx_qlinks cvmx_sso_ientx_qlinks_t;
@@ -2970,6 +3072,7 @@ union cvmx_sso_ientx_tag {
 	uint64_t reserved_39_63               : 25;
 #endif
 	} s;
+	struct cvmx_sso_ientx_tag_s           cn73xx;
 	struct cvmx_sso_ientx_tag_s           cn78xx;
 };
 typedef union cvmx_sso_ientx_tag cvmx_sso_ientx_tag_t;
@@ -3002,6 +3105,27 @@ union cvmx_sso_ientx_wqpgrp {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_sso_ientx_wqpgrp_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_62_63               : 2;
+	uint64_t head                         : 1;  /**< SSO entry is at the head of a tag chain that is descheduled. */
+	uint64_t nosched                      : 1;  /**< The nosched bit for the SSO entry. */
+	uint64_t reserved_56_59               : 4;
+	uint64_t grp                          : 8;  /**< Group of the SSO entry.
+                                                         INTERNAL:
+                                                         The upper bits are not stored in the RAM, but rather indicate the OCI node number. */
+	uint64_t reserved_42_47               : 6;
+	uint64_t wqp                          : 42; /**< Work queue pointer held in the SSO entry. */
+#else
+	uint64_t wqp                          : 42;
+	uint64_t reserved_42_47               : 6;
+	uint64_t grp                          : 8;
+	uint64_t reserved_56_59               : 4;
+	uint64_t nosched                      : 1;
+	uint64_t head                         : 1;
+	uint64_t reserved_62_63               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_sso_ientx_wqpgrp_s        cn78xx;
 };
 typedef union cvmx_sso_ientx_wqpgrp cvmx_sso_ientx_wqpgrp_t;
@@ -3033,6 +3157,7 @@ union cvmx_sso_ipl_confx {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_sso_ipl_confx_s           cn73xx;
 	struct cvmx_sso_ipl_confx_s           cn78xx;
 };
 typedef union cvmx_sso_ipl_confx cvmx_sso_ipl_confx_t;
@@ -3064,6 +3189,7 @@ union cvmx_sso_ipl_deschedx {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_sso_ipl_deschedx_s        cn73xx;
 	struct cvmx_sso_ipl_deschedx_s        cn78xx;
 };
 typedef union cvmx_sso_ipl_deschedx cvmx_sso_ipl_deschedx_t;
@@ -3080,13 +3206,13 @@ union cvmx_sso_ipl_freex {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_62_63               : 2;
 	uint64_t qnum_head                    : 3;  /**< Subqueue with current head. */
-	uint64_t qnum_tail                    : 3;  /**< Subqueue with current tail. */
+	uint64_t qnum_tail                    : 3;  /**< Subqueue for next tail. */
 	uint64_t reserved_28_55               : 28;
-	uint64_t queue_val                    : 1;  /**< One or more valid entries are in the queue. */
+	uint64_t queue_val                    : 1;  /**< One or more valid entries are in this subqueue. */
 	uint64_t reserved_25_26               : 2;
-	uint64_t queue_head                   : 12; /**< Index of entry at the head of the queue. */
+	uint64_t queue_head                   : 12; /**< Index of entry at the head of this subqueue. */
 	uint64_t reserved_12_12               : 1;
-	uint64_t queue_tail                   : 12; /**< Index of entry at the tail of the queue. */
+	uint64_t queue_tail                   : 12; /**< Index of entry at the tail of this subqueue. */
 #else
 	uint64_t queue_tail                   : 12;
 	uint64_t reserved_12_12               : 1;
@@ -3099,6 +3225,29 @@ union cvmx_sso_ipl_freex {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_sso_ipl_freex_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_62_63               : 2;
+	uint64_t qnum_head                    : 3;  /**< Subqueue with current head. */
+	uint64_t qnum_tail                    : 3;  /**< Subqueue for next tail. */
+	uint64_t reserved_28_55               : 28;
+	uint64_t queue_val                    : 1;  /**< One or more valid entries are in this subqueue. */
+	uint64_t reserved_23_26               : 4;
+	uint64_t queue_head                   : 10; /**< Index of entry at the head of this subqueue. */
+	uint64_t reserved_10_12               : 3;
+	uint64_t queue_tail                   : 10; /**< Index of entry at the tail of this subqueue. */
+#else
+	uint64_t queue_tail                   : 10;
+	uint64_t reserved_10_12               : 3;
+	uint64_t queue_head                   : 10;
+	uint64_t reserved_23_26               : 4;
+	uint64_t queue_val                    : 1;
+	uint64_t reserved_28_55               : 28;
+	uint64_t qnum_tail                    : 3;
+	uint64_t qnum_head                    : 3;
+	uint64_t reserved_62_63               : 2;
+#endif
+	} cn73xx;
 	struct cvmx_sso_ipl_freex_s           cn78xx;
 };
 typedef union cvmx_sso_ipl_freex cvmx_sso_ipl_freex_t;
@@ -3130,6 +3279,7 @@ union cvmx_sso_ipl_iaqx {
 	uint64_t reserved_28_63               : 36;
 #endif
 	} s;
+	struct cvmx_sso_ipl_iaqx_s            cn73xx;
 	struct cvmx_sso_ipl_iaqx_s            cn78xx;
 };
 typedef union cvmx_sso_ipl_iaqx cvmx_sso_ipl_iaqx_t;
@@ -3286,6 +3436,7 @@ union cvmx_sso_nos_cnt {
 #endif
 	} cn68xx;
 	struct cvmx_sso_nos_cnt_cn68xx        cn68xxp1;
+	struct cvmx_sso_nos_cnt_s             cn73xx;
 	struct cvmx_sso_nos_cnt_s             cn78xx;
 };
 typedef union cvmx_sso_nos_cnt cvmx_sso_nos_cnt_t;
@@ -3314,6 +3465,7 @@ union cvmx_sso_nw_tim {
 	} s;
 	struct cvmx_sso_nw_tim_s              cn68xx;
 	struct cvmx_sso_nw_tim_s              cn68xxp1;
+	struct cvmx_sso_nw_tim_s              cn73xx;
 	struct cvmx_sso_nw_tim_s              cn78xx;
 };
 typedef union cvmx_sso_nw_tim cvmx_sso_nw_tim_t;
@@ -3405,6 +3557,7 @@ union cvmx_sso_page_cnt {
 	uint64_t reserved_32_63               : 32;
 #endif
 	} s;
+	struct cvmx_sso_page_cnt_s            cn73xx;
 	struct cvmx_sso_page_cnt_s            cn78xx;
 };
 typedef union cvmx_sso_page_cnt cvmx_sso_page_cnt_t;
@@ -3502,6 +3655,7 @@ union cvmx_sso_ppx_arb {
 	uint64_t reserved_20_63               : 44;
 #endif
 	} s;
+	struct cvmx_sso_ppx_arb_s             cn73xx;
 	struct cvmx_sso_ppx_arb_s             cn78xx;
 };
 typedef union cvmx_sso_ppx_arb cvmx_sso_ppx_arb_t;
@@ -3604,7 +3758,7 @@ typedef union cvmx_sso_ppx_qos_pri cvmx_sso_ppx_qos_pri_t;
  * cvmx_sso_pp#_s#_grpmsk#
  *
  * These registers select which group or groups a core belongs to. There are 2 sets of masks per
- * core, each with 4 registers corresponding to 64 bit slices of the 256 groups.
+ * core, each with 1 register corresponding to 64 groups.
  */
 union cvmx_sso_ppx_sx_grpmskx {
 	uint64_t u64;
@@ -3624,6 +3778,7 @@ union cvmx_sso_ppx_sx_grpmskx {
 	uint64_t grp_msk                      : 64;
 #endif
 	} s;
+	struct cvmx_sso_ppx_sx_grpmskx_s      cn73xx;
 	struct cvmx_sso_ppx_sx_grpmskx_s      cn78xx;
 };
 typedef union cvmx_sso_ppx_sx_grpmskx cvmx_sso_ppx_sx_grpmskx_t;
@@ -3803,6 +3958,7 @@ union cvmx_sso_reset {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} cn68xx;
+	struct cvmx_sso_reset_s               cn73xx;
 	struct cvmx_sso_reset_s               cn78xx;
 };
 typedef union cvmx_sso_reset cvmx_sso_reset_t;
@@ -3966,6 +4122,62 @@ union cvmx_sso_sl_ppx_links {
                                                          The upper two bits are hardcoded to the node number. */
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t reserved_0_25                : 26;
+#else
+	uint64_t reserved_0_25                : 26;
+	uint64_t tail                         : 1;
+	uint64_t head                         : 1;
+	uint64_t grp                          : 10;
+	uint64_t reserved_38_47               : 10;
+	uint64_t index                        : 12;
+	uint64_t reserved_60_62               : 3;
+	uint64_t tailc                        : 1;
+#endif
+	} s;
+	struct cvmx_sso_sl_ppx_links_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t tailc                        : 1;  /**< Set when this SSO entry is the tail of the conflicted tail chain, and so there are no
+                                                         additional conflicts on this tag chain. */
+	uint64_t reserved_58_62               : 5;
+	uint64_t index                        : 10; /**< The SSO entry attached to the core. */
+	uint64_t reserved_36_47               : 12;
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         INTERNAL:
+                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t reserved_21_25               : 5;
+	uint64_t revlink_index                : 10; /**< Prior SSO entry in the tag list when HEAD=0 and TT is not UNTAGGED nor EMPTY, otherwise
+                                                         unpredictable. */
+	uint64_t link_index_vld               : 1;  /**< Indicates LINK_INDEX is valid. LINK_INDEX_VLD is itself valid when TAIL=1 and TT=ATOMIC,
+                                                         otherwise unpredictable. */
+	uint64_t link_index                   : 10; /**< Next SSO entry in the tag list when LINK_INDEX_VLD=1, TAILC=0 and TT=ATOMIC,
+                                                         otherwise unpredictable. */
+#else
+	uint64_t link_index                   : 10;
+	uint64_t link_index_vld               : 1;
+	uint64_t revlink_index                : 10;
+	uint64_t reserved_21_25               : 5;
+	uint64_t tail                         : 1;
+	uint64_t head                         : 1;
+	uint64_t grp                          : 8;
+	uint64_t reserved_36_47               : 12;
+	uint64_t index                        : 10;
+	uint64_t reserved_58_62               : 5;
+	uint64_t tailc                        : 1;
+#endif
+	} cn73xx;
+	struct cvmx_sso_sl_ppx_links_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t tailc                        : 1;  /**< Set when this SSO entry is the tail of the conflicted tail chain, and so there are no
+                                                         additional conflicts on this tag chain. */
+	uint64_t reserved_60_62               : 3;
+	uint64_t index                        : 12; /**< The SSO entry attached to the core. */
+	uint64_t reserved_38_47               : 10;
+	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t reserved_25_25               : 1;
 	uint64_t revlink_index                : 12; /**< Prior SSO entry in the tag list when HEAD=0 and TT is not UNTAGGED nor EMPTY, otherwise
                                                          unpredictable. */
@@ -3986,8 +4198,7 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t reserved_60_62               : 3;
 	uint64_t tailc                        : 1;
 #endif
-	} s;
-	struct cvmx_sso_sl_ppx_links_s        cn78xx;
+	} cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_links cvmx_sso_sl_ppx_links_t;
 
@@ -4026,6 +4237,7 @@ union cvmx_sso_sl_ppx_pendtag {
 	uint64_t pend_switch                  : 1;
 #endif
 	} s;
+	struct cvmx_sso_sl_ppx_pendtag_s      cn73xx;
 	struct cvmx_sso_sl_ppx_pendtag_s      cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_pendtag cvmx_sso_sl_ppx_pendtag_t;
@@ -4067,6 +4279,35 @@ union cvmx_sso_sl_ppx_pendwqp {
 	uint64_t pend_switch                  : 1;
 #endif
 	} s;
+	struct cvmx_sso_sl_ppx_pendwqp_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pend_switch                  : 1;  /**< Set when there is a pending SWTAG, SWTAG_DESCHED, or SWTAG_FULL to ORDERED or ATOMIC. If
+                                                         the status load was issued after an indexed GET_WORK, the DESCHED portion of a
+                                                         SWTAG_DESCHED cannot still be pending. */
+	uint64_t pend_get_work                : 1;  /**< Set when there is a pending GET_WORK. */
+	uint64_t pend_get_work_wait           : 1;  /**< When PEND_GET_WORK is set, indicates that the WAITW bit was set. */
+	uint64_t pend_nosched                 : 1;  /**< Set when nosched is desired and PEND_DESCHED is set. */
+	uint64_t pend_nosched_clr             : 1;  /**< Set when there is a pending CLR_NSCHED. */
+	uint64_t pend_desched                 : 1;  /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
+	uint64_t pend_alloc_we                : 1;  /**< Set when there is a pending ALLOC_WE. */
+	uint64_t reserved_54_56               : 3;
+	uint64_t pend_index                   : 10; /**< The index when PEND_NOSCHED_CLR is set. */
+	uint64_t reserved_42_43               : 2;
+	uint64_t pend_wqp                     : 42; /**< The WQP when PEND_NOSCHED_CLR is set. */
+#else
+	uint64_t pend_wqp                     : 42;
+	uint64_t reserved_42_43               : 2;
+	uint64_t pend_index                   : 10;
+	uint64_t reserved_54_56               : 3;
+	uint64_t pend_alloc_we                : 1;
+	uint64_t pend_desched                 : 1;
+	uint64_t pend_nosched_clr             : 1;
+	uint64_t pend_nosched                 : 1;
+	uint64_t pend_get_work_wait           : 1;
+	uint64_t pend_get_work                : 1;
+	uint64_t pend_switch                  : 1;
+#endif
+	} cn73xx;
 	struct cvmx_sso_sl_ppx_pendwqp_s      cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_pendwqp cvmx_sso_sl_ppx_pendwqp_t;
@@ -4106,6 +4347,34 @@ union cvmx_sso_sl_ppx_tag {
 	uint64_t tailc                        : 1;
 #endif
 	} s;
+	struct cvmx_sso_sl_ppx_tag_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t tailc                        : 1;  /**< Set when this SSO entry is the tail of the conflicted tail chain, and so there are no
+                                                         additional conflicts on this tag chain. */
+	uint64_t reserved_58_62               : 5;
+	uint64_t index                        : 10; /**< The SSO entry attached to the core. */
+	uint64_t reserved_44_47               : 4;
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         INTERNAL:
+                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
+	uint64_t tt                           : 2;  /**< The tag type attached to the core (updated when new tag list entered on SWTAG, SWTAG_FULL,
+                                                         or SWTAG_DESCHED.) */
+	uint64_t tag                          : 32; /**< The tag attached to the core (updated when new tag list entered on SWTAG, SWTAG_FULL, or
+                                                         SWTAG_DESCHED.) */
+#else
+	uint64_t tag                          : 32;
+	uint64_t tt                           : 2;
+	uint64_t tail                         : 1;
+	uint64_t head                         : 1;
+	uint64_t grp                          : 8;
+	uint64_t reserved_44_47               : 4;
+	uint64_t index                        : 10;
+	uint64_t reserved_58_62               : 5;
+	uint64_t tailc                        : 1;
+#endif
+	} cn73xx;
 	struct cvmx_sso_sl_ppx_tag_s          cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_tag cvmx_sso_sl_ppx_tag_t;
@@ -4132,6 +4401,21 @@ union cvmx_sso_sl_ppx_wqp {
 	uint64_t reserved_58_63               : 6;
 #endif
 	} s;
+	struct cvmx_sso_sl_ppx_wqp_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_56_63               : 8;
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         INTERNAL:
+                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t reserved_42_47               : 6;
+	uint64_t wqp                          : 42; /**< The WQP attached to the core (updated when new tag list entered on SWTAG_FULL.) */
+#else
+	uint64_t wqp                          : 42;
+	uint64_t reserved_42_47               : 6;
+	uint64_t grp                          : 8;
+	uint64_t reserved_56_63               : 8;
+#endif
+	} cn73xx;
 	struct cvmx_sso_sl_ppx_wqp_s          cn78xx;
 };
 typedef union cvmx_sso_sl_ppx_wqp cvmx_sso_sl_ppx_wqp_t;
@@ -4153,6 +4437,7 @@ union cvmx_sso_taqx_link {
 	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
+	struct cvmx_sso_taqx_link_s           cn73xx;
 	struct cvmx_sso_taqx_link_s           cn78xx;
 };
 typedef union cvmx_sso_taqx_link cvmx_sso_taqx_link_t;
@@ -4176,6 +4461,7 @@ union cvmx_sso_taqx_waex_tag {
 	uint64_t reserved_34_63               : 30;
 #endif
 	} s;
+	struct cvmx_sso_taqx_waex_tag_s       cn73xx;
 	struct cvmx_sso_taqx_waex_tag_s       cn78xx;
 };
 typedef union cvmx_sso_taqx_waex_tag cvmx_sso_taqx_waex_tag_t;
@@ -4197,6 +4483,7 @@ union cvmx_sso_taqx_waex_wqp {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_taqx_waex_wqp_s       cn73xx;
 	struct cvmx_sso_taqx_waex_wqp_s       cn78xx;
 };
 typedef union cvmx_sso_taqx_waex_wqp cvmx_sso_taqx_waex_wqp_t;
@@ -4218,6 +4505,7 @@ union cvmx_sso_taq_add {
 	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
+	struct cvmx_sso_taq_add_s             cn73xx;
 	struct cvmx_sso_taq_add_s             cn78xx;
 };
 typedef union cvmx_sso_taq_add cvmx_sso_taq_add_t;
@@ -4244,6 +4532,7 @@ union cvmx_sso_taq_cnt {
 	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
+	struct cvmx_sso_taq_cnt_s             cn73xx;
 	struct cvmx_sso_taq_cnt_s             cn78xx;
 };
 typedef union cvmx_sso_taq_cnt cvmx_sso_taq_cnt_t;
@@ -4283,6 +4572,7 @@ union cvmx_sso_tiaqx_status {
 	uint64_t wae_head                     : 4;
 #endif
 	} s;
+	struct cvmx_sso_tiaqx_status_s        cn73xx;
 	struct cvmx_sso_tiaqx_status_s        cn78xx;
 };
 typedef union cvmx_sso_tiaqx_status cvmx_sso_tiaqx_status_t;
@@ -4325,6 +4615,7 @@ union cvmx_sso_toaqx_status {
 	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
+	struct cvmx_sso_toaqx_status_s        cn73xx;
 	struct cvmx_sso_toaqx_status_s        cn78xx;
 };
 typedef union cvmx_sso_toaqx_status cvmx_sso_toaqx_status_t;
@@ -4501,7 +4792,8 @@ union cvmx_sso_wq_int_pc {
 	uint64_t reserved_60_63               : 4;
 	uint64_t pc                           : 28; /**< Work-executable interrupt periodic counter. */
 	uint64_t reserved_28_31               : 4;
-	uint64_t pc_thr                       : 20; /**< Work-executable interrupt periodic counter threshold. Zero disables the counter. */
+	uint64_t pc_thr                       : 20; /**< Work-executable interrupt periodic counter threshold. Zero disables the counter.
+                                                         If non-zero, the value must be >= 3. */
 	uint64_t reserved_0_7                 : 8;
 #else
 	uint64_t reserved_0_7                 : 8;
@@ -4513,6 +4805,7 @@ union cvmx_sso_wq_int_pc {
 	} s;
 	struct cvmx_sso_wq_int_pc_s           cn68xx;
 	struct cvmx_sso_wq_int_pc_s           cn68xxp1;
+	struct cvmx_sso_wq_int_pc_s           cn73xx;
 	struct cvmx_sso_wq_int_pc_s           cn78xx;
 };
 typedef union cvmx_sso_wq_int_pc cvmx_sso_wq_int_pc_t;
@@ -4634,6 +4927,7 @@ union cvmx_sso_ws_cfg {
 	uint64_t reserved_56_63               : 8;
 #endif
 	} s;
+	struct cvmx_sso_ws_cfg_s              cn73xx;
 	struct cvmx_sso_ws_cfg_s              cn78xx;
 };
 typedef union cvmx_sso_ws_cfg cvmx_sso_ws_cfg_t;
@@ -4683,6 +4977,7 @@ union cvmx_sso_xaqx_head_next {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_xaqx_head_next_s      cn73xx;
 	struct cvmx_sso_xaqx_head_next_s      cn78xx;
 };
 typedef union cvmx_sso_xaqx_head_next cvmx_sso_xaqx_head_next_t;
@@ -4711,6 +5006,7 @@ union cvmx_sso_xaqx_head_ptr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_xaqx_head_ptr_s       cn73xx;
 	struct cvmx_sso_xaqx_head_ptr_s       cn78xx;
 };
 typedef union cvmx_sso_xaqx_head_ptr cvmx_sso_xaqx_head_ptr_t;
@@ -4736,6 +5032,7 @@ union cvmx_sso_xaqx_tail_next {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_xaqx_tail_next_s      cn73xx;
 	struct cvmx_sso_xaqx_tail_next_s      cn78xx;
 };
 typedef union cvmx_sso_xaqx_tail_next cvmx_sso_xaqx_tail_next_t;
@@ -4762,6 +5059,7 @@ union cvmx_sso_xaqx_tail_ptr {
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
+	struct cvmx_sso_xaqx_tail_ptr_s       cn73xx;
 	struct cvmx_sso_xaqx_tail_ptr_s       cn78xx;
 };
 typedef union cvmx_sso_xaqx_tail_ptr cvmx_sso_xaqx_tail_ptr_t;
@@ -4775,15 +5073,16 @@ union cvmx_sso_xaq_aura {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t node                         : 2;  /**< Node number of current chip, to ensure that the aura is on the local node. */
-	uint64_t laura                        : 10; /**< FPA local-node aura to use for SSO XAQ allocations and frees. The FPA aura selected by
-                                                         LAURA must select a pool with FPA_POOL()_CFG[NAT_ALIGN]=1, and
-                                                         (FPA_POOL()_CFG[BUF_SIZE] - FPA_POOL()_CFG[BUF_OFFSET]) >= 4 KB / 128. */
+	uint64_t laura                        : 10; /**< FPA local-node aura to use for SSO XAQ allocations and frees. The FPA aura
+                                                         selected by LAURA must correspond to a pool where the buffers (after any
+                                                         FPA_POOL()_CFG[BUF_OFFSET]) are at least 4 KB. */
 #else
 	uint64_t laura                        : 10;
 	uint64_t node                         : 2;
 	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
+	struct cvmx_sso_xaq_aura_s            cn73xx;
 	struct cvmx_sso_xaq_aura_s            cn78xx;
 };
 typedef union cvmx_sso_xaq_aura cvmx_sso_xaq_aura_t;
@@ -4801,6 +5100,7 @@ union cvmx_sso_xaq_latency_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_sso_xaq_latency_pc_s      cn73xx;
 	struct cvmx_sso_xaq_latency_pc_s      cn78xx;
 };
 typedef union cvmx_sso_xaq_latency_pc cvmx_sso_xaq_latency_pc_t;
@@ -4817,6 +5117,7 @@ union cvmx_sso_xaq_req_pc {
 	uint64_t count                        : 64;
 #endif
 	} s;
+	struct cvmx_sso_xaq_req_pc_s          cn73xx;
 	struct cvmx_sso_xaq_req_pc_s          cn78xx;
 };
 typedef union cvmx_sso_xaq_req_pc cvmx_sso_xaq_req_pc_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
index 2eefa07..f865f24 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
@@ -55,1146 +55,2914 @@
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_CAPLENGTH(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_CAPLENGTH(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000000ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000000ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000000ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_CAPLENGTH (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000000ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_CAPLENGTH(block_id) (CVMX_ADD_IO_SEG(0x0001680000000000ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_CAPLENGTH(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000000ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000000ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000000ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_CONFIG(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_CONFIG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000058ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000058ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000058ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_CONFIG (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000058ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_CONFIG(block_id) (CVMX_ADD_IO_SEG(0x0001680000000058ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_CONFIG(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000058ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000058ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000058ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_CRCR(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_CRCR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000038ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000038ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000038ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_CRCR (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000038ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_CRCR(block_id) (CVMX_ADD_IO_SEG(0x0001680000000038ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_CRCR(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000038ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000038ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000038ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DALEPENA(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DALEPENA(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C720ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C720ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C720ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DALEPENA (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C720ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DALEPENA(block_id) (CVMX_ADD_IO_SEG(0x000168000000C720ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DALEPENA(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C720ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C720ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C720ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DBOFF(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DBOFF(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000014ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000014ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000014ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DBOFF (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000014ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DBOFF(block_id) (CVMX_ADD_IO_SEG(0x0001680000000014ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DBOFF(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000014ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000014ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000014ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DBX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 64)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DBX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000480ull) + (((offset) & 127) + ((block_id) & 1) * 0x4000000000ull) * 4;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 64)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000480ull) + (((offset) & 127) + ((block_id) & 1) * 0x4000000000ull) * 4;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 64)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000480ull) + (((offset) & 127) + ((block_id) & 0) * 0x4000000000ull) * 4;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DBX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000480ull) + (((offset) & 127) + ((block_id) & 0) * 0x4000000000ull) * 4;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DBX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000480ull) + (((offset) & 127) + ((block_id) & 1) * 0x4000000000ull) * 4)
+static inline uint64_t CVMX_USBDRDX_UAHC_DBX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000480ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000480ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000480ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DCBAAP(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DCBAAP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000050ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000050ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000050ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DCBAAP (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000050ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DCBAAP(block_id) (CVMX_ADD_IO_SEG(0x0001680000000050ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DCBAAP(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000050ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000050ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000050ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DCFG(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C700ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C700ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C700ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DCFG (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C700ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DCFG(block_id) (CVMX_ADD_IO_SEG(0x000168000000C700ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DCFG(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C700ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C700ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C700ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DCTL(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C704ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C704ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C704ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DCTL (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C704ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DCTL(block_id) (CVMX_ADD_IO_SEG(0x000168000000C704ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DCTL(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C704ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C704ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C704ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C808ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C808ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C808ull) + (((offset) & 15) + ((block_id) & 0) * 0x1000000000ull) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR0_X (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C808ull) + (((offset) & 15) + ((block_id) & 0) * 0x1000000000ull) * 16;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C808ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16)
+static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR0_X(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C808ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C808ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C808ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C804ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C804ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C804ull) + (((offset) & 15) + ((block_id) & 0) * 0x1000000000ull) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR1_X (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C804ull) + (((offset) & 15) + ((block_id) & 0) * 0x1000000000ull) * 16;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C804ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16)
+static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR1_X(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C804ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C804ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C804ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C800ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C800ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C800ull) + (((offset) & 15) + ((block_id) & 0) * 0x1000000000ull) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDPAR2_X (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C800ull) + (((offset) & 15) + ((block_id) & 0) * 0x1000000000ull) * 16;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C800ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16)
+static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDPAR2_X(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C800ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C800ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C800ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 15)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C80Cull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C80Cull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C80Cull) + (((offset) & 15) + ((block_id) & 0) * 0x1000000000ull) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DEPCMDX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C80Cull) + (((offset) & 15) + ((block_id) & 0) * 0x1000000000ull) * 16;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DEPCMDX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C80Cull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000000ull) * 16)
+static inline uint64_t CVMX_USBDRDX_UAHC_DEPCMDX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C80Cull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C80Cull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C80Cull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DEVTEN(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DEVTEN(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C708ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C708ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C708ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DEVTEN (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C708ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DEVTEN(block_id) (CVMX_ADD_IO_SEG(0x000168000000C708ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DEVTEN(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C708ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C708ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C708ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DGCMD(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DGCMD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C714ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C714ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C714ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DGCMD (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C714ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DGCMD(block_id) (CVMX_ADD_IO_SEG(0x000168000000C714ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DGCMD(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C714ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C714ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C714ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DGCMDPAR(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DGCMDPAR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C710ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C710ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C710ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DGCMDPAR (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C710ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DGCMDPAR(block_id) (CVMX_ADD_IO_SEG(0x000168000000C710ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DGCMDPAR(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C710ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C710ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C710ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DNCTRL(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DNCTRL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000034ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000034ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000034ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DNCTRL (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000034ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DNCTRL(block_id) (CVMX_ADD_IO_SEG(0x0001680000000034ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DNCTRL(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000034ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000034ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000034ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_DSTS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_DSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C70Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C70Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C70Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_DSTS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C70Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_DSTS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C70Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_DSTS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C70Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C70Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C70Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_ERDPX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_ERDPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000478ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000478ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000478ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_ERDPX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000478ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_ERDPX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000478ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_ERDPX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000478ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000478ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000478ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_ERSTBAX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_ERSTBAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000470ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000470ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000470ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_ERSTBAX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000470ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_ERSTBAX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000470ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_ERSTBAX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000470ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000470ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000470ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_ERSTSZX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_ERSTSZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000468ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000468ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000468ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_ERSTSZX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000468ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_ERSTSZX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000468ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_ERSTSZX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000468ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000468ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000468ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GBUSERRADDR(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GBUSERRADDR(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C130ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C130ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C130ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GBUSERRADDR (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C130ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GBUSERRADDR(block_id) (CVMX_ADD_IO_SEG(0x000168000000C130ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GBUSERRADDR(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C130ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C130ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C130ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GCTL(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C110ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C110ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C110ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GCTL (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C110ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GCTL(block_id) (CVMX_ADD_IO_SEG(0x000168000000C110ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GCTL(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C110ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C110ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C110ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GDBGBMU(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGBMU(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C16Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C16Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C16Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GDBGBMU (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C16Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGBMU(block_id) (CVMX_ADD_IO_SEG(0x000168000000C16Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGBMU(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C16Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C16Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C16Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GDBGEPINFO(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGEPINFO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C178ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C178ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C178ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GDBGEPINFO (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C178ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGEPINFO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C178ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGEPINFO(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C178ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C178ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C178ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C160ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C160ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C160ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GDBGFIFOSPACE (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C160ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(block_id) (CVMX_ADD_IO_SEG(0x000168000000C160ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGFIFOSPACE(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C160ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C160ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C160ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLNMCC(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLNMCC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C168ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C168ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C168ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLNMCC (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C168ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGLNMCC(block_id) (CVMX_ADD_IO_SEG(0x000168000000C168ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLNMCC(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C168ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C168ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C168ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSP(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C174ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C174ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C174ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSP (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C174ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGLSP(block_id) (CVMX_ADD_IO_SEG(0x000168000000C174ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSP(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C174ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C174ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C174ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSPMUX(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSPMUX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C170ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C170ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C170ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLSPMUX (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C170ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGLSPMUX(block_id) (CVMX_ADD_IO_SEG(0x000168000000C170ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLSPMUX(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C170ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C170ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C170ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLTSSM(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLTSSM(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C164ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C164ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C164ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GDBGLTSSM (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C164ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDBGLTSSM(block_id) (CVMX_ADD_IO_SEG(0x000168000000C164ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDBGLTSSM(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C164ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C164ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C164ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GDMAHLRATIO(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GDMAHLRATIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C624ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C624ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C624ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GDMAHLRATIO (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C624ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GDMAHLRATIO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C624ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GDMAHLRATIO(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C624ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C624ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C624ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTADRX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTADRX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C400ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C400ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C400ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTADRX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C400ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GEVNTADRX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C400ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTADRX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C400ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C400ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C400ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTCOUNTX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTCOUNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C40Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C40Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C40Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTCOUNTX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C40Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GEVNTCOUNTX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C40Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTCOUNTX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C40Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C40Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C40Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTSIZX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C408ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C408ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C408ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GEVNTSIZX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C408ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GEVNTSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C408ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GEVNTSIZX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C408ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C408ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C408ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GFLADJ(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GFLADJ(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C630ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C630ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C630ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GFLADJ (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C630ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GFLADJ(block_id) (CVMX_ADD_IO_SEG(0x000168000000C630ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GFLADJ(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C630ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C630ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C630ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GGPIO(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GGPIO(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C124ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C124ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C124ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GGPIO (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C124ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GGPIO(block_id) (CVMX_ADD_IO_SEG(0x000168000000C124ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GGPIO(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C124ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C124ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C124ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS0(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C140ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C140ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C140ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS0 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C140ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS0(block_id) (CVMX_ADD_IO_SEG(0x000168000000C140ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS0(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C140ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C140ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C140ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS1(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C144ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C144ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C144ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS1 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C144ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C144ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS1(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C144ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C144ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C144ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS2(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C148ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C148ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C148ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS2 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C148ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS2(block_id) (CVMX_ADD_IO_SEG(0x000168000000C148ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS2(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C148ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C148ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C148ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS3(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C14Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C14Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C14Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS3 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C14Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS3(block_id) (CVMX_ADD_IO_SEG(0x000168000000C14Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS3(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C14Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C14Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C14Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS4(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS4(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C150ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C150ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C150ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS4 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C150ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS4(block_id) (CVMX_ADD_IO_SEG(0x000168000000C150ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS4(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C150ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C150ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C150ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS5(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS5(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C154ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C154ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C154ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS5 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C154ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS5(block_id) (CVMX_ADD_IO_SEG(0x000168000000C154ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS5(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C154ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C154ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C154ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS6(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS6(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C158ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C158ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C158ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS6 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C158ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS6(block_id) (CVMX_ADD_IO_SEG(0x000168000000C158ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS6(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C158ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C158ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C158ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS7(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS7(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C15Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C15Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C15Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS7 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C15Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS7(block_id) (CVMX_ADD_IO_SEG(0x000168000000C15Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS7(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C15Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C15Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C15Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS8(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS8(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C600ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C600ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C600ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GHWPARAMS8 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C600ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GHWPARAMS8(block_id) (CVMX_ADD_IO_SEG(0x000168000000C600ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GHWPARAMS8(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C600ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C600ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C600ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GPMSTS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GPMSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C114ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C114ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C114ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GPMSTS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C114ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GPMSTS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C114ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GPMSTS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C114ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C114ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C114ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C138ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C138ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C138ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C138ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GPRTBIMAP(block_id) (CVMX_ADD_IO_SEG(0x000168000000C138ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C138ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C138ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C138ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C188ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C188ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C188ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_FS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C188ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C188ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_FS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C188ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C188ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C188ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C180ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C180ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C180ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GPRTBIMAP_HS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C180ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C180ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GPRTBIMAP_HS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C180ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C180ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C180ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GRLSID(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GRLSID(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C120ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C120ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C120ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GRLSID (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C120ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GRLSID(block_id) (CVMX_ADD_IO_SEG(0x000168000000C120ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GRLSID(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C120ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C120ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C120ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C61Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C61Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C61Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOPRIHST (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C61Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(block_id) (CVMX_ADD_IO_SEG(0x000168000000C61Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOPRIHST(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C61Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C61Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C61Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOSIZX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 2)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C380ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 2)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C380ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 2)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C380ull) + (((offset) & 3) + ((block_id) & 0) * 0x4000000000ull) * 4;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GRXFIFOSIZX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C380ull) + (((offset) & 3) + ((block_id) & 0) * 0x4000000000ull) * 4;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GRXFIFOSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C380ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4)
+static inline uint64_t CVMX_USBDRDX_UAHC_GRXFIFOSIZX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C380ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C380ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C380ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GRXTHRCFG(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GRXTHRCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C10Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C10Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C10Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GRXTHRCFG (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C10Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GRXTHRCFG(block_id) (CVMX_ADD_IO_SEG(0x000168000000C10Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GRXTHRCFG(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C10Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C10Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C10Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG0(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C100ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C100ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C100ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG0 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C100ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GSBUSCFG0(block_id) (CVMX_ADD_IO_SEG(0x000168000000C100ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG0(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C100ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C100ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C100ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG1(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C104ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C104ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C104ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GSBUSCFG1 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C104ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GSBUSCFG1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C104ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GSBUSCFG1(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C104ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C104ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C104ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GSTS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C118ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C118ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C118ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GSTS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C118ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GSTS(block_id) (CVMX_ADD_IO_SEG(0x000168000000C118ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GSTS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C118ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C118ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C118ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C610ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C610ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C610ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C610ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(block_id) (CVMX_ADD_IO_SEG(0x000168000000C610ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIDEV(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C610ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C610ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C610ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C618ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C618ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C618ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOPRIHST (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C618ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(block_id) (CVMX_ADD_IO_SEG(0x000168000000C618ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOPRIHST(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C618ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C618ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C618ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOSIZX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C300ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 3)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C300ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 3)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C300ull) + (((offset) & 3) + ((block_id) & 0) * 0x4000000000ull) * 4;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GTXFIFOSIZX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C300ull) + (((offset) & 3) + ((block_id) & 0) * 0x4000000000ull) * 4;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GTXFIFOSIZX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C300ull) + (((offset) & 3) + ((block_id) & 1) * 0x4000000000ull) * 4)
+static inline uint64_t CVMX_USBDRDX_UAHC_GTXFIFOSIZX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C300ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C300ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C300ull) + ((offset) + (block_id) * 0x4000000000ull) * 4;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GTXTHRCFG(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GTXTHRCFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C108ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C108ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C108ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GTXTHRCFG (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C108ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GTXTHRCFG(block_id) (CVMX_ADD_IO_SEG(0x000168000000C108ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GTXTHRCFG(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C108ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C108ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C108ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C12Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C12Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C12Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C12Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUCTL(block_id) (CVMX_ADD_IO_SEG(0x000168000000C12Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C12Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C12Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C12Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL1(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C11Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C11Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C11Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GUCTL1 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C11Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUCTL1(block_id) (CVMX_ADD_IO_SEG(0x000168000000C11Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUCTL1(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C11Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C11Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C11Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GUID(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUID(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C128ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000C128ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000C128ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GUID (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C128ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUID(block_id) (CVMX_ADD_IO_SEG(0x000168000000C128ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUID(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C128ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C128ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C128ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C240ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C240ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C240ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GUSB2I2CCTLX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C240ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C240ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2I2CCTLX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C240ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C240ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C240ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C200ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C200ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C200ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GUSB2PHYCFGX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C200ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C200ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUSB2PHYCFGX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C200ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C200ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C200ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000C2C0ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000C2C0ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000C2C0ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_GUSB3PIPECTLX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000C2C0ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000C2C0ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_GUSB3PIPECTLX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000C2C0ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000C2C0ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000C2C0ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_HCCPARAMS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_HCCPARAMS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000010ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000010ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000010ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_HCCPARAMS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000010ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_HCCPARAMS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000010ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_HCCPARAMS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000010ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000010ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000010ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS1(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000004ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000004ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000004ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS1 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000004ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_HCSPARAMS1(block_id) (CVMX_ADD_IO_SEG(0x0001680000000004ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS1(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000004ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000004ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000004ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS2(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000008ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000008ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000008ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS2 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000008ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_HCSPARAMS2(block_id) (CVMX_ADD_IO_SEG(0x0001680000000008ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS2(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000008ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000008ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000008ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS3(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000000Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000000Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000000Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_HCSPARAMS3 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000000Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_HCSPARAMS3(block_id) (CVMX_ADD_IO_SEG(0x000168000000000Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_HCSPARAMS3(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000000Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000000Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000000Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_IMANX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_IMANX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000460ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000460ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000460ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_IMANX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000460ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_IMANX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000460ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_IMANX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000460ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000460ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000460ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_IMODX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_IMODX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000464ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000464ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000464ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_IMODX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000464ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_IMODX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000464ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_IMODX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000464ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000464ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000464ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_MFINDEX(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_MFINDEX(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000440ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000440ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000440ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_MFINDEX (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000440ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_MFINDEX(block_id) (CVMX_ADD_IO_SEG(0x0001680000000440ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_MFINDEX(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000440ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000440ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000440ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PAGESIZE(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PAGESIZE(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000028ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000028ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000028ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_PAGESIZE (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000028ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_PAGESIZE(block_id) (CVMX_ADD_IO_SEG(0x0001680000000028ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_PAGESIZE(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000028ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000028ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000028ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_20X(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PORTHLPMC_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000042Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000042Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000042Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_PORTHLPMC_20X (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000042Cull) + ((block_id) & 0) * 0x10000000000ull;
+}
+#else
+static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_20X(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000042Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000042Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000042Cull) + (block_id) * 0x10000000000ull;
 }
-#else
-#define CVMX_USBDRDX_UAHC_PORTHLPMC_20X(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000042Cull) + ((block_id) & 1) * 0x10000000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000043Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x000168000000043Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 1)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x000169000000043Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_PORTHLPMC_SSX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000043Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(offset, block_id) (CVMX_ADD_IO_SEG(0x000168000000043Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_PORTHLPMC_SSX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000043Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000043Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000043Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_20X(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PORTLI_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000428ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000428ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000428ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_PORTLI_20X (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000428ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_PORTLI_20X(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000428ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_20X(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000428ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000428ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000428ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_SSX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PORTLI_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000438ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000438ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 1)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000438ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_PORTLI_SSX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000438ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_PORTLI_SSX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000438ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_PORTLI_SSX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000438ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000438ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000438ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_20X(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PORTPMSC_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000424ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000424ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000424ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_PORTPMSC_20X (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000424ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_PORTPMSC_20X(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000424ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_20X(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000424ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000424ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000424ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_SSX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PORTPMSC_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000434ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000434ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 1)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000434ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_PORTPMSC_SSX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000434ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_PORTPMSC_SSX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000434ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_PORTPMSC_SSX(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000434ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000434ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000434ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_PORTSCX(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_PORTSCX(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000420ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000000000ull) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001680000000420ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000000000ull) * 16;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 1)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001690000000420ull) + (((offset) & 1) + ((block_id) & 0) * 0x1000000000ull) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_PORTSCX (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000420ull) + (((offset) & 1) + ((block_id) & 0) * 0x1000000000ull) * 16;
 }
 #else
-#define CVMX_USBDRDX_UAHC_PORTSCX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001680000000420ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000000000ull) * 16)
+static inline uint64_t CVMX_USBDRDX_UAHC_PORTSCX(unsigned long offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000420ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000420ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000420ull) + ((offset) + (block_id) * 0x1000000000ull) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_RTSOFF(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_RTSOFF(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000018ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000018ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000018ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_RTSOFF (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000018ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_RTSOFF(block_id) (CVMX_ADD_IO_SEG(0x0001680000000018ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_RTSOFF(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000018ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000018ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000018ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000890ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000890ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000890ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW0 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000890ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(block_id) (CVMX_ADD_IO_SEG(0x0001680000000890ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW0(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000890ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000890ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000890ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000894ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000894ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000894ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW1 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000894ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(block_id) (CVMX_ADD_IO_SEG(0x0001680000000894ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW1(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000894ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000894ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000894ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000898ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000898ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000898ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW2 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000898ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(block_id) (CVMX_ADD_IO_SEG(0x0001680000000898ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW2(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000898ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000898ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000898ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x000168000000089Cull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x000168000000089Cull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x000169000000089Cull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT2_DW3 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x000169000000089Cull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(block_id) (CVMX_ADD_IO_SEG(0x000168000000089Cull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT2_DW3(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000168000000089Cull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x000169000000089Cull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x000169000000089Cull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016800000008A0ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x00016800000008A0ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x00016900000008A0ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW0 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00016900000008A0ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A0ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW0(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00016800000008A0ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00016900000008A0ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00016900000008A0ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016800000008A4ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x00016800000008A4ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x00016900000008A4ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW1 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00016900000008A4ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A4ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW1(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00016800000008A4ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00016900000008A4ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00016900000008A4ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016800000008A8ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x00016800000008A8ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x00016900000008A8ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW2 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00016900000008A8ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(block_id) (CVMX_ADD_IO_SEG(0x00016800000008A8ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW2(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00016800000008A8ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00016900000008A8ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00016900000008A8ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00016800000008ACull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x00016800000008ACull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x00016900000008ACull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_SUPTPRT3_DW3 (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00016900000008ACull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(block_id) (CVMX_ADD_IO_SEG(0x00016800000008ACull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_SUPTPRT3_DW3(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00016800000008ACull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00016900000008ACull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00016900000008ACull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_USBCMD(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_USBCMD(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000020ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000020ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000020ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_USBCMD (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000020ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_USBCMD(block_id) (CVMX_ADD_IO_SEG(0x0001680000000020ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_USBCMD(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000020ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000020ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000020ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGCTLSTS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGCTLSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000884ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000884ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000884ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGCTLSTS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000884ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_USBLEGCTLSTS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000884ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGCTLSTS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000884ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000884ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000884ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGSUP(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGSUP(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000880ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000880ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000880ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_USBLEGSUP (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000880ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_USBLEGSUP(block_id) (CVMX_ADD_IO_SEG(0x0001680000000880ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_USBLEGSUP(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000880ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000880ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000880ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UAHC_USBSTS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UAHC_USBSTS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001680000000024ull) + ((block_id) & 1) * 0x10000000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001680000000024ull) + ((block_id) & 1) * 0x10000000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001690000000024ull) + ((block_id) & 0) * 0x10000000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UAHC_USBSTS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001690000000024ull) + ((block_id) & 0) * 0x10000000000ull;
 }
 #else
-#define CVMX_USBDRDX_UAHC_USBSTS(block_id) (CVMX_ADD_IO_SEG(0x0001680000000024ull) + ((block_id) & 1) * 0x10000000000ull)
+static inline uint64_t CVMX_USBDRDX_UAHC_USBSTS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001680000000024ull) + (block_id) * 0x10000000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001690000000024ull) + (block_id) * 0x10000000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001690000000024ull) + (block_id) * 0x10000000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_BIST_STATUS(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_BIST_STATUS(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001180069000008ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_BIST_STATUS (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180069000008ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_BIST_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_BIST_STATUS(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180068000008ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180069000008ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180069000008ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_CTL(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_CTL(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001180069000000ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_CTL (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180069000000ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_CTL(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180068000000ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180069000000ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180069000000ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_ECC(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_ECC(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800680000F0ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800680000F0ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x00011800690000F0ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_ECC (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800690000F0ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_ECC(block_id) (CVMX_ADD_IO_SEG(0x00011800680000F0ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_ECC(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800680000F0ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800690000F0ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800690000F0ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_HOST_CFG(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_HOST_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800680000E0ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800680000E0ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x00011800690000E0ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_HOST_CFG (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800690000E0ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_HOST_CFG(block_id) (CVMX_ADD_IO_SEG(0x00011800680000E0ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_HOST_CFG(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800680000E0ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800690000E0ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800690000E0ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_INTSTAT(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_INTSTAT(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000030ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180068000030ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x0001180069000030ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_INTSTAT (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180069000030ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_INTSTAT(block_id) (CVMX_ADD_IO_SEG(0x0001180068000030ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_INTSTAT(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180068000030ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180069000030ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180069000030ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_HS(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CFG_HS(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000040ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001180068000040ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001180069000040ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CFG_HS (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180069000040ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_PORTX_CFG_HS(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180068000040ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_HS(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180068000040ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180069000040ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180069000040ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_SS(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CFG_SS(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000048ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001180068000048ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001180069000048ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CFG_SS (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180069000048ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_PORTX_CFG_SS(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180068000048ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CFG_SS(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180068000048ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180069000048ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180069000048ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000050ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001180068000050ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001180069000050ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180069000050ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180068000050ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_CFG(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180068000050ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180069000050ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180069000050ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(unsigned long offset, unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset == 0)) && ((block_id <= 1))))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180068000058ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x0001180068000058ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset == 0)) && ((block_id == 0)))
+				return CVMX_ADD_IO_SEG(0x0001180069000058ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS (%lu, %lu) not supported on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180069000058ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180068000058ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_PORTX_CR_DBG_STATUS(unsigned long __attribute__ ((unused)) offset, unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180068000058ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180069000058ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180069000058ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_SHIM_CFG(unsigned long block_id)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
-		cvmx_warn("CVMX_USBDRDX_UCTL_SHIM_CFG(%lu) is invalid on this chip\n", block_id);
-	return CVMX_ADD_IO_SEG(0x00011800680000E8ull) + ((block_id) & 1) * 0x1000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((block_id <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800680000E8ull) + ((block_id) & 1) * 0x1000000ull;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((block_id == 0))
+				return CVMX_ADD_IO_SEG(0x00011800690000E8ull) + ((block_id) & 0) * 0x1000000ull;
+			break;
+	}
+	cvmx_warn("CVMX_USBDRDX_UCTL_SHIM_CFG (block_id = %lu) not supported on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800690000E8ull) + ((block_id) & 0) * 0x1000000ull;
 }
 #else
-#define CVMX_USBDRDX_UCTL_SHIM_CFG(block_id) (CVMX_ADD_IO_SEG(0x00011800680000E8ull) + ((block_id) & 1) * 0x1000000ull)
+static inline uint64_t CVMX_USBDRDX_UCTL_SHIM_CFG(unsigned long block_id)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800680000E8ull) + (block_id) * 0x1000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800690000E8ull) + (block_id) * 0x1000000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800690000E8ull) + (block_id) * 0x1000000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_SPARE0(unsigned long block_id)
@@ -1208,6 +2976,17 @@ static inline uint64_t CVMX_USBDRDX_UCTL_SPARE0(unsigned long block_id)
 #define CVMX_USBDRDX_UCTL_SPARE0(block_id) (CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((block_id) & 1) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_USBDRDX_UCTL_SPARE0_ECO(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id == 0)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE0_ECO(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x0001180069000010ull);
+}
+#else
+#define CVMX_USBDRDX_UCTL_SPARE0_ECO(block_id) (CVMX_ADD_IO_SEG(0x0001180069000010ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1(unsigned long block_id)
 {
 	if (!(
@@ -1218,6 +2997,17 @@ static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1(unsigned long block_id)
 #else
 #define CVMX_USBDRDX_UCTL_SPARE1(block_id) (CVMX_ADD_IO_SEG(0x00011800680000F8ull) + ((block_id) & 1) * 0x1000000ull)
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1_ECO(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((block_id == 0)))))
+		cvmx_warn("CVMX_USBDRDX_UCTL_SPARE1_ECO(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800690000F8ull);
+}
+#else
+#define CVMX_USBDRDX_UCTL_SPARE1_ECO(block_id) (CVMX_ADD_IO_SEG(0x00011800690000F8ull))
+#endif
 
 /**
  * cvmx_usbdrd#_uahc_caplength
@@ -1240,6 +3030,7 @@ union cvmx_usbdrdx_uahc_caplength {
 	} s;
 	struct cvmx_usbdrdx_uahc_caplength_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_caplength_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_caplength_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_caplength cvmx_usbdrdx_uahc_caplength_t;
 
@@ -1266,6 +3057,7 @@ union cvmx_usbdrdx_uahc_config {
 	} s;
 	struct cvmx_usbdrdx_uahc_config_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_config_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_config_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_config cvmx_usbdrdx_uahc_config_t;
 
@@ -1300,6 +3092,7 @@ union cvmx_usbdrdx_uahc_crcr {
 	} s;
 	struct cvmx_usbdrdx_uahc_crcr_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_crcr_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_crcr_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_crcr cvmx_usbdrdx_uahc_crcr_t;
 
@@ -1343,6 +3136,7 @@ union cvmx_usbdrdx_uahc_dalepena {
 	} s;
 	struct cvmx_usbdrdx_uahc_dalepena_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_dalepena_s   cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dalepena_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dalepena cvmx_usbdrdx_uahc_dalepena_t;
 
@@ -1374,6 +3168,7 @@ union cvmx_usbdrdx_uahc_dbx {
 	} s;
 	struct cvmx_usbdrdx_uahc_dbx_s        cn70xx;
 	struct cvmx_usbdrdx_uahc_dbx_s        cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dbx_s        cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dbx cvmx_usbdrdx_uahc_dbx_t;
 
@@ -1396,6 +3191,7 @@ union cvmx_usbdrdx_uahc_dboff {
 	} s;
 	struct cvmx_usbdrdx_uahc_dboff_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_dboff_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dboff_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dboff cvmx_usbdrdx_uahc_dboff_t;
 
@@ -1422,6 +3218,7 @@ union cvmx_usbdrdx_uahc_dcbaap {
 	} s;
 	struct cvmx_usbdrdx_uahc_dcbaap_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_dcbaap_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dcbaap_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dcbaap cvmx_usbdrdx_uahc_dcbaap_t;
 
@@ -1498,6 +3295,7 @@ union cvmx_usbdrdx_uahc_dcfg {
 	} s;
 	struct cvmx_usbdrdx_uahc_dcfg_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dcfg_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dcfg_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dcfg cvmx_usbdrdx_uahc_dcfg_t;
 
@@ -1693,6 +3491,7 @@ union cvmx_usbdrdx_uahc_dctl {
 	} s;
 	struct cvmx_usbdrdx_uahc_dctl_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dctl_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dctl_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dctl cvmx_usbdrdx_uahc_dctl_t;
 
@@ -1847,6 +3646,7 @@ union cvmx_usbdrdx_uahc_depcmdx {
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdx_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_depcmdx_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdx cvmx_usbdrdx_uahc_depcmdx_t;
 
@@ -1873,6 +3673,7 @@ union cvmx_usbdrdx_uahc_depcmdpar0_x {
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar0_x cvmx_usbdrdx_uahc_depcmdpar0_x_t;
 
@@ -1899,6 +3700,7 @@ union cvmx_usbdrdx_uahc_depcmdpar1_x {
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar1_x cvmx_usbdrdx_uahc_depcmdpar1_x_t;
 
@@ -1925,6 +3727,7 @@ union cvmx_usbdrdx_uahc_depcmdpar2_x {
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar2_x cvmx_usbdrdx_uahc_depcmdpar2_x_t;
 
@@ -1974,6 +3777,7 @@ union cvmx_usbdrdx_uahc_devten {
 	} s;
 	struct cvmx_usbdrdx_uahc_devten_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_devten_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_devten_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_devten cvmx_usbdrdx_uahc_devten_t;
 
@@ -2025,6 +3829,7 @@ union cvmx_usbdrdx_uahc_dgcmd {
 	} s;
 	struct cvmx_usbdrdx_uahc_dgcmd_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_dgcmd_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dgcmd_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dgcmd cvmx_usbdrdx_uahc_dgcmd_t;
 
@@ -2054,6 +3859,7 @@ union cvmx_usbdrdx_uahc_dgcmdpar {
 	} s;
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dgcmdpar cvmx_usbdrdx_uahc_dgcmdpar_t;
 
@@ -2080,6 +3886,7 @@ union cvmx_usbdrdx_uahc_dnctrl {
 	} s;
 	struct cvmx_usbdrdx_uahc_dnctrl_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_dnctrl_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dnctrl_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dnctrl cvmx_usbdrdx_uahc_dnctrl_t;
 
@@ -2187,6 +3994,7 @@ union cvmx_usbdrdx_uahc_dsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_dsts_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_dsts_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_dsts_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_dsts cvmx_usbdrdx_uahc_dsts_t;
 
@@ -2215,6 +4023,7 @@ union cvmx_usbdrdx_uahc_erdpx {
 	} s;
 	struct cvmx_usbdrdx_uahc_erdpx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_erdpx_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_erdpx_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_erdpx cvmx_usbdrdx_uahc_erdpx_t;
 
@@ -2241,6 +4050,7 @@ union cvmx_usbdrdx_uahc_erstbax {
 	} s;
 	struct cvmx_usbdrdx_uahc_erstbax_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_erstbax_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_erstbax_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_erstbax cvmx_usbdrdx_uahc_erstbax_t;
 
@@ -2249,7 +4059,7 @@ typedef union cvmx_usbdrdx_uahc_erstbax cvmx_usbdrdx_uahc_erstbax_t;
  *
  * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.3.1.
  *
- * This register can be reset by IOI reset,
+ * This register can be reset by NCB reset,
  * or USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
@@ -2267,6 +4077,7 @@ union cvmx_usbdrdx_uahc_erstszx {
 	} s;
 	struct cvmx_usbdrdx_uahc_erstszx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_erstszx_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_erstszx_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
 
@@ -2281,8 +4092,7 @@ typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
  * outstanding transactions. Instead, it keeps track of the start address of the DMA transfer
  * associated with all active transactions. It is this address that is reported in
  * USBDRD()_UAHC_GBUSERRADDR when a bus error occurs. For example, if the host controller
- * initiates
- * a DMA
+ * initiates a DMA
  * transfer to write 1k of packet data starting at buffer address 0xABCD0000, and this DMA is
  * broken up into multiple 256B bursts on the AXI, then if a bus error occurs on any of these
  * associated AXI transfers, USBDRD()_UAHC_GBUSERRADDR reflects the DMA start address of
@@ -2306,6 +4116,7 @@ union cvmx_usbdrdx_uahc_gbuserraddr {
 	} s;
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gbuserraddr cvmx_usbdrdx_uahc_gbuserraddr_t;
 
@@ -2358,8 +4169,8 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          0x2 = Interval is 31.25 us.
                                                          0x3 = Interval is 15.625 us.
                                                          For full-speed mode, the scale-down value is multiplied by 8. */
-	uint32_t prtcapdir                    : 2;  /**< 0x1: for Host configurations.
-                                                         0x2: for Device configurations. */
+	uint32_t prtcapdir                    : 2;  /**< 0x1 = for Host configurations.
+                                                         0x2 = for Device configurations. */
 	uint32_t coresoftreset                : 1;  /**< Core soft reset: 1 = soft reset to core, 0 = no soft reset.
                                                          Clears the interrupts and all the USBDRD()_UAHC_* CSRs except the
                                                          following registers: USBDRD()_UAHC_GCTL, USBDRD()_UAHC_GUCTL, USBDRD()_UAHC_GSTS,
@@ -2463,6 +4274,7 @@ union cvmx_usbdrdx_uahc_gctl {
 	} s;
 	struct cvmx_usbdrdx_uahc_gctl_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_gctl_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gctl_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gctl cvmx_usbdrdx_uahc_gctl_t;
 
@@ -2490,6 +4302,7 @@ union cvmx_usbdrdx_uahc_gdbgbmu {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgbmu cvmx_usbdrdx_uahc_gdbgbmu_t;
 
@@ -2511,6 +4324,7 @@ union cvmx_usbdrdx_uahc_gdbgepinfo {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgepinfo cvmx_usbdrdx_uahc_gdbgepinfo_t;
 
@@ -2555,6 +4369,7 @@ union cvmx_usbdrdx_uahc_gdbgfifospace {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgfifospace cvmx_usbdrdx_uahc_gdbgfifospace_t;
 
@@ -2582,6 +4397,7 @@ union cvmx_usbdrdx_uahc_gdbglnmcc {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglnmcc cvmx_usbdrdx_uahc_gdbglnmcc_t;
 
@@ -2603,6 +4419,7 @@ union cvmx_usbdrdx_uahc_gdbglsp {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglsp cvmx_usbdrdx_uahc_gdbglsp_t;
 
@@ -2641,6 +4458,7 @@ union cvmx_usbdrdx_uahc_gdbglspmux {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglspmux cvmx_usbdrdx_uahc_gdbglspmux_t;
 
@@ -2699,6 +4517,7 @@ union cvmx_usbdrdx_uahc_gdbgltssm {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgltssm cvmx_usbdrdx_uahc_gdbgltssm_t;
 
@@ -2745,6 +4564,7 @@ union cvmx_usbdrdx_uahc_gdmahlratio {
 	} s;
 	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gdmahlratio cvmx_usbdrdx_uahc_gdmahlratio_t;
 
@@ -2777,6 +4597,7 @@ union cvmx_usbdrdx_uahc_gevntadrx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntadrx cvmx_usbdrdx_uahc_gevntadrx_t;
 
@@ -2818,6 +4639,7 @@ union cvmx_usbdrdx_uahc_gevntcountx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gevntcountx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gevntcountx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gevntcountx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntcountx cvmx_usbdrdx_uahc_gevntcountx_t;
 
@@ -2855,6 +4677,7 @@ union cvmx_usbdrdx_uahc_gevntsizx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gevntsizx_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gevntsizx_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gevntsizx_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gevntsizx cvmx_usbdrdx_uahc_gevntsizx_t;
 
@@ -2959,6 +4782,7 @@ union cvmx_usbdrdx_uahc_gfladj {
 	} s;
 	struct cvmx_usbdrdx_uahc_gfladj_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_gfladj_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gfladj_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gfladj cvmx_usbdrdx_uahc_gfladj_t;
 
@@ -2985,6 +4809,7 @@ union cvmx_usbdrdx_uahc_ggpio {
 	} s;
 	struct cvmx_usbdrdx_uahc_ggpio_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_ggpio_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ggpio_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ggpio cvmx_usbdrdx_uahc_ggpio_t;
 
@@ -3016,6 +4841,7 @@ union cvmx_usbdrdx_uahc_ghwparams0 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams0_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams0_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams0 cvmx_usbdrdx_uahc_ghwparams0_t;
 
@@ -3068,6 +4894,7 @@ union cvmx_usbdrdx_uahc_ghwparams1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams1_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams1_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams1 cvmx_usbdrdx_uahc_ghwparams1_t;
 
@@ -3089,6 +4916,7 @@ union cvmx_usbdrdx_uahc_ghwparams2 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams2_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams2_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams2 cvmx_usbdrdx_uahc_ghwparams2_t;
 
@@ -3130,6 +4958,7 @@ union cvmx_usbdrdx_uahc_ghwparams3 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams3_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams3_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams3 cvmx_usbdrdx_uahc_ghwparams3_t;
 
@@ -3167,6 +4996,7 @@ union cvmx_usbdrdx_uahc_ghwparams4 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams4_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams4_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams4_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams4 cvmx_usbdrdx_uahc_ghwparams4_t;
 
@@ -3198,6 +5028,7 @@ union cvmx_usbdrdx_uahc_ghwparams5 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams5_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams5_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams5_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams5 cvmx_usbdrdx_uahc_ghwparams5_t;
 
@@ -3239,6 +5070,7 @@ union cvmx_usbdrdx_uahc_ghwparams6 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams6_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams6_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams6_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams6 cvmx_usbdrdx_uahc_ghwparams6_t;
 
@@ -3262,13 +5094,14 @@ union cvmx_usbdrdx_uahc_ghwparams7 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams7_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams7_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams7_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams7 cvmx_usbdrdx_uahc_ghwparams7_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams8
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  *           See Synopsys DWC_usb3 Databook v2.20a, section 6.2.3.9.
  */
@@ -3283,6 +5116,7 @@ union cvmx_usbdrdx_uahc_ghwparams8 {
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams8_s cn70xx;
 	struct cvmx_usbdrdx_uahc_ghwparams8_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_ghwparams8_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams8 cvmx_usbdrdx_uahc_ghwparams8_t;
 
@@ -3334,6 +5168,7 @@ union cvmx_usbdrdx_uahc_gpmsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_gpmsts_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_gpmsts_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gpmsts_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gpmsts cvmx_usbdrdx_uahc_gpmsts_t;
 
@@ -3363,6 +5198,7 @@ union cvmx_usbdrdx_uahc_gprtbimap {
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap cvmx_usbdrdx_uahc_gprtbimap_t;
 
@@ -3392,6 +5228,7 @@ union cvmx_usbdrdx_uahc_gprtbimap_fs {
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap_fs cvmx_usbdrdx_uahc_gprtbimap_fs_t;
 
@@ -3421,6 +5258,7 @@ union cvmx_usbdrdx_uahc_gprtbimap_hs {
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap_hs cvmx_usbdrdx_uahc_gprtbimap_hs_t;
 
@@ -3437,15 +5275,16 @@ union cvmx_usbdrdx_uahc_grlsid {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t releaseid                    : 32; /**< Software can use this register to configure release-specific features in the driver.
                                                          INTERNAL: Synopsys ID
-                                                                 * SynopsysID[31:16] indicates Core Identification Number. 0x5533 is ASCII for U3
-                                                         (DWC_usb3).
-                                                                 * SynopsysID[15:0] indicates the release number. Current Release is 2.50a. */
+                                                          * SynopsysID[31:16] indicates Core Identification Number. 0x5533 is ASCII for
+                                                         U3 (DWC_usb3).
+                                                          * SynopsysID[15:0] indicates the release number. Current Release is 2.50a. */
 #else
 	uint32_t releaseid                    : 32;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_grlsid_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_grlsid_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_grlsid_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_grlsid cvmx_usbdrdx_uahc_grlsid_t;
 
@@ -3490,6 +5329,7 @@ union cvmx_usbdrdx_uahc_grxfifoprihst {
 	} s;
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn70xx;
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxfifoprihst cvmx_usbdrdx_uahc_grxfifoprihst_t;
 
@@ -3526,6 +5366,7 @@ union cvmx_usbdrdx_uahc_grxfifosizx {
 	} s;
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxfifosizx cvmx_usbdrdx_uahc_grxfifosizx_t;
 
@@ -3596,6 +5437,7 @@ union cvmx_usbdrdx_uahc_grxthrcfg {
 	} s;
 	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_grxthrcfg cvmx_usbdrdx_uahc_grxthrcfg_t;
 
@@ -3663,6 +5505,7 @@ union cvmx_usbdrdx_uahc_gsbuscfg0 {
 	} s;
 	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsbuscfg0 cvmx_usbdrdx_uahc_gsbuscfg0_t;
 
@@ -3708,6 +5551,7 @@ union cvmx_usbdrdx_uahc_gsbuscfg1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsbuscfg1 cvmx_usbdrdx_uahc_gsbuscfg1_t;
 
@@ -3748,6 +5592,7 @@ union cvmx_usbdrdx_uahc_gsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_gsts_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_gsts_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gsts_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gsts cvmx_usbdrdx_uahc_gsts_t;
 
@@ -3797,6 +5642,7 @@ union cvmx_usbdrdx_uahc_gtxfifopridev {
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifopridev cvmx_usbdrdx_uahc_gtxfifopridev_t;
 
@@ -3844,6 +5690,7 @@ union cvmx_usbdrdx_uahc_gtxfifoprihst {
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifoprihst cvmx_usbdrdx_uahc_gtxfifoprihst_t;
 
@@ -3881,6 +5728,7 @@ union cvmx_usbdrdx_uahc_gtxfifosizx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifosizx cvmx_usbdrdx_uahc_gtxfifosizx_t;
 
@@ -3932,32 +5780,142 @@ union cvmx_usbdrdx_uahc_gtxthrcfg {
                                                          OUT endpoints in the host mode. Valid values are from 0x1 to 0x10. */
 	uint32_t reserved_0_15                : 16;
 #else
-	uint32_t reserved_0_15                : 16;
-	uint32_t usbmaxtxburstsize            : 8;
-	uint32_t usbtxpktcnt                  : 4;
-	uint32_t reserved_28_28               : 1;
-	uint32_t usbtxpktcntsel               : 1;
-	uint32_t reserved_30_31               : 2;
+	uint32_t reserved_0_15                : 16;
+	uint32_t usbmaxtxburstsize            : 8;
+	uint32_t usbtxpktcnt                  : 4;
+	uint32_t reserved_28_28               : 1;
+	uint32_t usbtxpktcntsel               : 1;
+	uint32_t reserved_30_31               : 2;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn73xx;
+};
+typedef union cvmx_usbdrdx_uahc_gtxthrcfg cvmx_usbdrdx_uahc_gtxthrcfg_t;
+
+/**
+ * cvmx_usbdrd#_uahc_guctl
+ *
+ * This register provides a few options for the software to control the core behavior in the host
+ * mode. Most of the options are used to improve host inter-operability with different devices.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.11.
+ */
+union cvmx_usbdrdx_uahc_guctl {
+	uint32_t u32;
+	struct cvmx_usbdrdx_uahc_guctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t refclkper                    : 10; /**< Reference-clock period. Indicates (in terms of ns) the period of REF_CLK. The default
+                                                         value is set to 0x8
+                                                         (8 ns/125 MHz). This field must be updated during power on initialization if
+                                                         USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1 or USBDRD()_UAHC_GFLADJ [GFLADJ_REFCLK_LPM_SEL] = 1.
+                                                         The
+                                                         programmable maximum value 62 ns, and the minimum value is 8 ns. You use a reference clock
+                                                         with a period that is a integer multiple, so that ITP can meet the jitter margin of 32 ns.
+                                                         The allowable REF_CLK frequencies whose period is not integer multiples are
+                                                         16/17/19.2/24/39.7 MHz.
+                                                         This field should not be set to 0x0 at any time. If you do not plan to use this feature,
+                                                         then you need to set this field to 0x8, the default value. */
+	uint32_t noextrdl                     : 1;  /**< No extra delay between SOF and the first packet.
+                                                         Some high-speed devices misbehave when the host sends a packet immediately after an SOF.
+                                                         However, adding an extra delay between an SOF and the first packet can reduce the USB data
+                                                         rate and performance.
+                                                         This bit is used to control whether the host should wait for 2 us before it sends the
+                                                         first packet after a SOF, or not. You can set this bit to 1 to improve the performance if
+                                                         those problematic devices are not a concern in your host environment.
+                                                         0 = host waits for 2 us after an SOF before it sends the first USB packet.
+                                                         1 = host does not wait after an SOF before it sends the first USB packet. */
+	uint32_t psqextrressp                 : 3;  /**< PSQ extra reserved space. This is a debug feature, and is not intended for normal usage.
+                                                         This parameter specifies how much additional space in the PSQ (protocol-status queue) must
+                                                         be reserved before the U3PTL initiates a new USB transaction and burst beats. */
+	uint32_t sprsctrltransen              : 1;  /**< Sparse control transaction enable. Some devices are slow in responding to control
+                                                         transfers. Scheduling multiple transactions in one microframe/frame can cause these
+                                                         devices to misbehave. If this bit is set to 1, the host controller schedules transactions
+                                                         for a control transfer in different microframes/frames. */
+	uint32_t resbwhseps                   : 1;  /**< Reserving 85% bandwidth for high-speed periodic EPs. By default, host controller reserves
+                                                         80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85%
+                                                         to accommodate two high-speed, high-bandwidth ISOC EPs.
+                                                         USB 2.0 required 80% bandwidth allocated for ISOC traffic. If two high bandwidth ISOC
+                                                         devices (HD webcams) are connected, and if each requires 1024-bytes * 3 packets per
+                                                         microframe, then the bandwidth required is around 82%. If this bit is set to 1, it is
+                                                         possible to connect two webcams of 1024 bytes * 3 payload per microframe each. Otherwise,
+                                                         you may have to reduce the resolution of the webcams. */
+	uint32_t cmdevaddr                    : 1;  /**< Compliance mode for device address. When set to 1, slot ID can have different value than
+                                                         device address if max_slot_enabled < 128.
+                                                         0 = Device address is equal to slot ID.
+                                                         1 = Increment device address on each address device command.
+                                                         The xHCI compliance requires this bit to be set to 1. The 0 mode is for debug purpose
+                                                         only. This allows you to easily identify a device connected to a port in the Lecroy or
+                                                         Eliisys trace during hardware debug.
+                                                         This bit is used in host mode only. */
+	uint32_t reserved_14_14               : 1;
+	uint32_t enoverlapchk                 : 1;  /**< Enable check for LFPS overlap during remote Ux Exit. If this bit is set to:
+                                                         0 = When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS
+                                                         overlap.
+                                                         1 = The SuperSpeed link, when exiting U1/U2/U3, waits for either the remote link LFPS or
+                                                         TS1/TS2 training symbols before it confirms that the LFPS handshake is complete. This is
+                                                         done to handle the case where the LFPS glitch causes the link to start exiting from the
+                                                         low power state. Looking for the LFPS overlap makes sure that the link partner also sees
+                                                         the LFPS. */
+	uint32_t extcapsupten                 : 1;  /**< External extended capability support enable. If disabled, a read
+                                                         USBDRD()_UAHC_SUPTPRT3_DW0
+                                                         [NEXTCAPPTR] returns 0 in the next capability pointer field. This indicates there are no
+                                                         more capabilities. If enabled, a read to USBDRD()_UAHC_SUPTPRT3_DW0[NEXTCAPPTR] returns 4
+                                                         in
+                                                         the
+                                                         next capability pointer field.
+                                                         Always set to 0x0. */
+	uint32_t insrtextrfsbodi              : 1;  /**< Insert extra delay between full-speed bulk OUT transactions. Some full-speed devices are
+                                                         slow to receive bulk OUT data and can get stuck when there are consecutive bulk OUT
+                                                         transactions with short inter-transaction delays. This bit is used to control whether the
+                                                         host inserts extra delay between consecutive bulk OUT transactions to a full-speed
+                                                         endpoint.
+                                                         0 = Host does not insert extra delay.
+                                                         Setting this bit to 1 reduces the bulk OUT transfer performance for most of the full-speed
+                                                         devices.
+                                                         1 = Host inserts about 12 us extra delay between consecutive bulk OUT transactions to an
+                                                         full-speed endpoint to work around the device issue. */
+	uint32_t dtct                         : 2;  /**< Device timeout coarse tuning. This field determines how long the host waits for a response
+                                                         from device before considering a timeout.
+                                                         The core first checks the DTCT value. If it is 0, then the timeout value is defined by the
+                                                         DTFT. If it is non-zero, then it uses the following timeout values:
+                                                         0x0 = 0 us; use DTFT value instead.
+                                                         0x1 = 500 us.
+                                                         0x2 = 1.5 ms.
+                                                         0x3 = 6.5 ms. */
+	uint32_t dtft                         : 9;  /**< Device timeout fine tuning. This field determines how long the host waits for a response
+                                                         from a device before considering a timeout. For DTFT to take effect, DTCT must be set to
+                                                         0x0.
+                                                         The DTFT value specifies the number of 125MHz clock cycles * 256 to count before
+                                                         considering a device timeout. For the 125 MHz clock cycles (8 ns period), this is
+                                                         calculated as follows:
+                                                         _ [DTFT value] * 256 * 8 (ns)
+                                                         0x2 = 2 * 256 * 8 -> 4 us.
+                                                         0x5 = 5 * 256 * 8 -> 10 us.
+                                                         0xA = 10 * 256 * 8 -> 20 us.
+                                                         0x10 = 16 * 256 * 8 -> 32 us.
+                                                         0x19 = 25 * 256 * 8 -> 51 us.
+                                                         0x31 = 49 * 256 * 8 -> 100 us.
+                                                         0x62 = 98 * 256 * 8 -> 200 us. */
+#else
+	uint32_t dtft                         : 9;
+	uint32_t dtct                         : 2;
+	uint32_t insrtextrfsbodi              : 1;
+	uint32_t extcapsupten                 : 1;
+	uint32_t enoverlapchk                 : 1;
+	uint32_t reserved_14_14               : 1;
+	uint32_t cmdevaddr                    : 1;
+	uint32_t resbwhseps                   : 1;
+	uint32_t sprsctrltransen              : 1;
+	uint32_t psqextrressp                 : 3;
+	uint32_t noextrdl                     : 1;
+	uint32_t refclkper                    : 10;
 #endif
 	} s;
-	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xx;
-	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xxp1;
-};
-typedef union cvmx_usbdrdx_uahc_gtxthrcfg cvmx_usbdrdx_uahc_gtxthrcfg_t;
-
-/**
- * cvmx_usbdrd#_uahc_guctl
- *
- * This register provides a few options for the software to control the core behavior in the host
- * mode. Most of the options are used to improve host inter-operability with different devices.
- *
- * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.11.
- */
-union cvmx_usbdrdx_uahc_guctl {
-	uint32_t u32;
-	struct cvmx_usbdrdx_uahc_guctl_s {
+	struct cvmx_usbdrdx_uahc_guctl_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t refclkper                    : 10; /**< Reference-clock period. Indicates (in terms of ns) the period of REF_CLK. The default
                                                          value is set to 0x8
@@ -4070,9 +6028,122 @@ union cvmx_usbdrdx_uahc_guctl {
 	uint32_t noextrdl                     : 1;
 	uint32_t refclkper                    : 10;
 #endif
-	} s;
-	struct cvmx_usbdrdx_uahc_guctl_s      cn70xx;
-	struct cvmx_usbdrdx_uahc_guctl_s      cn70xxp1;
+	} cn70xx;
+	struct cvmx_usbdrdx_uahc_guctl_cn70xx cn70xxp1;
+	struct cvmx_usbdrdx_uahc_guctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t refclkper                    : 10; /**< Reference-clock period. Indicates (in terms of ns) the period of REF_CLK. The default
+                                                         value is set to 0x8
+                                                         (8 ns/125 MHz). This field must be updated during power on initialization if
+                                                         USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1 or USBDRD()_UAHC_GFLADJ [GFLADJ_REFCLK_LPM_SEL] = 1.
+                                                         The
+                                                         programmable maximum value 62 ns, and the minimum value is 8 ns. You use a reference clock
+                                                         with a period that is a integer multiple, so that ITP can meet the jitter margin of 32 ns.
+                                                         The allowable REF_CLK frequencies whose period is not integer multiples are
+                                                         16/17/19.2/24/39.7 MHz.
+                                                         This field should not be set to 0x0 at any time. If you do not plan to use this feature,
+                                                         then you need to set this field to 0x8, the default value. */
+	uint32_t noextrdl                     : 1;  /**< No extra delay between SOF and the first packet.
+                                                         Some high-speed devices misbehave when the host sends a packet immediately after an SOF.
+                                                         However, adding an extra delay between an SOF and the first packet can reduce the USB data
+                                                         rate and performance.
+                                                         This bit is used to control whether the host should wait for 2 us before it sends the
+                                                         first packet after a SOF, or not. You can set this bit to 1 to improve the performance if
+                                                         those problematic devices are not a concern in your host environment.
+                                                         0 = host waits for 2 us after an SOF before it sends the first USB packet.
+                                                         1 = host does not wait after an SOF before it sends the first USB packet. */
+	uint32_t psqextrressp                 : 3;  /**< PSQ extra reserved space. This is a debug feature, and is not intended for normal usage.
+                                                         This parameter specifies how much additional space in the PSQ (protocol-status queue) must
+                                                         be reserved before the U3PTL initiates a new USB transaction and burst beats. */
+	uint32_t sprsctrltransen              : 1;  /**< Sparse control transaction enable. Some devices are slow in responding to control
+                                                         transfers. Scheduling multiple transactions in one microframe/frame can cause these
+                                                         devices to misbehave. If this bit is set to 1, the host controller schedules transactions
+                                                         for a control transfer in different microframes/frames. */
+	uint32_t resbwhseps                   : 1;  /**< Reserving 85% bandwidth for high-speed periodic EPs. By default, host controller reserves
+                                                         80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85%
+                                                         to accommodate two high-speed, high-bandwidth ISOC EPs.
+                                                         USB 2.0 required 80% bandwidth allocated for ISOC traffic. If two high bandwidth ISOC
+                                                         devices (HD webcams) are connected, and if each requires 1024-bytes * 3 packets per
+                                                         microframe, then the bandwidth required is around 82%. If this bit is set to 1, it is
+                                                         possible to connect two webcams of 1024 bytes * 3 payload per microframe each. Otherwise,
+                                                         you may have to reduce the resolution of the webcams. */
+	uint32_t cmdevaddr                    : 1;  /**< Compliance mode for device address. When set to 1, slot ID can have different value than
+                                                         device address if max_slot_enabled < 128.
+                                                         0 = Device address is equal to slot ID.
+                                                         1 = Increment device address on each address device command.
+                                                         The xHCI compliance requires this bit to be set to 1. The 0 mode is for debug purpose
+                                                         only. This allows you to easily identify a device connected to a port in the Lecroy or
+                                                         Eliisys trace during hardware debug.
+                                                         This bit is used in host mode only. */
+	uint32_t usbdrdstinautoretryen        : 1;  /**< Host IN auto-retry enable. When set, this field enables the auto-retry feature. For IN
+                                                         transfers (non-isochronous) that encounter data packets with CRC errors or internal
+                                                         overrun scenarios, the auto-retry feature causes the host core to reply to the device with
+                                                         a non-terminating retry ACK (i.e. an ACK transaction packet with Retry = 1 and NumP != 0).
+                                                         If the auto-retry feature is disabled (default), the core responds with a terminating
+                                                         retry ACK (i.e. an ACK transaction packet with Retry = 1 and NumP = 0). */
+	uint32_t enoverlapchk                 : 1;  /**< Enable check for LFPS overlap during remote Ux Exit. If this bit is set to:
+                                                         0 = When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS
+                                                         overlap.
+                                                         1 = The SuperSpeed link, when exiting U1/U2/U3, waits for either the remote link LFPS or
+                                                         TS1/TS2 training symbols before it confirms that the LFPS handshake is complete. This is
+                                                         done to handle the case where the LFPS glitch causes the link to start exiting from the
+                                                         low power state. Looking for the LFPS overlap makes sure that the link partner also sees
+                                                         the LFPS. */
+	uint32_t extcapsupten                 : 1;  /**< External extended capability support enable. If disabled, a read
+                                                         USBDRD()_UAHC_SUPTPRT3_DW0
+                                                         [NEXTCAPPTR] returns 0 in the next capability pointer field. This indicates there are no
+                                                         more capabilities. If enabled, a read to USBDRD()_UAHC_SUPTPRT3_DW0[NEXTCAPPTR] returns 4
+                                                         in
+                                                         the
+                                                         next capability pointer field.
+                                                         Always set to 0x0. */
+	uint32_t insrtextrfsbodi              : 1;  /**< Insert extra delay between full-speed bulk OUT transactions. Some full-speed devices are
+                                                         slow to receive bulk OUT data and can get stuck when there are consecutive bulk OUT
+                                                         transactions with short inter-transaction delays. This bit is used to control whether the
+                                                         host inserts extra delay between consecutive bulk OUT transactions to a full-speed
+                                                         endpoint.
+                                                         0 = Host does not insert extra delay.
+                                                         Setting this bit to 1 reduces the bulk OUT transfer performance for most of the full-speed
+                                                         devices.
+                                                         1 = Host inserts about 12 us extra delay between consecutive bulk OUT transactions to an
+                                                         full-speed endpoint to work around the device issue. */
+	uint32_t dtct                         : 2;  /**< Device timeout coarse tuning. This field determines how long the host waits for a response
+                                                         from device before considering a timeout.
+                                                         The core first checks the DTCT value. If it is 0, then the timeout value is defined by the
+                                                         DTFT. If it is non-zero, then it uses the following timeout values:
+                                                         0x0 = 0 us; use DTFT value instead.
+                                                         0x1 = 500 us.
+                                                         0x2 = 1.5 ms.
+                                                         0x3 = 6.5 ms. */
+	uint32_t dtft                         : 9;  /**< Device timeout fine tuning. This field determines how long the host waits for a response
+                                                         from a device before considering a timeout. For DTFT to take effect, DTCT must be set to
+                                                         0x0.
+                                                         The DTFT value specifies the number of 125MHz clock cycles * 256 to count before
+                                                         considering a device timeout. For the 125 MHz clock cycles (8 ns period), this is
+                                                         calculated as follows:
+                                                         _ [DTFT value] * 256 * 8 (ns)
+                                                         0x2 = 2 * 256 * 8 -> 4 us.
+                                                         0x5 = 5 * 256 * 8 -> 10 us.
+                                                         0xA = 10 * 256 * 8 -> 20 us.
+                                                         0x10 = 16 * 256 * 8 -> 32 us.
+                                                         0x19 = 25 * 256 * 8 -> 51 us.
+                                                         0x31 = 49 * 256 * 8 -> 100 us.
+                                                         0x62 = 98 * 256 * 8 -> 200 us. */
+#else
+	uint32_t dtft                         : 9;
+	uint32_t dtct                         : 2;
+	uint32_t insrtextrfsbodi              : 1;
+	uint32_t extcapsupten                 : 1;
+	uint32_t enoverlapchk                 : 1;
+	uint32_t usbdrdstinautoretryen        : 1;
+	uint32_t cmdevaddr                    : 1;
+	uint32_t resbwhseps                   : 1;
+	uint32_t sprsctrltransen              : 1;
+	uint32_t psqextrressp                 : 3;
+	uint32_t noextrdl                     : 1;
+	uint32_t refclkper                    : 10;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_guctl cvmx_usbdrdx_uahc_guctl_t;
 
@@ -4101,6 +6172,7 @@ union cvmx_usbdrdx_uahc_guctl1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_guctl1_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_guctl1_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_guctl1_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_guctl1 cvmx_usbdrdx_uahc_guctl1_t;
 
@@ -4129,6 +6201,7 @@ union cvmx_usbdrdx_uahc_guid {
 	} s;
 	struct cvmx_usbdrdx_uahc_guid_s       cn70xx;
 	struct cvmx_usbdrdx_uahc_guid_s       cn70xxp1;
+	struct cvmx_usbdrdx_uahc_guid_s       cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_guid cvmx_usbdrdx_uahc_guid_t;
 
@@ -4152,6 +6225,7 @@ union cvmx_usbdrdx_uahc_gusb2i2cctlx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb2i2cctlx cvmx_usbdrdx_uahc_gusb2i2cctlx_t;
 
@@ -4261,6 +6335,7 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb2phycfgx cvmx_usbdrdx_uahc_gusb2phycfgx_t;
 
@@ -4435,6 +6510,7 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_gusb3pipectlx cvmx_usbdrdx_uahc_gusb3pipectlx_t;
 
@@ -4477,6 +6553,7 @@ union cvmx_usbdrdx_uahc_hccparams {
 	} s;
 	struct cvmx_usbdrdx_uahc_hccparams_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_hccparams_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_hccparams_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_hccparams cvmx_usbdrdx_uahc_hccparams_t;
 
@@ -4503,6 +6580,7 @@ union cvmx_usbdrdx_uahc_hcsparams1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams1_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_hcsparams1_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams1 cvmx_usbdrdx_uahc_hcsparams1_t;
 
@@ -4533,6 +6611,7 @@ union cvmx_usbdrdx_uahc_hcsparams2 {
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams2_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_hcsparams2_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams2 cvmx_usbdrdx_uahc_hcsparams2_t;
 
@@ -4557,6 +6636,7 @@ union cvmx_usbdrdx_uahc_hcsparams3 {
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_hcsparams3_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_hcsparams3_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams3 cvmx_usbdrdx_uahc_hcsparams3_t;
 
@@ -4585,6 +6665,7 @@ union cvmx_usbdrdx_uahc_imanx {
 	} s;
 	struct cvmx_usbdrdx_uahc_imanx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_imanx_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_imanx_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_imanx cvmx_usbdrdx_uahc_imanx_t;
 
@@ -4611,6 +6692,7 @@ union cvmx_usbdrdx_uahc_imodx {
 	} s;
 	struct cvmx_usbdrdx_uahc_imodx_s      cn70xx;
 	struct cvmx_usbdrdx_uahc_imodx_s      cn70xxp1;
+	struct cvmx_usbdrdx_uahc_imodx_s      cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_imodx cvmx_usbdrdx_uahc_imodx_t;
 
@@ -4637,6 +6719,7 @@ union cvmx_usbdrdx_uahc_mfindex {
 	} s;
 	struct cvmx_usbdrdx_uahc_mfindex_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_mfindex_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_mfindex_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_mfindex cvmx_usbdrdx_uahc_mfindex_t;
 
@@ -4659,6 +6742,7 @@ union cvmx_usbdrdx_uahc_pagesize {
 	} s;
 	struct cvmx_usbdrdx_uahc_pagesize_s   cn70xx;
 	struct cvmx_usbdrdx_uahc_pagesize_s   cn70xxp1;
+	struct cvmx_usbdrdx_uahc_pagesize_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_pagesize cvmx_usbdrdx_uahc_pagesize_t;
 
@@ -4700,6 +6784,7 @@ union cvmx_usbdrdx_uahc_porthlpmc_20x {
 	} s;
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_porthlpmc_20x cvmx_usbdrdx_uahc_porthlpmc_20x_t;
 
@@ -4725,6 +6810,7 @@ union cvmx_usbdrdx_uahc_porthlpmc_ssx {
 	} s;
 	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_porthlpmc_ssx cvmx_usbdrdx_uahc_porthlpmc_ssx_t;
 
@@ -4745,6 +6831,7 @@ union cvmx_usbdrdx_uahc_portli_20x {
 	} s;
 	struct cvmx_usbdrdx_uahc_portli_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portli_20x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portli_20x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portli_20x cvmx_usbdrdx_uahc_portli_20x_t;
 
@@ -4767,6 +6854,7 @@ union cvmx_usbdrdx_uahc_portli_ssx {
 	} s;
 	struct cvmx_usbdrdx_uahc_portli_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portli_ssx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portli_ssx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portli_ssx cvmx_usbdrdx_uahc_portli_ssx_t;
 
@@ -4803,6 +6891,7 @@ union cvmx_usbdrdx_uahc_portpmsc_20x {
 	} s;
 	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portpmsc_20x cvmx_usbdrdx_uahc_portpmsc_20x_t;
 
@@ -4833,6 +6922,7 @@ union cvmx_usbdrdx_uahc_portpmsc_ssx {
 	} s;
 	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn70xx;
 	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portpmsc_ssx cvmx_usbdrdx_uahc_portpmsc_ssx_t;
 
@@ -4904,6 +6994,7 @@ union cvmx_usbdrdx_uahc_portscx {
 	} s;
 	struct cvmx_usbdrdx_uahc_portscx_s    cn70xx;
 	struct cvmx_usbdrdx_uahc_portscx_s    cn70xxp1;
+	struct cvmx_usbdrdx_uahc_portscx_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_portscx cvmx_usbdrdx_uahc_portscx_t;
 
@@ -4926,6 +7017,7 @@ union cvmx_usbdrdx_uahc_rtsoff {
 	} s;
 	struct cvmx_usbdrdx_uahc_rtsoff_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_rtsoff_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_rtsoff_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_rtsoff cvmx_usbdrdx_uahc_rtsoff_t;
 
@@ -4952,6 +7044,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw0 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw0 cvmx_usbdrdx_uahc_suptprt2_dw0_t;
 
@@ -4972,6 +7065,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw1 cvmx_usbdrdx_uahc_suptprt2_dw1_t;
 
@@ -5008,6 +7102,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw2 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw2 cvmx_usbdrdx_uahc_suptprt2_dw2_t;
 
@@ -5030,6 +7125,7 @@ union cvmx_usbdrdx_uahc_suptprt2_dw3 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw3 cvmx_usbdrdx_uahc_suptprt2_dw3_t;
 
@@ -5059,6 +7155,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw0 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw0 cvmx_usbdrdx_uahc_suptprt3_dw0_t;
 
@@ -5079,6 +7176,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw1 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw1 cvmx_usbdrdx_uahc_suptprt3_dw1_t;
 
@@ -5105,6 +7203,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw2 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw2 cvmx_usbdrdx_uahc_suptprt3_dw2_t;
 
@@ -5127,6 +7226,7 @@ union cvmx_usbdrdx_uahc_suptprt3_dw3 {
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn70xx;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw3 cvmx_usbdrdx_uahc_suptprt3_dw3_t;
 
@@ -5171,6 +7271,7 @@ union cvmx_usbdrdx_uahc_usbcmd {
 	} s;
 	struct cvmx_usbdrdx_uahc_usbcmd_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_usbcmd_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_usbcmd_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_usbcmd cvmx_usbdrdx_uahc_usbcmd_t;
 
@@ -5230,6 +7331,7 @@ union cvmx_usbdrdx_uahc_usblegctlsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn70xx;
 	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn70xxp1;
+	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_usblegctlsts cvmx_usbdrdx_uahc_usblegctlsts_t;
 
@@ -5264,6 +7366,7 @@ union cvmx_usbdrdx_uahc_usblegsup {
 	} s;
 	struct cvmx_usbdrdx_uahc_usblegsup_s  cn70xx;
 	struct cvmx_usbdrdx_uahc_usblegsup_s  cn70xxp1;
+	struct cvmx_usbdrdx_uahc_usblegsup_s  cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_usblegsup cvmx_usbdrdx_uahc_usblegsup_t;
 
@@ -5310,13 +7413,15 @@ union cvmx_usbdrdx_uahc_usbsts {
 	} s;
 	struct cvmx_usbdrdx_uahc_usbsts_s     cn70xx;
 	struct cvmx_usbdrdx_uahc_usbsts_s     cn70xxp1;
+	struct cvmx_usbdrdx_uahc_usbsts_s     cn73xx;
 };
 typedef union cvmx_usbdrdx_uahc_usbsts cvmx_usbdrdx_uahc_usbsts_t;
 
 /**
  * cvmx_usbdrd#_uctl_bist_status
  *
- * This register indicates the results from the built-in self-test (BIST) runs of USBH memories.
+ * This register indicates the results from the built-in self-test (BIST) runs of USBDRD
+ * memories.
  * A 0 indicates pass or never run, a 1 indicates fail. This register can be reset by IOI reset.
  */
 union cvmx_usbdrdx_uctl_bist_status {
@@ -5356,6 +7461,7 @@ union cvmx_usbdrdx_uctl_bist_status {
 	} s;
 	struct cvmx_usbdrdx_uctl_bist_status_s cn70xx;
 	struct cvmx_usbdrdx_uctl_bist_status_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_bist_status_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_bist_status cvmx_usbdrdx_uctl_bist_status_t;
 
@@ -5370,7 +7476,8 @@ union cvmx_usbdrdx_uctl_ctl {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uctl_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t clear_bist                   : 1;  /**< BIST fast-clear mode select. A BIST run with this bit set clears all entries in USBH RAMs
+	uint64_t clear_bist                   : 1;  /**< BIST fast-clear mode select. A BIST run with this bit set clears all entries in USBDRD
+                                                         RAMs
                                                          to 0x0.
                                                          There are two major modes of BIST: full and clear. Full BIST is run by the BIST state
                                                          machine when CLEAR_BIST is deasserted during BIST. Clear BIST is run if CLEAR_BIST is
@@ -5537,7 +7644,8 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          being reset.
                                                          This also resets the suspend-clock divider. */
 	uint64_t reserved_27_27               : 1;
-	uint64_t h_clkdiv_sel                 : 3;  /**< The hclk frequency is sclk frequency divided by H_CLKDIV_SEL.
+	uint64_t h_clkdiv_sel                 : 3;  /**< Controller clock-frequency-divider select. The controller-clock frequency is the
+                                                         coprocessor-clock frequency divided by H_CLKDIV_SEL and must be at or below 300 MHz.
                                                          The divider values are the following:
                                                          0x0 = divide by 1.
                                                          0x1 = divide by 2.
@@ -5604,14 +7712,14 @@ union cvmx_usbdrdx_uctl_ctl {
 	uint64_t uphy_rst                     : 1;  /**< PHY reset; resets UPHY; active-high. */
 	uint64_t uahc_rst                     : 1;  /**< Software reset; resets UAHC; active-high.
                                                          INTERNAL: Note that soft-resetting the UAHC while it is active may cause violations of RSL
-                                                         or IOI protocols. */
+                                                         or NCB protocols. */
 	uint64_t uctl_rst                     : 1;  /**< Software reset; resets UCTL; active-high.
                                                          Resets UAHC DMA and register shims. Resets UCTL RSL registers 0x30-0xF8.
                                                          Does not reset UCTL RSL registers 0x0-0x28.
                                                          UCTL RSL registers starting from 0x30 can be accessed only after the controller clock is
                                                          active and UCTL_RST is deasserted.
                                                          INTERNAL: Note that soft-resetting the UCTL while it is active may cause violations of
-                                                         RSL, IOI, and CIB protocols. */
+                                                         RSL, NCB, and CIB protocols. */
 #else
 	uint64_t uctl_rst                     : 1;
 	uint64_t uahc_rst                     : 1;
@@ -5650,13 +7758,13 @@ union cvmx_usbdrdx_uctl_ctl {
 	} s;
 	struct cvmx_usbdrdx_uctl_ctl_s        cn70xx;
 	struct cvmx_usbdrdx_uctl_ctl_s        cn70xxp1;
+	struct cvmx_usbdrdx_uctl_ctl_s        cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_ctl cvmx_usbdrdx_uctl_ctl_t;
 
 /**
  * cvmx_usbdrd#_uctl_ecc
  *
- * Accessible by: only when H_CLKDIV_EN.
  * This register can be used to disable ECC correction, insert ECC errors, and debug ECC
  * failures.
  * * The ECC_ERR* fields are captured when there are no outstanding ECC errors indicated in
@@ -5673,6 +7781,8 @@ typedef union cvmx_usbdrdx_uctl_ctl cvmx_usbdrdx_uctl_ctl_t;
  * 0x2 = SBE on bit[1].
  * 0x3 = DBE on bit[1:0].
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_ecc {
@@ -5683,6 +7793,43 @@ union cvmx_usbdrdx_uctl_ecc {
 	uint64_t ecc_err_source               : 4;  /**< Source of ECC error, see USBDRD_UCTL_ECC_ERR_SOURCE_E. */
 	uint64_t ecc_err_syndrome             : 8;  /**< Syndrome bits of the ECC error. */
 	uint64_t ecc_err_address              : 16; /**< RAM address of the ECC error. */
+	uint64_t reserved_21_31               : 11;
+	uint64_t uctl_xm_r_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uctl_xm_r_ecc_cor_dis        : 1;  /**< Enables ECC correction on UCTL AxiMaster read-data FIFO. */
+	uint64_t uctl_xm_w_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uctl_xm_w_ecc_cor_dis        : 1;  /**< Enables ECC correction on UCTL AxiMaster write-data FIFO. */
+	uint64_t reserved_9_14                : 6;
+	uint64_t uahc_ram2_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram2_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC RxFIFO RAMs (RAM2). */
+	uint64_t uahc_ram1_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram1_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC TxFIFO RAMs (RAM1). */
+	uint64_t uahc_ram0_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
+	uint64_t uahc_ram0_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC Desc/Reg cache (RAM0). */
+#else
+	uint64_t uahc_ram0_ecc_cor_dis        : 1;
+	uint64_t uahc_ram0_ecc_flip_synd      : 2;
+	uint64_t uahc_ram1_ecc_cor_dis        : 1;
+	uint64_t uahc_ram1_ecc_flip_synd      : 2;
+	uint64_t uahc_ram2_ecc_cor_dis        : 1;
+	uint64_t uahc_ram2_ecc_flip_synd      : 2;
+	uint64_t reserved_9_14                : 6;
+	uint64_t uctl_xm_w_ecc_cor_dis        : 1;
+	uint64_t uctl_xm_w_ecc_flip_synd      : 2;
+	uint64_t uctl_xm_r_ecc_cor_dis        : 1;
+	uint64_t uctl_xm_r_ecc_flip_synd      : 2;
+	uint64_t reserved_21_31               : 11;
+	uint64_t ecc_err_address              : 16;
+	uint64_t ecc_err_syndrome             : 8;
+	uint64_t ecc_err_source               : 4;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_ecc_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t ecc_err_source               : 4;  /**< Source of ECC error, see USBDRD_UCTL_ECC_ERR_SOURCE_E. */
+	uint64_t ecc_err_syndrome             : 8;  /**< Syndrome bits of the ECC error. */
+	uint64_t ecc_err_address              : 16; /**< RAM address of the ECC error. */
 	uint64_t reserved_9_31                : 23;
 	uint64_t uahc_ram2_ecc_flip_synd      : 2;  /**< Insert ECC error for testing purposes. */
 	uint64_t uahc_ram2_ecc_cor_dis        : 1;  /**< Enables ECC correction on UAHC RxFIFO RAMs (RAM2). */
@@ -5703,20 +7850,20 @@ union cvmx_usbdrdx_uctl_ecc {
 	uint64_t ecc_err_source               : 4;
 	uint64_t reserved_60_63               : 4;
 #endif
-	} s;
-	struct cvmx_usbdrdx_uctl_ecc_s        cn70xx;
-	struct cvmx_usbdrdx_uctl_ecc_s        cn70xxp1;
+	} cn70xx;
+	struct cvmx_usbdrdx_uctl_ecc_cn70xx   cn70xxp1;
+	struct cvmx_usbdrdx_uctl_ecc_s        cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_ecc cvmx_usbdrdx_uctl_ecc_t;
 
 /**
  * cvmx_usbdrd#_uctl_host_cfg
  *
- * Accessible by: only when H_CLKDIV_EN.
- *
  * This register allows configuration of various host controller (UAHC) features. Most of these
  * are strap signals and should be modified only while the controller is not running.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_host_cfg {
@@ -5785,6 +7932,7 @@ union cvmx_usbdrdx_uctl_host_cfg {
 	} s;
 	struct cvmx_usbdrdx_uctl_host_cfg_s   cn70xx;
 	struct cvmx_usbdrdx_uctl_host_cfg_s   cn70xxp1;
+	struct cvmx_usbdrdx_uctl_host_cfg_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_host_cfg cvmx_usbdrdx_uctl_host_cfg_t;
 
@@ -5801,6 +7949,52 @@ union cvmx_usbdrdx_uctl_intstat {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uctl_intstat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_30_63               : 34;
+	uint64_t xm_r_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_r_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_w_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t xm_w_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t reserved_22_25               : 4;
+	uint64_t ram2_dbe                     : 1;  /**< Detected double-bit error on the UAHC RxFIFO RAMs (RAM2). */
+	uint64_t ram2_sbe                     : 1;  /**< Detected single-bit error on the UAHC RxFIFO RAMs (RAM2). */
+	uint64_t ram1_dbe                     : 1;  /**< Detected double-bit error on the UAHC TxFIFO RAMs (RAM1). */
+	uint64_t ram1_sbe                     : 1;  /**< Detected single-bit error on the UAHC TxFIFO RAMs (RAM1). */
+	uint64_t ram0_dbe                     : 1;  /**< Detected double-bit error on the UAHC Desc/Reg Cache (RAM0). */
+	uint64_t ram0_sbe                     : 1;  /**< Detected single-bit error on the UAHC Desc/Reg Cache (RAM0). */
+	uint64_t reserved_3_15                : 13;
+	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. Error information is logged in
+                                                         USBDRD()_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates
+                                                         the assumptions made by the AXI-to-IOI shim. Such scenarios include: illegal length/size
+                                                         combinations and address out-of-bounds.
+                                                         For more information on exact failures, see the description in
+                                                         USBDRD()_UCTL_SHIM_CFG[XM_BAD_DMA_TYPE]. The hardware does not translate the request
+                                                         correctly
+                                                         and results may violate IOI protocols. */
+	uint64_t xs_ncb_oob                   : 1;  /**< Detected out-of-bound register access to UAHC over IOI. The UAHC defines 1MB of register
+                                                         space, starting at offset 0x0. Any accesses outside of this register space cause this bit
+                                                         to be set to 1. Error information is logged in USBDRD()_UCTL_SHIM_CFG[XS_NCB_OOB_*]. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t xs_ncb_oob                   : 1;
+	uint64_t xm_bad_dma                   : 1;
+	uint64_t reserved_3_15                : 13;
+	uint64_t ram0_sbe                     : 1;
+	uint64_t ram0_dbe                     : 1;
+	uint64_t ram1_sbe                     : 1;
+	uint64_t ram1_dbe                     : 1;
+	uint64_t ram2_sbe                     : 1;
+	uint64_t ram2_dbe                     : 1;
+	uint64_t reserved_22_25               : 4;
+	uint64_t xm_w_sbe                     : 1;
+	uint64_t xm_w_dbe                     : 1;
+	uint64_t xm_r_sbe                     : 1;
+	uint64_t xm_r_dbe                     : 1;
+	uint64_t reserved_30_63               : 34;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_intstat_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_22_63               : 42;
 	uint64_t ram2_dbe                     : 1;  /**< Detected double-bit error on the UAHC RxFIFO RAMs (RAM2). */
 	uint64_t ram2_sbe                     : 1;  /**< Detected single-bit error on the UAHC RxFIFO RAMs (RAM2). */
@@ -5834,16 +8028,16 @@ union cvmx_usbdrdx_uctl_intstat {
 	uint64_t ram2_dbe                     : 1;
 	uint64_t reserved_22_63               : 42;
 #endif
-	} s;
-	struct cvmx_usbdrdx_uctl_intstat_s    cn70xx;
-	struct cvmx_usbdrdx_uctl_intstat_s    cn70xxp1;
+	} cn70xx;
+	struct cvmx_usbdrdx_uctl_intstat_cn70xx cn70xxp1;
+	struct cvmx_usbdrdx_uctl_intstat_s    cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_intstat cvmx_usbdrdx_uctl_intstat_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cfg_hs
  *
- * This register controls configuration and test controls for the HS port 0 PHY.
+ * This register controls configuration and test controls for the high-speed port 0 PHY.
  *
  * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
  *
@@ -5874,10 +8068,10 @@ union cvmx_usbdrdx_uctl_portx_cfg_hs {
 	uint64_t reserved_46_47               : 2;
 	uint64_t tx_hs_xv_tune                : 2;  /**< Transmitter high-speed crossover adjustment. This bus adjusts the voltage at which the DP0
                                                          and DM0 signals cross while transmitting in high-speed mode.
-                                                         0x3 = default setting.
-                                                         0x2 = +15 mV.
+                                                         0x0 = reserved.
                                                          0x1 = -15 mV.
-                                                         0x0 = reserved. */
+                                                         0x2 = +15 mV.
+                                                         0x3 = default setting. */
 	uint64_t tx_preemp_amp_tune           : 2;  /**< High-speed transmitter pre-emphasis current control. Controls the amount of current
                                                          sourced to DP0 and DM0 after a J-to-K or K-to-J transition. The high-speed transmitter
                                                          preemphasis current is defined in terms of unit amounts. One unit amount is approximately
@@ -5960,15 +8154,17 @@ union cvmx_usbdrdx_uctl_portx_cfg_hs {
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cfg_hs cvmx_usbdrdx_uctl_portx_cfg_hs_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cfg_ss
  *
- * Accessible by: only when H_CLKDIV_EN.
  * This register controls configuration and test controls for the SS port 0 PHY.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  *
  * INTERNAL: All these settings are for high-speed functionality, connect on DVDD power domain.
@@ -6093,17 +8289,18 @@ union cvmx_usbdrdx_uctl_portx_cfg_ss {
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cfg_ss cvmx_usbdrdx_uctl_portx_cfg_ss_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cr_dbg_cfg
  *
- * Accessible by: only when H_CLKDIV_EN
- *
  * This register allows indirect access to the configuration and test controls for the port 0
  * PHY.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  *
  * INTERNAL: (In body of HRM)
@@ -6184,16 +8381,18 @@ union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg {
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cr_dbg_status
  *
- * Accessible by: only when H_CLKDIV_EN.
  * This register allows indirect access to the configuration and test controls for the port 0
  * PHY.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_portx_cr_dbg_status {
@@ -6213,18 +8412,20 @@ union cvmx_usbdrdx_uctl_portx_cr_dbg_status {
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn70xx;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn70xxp1;
+	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cr_dbg_status cvmx_usbdrdx_uctl_portx_cr_dbg_status_t;
 
 /**
  * cvmx_usbdrd#_uctl_shim_cfg
  *
- * Accessible by: only when H_CLKDIV_EN.
  * This register allows configuration of various shim (UCTL) features. The fields XS_NCB_OOB_*
  * are captured when there are no outstanding OOB errors indicated in INTSTAT and a new OOB error
  * arrives. The fields XS_BAD_DMA_* are captured when there are no outstanding DMA errors
  * indicated in INTSTAT and a new DMA error arrives.
  *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_shim_cfg {
@@ -6237,8 +8438,8 @@ union cvmx_usbdrdx_uctl_shim_cfg {
 	uint64_t xs_ncb_oob_osrc              : 12; /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB
                                                          error.
                                                          <59:58> = chipID.
-                                                         <57> = Request source: 0 = core, 1 = NCB-device.
-                                                         <56:51> = Core/NCB-device number. Note that for NCB devices, <56> is always 0.
+                                                         <57> = Request source: 0 = core, 1 = IOI-device.
+                                                         <56:51> = Core/IOI-device number. Note that for IOI devices, <56> is always 0.
                                                          <50:48> = SubID. */
 	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
                                                          0 = read error log, 1 = write error log */
@@ -6269,6 +8470,7 @@ union cvmx_usbdrdx_uctl_shim_cfg {
 	} s;
 	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn70xx;
 	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn70xxp1;
+	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn73xx;
 };
 typedef union cvmx_usbdrdx_uctl_shim_cfg cvmx_usbdrdx_uctl_shim_cfg_t;
 
@@ -6294,6 +8496,27 @@ union cvmx_usbdrdx_uctl_spare0 {
 typedef union cvmx_usbdrdx_uctl_spare0 cvmx_usbdrdx_uctl_spare0_t;
 
 /**
+ * cvmx_usbdrd#_uctl_spare0_eco
+ *
+ * This register is a spare register. This register can be reset by IOI reset.
+ *
+ */
+union cvmx_usbdrdx_uctl_spare0_eco {
+	uint64_t u64;
+	struct cvmx_usbdrdx_uctl_spare0_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_spare0_eco_s cn73xx;
+};
+typedef union cvmx_usbdrdx_uctl_spare0_eco cvmx_usbdrdx_uctl_spare0_eco_t;
+
+/**
  * cvmx_usbdrd#_uctl_spare1
  *
  * Accessible by: only when H_CLKDIV_EN.
@@ -6314,4 +8537,26 @@ union cvmx_usbdrdx_uctl_spare1 {
 };
 typedef union cvmx_usbdrdx_uctl_spare1 cvmx_usbdrdx_uctl_spare1_t;
 
+/**
+ * cvmx_usbdrd#_uctl_spare1_eco
+ *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
+ */
+union cvmx_usbdrdx_uctl_spare1_eco {
+	uint64_t u64;
+	struct cvmx_usbdrdx_uctl_spare1_eco_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+#else
+	uint64_t eco_rw                       : 32;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_usbdrdx_uctl_spare1_eco_s cn73xx;
+};
+typedef union cvmx_usbdrdx_uctl_spare1_eco cvmx_usbdrdx_uctl_spare1_eco_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index c41c1b8..a9a9d84 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -170,8 +170,10 @@ typedef enum {
 				/**<  Octeon has OCLA */
 	OCTEON_FEATURE_FAU,
 				/**<  Octeon has FAU */
+	OCTEON_FEATURE_BGX,
+				/**<  Octeon has BGX */
 	OCTEON_FEATURE_BGX_MIX,
-				/**<  Octeon has FAU */
+				/**<  On of the BGX is used for MIX */
 	OCTEON_FEATURE_HNA,
 				/**<  Octeon has HNA */
 	OCTEON_FEATURE_OCX,
@@ -475,6 +477,11 @@ static inline int octeon_has_feature_OCTEON_FEATURE_FAU(void)
 	return !OCTEON_IS_MODEL(OCTEON_CN78XX);
 }
 
+static inline int octeon_has_feature_OCTEON_FEATURE_BGX(void)
+{
+	return OCTEON_IS_MODEL(OCTEON_CN78XX);
+}
+
 static inline int octeon_has_feature_OCTEON_FEATURE_BGX_MIX(void)
 {
 	return OCTEON_IS_MODEL(OCTEON_CN78XX);
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
index 951757e..1cf86d4 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -39,7 +39,7 @@
 
 #include "octeon-bgx.h"
 
-static atomic_t bgx_nexus_once;
+static atomic_t bgx_nexus_once[4];
 static atomic_t request_ethernet3_once;
 
 static int bgx_probe(struct platform_device *pdev)
@@ -57,15 +57,16 @@ static int bgx_probe(struct platform_device *pdev)
 	int r = 0;
 	char id[64];
 
-	/* One time initialization */
-	if (atomic_cmpxchg(&bgx_nexus_once, 0, 1) == 0)
-		__cvmx_helper_init_port_config_data();
 
 	reg = of_get_property(pdev->dev.of_node, "reg", NULL);
 	addr = of_translate_address(pdev->dev.of_node, reg);
 	interface = (addr >> 24) & 0xf;
 	numa_node = (addr >> 36) & 0x7;
 
+	/* One time initialization */
+	if (atomic_cmpxchg(bgx_nexus_once + numa_node, 0, 1) == 0)
+		__cvmx_helper_init_port_config_data(numa_node);
+
 	__cvmx_helper_bgx_probe(cvmx_helper_node_interface_to_xiface(numa_node, interface));
 
 	/* Assign 8 CAM entries per LMAC */
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index ad637e7..8e25401 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -768,7 +768,6 @@ static int octeon3_eth_global_init(unsigned int node)
 		goto done;
 	}
 
-	__cvmx_helper_init_port_config_data();
 	rv = __cvmx_helper_pko3_init_global(node, oen->pko_aura.laura | (node << 10));
 	if (rv) {
 		pr_err("cvmx_helper_pko3_init_global failed\n");
@@ -1303,17 +1302,23 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 	ipd_port = cvmx_helper_get_ipd_port(priv->xiface, priv->port_index);
 
 	r =  __cvmx_pko3_config_gen_interface(priv->xiface, priv->port_index, 1, false);
-	if (r)
+	if (r) {
+		dev_err(netdev->dev.parent, "__cvmx_pko3_config_gen_interface: %d\n", r);
 		return -ENODEV;
+	}
 
 	r = __cvmx_pko3_helper_dqs_activate(priv->xiface, priv->port_index, false);
-	if (r < 0)
+	if (r < 0) {
+		dev_err(netdev->dev.parent, "__cvmx_pko3_helper_dqs_activate: %d\n", r);
 		return -ENODEV;
+	}
 
 	/* Padding and FCS are done in BGX */
 	r = cvmx_pko3_interface_options(priv->xiface, priv->port_index, false, false, 0);
-	if (r)
+	if (r) {
+		dev_err(netdev->dev.parent, "cvmx_pko3_interface_options: %d\n", r);
 		return -ENODEV;
+	}
 
 	node_dq = cvmx_pko3_get_queue_base(ipd_port);
 	xdq = cvmx_helper_ipd_port_to_xport(node_dq);
-- 
2.6.2

