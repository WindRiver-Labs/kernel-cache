From a6e27ceac48cadc37b46bd690f4f24e9c2e240a1 Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Fri, 11 Sep 2015 11:55:53 -0700
Subject: [PATCH 952/974] mips: i2c-octeon symbolic names

No functional change, but replace manifest constants like 0xf8 with
symbolic names like STAT_IDLE_F8 for readability in upcoming changes,
and comment some things better.

The STAT_xxx_yy names have their hex value in the name for ease of reference,
as the hardware ref manual just speaks of these 29 states by their hex values.

Signed-off-by: Peter Swain <pswain@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/i2c/busses/i2c-octeon.c | 117 ++++++++++++++++++++++++++--------------
 1 file changed, 78 insertions(+), 39 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index 479979e..f09a0d9 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -56,21 +56,55 @@
 #define SW_TWSI_OP_TWSI_CLK     0x0800000000000000ull
 
 /* Controller command and status bits */
-#define TWSI_CTL_CE   0x80
-#define TWSI_CTL_ENAB 0x40
-#define TWSI_CTL_STA  0x20
-#define TWSI_CTL_STP  0x10
-#define TWSI_CTL_IFLG 0x08
-#define TWSI_CTL_AAK  0x04
-
-/* Some status values */
-#define STAT_START      0x08
-#define STAT_RSTART     0x10
-#define STAT_TXADDR_ACK 0x18
-#define STAT_TXDATA_ACK 0x28
-#define STAT_RXADDR_ACK 0x40
-#define STAT_RXDATA_ACK 0x50
-#define STAT_IDLE       0xF8
+#define TWSI_CTL_CE   0x80	/* HighLevelController enable */
+#define TWSI_CTL_ENAB 0x40	/* bus enable */
+#define TWSI_CTL_STA  0x20	/* master-mode start */
+#define TWSI_CTL_STP  0x10	/* master-mode stop */
+#define TWSI_CTL_IFLG 0x08	/* bus idle */
+#define TWSI_CTL_AAK  0x04	/* Assert ACK */
+
+/* Some status values - named with value, as HRM speaks of values */
+#define STAT_ERROR_00		0x00
+#define STAT_START_08		0x08
+#define STAT_RSTART_10		0x10
+#define STAT_TXADDR_ACK_18	0x18
+#define STAT_TXADDR_NAK_20	0x20
+#define STAT_TXDATA_ACK_28	0x28
+#define STAT_TXDATA_NAK_30	0x30
+#define STAT_LOST_ARB_38	0x38
+#define STAT_RXADDR_ACK_40	0x40
+#define STAT_RXADDR_NAK_48	0x48
+#define STAT_RXDATA_ACK_50	0x50
+#define STAT_RXDATA_NAK_58	0x58
+#define STAT_SLAVE_60		0x60
+#define STAT_LOST_ARB_68	0x68
+#define STAT_SLAVE_70		0x70
+#define STAT_LOST_ARB_78	0x78
+#define STAT_SLAVE_80		0x80
+#define STAT_SLAVE_88		0x88
+#define STAT_GENDATA_ACK_90	0x90
+#define STAT_GENDATA_NAK_98	0x98
+#define STAT_SLAVE_A0		0xA0
+#define STAT_SLAVE_A8		0xA8
+#define STAT_LOST_ARB_B0	0xB0
+#define STAT_SLAVE_LOST_B8	0xB8
+#define STAT_SLAVE_NAK_C0	0xC0
+#define STAT_SLAVE_ACK_C8	0xC8
+#define STAT_AD2W_ACK_D0	0xD0
+#define STAT_AD2W_NAK_D8	0xD8
+#define STAT_IDLE_F8		0xF8
+
+/* TWSI_INT values */
+#define ST_INT			0x01
+#define TS_INT			0x02
+#define CORE_INT		0x04
+#define ST_EN			0x10
+#define TS_EN			0x20
+#define CORE_EN			0x40
+#define SDA_OVR			0x100
+#define SCL_OVR			0x200
+#define SDA			0x400
+#define SCL			0x800
 
 struct octeon_i2c {
 	wait_queue_head_t queue;
@@ -113,7 +147,7 @@ static void octeon_i2c_write_sw(struct octeon_i2c *i2c,
 }
 
 /**
- * octeon_i2c_read_sw - write an I2C core register.
+ * octeon_i2c_read_sw - read an I2C core register.
  * @i2c: The struct octeon_i2c.
  * @eop_reg: Register selector.
  *
@@ -148,12 +182,12 @@ static void octeon_i2c_write_int(struct octeon_i2c *i2c, u64 data)
  * octeon_i2c_int_enable - enable the CORE interrupt.
  * @i2c: The struct octeon_i2c.
  *
- * The interrupt will be asserted when there is non-STAT_IDLE state in
+ * The interrupt will be asserted when there is non-STAT_IDLE_F8 state in
  * the SW_TWSI_EOP_TWSI_STAT register.
  */
 static void octeon_i2c_int_enable(struct octeon_i2c *i2c)
 {
-	octeon_i2c_write_int(i2c, 0x40);
+	octeon_i2c_write_int(i2c, CORE_EN);
 }
 
 /**
@@ -169,7 +203,7 @@ static void octeon_i2c_int_disable(struct octeon_i2c *i2c)
  * octeon_i2c_int_enable78 - enable the CORE interrupt.
  * @i2c: The struct octeon_i2c.
  *
- * The interrupt will be asserted when there is non-STAT_IDLE state in
+ * The interrupt will be asserted when there is non-STAT_IDLE_F8 state in
  * the SW_TWSI_EOP_TWSI_STAT register.
  */
 static void octeon_i2c_int_enable78(struct octeon_i2c *i2c)
@@ -198,7 +232,7 @@ static void octeon_i2c_int_disable78(struct octeon_i2c *i2c)
  * octeon_i2c_hlc_int_enable78 - enable the ST interrupt.
  * @i2c: The struct octeon_i2c.
  *
- * The interrupt will be asserted when there is non-STAT_IDLE state in
+ * The interrupt will be asserted when there is non-STAT_IDLE_F8 state in
  * the SW_TWSI_EOP_TWSI_STAT register.
  */
 static void octeon_i2c_hlc_int_enable78(struct octeon_i2c *i2c)
@@ -236,17 +270,18 @@ static void octeon_i2c_unblock(struct octeon_i2c *i2c)
 	int i;
 
 	dev_dbg(i2c->dev, "%s\n", __func__);
+
 	for (i = 0; i < 9; i++) {
-		octeon_i2c_write_int(i2c, 0x0);
+		octeon_i2c_write_int(i2c, 0);
 		udelay(5);
-		octeon_i2c_write_int(i2c, 0x200);
+		octeon_i2c_write_int(i2c, SCL_OVR);
 		udelay(5);
 	}
-	octeon_i2c_write_int(i2c, 0x300);
+	octeon_i2c_write_int(i2c, SDA_OVR | SCL_OVR);
 	udelay(5);
-	octeon_i2c_write_int(i2c, 0x100);
+	octeon_i2c_write_int(i2c, SDA_OVR);
 	udelay(5);
-	octeon_i2c_write_int(i2c, 0x0);
+	octeon_i2c_write_int(i2c, 0);
 }
 
 /**
@@ -349,24 +384,24 @@ static int octeon_i2c_enable_hlc(struct octeon_i2c *i2c)
 
 static bool octeon_i2c_lost_arb(u64 code)
 {
-	switch (code & 0xffull) {
+	switch (code & 0xff) {
 	/* Arbitration lost in address or data byte */
-	case 0x38:
+	case STAT_LOST_ARB_38:
 	/*
 	 * Arbitration lost in address as master, slave address +
 	 * write bit received, ACK transmitted.
 	 */
-	case 0x68:
+	case STAT_LOST_ARB_68:
 	/*
 	 * Arbitration lost in address as master, general call address
 	 * received, ACK transmitted.
 	 */
-	case 0x78:
+	case STAT_LOST_ARB_78:
 	/*
 	 * Arbitration lost in address as master, slave address + read
 	 * bit received, ACK transmitted.
 	 */
-	case 0xb0:
+	case STAT_LOST_ARB_B0:
 		return true;
 	default:
 		return false;
@@ -391,7 +426,8 @@ static int octeon_i2c_start(struct octeon_i2c *i2c)
 
 	result = octeon_i2c_wait(i2c);
 	if (result) {
-		if (octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT) == STAT_IDLE) {
+		if (octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT)
+				== STAT_IDLE_F8) {
 			/*
 			 * Controller refused to send start flag May
 			 * be a client is holding SDA low - let's try
@@ -408,7 +444,7 @@ static int octeon_i2c_start(struct octeon_i2c *i2c)
 	}
 
 	data = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);
-	if ((data != STAT_START) && (data != STAT_RSTART)) {
+	if ((data != STAT_START_08) && (data != STAT_RSTART_10)) {
 		dev_err(i2c->dev, "%s: bad status (0x%x)\n", __func__, data);
 		return -EIO;
 	}
@@ -431,7 +467,7 @@ static int octeon_i2c_stop(struct octeon_i2c *i2c)
 
 	data = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);
 
-	if (data != STAT_IDLE) {
+	if (data != STAT_IDLE_F8) {
 		dev_err(i2c->dev, "%s: bad status(0x%x)\n", __func__, data);
 		return -EIO;
 	}
@@ -473,7 +509,8 @@ restart:
 		if (phase == 0 && octeon_i2c_lost_arb(tmp))
 			goto restart;
 
-		if ((tmp != STAT_TXADDR_ACK) && (tmp != STAT_TXDATA_ACK)) {
+		if ((tmp != STAT_TXADDR_ACK_18)
+		 && (tmp != STAT_TXDATA_ACK_28)) {
 			dev_err(i2c->dev,
 				"%s: bad status before write (0x%x)\n",
 				__func__, tmp);
@@ -529,7 +566,8 @@ restart:
 		if (phase == 0 && octeon_i2c_lost_arb(tmp))
 			goto restart;
 
-		if ((tmp != STAT_RXDATA_ACK) && (tmp != STAT_RXADDR_ACK)) {
+		if ((tmp != STAT_RXDATA_ACK_50)
+		 && (tmp != STAT_RXADDR_ACK_40)) {
 			dev_err(i2c->dev,
 				"%s: bad status before read (0x%x)\n",
 				__func__, tmp);
@@ -560,12 +598,13 @@ static bool octeon_i2c_hlc_test_ready(struct octeon_i2c *i2c)
 
 static void octeon_i2c_hlc_int_enable(struct octeon_i2c *i2c)
 {
-	octeon_i2c_write_int(i2c, 0x10);
+	octeon_i2c_write_int(i2c, ST_EN);
 }
 
 static void octeon_i2c_hlc_int_clear(struct octeon_i2c *i2c)
 {
-	octeon_i2c_write_int(i2c, 0x3);
+	/* clear ST/TS events, listen for neither */
+	octeon_i2c_write_int(i2c, ST_INT | TS_INT);
 }
 
 /**
@@ -968,12 +1007,12 @@ static int octeon_i2c_initlowlevel(struct octeon_i2c *i2c)
 	octeon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_RST, 0);
 
 	status = 0;
-	for (tries = 10; tries && status != STAT_IDLE; tries--) {
+	for (tries = 10; tries && status != STAT_IDLE_F8; tries--) {
 		udelay(1);
 		status = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);
 	}
 
-	if (status != STAT_IDLE) {
+	if (status != STAT_IDLE_F8) {
 		dev_err(i2c->dev, "%s: TWSI_RST failed! (0x%x)\n",
 			__func__, status);
 		return -EIO;
-- 
2.6.2

