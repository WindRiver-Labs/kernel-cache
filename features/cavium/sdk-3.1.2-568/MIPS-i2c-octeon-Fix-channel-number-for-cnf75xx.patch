From aa997769f460901f2fd3a063c01868b7e13e7ed5 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Fri, 18 Dec 2015 12:10:38 -0800
Subject: [PATCH 06/13] MIPS:i2c-octeon: Fix channel number for cnf75xx.

CNF75xx has 3 TWSI devices, and the base address is different, adjust
the channel to match the base address.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from patch set for OCTEON SDK 3.1.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-twsi.c |  100 ++++++++++++++++---------
 drivers/i2c/busses/i2c-octeon.c               |   11 ++-
 2 files changed, 73 insertions(+), 38 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-twsi.c b/arch/mips/cavium-octeon/executive/cvmx-twsi.c
index 50cc709..785f104 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-twsi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-twsi.c
@@ -42,7 +42,7 @@
  *
  * Interface to the TWSI / I2C bus
  *
- * <hr>$Revision: 109574 $<hr>
+ * <hr>$Revision: 130004 $<hr>
  *
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
@@ -69,8 +69,29 @@
 #define cvmx_csr_db_decode(...)
 #endif /*PRINT_TWSI_CONFIG */
 
-#define node_bus_to_i2c_bus(node,bus)	((node << 1) | bus)
-#define i2c_bus_to_node(i2c_bus)	((i2c_bus >> 1) & 0x3)
+static int node_bus_to_i2c_bus(int node, int bus)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_MULTINODE))
+		return (node << 1) | bus;
+	else
+		return bus;
+}
+
+static int i2c_bus_to_node(int i2c_bus)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_MULTINODE))
+		return (i2c_bus >> 1) & 0x3;
+	else
+		return 0;
+}
+
+static int __i2c_twsi_bus(int i2c_bus)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_MULTINODE))
+		return i2c_bus & 0x1;
+	else
+		return i2c_bus;
+}
 
 #endif /* #ifdef CVMX_BUILD_FOR_LINUX_KERNEL */
 
@@ -101,38 +122,39 @@ int cvmx_twsix_unblock(int twsi_id)
 	cvmx_mio_tws_int_t tws_int;
 	uint64_t old_sw_twsi;
 	int i;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
 
 	/* Put the bus in low-level mode */
 	old_sw_twsi = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-					 CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1));
+					 CVMX_MIO_TWSX_SW_TWSI(twsi_bus));
 	sw_twsi.u64 = 0;
 	sw_twsi.s.v = 1;
 	sw_twsi.s.op = 6;
 	sw_twsi.s.eop_ia = TWSI_CTL;
 	sw_twsi.s.d = 0x40;	/* ENAB !CE !AAK */
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi.u64);
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi.u64);
 	cvmx_wait_usec(10);
 	tws_int.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-					 CVMX_MIO_TWSX_INT(twsi_id & 1));
+					 CVMX_MIO_TWSX_INT(twsi_bus));
 	cvmx_wait_usec(10);
 	tws_int.s.scl_ovr = 0;
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_INT(twsi_id & 1), tws_int.u64);
+			    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
 	cvmx_wait_usec(10);
 	for (i = 0; i < 9; i++) {
 		tws_int.s.scl_ovr = 1;
 		cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-				    CVMX_MIO_TWSX_INT(twsi_id & 1), tws_int.u64);
+				    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
 		cvmx_wait_usec(10);
 		tws_int.s.scl_ovr = 0;
 		cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-				    CVMX_MIO_TWSX_INT(twsi_id & 1), tws_int.u64);
+				    CVMX_MIO_TWSX_INT(twsi_bus), tws_int.u64);
 		cvmx_wait_usec(10);
 	}
 	/* Restore back to high level mode */
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), old_sw_twsi);
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), old_sw_twsi);
 	cvmx_wait_usec(10);
 	return 0;
 }
@@ -207,6 +229,7 @@ int cvmx_twsix_read_ia(int twsi_id, uint8_t dev_addr, uint16_t internal_addr,
 	cvmx_mio_twsx_sw_twsi_ext_t twsi_ext;
 	int retry_limit = 5;
 	int count = TWSI_TIMEOUT;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
 
 	if (num_bytes < 1 || num_bytes > 8 || !data 
 		|| ia_width_bytes < 0 || ia_width_bytes > 2)
@@ -229,17 +252,17 @@ retry:
 		sw_twsi_val.s.eia = 1;
 		twsi_ext.s.ia = internal_addr >> 8;
 		cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-				    CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_id & 1), 
+				    CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_bus),
 				    twsi_ext.u64);
 	}
 
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			   CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	while ((((cvmx_mio_twsx_sw_twsi_t)
 		(sw_twsi_val.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-				     CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1)))).s.v)
+				     CVMX_MIO_TWSX_SW_TWSI(twsi_bus)))).s.v)
 	       && --count > 0)
 		cvmx_wait_usec(10);
 	if (count <= 0) {
@@ -252,7 +275,7 @@ retry:
 	}
 	twsi_printf("Results:\n");
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			   CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	if (!sw_twsi_val.s.r) {
 		/* Check the reason for the failure.  We may need to retry to handle multi-master
 		 ** configurations.
@@ -282,7 +305,7 @@ retry:
 	if (num_bytes > 4) {
 		*data = (sw_twsi_val.s.d & 0xFFFFFFFF);
 		twsi_ext.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-						  CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_id & 1));
+						  CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_bus));
 		*data |= ((unsigned long long)(twsi_ext.s.d & (0xFFFFFFFF >> (32 - (num_bytes-4) * 8))) << 32);
 	} else {
 		*data = (sw_twsi_val.s.d & (0xFFFFFFFF >> (32 - num_bytes * 8)));
@@ -344,6 +367,7 @@ int cvmx_twsix_read(int twsi_id, uint8_t dev_addr, int num_bytes, uint64_t * dat
 	cvmx_mio_twsx_sw_twsi_ext_t twsi_ext;
 	int retry_limit = 5;
 	int count = TWSI_TIMEOUT;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
 
 	if (num_bytes > 8 || num_bytes < 1)
 		return -1;
@@ -356,12 +380,12 @@ retry:
 	sw_twsi_val.s.size = num_bytes - 1;
 
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			   CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	while (((cvmx_mio_twsx_sw_twsi_t)
 		(sw_twsi_val.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-						      CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1)))).s.v
+						      CVMX_MIO_TWSX_SW_TWSI(twsi_bus)))).s.v
 	       && --count > 0)
 		cvmx_wait_usec(10);
 	if (count <= 0) {
@@ -374,7 +398,7 @@ retry:
 	}
 	twsi_printf("Results:\n");
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			   CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	if (!sw_twsi_val.s.r)
 		if (!sw_twsi_val.s.r) {
 			/* Check the reason for the failure.  We may need to retry to handle multi-master
@@ -404,7 +428,7 @@ retry:
 	if (num_bytes > 4) {
 		*data = (sw_twsi_val.s.d & 0xFFFFFFFF);
 		twsi_ext.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-						  CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_id & 1));
+						  CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_bus));
 		*data |= ((unsigned long long)(twsi_ext.s.d & (0xFFFFFFFF >> (32 - (num_bytes-4) * 8))) << 32);
 	} else {
 		*data = (sw_twsi_val.s.d & (0xFFFFFFFF >> (32 - num_bytes * 8)));
@@ -464,6 +488,7 @@ int cvmx_twsix_write(int twsi_id, uint8_t dev_addr, int num_bytes, uint64_t data
 	cvmx_mio_twsx_sw_twsi_t sw_twsi_val;
 	int count = TWSI_TIMEOUT;
 	int retries = 5;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
 
 	if (num_bytes > 8 || num_bytes < 1)
 		return -1;
@@ -484,15 +509,15 @@ retry:
 		twsi_ext.u64 = 0;
 		twsi_ext.s.d = data >> 32;
 		cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-				    CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_id & 1), twsi_ext.u64);
+				    CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_bus), twsi_ext.u64);
 	}
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			   CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	while (((cvmx_mio_twsx_sw_twsi_t) 
 		(sw_twsi_val.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-						      CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1)))).s.v
+						      CVMX_MIO_TWSX_SW_TWSI(twsi_bus)))).s.v
 	       && --count > 0)
 		cvmx_wait_usec(10);
 	if (count <= 0) {
@@ -501,7 +526,7 @@ retry:
 	}
 	twsi_printf("Results:\n");
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			   CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	if (!sw_twsi_val.s.r)
 		return -1;
 
@@ -587,6 +612,7 @@ int cvmx_twsix_write_ia(int twsi_id, uint8_t dev_addr, uint16_t internal_addr,
 	int to;
 	int count = TWSI_TIMEOUT;
 	int retry_limit = 5;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
 
 	if (num_bytes < 1 || num_bytes > 8 || ia_width_bytes < 0 || ia_width_bytes > 2)
 		return -1;
@@ -617,16 +643,16 @@ retry:
 			__func__, twsi_id, dev_addr, internal_addr, 
 			num_bytes, ia_width_bytes, data);
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_id & 1), twsi_ext.u64);
+			   CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_bus), twsi_ext.u64);
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_id & 1), twsi_ext.u64);
+			    CVMX_MIO_TWSX_SW_TWSI_EXT(twsi_bus), twsi_ext.u64);
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			   CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 	while (((cvmx_mio_twsx_sw_twsi_t)
 	        (sw_twsi_val.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-						      CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1)))).s.v
+						      CVMX_MIO_TWSX_SW_TWSI(twsi_bus)))).s.v
 	       && --count > 0)
 		cvmx_wait_usec(10);
 	if (count <= 0) {
@@ -640,7 +666,7 @@ retry:
 
 	twsi_printf("Results:\n");
 	cvmx_csr_db_decode(cvmx_get_proc_id(), 
-			   CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			   CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 /*	cvmx_csr_db_decode(cvmx_get_proc_id(), CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64); */
 	if (!sw_twsi_val.s.r) {
 		/* Check the reason for the failure.  We may need to retry to handle multi-master
@@ -712,6 +738,7 @@ EXPORT_SYMBOL(cvmx_twsix_write_ia);
 static void cvmx_twsix_write_llc_reg(int twsi_id, uint8_t eop_reg, uint8_t data)
 {
 	cvmx_mio_twsx_sw_twsi_t sw_twsi_val, tmp;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
 
 	sw_twsi_val.u64 = 0;
 	sw_twsi_val.s.v = 1;
@@ -719,17 +746,18 @@ static void cvmx_twsix_write_llc_reg(int twsi_id, uint8_t eop_reg, uint8_t data)
 	sw_twsi_val.s.eop_ia = eop_reg;
 	sw_twsi_val.s.d = data;
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 
 	do {
 		tmp.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-					     CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1));
+					     CVMX_MIO_TWSX_SW_TWSI(twsi_bus));
 	} while (tmp.s.v != 0);
 }
 
 static uint8_t cvmx_twsix_read_llc_reg(int twsi_id, uint8_t eop_reg)
 {
 	cvmx_mio_twsx_sw_twsi_t sw_twsi_val, tmp;
+	int twsi_bus = __i2c_twsi_bus(twsi_id);
 
 	sw_twsi_val.u64 = 0;
 	sw_twsi_val.s.v = 1;
@@ -737,11 +765,11 @@ static uint8_t cvmx_twsix_read_llc_reg(int twsi_id, uint8_t eop_reg)
 	sw_twsi_val.s.eop_ia = eop_reg;
 	sw_twsi_val.s.r = 1;
 	cvmx_write_csr_node(i2c_bus_to_node(twsi_id), 
-			    CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1), sw_twsi_val.u64);
+			    CVMX_MIO_TWSX_SW_TWSI(twsi_bus), sw_twsi_val.u64);
 
 	do {
 		tmp.u64 = cvmx_read_csr_node(i2c_bus_to_node(twsi_id), 
-					     CVMX_MIO_TWSX_SW_TWSI(twsi_id & 1));
+					     CVMX_MIO_TWSX_SW_TWSI(twsi_bus));
 	} while (tmp.s.v != 0);
 
 	return tmp.s.d & 0xff;
diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index fe93a7f..65e9df8 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -1168,7 +1168,7 @@ static int octeon_i2c_initlowlevel(struct octeon_i2c *i2c)
 	return 0;
 }
 
-static int octeon_i2c_cvmx_map[2] = {-ENODEV, -ENODEV};
+static int octeon_i2c_cvmx_map[3] = {-ENODEV, -ENODEV, -ENODEV};
 
 int octeon_i2c_cvmx2i2c(unsigned int cvmx_twsi_bus_num)
 {
@@ -1242,8 +1242,15 @@ static int octeon_i2c_probe(struct platform_device *pdev)
 	case 0x1180000001000:
 		i2c->cvmx_channel = 0;
 		break;
+	case 0x1180000001100:
+		if (OCTEON_IS_MODEL(OCTEON_CNF75XX))
+			i2c->cvmx_channel = 1;
+		break;
 	case 0x1180000001200:
-		i2c->cvmx_channel = 1;
+		if (OCTEON_IS_MODEL(OCTEON_CNF75XX))
+			i2c->cvmx_channel = 2;
+		else
+			i2c->cvmx_channel = 1;
 		break;
 	default:
 		break;
-- 
1.7.5.4

