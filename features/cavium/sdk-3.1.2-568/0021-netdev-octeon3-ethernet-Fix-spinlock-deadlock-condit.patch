From 68921c99ef00c15438e6f28b9f36fa0540430368 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Thu, 13 Nov 2014 15:39:40 -0800
Subject: [PATCH 021/184] netdev: octeon3-ethernet: Fix spinlock deadlock
 condition.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 8d09224be1c3b03e19392d30fdbc7733ca908057
Description:

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/octeon3-ethernet.c | 32 +++++++++++++++-----------
 1 file changed, 18 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index 5f0981b..0b9a7ea 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -856,10 +856,11 @@ static struct octeon3_napi_wrapper *octeon3_napi_alloc(struct octeon3_rx *cxt,
 	struct octeon3_ethernet_node	*oen;
 	struct octeon3_ethernet		*priv = cxt->parent;
 	int				node = priv->numa_node;
+	unsigned long			flags;
 	int				i;
 
 	oen = octeon3_eth_node + node;
-	spin_lock(&oen->napi_alloc_lock);
+	spin_lock_irqsave(&oen->napi_alloc_lock, flags);
 
 	/* Find a free napi wrapper */
 	for (i = 0; i < CVMX_MAX_CORES; i++) {
@@ -883,12 +884,12 @@ static struct octeon3_napi_wrapper *octeon3_napi_alloc(struct octeon3_rx *cxt,
 			napi_wrapper[node][i].idx = idx;
 			napi_wrapper[node][i].cpu = cpu;
 			napi_wrapper[node][i].cxt = cxt;
-			spin_unlock(&oen->napi_alloc_lock);
+			spin_unlock_irqrestore(&oen->napi_alloc_lock, flags);
 			return &napi_wrapper[node][i];
 		}
 	}
 
-	spin_unlock(&oen->napi_alloc_lock);
+	spin_unlock_irqrestore(&oen->napi_alloc_lock, flags);
 	return NULL;
 }
 
@@ -917,24 +918,25 @@ static int octeon3_rm_napi_from_cxt(int				node,
 	struct octeon3_ethernet_node	*oen;
 	struct octeon3_rx		*cxt;
 	int				idx;
+	unsigned long			flags;
 
 	oen = octeon3_eth_node + node;
 	cxt = napiw->cxt;
 	idx = napiw->idx;
 
 	/* Free the napi block */
-	spin_lock(&oen->napi_alloc_lock);
+	spin_lock_irqsave(&oen->napi_alloc_lock, flags);
 	bitmap_clear(oen->napi_cpu_bitmap, napiw->cpu, 1);
 	napiw->available = 1;
 	napiw->idx = -1;
 	napiw->cpu = -1;
 	napiw->cxt = NULL;
-	spin_unlock(&oen->napi_alloc_lock);
+	spin_unlock_irqrestore(&oen->napi_alloc_lock, flags);
 
 	/* Free the napi idx */
-	spin_lock(&cxt->napi_idx_lock);
+	spin_lock_irqsave(&cxt->napi_idx_lock, flags);
 	bitmap_clear(cxt->napi_idx_bitmap, idx, 1);
-	spin_unlock(&cxt->napi_idx_lock);
+	spin_unlock_irqrestore(&cxt->napi_idx_lock, flags);
 
 	return 0;
 }
@@ -950,24 +952,25 @@ static int octeon3_add_napi_to_cxt(struct octeon3_rx *cxt)
 	struct octeon3_napi_wrapper	*napiw;
 	struct octeon3_ethernet		*priv = cxt->parent;
 	int				idx;
+	unsigned long			flags;
 	int				rc;
 
 	/* Get a free napi idx */
-	spin_lock(&cxt->napi_idx_lock);
+	spin_lock_irqsave(&cxt->napi_idx_lock, flags);
 	idx = find_first_zero_bit(cxt->napi_idx_bitmap, CVMX_MAX_CORES);
 	if (unlikely(idx >= CVMX_MAX_CORES)) {
-		spin_unlock(&cxt->napi_idx_lock);
+		spin_unlock_irqrestore(&cxt->napi_idx_lock, flags);
 		return -ENOMEM;
 	}
 	bitmap_set(cxt->napi_idx_bitmap, idx, 1);
-	spin_unlock(&cxt->napi_idx_lock);
+	spin_unlock_irqrestore(&cxt->napi_idx_lock, flags);
 
 	/* Get a free napi block */
 	napiw = octeon3_napi_alloc(cxt, idx, -1);
 	if (unlikely(napiw == NULL)) {
-		spin_lock(&cxt->napi_idx_lock);
+		spin_lock_irqsave(&cxt->napi_idx_lock, flags);
 		bitmap_clear(cxt->napi_idx_bitmap, idx, 1);
-		spin_unlock(&cxt->napi_idx_lock);
+		spin_unlock_irqrestore(&cxt->napi_idx_lock, flags);
 		return -ENOMEM;
 	}
 
@@ -1226,10 +1229,11 @@ static int octeon3_eth_napi(struct napi_struct *napi, int budget)
 static int octeon3_napi_init_node(int node, struct net_device *netdev)
 {
 	struct octeon3_ethernet_node	*oen;
+	unsigned long			flags;
 	int				i;
 
 	oen = octeon3_eth_node + node;
-	spin_lock(&oen->napi_alloc_lock);
+	spin_lock_irqsave(&oen->napi_alloc_lock, flags);
 
 	if (oen->napi_init_done)
 		goto done;
@@ -1249,7 +1253,7 @@ static int octeon3_napi_init_node(int node, struct net_device *netdev)
 
 	oen->napi_init_done = true;
  done:
-	spin_unlock(&oen->napi_alloc_lock);
+	spin_unlock_irqrestore(&oen->napi_alloc_lock, flags);
 	return 0;
 
 }
-- 
1.9.1

