From 81ae054ff6e526bce5215d3d98ea5f47c4ae0096 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 25 Jul 2014 18:05:50 -0700
Subject: [PATCH 688/974] MIPS: OCTEON: Add NUMA support for cn78XX

Create machine specific bootmem initialization, and add topology
functions.  This gets it to boot, but more changes needed to be able
to use devices on node-1.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/Kconfig                                  |   2 +
 arch/mips/cavium-octeon/Makefile                   |   1 +
 arch/mips/cavium-octeon/octeon-numa.c              | 105 +++++++++++++++++++
 arch/mips/cavium-octeon/setup.c                    | 113 ++++++++++++++++++---
 arch/mips/cavium-octeon/smp.c                      |   1 +
 .../include/asm/mach-cavium-octeon/mach_bootmem.h  |   8 ++
 arch/mips/include/asm/mach-cavium-octeon/mmzone.h  |  20 ++++
 .../mips/include/asm/mach-cavium-octeon/topology.h |  42 ++++++++
 arch/mips/include/asm/octeon/octeon.h              |   7 ++
 9 files changed, 287 insertions(+), 12 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/octeon-numa.c
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/mmzone.h
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/topology.h

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 5c27cf7..efcefe6 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -768,6 +768,7 @@ config CAVIUM_OCTEON_SOC
 	select SYS_SUPPORTS_SMP
 	select NR_CPUS_DEFAULT_64
 	select MIPS_NR_CPU_NR_MAP_1024
+	select SYS_SUPPORTS_NUMA
 	help
 	  This option supports all of the Octeon SoCs and reference
 	  boards from Cavium, Inc. The Cavium Octeon processor is a
@@ -2188,6 +2189,7 @@ config SYS_SUPPORTS_NUMA
 
 config NODES_SHIFT
 	int
+	default "1" if CAVIUM_OCTEON_SOC
 	default "6"
 	depends on NEED_MULTIPLE_NODES
 
diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index e2ff044..c29f2d5 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -21,6 +21,7 @@ obj-y += octeon-memcpy.o
 obj-y += executive/
 
 obj-$(CONFIG_SMP)			+= smp.o
+obj-$(CONFIG_NUMA)			+= octeon-numa.o
 obj-$(CONFIG_SYSFS)			+= octeon-power-throttle.o
 obj-$(CONFIG_SYSFS)                     += cacheinfo.o
 obj-$(CONFIG_MTD)			+= flash_setup.o
diff --git a/arch/mips/cavium-octeon/octeon-numa.c b/arch/mips/cavium-octeon/octeon-numa.c
new file mode 100644
index 0000000..beb151c
--- /dev/null
+++ b/arch/mips/cavium-octeon/octeon-numa.c
@@ -0,0 +1,105 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2014 Cavium, Inc.
+ */
+
+#include <linux/init.h>
+#include <linux/topology.h>
+#include <linux/mm.h>
+#include <linux/nodemask.h>
+#include <linux/bootmem.h>
+#include <linux/swap.h>
+
+#include <asm/sections.h>
+
+#include <asm/pgalloc.h>
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-coremask.h>
+
+
+void octeon_setup_numa(void)
+{
+	int id;
+	int node;
+	struct cpumask *mask;
+	const int coreid = cvmx_get_core_num();
+	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
+
+	for (id = 0; id < CONFIG_MIPS_NR_CPU_NR_MAP; id++) {
+		if (cvmx_coremask_is_core_set(&sysinfo->core_mask, id)) {
+			node = (id >> 7) & 7;
+			node_set_online(node);
+			node_set_state(node, N_POSSIBLE);
+		}
+	}
+	node = (coreid >> 7) & 7;
+	mask = cpumask_of_node(node);
+	/* The boot CPU will be CPU 0 */
+	cpu_set(0, *mask);
+}
+
+void octeon_numa_cpu_online(void)
+{
+	int node;
+	struct cpumask *mask;
+	const int coreid = cvmx_get_core_num();
+
+	node = (coreid >> 7) & 7;
+	mask = cpumask_of_node(node);
+	cpu_set(smp_processor_id(), *mask);
+}
+
+void __init paging_init(void)
+{
+	unsigned long max_zone_pfns[MAX_NR_ZONES] = {0,};
+	unsigned node;
+
+	pagetable_init();
+
+#ifdef CONFIG_ZONE_DMA
+	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
+#endif
+#ifdef CONFIG_ZONE_DMA32
+	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
+#endif
+	for_each_online_node(node) {
+		unsigned long start_pfn, end_pfn;
+
+		get_pfn_range_for_nid(node, &start_pfn, &end_pfn);
+
+		if (end_pfn > max_low_pfn)
+			max_low_pfn = end_pfn;
+	}
+	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
+
+	free_area_init_nodes(max_zone_pfns);
+}
+
+void setup_zero_pages(void);
+
+void __init mem_init(void)
+{
+	unsigned long codesize, datasize, initsize, tmp;
+	int node;
+
+	for_each_online_node(node) {
+		totalram_pages += free_all_bootmem_node(NODE_DATA(node));
+	}
+	setup_zero_pages();	/* This comes from node 0 */
+
+	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
+
+	tmp = nr_free_pages();
+	pr_info("Memory: %luk/%luk available (%ldk kernel code, %ldk reserved, %ldk data, %ldk init)\n",
+	       tmp << (PAGE_SHIFT-10),
+	       num_physpages << (PAGE_SHIFT-10),
+	       codesize >> 10,
+	       (num_physpages - tmp) << (PAGE_SHIFT-10),
+	       datasize >> 10,
+	       initsize >> 10);
+}
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index febb80e..f4b2a0f 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -29,6 +29,11 @@
 #include <linux/kexec.h>
 #include <linux/initrd.h>
 
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+
+#include <mmzone.h>
+
 #include <asm/processor.h>
 #include <asm/reboot.h>
 #include <asm/smp-ops.h>
@@ -830,6 +835,7 @@ append_arg:
 #endif
 
 	octeon_user_io_init();
+	octeon_setup_numa();
 	octeon_setup_smp();
 
 #ifdef CONFIG_CAVIUM_GDB
@@ -1002,17 +1008,8 @@ void __init plat_mem_setup(void)
 	cvmx_bootmem_lock();
 	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX)
 		&& (total < MAX_MEMORY)) {
-#if defined(CONFIG_64BIT) || defined(CONFIG_64BIT_PHYS_ADDR)
-		if (total < MIN_MEM_32)
-			limit_max = (1ull << 32)-1;	/* 4GBytes */
-		else
-			limit_max = ~0ull;		/* unlimitted */
-#elif defined(CONFIG_HIGHMEM)
-		limit_max = (1ull << 31) - 1;	/* 4GBytes */
-#else
-		limit_max = (1ull << 29) - 1;	/* 512MBytes */
-#endif
-		limit_min = __pa_symbol(&__init_end);
+		limit_max = ~0ull;		/* unlimitted */
+		limit_min = 0;
 
 		memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
 				limit_min, limit_max, 0x100000,
@@ -1020,7 +1017,6 @@ void __init plat_mem_setup(void)
 
 		if (memory >= 0) {
 			u64 size = mem_alloc_size;
-
 			/*
 			 * exclude a page at the beginning and end of
 			 * the 256MB PCIe 'hole' so the kernel will not
@@ -1064,6 +1060,99 @@ mem_alloc_done:
 	cvmx_qlm_init();
 }
 
+struct node_data __node_data[4];
+
+void __init mach_bootmem_init(void)
+{
+	int i;
+	int node;
+
+	min_low_pfn = ~0UL;
+	max_low_pfn = 0;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		unsigned long start, end;
+		struct node_data *nd;
+		bool is_usable;
+
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RAM:
+			is_usable = true;
+			break;
+		case BOOT_MEM_KERNEL:
+		case BOOT_MEM_INIT_RAM:
+			is_usable = false;
+			break;
+		default:
+			/* Not usable memory */
+			continue;
+		}
+		start = PFN_UP(boot_mem_map.map[i].addr);
+		end = PFN_DOWN(boot_mem_map.map[i].addr
+				+ boot_mem_map.map[i].size);
+		node = pa_to_nid(boot_mem_map.map[i].addr);
+		nd = __node_data + node;
+
+		if (max_low_pfn < end)
+			max_low_pfn = end;
+		if (min_low_pfn > start)
+			min_low_pfn = start;
+
+		memblock_add_node(PFN_PHYS(start), PFN_PHYS(end - start), node);
+
+		if (nd->endpfn == 0) {
+			nd->startpfn = start;
+			nd->endpfn = end;
+		} else {
+			if (nd->startpfn > start)
+				nd->startpfn = start;
+			if (nd->endpfn < end)
+				nd->endpfn = end;
+		}
+		if (is_usable && (nd->startmempfn == 0 || start < nd->startmempfn))
+			nd->startmempfn = start;
+	}
+	num_physpages = 0;
+
+	for_each_online_node(node) {
+		unsigned long bootmap_size;
+		struct node_data *nd = __node_data + node;
+		if (nd->endpfn == 0)
+			continue;
+		NODE_DATA(node)->bdata = &bootmem_node_data[node];
+		bootmap_size = init_bootmem_node(NODE_DATA(node), nd->startmempfn, nd->startpfn,  nd->endpfn);
+
+		for (i = 0; i < boot_mem_map.nr_map; i++) {
+			int map_nid;
+			bool is_init;
+
+			switch (boot_mem_map.map[i].type) {
+			case BOOT_MEM_RAM:
+				is_init = false;
+				break;
+			case BOOT_MEM_INIT_RAM:
+				is_init = true;
+				break;
+			default:
+				/* Not usable memory */
+				continue;
+			}
+			map_nid = pa_to_nid(boot_mem_map.map[i].addr);
+			if (map_nid != node)
+				continue;
+			memory_present(node,
+				       PFN_DOWN(boot_mem_map.map[i].addr),
+				       PFN_UP(boot_mem_map.map[i].addr + boot_mem_map.map[i].size));
+			if (!is_init) {
+				num_physpages += PFN_DOWN(boot_mem_map.map[i].size);
+				memblock_add_node(boot_mem_map.map[i].addr, boot_mem_map.map[i].size, node);
+				free_bootmem_node(NODE_DATA(node), boot_mem_map.map[i].addr, boot_mem_map.map[i].size);
+			}
+		}
+		reserve_bootmem(PFN_PHYS(nd->startmempfn), bootmap_size, BOOTMEM_DEFAULT);
+	}
+}
+
 /*
  * Emit one character to the boot UART.	 Exported for use by the
  * watchdog timer.
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index f79817b..7c3fcf1 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -313,6 +313,7 @@ static void octeon_smp_finish(void)
 	octeon_user_io_init();
 	per_cpu(cpu_state, smp_processor_id()) = CPU_ONLINE;
 	mb();
+	octeon_numa_cpu_online();
 
 	/* to generate the first CPU timer interrupt */
 	write_c0_compare(read_c0_count() + mips_hpt_frequency / HZ);
diff --git a/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h b/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
new file mode 100644
index 0000000..3d8d1de
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
@@ -0,0 +1,8 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H
+#define _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H
+
+void mach_bootmem_init(void);
+
+#define mach_bootmem_init mach_bootmem_init
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H */
diff --git a/arch/mips/include/asm/mach-cavium-octeon/mmzone.h b/arch/mips/include/asm/mach-cavium-octeon/mmzone.h
new file mode 100644
index 0000000..547098c
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/mmzone.h
@@ -0,0 +1,20 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_MMZONE_H
+#define _ASM_MACH_CAVIUM_OCTEON_MMZONE_H
+
+struct node_data {
+#ifdef CONFIG_NUMA
+	struct pglist_data pglist;
+	struct cpumask cpumask_on_node;
+#endif
+	unsigned long startmempfn;
+	unsigned long startpfn;
+	unsigned long endpfn;
+};
+
+extern struct node_data __node_data[];
+
+#ifdef CONFIG_NUMA
+#define NODE_DATA(n)		(&__node_data[(n)].pglist)
+#endif
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_MMZONE_H */
diff --git a/arch/mips/include/asm/mach-cavium-octeon/topology.h b/arch/mips/include/asm/mach-cavium-octeon/topology.h
new file mode 100644
index 0000000..76a8c2a
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/topology.h
@@ -0,0 +1,42 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H
+#define _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H
+
+#ifdef CONFIG_NUMA
+
+static inline int cpu_to_node(int cpu)
+{
+	return (cpu_logical_map(cpu) >> 7) & 7;
+}
+
+static inline struct cpumask *cpumask_of_node(int node)
+{
+	if (node == -1)
+		return cpu_all_mask;
+	return &__node_data[node].cpumask_on_node;
+}
+
+static inline int parent_node(int node)
+{
+	return node;
+}
+
+struct pci_bus;
+static inline int pcibus_to_node(struct pci_bus *bus)
+{
+	return 0;
+}
+
+static inline struct cpumask *cpumask_of_pcibus(struct pci_bus *bus)
+{
+	return cpumask_of_node(pcibus_to_node(bus));
+}
+#endif /* CONFIG_NUMA */
+
+static inline int pa_to_nid(u64 pa)
+{
+	return (pa >> 40) & 7;
+}
+
+#include <asm-generic/topology.h>
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H */
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 546c329..cd51ec2 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -469,6 +469,13 @@ void octeon_setup_smp(void);
 #else
 static inline void octeon_setup_smp(void) {}
 #endif
+#ifdef CONFIG_NUMA
+void octeon_setup_numa(void);
+void octeon_numa_cpu_online(void);
+#else
+static inline void octeon_setup_numa(void) {}
+static inline void octeon_numa_cpu_online(void) {}
+#endif
 
 extern struct semaphore octeon_bootbus_sem;
 
-- 
2.6.2

