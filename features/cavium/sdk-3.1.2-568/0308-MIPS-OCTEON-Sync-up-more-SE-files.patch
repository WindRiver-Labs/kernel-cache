From a80ba725e1d1b8c6952b2c638d8a9b422e96f721 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Wed, 25 Sep 2013 10:29:21 -0700
Subject: [PATCH 308/974] MIPS: OCTEON: Sync up more SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-agl.c       | 13 ++++++
 .../mips/cavium-octeon/executive/cvmx-helper-agl.c | 22 +++++++---
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       | 50 +++++++++++-----------
 3 files changed, 53 insertions(+), 32 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-agl.c b/arch/mips/cavium-octeon/executive/cvmx-agl.c
index ba46b94..c24c4d3 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-agl.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-agl.c
@@ -211,5 +211,18 @@ int cvmx_agl_link_set(int port, cvmx_helper_link_info_t link_info, int mode)
 	agl_gmx_prtx.s.en = 1;
 	cvmx_write_csr(CVMX_AGL_GMX_PRTX_CFG(port), agl_gmx_prtx.u64);
 
+	if (OCTEON_IS_OCTEON3()) {
+		union cvmx_agl_prtx_ctl agl_prtx_ctl;
+		/* Enable the interface, set clkrst */
+		agl_prtx_ctl.u64 = cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
+		agl_prtx_ctl.s.clkrst = 1;
+		cvmx_write_csr(CVMX_AGL_PRTX_CTL(port), agl_prtx_ctl.u64);
+		cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
+		agl_prtx_ctl.s.enable = 1;
+		cvmx_write_csr(CVMX_AGL_PRTX_CTL(port), agl_prtx_ctl.u64);
+		/* Read the value back to force the previous write */
+		cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
+	}
+
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c b/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
index 5ae133b..c3e6ce2 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
@@ -136,10 +136,16 @@ int __cvmx_helper_agl_probe(int interface)
 	agl_prtx_ctl.s.clkrst = 0;
 	agl_prtx_ctl.s.dllrst = 0;
 	agl_prtx_ctl.s.clktx_byp = 0;
+
+
+	if (OCTEON_IS_OCTEON3()) {
+		agl_prtx_ctl.s.refclk_sel = 0;
+		agl_prtx_ctl.s.clkrx_set = 0x0;
+		agl_prtx_ctl.s.clkrx_byp = 1;
+	}
 	cvmx_write_csr(CVMX_AGL_PRTX_CTL(port), agl_prtx_ctl.u64);
 	/* Force write out before wait */
 	cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
-
 	/*
 	 * Wait for the DLL to lock. External 125 MHz reference clock must be
 	 * stable at this point.
@@ -153,12 +159,14 @@ int __cvmx_helper_agl_probe(int interface)
 	/* Force write out before wait */
 	cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
 
-	/* Enable the interface */
-	agl_prtx_ctl.u64 = cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
-	agl_prtx_ctl.s.enable = 1;
-	cvmx_write_csr(CVMX_AGL_PRTX_CTL(port), agl_prtx_ctl.u64);
-	/* Read the value back to force the previous write */
-	agl_prtx_ctl.u64 = cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
+	if (!OCTEON_IS_OCTEON3()) {
+		/* Enable the interface */
+		agl_prtx_ctl.u64 = cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
+		agl_prtx_ctl.s.enable = 1;
+		cvmx_write_csr(CVMX_AGL_PRTX_CTL(port), agl_prtx_ctl.u64);
+		/* Read the value back to force the previous write */
+		agl_prtx_ctl.u64 = cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
+	}
 
 	/* Enable the compensation controller */
 	agl_prtx_ctl.u64 = cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 38f9bc6..f178f8f 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 88225 $<hr>
+ * <hr>$Revision: 88712 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -56,6 +56,12 @@
 #include <asm/octeon/cvmx-sriomaintx-defs.h>
 #include <asm/octeon/cvmx-pciercx-defs.h>
 #include <asm/octeon/cvmx-pemx-defs.h>
+#elif defined(CVMX_BUILD_FOR_UBOOT)
+#include <common.h>
+#include <asm/arch/cvmx.h>
+#include <asm/arch/cvmx-bootmem.h>
+#include <asm/arch/cvmx-helper-jtag.h>
+#include <asm/arch/cvmx-qlm.h>
 #else
 #include "cvmx.h"
 #include "cvmx-bootmem.h"
@@ -63,6 +69,10 @@
 #include "cvmx-qlm.h"
 #endif
 
+#ifdef CVMX_BUILD_FOR_UBOOT
+DECLARE_GLOBAL_DATA_PTR;
+#endif
+
 /**
  * The JTAG chain for CN52XX and CN56XX is 4 * 268 bits long, or 1072.
  * CN5XXX full chain shift is:
@@ -236,6 +246,9 @@ void cvmx_qlm_init(void)
 	static uint64_t qlm_base = 0;
 	const cvmx_bootmem_named_block_desc_t *desc;
 
+	if (OCTEON_IS_OCTEON3())
+		return;
+
 #ifndef CVMX_BUILD_FOR_LINUX_HOST
 	/* Skip actual JTAG accesses on simulator */
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
@@ -695,33 +708,17 @@ int cvmx_qlm_get_gbaud_mhz(int qlm)
 			return 0;	/* Disabled */
 		}
 	} else if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
-		cvmx_gserx_dlmx_mpll_status_t mpll_status;
-		cvmx_gserx_dlmx_ref_clkdiv2_t ref_clkdiv2;
 		cvmx_gserx_dlmx_mpll_multiplier_t mpll_multiplier;
 		uint64_t meas_refclock;
-		uint64_t mhz;
+		uint64_t freq;
 
-		/* Return zero if the PLL hasn't locked */
-		mpll_status.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_MPLL_STATUS(qlm, 0));
-#ifdef CVMX_BUILD_FOR_LINUX_HOST
-		if (mpll_status.s.mpll_status == 0)
-			return 0;
-#else
-		if ((cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM)
-	    	    && (mpll_status.s.mpll_status == 0))
-			return 0;
-#endif
-		meas_refclock = cvmx_qlm_measure_clock(qlm);
-		mhz = meas_refclock / 1000000;
 		/* Measure the reference clock */
-		/* Divide it by two if the DLM is configure that way */
-		ref_clkdiv2.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_REF_CLKDIV2(qlm, 0));
-		if (ref_clkdiv2.s.ref_clkdiv2)
-			mhz /= 2;
+		meas_refclock = cvmx_qlm_measure_clock(qlm);
 		/* Multiply to get the final frequency */
 		mpll_multiplier.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_MPLL_MULTIPLIER(qlm, 0));
-		mhz *= mpll_multiplier.s.mpll_multiplier;
-		return mhz;
+		freq = meas_refclock * mpll_multiplier.s.mpll_multiplier;
+		freq = (freq + 500000) / 1000000;
+		return freq;
 	}
 	return 0;
 }
@@ -732,7 +729,7 @@ static enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn70xx(int qlm)
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
 		union cvmx_gserx_dlmx_phy_reset phy_reset;
 
-		phy_reset.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_PHY_RESET(0, qlm));
+		phy_reset.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_PHY_RESET(qlm, 0));
 		if (phy_reset.s.phy_reset)
 			return CVMX_QLM_MODE_DISABLED;
 
@@ -1019,7 +1016,7 @@ static enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn78xx(int qlm)
 	 * Until gser configuration is in place, we hard code the
 	 * qlm mode here. This means that for the time being, this
 	 * function and __cvmx_get_mode_cn78xx() have to be in sync
-	 * since they are both hard coded. Note that register 
+	 * since they are both hard coded. Note that register
 	 * CVMX_MIO_QLMX_CFG is not yet modeled by the simulator.
 	 */
 	switch(qlm) {
@@ -1069,7 +1066,10 @@ int cvmx_qlm_measure_clock(int qlm)
 
 	/* Force the reference to 156.25Mhz when running in simulation.
 	   This supports the most speeds */
-#ifndef CVMX_BUILD_FOR_LINUX_HOST
+#ifdef CVMX_BUILD_FOR_UBOOT
+	if (gd->board_type == CVMX_BOARD_TYPE_SIM)
+		return 156250000;
+#elif !defined(CVMX_BUILD_FOR_LINUX_HOST)
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
 		return 156250000;
 #endif
-- 
2.6.2

