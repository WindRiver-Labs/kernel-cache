From 610a2efd0fc4119fec33fa0c4325e17945f6c97e Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 25 Sep 2013 10:29:21 -0700
Subject: [PATCH 305/974] MIPS: OCTEON: Add preliminary cib_sata interrupt
 controller support.

WIP.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c | 136 +++++++++++++++++++++++++++++++++++
 1 file changed, 136 insertions(+)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index 9103f52..c8b3300 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -2391,11 +2391,147 @@ static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
 	return 0;
 }
 
+struct octeon_irq_cibsata_data {
+	int bit;
+};
+
+static DEFINE_RAW_SPINLOCK(octeon_irq_cibsata_lock);
+
+static void octeon_irq_cibsata_enable(struct irq_data *data)
+{
+	unsigned long flags;
+	u64 en;
+	struct octeon_irq_cibsata_data *cd = irq_data_get_irq_chip_data(data);
+
+	raw_spin_lock_irqsave(&octeon_irq_cibsata_lock, flags);
+	en = cvmx_read_csr(CVMX_CIU_CIB_SATA_ENX(0));
+	en |= 1ull < cd->bit;
+	cvmx_write_csr(CVMX_CIU_CIB_SATA_ENX(0), en);
+	raw_spin_unlock_irqrestore(&octeon_irq_cibsata_lock, flags);
+}
+
+static void octeon_irq_cibsata_disable(struct irq_data *data)
+{
+	unsigned long flags;
+	u64 en;
+	struct octeon_irq_cibsata_data *cd = irq_data_get_irq_chip_data(data);
+
+	raw_spin_lock_irqsave(&octeon_irq_cibsata_lock, flags);
+	en = cvmx_read_csr(CVMX_CIU_CIB_SATA_ENX(0));
+	en &= ~(1ull < cd->bit);
+	cvmx_write_csr(CVMX_CIU_CIB_SATA_ENX(0), en);
+	raw_spin_unlock_irqrestore(&octeon_irq_cibsata_lock, flags);
+}
+
+static struct irq_chip octeon_irq_chip_cibsata = {
+	.name = "CIU3",
+	.irq_enable = octeon_irq_cibsata_enable,
+	.irq_disable = octeon_irq_cibsata_disable,
+	.irq_mask = octeon_irq_cibsata_disable,
+	.irq_unmask = octeon_irq_cibsata_enable,
+};
+
+static int octeon_irq_cibsata_xlat(struct irq_domain *d,
+				   struct device_node *node,
+				   const u32 *intspec,
+				   unsigned int intsize,
+				   unsigned long *out_hwirq,
+				   unsigned int *out_type)
+{
+	*out_hwirq = intspec[0];
+	*out_type = 0;
+	return 0;
+}
+
+static int octeon_irq_cibsata_map(struct irq_domain *d,
+				  unsigned int virq, irq_hw_number_t hw)
+{
+	struct octeon_irq_cibsata_data *cd;
+
+	cd = kmalloc(sizeof(*cd), GFP_KERNEL);
+	cd->bit = hw;
+
+	irq_set_chip_and_handler(virq, &octeon_irq_chip_cibsata,
+				 handle_simple_irq);
+	irq_set_chip_data(virq, cd);
+	return 0;
+}
+
+static struct irq_domain_ops octeon_irq_domain_cibsata_ops = {
+	.map = octeon_irq_cibsata_map,
+	.unmap = octeon_irq_free_cd,
+	.xlate = octeon_irq_cibsata_xlat,
+};
+
+/* Chain to real handler. */
+static irqreturn_t octeon_irq_cibsata_handler(int my_irq, void *data)
+{
+	u64 en;
+	u64 raw;
+	u64 bits;
+	int i;
+	int irq;
+	struct irq_domain *cibsata_domain = data;
+
+	en = cvmx_read_csr(CVMX_CIU_CIB_SATA_ENX(0));
+	raw = cvmx_read_csr(CVMX_CIU_CIB_SATA_RAWX(0));
+
+	bits = en & raw;
+
+	/* Acknologe the bits we will be sending. */
+	cvmx_write_csr(CVMX_CIU_CIB_SATA_RAWX(0), bits);
+
+	for (i = 0; i < 4; i++) {
+		if ((bits & 1ull << i) == 0)
+			continue;
+		irq = irq_find_mapping(cibsata_domain, i);
+		if (!irq)
+			pr_err("ERROR: No mapping for cibsata %d\n", i);
+		else
+			generic_handle_irq(irq);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init octeon_irq_init_cibsata(struct device_node *ciu_node,
+					  struct device_node *parent)
+{
+	int parent_irq;
+	int r;
+	struct irq_domain *cibsata_domain;
+
+	parent_irq = irq_of_parse_and_map(ciu_node, 0);
+	if (!parent_irq) {
+		pr_err("ERROR: Couldn't acquire parent_irq\n.");
+		return -EINVAL;
+	}
+
+	cibsata_domain = irq_domain_add_linear(ciu_node, 4,
+					       &octeon_irq_domain_cibsata_ops,
+					       NULL);
+	if (!cibsata_domain) {
+		pr_err("ERROR: Couldn't irq_domain_add_linear()\n.");
+		return -ENOMEM;
+	}
+
+	r = request_irq(parent_irq, octeon_irq_cibsata_handler, IRQF_NO_THREAD,
+			"cibsata", cibsata_domain);
+	if (r) {
+		pr_err("request_irq cibsata failed %d\n", r);
+		return r;
+	}
+	pr_info("interrupt controller probed: %s\n", ciu_node->name);
+	return 0;
+}
+
 static struct of_device_id __initdata ciu_types[] = {
 	{.compatible = "cavium,octeon-3860-ciu", .data = octeon_irq_init_ciu},
 	{.compatible = "cavium,octeon-3860-gpio", .data = octeon_irq_init_gpio},
 	{.compatible = "cavium,octeon-6880-ciu2", .data = octeon_irq_init_ciu2},
 	{.compatible = "cavium,octeon-7880-ciu3", .data = octeon_irq_init_ciu3},
+	{.compatible = "cavium,octeon-7130-cibsata", .data = octeon_irq_init_cibsata},
+	//{.compatible = "cavium,octeon-7130-cibusb", .data = octeon_irq_init_cibusb},
 	{}
 };
 
-- 
2.6.2

