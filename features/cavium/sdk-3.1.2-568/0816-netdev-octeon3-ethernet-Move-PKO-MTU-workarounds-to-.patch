From daf9382fd14d2be85f275189d74777fe8b35aad2 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 7 Jul 2014 18:05:50 -0700
Subject: [PATCH 816/974] netdev: octeon3-ethernet: Move PKO MTU workarounds to
 octeon3-ethernet.c

The PKO is in the domain of the octeon3-ethernet.c code, so put these
things there.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-port.c  | 53 --------------------------
 drivers/net/ethernet/octeon/octeon3-ethernet.c | 51 ++++++++++++++++++++++++-
 2 files changed, 49 insertions(+), 55 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 45fbdf4..cd4435d 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -34,7 +34,6 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/list.h>
-#include <linux/if_vlan.h>
 
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-util.h>
@@ -411,46 +410,6 @@ int bgx_port_disable(struct net_device *netdev)
 }
 EXPORT_SYMBOL(bgx_port_disable);
 
-static int get_max_78xx_pass1_x_mtu(int xiface, int index)
-{
-	int	fifo_size;
-	int	max_mtu = 1500;
-
-	/* Due to errata PKO-20096, the mtu must be limited.
-	 * PKO-20096 causes PKO to lock up when calculating the L4
-	 * checksum for large packets. How large the packets can be
-	 * depends on the amount of pko fifo assigned to the port.
-	 *
-	 *   FIFO size                Max frame size
-	 *	2.5 KB				1920
-	 *	5.0 KB				4480
-	 *     10.0 KB				9600
-	 *
-	 * The maximum mtu is set to the largest frame size minus the
-	 * l2 header.
-	 */
-	fifo_size = cvmx_pko3_port_fifo_size(xiface, index);
-
-	switch (fifo_size) {
-	case 2560:
-		max_mtu = 1920 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
-		break;
-
-	case 5120:
-		max_mtu = 4480 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
-		break;
-
-	case 10240:
-		max_mtu = 9600 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
-		break;
-
-	default:
-		break;
-	}
-
-	return max_mtu;
-}
-
 int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	union cvmx_bgxx_cmrx_config cfg;
@@ -460,17 +419,6 @@ int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 	if (new_mtu < 60 || new_mtu > 65392)
 		return -EINVAL;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
-		int	max_mtu;
-
-		max_mtu = get_max_78xx_pass1_x_mtu(priv->xiface, priv->index);
-		if (new_mtu > max_mtu) {
-			new_mtu = max_mtu;
-			netdev_warn(netdev, "Maximum MTU supported is %d",
-				    max_mtu);
-		}
-	}
-
 	netdev->mtu = new_mtu;
 
 	max_frame = round_up(new_mtu + ETH_HLEN + ETH_FCS_LEN, 8);
@@ -485,7 +433,6 @@ int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 				    CVMX_BGXX_SMUX_RX_JABBER(priv->index, priv->bgx_interface),
 				    max_frame);
 
-
 	return 0;
 }
 EXPORT_SYMBOL(bgx_port_change_mtu);
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index 6201373..709c6b0e 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -35,6 +35,7 @@
 #include <linux/platform_device.h>
 #include <linux/ip.h>
 #include <linux/ipv6.h>
+#include <linux/if_vlan.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
@@ -1302,6 +1303,52 @@ static const struct ethtool_ops octeon3_ethtool_ops = {
 	.get_link = ethtool_op_get_link,
 };
 
+static int octeon3_eth_ndo_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		int fifo_size;
+		int max_mtu = 1500;
+		struct octeon3_ethernet *priv = netdev_priv(netdev);
+
+		/* On 78XX-Pass1 the mtu must be limited.  The PKO may
+		 * to lock up when calculating the L4 checksum for
+		 * large packets. How large the packets can be depends
+		 * on the amount of pko fifo assigned to the port.
+		 *
+		 *   FIFO size                Max frame size
+		 *	2.5 KB				1920
+		 *	5.0 KB				4480
+		 *     10.0 KB				9600
+		 *
+		 * The maximum mtu is set to the largest frame size minus the
+		 * l2 header.
+		 */
+		fifo_size = cvmx_pko3_port_fifo_size(priv->xiface, priv->port_index);
+
+		switch (fifo_size) {
+		case 2560:
+			max_mtu = 1920 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+			break;
+
+		case 5120:
+			max_mtu = 4480 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+			break;
+
+		case 10240:
+			max_mtu = 9600 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+			break;
+
+		default:
+			break;
+		}
+		if (new_mtu > max_mtu) {
+			netdev_warn(netdev, "Maximum MTU supported is %d", max_mtu);
+			return -EINVAL;
+		}
+	}
+	return bgx_port_change_mtu(netdev, new_mtu);
+}
+
 static int octeon3_eth_ndo_init(struct net_device *netdev)
 {
 	struct octeon3_ethernet *priv = netdev_priv(netdev);
@@ -1499,7 +1546,7 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 		eth_hw_addr_random(netdev);
 	}
 	bgx_port_set_rx_filtering(netdev);
-	bgx_port_change_mtu(netdev, netdev->mtu);
+	octeon3_eth_ndo_change_mtu(netdev, netdev->mtu);
 
 	octeon3_napi_init_node(priv->numa_node, netdev);
 
@@ -2016,7 +2063,7 @@ static const struct net_device_ops octeon3_eth_netdev_ops = {
 	.ndo_get_stats64	= octeon3_eth_ndo_get_stats64,
 	.ndo_set_rx_mode	= bgx_port_set_rx_filtering,
 	.ndo_set_mac_address	= octeon3_eth_set_mac_address,
-	.ndo_change_mtu		= bgx_port_change_mtu,
+	.ndo_change_mtu		= octeon3_eth_ndo_change_mtu,
 	.ndo_do_ioctl		= bgx_port_do_ioctl,
 };
 
-- 
2.6.2

