From aef2d3b5f7bfc932c874e6a321f055ed23ac524a Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 19 Feb 2014 13:46:59 -0800
Subject: [PATCH 594/974] MIPS: OCTEON: Update S.E. to r100235

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-dma-engine.c |    3 +-
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |    5 +
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |   23 +-
 .../mips/cavium-octeon/executive/cvmx-helper-npi.c |    6 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |   73 +-
 .../cavium-octeon/executive/cvmx-helper-util.c     |   19 +-
 arch/mips/cavium-octeon/executive/cvmx-ocla.c      |    7 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |  151 +-
 arch/mips/cavium-octeon/executive/cvmx-pki.c       |   34 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |   11 +-
 .../cavium-octeon/executive/cvmx-sso-resources.c   |   29 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-helper-pki.h     |    3 +-
 arch/mips/include/asm/octeon/cvmx-helper-util.h    |   63 +-
 arch/mips/include/asm/octeon/cvmx-pki.h            |   49 +-
 arch/mips/include/asm/octeon/cvmx-pow.h            |   76 +-
 arch/mips/include/asm/octeon/cvmx-sata-defs.h      |  278 +-
 arch/mips/include/asm/octeon/cvmx-uahcx-defs.h     | 1244 +++++----
 arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h   | 2723 +++++++++++---------
 arch/mips/include/asm/octeon/cvmx-wqe.h            |   55 +-
 20 files changed, 2740 insertions(+), 2118 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c b/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
index 1f0dee3..e65035c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
@@ -43,7 +43,7 @@
  * Interface to the PCI / PCIe DMA engines. These are only avialable
  * on chips with PCI / PCIe.
  *
- * <hr>$Revision: 95866 $<hr>
+ * <hr>$Revision: 100051 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/export.h>
@@ -377,6 +377,7 @@ static inline int __cvmx_dma_engine_build_internal_pointers(cvmx_dma_engine_buff
 			chunk = 8191;
 		buffers[segments].u64 = 0;
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+			buffers[segments].internal_cn78xx.ac = 1;
 			buffers[segments].internal_cn78xx.size = chunk;
 			buffers[segments].internal_cn78xx.addr = address;
 		} else {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 33e79f2..1e96046 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -1134,6 +1134,11 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 		cmr_config.s.data_pkt_tx_en = 1;
 		cmr_config.s.data_pkt_rx_en = 1;
 		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+		res = __cvmx_helper_bgx_xaui_link_init(index, xiface);
+		if (res == -1) {
+			cvmx_dprintf("Failed to get BGX(%d,%d) link\n", interface, index);
+			continue;
+		}
 	}
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index c421678..2a59d0b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -945,13 +945,22 @@ int __cvmx_helper_init_port_config_data(void)
 		}
 		/* Initialize pknd and bpid */
 		for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
-			n = cvmx_helper_interface_enumerate(i);
-			for (j = 0; j < n; j++) {
-				cvmx_cfg_port[0][i][j].ccpp_pknd = pknd++;
-				cvmx_cfg_port[0][i][j].ccpp_bpid = bpid++;
-			}
-		}
-
+                        n = cvmx_helper_interface_enumerate(i);
+                        if (cvmx_helper_interface_get_mode(i) == CVMX_HELPER_INTERFACE_MODE_NPI &&
+                            OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+                                for (j = 0; j < n; j++) {
+                                        cvmx_cfg_port[0][i][j].ccpp_pknd = pknd;
+                                        cvmx_cfg_port[0][i][j].ccpp_bpid = bpid;
+                                }
+                                pknd++;
+                                bpid++;
+                        } else {
+                                for (j = 0; j < n; j++) {
+                                        cvmx_cfg_port[0][i][j].ccpp_pknd = pknd++;
+                                        cvmx_cfg_port[0][i][j].ccpp_bpid = bpid++;
+                                }
+                        }
+                }
 		cvmx_helper_cfg_assert(pknd <= CVMX_HELPER_CFG_MAX_PIP_PKND);
 		cvmx_helper_cfg_assert(bpid <= CVMX_HELPER_CFG_MAX_PIP_BPID);
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
index a8d6ca7..ad74f7b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
@@ -43,7 +43,7 @@
  * Functions for NPI initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 97463 $<hr>
+ * <hr>$Revision: 99993 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -85,7 +85,9 @@ int __cvmx_helper_npi_probe(int interface)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
 			return 32;
-	} else if (!(OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1_X) ||
+        } else if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+                return 64;
+        } else if (!(OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1_X) ||
 		   OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_X) ||
 		   OCTEON_IS_MODEL(OCTEON_CN31XX) ||
 		   OCTEON_IS_MODEL(OCTEON_CN50XX) ||
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index 7b2b4ca..776b40b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -223,6 +223,29 @@ int __cvmx_helper_pki_setup_fpa_pools(int node)
 }
 #endif
 
+/**
+ * This function writes qpg entry at specified offset in hardware
+ *
+ * @param node		node number
+ * @param index		offset in qpg entry to write to.
+ * @param padd		port address for channel calculation
+ * @param aura		aura number to send packet to
+ * @param group_ok	group number to send packet to if there is no error
+ * @param group_bad	group number to send packet  to if there is error
+ */
+static void cvmx_pki_write_qpg_entry(int node, int index, int padd, int aura,
+					      int group_ok, int group_bad)
+{
+	cvmx_pki_qpg_tblx_t qpg_tbl;
+	qpg_tbl.u64 = cvmx_read_csr_node(node, CVMX_PKI_QPG_TBLX(index));
+	qpg_tbl.s.padd = padd;
+	qpg_tbl.s.laura = aura;
+	qpg_tbl.s.grp_ok = group_ok;
+	qpg_tbl.s.grp_bad = group_bad;
+	cvmx_write_csr_node(node, CVMX_PKI_QPG_TBLX(index), qpg_tbl.u64);
+}
+
+
 int __cvmx_helper_setup_pki_qpg_table(int node)
 {
 	int offset;
@@ -241,31 +264,34 @@ int __cvmx_helper_setup_pki_qpg_table(int node)
 	return 0;
 }
 
-#if 0
-int __cvmx_helper_setup_pki_pcam_table(int node)
+void __cvmx_helper_pki_set_ltype_map(int node)
 {
-	uint64_t index;
-	int bank;
-
-	struct cvmx_pki_pcam_config *pcam_cfg;
-	index = pki_profiles[node].pcam_list.index;
-
-	while (index--) {
-		pcam_cfg = &pki_profiles[node].pcam_list.pcam_cfg[index];
-		bank = pcam_cfg->pcam_input.field % 2;
-		pcam_cfg->entry_num = cvmx_pki_pcam_alloc_entry(node, pcam_cfg->entry_num, bank, pcam_cfg->cluster_mask);
-		if (pcam_cfg->entry_num == -1) {
-			cvmx_dprintf("ERROR: Allocating pcam entry\n");
-			return -1;
-		}
-		cvmx_pki_pcam_write_entry(node, pcam_cfg->entry_num,
-					  pcam_cfg->cluster_mask, pcam_cfg->pcam_input,
-					  pcam_cfg->pcam_action);
-	}
-	return 0;
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_NONE, CVMX_PKI_BELTYPE_NONE);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_ENET, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_VLAN, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_SNAP_PAYLD, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_ARP, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_RARP, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_IP4, CVMX_PKI_BELTYPE_IP4);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_IP4_OPT, CVMX_PKI_BELTYPE_IP4);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_IP6, CVMX_PKI_BELTYPE_IP6);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_IP6_OPT, CVMX_PKI_BELTYPE_IP6);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_IPSEC_ESP, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_IPFRAG, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_IPCOMP, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_TCP, CVMX_PKI_BELTYPE_TCP);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_UDP, CVMX_PKI_BELTYPE_UDP);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_SCTP, CVMX_PKI_BELTYPE_SCTP);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_UDP_VXLAN, CVMX_PKI_BELTYPE_UDP);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_GRE, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_NVGRE, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_GTP, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_SW28, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_SW29, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_SW30, CVMX_PKI_BELTYPE_MISC);
+        cvmx_pki_write_ltype_map(node, CVMX_PKI_LTYPE_E_SW31, CVMX_PKI_BELTYPE_MISC);
 }
-#endif
-
+EXPORT_SYMBOL(__cvmx_helper_pki_set_ltype_map);
 /**
  * This function installs the default VLAN entries to identify
  * the VLAN and set WQE[vv], WQE[vs] if VLAN is found. In 78XX
@@ -357,6 +383,7 @@ void cvmx_helper_pki_enable(int node)
 
 int __cvmx_helper_pki_global_setup(int node)
 {
+        __cvmx_helper_pki_set_ltype_map(node);
 	if (!cvmx_pki_dflt_init[node])
 		return 0;
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 210c680..36ec03f 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -346,15 +346,6 @@ int cvmx_helper_dump_packet(cvmx_wqe_t *work)
 	return 0;
 }
 
-void copy_ptr_maybe_swap(uint64_t *dst, uint64_t *src, bool swap)
-{
-        uint64_t t;
-
-        t = *src;
-        if (swap)
-                t = __builtin_bswap64 (t);
-        *dst = t;
-}
 
 /**
  * Extract packet data buffer pointer from work queue entry.
@@ -377,7 +368,7 @@ cvmx_buf_ptr_t cvmx_wqe_get_packet_ptr(cvmx_wqe_t *work)
 		unsigned pool, bufs;
 
 		/* In case of repeated calls of this function */
-		if (wqe->pki_wqe_translated) {
+		if (wqe->pki_wqe_translated || wqe->word2.software ) {
 			optr.u64 = wqe->packet_ptr.u64;
 			return optr;
 		}
@@ -408,15 +399,13 @@ cvmx_buf_ptr_t cvmx_wqe_get_packet_ptr(cvmx_wqe_t *work)
 
 			vptr = cvmx_phys_to_ptr(lptr.s.addr);
 
+                        memcpy(&nptr, vptr - 8, 8);
 			/* Errata (PKI-20776) PKI_BUFLINK_S's are endian-swapped
                         CN78XX pass 1.x has a bug where the packet pointer in each segment is
                         written in the opposite endianness of the configured mode. Fix these
                         here */
                         if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
-                                copy_ptr_maybe_swap((uint64_t*)&nptr, (uint64_t*)(vptr - 8), 1);
-                        else
-                                copy_ptr_maybe_swap((uint64_t*)&nptr, (uint64_t*)(vptr - 8), 0);
-
+                                nptr.u64 = __builtin_bswap64(nptr.u64);
 			lptr.u64=0;
 			lptr.s.pool = pool;
 			lptr.s.addr = nptr.addr;
@@ -434,7 +423,7 @@ cvmx_buf_ptr_t cvmx_wqe_get_packet_ptr(cvmx_wqe_t *work)
 	} else {
 		cvmx_buf_ptr_t bptr;
 
-		if ( work->word2.s.bufs > 0)
+		if (work->word2.s.bufs > 0 || work->word2.s.software)
 			return work->packet_ptr;
 
 		/* data is only in WQE, convert it into a buf_ptr */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-ocla.c b/arch/mips/cavium-octeon/executive/cvmx-ocla.c
index c909a30..dedfc6b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-ocla.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-ocla.c
@@ -472,7 +472,12 @@ int cvmx_ocla_init(int			node,
 		cvmx_write_csr_node(node, CVMX_OCLAX_STACK_STORE_CNT(ix), 0);
 
 		limit.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_FIFO_LIMIT(ix));
-		limit.s.ddr = 0;
+		/*
+		 * To accomodate 78xx'x pass1 bug, ddr must be:
+		 * ddr > 28
+		 * ddr % 26 == 0
+		 */
+		limit.s.ddr = 52;
 		cvmx_write_csr_node(node, CVMX_OCLAX_FIFO_LIMIT(ix), limit.u64);
 	}
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 21ba947..e1ba3fb 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,12 +42,13 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 98966 $<hr>
+ * <hr>$Revision: 100137 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-clock.h>
 #include <asm/octeon/cvmx-ciu-defs.h>
+#include <asm/octeon/cvmx-dtx-defs.h>
 #include <asm/octeon/cvmx-dpi-defs.h>
 #include <asm/octeon/cvmx-gserx-defs.h>
 #include <asm/octeon/cvmx-mio-defs.h>
@@ -431,6 +432,53 @@ static void __cvmx_pcie_rc_initialize_config_space(int pcie_port)
 		cfg452.s.lme = (pem_cfg.cn78xx.lanes8) ? 0xf : 0x7;
 		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG452(pcie_port), cfg452.u32);
 	}
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		cvmx_pciercx_cfg089_t cfg089;
+		cvmx_pciercx_cfg090_t cfg090;
+		cvmx_pciercx_cfg091_t cfg091;
+		cvmx_pciercx_cfg092_t cfg092;
+		cvmx_pciercx_cfg548_t cfg548;
+		cvmx_pciercx_cfg554_t cfg554;
+		/* Errata (GSER-21178) PCIe gen3 doesn't work */
+		/* The starting equalization hints are incorrect on CN78XX pass 1.x. Fix
+		them for the 8 possible lanes. It doesn't hurt to program them even for
+		lanes not in use */
+		cfg089.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG089(pcie_port));
+		cfg089.s.l1urph= 2;
+		cfg089.s.l1utp = 7;
+		cfg089.s.l0urph = 2;
+		cfg089.s.l0utp = 7;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG089(pcie_port), cfg089.u32);
+		cfg090.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG090(pcie_port));
+		cfg090.s.l3urph= 2;
+		cfg090.s.l3utp = 7;
+		cfg090.s.l2urph = 2;
+		cfg090.s.l2utp = 7;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG090(pcie_port), cfg090.u32);
+		cfg091.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG091(pcie_port));
+		cfg091.s.l5urph= 2;
+		cfg091.s.l5utp = 7;
+		cfg091.s.l4urph = 2;
+		cfg091.s.l4utp = 7;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG091(pcie_port), cfg091.u32);
+		cfg092.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG092(pcie_port));
+		cfg092.s.l7urph= 2;
+		cfg092.s.l7utp = 7;
+		cfg092.s.l6urph = 2;
+		cfg092.s.l6utp = 7;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG092(pcie_port), cfg092.u32);
+		/* FIXME: Disable phase 2 and phase 3 equalization */
+		cfg548.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG548(pcie_port));
+		cfg548.s.ep2p3d = 1;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG548(pcie_port), cfg548.u32);
+		/* Errata (GSER-21331) GEN3 Equalization may fail */
+		/* Disable preset #10 and disable the 2ms timeout */
+		cfg554.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG554(pcie_port));
+		cfg554.s.p23td = 1;
+		cfg554.s.prv = 0x3ff;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG554(pcie_port), cfg554.u32);
+	}
 }
 
 /**
@@ -947,9 +995,12 @@ retry:
 static int __cvmx_pcie_rc_initialize_link_gen2(int pcie_port)
 {
 	uint64_t start_cycle;
+	int try_gen3;
 
 	cvmx_pemx_ctl_status_t pem_ctl_status;
 	cvmx_pciercx_cfg032_t pciercx_cfg032;
+	cvmx_pciercx_cfg031_t pciercx_cfg031;
+	cvmx_pciercx_cfg040_t pciercx_cfg040;
 	cvmx_pciercx_cfg448_t pciercx_cfg448;
 
 	if (OCTEON_IS_OCTEON3()) {
@@ -959,6 +1010,22 @@ static int __cvmx_pcie_rc_initialize_link_gen2(int pcie_port)
 		}
 	}
 
+	/* Remember if the link should try Gen3. This is needed for the CN78XX
+	pass 1.x workaround below */
+	pciercx_cfg031.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG031(pcie_port));
+	try_gen3 = (pciercx_cfg031.s.mls == 3);
+
+	/* Errata (GSER-21178) PCIe gen3 doesn't work */
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && try_gen3) {
+		/* Force Gen1 for initial link bringup. We'll fix it later */
+		pciercx_cfg031.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG031(pcie_port));
+		pciercx_cfg031.s.mls = 1;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG031(pcie_port), pciercx_cfg031.u32);
+		pciercx_cfg040.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG040(pcie_port));
+		pciercx_cfg040.s.tls = 1;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG040(pcie_port), pciercx_cfg040.u32);
+	}
+
 	/* Bring up the link */
 	pem_ctl_status.u64 = cvmx_read_csr(CVMX_PEMX_CTL_STATUS(pcie_port));
 	pem_ctl_status.s.lnk_enb = 1;
@@ -974,6 +1041,82 @@ static int __cvmx_pcie_rc_initialize_link_gen2(int pcie_port)
 							 CVMX_PCIERCX_CFG032(pcie_port));
 	} while ((pciercx_cfg032.s.dlla == 0) || (pciercx_cfg032.s.lt == 1));
 
+	/* Errata (GSER-21178) PCIe gen3 doesn't work, continued */
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && try_gen3) {
+		cvmx_pciercx_cfg031_t cfg031;
+		cvmx_pciercx_cfg032_t cfg032;
+		cvmx_pciercx_cfg040_t cfg040;
+		cvmx_pciercx_cfg515_t cfg515;
+		cvmx_pemx_cfg_t pem_cfg;
+		int low_qlm, high_qlm;
+		int qlm, lane;
+
+		/* Enable gen3 speed selection */
+		cfg031.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG031(pcie_port));
+		cfg031.s.mls = 3;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG031(pcie_port), cfg031.u32);
+		cfg040.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG040(pcie_port));
+		cfg040.s.tls = 3;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG040(pcie_port), cfg040.u32);
+		/* Force a demand speed change */
+		cfg515.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG515(pcie_port));
+		cfg515.s.dsc = 1;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG515(pcie_port), cfg515.u32);
+		cvmx_wait_usec(500);
+
+		/* Wait up to 10ms for the link speed change to complete */
+		start_cycle = cvmx_get_cycle();
+		do {
+			if (cvmx_get_cycle() - start_cycle > cvmx_clock_get_rate(CVMX_CLOCK_CORE))
+				return -1;
+			cvmx_wait(10000);
+			pciercx_cfg032.u32 = cvmx_pcie_cfgx_read(pcie_port,
+							 CVMX_PCIERCX_CFG032(pcie_port));
+		} while (pciercx_cfg032.s.ls != 3);
+
+		pem_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(pcie_port));
+		low_qlm = pcie_port;  /* FIXME */
+		high_qlm = (pem_cfg.cn78xx.lanes8) ? low_qlm+1 : low_qlm;
+
+		/* Toggle cfg_rx_dll_locken_ovvrd_en and rx_resetn_ovrrd_en across
+		all QM lanes in use */
+		for (qlm = low_qlm; qlm <= high_qlm; qlm++) {
+			for (lane = 0; lane < 4; lane++) {
+				cvmx_gserx_lanex_rx_misc_ovrrd_t misc_ovrrd;
+				cvmx_gserx_lanex_pwr_ctrl_t pwr_ctrl;
+
+				misc_ovrrd.u64 = cvmx_read_csr(CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm));
+				misc_ovrrd.s.cfg_rx_dll_locken_ovvrd_en = 1;
+				cvmx_write_csr(CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm), misc_ovrrd.u64);
+				pwr_ctrl.u64 = cvmx_read_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, qlm));
+				pwr_ctrl.s.rx_resetn_ovrrd_en = 1;
+				cvmx_write_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, qlm), pwr_ctrl.u64);
+			}
+		}
+		for (qlm = low_qlm; qlm <= high_qlm; qlm++) {
+			for (lane = 0; lane < 4; lane++) {
+				cvmx_gserx_lanex_rx_misc_ovrrd_t misc_ovrrd;
+				cvmx_gserx_lanex_pwr_ctrl_t pwr_ctrl;
+
+				misc_ovrrd.u64 = cvmx_read_csr(CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm));
+				misc_ovrrd.s.cfg_rx_dll_locken_ovvrd_en = 0;
+				cvmx_write_csr(CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm), misc_ovrrd.u64);
+				pwr_ctrl.u64 = cvmx_read_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, qlm));
+				pwr_ctrl.s.rx_resetn_ovrrd_en = 0;
+				cvmx_write_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, qlm), pwr_ctrl.u64);
+			}
+		}
+
+		/* Wait for the link to come up (hopefully Gen3) and link training to be complete */
+		start_cycle = cvmx_clock_get_count(CVMX_CLOCK_CORE);
+		do {
+			if (cvmx_clock_get_count(CVMX_CLOCK_CORE) - start_cycle > cvmx_clock_get_rate(CVMX_CLOCK_CORE))
+				return -1;
+			cvmx_wait_usec(1000);
+			cfg032.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG032(pcie_port));
+		} while ((cfg032.s.dlla == 0) || (cfg032.s.lt == 1));
+	}
+
 	/* Update the Replay Time Limit.  Empirically, some PCIe devices take a
 	 * little longer to respond than expected under load. As a workaround
 	 * for this we configure the Replay Time Limit to the value expected
@@ -1137,6 +1280,12 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 			return -1;
 		}
 	}
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		cvmx_write_csr(CVMX_DTX_PEMX_SELX(0, pcie_port), 0x17);
+		cvmx_write_csr(CVMX_DTX_PEMX_SELX(1, pcie_port), 0);
+	}
+
 	if (ep_mode) {
 		cvmx_dprintf("PCIe: Port %d in endpoint mode.\n", pcie_port);
 		return -1;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki.c b/arch/mips/cavium-octeon/executive/cvmx-pki.c
index d6bea5f..4fb65ca 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki.c
@@ -196,9 +196,28 @@ void cvmx_pki_read_global_cfg(int node, struct cvmx_pki_global_config *gbl_cfg)
                 gbl_cfg->frm_len[id].maxlen = frm_len_chk.s.maxlen;
                 gbl_cfg->frm_len[id].minlen = frm_len_chk.s.minlen;
         }
-	/* vinita_to_do remaining parameters */
 }
 
+/**
+ * This function writes max and min frame lengths to hardware which can be used
+ * to check the size of frame arrived.There are 2 possible combination which are
+ * indicated by id field.
+ * @param node		node number.
+ * @param id		choose which frame len register to write to
+ * @param len_chk	struct containing Byte count for max-sized/min-sized frame check.
+ *
+ */
+static void cvmx_pki_write_frame_len(int node, int id,
+				     struct cvmx_pki_frame_len len_chk)
+{
+	cvmx_pki_frm_len_chkx_t frm_len_chk;
+	frm_len_chk.u64 = cvmx_read_csr_node(node, CVMX_PKI_FRM_LEN_CHKX(id));
+	frm_len_chk.s.maxlen = len_chk.maxlen;
+	frm_len_chk.s.minlen = len_chk.minlen;
+	cvmx_write_csr_node(node, CVMX_PKI_FRM_LEN_CHKX(id), frm_len_chk.u64);
+}
+
+
 void cvmx_pki_write_global_cfg(int node, struct cvmx_pki_global_config *gbl_cfg)
 {
 	cvmx_pki_stat_ctl_t stat_ctl;
@@ -215,7 +234,6 @@ void cvmx_pki_write_global_cfg(int node, struct cvmx_pki_global_config *gbl_cfg)
 	cvmx_pki_write_tag_secret(node, gbl_cfg->tag_secret);
 	cvmx_pki_write_frame_len(node, 0, gbl_cfg->frm_len[0]);
 	cvmx_pki_write_frame_len(node, 1, gbl_cfg->frm_len[1]);
-	/* vinita_to_do remaining parameters */
 }
 
 /**
@@ -382,8 +400,6 @@ void cvmx_pki_set_style_config(int node, uint64_t style, uint64_t cluster_mask,
 			style_alg_reg.s.qpg_port_msb = style_cfg->parm_cfg.qpg_port_msb;
 			style_alg_reg.s.wqe_vs = style_cfg->parm_cfg.wqe_vs;
 			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster), style_alg_reg.u64);
-
-			cvmx_pki_write_tag_config(node, style, cluster_mask, &style_cfg->tag_cfg);
 		}
 		cluster++;
 	}
@@ -397,6 +413,8 @@ void cvmx_pki_set_style_config(int node, uint64_t style, uint64_t cluster_mask,
 	style_buf_reg.s.mb_size = (style_cfg->parm_cfg.mbuff_size)/8;
 	style_buf_reg.s.dis_wq_dat = style_cfg->parm_cfg.dis_wq_dat;
 	cvmx_write_csr_node(node, CVMX_PKI_STYLEX_BUF(style), style_buf_reg.u64);
+
+        cvmx_pki_write_tag_config(node, style, cluster_mask, &style_cfg->tag_cfg);
 }
 
 void cvmx_pki_get_tag_config(int node, int style, uint64_t cluster_mask,
@@ -552,7 +570,8 @@ void cvmx_pki_config_port(int ipd_port, struct cvmx_pki_port_config *port_cfg)
 	index = cvmx_helper_get_interface_index_num(ipd_port);
 	pknd = cvmx_helper_get_pknd(interface, index);
 
-	cvmx_pki_set_pkind_config(xp.node, pknd, &port_cfg->pkind_cfg);
+        if (cvmx_pki_set_pkind_config(xp.node, pknd, &port_cfg->pkind_cfg))
+                return;
 	style = port_cfg->pkind_cfg.initial_style;
 	pki_cl_msk.u64 = cvmx_read_csr_node(xp.node, CVMX_PKI_ICGX_CFG(port_cfg->pkind_cfg.cluster_grp));
 	cl_mask = pki_cl_msk.s.clusters;
@@ -918,7 +937,6 @@ void cvmx_pki_show_valid_pcam_entries(int node)
 	cvmx_pki_clx_pcamx_matchx_t	pcam_match;
 	cvmx_pki_clx_pcamx_actionx_t	pcam_action;
 
-	/*vinita_to_do, later modify to use/t/t etc*/
 	for (cluster = 0; cluster < 4; cluster++) {
 		for (bank = 0; bank < 2; bank++) {
 			cvmx_dprintf("\n--------------Cluster %1d Bank %1d---------------------\n", cluster, bank);
@@ -973,8 +991,8 @@ void cvmx_pki_show_pkind_attributes(int node, int pkind)
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
 		if (pki_cl_grp.s.clusters & (0x01L << cluster)) {
-                         cvmx_dprintf("pkind %d config 0x%llx\n", pkind, (unsigned long long)cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster)));
-			/*vinita_to_do later modify in human readble format or now just print register value*/
+                        cvmx_dprintf("pkind %d config 0x%llx\n", pkind, (unsigned long long)cvmx_read_csr_node(node,
+                                     CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster)));
 			pkind_cfg_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
 			cvmx_dprintf("initial parse Mode: %d\n", pkind_cfg_style.s.pm);
 			cvmx_dprintf("initial_style: %d\n", pkind_cfg_style.s.style);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index c3305c5..e8d9851 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 99024 $<hr>
+ * <hr>$Revision: 100230 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -906,7 +906,14 @@ static enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn70xx(int qlm)
 			case CVMX_GMX_INF_MODE_RXAUI:
 				return CVMX_QLM_MODE_RXAUI_1X2;
 			default:
-				return CVMX_QLM_MODE_DISABLED;
+				switch (inf_mode1.s.mode) {
+				case CVMX_GMX_INF_MODE_SGMII:
+					return CVMX_QLM_MODE_DISABLED_SGMII;
+				case CVMX_GMX_INF_MODE_QSGMII:
+					return CVMX_QLM_MODE_DISABLED_QSGMII;
+				default:
+					return CVMX_QLM_MODE_DISABLED;
+				}
 			}
 		}
 	case 1:  /* Sata / pem0 */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c b/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
index 852950b..d7fb307 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-sso-resources.c
@@ -63,10 +63,10 @@ static struct global_resource_tag get_sso_resource_tag(int node)
 	}
 }
 
-int cvmx_sso_allocate_groups(int node, int groups_allocated[], int count)
+int cvmx_sso_allocate_group_range(int node, int *base_group, int count)
 {
 	int num_grp;
-	int rv = -1;
+	int start;
 	uint64_t owner = 0;
 	struct global_resource_tag tag = get_sso_resource_tag(node);
 
@@ -82,25 +82,30 @@ int cvmx_sso_allocate_groups(int node, int groups_allocated[], int count)
 		return -1;
 	}
 
-	if (groups_allocated[0] >= 0) {
-		while (count--) {
-			rv = cvmx_reserve_global_resource_range(tag, owner, groups_allocated[count], 1);
-			if (!rv)
-				return CVMX_RESOURCE_ALREADY_RESERVED;
-		}
+	if (*base_group >= 0) {
+		start = cvmx_reserve_global_resource_range(tag, owner, *base_group, count);
+		if (start != *base_group)
+			return CVMX_RESOURCE_ALREADY_RESERVED;
+		else
+			return 0;
 	} else {
-		rv = cvmx_resource_alloc_many(tag, owner, count, groups_allocated);
+		start = cvmx_allocate_global_resource_range(tag, owner, count, 1);
+		if (start < 0) {
+			return CVMX_RESOURCE_ALREADY_RESERVED;
+		} else {
+			*base_group = start;
+			return 0;
+		}
 	}
-	return rv;
 }
-EXPORT_SYMBOL(cvmx_sso_allocate_groups);
+EXPORT_SYMBOL(cvmx_sso_allocate_group_range);
 
 int cvmx_sso_allocate_group(int node)
 {
 	int r;
 	int grp = -1;
 
-	r = cvmx_sso_allocate_groups(node, &grp, 1);
+	r = cvmx_sso_allocate_group_range(node, &grp, 1);
 
 	return r == 0 ? grp : -1;
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index e00c98f..41fbf9f 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 99261 $<hr>
+ * <hr>$Revision: 100175 $<hr>
  *
  */
 
@@ -280,6 +280,7 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_NIC401NVG = 62,
 	CVMX_BOARD_TYPE_NIC210NVG = 63,
 	CVMX_BOARD_TYPE_SFF7000 = 64,
+	CVMX_BOARD_TYPE_EBB7800_CFG1 = 65,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -313,13 +314,13 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_CUST_L2_WSTRNSNIC_TX = 10019,
 	CVMX_BOARD_TYPE_CUST_L2_WSTRNSNIC_RX = 10020,
 	CVMX_BOARD_TYPE_CUST_L2_ZINWELL = 10021,
+	CVMX_BOARD_TYPE_CUST_CLARK = 10022,
 	CVMX_BOARD_TYPE_CUST_DEFINED_MAX = 20000,
 
 	/* Set aside a range for customer private use.  The SDK won't
 	 ** use any numbers in this range. */
 	CVMX_BOARD_TYPE_CUST_PRIVATE_MIN = 20001,
 	CVMX_BOARD_TYPE_UBNT_E100 = 20002,
-	CVMX_BOARD_TYPE_CUST_CLARK = 20003,
 	CVMX_BOARD_TYPE_CUST_PRIVATE_MAX = 30000,
 
 	/* Range for IO modules */
@@ -412,6 +413,7 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC401NVG)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC210NVG)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SFF7000)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7800_CFG1)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-pki.h b/arch/mips/include/asm/octeon/cvmx-helper-pki.h
index abf7645..e33d01a 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-pki.h
@@ -60,7 +60,7 @@ extern "C" {
 #endif
 
 /* Modify this if more than 8 ilk channels need to be supported */
-#define CVMX_MAX_PORT_PER_INTERFACE	8
+#define CVMX_MAX_PORT_PER_INTERFACE	64
 #define CVMX_MAX_QOS_PRIORITY		64
 #define CVMX_PKI_FIND_AVAILABLE_RSRC    (-1)
 
@@ -229,6 +229,7 @@ void cvmx_helper_pki_set_dflt_style(int node, struct cvmx_pki_style_config *styl
  */
 void cvmx_helper_pki_set_wqe_mode(int node, bool pkt_outside_wqe);
 void pki_wqe_dump(const cvmx_wqe_78xx_t* wqp);
+void __cvmx_helper_pki_set_ltype_map(int node);
 
 #ifdef __cplusplus
 /* *INDENT-OFF* */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-util.h b/arch/mips/include/asm/octeon/cvmx-helper-util.h
index dca3cfd..a857974 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-util.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-util.h
@@ -42,7 +42,7 @@
  *
  * Small helper utilities.
  *
- * <hr>$Revision: 96774 $<hr>
+ * <hr>$Revision: 100097 $<hr>
  */
 
 #ifndef __CVMX_HELPER_UTIL_H__
@@ -144,6 +144,67 @@ static inline int cvmx_helper_node_interface_to_xiface(int node, int interface)
 }
 
 /**
+ * Free the pki packet buffers contained in a work queue entry.
+ * If first packet buffer contains wqe, wqe gets freed too so do not access
+ * wqe after calling this function.
+ * This function asssumes that buffers to be freed are from
+ * Naturally aligned pool/aura.
+ * It does not use don't write back.
+ * @param work   Work queue entry with packet to free
+ */
+static inline void cvmx_helper_free_pki_pkt_data(cvmx_wqe_t *work)
+{
+        uint64_t        number_buffers;
+        uint64_t        start_of_buffer;
+        cvmx_buf_ptr_pki_t  next_buffer_ptr;
+        cvmx_buf_ptr_pki_t  buffer_ptr;
+        cvmx_wqe_78xx_t *wqe = (cvmx_wqe_78xx_t*)work;
+
+        if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+                cvmx_dprintf("ERROR: free_pki_pkt_data: Supported only on 78xx\n");
+                return;
+        }
+        /* Make sure errata pki-20776 has been applied*/
+        cvmx_wqe_pki_errata_20776(work);
+        buffer_ptr = wqe->packet_ptr;
+        number_buffers = cvmx_wqe_get_bufs(work);
+
+        while (number_buffers--) {
+                unsigned aura = cvmx_wqe_get_aura(work);
+                /* XXX- assumes the buffer is cache-line aligned and naturally aligned mode*/
+                start_of_buffer = (buffer_ptr.addr >> 7) << 7;
+                /* Read pointer to next buffer before we free the current buffer. */
+                next_buffer_ptr = *(cvmx_buf_ptr_pki_t *)
+                                cvmx_phys_to_ptr(buffer_ptr.addr - 8);
+                /* FPA AURA comes from WQE, includes node */
+                cvmx_fpa3_free_gaura(cvmx_phys_to_ptr(start_of_buffer),	aura, 0);
+                buffer_ptr = next_buffer_ptr;
+        }
+}
+
+/**
+ * Free the pki wqe entry buffer.
+ * If wqe buffers contains first packet buffer, wqe does not get freed here.
+ * This function asssumes that buffers to be freed are from
+ * Naturally aligned pool/aura.
+ * It does not use don't write back.
+ * @param work   Work queue entry to free
+ */
+static inline void cvmx_wqe_pki_free(cvmx_wqe_t *work)
+{
+        cvmx_wqe_78xx_t *wqe = (cvmx_wqe_78xx_t *)work;
+
+        if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+                cvmx_dprintf("ERROR: cvmx_wqe_free: Supported only on 78xx\n");
+                return;
+        }
+        /* Do nothing if the first packet buffer shares WQE buffer */
+        if (!wqe->packet_ptr.packet_outside_wqe)
+                return;
+        cvmx_fpa3_free_gaura(work, cvmx_wqe_get_aura(work), 0);
+}
+
+/**
  * Convert a interface mode into a human readable string
  *
  * @param mode   Mode to convert
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index eaf6424..b5d3187 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -178,7 +178,8 @@ enum cvmx_pki_beltype { /* PKI_BELTYPE_E_t */
 	CVMX_PKI_BELTYPE_TCP    = PKI_BELTYPE_E__TCP_M,
 	CVMX_PKI_BELTYPE_UDP    = PKI_BELTYPE_E__UDP_M,
 	CVMX_PKI_BELTYPE_SCTP   = PKI_BELTYPE_E__SCTP_M,
-	CVMX_PKI_BELTYPE_SNAP   = PKI_BELTYPE_E__SNAP_M
+	CVMX_PKI_BELTYPE_SNAP   = PKI_BELTYPE_E__SNAP_M,
+        CVMX_PKI_BELTYPE_MAX   = CVMX_PKI_BELTYPE_SNAP
 };
 
 struct cvmx_pki_frame_len {
@@ -568,29 +569,6 @@ struct cvmx_pki_port_stats {
 					mode for the packet is SKIP-TO-IP */
 };
 
-
-/**
- * This function writes qpg entry at specified offset in hardware
- *
- * @param node		node number
- * @param index		offset in qpg entry to write to.
- * @param padd		port address for channel calculation
- * @param aura		aura number to send packet to
- * @param group_ok	group number to send packet to if there is no error
- * @param group_bad	group number to send packet  to if there is error
- */
-static inline void cvmx_pki_write_qpg_entry(int node, int index, int padd, int aura,
-					      int group_ok, int group_bad)
-{
-	cvmx_pki_qpg_tblx_t qpg_tbl;
-	qpg_tbl.u64 = cvmx_read_csr_node(node, CVMX_PKI_QPG_TBLX(index));
-	qpg_tbl.s.padd = padd;
-	qpg_tbl.s.laura = aura;
-	qpg_tbl.s.grp_ok = group_ok;
-	qpg_tbl.s.grp_bad = group_bad;
-	cvmx_write_csr_node(node, CVMX_PKI_QPG_TBLX(index), qpg_tbl.u64);
-}
-
 /**
  * This function assignes the clusters to a group, later pkind can be
  * configured to use that group depending on number of clusters pkind
@@ -646,29 +624,14 @@ static inline void cvmx_pki_write_tag_secret(int node, struct cvmx_pki_tag_sec t
 	cvmx_write_csr_node(node, CVMX_PKI_TAG_SECRET, tag_secret_reg.u64);
 }
 
-/**
- * This function writes max and min frame lengths to hardware which can be used
- * to check the size of frame arrived.There are 2 possible combination which are
- * indicated by id field.
- * @param node		node number.
- * @param id		choose which frame len register to write to
- * @param len_chk	struct containing Byte count for max-sized/min-sized frame check.
- *
- */
-static inline void cvmx_pki_write_frame_len(int node, int id,
-					   struct cvmx_pki_frame_len len_chk)
-{
-	cvmx_pki_frm_len_chkx_t frm_len_chk;
-	frm_len_chk.u64 = cvmx_read_csr_node(node, CVMX_PKI_FRM_LEN_CHKX(id));
-	frm_len_chk.s.maxlen = len_chk.maxlen;
-	frm_len_chk.s.minlen = len_chk.minlen;
-	cvmx_write_csr_node(node, CVMX_PKI_FRM_LEN_CHKX(id), frm_len_chk.u64);
-}
-
 static inline void cvmx_pki_write_ltype_map(int node, enum cvmx_pki_layer_type layer,
 					    enum cvmx_pki_beltype backend)
 {
 	cvmx_pki_ltypex_map_t ltype_map;
+        if (layer > CVMX_PKI_LTYPE_E_MAX || backend > CVMX_PKI_BELTYPE_MAX) {
+                cvmx_dprintf("ERROR: invalid ltype beltype mapping\n");
+                return;
+        }
 	ltype_map.u64 = cvmx_read_csr_node(node, CVMX_PKI_LTYPEX_MAP(layer));
 	ltype_map.s.beltype = backend;
 	cvmx_write_csr_node(node, CVMX_PKI_LTYPEX_MAP(layer), ltype_map.u64);
diff --git a/arch/mips/include/asm/octeon/cvmx-pow.h b/arch/mips/include/asm/octeon/cvmx-pow.h
index cbd1dc8..68e589c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow.h
@@ -1978,6 +1978,7 @@ static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
 {
 	union cvmx_pow_tag_req_addr ptr;
 	cvmx_pow_tag_req_t tag_req;
+	unsigned node = cvmx_get_node_num();
 
 	if (CVMX_ENABLE_POW_CHECKS) {
 		cvmx_pow_tag_info_t current_tag;
@@ -1998,17 +1999,29 @@ static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
 
 	tag_req.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		unsigned xgrp = 0;
+		unsigned xgrp;
 		uint64_t wqp_phys;
 
 		wqp_phys = cvmx_ptr_to_phys(wqp);
 
-		/* Inherit QoS but replace grp, current node */
-		if(wqp_phys!= 0x80)
+		if(wqp_phys!= 0x80) {
+			/* If WQE is valid, use its XGRP */
 			xgrp = wqp->word1.cn78xx.grp;
-		xgrp &= 0x7;
-		xgrp |= group << 3;
-		xgrp |= 0x300 & (cvmx_get_node_num() << 8);
+			/* Use XGRP[node] too */
+			node = xgrp >> 8;
+			/* Modify XGRP with legacy group # from arg */
+			xgrp &= ~0xf8;
+			xgrp |= 0xf8 & (group << 3);
+
+			wqp->word1.cn78xx.grp = xgrp;
+			wqp->word1.cn78xx.tag = tag;
+			wqp->word1.cn78xx.tag_type = tag_type;
+			CVMX_SYNCWS;
+		} else {
+			/* If no WQE, build XGRP with QoS=0 and current node */
+			xgrp = group << 3;
+			xgrp |= node << 8;
+		}
 
 		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_SWTAG_FULL;
 		tag_req.s_cn78xx_other.type = tag_type;
@@ -2016,11 +2029,6 @@ static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
 		tag_req.s_cn78xx_other.wqp = wqp_phys;
 
 		/* WQE GRP is 10 bits, includes node # */
-		if(wqp_phys != 0x80) {
-			wqp->word1.cn78xx.grp = xgrp;
-			wqp->word1.cn78xx.tag = tag;
-			wqp->word1.cn78xx.tag_type = tag_type;
-		}
 	}
 	else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
 		tag_req.s_cn68xx_other.op = CVMX_POW_TAG_OP_SWTAG_FULL;
@@ -2039,7 +2047,7 @@ static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
 		ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
 		ptr.s_cn78xx.is_io = 1;
 		ptr.s_cn78xx.did = CVMX_OCT_DID_TAG_SWTAG;
-		ptr.s_cn78xx.node =  cvmx_get_node_num();
+		ptr.s_cn78xx.node = node;
 		ptr.s_cn78xx.tag  = tag;
 	} else {
 		ptr.s.mem_region = CVMX_IO_SEG;
@@ -2189,6 +2197,7 @@ static inline void cvmx_pow_work_submit(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow
 		wqp->word1.cn78xx.tag = tag;
 		wqp->word1.cn78xx.tag_type = tag_type;
 		wqp->word1.cn78xx.grp = xgrp;
+		CVMX_SYNCWS;
 
 		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_ADDWQ;
 		tag_req.s_cn78xx_other.type = tag_type;
@@ -2258,17 +2267,16 @@ static inline void cvmx_pow_work_submit(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow
  * This entry is updated to match the other parameters
  * @param tag tag value to be assigned to work queue entry
  * @param tag_type type of tag
- * @param group group value for the work queue entry, in the range 0..255
- * on the CN78XX model.
+ * @param xgrp native CN78XX group in the range 0..255
  * @param node The OCI node number for the target group
  *
  * When this function is called on a model prior to CN78XX, which does
- * not support OCI nodes, the 'node' argument is ignored, and the 'group'
- * parameter is converted into 'qps' (the lower 3 bits) and 'grp' (the higher
+ * not support OCI nodes, the 'node' argument is ignored, and the 'xgrp'
+ * parameter is converted into 'qos' (the lower 3 bits) and 'grp' (the higher
  * 5 bits), following the backward-compatibility scheme of translating
  * between new and old style group numbers.
  */
-static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint8_t  group, uint8_t node)
+static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint8_t xgrp, uint8_t node)
 {
 	union cvmx_pow_tag_req_addr ptr;
 	cvmx_pow_tag_req_t tag_req;
@@ -2277,16 +2285,17 @@ static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvm
 	ptr.u64 = 0;
 
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		unsigned xgrp;
+		unsigned gxgrp;
 
-		xgrp = group & 0xff;
-		xgrp |= 0x300 & (node << 8);
+		gxgrp = xgrp & 0xff;
+		gxgrp |= node << 8;
  
 		wqp->word1.cn78xx.rsvd_0 = 0;
 		wqp->word1.cn78xx.rsvd_1 = 0;
 		wqp->word1.cn78xx.tag = tag;
 		wqp->word1.cn78xx.tag_type = tag_type;
-		wqp->word1.cn78xx.grp = xgrp;
+		wqp->word1.cn78xx.grp = gxgrp;
+		CVMX_SYNCWS;
 
 		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_ADDWQ;
 		tag_req.s_cn78xx_other.type = tag_type;
@@ -2302,8 +2311,8 @@ static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvm
 		wqp->word1.cn68xx.zero_0 = 0;
 		wqp->word1.cn68xx.zero_1 = 0;
 		wqp->word1.cn68xx.zero_2 = 0;
-		wqp->word1.cn68xx.qos = group & 0x7;
-		wqp->word1.cn68xx.grp = group >> 3;
+		wqp->word1.cn68xx.qos = xgrp & 0x7;
+		wqp->word1.cn68xx.grp = xgrp >> 3;
 
 		wqp->word1.tag = tag;
 		wqp->word1.tag_type = tag_type;
@@ -2311,8 +2320,8 @@ static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvm
 		tag_req.s_cn68xx_add.op = CVMX_POW_TAG_OP_ADDWQ;
 		tag_req.s_cn68xx_add.type = tag_type;
 		tag_req.s_cn68xx_add.tag = tag;
-		tag_req.s_cn68xx_add.qos = group & 0x7;
-		tag_req.s_cn68xx_add.grp = group >> 3;
+		tag_req.s_cn68xx_add.qos = xgrp & 0x7;
+		tag_req.s_cn68xx_add.grp = xgrp >> 3;
 
 		ptr.s.mem_region = CVMX_IO_SEG;
 		ptr.s.is_io = 1;
@@ -2321,8 +2330,8 @@ static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvm
 	} else {
 		/* Reset all reserved bits */
 		wqp->word1.cn38xx.zero_2 = 0;
-		wqp->word1.cn38xx.qos = group & 0x7;
-		wqp->word1.cn38xx.grp = group >> 3;
+		wqp->word1.cn38xx.qos = xgrp & 0x7;
+		wqp->word1.cn38xx.grp = xgrp >> 3;
 
 		wqp->word1.tag = tag;
 		wqp->word1.tag_type = tag_type;
@@ -2330,8 +2339,8 @@ static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvm
 		tag_req.s_cn38xx.op = CVMX_POW_TAG_OP_ADDWQ;
 		tag_req.s_cn38xx.type = tag_type;
 		tag_req.s_cn38xx.tag = tag;
-		tag_req.s_cn38xx.qos = group & 0x7;
-		tag_req.s_cn38xx.grp = group >> 3;
+		tag_req.s_cn38xx.qos = xgrp & 0x7;
+		tag_req.s_cn38xx.grp = xgrp >> 3;
 
 		ptr.s.mem_region = CVMX_IO_SEG;
 		ptr.s.is_io = 1;
@@ -3010,13 +3019,12 @@ extern int cvmx_pow_get_num_entries(void);
  * This will allocate count number of SSO groups on the specified node to the
  * calling application. These groups will be for exclusive use of the application
  * until they are freed.
- * @param groups_allocated is an array of length count allocated by
- *			  the application before invoking the
- *			  cvmx_sso_allocate_groups.  On return it will
- *			  contain the index numbers of the groups allocated.
+ * @param node The numa node for the allocation.
+ * @param base_group Pointer to the initial group, -1 to allocate anywhere.
+ * @param count  The number of consecutive groups to allocate.
  * @return 0 on success and -1 on failure.
  */
-int cvmx_sso_allocate_groups(int node, int groups_allocated[], int count);
+int cvmx_sso_allocate_group_range(int node, int *base_group, int count);
 int cvmx_sso_allocate_group(int node);
 
 #ifdef  __cplusplus
diff --git a/arch/mips/include/asm/octeon/cvmx-sata-defs.h b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
index 0847a74..fe5b884 100644
--- a/arch/mips/include/asm/octeon/cvmx-sata-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -553,20 +553,20 @@ union cvmx_sata_uahc_gbl_bistafr {
 	struct cvmx_sata_uahc_gbl_bistafr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_16_31               : 16;
-	uint32_t ncp                          : 8;  /**< Bits 7:0 of the 2nd DWORD of BIST activate FIS.
-                                                         0xF1: low transition density pattern (LTDP)
-                                                         0xB5: high transition density pattern (HTDP)
-                                                         0xAB: low frequency spectral component pattern (LFSCP)
-                                                         0x7F: simultaneous switching outputs pattern (SSOP)
-                                                         0x78: mid frequency test pattern (MFTP)
-                                                         0x4A: high frequency test pattern (HFTP)
-                                                         0x7E: low frequency test pattern (LFTP)
-                                                         Else: lone bit pattern (LBP) */
-	uint32_t pd                           : 8;  /**< Bits 23:16 of the 1st DWORD of the BIST activate FIS.
-                                                         Only the following values are supported:
-                                                         0x10: Far-end retimed
-                                                         0xC0: Far-end transmit only
-                                                         0xE0: Far-end transmit only with scrambler bypassed */
+	uint32_t ncp                          : 8;  /**< Bits 7:0 of the second DWORD of BIST activate FIS.
+                                                         0xF1 = low transition density pattern (LTDP)
+                                                         0xB5 = high transition density pattern (HTDP)
+                                                         0xAB = low frequency spectral component pattern (LFSCP)
+                                                         0x7F = simultaneous switching outputs pattern (SSOP)
+                                                         0x78 = mid frequency test pattern (MFTP)
+                                                         0x4A = high frequency test pattern (HFTP)
+                                                         0x7E = low frequency test pattern (LFTP)
+                                                         All other values = lone bit pattern (LBP) */
+	uint32_t pd                           : 8;  /**< Bits 23:16 of the first DWORD of the BIST activate FIS. Only the following values are
+                                                         supported:
+                                                         0x10 = Far-end retimed
+                                                         0xC0 = Far-end transmit only
+                                                         0xE0 = Far-end transmit only with scrambler bypassed */
 #else
 	uint32_t pd                           : 8;
 	uint32_t ncp                          : 8;
@@ -574,6 +574,7 @@ union cvmx_sata_uahc_gbl_bistafr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_bistafr_s   cn70xx;
+	struct cvmx_sata_uahc_gbl_bistafr_s   cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_bistafr cvmx_sata_uahc_gbl_bistafr_t;
 
@@ -604,9 +605,9 @@ union cvmx_sata_uahc_gbl_bistcr {
 	uint32_t sdfe                         : 1;  /**< Signal detect feature enable. */
 	uint32_t reserved_11_11               : 1;
 	uint32_t llc                          : 3;  /**< Link layer control.
-                                                         Bit 10: RPD - repeat primitive drop enable
-                                                         Bit  9: DESCRAM - descrambler enable
-                                                         Bit  8: SCRAM - scrambler enable */
+                                                         <10> = RPD - repeat primitive drop enable
+                                                         <9> = DESCRAM - descrambler enable
+                                                         <8> = SCRAM - scrambler enable */
 	uint32_t reserved_7_7                 : 1;
 	uint32_t erren                        : 1;  /**< Error enable. */
 	uint32_t flip                         : 1;  /**< Flip disparity. */
@@ -636,6 +637,7 @@ union cvmx_sata_uahc_gbl_bistcr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_bistcr_s    cn70xx;
+	struct cvmx_sata_uahc_gbl_bistcr_s    cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_bistcr cvmx_sata_uahc_gbl_bistcr_t;
 
@@ -657,6 +659,7 @@ union cvmx_sata_uahc_gbl_bistdecr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_bistdecr_s  cn70xx;
+	struct cvmx_sata_uahc_gbl_bistdecr_s  cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_bistdecr cvmx_sata_uahc_gbl_bistdecr_t;
 
@@ -678,6 +681,7 @@ union cvmx_sata_uahc_gbl_bistfctr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_bistfctr_s  cn70xx;
+	struct cvmx_sata_uahc_gbl_bistfctr_s  cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_bistfctr cvmx_sata_uahc_gbl_bistfctr_t;
 
@@ -701,6 +705,7 @@ union cvmx_sata_uahc_gbl_bistsr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_bistsr_s    cn70xx;
+	struct cvmx_sata_uahc_gbl_bistsr_s    cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_bistsr cvmx_sata_uahc_gbl_bistsr_t;
 
@@ -734,7 +739,7 @@ union cvmx_sata_uahc_gbl_cap {
 	uint32_t cccs                         : 1;  /**< Command completion coalescing support. */
 	uint32_t ems                          : 1;  /**< Enclosure management support. */
 	uint32_t sxs                          : 1;  /**< Supports external SATA. */
-	uint32_t np                           : 5;  /**< Number of ports. 0x1 = 2 ports. */
+	uint32_t np                           : 5;  /**< Number of ports. 0x1 = two ports, all other values reserved. */
 #else
 	uint32_t np                           : 5;
 	uint32_t sxs                          : 1;
@@ -760,6 +765,7 @@ union cvmx_sata_uahc_gbl_cap {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_cap_s       cn70xx;
+	struct cvmx_sata_uahc_gbl_cap_s       cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_cap cvmx_sata_uahc_gbl_cap_t;
 
@@ -791,6 +797,7 @@ union cvmx_sata_uahc_gbl_cap2 {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_cap2_s      cn70xx;
+	struct cvmx_sata_uahc_gbl_cap2_s      cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_cap2 cvmx_sata_uahc_gbl_cap2_t;
 
@@ -804,8 +811,8 @@ union cvmx_sata_uahc_gbl_ccc_ctl {
 	uint32_t u32;
 	struct cvmx_sata_uahc_gbl_ccc_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t tv                           : 16; /**< Time-out value.  Writable only when SATA_UAHC_GBL_CCC_CTL[EN] = 0. */
-	uint32_t cc                           : 8;  /**< Command completions.  Writable only when SATA_UAHC_GBL_CCC_CTL[EN] = 0. */
+	uint32_t tv                           : 16; /**< Time-out value. Writable only when EN = 0. */
+	uint32_t cc                           : 8;  /**< Command completions. Writable only when EN = 0. */
 	uint32_t intr                         : 5;  /**< Specifies the port interrupt used by the CCC feature. */
 	uint32_t reserved_1_2                 : 2;
 	uint32_t en                           : 1;  /**< CCC enable. */
@@ -818,6 +825,7 @@ union cvmx_sata_uahc_gbl_ccc_ctl {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_ccc_ctl_s   cn70xx;
+	struct cvmx_sata_uahc_gbl_ccc_ctl_s   cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_ccc_ctl cvmx_sata_uahc_gbl_ccc_ctl_t;
 
@@ -839,6 +847,7 @@ union cvmx_sata_uahc_gbl_ccc_ports {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_ccc_ports_s cn70xx;
+	struct cvmx_sata_uahc_gbl_ccc_ports_s cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_ccc_ports cvmx_sata_uahc_gbl_ccc_ports_t;
 
@@ -855,8 +864,7 @@ union cvmx_sata_uahc_gbl_ghc {
 	uint32_t ae                           : 1;  /**< AHCI enable. */
 	uint32_t reserved_2_30                : 29;
 	uint32_t ie                           : 1;  /**< Interrupt enable. */
-	uint32_t hr                           : 1;  /**< HBA reset. Writing a '1' resets the UAHC. HW will clear this bit once
-                                                         reset is complete. */
+	uint32_t hr                           : 1;  /**< HBA reset. Writing a 1 resets the UAHC. Hardware clears this bit once reset is complete. */
 #else
 	uint32_t hr                           : 1;
 	uint32_t ie                           : 1;
@@ -865,6 +873,7 @@ union cvmx_sata_uahc_gbl_ghc {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_ghc_s       cn70xx;
+	struct cvmx_sata_uahc_gbl_ghc_s       cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_ghc cvmx_sata_uahc_gbl_ghc_t;
 
@@ -910,6 +919,7 @@ union cvmx_sata_uahc_gbl_gparam1r {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_gparam1r_s  cn70xx;
+	struct cvmx_sata_uahc_gbl_gparam1r_s  cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_gparam1r cvmx_sata_uahc_gbl_gparam1r_t;
 
@@ -951,6 +961,7 @@ union cvmx_sata_uahc_gbl_gparam2r {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_gparam2r_s  cn70xx;
+	struct cvmx_sata_uahc_gbl_gparam2r_s  cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_gparam2r cvmx_sata_uahc_gbl_gparam2r_t;
 
@@ -970,6 +981,7 @@ union cvmx_sata_uahc_gbl_idr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_idr_s       cn70xx;
+	struct cvmx_sata_uahc_gbl_idr_s       cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_idr cvmx_sata_uahc_gbl_idr_t;
 
@@ -991,6 +1003,7 @@ union cvmx_sata_uahc_gbl_is {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_is_s        cn70xx;
+	struct cvmx_sata_uahc_gbl_is_s        cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_is cvmx_sata_uahc_gbl_is_t;
 
@@ -1020,6 +1033,7 @@ union cvmx_sata_uahc_gbl_oobr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_oobr_s      cn70xx;
+	struct cvmx_sata_uahc_gbl_oobr_s      cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_oobr cvmx_sata_uahc_gbl_oobr_t;
 
@@ -1034,14 +1048,14 @@ union cvmx_sata_uahc_gbl_pi {
 	struct cvmx_sata_uahc_gbl_pi_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_2_31                : 30;
-	uint32_t pi                           : 2;  /**< Ports implemented. This field is one-time writable, then becomes
-                                                         read-only. */
+	uint32_t pi                           : 2;  /**< Number of ports implemented. This field is one-time writable, then becomes read-only. */
 #else
 	uint32_t pi                           : 2;
 	uint32_t reserved_2_31                : 30;
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_pi_s        cn70xx;
+	struct cvmx_sata_uahc_gbl_pi_s        cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_pi cvmx_sata_uahc_gbl_pi_t;
 
@@ -1056,10 +1070,10 @@ union cvmx_sata_uahc_gbl_pparamr {
 	struct cvmx_sata_uahc_gbl_pparamr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_12_31               : 20;
-	uint32_t tx_mem_m                     : 1;  /**< TX FIFO memory read port type (P#_TX_MEM_MODE). */
-	uint32_t tx_mem_s                     : 1;  /**< TX FIFO memory type (P#_TX_MEM_SELECT). */
-	uint32_t rx_mem_m                     : 1;  /**< RX FIFO memory read port type (P#_RX_MEM_MODE). */
-	uint32_t rx_mem_s                     : 1;  /**< RX FIFO memory type (P#_RX_MEM_SELECT). */
+	uint32_t tx_mem_m                     : 1;  /**< TX FIFO memory read port type (Pn_TX_MEM_MODE). */
+	uint32_t tx_mem_s                     : 1;  /**< TX FIFO memory type (Pn_TX_MEM_SELECT). */
+	uint32_t rx_mem_m                     : 1;  /**< RX FIFO memory read port type (Pn_RX_MEM_MODE). */
+	uint32_t rx_mem_s                     : 1;  /**< RX FIFO memory type (Pn_RX_MEM_SELECT). */
 	uint32_t txfifo_depth                 : 4;  /**< TX FIFO depth in FIFO words. */
 	uint32_t rxfifo_depth                 : 4;  /**< RX FIFO depth in FIFO words. */
 #else
@@ -1073,6 +1087,7 @@ union cvmx_sata_uahc_gbl_pparamr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_pparamr_s   cn70xx;
+	struct cvmx_sata_uahc_gbl_pparamr_s   cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_pparamr cvmx_sata_uahc_gbl_pparamr_t;
 
@@ -1098,6 +1113,7 @@ union cvmx_sata_uahc_gbl_testr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_testr_s     cn70xx;
+	struct cvmx_sata_uahc_gbl_testr_s     cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_testr cvmx_sata_uahc_gbl_testr_t;
 
@@ -1112,13 +1128,14 @@ union cvmx_sata_uahc_gbl_timer1ms {
 	struct cvmx_sata_uahc_gbl_timer1ms_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_20_31               : 12;
-	uint32_t timv                         : 20; /**< 1ms timer value.  Writable only when SATA_UAHC_GBL_CCC_CTL[EN] is NOT set. */
+	uint32_t timv                         : 20; /**< 1ms timer value. Writable only when SATA_UAHC_GBL_CCC_CTL[EN] = 0. */
 #else
 	uint32_t timv                         : 20;
 	uint32_t reserved_20_31               : 12;
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_timer1ms_s  cn70xx;
+	struct cvmx_sata_uahc_gbl_timer1ms_s  cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_timer1ms cvmx_sata_uahc_gbl_timer1ms_t;
 
@@ -1138,6 +1155,7 @@ union cvmx_sata_uahc_gbl_versionr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_versionr_s  cn70xx;
+	struct cvmx_sata_uahc_gbl_versionr_s  cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_versionr cvmx_sata_uahc_gbl_versionr_t;
 
@@ -1159,6 +1177,7 @@ union cvmx_sata_uahc_gbl_vs {
 #endif
 	} s;
 	struct cvmx_sata_uahc_gbl_vs_s        cn70xx;
+	struct cvmx_sata_uahc_gbl_vs_s        cn70xxp1;
 };
 typedef union cvmx_sata_uahc_gbl_vs cvmx_sata_uahc_gbl_vs_t;
 
@@ -1178,6 +1197,7 @@ union cvmx_sata_uahc_px_ci {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_ci_s         cn70xx;
+	struct cvmx_sata_uahc_px_ci_s         cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_ci cvmx_sata_uahc_px_ci_t;
 
@@ -1191,7 +1211,7 @@ union cvmx_sata_uahc_px_clb {
 	uint64_t u64;
 	struct cvmx_sata_uahc_px_clb_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t clb                          : 54; /**< Command list base address. */
+	uint64_t clb                          : 54; /**< Command-list base address. */
 	uint64_t reserved_0_9                 : 10;
 #else
 	uint64_t reserved_0_9                 : 10;
@@ -1199,6 +1219,7 @@ union cvmx_sata_uahc_px_clb {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_clb_s        cn70xx;
+	struct cvmx_sata_uahc_px_clb_s        cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_clb cvmx_sata_uahc_px_clb_t;
 
@@ -1214,27 +1235,27 @@ union cvmx_sata_uahc_px_cmd {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t icc                          : 4;  /**< Interface communication control. */
 	uint32_t asp                          : 1;  /**< Aggressive slumber/partial. */
-	uint32_t alpe                         : 1;  /**< Aggressive link power management enable. */
+	uint32_t alpe                         : 1;  /**< Aggressive link-power-management enable. */
 	uint32_t dlae                         : 1;  /**< Drive LED on ATAPI enable. */
 	uint32_t atapi                        : 1;  /**< Device is ATAPI. */
 	uint32_t apste                        : 1;  /**< Automatic partial to slumber transitions enable. */
 	uint32_t fbscp                        : 1;  /**< FIS-based switching capable port. Write-once. */
 	uint32_t esp                          : 1;  /**< External SATA port. Write-once. */
-	uint32_t cpd                          : 1;  /**< Cold presence detection. Write-once. */
+	uint32_t cpd                          : 1;  /**< Cold-presence detection. Write-once. */
 	uint32_t mpsp                         : 1;  /**< Mechanical presence switch attached to port. Write-once. */
-	uint32_t hpcp                         : 1;  /**< Hot plug capable support. Write-once. */
+	uint32_t hpcp                         : 1;  /**< Hot-plug-capable support. Write-once. */
 	uint32_t pma                          : 1;  /**< Port multiplier attached. */
 	uint32_t cps                          : 1;  /**< Cold presence state. */
 	uint32_t cr                           : 1;  /**< Command list running. */
 	uint32_t fr                           : 1;  /**< FIS receive running. */
 	uint32_t mpss                         : 1;  /**< Mechanical presence switch state. */
-	uint32_t ccs                          : 5;  /**< Current command slot. */
+	uint32_t ccs                          : 5;  /**< Current-command slot. */
 	uint32_t reserved_5_7                 : 3;
-	uint32_t fre                          : 1;  /**< FIS receive enable. */
-	uint32_t clo                          : 1;  /**< Command list override. */
-	uint32_t pod                          : 1;  /**< Power on device. R/W only if CPD=1, else read only. */
-	uint32_t sud                          : 1;  /**< Spin-up device. R/W only if SATA_UAHC_GBL_CAP[SSS]=1, else read only.
-                                                         Setting this bit triggers a COMRESET initialization sequence. */
+	uint32_t fre                          : 1;  /**< FIS-receive enable. */
+	uint32_t clo                          : 1;  /**< Command-list override. */
+	uint32_t pod                          : 1;  /**< Power-on device. R/W only if CPD = 1, else read only. */
+	uint32_t sud                          : 1;  /**< Spin-up device. R/W only if SATA_UAHC_GBL_CAP[SSS] = 1, else read only. Setting this bit
+                                                         triggers a COMRESET initialization sequence. */
 	uint32_t st                           : 1;  /**< Start. */
 #else
 	uint32_t st                           : 1;
@@ -1263,6 +1284,7 @@ union cvmx_sata_uahc_px_cmd {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_cmd_s        cn70xx;
+	struct cvmx_sata_uahc_px_cmd_s        cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_cmd cvmx_sata_uahc_px_cmd_t;
 
@@ -1277,10 +1299,10 @@ union cvmx_sata_uahc_px_dmacr {
 	struct cvmx_sata_uahc_px_dmacr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_8_31                : 24;
-	uint32_t rxts                         : 4;  /**< Receive transaction size. This field is R/W when SATA_UAHC_PX_CMD[ST]=0
-                                                         and read only when SATA_UAHC_PX_CMD[ST]=1. */
-	uint32_t txts                         : 4;  /**< Transmit transaction size. This field is R/W when SATA_UAHC_PX_CMD[ST]=0
-                                                         and read only when SATA_UAHC_PX_CMD[ST]=1. */
+	uint32_t rxts                         : 4;  /**< Receive transaction size. This field is R/W when SATA_UAHC_P(0..1)_CMD[ST] = 0
+                                                         and read only when SATA_UAHC_P(0..1)_CMD[ST] = 1. */
+	uint32_t txts                         : 4;  /**< Transmit transaction size. This field is R/W when SATA_UAHC_P(0..1)_CMD[ST] = 0
+                                                         and read only when SATA_UAHC_P(0..1)_CMD[ST] = 1. */
 #else
 	uint32_t txts                         : 4;
 	uint32_t rxts                         : 4;
@@ -1288,6 +1310,7 @@ union cvmx_sata_uahc_px_dmacr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_dmacr_s      cn70xx;
+	struct cvmx_sata_uahc_px_dmacr_s      cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_dmacr cvmx_sata_uahc_px_dmacr_t;
 
@@ -1309,6 +1332,7 @@ union cvmx_sata_uahc_px_fb {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_fb_s         cn70xx;
+	struct cvmx_sata_uahc_px_fb_s         cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_fb cvmx_sata_uahc_px_fb_t;
 
@@ -1342,6 +1366,7 @@ union cvmx_sata_uahc_px_fbs {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_fbs_s        cn70xx;
+	struct cvmx_sata_uahc_px_fbs_s        cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_fbs cvmx_sata_uahc_px_fbs_t;
 
@@ -1355,25 +1380,25 @@ union cvmx_sata_uahc_px_ie {
 	uint32_t u32;
 	struct cvmx_sata_uahc_px_ie_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t cpde                         : 1;  /**< Cold port detect enable. */
-	uint32_t tfee                         : 1;  /**< Task file error enable. */
-	uint32_t hbfe                         : 1;  /**< Host bus fatal error enable. */
-	uint32_t hbde                         : 1;  /**< Host bus data error enable. */
-	uint32_t ife                          : 1;  /**< Interface fatal error enable. */
-	uint32_t infe                         : 1;  /**< Interfave non-fatal error enable. */
+	uint32_t cpde                         : 1;  /**< Cold-port-detect enable. */
+	uint32_t tfee                         : 1;  /**< Task-file-error enable. */
+	uint32_t hbfe                         : 1;  /**< Host-bus fatal-error enable. */
+	uint32_t hbde                         : 1;  /**< Host-bus data-error enable. */
+	uint32_t ife                          : 1;  /**< Interface fatal-error enable. */
+	uint32_t infe                         : 1;  /**< Interface non-fatal-error enable. */
 	uint32_t reserved_25_25               : 1;
 	uint32_t ofe                          : 1;  /**< Overflow enable. */
-	uint32_t impe                         : 1;  /**< Incorrect port multiplier enable. */
-	uint32_t prce                         : 1;  /**< PHY ready change enable. */
+	uint32_t impe                         : 1;  /**< Incorrect port-multiplier enable. */
+	uint32_t prce                         : 1;  /**< PHY-ready-change enable. */
 	uint32_t reserved_8_21                : 14;
-	uint32_t dmpe                         : 1;  /**< Device mechanical presence enable. */
-	uint32_t pce                          : 1;  /**< Port connect change enable. */
-	uint32_t dpe                          : 1;  /**< Descriptor processed enable. */
-	uint32_t ufe                          : 1;  /**< Unknown FIS interrupt enable. */
-	uint32_t sdbe                         : 1;  /**< Set device bits interrupt enable. */
-	uint32_t dse                          : 1;  /**< DMA setup FIS interrupt enable. */
-	uint32_t pse                          : 1;  /**< PIO setup FIS interrupt enable. */
-	uint32_t dhre                         : 1;  /**< Device to host register FIS interrupt enable. */
+	uint32_t dmpe                         : 1;  /**< Device mechanical-presence enable. */
+	uint32_t pce                          : 1;  /**< Port-connect-change enable. */
+	uint32_t dpe                          : 1;  /**< Descriptor-processed enable. */
+	uint32_t ufe                          : 1;  /**< Unknown-FIS-interrupt enable. */
+	uint32_t sdbe                         : 1;  /**< Set device-bits-interrupt enable. */
+	uint32_t dse                          : 1;  /**< DMA-setup FIS interrupt enable. */
+	uint32_t pse                          : 1;  /**< PIO-setup FIS interrupt enable. */
+	uint32_t dhre                         : 1;  /**< Device-to-host register FIS interrupt enable. */
 #else
 	uint32_t dhre                         : 1;
 	uint32_t pse                          : 1;
@@ -1397,6 +1422,7 @@ union cvmx_sata_uahc_px_ie {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_ie_s         cn70xx;
+	struct cvmx_sata_uahc_px_ie_s         cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_ie cvmx_sata_uahc_px_ie_t;
 
@@ -1410,25 +1436,25 @@ union cvmx_sata_uahc_px_is {
 	uint32_t u32;
 	struct cvmx_sata_uahc_px_is_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t cpds                         : 1;  /**< Cold port detect status. */
-	uint32_t tfes                         : 1;  /**< Task file error status. */
-	uint32_t hbfs                         : 1;  /**< Host bus fatal error status. */
-	uint32_t hbds                         : 1;  /**< Host bus data error status. */
-	uint32_t ifs                          : 1;  /**< Interface fatal error status. */
-	uint32_t infs                         : 1;  /**< Interfave non-fatal error status. */
+	uint32_t cpds                         : 1;  /**< Cold-port detect status. */
+	uint32_t tfes                         : 1;  /**< Task-file error status. */
+	uint32_t hbfs                         : 1;  /**< Host-bus fatal-error status. */
+	uint32_t hbds                         : 1;  /**< Host-bus data-error status. */
+	uint32_t ifs                          : 1;  /**< Interface fatal-error status. */
+	uint32_t infs                         : 1;  /**< Interface non-fatal-error status. */
 	uint32_t reserved_25_25               : 1;
 	uint32_t ofs                          : 1;  /**< Overflow status. */
-	uint32_t imps                         : 1;  /**< Incorrect port multiplier status. */
-	uint32_t prcs                         : 1;  /**< PHY ready change status. */
+	uint32_t imps                         : 1;  /**< Incorrect port-multiplier status. */
+	uint32_t prcs                         : 1;  /**< PHY-ready change status. */
 	uint32_t reserved_8_21                : 14;
-	uint32_t dmps                         : 1;  /**< Device mechanical presence status. */
-	uint32_t pcs                          : 1;  /**< Port connect change status. */
+	uint32_t dmps                         : 1;  /**< Device mechanical-presence status. */
+	uint32_t pcs                          : 1;  /**< Port-connect-change status. */
 	uint32_t dps                          : 1;  /**< Descriptor processed. */
 	uint32_t ufs                          : 1;  /**< Unknown FIS interrupt. */
 	uint32_t sdbs                         : 1;  /**< Set device bits interrupt. */
 	uint32_t dss                          : 1;  /**< DMA setup FIS interrupt. */
 	uint32_t pss                          : 1;  /**< PIO setup FIS interrupt. */
-	uint32_t dhrs                         : 1;  /**< Device to host register FIS interrupt. */
+	uint32_t dhrs                         : 1;  /**< Device-to-host register FIS interrupt. */
 #else
 	uint32_t dhrs                         : 1;
 	uint32_t pss                          : 1;
@@ -1452,6 +1478,7 @@ union cvmx_sata_uahc_px_is {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_is_s         cn70xx;
+	struct cvmx_sata_uahc_px_is_s         cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_is cvmx_sata_uahc_px_is_t;
 
@@ -1471,6 +1498,7 @@ union cvmx_sata_uahc_px_phycr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_phycr_s      cn70xx;
+	struct cvmx_sata_uahc_px_phycr_s      cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_phycr cvmx_sata_uahc_px_phycr_t;
 
@@ -1490,6 +1518,7 @@ union cvmx_sata_uahc_px_physr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_physr_s      cn70xx;
+	struct cvmx_sata_uahc_px_physr_s      cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_physr cvmx_sata_uahc_px_physr_t;
 
@@ -1509,6 +1538,7 @@ union cvmx_sata_uahc_px_sact {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_sact_s       cn70xx;
+	struct cvmx_sata_uahc_px_sact_s       cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_sact cvmx_sata_uahc_px_sact_t;
 
@@ -1523,11 +1553,11 @@ union cvmx_sata_uahc_px_sctl {
 	struct cvmx_sata_uahc_px_sctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_10_31               : 22;
-	uint32_t ipm                          : 2;  /**< Interface power management transitions allowed. */
+	uint32_t ipm                          : 2;  /**< Interface power-management transitions allowed. */
 	uint32_t reserved_6_7                 : 2;
 	uint32_t spd                          : 2;  /**< Speed allowed. */
 	uint32_t reserved_3_3                 : 1;
-	uint32_t det                          : 3;  /**< Device detection initialization. */
+	uint32_t det                          : 3;  /**< Device-detection initialization. */
 #else
 	uint32_t det                          : 3;
 	uint32_t reserved_3_3                 : 1;
@@ -1538,6 +1568,7 @@ union cvmx_sata_uahc_px_sctl {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_sctl_s       cn70xx;
+	struct cvmx_sata_uahc_px_sctl_s       cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_sctl cvmx_sata_uahc_px_sctl_t;
 
@@ -1595,6 +1626,7 @@ union cvmx_sata_uahc_px_serr {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_serr_s       cn70xx;
+	struct cvmx_sata_uahc_px_serr_s       cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_serr cvmx_sata_uahc_px_serr_t;
 
@@ -1614,6 +1646,7 @@ union cvmx_sata_uahc_px_sig {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_sig_s        cn70xx;
+	struct cvmx_sata_uahc_px_sig_s        cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_sig cvmx_sata_uahc_px_sig_t;
 
@@ -1635,6 +1668,7 @@ union cvmx_sata_uahc_px_sntf {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_sntf_s       cn70xx;
+	struct cvmx_sata_uahc_px_sntf_s       cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_sntf cvmx_sata_uahc_px_sntf_t;
 
@@ -1660,6 +1694,7 @@ union cvmx_sata_uahc_px_ssts {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_ssts_s       cn70xx;
+	struct cvmx_sata_uahc_px_ssts_s       cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_ssts cvmx_sata_uahc_px_ssts_t;
 
@@ -1674,8 +1709,8 @@ union cvmx_sata_uahc_px_tfd {
 	struct cvmx_sata_uahc_px_tfd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_16_31               : 16;
-	uint32_t tferr                        : 8;  /**< Copy of task file error register. */
-	uint32_t sts                          : 8;  /**< Copy of task file status register. */
+	uint32_t tferr                        : 8;  /**< Copy of task-file error register. */
+	uint32_t sts                          : 8;  /**< Copy of task-file status register. */
 #else
 	uint32_t sts                          : 8;
 	uint32_t tferr                        : 8;
@@ -1683,6 +1718,7 @@ union cvmx_sata_uahc_px_tfd {
 #endif
 	} s;
 	struct cvmx_sata_uahc_px_tfd_s        cn70xx;
+	struct cvmx_sata_uahc_px_tfd_s        cn70xxp1;
 };
 typedef union cvmx_sata_uahc_px_tfd cvmx_sata_uahc_px_tfd_t;
 
@@ -1734,6 +1770,7 @@ union cvmx_sata_uctl_bist_status {
 #endif
 	} s;
 	struct cvmx_sata_uctl_bist_status_s   cn70xx;
+	struct cvmx_sata_uctl_bist_status_s   cn70xxp1;
 };
 typedef union cvmx_sata_uctl_bist_status cvmx_sata_uctl_bist_status_t;
 
@@ -1748,45 +1785,42 @@ union cvmx_sata_uctl_ctl {
 	uint64_t u64;
 	struct cvmx_sata_uctl_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t clear_bist                   : 1;  /**< BIST fast-clear mode select.
-                                                         There are 2 major modes of BIST: full and clear. Full BIST is run by the BIST state
-                                                         machine when clear_bist is deasserted during BIST. Clear BIST is run if clear_bist is
-                                                         asserted during BIST. A Clear BIST run will simply clear all entries in SATA RAMs to 0x0.
-                                                         To avoid race conditions, software must first perform a CSR write operation that puts the
-                                                         clear_bist setting into the correct state and then perform another CSR write operation to
-                                                         set the BIST trigger (keeping the clear_bist state constant).
-                                                         CLEAR BIST completion is indicated by SATA_UCTL_BIST_STATUS[NDONE]. A BIST clear operation
-                                                         takes almost 2,000 host-controller-clock cycles for the largest RAM. */
-	uint64_t start_bist                   : 1;  /**< Rising edge starts BIST on the memories in SATA.
-                                                         To run BIST, both the host-controller clock must be configured and enabled, and should be
-                                                         configured to the maximum available frequency given the available coprocessor clock and
-                                                         dividers.
-                                                         Also, the UCTL, UAHC, and UPHY should be held in software- initiated reset until BIST is
-                                                         complete.
-                                                         BIST defect status can be checked after FULL BIST completion, both of which are indicated
-                                                         in SATA_UCTL_BIST_STATUS. The full BIST run takes almost 80,000 host-controller-clock
-                                                         cycles
-                                                         for the largest RAM. */
+	uint64_t clear_bist                   : 1;  /**< BIST fast-clear mode select. There are two major modes of BIST: FULL and CLEAR.
+                                                         0 = FULL BIST is run by the BIST state machine.
+                                                         1 = CLEAR BIST is run by the BIST state machine. A clear-BIST run clears all entries in
+                                                         SATA RAMs to 0x0.
+                                                         To avoid race conditions, software must first perform a CSR write operation that puts
+                                                         CLEAR_BIST into the correct state and then perform another CSR write operation to set
+                                                         START_BIST (keeping CLEAR_BIST constant). CLEAR BIST completion is indicated by
+                                                         SATA_UCTL_BIST_STATUS[NDONE].
+                                                         A BIST clear operation takes almost 2,000 host-controller clock cycles for the largest
+                                                         RAM. */
+	uint64_t start_bist                   : 1;  /**< Start BIST. The rising edge starts BIST on the memories in SATA. To run BIST, the host-
+                                                         controller clock must be both configured and enabled, and should be configured to the
+                                                         maximum available frequency given the available coprocessor clock and dividers.
+                                                         Refer to Cold Reset for clock initialization procedures. BIST defect status can be checked
+                                                         after FULL BIST completion, both of which are indicated in SATA_UCTL_BIST_STATUS. The FULL
+                                                         BIST run takes almost 80,000 host-controller clock cycles for the largest RAM. */
 	uint64_t reserved_31_61               : 31;
-	uint64_t a_clk_en                     : 1;  /**< Host-controller-clock enable. When set to 1, the host-controller clock is generated. This
+	uint64_t a_clk_en                     : 1;  /**< Host-controller clock enable. When set to 1, the host-controller clock is generated. This
                                                          also enables access to UCTL registers 0x30-0xF8. */
-	uint64_t a_clk_byp_sel                : 1;  /**< Select the bypass input to the host-controller-clock divider.
+	uint64_t a_clk_byp_sel                : 1;  /**< Select the bypass input to the host-controller clock divider.
                                                          0 = use the divided coprocessor clock from the A_CLKDIV divider
-                                                         1 = use the bypass clock from the GPIO pins
-                                                         Generally bypass is only used for scan purposes.
-                                                         This signal is just a multiplexer-select signal; it does not enable the host-controller
-                                                         clock. You must still set A_CLK_EN separately. A_CLK_BYP_SEL select should not be
-                                                         changed unless A_CLK_EN is disabled.
-                                                         The bypass clock can be selected and running even if the host-controller-clock dividers
-                                                         are not running. */
+                                                         1 = use the bypass clock from the GPIO pins (generally bypass is only used for scan
+                                                         purposes).
+                                                         This signal is a multiplexer-select signal; it does not enable the host-controller clock.
+                                                         You must set A_CLK_EN separately. A_CLK_BYP_SEL select should not be changed unless
+                                                         A_CLK_EN is disabled. The bypass clock can be selected and running even if the host-
+                                                         controller clock dividers are not running. */
 	uint64_t a_clkdiv_rst                 : 1;  /**< Host-controller-clock divider reset. Divided clocks are not generated while the divider is
                                                          being reset.
                                                          This also resets the suspend-clock divider. */
 	uint64_t reserved_27_27               : 1;
-	uint64_t a_clkdiv_sel                 : 3;  /**< The hclk frequency is sclk frequency divided by A_CLKDIV_SEL.
-                                                         The host-controller-clock frequency must be at or below 333MHz.
-                                                         This field can be changed only when A_CLKDIV_RST = 1.
-                                                         The divider values are the following:
+	uint64_t a_clkdiv_sel                 : 3;  /**< The host-controller clock frequency is the coprocessor-clock frequency divided by
+                                                         A_CLKDIV_SEL. The host-controller clock frequency must be at or below the requirements
+                                                         listed in Table 22-1 (Maximum ACLK Frequency).
+                                                         This field can be changed only when A_CLKDIV_RST = 1. The divider values are the
+                                                         following:
                                                          0x0 = divide by 1 0x4 = divide by 6
                                                          0x1 = divide by 2 0x5 = divide by 8
                                                          0x2 = divide by 3 0x6 = divide by 16
@@ -1798,11 +1832,11 @@ union cvmx_sata_uctl_ctl {
 	uint64_t sata_uahc_rst                : 1;  /**< Software reset; resets UAHC; active-high.
                                                          INTERNAL: Note that soft-resetting the UAHC while it is active may cause violations of RSL
                                                          or NCB protocols. */
-	uint64_t sata_uctl_rst                : 1;  /**< Software reset; resets UCTL; active-high.
-                                                         Resets UAHC DMA and register shims. Resets UCTL RSL registers 0x30-0xF8.
-                                                         Does not reset UCTL RSL registers 0x0-0x28.
-                                                         UCTL RSL registers starting from 0x30 can be accessed only after the host-controller clock
-                                                         is active and UCTL_RST is deasserted.
+	uint64_t sata_uctl_rst                : 1;  /**< Software reset; resets UCTL; active-high. Resets UAHC DMA and register shims and the UCTL
+                                                         RSL registers 0x30-0xF8.
+                                                         It does not reset UCTL RSL registers 0x0-0x28.
+                                                         The UCTL RSL registers starting from 0x30 can be accessed only after the host-controller
+                                                         clock is active and UCTL_RST is deasserted.
                                                          INTERNAL: Note that soft-resetting the UCTL while it is active may cause violations of
                                                          RSL, NCB, and CIB protocols. */
 #else
@@ -1822,6 +1856,7 @@ union cvmx_sata_uctl_ctl {
 #endif
 	} s;
 	struct cvmx_sata_uctl_ctl_s           cn70xx;
+	struct cvmx_sata_uctl_ctl_s           cn70xxp1;
 };
 typedef union cvmx_sata_uctl_ctl cvmx_sata_uctl_ctl_t;
 
@@ -1837,19 +1872,17 @@ union cvmx_sata_uctl_intstat {
 	struct cvmx_sata_uctl_intstat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. Error information is logged in
+	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. The error information is logged in
                                                          SATA_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates the
                                                          assumptions made by the AXI-to-IOI shim. Such scenarios include: illegal length/size
                                                          combinations and address out-of-bounds.
                                                          For more information on exact failures, see description in
                                                          SATA_UCTL_SHIM_CFG[XM_BAD_DMA_TYPE].
                                                          The hardware does not translate the request correctly and results may violate IOI
-                                                         protocols.
-                                                         Throws SATA_UCTL_INTSN_E::SATA_UCTL_INTSTAT_XM_BAD_DMA. */
+                                                         protocols. */
 	uint64_t xs_ncb_oob                   : 1;  /**< Detected out-of-bound register access to UAHC over IOI. The UAHC defines 1MB of register
                                                          space, starting at offset 0x0. Any accesses outside of this register space cause this bit
-                                                         to be set to 1. Error information is logged in SATA_UCTL_SHIM_CFG[XS_NCB_OOB_*].
-                                                         Throws SATA_UCTL_INTSN_E::SATA_UCTL_INTSTAT_XS_NCB_OOB. */
+                                                         to be set to 1. The error information is logged in SATA_UCTL_SHIM_CFG[XS_NCB_OOB_*]. */
 	uint64_t reserved_0_0                 : 1;
 #else
 	uint64_t reserved_0_0                 : 1;
@@ -1859,6 +1892,7 @@ union cvmx_sata_uctl_intstat {
 #endif
 	} s;
 	struct cvmx_sata_uctl_intstat_s       cn70xx;
+	struct cvmx_sata_uctl_intstat_s       cn70xxp1;
 };
 typedef union cvmx_sata_uctl_intstat cvmx_sata_uctl_intstat_t;
 
@@ -1878,12 +1912,11 @@ union cvmx_sata_uctl_shim_cfg {
 	struct cvmx_sata_uctl_shim_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t xs_ncb_oob_wrn               : 1;  /**< Read/write error log for out-of-bound UAHC register access.
-                                                         0 = read, 1 = write */
+                                                         0 = read, 1 = write. */
 	uint64_t reserved_57_62               : 6;
-	uint64_t xs_ncb_oob_osrc              : 9;  /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB
-                                                         error. */
+	uint64_t xs_ncb_oob_osrc              : 9;  /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB error. */
 	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
-                                                         0 = read error log, 1 = write error log */
+                                                         0 = read error log, 1 = write error log. */
 	uint64_t reserved_44_46               : 3;
 	uint64_t xm_bad_dma_type              : 4;  /**< ErrType error log for bad DMA access from UAHC. Encodes the type of error encountered
                                                          (error largest encoded value has priority). See SATA_UCTL_XM_BAD_DMA_TYPE_E. */
@@ -1910,6 +1943,7 @@ union cvmx_sata_uctl_shim_cfg {
 #endif
 	} s;
 	struct cvmx_sata_uctl_shim_cfg_s      cn70xx;
+	struct cvmx_sata_uctl_shim_cfg_s      cn70xxp1;
 };
 typedef union cvmx_sata_uctl_shim_cfg cvmx_sata_uctl_shim_cfg_t;
 
@@ -1930,6 +1964,7 @@ union cvmx_sata_uctl_spare0 {
 #endif
 	} s;
 	struct cvmx_sata_uctl_spare0_s        cn70xx;
+	struct cvmx_sata_uctl_spare0_s        cn70xxp1;
 };
 typedef union cvmx_sata_uctl_spare0 cvmx_sata_uctl_spare0_t;
 
@@ -1950,6 +1985,7 @@ union cvmx_sata_uctl_spare1 {
 #endif
 	} s;
 	struct cvmx_sata_uctl_spare1_s        cn70xx;
+	struct cvmx_sata_uctl_spare1_s        cn70xxp1;
 };
 typedef union cvmx_sata_uctl_spare1 cvmx_sata_uctl_spare1_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h b/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
index 1b58272..b994cd8 100644
--- a/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -1563,17 +1563,19 @@ typedef union cvmx_uahcx_caplength cvmx_uahcx_caplength_t;
 /**
  * cvmx_uahc#_config
  *
- * See xHCI specification v1.0 section 5.4.7.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or
- * UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.7.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_config {
 	uint32_t u32;
 	struct cvmx_uahcx_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_8_31                : 24;
-	uint32_t maxslotsen                   : 8;  /**< Maximum device slots enabled */
+	uint32_t maxslotsen                   : 8;  /**< Maximum device slots enabled. */
 #else
 	uint32_t maxslotsen                   : 8;
 	uint32_t reserved_8_31                : 24;
@@ -1586,10 +1588,12 @@ typedef union cvmx_uahcx_config cvmx_uahcx_config_t;
 /**
  * cvmx_uahc#_crcr
  *
- * See xHCI specification v1.0 section 5.4.5.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or
- * UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.5.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_crcr {
 	uint64_t u64;
@@ -1617,11 +1621,14 @@ typedef union cvmx_uahcx_crcr cvmx_uahcx_crcr_t;
 /**
  * cvmx_uahc#_db#
  *
- * See xHCI specification v1.0 section 5.6.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or
- * UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
- * INTERNAL: xHCI spec, page 32: there are UAHC(0)_HCSPARAMS1[MAXSLOTS]+1 doorbell registers.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.6.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
+ *
+ * INTERNAL: xHCI spec, page 32: there are UAHC()_HCSPARAMS1[MAXSLOTS]+1 doorbell registers.
  */
 union cvmx_uahcx_dbx {
 	uint32_t u32;
@@ -1664,10 +1671,12 @@ typedef union cvmx_uahcx_dboff cvmx_uahcx_dboff_t;
 /**
  * cvmx_uahc#_dcbaap
  *
- * See xHCI specification v1.0 section 5.4.6.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or
- * UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.6.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_dcbaap {
 	uint64_t u64;
@@ -1687,10 +1696,12 @@ typedef union cvmx_uahcx_dcbaap cvmx_uahcx_dcbaap_t;
 /**
  * cvmx_uahc#_dnctrl
  *
- * See xHCI specification v1.0 section 5.4.4.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or
- * UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.4.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_dnctrl {
 	uint32_t u32;
@@ -2678,16 +2689,18 @@ typedef union cvmx_uahcx_ehci_usbsts cvmx_uahcx_ehci_usbsts_t;
 /**
  * cvmx_uahc#_erdp#
  *
- * See xHCI specification v1.0 section 5.5.2.3.3.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or
- * UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.3.3.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_erdpx {
 	uint64_t u64;
 	struct cvmx_uahcx_erdpx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t erdp                         : 60; /**< Event ring dequeue pointer bits<31:4>. */
+	uint64_t erdp                         : 60; /**< Event ring dequeue pointer bits <63:4>. */
 	uint64_t ehb                          : 1;  /**< Event handler busy */
 	uint64_t desi                         : 3;  /**< Dequeue ERST segment index. */
 #else
@@ -2703,16 +2716,18 @@ typedef union cvmx_uahcx_erdpx cvmx_uahcx_erdpx_t;
 /**
  * cvmx_uahc#_erstba#
  *
- * See xHCI specification v1.0 section 5.5.2.3.2.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or
- * UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.3.2.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_erstbax {
 	uint64_t u64;
 	struct cvmx_uahcx_erstbax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t erstba                       : 58; /**< Event-ring segment-table base-address. */
+	uint64_t erstba                       : 58; /**< Event-ring segment-table base-address bits<63:6>. */
 	uint64_t reserved_0_5                 : 6;
 #else
 	uint64_t reserved_0_5                 : 6;
@@ -2726,9 +2741,12 @@ typedef union cvmx_uahcx_erstbax cvmx_uahcx_erstbax_t;
 /**
  * cvmx_uahc#_erstsz#
  *
- * See xHCI specification v1.0 section 5.5.2.3.1.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.3.1.
+ *
+ * This register can be reset by NCB reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_erstszx {
 	uint32_t u32;
@@ -2750,24 +2768,27 @@ typedef union cvmx_uahcx_erstszx cvmx_uahcx_erstszx_t;
  *
  * When the AXI Master Bus returns Error response, the SoC Bus Error is generated. In the host
  * mode, the host_system_err port indicates this condition. In addition, it is also indicated in
- * UAHC(0)_USBSTS[HSE]. Due to the nature of AXI, it is possible that multiple AXI transactions
- * are active at a time. The Host Controller does not keep track of the start address of all
+ * UAHC()_USBSTS[HSE]. Due to the nature of AXI, it is possible that multiple AXI transactions
+ * are active at a time. The host controller does not keep track of the start address of all
  * outstanding transactions. Instead, it keeps track of the start address of the DMA transfer
- * associated with all active transactions. It is this address that is reported in the
- * GBUSERRADDR when a bus error occurs. For example, if the host controller initiates a DMA
+ * associated with all active transactions. It is this address that is reported in
+ * UAHC()_GBUSERRADDR when a bus error occurs. For example, if the host controller initiates a
+ * DMA
  * transfer to write 1k of packet data starting at buffer address 0xABCD0000, and this DMA is
  * broken up into multiple 256B bursts on the AXI, then if a bus error occurs on any of these
- * associated AXI transfers, the GBUSERRADDR reflects the DMA start address of 0xABCD0000
+ * associated AXI transfers, UAHC()_GBUSERRADDR reflects the DMA start address of 0xABCD0000
  * regardless of which AXI transaction received the error.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.12.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gbuserraddr {
 	uint64_t u64;
 	struct cvmx_uahcx_gbuserraddr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t busaddr                      : 64; /**< Bus address. Contains the first bus address that encountered an SoC bus error. It is valid
-                                                         when the UAHC(0)_GSTS[BUSERRADDRVLD] = 1. It can only be cleared by resetting the core. */
+                                                         when the UAHC()_GSTS[BUSERRADDRVLD] = 1. It can only be cleared by resetting the core. */
 #else
 	uint64_t busaddr                      : 64;
 #endif
@@ -2779,8 +2800,9 @@ typedef union cvmx_uahcx_gbuserraddr cvmx_uahcx_gbuserraddr_t;
 /**
  * cvmx_uahc#_gctl
  *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.5.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gctl {
 	uint32_t u32;
@@ -2800,9 +2822,9 @@ union cvmx_uahcx_gctl {
                                                          accuracy = 18 ms (Range is 12 ms - 18 ms)
                                                          100 ms + 0~+50% accuracy = 150 ms (Range is 100 ms - 150 ms).
                                                          The suspend clock accuracy requirement is:
-                                                         (12,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period should be between 12,000 and
+                                                         _ (12,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period should be between 12,000 and
                                                          18,000
-                                                         (100,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period should be between 100,000 and
+                                                         _ (100,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period should be between 100,000 and
                                                          150,000
                                                          For example, if your suspend_clk frequency varies from 7.5 MHz to 10.5MHz, then the value
                                                          needs to programmed is: Power Down Scale = 10500/16 = 657 (rounded up; and fastest
@@ -2810,26 +2832,25 @@ union cvmx_uahcx_gctl {
 	uint32_t masterfiltbypass             : 1;  /**< Master filter bypass. Not relevant for Cavium's configuration. */
 	uint32_t reserved_16_17               : 2;
 	uint32_t frmscldwn                    : 2;  /**< Frame scale down. Scales down device view of a SOF/USOF/ITP duration.
-                                                         For SS/HS mode:
-                                                         0x3 = Interval is 15.625 us
-                                                         0x2 = Interval is 31.25 us
-                                                         0x1 = Interval is 62.5 us
-                                                         0x0 = Interval is 125 us
-                                                         For FS mode, the scale-down value is multiplied by 8. */
+                                                         For SuperSpeed/high-speed mode:
+                                                         0x0 = Interval is 125 us.
+                                                         0x1 = Interval is 62.5 us.
+                                                         0x2 = Interval is 31.25 us.
+                                                         0x3 = Interval is 15.625 us.
+                                                         For full-speed mode, the scale-down value is multiplied by 8. */
 	uint32_t prtcapdir                    : 2;  /**< Port capability direction. Always keep set to 0x1. */
 	uint32_t coresoftreset                : 1;  /**< Core soft reset: 1 = soft reset to core, 0 = no soft reset.
-                                                         Clears the interrupts and all the UAHC(0)_* CSRs except the
-                                                         following registers: UAHC(0)_GCTL, UAHC(0)_GUCTL, UAHC(0)_GSTS,
-                                                         UAHC(0)_GRLSID, UAHC(0)_GGPIO, UAHC(0)_GUID, UAHC(0)_GUSB2PHYCFG[*],
-                                                         UAHC(0)_GUSB3PIPECTL[*].
-                                                         When you reset PHYs (using UAHC(0)_GUBS3PHYCFG or UAHC(0)_GUSB3PIPECTL
-                                                         registers), you must keep the core in reset state until PHY
-                                                         clocks are stable. This controls the bus, ram, and mac domain
-                                                         resets.
+                                                         Clears the interrupts and all the UAHC()_* CSRs except the
+                                                         following registers: UAHC()_GCTL, UAHC()_GUCTL, UAHC()_GSTS,
+                                                         UAHC()_GRLSID, UAHC()_GGPIO, UAHC()_GUID, UAHC()_GUSB2PHYCFG(),
+                                                         UAHC()_GUSB3PIPECTL().
+                                                         When you reset PHYs (using UAHC()_GUSB2PHYCFG() or UAHC()_GUSB3PIPECTL()), you must keep
+                                                         the
+                                                         core in reset state until PHY clocks are stable. This controls the bus, RAM, and MAC
+                                                         domain resets.
                                                          INTERNAL: Refer to Reset Generation on Synopsys Databook page 250.
-                                                         Note: Under soft reset, accesses to UAHC(0)_* CSRs other than UAHC(0)_GCTL
-                                                         may fail (Timeout).
-                                                         Note: This bit is for debug purposes only. Use USBCMD.HCRESET for soft reset. */
+                                                         Under soft reset, accesses to UAHC()_* CSRs other than UAHC()_GCTL may fail (timeout).
+                                                         This bit is for debug purposes only. Use UAHC()_USBCMD[HCRST] for soft reset. */
 	uint32_t sofitpsync                   : 1;  /**< Synchronize ITP to reference clock. In host mode, if this bit is set to:
                                                          0 = The core keeps the UTMI/ULPI PHY on the first port in non-suspended state whenever
                                                          there is a SuperSpeed port that is not in Rx.Detect, SS.Disable, and U3 state.
@@ -2838,52 +2859,48 @@ union cvmx_uahcx_gctl {
                                                          This feature is useful because it saves power by suspending UTMI/ULPI when SuperSpeed only
                                                          is active and it helps resolve when the PHY does not transmit a host resume unless it is
                                                          placed in suspend state.
-                                                         This bit must be programmed as a part of initialization at power-on reset, and must not be
-                                                         dynamically changed afterwards.
-                                                         Note: UAHC(0)_USB2PHYCFG[*][SUSPHY] eventually decides to put the UTMI/ULPI PHY in to
-                                                         suspend state. In addition, when this bit is set to 1, the core generates ITP off of the
-                                                         REF_CLK-based counter. Otherwise, ITP and SOF are generated off of UTMI/ULPI_CLK[0] based
-                                                         counter. To program the reference clock period inside the core, refer to
-                                                         UAHC(0)_GUCTL[REFCLKPER].
-                                                         INTERNAL: If you do not plan to ever use this feature or the
-                                                         UAHC(0)_GFLADJ[GFLADJ_REFCLK_LPM_SEL] feature, the minimum frequence for the ref_clk can
-                                                         be as low as 32KHz. You can connect the SUSPEND_CLK (as low as 32 KHz) to REF_CLK.
-                                                         Note: If you plan to enable hardware-based LPM (PORTPMSC.HLE = 1), this feature cannot be
-                                                         used. Turn off this feature by setting this bit to zero and use the
-                                                         UAHC(0)_GFLADJ[GFLADJ_REFCLK_LPM_SEL] feature.
-                                                         Note: If you set this bit to 1, the UAHC(0)_GUSB2PHYCFG[U2_FREECLK_EXISTS] bit must be set
-                                                         to zero. */
-	uint32_t u1u2timerscale               : 1;  /**< Disable U1/U2 timer scaledown. If set to 1, along with SCALEDOWN =0x1, disables the scale
+                                                         UAHC()_GUSB2PHYCFG()[SUSPHY] eventually decides to put the UTMI/ULPI PHY in to suspend
+                                                         state. In addition, when this bit is set to 1, the core generates ITP off of the REF_CLK-
+                                                         based counter. Otherwise, ITP and SOF are generated off of UTMI/ULPI_CLK[0] based counter.
+                                                         To program the reference clock period inside the core, refer to UAHC()_GUCTL[REFCLKPER].
+                                                         If you do not plan to ever use this feature or the UAHC()_GFLADJ[GFLADJ_REFCLK_LPM_SEL]
+                                                         feature, the minimum frequency for the ref_clk can be as low as 32KHz. You can connect the
+                                                         SUSPEND_CLK (as low as 32 KHz) to REF_CLK.
+                                                         If you plan to enable hardware-based LPM (PORTPMSC[HLE] = 1), this feature cannot be used.
+                                                         Turn off this feature by setting this bit to zero and use the
+                                                         UAHC()_GFLADJ[GFLADJ_REFCLK_LPM_SEL] feature.
+                                                         If you set this bit to 1, the UAHC()_GUSB2PHYCFG() [U2_FREECLK_EXISTS] bit must be set to
+                                                         0. */
+	uint32_t u1u2timerscale               : 1;  /**< Disable U1/U2 timer scaledown. If set to 1, along with SCALEDOWN = 0x1, disables the scale
                                                          down of U1/U2 inactive timer values.
                                                          This is for simulation mode only. */
 	uint32_t debugattach                  : 1;  /**< Debug attach. When this bit is set:
-                                                         SS link proceeds directly to the polling-link state (after RUN/STOP in the DCTL register
-                                                         is asserted) without checking remote termination.
-                                                         Link LFPS polling timeout is infinite
-                                                         Polling timeout during TS1 is infinite (in case link is waiting for TXEQ to finish). */
+                                                         * SuperSpeed link proceeds directly to the polling-link state (UAHC()_DCTL[RS] = 1)
+                                                         without checking remote termination.
+                                                         * Link LFPS polling timeout is infinite
+                                                         * Polling timeout during TS1 is infinite (in case link is waiting for TXEQ to finish). */
 	uint32_t ramclksel                    : 2;  /**< RAM clock select. Always keep set to 0x0. */
 	uint32_t scaledown                    : 2;  /**< Scale-down mode. When scale-down mode is enabled for simulation, the core uses scaled-down
                                                          timing values, resulting in faster simulations. When scale-down mode is disabled, actual
                                                          timing values are used. This is required for hardware operation.
-                                                         HS/FS/LS modes:
-                                                         0x0 = disables all scale-downs. Actual timing values are used.
-                                                         0x1 = enables scale-down of all timing values. These include:
-                                                         speed enumeration
-                                                         HNP/SRP
-                                                         suspend and resume
+                                                         High-speed/full-speed/low-speed modes:
+                                                         0x0 = Disables all scale-downs. Actual timing values are used.
+                                                         0x1 = Enables scale-down of all timing values. These include:
+                                                         * Speed enumeration
+                                                         * HNP/SRP
+                                                         * Suspend and resume
                                                          0x2 = N/A
-                                                         0x3 = enables bits <0> and <1> scale-down timing values.
-                                                         SS mode:
-                                                         0x0 = disables all scale-downs. Actual timing values are used.
-                                                         0x1 = enables scaled down SS timing and repeat values including:
-                                                         number of TxEq training sequences reduce to eight
-                                                         LFPS polling burst time reduce to 100 ns
-                                                         LFPS warm reset receive reduce to 30 us.
+                                                         0x3 = Enables bits <0> and <1> scale-down timing values.
+                                                         SuperSpeed mode:
+                                                         0x0 = Disables all scale-downs. Actual timing values are used.
+                                                         0x1 = Enables scaled down SuperSpeed timing and repeat values including:
+                                                         * Number of TxEq training sequences reduce to eight
+                                                         * LFPS polling burst time reduce to 100 ns
+                                                         * LFPS warm reset receive reduce to 30 us.
                                                          INTERNAL: Refer to the rtl_vip_scaledown_mapping.xls file under <workspace>/sim/SoC_sim
-                                                         directory
-                                                         for the complete list.
-                                                         0x2 = no TxEq training sequences are sent. Overrides bit<4>.
-                                                         0x3 = enables bits<0> and <1> scale-down timing values. */
+                                                         directory for the complete list.
+                                                         0x2 = No TxEq training sequences are sent. Overrides bit<4>.
+                                                         0x3 = Enables bits<0> and <1> scale-down timing values. */
 	uint32_t disscramble                  : 1;  /**< Disable scrambling. Transmit request to link partner on next transition to recovery or polling. */
 	uint32_t u2exit_lfps                  : 1;  /**< LFPS U2 exit.
                                                          0 = The link treats 248ns LFPS as a valid U2 exit.
@@ -2922,8 +2939,10 @@ typedef union cvmx_uahcx_gctl cvmx_uahcx_gctl_t;
 /**
  * cvmx_uahc#_gdbgbmu
  *
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
+ * See description in UAHC()_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.5.
  */
 union cvmx_uahcx_gdbgbmu {
@@ -2946,10 +2965,9 @@ typedef union cvmx_uahcx_gdbgbmu cvmx_uahcx_gdbgbmu_t;
 /**
  * cvmx_uahc#_gdbgepinfo
  *
- * See description in DBGFIFOSPACE.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.8.
- * INTERNAL: This register is for Synopsys internal use only.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
+ * See description in UAHC()_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
  */
 union cvmx_uahcx_gdbgepinfo {
 	uint64_t u64;
@@ -2967,15 +2985,16 @@ typedef union cvmx_uahcx_gdbgepinfo cvmx_uahcx_gdbgepinfo_t;
 /**
  * cvmx_uahc#_gdbgfifospace
  *
- * These registers are for debug purposes. They provide debug information on the internal status
- * and state machines.
- * Global Debug Registers have design-specific information, and are used by for
- * debugging purposes. These registers are not intended to be used by the customer. If any
- * debug assistance is needed for the silicon, contact Customer Support with a dump
- * of these registers.
+ * This register is for debug purposes. It provides debug information on the internal status and
+ * state machines. Global debug registers have design-specific information, and are used by state
+ * machines. Global debug registers have design-specific information, and are used for debugging
+ * purposes. These registers are not intended to be used by the customer. If any debug assistance
+ * is needed for the silicon, contact customer support with a dump of these registers.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.2.
  * INTERNAL: Contact Synopsys directly.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gdbgfifospace {
 	uint32_t u32;
@@ -2987,15 +3006,15 @@ union cvmx_uahcx_gdbgfifospace {
                                                          FIFO/queue select: <7:5> indicates the FIFO/queue type; <4:0> indicates the FIFO/queue
                                                          number.
                                                          For example, 0x21 refers to RxFIFO_1, and 0x5E refers to TxReqQ_30.
-                                                         0x1F-0x0: TxFIFO_31 to TxFIFO_0
-                                                         0x3F-0x20: RxFIFO_31 to RxFIFO_0
-                                                         0x5F-0x40: TxReqQ_31 to TxReqQ_0
-                                                         0x7F-0x60: RxReqQ_31 to RxReqQ_0
-                                                         0x9F-0x80: RxInfoQ_31 to RxInfoQ_0
-                                                         0xA0: DescFetchQ
-                                                         0xA1: EventQ
-                                                         0xA2: ProtocolStatusQ
-                                                         Port-select: <3:0> selects the port-number when accessing UAHC(0)_GDBGLTSSM. */
+                                                         0x1F-0x0: TxFIFO_31 to TxFIFO_0.
+                                                         0x3F-0x20: RxFIFO_31 to RxFIFO_0.
+                                                         0x5F-0x40: TxReqQ_31 to TxReqQ_0.
+                                                         0x7F-0x60: RxReqQ_31 to RxReqQ_0.
+                                                         0x9F-0x80: RxInfoQ_31 to RxInfoQ_0.
+                                                         0xA0: DescFetchQ.
+                                                         0xA1: EventQ.
+                                                         0xA2: ProtocolStatusQ.
+                                                         Port-select: <3:0> selects the port-number when accessing UAHC()_GDBGLTSSM. */
 #else
 	uint32_t select                       : 8;
 	uint32_t reserved_8_15                : 8;
@@ -3009,8 +3028,10 @@ typedef union cvmx_uahcx_gdbgfifospace cvmx_uahcx_gdbgfifospace_t;
 /**
  * cvmx_uahc#_gdbglnmcc
  *
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
+ * See description in UAHC()_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.4.
  */
 union cvmx_uahcx_gdbglnmcc {
@@ -3019,7 +3040,7 @@ union cvmx_uahcx_gdbglnmcc {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_9_31                : 23;
 	uint32_t lnmcc_berc                   : 9;  /**< This field indicates the bit-error-rate information for the port selected in
-                                                         UAHC(0)_GDBGFIFOSPACE[SELECT] (port-select).
+                                                         UAHC()_GDBGFIFOSPACE[SELECT] (port-select).
                                                          This field is for debug purposes only. */
 #else
 	uint32_t lnmcc_berc                   : 9;
@@ -3033,10 +3054,9 @@ typedef union cvmx_uahcx_gdbglnmcc cvmx_uahcx_gdbglnmcc_t;
 /**
  * cvmx_uahc#_gdbglsp
  *
- * See description in DBGFIFOSPACE.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.7.
- * INTERNAL: This register is for Synopsys internal use only.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
+ * See description in UAHC()_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
  */
 union cvmx_uahcx_gdbglsp {
 	uint32_t u32;
@@ -3054,10 +3074,12 @@ typedef union cvmx_uahcx_gdbglsp cvmx_uahcx_gdbglsp_t;
 /**
  * cvmx_uahc#_gdbglspmux
  *
- * See description in DBGFIFOSPACE.
+ * See description in UAHC()_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.6.
  * INTERNAL: This register is for Synopsys internal use only.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gdbglspmux {
 	uint32_t u32;
@@ -3069,11 +3091,11 @@ union cvmx_uahcx_gdbglspmux {
                                                          A value of 0x3F drives 0s on the logic_analyzer_trace signal. If you plan to OR (instead
                                                          using a mux) this signal with other trace signals in your system to generate a common
                                                          trace signal, you can use this feature. */
-	uint32_t endbc                        : 1;  /**< Enable debugging of the Debug Capability LSP. Use HOSTSELECT to select the DbC LSP debug
+	uint32_t endbc                        : 1;  /**< Enable debugging of the debug capability LSP. Use HOSTSELECT to select the DbC LSP debug
                                                          information presented in the GDBGLSP register.
                                                          INTERNAL: Note this can only be used if DebugCapabaility was enabled at compile. */
 	uint32_t reserved_14_14               : 1;
-	uint32_t hostselect                   : 14; /**< Host select. Selects the LSP debug information presented in UAHC(0)_GDBGLSP. */
+	uint32_t hostselect                   : 14; /**< Host select. Selects the LSP debug information presented in UAHC()_GDBGLSP. */
 #else
 	uint32_t hostselect                   : 14;
 	uint32_t reserved_14_14               : 1;
@@ -3090,9 +3112,11 @@ typedef union cvmx_uahcx_gdbglspmux cvmx_uahcx_gdbglspmux_t;
  * cvmx_uahc#_gdbgltssm
  *
  * In multiport host configuration, the port number is defined by
- * UAHC(0)_GDBGFIFOSPACE[SELECT]<3:0>. Value of this register may change immediately after reset.
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
+ * UAHC()_GDBGFIFOSPACE[SELECT]<3:0>. Value of this register may change immediately after reset.
+ * See description in UAHC()_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.3.
  */
 union cvmx_uahcx_gdbgltssm {
@@ -3103,31 +3127,31 @@ union cvmx_uahcx_gdbgltssm {
 	uint32_t ltdbtimeout                  : 1;  /**< LTDB timeout. */
 	uint32_t ltdblinkstate                : 4;  /**< LTDB link state. */
 	uint32_t ltdbsubstate                 : 4;  /**< LTDB substate. */
-	uint32_t debugpipestatus              : 18; /**< Debug PIPE Status.
-                                                         <17> Elastic Buffer Mode
-                                                         <16> Tx Elec Idle
-                                                         <15> Rx Polarity
-                                                         <14> Tx Detect Rx/Loopback
-                                                         <13:11> LTSSM PHY command State
-                                                         0x0: PHY_IDLE (PHY command state is in IDLE. No PHY request pending)
-                                                         0x1: PHY_DET (Request to start Receiver detection)
-                                                         0x2: PHY_DET_3 (Wait for Phy_Status (Receiver detection))
-                                                         0x3: PHY_PWR_DLY (Delay Pipe3_PowerDown P0 -> P1/P2/P3 request)
-                                                         0x4: PHY_PWR_A (Delay for internal logic)
-                                                         0x5: PHY_PWR_B (Wait for Phy_Status(Power state change request))
-                                                         <10:9> Power Down
-                                                         <8> RxEq Train
-                                                         <7:6> Tx Deemphasis
-                                                         <5:3> LTSSM Clock State
-                                                         0x0: CLK_NORM (PHY is in non-P3 state and PCLK is running)
-                                                         0x1: CLK_TO_P3 (P3 entry request to PHY)
-                                                         0x2: CLK_WAIT1 (Wait for Phy_Status (P3 request))
-                                                         0x3: CLK_P3 (PHY is in P3 and PCLK is not running)
-                                                         0x4: CLK_TO_P0 (P3 exit request to PHY)
-                                                         0x5: CLK_WAIT2 (Wait for Phy_Status (P3 exit request))
-                                                         <2> Tx Swing
-                                                         <1> Rx Termination
-                                                         <0> Tx Ones/Zeros */
+	uint32_t debugpipestatus              : 18; /**< Debug PIPE status.
+                                                         _ <17> Elastic buffer mode.
+                                                         _ <16> TX elec idle.
+                                                         _ <15> RX polarity.
+                                                         _ <14> TX Detect RX/loopback.
+                                                         _ <13:11> LTSSM PHY command state.
+                                                         _ 0x0 = PHY_IDLE (PHY command state is in IDLE. No PHY request is pending.)
+                                                         _ 0x1 = PHY_DET (Request to start receiver detection).
+                                                         _ 0x2 = PHY_DET_3 (Wait for Phy_Status (receiver detection)).
+                                                         _ 0x3 = PHY_PWR_DLY (delay Pipe3_PowerDown P0 -> P1/P2/P3 request).
+                                                         _ 0x4 = PHY_PWR_A (delay for internal logic).
+                                                         _ 0x5 = PHY_PWR_B (wait for Phy_Status(Power-state change request)).
+                                                         _ <10:9> Power down.
+                                                         _ <8> RxEq train.
+                                                         _ <7:6> TX de-emphasis.
+                                                         _ <5:3> LTSSM clock state.
+                                                         _ 0x0 = CLK_NORM (PHY is in non-P3 state and PCLK is running).
+                                                         _ 0x1 = CLK_TO_P3 (P3 entry request to PHY).
+                                                         _ 0x2 = CLK_WAIT1 (wait for Phy_Status (P3 request)).
+                                                         _ 0x3 = CLK_P3 (PHY is in P3 and PCLK is not running).
+                                                         _ 0x4 = CLK_TO_P0 (P3 exit request to PHY).
+                                                         _ 0x5 = CLK_WAIT2 (Wait for Phy_Status (P3 exit request)).
+                                                         _ <2> TX swing.
+                                                         _ <1> RX termination.
+                                                         _ <0> TX 1s/0s. */
 #else
 	uint32_t debugpipestatus              : 18;
 	uint32_t ltdbsubstate                 : 4;
@@ -3144,19 +3168,27 @@ typedef union cvmx_uahcx_gdbgltssm cvmx_uahcx_gdbgltssm_t;
  * cvmx_uahc#_gdmahlratio
  *
  * This register specifies the relative priority of the SuperSpeed FIFOs with respect to the
- * HighSpeed/FullSpeed/LowSpeed FIFOs. The DMA arbiter prioritizes the
- * HighSpeed/FullSpeed/LowSpeed round-robin arbiter group every DMA high-low priority ratio
- * grants as indicated in the register separately for TX and RX. To illustrate, consider that all
- * FIFOs are requesting access simultaneously, and the ratio is 4. SuperSpeed gets priority for 4
- * packets, HighSpeed/FullSpeed/LowSpeed gets priority for 1 packet, SuperSpeed gets priority for
- * 4 packets, HighSpeed/FullSpeed/LowSpeed gets priority for 1 packet, and so on.
- * If FIFOs from both speed groups are not requesting access simultaneously then,
- * If SuperSpeed got grants 4 out of the last 4 times, then HighSpeed/FullSpeed/LowSpeed get the
- * priority on any future request.
- * If HighSpeed/FullSpeed/LowSpeed got the grant last time, SuperSpeed gets the priority on the
- * next request.
- * If there is a valid request on either SuperSpeed or HighSpeed/FullSpeed/LowSpeed, a grant is
- * always awarded; there is no idle.
+ * high-speed/full-speed/low-speed FIFOs. The DMA arbiter prioritizes the high-speed/full-speed
+ * /low-speed round-robin arbiter group every DMA high-low priority ratio grants as indicated in
+ * the register separately for TX and RX.
+ *
+ * To illustrate, consider that all FIFOs are requesting access simultaneously, and the ratio is
+ * 4. SuperSpeed gets priority for four packets, high-speed/full-speed/low-speed gets priority
+ * for one packet, SuperSpeed gets priority for four packets, high-speed/full-speed/low-speed
+ * gets priority for one packet, and so on.
+ *
+ * If FIFOs from both speed groups are not requesting access simultaneously then:
+ * * If SuperSpeed got grants four out of the last four times, then high-speed/full-speed/
+ * low-speed get the priority on any future request.
+ * * If high-speed/full-speed/low-speed got the grant last time, SuperSpeed gets the priority on
+ * the next request.
+ *
+ * If there is a valid request on either SuperSpeed or high-speed/full-speed/low-speed, a grant
+ * is always awarded; there is no idle.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.5.
  */
 union cvmx_uahcx_gdmahlratio {
 	uint32_t u32;
@@ -3186,8 +3218,10 @@ typedef union cvmx_uahcx_gdmahlratio cvmx_uahcx_gdmahlratio_t;
  * addition, it enables running SOF or ITP frame timer counters completely off of the REF_CLK.
  * This facilitates hardware LPM in host mode with the SOF or ITP counters being run off of the
  * REF_CLK signal.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.6.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gfladj {
 	uint32_t u32;
@@ -3196,74 +3230,73 @@ union cvmx_uahcx_gfladj {
 	uint32_t gfladj_refclk_240mhzdecr_pls1 : 1; /**< This field indicates that the decrement value that the controller applies for each REF_CLK
                                                          must be GFLADJ_REFCLK_240MHZ_DECR and GFLADJ_REFCLK_240MHZ_DECR +1 alternatively on each
                                                          REF_CLK. Set this bit to 1 only if GFLADJ_REFCLK_LPM_SEL is set to 1 and the fractional
-                                                         component of 240/ref_frequency is greater than or equal to 0.5. Example:
+                                                         component of 240/ref_frequency is greater than or equal to 0.5.
+                                                         Example:
                                                          If the REF_CLK is 19.2 MHz then,
-                                                         GUCTL.REF_CLK_PERIOD = 52
-                                                         GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = (240/19.2) = 12.5
-                                                         GFLADJ.GFLADJ_REFCLK_240MHZDECR_PLS1 = 1
+                                                         * UAHC()_GUCTL[REFCLKPER] = 52.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = (240/19.2) = 12.5.
+                                                         * GFLADJ_REFCLK_240MHZDECR_PLS1 = 1.
                                                          If the REF_CLK is 24 MHz then,
-                                                         GUCTL.REF_CLK_PERIOD = 41
-                                                         GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = (240/24) = 10
-                                                         GFLADJ.GFLADJ_REFCLK_240MHZDECR_PLS1 = 0 */
+                                                         * UAHC()_GUCTL[REFCLKPER] = 41.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = (240/24) = 10.
+                                                         * GFLADJ_REFCLK_240MHZDECR_PLS1 = 0. */
 	uint32_t gfladj_refclk_240mhz_decr    : 7;  /**< This field indicates the decrement value that the controller applies for each REF_CLK in
                                                          order to derive a frame timer in terms of a 240-MHz clock. This field must be programmed
                                                          to a non-zero value only if GFLADJ_REFCLK_LPM_SEL is set to 1.
                                                          The value is derived as follows:
-                                                         GFLADJ_REFCLK_240MHZ_DECR = 240/ref_clk_frequency
+                                                         _ GFLADJ_REFCLK_240MHZ_DECR = 240/ref_clk_frequency
                                                          Examples:
                                                          If the REF_CLK is 24 MHz then,
-                                                         GUCTL.REF_CLK_PERIOD = 41
-                                                         GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/24 = 10
+                                                         * UAHC()_GUCTL[REFCLKPER] = 41.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = 240/24 = 10.
                                                          If the REF_CLK is 48 MHz then,
-                                                         GUCTL.REF_CLK_PERIOD = 20
-                                                         GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/48 = 5
+                                                         * UAHC()_GUCTL[REFCLKPER] = 20.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = 240/48 = 5.
                                                          If the REF_CLK is 17 MHz then,
-                                                         GUCTL.REF_CLK_PERIOD = 58
-                                                         GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/17 = 14 */
-	uint32_t gfladj_refclk_lpm_sel        : 1;  /**< This bit enables the functionality of running SOF/ITP counters on the REF_CLK. This bit
-                                                         must not be set to 1 if UAHC(0)_GCTL[SOFITPSYNC] bit is set to 1. Similarly, if
-                                                         GFLADJ_REFCLK_LPM_SEL set to 1, UAHC(0)_GCTL[SOFITPSYNC] must not be set to 1. When
-                                                         GFLADJ_REFCLK_LPM_SEL is set to 1 the overloading of the suspend control of the USB 2.0
-                                                         first port PHY (UTMI) with USB 3.0 port states is removed. Note that the REF_CLK
-                                                         frequencies supported in this mode are 16/17/19.2/20/24/39.7/40 MHz.
+                                                         * UAHC()_GUCTL[REFCLKPER] = 58.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = 240/17 = 14. */
+	uint32_t gfladj_refclk_lpm_sel        : 1;  /**< This bit enables the functionality of running SOF/ITP counters on the REF_CLK.
+                                                         This bit must not be set to 1 if UAHC()_GCTL[SOFITPSYNC] = 1. Similarly, if
+                                                         GFLADJ_REFCLK_LPM_SEL = 1, UAHC()_GCTL[SOFITPSYNC] must not be set to 1.
+                                                         When GFLADJ_REFCLK_LPM_SEL = 1 the overloading of the suspend control of the USB 2.0 first
+                                                         port PHY (UTMI) with USB 3.0 port states is removed. Note that the REF_CLK frequencies
+                                                         supported in this mode are 16/17/19.2/20/24/39.7/40 MHz.
                                                          INTERNAL: The utmi_clk[0] signal of the core must be connected to the FREECLK of the PHY.
-                                                         If you set this bit to 1, the GUSB2PHYCFG.U2_FREECLK_EXISTS bit must be set to 0. */
+                                                         If you set this bit to 1, UAHC()_GUSB2PHYCFG()[U2_FREECLK_EXISTS] must be set to 0. */
 	uint32_t reserved_22_22               : 1;
 	uint32_t gfladj_refclk_fladj          : 14; /**< This field indicates the frame length adjustment to be applied when SOF/ITP counter is
-                                                         running off of the REF_CLK. This register value is used to adjust:
-                                                         ITP interval when GCTL[SOFITPSYNC] is set to 1
-                                                         both SOF and ITP interval when GLADJ.GFLADJ_REFCLK_LPM_SEL is set to 1.
-                                                         This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL is set to
-                                                         1 or GCTL.SOFITPSYNC is set to 1.
+                                                         running off of the REF_CLK. This register value is used to adjust:.
+                                                         * ITP interval when UAHC()_GCTL[SOFITPSYNC] = 1
+                                                         * both SOF and ITP interval when GFLADJ_REFCLK_LPM_SEL = 1.
+                                                         This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL = 1 or
+                                                         UAHC()_GCTL[SOFITPSYNC] = 1.
                                                          The value is derived as below:
-                                                         FLADJ_REF_CLK_FLADJ = ((125000/ref_clk_period_integer) - (125000/ref_clk_period)) *
+                                                         _ FLADJ_REF_CLK_FLADJ = ((125000/ref_clk_period_integer) - (125000/ref_clk_period)) *
                                                          ref_clk_period
                                                          where,
-                                                         the ref_clk_period_integer is the integer value of the REF_CLK period got by truncating
-                                                         the decimal (fractional) value that is programmed in the GUCTL.REF_CLK_PERIOD field
-                                                         the ref_clk_period is the REF_CLK period including the fractional value.
+                                                         * the ref_clk_period_integer is the integer value of the REF_CLK period got by truncating
+                                                         the decimal (fractional) value that is programmed in UAHC()_GUCTL[REFCLKPER].
+                                                         * the ref_clk_period is the REF_CLK period including the fractional value.
                                                          Examples:
                                                          If the REF_CLK is 24 MHz then,
-                                                         GUCTL.REF_CLK_PERIOD = 41
-                                                         GFLADJ.GLADJ_REFCLK_FLADJ = ((125000/41) -(125000/41.6666))*41.6666 = 2032 (ignoring the
-                                                         fractional value)
+                                                         * UAHC()_GUCTL[REFCLKPER] = 41.
+                                                         * GLADJ_REFCLK_FLADJ = ((125000/41) -
+                                                         (125000/41.6666)) * 41.6666 = 2032 (ignoring the fractional value).
                                                          If the REF_CLK is 48 MHz then,
-                                                         GUCTL.REF_CLK_PERIOD = 20
-                                                         GFLADJ.GLADJ_REFCLK_FLADJ = ((125000/20) -(125000/20.8333))*20.8333 = 5208 (ignoring the
-                                                         fractional value) */
-	uint32_t gfladj_30mhz_reg_sel         : 1;  /**< This field selects whether to use the input signal fladj_30mhz_reg or the
-                                                         GFLADJ.GFLADJ_30MHZ to adjust the frame length for the SOF/ITP. When this bit is set to,
-                                                         1, the controller uses the register field GFLADJ.GFLADJ_30MHZ value 0, the controller uses
-                                                         the input signal fladj_30mhz_reg value */
+                                                         * UAHC()_GUCTL[REFCLKPER] = 20.
+                                                         * GLADJ_REFCLK_FLADJ = ((125000/20) -
+                                                         (125000/20.8333)) * 20.8333 = 5208 (ignoring the fractional value). */
+	uint32_t gfladj_30mhz_reg_sel         : 1;  /**< This field selects whether to use the input signal fladj_30mhz_reg or the GFLADJ_30MHZ to
+                                                         adjust the frame length for the SOF/ITP. When this bit is set to, 1, the controller uses
+                                                         GFLADJ_30MHZ value 0x0, the controller uses the input signal fladj_30mhz_reg value. */
 	uint32_t reserved_6_6                 : 1;
 	uint32_t gfladj_30mhz                 : 6;  /**< This field indicates the value that is used for frame length adjustment instead of
                                                          considering from the sideband input signal fladj_30mhz_reg. This enables post-silicon
                                                          frame length adjustment in case the input signal fladj_30mhz_reg is connected to a wrong
-                                                         value or is not valid. The controller uses this value if GFLADJ.GFLADJ_30MHZ_REG_SEL is
-                                                         set to 1 and the SOF/ITP counters are running off of UTMI(ULPI) clock
-                                                         (GFLADJ_REFCLK_LPM_SEL is 0 and GCTL.SOFITPSYNC is 1 or 0). For details on how to set this
-                                                         value, refer to section 5.2.4 Frame Length Adjustment Register (FLADJ) of the xHCI
-                                                         Specification. */
+                                                         value or is not valid. The controller uses this value if GFLADJ_30MHZ_REG_SEL = 1 and the
+                                                         SOF/ITP counters are running off of UTMI(ULPI) clock (GFLADJ_REFCLK_LPM_SEL = 0 and
+                                                         UAHC()_GCTL[SOFITPSYNC] is 1 or 0). For details on how to set this value, refer to
+                                                         section 5.2.4 Frame Length Adjustment Register (FLADJ) of the xHCI Specification. */
 #else
 	uint32_t gfladj_30mhz                 : 6;
 	uint32_t reserved_6_6                 : 1;
@@ -3284,8 +3317,10 @@ typedef union cvmx_uahcx_gfladj cvmx_uahcx_gfladj_t;
  *
  * The application can use this register for general purpose input and output ports or for
  * debugging.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.9.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_ggpio {
 	uint32_t u32;
@@ -3305,7 +3340,7 @@ typedef union cvmx_uahcx_ggpio cvmx_uahcx_ggpio_t;
 /**
  * cvmx_uahc#_ghwparams0
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.1.
  */
@@ -3335,7 +3370,7 @@ typedef union cvmx_uahcx_ghwparams0 cvmx_uahcx_ghwparams0_t;
 /**
  * cvmx_uahc#_ghwparams1
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.2.
  */
@@ -3346,16 +3381,16 @@ union cvmx_uahcx_ghwparams1 {
 	uint32_t en_dbc                       : 1;  /**< Enable debug capability. */
 	uint32_t rm_opt_features              : 1;  /**< Remove optional features. */
 	uint32_t sync_rst                     : 1;  /**< Synchronous reset coding. */
-	uint32_t ram_bus_clks_sync            : 1;  /**< RAM_CLK and BUS_CLK are synchronous.
-                                                         INTERNAL: (appears to be orthogonal from the RAM_CLK_TO_BUS_CLK parameter) */
+	uint32_t ram_bus_clks_sync            : 1;  /**< RAM_CLK and BUS_CLK are synchronous. INTERNAL: (appears to be orthogonal from the
+                                                         RAM_CLK_TO_BUS_CLK parameter) */
 	uint32_t mac_ram_clks_sync            : 1;  /**< MAC3_CLK and RAM_CLK are synchronous. */
 	uint32_t mac_phy_clks_sync            : 1;  /**< MAC3_CLK and PHY_CLK are synchronous. */
-	uint32_t en_pwropt                    : 2;  /**< Power optimization mode.
-                                                         Bit <0>: clock-gating feature available.
-                                                         Bit <1>: hibernation feature available. */
+	uint32_t en_pwropt                    : 2;  /**< Power optimization mode:
+                                                         bit<0> = Clock-gating feature available.
+                                                         bit<1> = Hibernation feature available. */
 	uint32_t spram_typ                    : 1;  /**< SRAM type: one-port RAMs. */
 	uint32_t num_rams                     : 2;  /**< Number of RAMs. */
-	uint32_t device_num_int               : 6;  /**< Number of event buffers (and interrupts) in device-mode. */
+	uint32_t device_num_int               : 6;  /**< Number of event buffers (and interrupts) in device-mode (unsupported). */
 	uint32_t aspacewidth                  : 3;  /**< Native interface address-space port width. */
 	uint32_t reqinfowidth                 : 3;  /**< Native interface request/response-info port width. */
 	uint32_t datainfowidth                : 3;  /**< Native interface data-info port width. */
@@ -3386,7 +3421,7 @@ typedef union cvmx_uahcx_ghwparams1 cvmx_uahcx_ghwparams1_t;
 /**
  * cvmx_uahc#_ghwparams2
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.3.
  */
@@ -3406,7 +3441,8 @@ typedef union cvmx_uahcx_ghwparams2 cvmx_uahcx_ghwparams2_t;
 /**
  * cvmx_uahc#_ghwparams3
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.4.
  */
 union cvmx_uahcx_ghwparams3 {
@@ -3415,14 +3451,14 @@ union cvmx_uahcx_ghwparams3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_31_31               : 1;
 	uint32_t cache_total_xfer_resources   : 8;  /**< Maximum number of transfer resources in the core. */
-	uint32_t num_in_eps                   : 5;  /**< Maximum number of device-mode IN endpoints active. */
-	uint32_t num_eps                      : 6;  /**< Number of device-mode single-directional endpoints. */
+	uint32_t num_in_eps                   : 5;  /**< Maximum number of device-mode (unsupported) IN endpoints active. */
+	uint32_t num_eps                      : 6;  /**< Number of device-mode (unsupported) single-directional endpoints. */
 	uint32_t ulpi_carkit                  : 1;  /**< ULPI Carkit is not supported. */
 	uint32_t vendor_ctl_interface         : 1;  /**< UTMI+ PHY vendor control interface enabled. */
 	uint32_t reserved_8_9                 : 2;
 	uint32_t hsphy_dwidth                 : 2;  /**< Data width of the UTMI+ PHY interface: 0x2 = 8-or-16 bits. */
 	uint32_t fsphy_interface              : 2;  /**< USB 1.1 full-speed serial transceiver interface. */
-	uint32_t hsphy_interface              : 2;  /**< High-Speed PHY interface: 0x1 = UTMI+. */
+	uint32_t hsphy_interface              : 2;  /**< High-speed PHY interface: 0x1 = UTMI+. */
 	uint32_t ssphy_interface              : 2;  /**< SuperSpeed PHY interface: 0x1 = PIPE3. */
 #else
 	uint32_t ssphy_interface              : 2;
@@ -3445,7 +3481,7 @@ typedef union cvmx_uahcx_ghwparams3 cvmx_uahcx_ghwparams3_t;
 /**
  * cvmx_uahc#_ghwparams4
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.5.
  */
@@ -3457,8 +3493,8 @@ union cvmx_uahcx_ghwparams4 {
 	uint32_t bmu_ptl_depth_m1             : 4;  /**< Depth of the BMU-PTL source/sink buffers minus 1. */
 	uint32_t en_isoc_supt                 : 1;  /**< Isochronous support enabled. */
 	uint32_t reserved_22_22               : 1;
-	uint32_t ext_buff_control             : 1;  /**< Enables device external buffer control sideband controls */
-	uint32_t num_ss_usb_instances         : 4;  /**< Number of SS bus instances. */
+	uint32_t ext_buff_control             : 1;  /**< Enables device external buffer control sideband controls. */
+	uint32_t num_ss_usb_instances         : 4;  /**< Number of SuperSpeed bus instances. */
 	uint32_t hiber_scratchbufs            : 4;  /**< Number of hibernation scratchpad buffers. */
 	uint32_t reserved_6_12                : 7;
 	uint32_t cache_trbs_per_transfer      : 6;  /**< Number of TRBs per transfer that can be cached. */
@@ -3481,7 +3517,7 @@ typedef union cvmx_uahcx_ghwparams4 cvmx_uahcx_ghwparams4_t;
 /**
  * cvmx_uahc#_ghwparams5
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.6.
  */
@@ -3492,8 +3528,8 @@ union cvmx_uahcx_ghwparams5 {
 	uint32_t reserved_28_31               : 4;
 	uint32_t dfq_fifo_depth               : 6;  /**< Size of the BMU descriptor fetch-request queue. */
 	uint32_t dwq_fifo_depth               : 6;  /**< Size of the BMU descriptor write queue. */
-	uint32_t txq_fifo_depth               : 6;  /**< Size of the BMU Tx request queue. */
-	uint32_t rxq_fifo_depth               : 6;  /**< Size of the BMU Rx request queue. */
+	uint32_t txq_fifo_depth               : 6;  /**< Size of the BMU TX request queue. */
+	uint32_t rxq_fifo_depth               : 6;  /**< Size of the BMU RX request queue. */
 	uint32_t bmu_busgm_depth              : 4;  /**< Depth of the BMU-BUSGM source/sink buffers. */
 #else
 	uint32_t bmu_busgm_depth              : 4;
@@ -3511,7 +3547,7 @@ typedef union cvmx_uahcx_ghwparams5 cvmx_uahcx_ghwparams5_t;
 /**
  * cvmx_uahc#_ghwparams6
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.7.
  */
@@ -3520,15 +3556,15 @@ union cvmx_uahcx_ghwparams6 {
 	struct cvmx_uahcx_ghwparams6_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t ram0_depth                   : 16; /**< RAM0 Depth. */
-	uint32_t en_bus_filters               : 1;  /**< VBus filters support. */
-	uint32_t en_bc                        : 1;  /**< Battery-charging support. */
-	uint32_t en_otg_ss                    : 1;  /**< OTG SuperSpeed support. */
-	uint32_t en_adp                       : 1;  /**< ADP support. */
+	uint32_t en_bus_filters               : 1;  /**< Enable VBus filters support. */
+	uint32_t en_bc                        : 1;  /**< Enable battery-charging support. */
+	uint32_t en_otg_ss                    : 1;  /**< Enable OTG SuperSpeed support. */
+	uint32_t en_adp                       : 1;  /**< Enable ADP support. */
 	uint32_t hnp_support                  : 1;  /**< HNP support. */
 	uint32_t srp_support                  : 1;  /**< SRP support. */
 	uint32_t reserved_8_9                 : 2;
-	uint32_t en_fpga                      : 1;  /**< FPGA implementation. */
-	uint32_t en_dbg_ports                 : 1;  /**< Debug ports for FGPA. */
+	uint32_t en_fpga                      : 1;  /**< Enable FPGA implementation. */
+	uint32_t en_dbg_ports                 : 1;  /**< Enable Debug ports for FGPA. */
 	uint32_t psq_fifo_depth               : 6;  /**< Size of the BMU-protocol status queue. */
 #else
 	uint32_t psq_fifo_depth               : 6;
@@ -3551,7 +3587,7 @@ typedef union cvmx_uahcx_ghwparams6 cvmx_uahcx_ghwparams6_t;
 /**
  * cvmx_uahc#_ghwparams7
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.8.
  */
@@ -3573,7 +3609,7 @@ typedef union cvmx_uahcx_ghwparams7 cvmx_uahcx_ghwparams7_t;
 /**
  * cvmx_uahc#_ghwparams8
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.3.9.
  */
@@ -3595,12 +3631,14 @@ typedef union cvmx_uahcx_ghwparams8 cvmx_uahcx_ghwparams8_t;
  *
  * This debug register gives information on which event caused the hibernation exit. These
  * registers are for debug purposes. They provide debug information on the internal status and
- * state machines. Global Debug Registers have design-specific information, and are used by for
+ * state machines. Global debug registers have design-specific information, and are used by for
  * debugging purposes. These registers are not intended to be used by the customer. If any debug
  * assistance is needed for the silicon, contact Customer Support with a dump of these registers.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.1.
  * INTERNAL: Contact Synopsys directly.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gpmsts {
 	uint32_t u32;
@@ -3609,23 +3647,23 @@ union cvmx_uahcx_gpmsts {
 	uint32_t portsel                      : 4;  /**< This field selects the port number. Always 0x0. */
 	uint32_t reserved_17_27               : 11;
 	uint32_t u3wakeup                     : 5;  /**< This field gives the USB 3.0 port wakeup conditions.
-                                                         Bit<12>: Overcurrent detected
-                                                         Bit<13>: Resume detected
-                                                         Bit<14>: Connect detected
-                                                         Bit<15>: Disconnect detected
-                                                         Bit<16>: Last connection state */
+                                                         bit<12> = Overcurrent detected.
+                                                         bit<13> = Resume detected.
+                                                         bit<14> = Connect detected.
+                                                         bit<15> = Disconnect detected.
+                                                         bit<16> = Last connection state. */
 	uint32_t reserved_10_11               : 2;
 	uint32_t u2wakeup                     : 10; /**< This field indicates the USB 2.0 port wakeup conditions.
-                                                         Bit<0>: Overcurrent detected
-                                                         Bit<1>: Resume detected
-                                                         Bit<2>: Connect detected
-                                                         Bit<3>: Disconnect detected
-                                                         Bit<4>: Last connection state
-                                                         Bit<5>: ID change detected
-                                                         Bit<6>: SRP request detected
-                                                         Bit<7>: ULPI interrupt detected
-                                                         Bit<8>: USB reset detected
-                                                         Bit<9>: Resume detected changed */
+                                                         bit<0> = Overcurrent detected.
+                                                         bit<1> = Resume detected.
+                                                         bit<2> = Connect detected.
+                                                         bit<3> = Disconnect detected.
+                                                         bit<4> = Last connection state.
+                                                         bit<5> = ID change detected.
+                                                         bit<6> = SRP request detected.
+                                                         bit<7> = ULPI interrupt detected.
+                                                         bit<8> = USB reset detected.
+                                                         bit<9> = Resume detected changed. */
 #else
 	uint32_t u2wakeup                     : 10;
 	uint32_t reserved_10_11               : 2;
@@ -3646,15 +3684,17 @@ typedef union cvmx_uahcx_gpmsts cvmx_uahcx_gpmsts_t;
  * instances. Software can program this register to specify how USB 3.0 ports are connected to
  * SuperSpeed USB instances. The UAHC only implements one SuperSpeed bus-instance, so this
  * register should always be 0.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.2.1.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gprtbimap {
 	uint64_t u64;
 	struct cvmx_uahcx_gprtbimap_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t binum1                       : 4;  /**< SS USB instance number for port 1 */
+	uint64_t binum1                       : 4;  /**< SuperSpeed USB instance number for port 1. */
 #else
 	uint64_t binum1                       : 4;
 	uint64_t reserved_4_63                : 60;
@@ -3667,22 +3707,22 @@ typedef union cvmx_uahcx_gprtbimap cvmx_uahcx_gprtbimap_t;
 /**
  * cvmx_uahc#_gprtbimap_fs
  *
- * This register specifies the FullSpeed/LowSpeed USB instance number to which each USB 1.1 port
- * is connected. By default, USB 1.1 ports are evenly distributed among all FullSpeed/LowSpeed
- * USB instances.
- * Software can program this register to specify how USB 1.1 ports are connected to
- * FullSpeed/LowSpeed USB instances.
- * The UAHC only implements one FullSpeed/LowSpeed bus-instance, so this register should always
- * be 0.
+ * This register specifies the full-speed/low-speed USB instance number to which each USB 1.1
+ * port is connected. By default, USB 1.1 ports are evenly distributed among all full-speed/
+ * low-speed USB instances. Software can program this register to specify how USB 1.1 ports are
+ * connected to full-speed/low-speed USB instances. The UAHC only implements one full-speed/
+ * low-speed bus-instance, so this register should always be 0x0.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.2.3.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gprtbimap_fs {
 	uint64_t u64;
 	struct cvmx_uahcx_gprtbimap_fs_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t binum1                       : 4;  /**< FullSpeed USB instance number for port 1. */
+	uint64_t binum1                       : 4;  /**< Full-speed USB instance number for port 1. */
 #else
 	uint64_t binum1                       : 4;
 	uint64_t reserved_4_63                : 60;
@@ -3695,20 +3735,22 @@ typedef union cvmx_uahcx_gprtbimap_fs cvmx_uahcx_gprtbimap_fs_t;
 /**
  * cvmx_uahc#_gprtbimap_hs
  *
- * This register specifies the HighSpeed USB instance number to which each USB 2.0 port is
- * connected. By default, USB 2.0 ports are evenly distributed among all HighSpeed USB
- * instances. Software can program this register to specify how USB 2.0 ports are connected
- * to HighSpeed USB instances.
- * The UAHC only implements one HighSpeed bus-instance, so this register should always be 0.
+ * This register specifies the high-speed USB instance number to which each USB 2.0 port is
+ * connected. By default, USB 2.0 ports are evenly distributed among all high-speed USB
+ * instances. Software can program this register to specify how USB 2.0 ports are connected to
+ * high-speed USB instances. The UAHC only implements one high-speed bus-instance, so this
+ * register should always be 0.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.2.2.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gprtbimap_hs {
 	uint64_t u64;
 	struct cvmx_uahcx_gprtbimap_hs_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t binum1                       : 4;  /**< HighSpeed USB instance number for port 1. */
+	uint64_t binum1                       : 4;  /**< High-speed USB instance number for port 1. */
 #else
 	uint64_t binum1                       : 4;
 	uint64_t reserved_4_63                : 60;
@@ -3721,8 +3763,8 @@ typedef union cvmx_uahcx_gprtbimap_hs cvmx_uahcx_gprtbimap_hs_t;
 /**
  * cvmx_uahc#_grlsid
  *
- * INTERNAL: Original name: GSNPSID = Synopsys ID
  * This is a read-only register that contains the release number of the core.
+ * INTERNAL: Original name: GSNPSID = Synopsys ID.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.8.
  */
 union cvmx_uahcx_grlsid {
@@ -3731,9 +3773,9 @@ union cvmx_uahcx_grlsid {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t releaseid                    : 32; /**< Software can use this register to configure release-specific features in the driver.
                                                          INTERNAL: Synopsys ID
-                                                         INTERNAL:   * SynopsysID[31:16] indicates Core Identification Number. 0x5533 is ASCII for
+                                                          * SynopsysID[31:16] indicates Core Identification Number. 0x5533 is ASCII for
                                                          U3 (DWC_usb3).
-                                                         INTERNAL:   * SynopsysID[15:0] indicates the release number. Current Release is 2.50a. */
+                                                          * SynopsysID[15:0] indicates the release number. Current Release is 2.50a. */
 #else
 	uint32_t releaseid                    : 32;
 #endif
@@ -3746,30 +3788,36 @@ typedef union cvmx_uahcx_grlsid cvmx_uahcx_grlsid_t;
  * cvmx_uahc#_grxfifoprihst
  *
  * This register specifies the relative DMA priority level among the host RXFIFOs (one per USB
- * bus instance) within the associated speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed).
- * When multiple RXFIFOs compete for DMA service at a given time, the RXDMA arbiter grants access
- * on a packet-basis in the following manner:
- * Among the FIFOs in the same speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed):
- * High-priority RXFIFOs are granted access using round-robin arbitration
- * Low-priority RXFIFOs are granted access using round-robin arbitration only after high-priority
+ * bus instance) within the associated speed group (SuperSpeed or high-speed/full-speed
+ * /low-speed). When multiple RXFIFOs compete for DMA service at a given time, the RXDMA arbiter
+ * grants access on a packet-basis in the following manner:
+ *
+ * Among the FIFOs in the same speed group (SuperSpeed or high-speed/full-speed/low-speed):
+ * * High-priority RXFIFOs are granted access using round-robin arbitration.
+ * * Low-priority RXFIFOs are granted access using round-robin arbitration only after high-
+ * priority
  * RXFIFOs have no further processing to do (i.e., either the RXQs are empty or the corresponding
  * RXFIFOs do not have the required data).
- * The RX DMA arbiter prioritizes the SuperSpeed group or HighSpeed/FullSpeed/LowSpeed group
- * according to the ratio programmed in the UAHC(0)_GDMAHLRATIO register.
+ *
+ * The RX DMA arbiter prioritizes the SuperSpeed group or high-speed/full-speed/low-speed group
+ * according to the ratio programmed in
+ * UAHC()_GDMAHLRATIO.
+ *
  * For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until
  * the entire packet is completed. The register size corresponds to the number of configured USB
  * bus instances; for example, in the default configuration, there are 3 USB bus instances (1
- * SuperSpeed, 1 HighSpeed, and 1 FullSpeed/LowSpeed).
+ * SuperSpeed, 1 high-speed, and 1 full-speed/low-speed).
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.3.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_grxfifoprihst {
 	uint32_t u32;
 	struct cvmx_uahcx_grxfifoprihst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_3_31                : 29;
-	uint32_t rx_priority                  : 3;  /**< Each register bit n controls the priority (1: high, 0: low) of RX FIFO<n> within a speed
-                                                         group. */
+	uint32_t rx_priority                  : 3;  /**< Each register bit[n] controls the priority (1 = high, 0 = low) of RXFIFO[n] within a speed group. */
 #else
 	uint32_t rx_priority                  : 3;
 	uint32_t reserved_3_31                : 29;
@@ -3785,20 +3833,23 @@ typedef union cvmx_uahcx_grxfifoprihst cvmx_uahcx_grxfifoprihst_t;
  * The application can program the internal RAM start address/depth of the each RxFIFO as shown
  * below. It is recommended that software use the default value. In Host mode, per-port registers
  * are implemented. One register per FIFO.
+ *
+ * Reset values = 0:[0x0000_0084] 1:[0x0084_0104] 2:[0x0188_0180].
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.6.2.
  * INTERNAL: For more information, see the BMU section in Block Descriptions on Synopsys Databook
  * page 238.
- * reset values = 0:[0x0000_0084] 1:[0x0084_0104] 2:[0x0188_0180]
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_grxfifosizx {
 	uint32_t u32;
 	struct cvmx_uahcx_grxfifosizx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t rxfstaddr                    : 16; /**< RxFIFOn RAM start address.  This field contains the memory start address for RxFIFOn. The
+	uint32_t rxfstaddr                    : 16; /**< RxFIFOn RAM start address. This field contains the memory start address for RxFIFOn. The
                                                          reset value is derived from configuration parameters. */
 	uint32_t rxfdep                       : 16; /**< RxFIFOn depth. This value is in terms of RX RAM Data width.
-                                                         minimum value = 0x20, maximum value = 0x4000
+                                                         minimum value = 0x20, maximum value = 0x4000.
                                                          INTERNAL: For more information, see the Hardware Integration chapter of the Synopsys
                                                          Databook.
                                                          The reset value is derived from configuration parameters. */
@@ -3820,16 +3871,21 @@ typedef union cvmx_uahcx_grxfifosizx cvmx_uahcx_grxfifosizx_t;
  * 1024-byte packet, then starting a burst on 1-packet condition leads to an early abort of the
  * burst causing unnecessary performance reduction. This register allows the configuration of
  * threshold and burst size control. This feature is enabled by USBRXPKTCNTSEL.
+ *
  * Receive Path:
- * The RX threshold is controlled by USBRXPKTCNT and the RX burst size is controlled by
+ * * The RX threshold is controlled by USBRXPKTCNT and the RX burst size is controlled by
  * USBMAXRXBURSTSIZE.
- * Selecting optimal RX FIFO size, RX Threshold, and RX burst size avoids RX burst aborts due to
- * overrun if the system bus is slower than USB. Once in a while overrun is OK, and there is no
- * functional issue.
- * Some devices do not support terminating ACK retry. With these devices, host cannot set ACK=0
+ * * Selecting optimal RX FIFO size, RX Threshold, and RX burst size avoids RX burst aborts due
+ * to overrun if the system bus is slower than USB. Once in a while overrun is OK, and there is
+ * no functional issue.
+ * * Some devices do not support terminating ACK retry. With these devices, host cannot set ACK=0
  * and Retry=0 and do retry later and you have to retry immediately. For such devices, minimize
  * retry due to underrun. Setting threshold and burst size guarantees this.
  * A larger RX threshold affects the performance since the scheduler is idle during this time.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.4.
  */
 union cvmx_uahcx_grxthrcfg {
 	uint32_t u32;
@@ -3844,12 +3900,14 @@ union cvmx_uahcx_grxthrcfg {
                                                          USBRXPKTCNT amount of packets.
                                                          This mode is only used for SuperSpeed. */
 	uint32_t reserved_28_28               : 1;
-	uint32_t usbrxpktcnt                  : 4;  /**< USB receive-packet count. Specifies space (in number of packets) that must be available in
-                                                         the RX FIFO before the core can start the corresponding USB RX transaction (burst).
+	uint32_t usbrxpktcnt                  : 4;  /**< USB receive-packet count. In host-mode, specifies space (in number of packets) that must
+                                                         be available in the RX FIFO before the core can start the corresponding USB RX transaction
+                                                         (burst).
                                                          This field is only valid when USBRXPKTCNTSEL = 1. The valid values are from 0x1 to 0xF.
-                                                         Note: This field must be less than or equal to the USBMAXRXBURSTSIZE field. */
-	uint32_t usbmaxrxburstsize            : 5;  /**< USB maximum receive-burst size. Specifies the maximum bulk IN burst the core should do.
-                                                         When the system bus is slower than the USB, RX FIFO can overrun during a long burst.
+                                                         This field must be <= USBMAXRXBURSTSIZE. */
+	uint32_t usbmaxrxburstsize            : 5;  /**< USB maximum receive-burst size. In host-mode, specifies the maximum bulk IN burst the core
+                                                         should do. When the system bus is slower than the USB, RX FIFO can overrun during a long
+                                                         burst.
                                                          Program a smaller value to this field to limit the RX burst size that the core can do. It
                                                          only applies to SuperSpeed Bulk, Isochronous, and Interrupt IN endpoints in the host mode.
                                                          This field is only valid when USBRXPKTCNTSEL = 1. The valid values are from 0x1 to 0x10. */
@@ -3874,11 +3932,13 @@ typedef union cvmx_uahcx_grxthrcfg cvmx_uahcx_grxthrcfg_t;
  * operation. This register mainly contains AXI system-related configuration parameters. Do not
  * change this register after the initial programming. The application must program this register
  * before starting any transactions on AXI. When INCRBRSTENA is enabled, it has the highest
- * priority over other burst lengths. The core always perform the largest burst when enabled.
+ * priority over other burst lengths. The core always performs the largest burst when enabled.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: The AXI cache signals are not connected in Cavium's hookup, so the *REQINFO fields
  * can be ignored.
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.1.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gsbuscfg0 {
 	uint32_t u32;
@@ -3890,9 +3950,9 @@ union cvmx_uahcx_gsbuscfg0 {
 	uint32_t deswrreqinfo                 : 4;  /**< AXI-cache for descriptor-write operations. Always set to 0x0. */
 	uint32_t reserved_12_15               : 4;
 	uint32_t datbigend                    : 1;  /**< Data access is big-endian. Keep this set to 0 (little-endian) and use the
-                                                         UCTL(0)_SHIM_CFG[DMA_ENDIAN_MODE] setting instead. */
+                                                         UCTL()_SHIM_CFG[DMA_ENDIAN_MODE] setting instead. */
 	uint32_t descbigend                   : 1;  /**< Descriptor access is big-endian. Keep this set to 0 (little-endian) and use the
-                                                         UCTL(0)_SHIM_CFG[DMA_ENDIAN_MODE] setting instead. */
+                                                         UCTL()_SHIM_CFG[DMA_ENDIAN_MODE] setting instead. */
 	uint32_t reserved_8_9                 : 2;
 	uint32_t incr256brstena               : 1;  /**< INCR256 burst-type enable. Always set to 0. */
 	uint32_t incr128brstena               : 1;  /**< INCR128 burst-type enable. Always set to 0. */
@@ -3904,8 +3964,8 @@ union cvmx_uahcx_gsbuscfg0 {
 	uint32_t incrbrstena                  : 1;  /**< Undefined-length INCR burst-type enable.
                                                          This bit determines the set of burst lengths to be utilized by the master interface. It
                                                          works in conjunction with the GSBUSCFG0[7:1] enables (INCR*BRSTENA).
-                                                         If disabled, the AXI master will use only the following burst lengths:
-                                                         1, 4, 8, 16 (assuming the INCR*BRSTENA are set to their reset values)
+                                                         If disabled, the AXI master will use only the burst lengths
+                                                         1, 4, 8, 16 (assuming the INCR*BRSTENA are set to their reset values).
                                                          If enabled, the AXI master uses any length less than or equal to the largest-enabled burst
                                                          length based on the INCR*BRSTENA fields. */
 #else
@@ -3938,8 +3998,10 @@ typedef union cvmx_uahcx_gsbuscfg0 cvmx_uahcx_gsbuscfg0_t;
  * operation. This register mainly contains AXI system-related configuration parameters. Do not
  * change this register after the initial programming. The application must program this register
  * before starting any transactions on AXI.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.2.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gsbuscfg1 {
 	uint32_t u32;
@@ -3947,20 +4009,20 @@ union cvmx_uahcx_gsbuscfg1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_13_31               : 19;
 	uint32_t en1kpage                     : 1;  /**< 1K page-boundary enable.
-                                                         0 = AXI breaks transfers at the 4K page boundary (default)
-                                                         1 = AXI breaks transfers at the 1K page boundary */
+                                                         0 = Break transfers at the 4K page boundary (default).
+                                                         1 = Break transfers at the 1K page boundary. */
 	uint32_t pipetranslimit               : 4;  /**< AXI pipelined transfers burst-request limit. Controls the number of outstanding pipelined
                                                          transfers requests the AXI master will push to the AXI slave. Once the AXI master reaches
                                                          this limit, it does not make more requests on the AXI ARADDR and AWADDR buses until the
                                                          associated data phases complete. This field is encoded as follows:
-                                                         0x0 = 1 request 0x8 = 9 requests
-                                                         0x1 = 2 requests 0x9 = 10 requests
-                                                         0x2 = 3 requests 0xA = 11 requests
-                                                         0x3 = 4 requests 0xB = 12 requests
-                                                         0x4 = 5 requests 0xC = 13 requests
-                                                         0x5 = 6 requests 0xD = 14 requests
-                                                         0x6 = 7 requests 0xE = 15 requests
-                                                         0x7 = 8 requests 0xF = 16 requests */
+                                                         0x0 = 1 request. 0x8 = 9 requests.
+                                                         0x1 = 2 requests. 0x9 = 10 requests.
+                                                         0x2 = 3 requests. 0xA = 11 requests.
+                                                         0x3 = 4 requests. 0xB = 12 requests.
+                                                         0x4 = 5 requests. 0xC = 13 requests.
+                                                         0x5 = 6 requests. 0xD = 14 requests.
+                                                         0x6 = 7 requests. 0xE = 15 requests.
+                                                         0x7 = 8 requests. 0xF = 16 requests. */
 	uint32_t reserved_0_7                 : 8;
 #else
 	uint32_t reserved_0_7                 : 8;
@@ -3976,26 +4038,27 @@ typedef union cvmx_uahcx_gsbuscfg1 cvmx_uahcx_gsbuscfg1_t;
 /**
  * cvmx_uahc#_gsts
  *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.6.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gsts {
 	uint32_t u32;
 	struct cvmx_uahcx_gsts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t cbelt                        : 12; /**< Current BELT value. In host mode, indicates the minimum value of all received device BELT
-                                                         values and the BELT value that is set by the Set Latency Tolerance Value command. */
+                                                         values and the BELT value that is set by the set latency tolerance value command. */
 	uint32_t reserved_8_19                : 12;
 	uint32_t host_ip                      : 1;  /**< Host interrupt pending. Indicates that there is a pending interrupt pertaining to xHC in
                                                          the host-event queue. */
 	uint32_t reserved_6_6                 : 1;
 	uint32_t csrtimeout                   : 1;  /**< CSR timeout. When set to 1, indicates that software performed a write or read operation to
-                                                         a core register that could not be completed within 0xFFFF host-controller clock cycles. */
-	uint32_t buserraddrvld                : 1;  /**< Bus-error address valid. Indicates that UAHC(0)_GBUSERRADDR_* is valid and reports the
+                                                         a core register that could not be completed within 0xFFFF controller-clock cycles. */
+	uint32_t buserraddrvld                : 1;  /**< Bus-error address valid. Indicates that UAHC()_GBUSERRADDR is valid and reports the
                                                          first bus address that encounters a bus error. */
 	uint32_t reserved_2_3                 : 2;
-	uint32_t curmod                       : 2;  /**< Current mode of operation. Always 0x1.
-                                                         INTERNAL: May vary from 0x1 if you write UAHC(0)_GCTL[PRTCAPDIR]!=0x1. */
+	uint32_t curmod                       : 2;  /**< Current mode of operation. Always 0x1. INTERNAL: May vary from 0x1 if you write
+                                                         UAHC()_GCTL[PRTCAPDIR]!=0x1. */
 #else
 	uint32_t curmod                       : 2;
 	uint32_t reserved_2_3                 : 2;
@@ -4015,22 +4078,30 @@ typedef union cvmx_uahcx_gsts cvmx_uahcx_gsts_t;
  * cvmx_uahc#_gtxfifoprihst
  *
  * This register specifies the relative DMA priority level among the host TXFIFOs (one per USB
- * bus instance) within the associated speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed).
- * When multiple TXFIFOs compete for DMA service at a given time, the TXDMA arbiter grants access
- * on a packet-basis in the following manner:
- * Among the FIFOs in the same speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed):
- * High-priority TXFIFOs are granted access using round-robin arbitration
- * Low-priority TXFIFOs are granted access using round-robin arbitration only after high-priority
+ * bus instance) within the associated speed group (SuperSpeed or high-speed/full-speed
+ * /low-speed). When multiple TXFIFOs compete for DMA service at a given time, the TXDMA arbiter
+ * grants access on a packet-basis in the following manner:
+ *
+ * Among the FIFOs in the same speed group (SuperSpeed or high-speed/full-speed/low-speed):
+ *
+ * * High-priority TXFIFOs are granted access using round-robin arbitration.
+ * * Low-priority TXFIFOs are granted access using round-robin arbitration only after high-
+ * priority
  * TXFIFOs have no further processing to do (i.e., either the TXQs are empty or the corresponding
  * TXFIFOs do not have the required data).
- * The TX DMA arbiter prioritizes the SuperSpeed group or HighSpeed/FullSpeed/LowSpeed group
- * according to the ratio programmed in the UAHC(0)_GDMAHLRATIO register.
+ *
+ * The TX DMA arbiter prioritizes the SuperSpeed group or high-speed/full-speed/low-speed group
+ * according to the ratio programmed in
+ * UAHC()_GDMAHLRATIO.
+ *
  * For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until
  * the entire packet is completed. The register size corresponds to the number of configured USB
  * bus instances; for example, in the default configuration, there are 3 USB bus instances (1
- * SuperSpeed, 1 HighSpeed, and 1 FullSpeed/LowSpeed).
+ * SuperSpeed, 1 high-speed, and 1 full-speed/low-speed).
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.2.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gtxfifoprihst {
 	uint32_t u32;
@@ -4053,13 +4124,16 @@ typedef union cvmx_uahcx_gtxfifoprihst cvmx_uahcx_gtxfifoprihst_t;
  *
  * This register holds the internal RAM start address/depth of each TxFIFO implemented. Unless
  * packet size/buffer size for each endpoint is different and application-specific, it is
- * recommended that the software use the default value. One register per FIFO.
- * One register per FIFO.
+ * recommended that the software use the default value. One register per FIFO. One register per
+ * FIFO.
+ *
+ * Reset values = 0:[0x0000_0082] 1:[0x0082_0103] 2:[0x0185_0205].
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.6.1.
  * INTERNAL: For more information, refer to the BMU section in Block Descriptions on Synopsys
  * Databook page 238.
- * reset values = 0:[0x0000_0082] 1:[0x0082_0103] 2:[0x0185_0205]
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gtxfifosizx {
 	uint32_t u32;
@@ -4090,16 +4164,18 @@ typedef union cvmx_uahcx_gtxfifosizx cvmx_uahcx_gtxfifosizx_t;
  * 1024-byte packet, then starting a burst on 1-packet condition leads to an early abort of the
  * burst causing unnecessary performance reduction. This register allows the configuration of
  * threshold and burst size control. This feature is enabled by [USBTXPKTCNTSEL].
+ *
  * Transmit Path:
- *   * The Tx Threshold is controlled by [USBTXPKTCNT], and the Tx burst size is
- *     controlled by [USBMAXTXBURSTSIZE].
- *   * Selecting optimal Tx FIFO size, Tx Threshold, and Tx burst size avoids Tx burst aborts due
- *     to an underrun if the system bus is slower than USB. Once in a while an underrun is OK,
- *     and there is no functional issue.
- *   * A larger threshold will affect the performance, since the scheduler is idle during this
- *     time.
+ * * The TX Threshold is controlled by [USBTXPKTCNT], and the TX burst size is controlled by
+ * [USBMAXTXBURSTSIZE].
+ * * Selecting optimal TX FIFO size, TX Threshold, and TX burst size avoids TX burst aborts due
+ * to an underrun if the system bus is slower than USB. Once in a while an underrun is OK, and
+ * there is no functional issue.
+ * * A larger threshold affects the performance, since the scheduler is idle during this time.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.3.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gtxthrcfg {
 	uint32_t u32;
@@ -4119,7 +4195,7 @@ union cvmx_uahcx_gtxthrcfg {
 	uint32_t usbtxpktcnt                  : 4;  /**< USB transmit-packet count. Specifies the number of packets that must be in the TXFIFO
                                                          before the core can start transmission for the corresponding USB transaction (burst). This
                                                          field is only valid when USBTXPKTCNTSEL = 1. Valid values are from 0x1 to 0xF.
-                                                         Note: This field must be less than or equal to the USBMAXTXBURSTSIZE field. */
+                                                         This field must be <= USBMAXTXBURSTSIZE. */
 	uint32_t usbmaxtxburstsize            : 8;  /**< USB maximum TX burst size. When USBTXPKTCNTSEL = 1, this field specifies the maximum bulk
                                                          OUT burst the core should do. When the system bus is slower than the USB, TX FIFO can
                                                          underrun during a long burst. Program a smaller value to this field to limit the TX burst
@@ -4142,11 +4218,12 @@ typedef union cvmx_uahcx_gtxthrcfg cvmx_uahcx_gtxthrcfg_t;
 /**
  * cvmx_uahc#_guctl
  *
- * This register provides a few options for the software to control the core behavior in the Host
- * mode.
- * Most of the options are used to improve host inter-operability with different devices.
+ * This register provides a few options for the software to control the core behavior in the host
+ * mode. Most of the options are used to improve host inter-operability with different devices.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.11.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_guctl {
 	uint32_t u32;
@@ -4154,17 +4231,18 @@ union cvmx_uahcx_guctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t refclkper                    : 10; /**< Reference-clock period. Indicates (in terms of ns) the period of REF_CLK. The default
                                                          value is set to 0x8
-                                                         (8 ns/125 MHz). This field must be updated during power on initialization if UAHC(0)_GCTL
-                                                         [SOFITPSYNC] = 1 or UAHC(0)_GFLADJ [GFLADJ_REFCLK_LPM_SEL] = 1. The programmable maximum
-                                                         value 62 ns, and the minimum value is 8 ns. You use a reference clock with a period that
-                                                         is a integer multiple, so that ITP can meet the jitter margin of 32 ns. The allowable
-                                                         REF_CLK frequencies whose period is not integer multiples are 16/17/19.2/24/39.7 MHz.
+                                                         (8 ns/125 MHz). This field must be updated during power on initialization if
+                                                         UAHC()_GCTL[SOFITPSYNC] = 1 or UAHC()_GFLADJ [GFLADJ_REFCLK_LPM_SEL] = 1. The
+                                                         programmable maximum value 62 ns, and the minimum value is 8 ns. You use a reference clock
+                                                         with a period that is a integer multiple, so that ITP can meet the jitter margin of 32 ns.
+                                                         The allowable REF_CLK frequencies whose period is not integer multiples are
+                                                         16/17/19.2/24/39.7 MHz.
                                                          This field should not be set to 0x0 at any time. If you do not plan to use this feature,
                                                          then you need to set this field to 0x8, the default value. */
 	uint32_t noextrdl                     : 1;  /**< No extra delay between SOF and the first packet.
-                                                         Some HS devices misbehave when the host sends a packet immediately after an SOF. However,
-                                                         adding an extra delay between an SOF and the first packet can reduce the USB data rate and
-                                                         performance.
+                                                         Some high-speed devices misbehave when the host sends a packet immediately after an SOF.
+                                                         However, adding an extra delay between an SOF and the first packet can reduce the USB data
+                                                         rate and performance.
                                                          This bit is used to control whether the host should wait for 2 us before it sends the
                                                          first packet after a SOF, or not. You can set this bit to 1 to improve the performance if
                                                          those problematic devices are not a concern in your host environment.
@@ -4177,9 +4255,9 @@ union cvmx_uahcx_guctl {
                                                          transfers. Scheduling multiple transactions in one microframe/frame can cause these
                                                          devices to misbehave. If this bit is set to 1, the host controller schedules transactions
                                                          for a control transfer in different microframes/frames. */
-	uint32_t resbwhseps                   : 1;  /**< Reserving 85% bandwidth for HS periodic EPs. By default, host controller reserves 80% of
-                                                         the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85% to
-                                                         accommodate two high-speed, high-bandwidth ISOC EPs.
+	uint32_t resbwhseps                   : 1;  /**< Reserving 85% bandwidth for high-speed periodic EPs. By default, host controller reserves
+                                                         80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85%
+                                                         to accommodate two high-speed, high-bandwidth ISOC EPs.
                                                          USB 2.0 required 80% bandwidth allocated for ISOC traffic. If two high bandwidth ISOC
                                                          devices (HD webcams) are connected, and if each requires 1024-bytes * 3 packets per
                                                          microframe, then the bandwidth required is around 82%. If this bit is set to 1, it is
@@ -4187,8 +4265,8 @@ union cvmx_uahcx_guctl {
                                                          you may have to reduce the resolution of the webcams. */
 	uint32_t cmdevaddr                    : 1;  /**< Compliance mode for device address. When set to 1, slot ID can have different value than
                                                          device address if max_slot_enabled < 128.
-                                                         1 = increment device address on each address device command.
-                                                         0 = device address is equal to slot ID.
+                                                         0 = Device address is equal to slot ID.
+                                                         1 = Increment device address on each address device command.
                                                          The xHCI compliance requires this bit to be set to 1. The 0 mode is for debug purpose
                                                          only. This allows you to easily identify a device connected to a port in the Lecroy or
                                                          Eliisys trace during hardware debug. */
@@ -4199,50 +4277,50 @@ union cvmx_uahcx_guctl {
                                                          If the auto-retry feature is disabled (default), the core responds with a terminating
                                                          retry ACK (i.e. an ACK transaction packet with Retry = 1 and NumP = 0). */
 	uint32_t enoverlapchk                 : 1;  /**< Enable check for LFPS overlap during remote Ux Exit. If this bit is set to:
-                                                         - 1: The SuperSpeed link, when exiting U1/U2/U3, waits for either the remote link LFPS or
-                                                          TS1/TS2 training symbols before it confirms that the LFPS handshake is complete. This is
-                                                          done to handle the case where the LFPS glitch causes the link to start exiting from the
-                                                          low power state. Looking for the LFPS overlap makes sure that the link partner also sees
-                                                          the LFPS.
-                                                         - 0: When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS
-                                                          overlap. */
-	uint32_t extcapsupten                 : 1;  /**< External extended capability support enable. If disabled, a read UAHC(0)_SUPTPRT3_DW0
-                                                         [NEXTCAPPTR] returns 0 in the Next Capability Pointer field. This indicates there are no
-                                                         more capabilities. If enabled, a read to UAHC(0)_SUPTPRT3_DW0[NEXTCAPPTR] returns 4 in the
-                                                         Next Capability Pointer field.
+                                                         0 = When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS
+                                                         overlap.
+                                                         1 = The SuperSpeed link, when exiting U1/U2/U3, waits for either the remote link LFPS or
+                                                         TS1/TS2 training symbols before it confirms that the LFPS handshake is complete. This is
+                                                         done to handle the case where the LFPS glitch causes the link to start exiting from the
+                                                         low power state. Looking for the LFPS overlap makes sure that the link partner also sees
+                                                         the LFPS. */
+	uint32_t extcapsupten                 : 1;  /**< External extended capability support enable. If disabled, a read UAHC()_SUPTPRT3_DW0
+                                                         [NEXTCAPPTR] returns 0 in the next capability pointer field. This indicates there are no
+                                                         more capabilities. If enabled, a read to UAHC()_SUPTPRT3_DW0[NEXTCAPPTR] returns 4 in the
+                                                         next capability pointer field.
                                                          Always set to 0x0. */
-	uint32_t insrtextrfsbodi              : 1;  /**< Insert extra delay between FS bulk OUT transactions. Some FS devices are slow to receive
-                                                         bulk OUT data and can get stuck when there are consecutive bulk OUT transactions with
-                                                         short inter-transaction delays. This bit is used to control whether the host inserts extra
-                                                         delay between consecutive bulk OUT transactions to a FS endpoint.
-                                                         1 = host inserts about 12us extra delay between consecutive bulk OUT transactions to an FS
-                                                         endpoint to work around the device issue.
-                                                         0 = host does not insert extra delay.
-                                                         Setting this bit to 1 reduces the bulk OUT transfer performance for most of the FS
-                                                         devices. */
+	uint32_t insrtextrfsbodi              : 1;  /**< Insert extra delay between full-speed bulk OUT transactions. Some full-speed devices are
+                                                         slow to receive bulk OUT data and can get stuck when there are consecutive bulk OUT
+                                                         transactions with short inter-transaction delays. This bit is used to control whether the
+                                                         host inserts extra delay between consecutive bulk OUT transactions to a full-speed
+                                                         endpoint.
+                                                         0 = Host does not insert extra delay.
+                                                         Setting this bit to 1 reduces the bulk OUT transfer performance for most of the full-speed
+                                                         devices.
+                                                         1 = Host inserts about 12 us extra delay between consecutive bulk OUT transactions to an
+                                                         full-speed endpoint to work around the device issue. */
 	uint32_t dtct                         : 2;  /**< Device timeout coarse tuning. This field determines how long the host waits for a response
                                                          from device before considering a timeout.
                                                          The core first checks the DTCT value. If it is 0, then the timeout value is defined by the
                                                          DTFT. If it is non-zero, then it uses the following timeout values:
-                                                         0x0 = 0 us; use DTFT value instead
-                                                         0x1 = 500 us
-                                                         0x2 = 1.5 ms
-                                                         0x3 = 6.5 ms */
+                                                         0x0 = 0 us; use DTFT value instead.
+                                                         0x1 = 500 us.
+                                                         0x2 = 1.5 ms.
+                                                         0x3 = 6.5 ms. */
 	uint32_t dtft                         : 9;  /**< Device timeout fine tuning. This field determines how long the host waits for a response
                                                          from a device before considering a timeout. For DTFT to take effect, DTCT must be set to
                                                          0x0.
                                                          The DTFT value specifies the number of 125MHz clock cycles * 256 to count before
                                                          considering a device timeout. For the 125 MHz clock cycles (8 ns period), this is
                                                          calculated as follows:
-                                                         [DTFT value] * 256 * 8 (ns)
-                                                         DTFT Value Calculation Timeout
-                                                         0x2 2 * 256 * 8 4 us
-                                                         0x5 5 * 256 * 8 10 us
-                                                         0xA 10 * 256 * 8 20 us
-                                                         0x10 16 * 256 * 8 32 us
-                                                         0x19 25 * 256 * 8 51 us
-                                                         0x31 49 * 256 * 8 100 us
-                                                         0x62 98 * 256 * 8 200 us */
+                                                         _ [DTFT value] * 256 * 8 (ns)
+                                                         0x2 = 2 * 256 * 8 -> 4 us.
+                                                         0x5 = 5 * 256 * 8 -> 10 us.
+                                                         0xA = 10 * 256 * 8 -> 20 us.
+                                                         0x10 = 16 * 256 * 8 -> 32 us.
+                                                         0x19 = 25 * 256 * 8 -> 51 us.
+                                                         0x31 = 49 * 256 * 8 -> 100 us.
+                                                         0x62 = 98 * 256 * 8 -> 200 us. */
 #else
 	uint32_t dtft                         : 9;
 	uint32_t dtct                         : 2;
@@ -4265,8 +4343,9 @@ typedef union cvmx_uahcx_guctl cvmx_uahcx_guctl_t;
 /**
  * cvmx_uahc#_guctl1
  *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.7.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_guctl1 {
 	uint32_t u32;
@@ -4293,11 +4372,13 @@ typedef union cvmx_uahcx_guctl1 cvmx_uahcx_guctl1_t;
  * This is a read/write register containing the User ID. The power-on value for this register is
  * specified as the User Identification Register. This register can be used in the following
  * ways:
- *   * To store the version or revision of your system
- *   * To store hardware configurations that are outside the core
- *   * As a scratch register
+ * * To store the version or revision of your system.
+ * * To store hardware configurations that are outside of the core.
+ * * As a scratch register.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.10.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_guid {
 	uint32_t u32;
@@ -4315,9 +4396,11 @@ typedef union cvmx_uahcx_guid cvmx_uahcx_guid_t;
 /**
  * cvmx_uahc#_gusb2i2cctl#
  *
- * Reserved for future use.
+ * This register is reserved for future use.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.2.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
  */
 union cvmx_uahcx_gusb2i2cctlx {
 	uint32_t u32;
@@ -4339,9 +4422,11 @@ typedef union cvmx_uahcx_gusb2i2cctlx cvmx_uahcx_gusb2i2cctlx_t;
  * PHY-related configuration parameters. The application must program this register before
  * starting any transactions on either the SoC bus or the USB. Per-port registers are
  * implemented.
- * Note: Do not make changes to this register after the initial programming.
+ *
+ * Do not make changes to this register after the initial programming.
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.1.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
+ * Reset by: IOI reset or UCTL()_CTL[UAHC_RST].
  */
 union cvmx_uahcx_gusb2phycfgx {
 	uint32_t u32;
@@ -4349,14 +4434,14 @@ union cvmx_uahcx_gusb2phycfgx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t physoftrst                   : 1;  /**< PHY soft reset. Causes the usb2phy_reset signal to be asserted to reset a UTMI PHY. */
 	uint32_t u2_freeclk_exists            : 1;  /**< Specifies whether your USB 2.0 PHY provides a free-running PHY clock, which is active when
-                                                          the clock control input is active. If your USB 2.0 PHY provides a free-running PHY clock,
-                                                          it must be connected to the utmi_clk[0] input. The remaining utmi_clk[n] must be connected
-                                                          to the respective port clocks. The core uses the Port-0 clock for generating the internal
-                                                          mac2 clock.
-                                                         - 0: USB 2.0 free clock does not exist
-                                                         - 1: USB 2.0 free clock exists
-                                                          Note: This field must be set to zero if you enable ITP generation based on the REF_CLK
-                                                          counter, GCTL.SOFITPSYNC=1, or GFLADJ. GFLADJ_REFCLK_LPM_SEL=1. */
+                                                         the clock control input is active. If your USB 2.0 PHY provides a free-running PHY clock,
+                                                         it must be connected to the utmi_clk[0] input. The remaining utmi_clk[n] must be connected
+                                                         to the respective port clocks. The core uses the Port-0 clock for generating the internal
+                                                         mac2 clock.
+                                                         0 = USB 2.0 free clock does not exist.
+                                                         1 = USB 2.0 free clock exists.
+                                                         This field must be set to zero if you enable ITP generation based on the REF_CLK
+                                                         counter, UAHC()_GCTL[SOFITPSYNC] = 1, or UAHC()_GFLADJ [GFLADJ_REFCLK_LPM_SEL] = 1. */
 	uint32_t ulpi_lpm_with_opmode_chk     : 1;  /**< Support the LPM over ULPI without NOPID token to the ULPI PHY. Always 0x0. */
 	uint32_t reserved_19_28               : 10;
 	uint32_t ulpiextvbusindicator         : 1;  /**< Reserved (unused in this configuration). */
@@ -4373,14 +4458,14 @@ union cvmx_uahcx_gusb2phycfgx {
 	uint32_t reserved_9_9                 : 1;
 	uint32_t enblslpm                     : 1;  /**< Enable utmi_sleep_n and utmi_l1_suspend_n. The application uses this field to control
                                                          utmi_sleep_n and utmi_l1_suspend_n assertion to the PHY in the L1 state.
-                                                         1 = utmi_sleep_n and utmi_l1_suspend_n assertion from the core is transferred to the
-                                                         external PHY.
                                                          0 = utmi_sleep_n and utmi_l1_suspend_n assertion from the core is not transferred to the
                                                          external PHY.
+                                                         1 = utmi_sleep_n and utmi_l1_suspend_n assertion from the core is transferred to the
+                                                         external PHY.
                                                          When hardware LPM is enabled, this bit should be set high for Port0. */
-	uint32_t physel                       : 1;  /**< USB 2.0 HS PHY or USB 1.1 FS Serial Transceiver Select */
-	uint32_t susphy                       : 1;  /**< Suspend USB2.0 HS/FS/LS PHY. When set, USB2.0 PHY enters suspend mode if suspend
-                                                         conditions are valid. */
+	uint32_t physel                       : 1;  /**< USB 2.0 high-speed PHY or USB 1.1 full-speed serial transceiver select. */
+	uint32_t susphy                       : 1;  /**< Suspend USB2.0 high-speed/full-speed/low-speed PHY. When set, USB2.0 PHY enters suspend
+                                                         mode if suspend conditions are valid. */
 	uint32_t fsintf                       : 1;  /**< Full-speed serial-interface select. Always reads as 0x0. */
 	uint32_t ulpi_utmi_sel                : 1;  /**< ULPI or UTMI+ select. Always reads as 0x0, indicating UTMI+. */
 	uint32_t phyif                        : 1;  /**< PHY interface width: 1 = 16-bit, 0 = 8-bit.
@@ -4389,7 +4474,7 @@ union cvmx_uahcx_gusb2phycfgx {
                                                          The UTMI 8-bit and 16-bit modes cannot be used together for different ports at the same
                                                          time (i.e., all the ports should be in 8-bit mode, or all of them should be in 16-bit
                                                          mode). */
-	uint32_t toutcal                      : 3;  /**< HS/FS timeout calibration.
+	uint32_t toutcal                      : 3;  /**< High-speed/full-speed timeout calibration.
                                                          The number of PHY clock cycles, as indicated by the application in this field, is
                                                          multiplied by a bit-time factor; this factor is added to the high-speed/full-speed
                                                          interpacket timeout duration in the core to account for additional delays introduced by
@@ -4399,13 +4484,13 @@ union cvmx_uahcx_gusb2phycfgx {
                                                          times. The USB standard timeout value for full-speed operation is 16 to 18 (inclusive) bit
                                                          times. The application must program this field based on the speed of connection.
                                                          The number of bit times added per PHY clock are:
-                                                         high-speed operation:
-                                                         - one 30-MHz PHY clock = 16 bit times
-                                                         - one 60-MHz PHY clock = 8 bit times
-                                                         full-speed operation:
-                                                         - one 30-MHz PHY clock = 0.4 bit times
-                                                         - one 60-MHz PHY clock = 0.2 bit times
-                                                         - one 48-MHz PHY clock = 0.25 bit times */
+                                                         * High-speed operation:
+                                                         - one 30-MHz PHY clock = 16 bit times.
+                                                         - one 60-MHz PHY clock = 8 bit times.
+                                                         * Full-speed operation:
+                                                         - one 30-MHz PHY clock = 0.4 bit times.
+                                                         - one 60-MHz PHY clock = 0.2 bit times.
+                                                         - one 48-MHz PHY clock = 0.25 bit times. */
 #else
 	uint32_t toutcal                      : 3;
 	uint32_t phyif                        : 1;
@@ -4436,11 +4521,13 @@ typedef union cvmx_uahcx_gusb2phycfgx cvmx_uahcx_gusb2phycfgx_t;
  *
  * This register is used to configure the core after power-on. It contains USB 3.0 and USB 3.0
  * PHY-related configuration parameters. The application must program this register before
- * starting any transactions on either the SoC bus or the USB.
- * Per-port registers are implemented.
- * Note: Do not make changes to this register after the initial programming.
+ * starting any transactions on either the SoC bus or the USB. Per-port registers are
+ * implemented.
+ *
+ * Do not make changes to this register after the initial programming.
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.4.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET].
+ * Reset by: IOI reset or UCTL()_CTL[UAHC_RST].
  */
 union cvmx_uahcx_gusb3pipectlx {
 	uint32_t u32;
@@ -4448,50 +4535,51 @@ union cvmx_uahcx_gusb3pipectlx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t physoftrst                   : 1;  /**< USB3 PHY soft reset (PHYSoftRst). When set to 1, initiates a PHY soft reset. After setting
                                                          this bit to 1, the software needs to clear this bit. */
-	uint32_t hstprtcmpl                   : 1;  /**< Host port compliance. Setting this bit to 1 enables placing the SS port link into a
-                                                         compliance state, which allows testing of the PIPE PHY compliance patterns without having
-                                                         to have a test fixture on the USB 3.0 cable. By default, this bit should be set to 0.
-                                                         In compliance-lab testing, the SS port link enters compliance after failing the first
-                                                         polling sequence after power on. Set this bit to 0, when you run compliance tests.
+	uint32_t hstprtcmpl                   : 1;  /**< Host port compliance. Setting this bit to 1 enables placing the SuperSpeed port link into
+                                                         a compliance state, which allows testing of the PIPE PHY compliance patterns without
+                                                         having to have a test fixture on the USB 3.0 cable. By default, this bit should be set to
+                                                         0.
+                                                         In compliance-lab testing, the SuperSpeed port link enters compliance after failing the
+                                                         first polling sequence after power on. Set this bit to 0 when you run compliance tests.
                                                          The sequence for using this functionality is as follows:
-                                                         Disconnect any plugged in devices.
-                                                         Set UAHC_USBCMD[HCRST] = 1 or power-on-chip reset.
-                                                         Set UAHC_PORTSC[PP] = 0.
-                                                         Set HSTPRTCMPL = 1. This places the link into compliance state.
+                                                         * Disconnect any plugged-in devices.
+                                                         * Set UAHC()_USBCMD[HCRST] = 1 or power-on-chip reset.
+                                                         * Set UAHC()_PORTSC()[PP] = 0.
+                                                         * Set HSTPRTCMPL = 1. This places the link into compliance state.
                                                          To advance the compliance pattern, follow this sequence (toggle HSTPRTCMPL):
-                                                         Set HSTPRTCMPL = 0.
-                                                         Set HSTPRTCMPL = 1. This advances the link to the next compliance pattern.
-                                                         To exit from the compliance state, set UAHC_USBCMD[HCRST = 1 or power-on-chip reset. */
-	uint32_t u2ssinactp3ok                : 1;  /**< P3 OK for U2/SSInactive:
-                                                         1 = during link state U2/SS.Inactive, put PHY in P3
-                                                         0 = during link state U2/SS.Inactive, put PHY in P2 (Default) */
+                                                         * Set HSTPRTCMPL = 0.
+                                                         * Set HSTPRTCMPL = 1. This advances the link to the next compliance pattern.
+                                                         To exit from the compliance state, set UAHC()_USBCMD[HCRST] = 1 or power-on-chip reset. */
+	uint32_t u2ssinactp3ok                : 1;  /**< P3 OK for U2/SS.Inactive:
+                                                         0 = During link state U2/SS.Inactive, put PHY in P2 (default).
+                                                         1 = During link state U2/SS.Inactive, put PHY in P3. */
 	uint32_t disrxdetp3                   : 1;  /**< Disables receiver detection in P3. If PHY is in P3 and the core needs to perform receiver
                                                          detection:
-                                                         1 = core changes the PHY power state to P2 and then performs receiver detection. After
-                                                         receiver detection, core changes PHY power state to P3.
-                                                         0 = core performs receiver detection in P3 (default) */
+                                                         0 = Core performs receiver detection in P3 (default).
+                                                         1 = Core changes the PHY power state to P2 and then performs receiver detection. After
+                                                         receiver detection, core changes PHY power state to P3. */
 	uint32_t ux_exit_in_px                : 1;  /**< UX exit in Px:
-                                                         1 = the core does U1/U2/U3 exit in PHY power state P1/P2/P3 respectively
-                                                         0 = the core does U1/U2/U3 exit in PHY power state P0 (default behavior)
-                                                         This bit is added for SS PHY workaround where SS PHY injects a glitch on pipe3_RxElecIdle
-                                                         while receiving Ux exit LFPS, and pipe3_PowerDown change is in progress.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         0 = Core does U1/U2/U3 exit in PHY power state P0 (default behavior).
+                                                         1 = Core does U1/U2/U3 exit in PHY power state P1/P2/P3 respectively.
+                                                         This bit is added for SuperSpeed PHY workaround where SuperSpeed PHY injects a glitch on
+                                                         pipe3_RxElecIdle while receiving Ux exit LFPS, and pipe3_PowerDown change is in progress.
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t ping_enchance_en             : 1;  /**< Ping enhancement enable. When set to 1, the downstream-port U1-ping-receive timeout
                                                          becomes 500 ms instead of 300 ms. Minimum Ping.LFPS receive duration is 8 ns (one mac3_clk
                                                          cycle). This field is valid for the downstream port only.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t u1u2exitfail_to_recov        : 1;  /**< U1U2exit fail to recovery. When set to 1, and U1/U2 LFPS handshake fails, the LTSSM
-                                                         transitions from U1/U2 to recovery instead of SS inactive.
+                                                         transitions from U1/U2 to recovery instead of SS.inactive.
                                                          If recovery fails, then the LTSSM can enter SS.Inactive. This is an enhancement only. It
                                                          prevents interoperability issue if the remote link does not do the proper handshake. */
 	uint32_t request_p1p2p3               : 1;  /**< Always request P1/P2/P3 for U1/U2/U3.
-                                                         1 = the core always requests PHY power change from P0 to P1/P2/P3 during U0 to U1/U2/U3
-                                                         transition.
                                                          0 = if immediate Ux exit (remotely initiated, or locally initiated) happens, the core does
                                                          not request P1/P2/P3 power state change.
-                                                         INTERNAL: Note: This bit should be set to '1' for Synopsys PHY. For third-party SuperSpeed
+                                                         1 = the core always requests PHY power change from P0 to P1/P2/P3 during U0 to U1/U2/U3
+                                                         transition.
+                                                         INTERNAL: Note: This bit should be set to 1 for Synopsys PHY. For third-party SuperSpeed
                                                          PHY, check with your PHY vendor. */
 	uint32_t startrxdetu3rxdet            : 1;  /**< Start receiver detection in U3/Rx.Detect.
                                                          If DISRXDETU3RXDET is set to 1 during reset, and the link is in U3 or Rx.Detect state, the
@@ -4511,19 +4599,19 @@ union cvmx_uahcx_gusb3pipectlx {
                                                          INTERNAL: Should always be 0x1 for a Synopsys PHY. */
 	uint32_t delaypxtransenterux          : 1;  /**< Delay PHY power change from P0 to P1/P2/P3 when link state changing from U0 to U1/U2/U3
                                                          respectively.
-                                                         1 = when entering U1/U2/U3, delay the transition to P1/P2/P3 until the pipe3 signals,
-                                                         Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0
                                                          0 = when entering U1/U2/U3, transition to P1/P2/P3 without checking for Pipe3_RxElecIlde
                                                          and pipe3_RxValid.
+                                                         1 = when entering U1/U2/U3, delay the transition to P1/P2/P3 until the pipe3 signals,
+                                                         Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0.
                                                          INTERNAL: Note: This bit should be set to '1' for Synopsys PHY. It is also used by third-
                                                          party SuperSpeed PHY. */
 	uint32_t suspend_en                   : 1;  /**< Suspend USB3.0 SuperSpeed PHY (Suspend_en). When set to 1, and if suspend conditions are
                                                          valid, the USB 3.0 PHY enters suspend mode. */
 	uint32_t datwidth                     : 2;  /**< PIPE data width.
-                                                         0x0 = 32 bits
-                                                         0x1 = 16 bits
-                                                         0x2 = 8 bits
-                                                         0x3 = reserved
+                                                         0x0 = 32 bits.
+                                                         0x1 = 16 bits.
+                                                         0x2 = 8 bits.
+                                                         0x3 = reserved.
                                                          One clock cycle after reset, these bits receive the value seen on the pipe3_DataBusWidth.
                                                          This will always be 0x0.
                                                          INTERNAL: The simulation testbench uses the coreConsultant parameter to configure the VIP.
@@ -4532,42 +4620,42 @@ union cvmx_uahcx_gusb3pipectlx {
 	uint32_t abortrxdetinu2               : 1;  /**< Abort RX Detect in U2. When set to 1, and the link state is U2, the core aborts receiver
                                                          detection if it receives U2 exit LFPS from the remote link partner.
                                                          This bit is for downstream port only.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t skiprxdet                    : 1;  /**< Skip RX detect. When set to 1, the core skips RX detection if pipe3_RxElecIdle is low.
                                                          Skip is defined as waiting for the appropriate timeout, then repeating the operation. */
 	uint32_t lfpsp0algn                   : 1;  /**< LFPS P0 align. When set to 1:
-                                                         the core deasserts LFPS transmission on the clock edge that it requests Phy power state 0
-                                                         when exiting U1, U2, or U3 low power states. Otherwise, LFPS transmission is asserted one
-                                                         clock earlier.
-                                                         the core requests symbol transmission two pipe3_rx_pclks periods after the PHY asserts
+                                                         * the core deasserts LFPS transmission on the clock edge that it requests Phy power state
+                                                         0 when exiting U1, U2, or U3 low power states. Otherwise, LFPS transmission is asserted
+                                                         one clock earlier.
+                                                         * the core requests symbol transmission two pipe3_rx_pclks periods after the PHY asserts
                                                          PhyStatus as a result of the PHY switching from P1 or P2 state to P0 state.
                                                          For USB 3.0 host, this is not required. */
 	uint32_t p3p2tranok                   : 1;  /**< P3 P2 transitions OK.
-                                                         1 = the core transitions directly from Phy power state P2 to P3 or from state P3 to P2.
                                                          0 = P0 is always entered as an intermediate state during transitions between P2 and P3, as
                                                          defined in the PIPE3 specification.
+                                                         1 = the core transitions directly from Phy power state P2 to P3 or from state P3 to P2.
                                                          According to PIPE3 specification, any direct transition between P3 and P2 is illegal.
                                                          INTERNAL: This bit is used only for some non-Synopsys PHYs that cannot do LFPS in P3.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t p3exsigp2                    : 1;  /**< P3 exit signal in P2. When set to 1, the core always changes the PHY power state to P2,
                                                          before attempting a U3 exit handshake.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t lfpsfilt                     : 1;  /**< LFPS filter. When set to 1, filter LFPS reception with pipe3_RxValid in PHY power state
                                                          P0, ignore LFPS reception from the PHY unless both pipe3_Rxelecidle and pipe3_RxValid are
                                                          deasserted. */
 	uint32_t rxdet2polllfpsctrl           : 1;  /**< RX_DETECT to Polling.
-                                                         0 = Enables a 400us delay to start polling LFPS after RX_DETECT. This allows VCM offset to
-                                                         settle to a proper level.
-                                                         1 = Disables the 400us delay to start polling LFPS after RX_DETECT. */
+                                                         0 = Enables a 400 us delay to start polling LFPS after RX_DETECT. This allows VCM offset
+                                                         to settle to a proper level.
+                                                         1 = Disables the 400 us delay to start polling LFPS after RX_DETECT. */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t txswing                      : 1;  /**< Tx swing. Refer to the PIPE3 specificiation. */
-	uint32_t txmargin                     : 3;  /**< Tx margin. Refer to the PIPE3 specificiation, table 5-3. */
-	uint32_t txdeemphasis                 : 2;  /**< Tx de-emphasis. The value driven to the PHY is controlled by the LTSSM during USB3
-                                                         compliance mode. Refer to the PIPE3 specificiation, table 5-3. */
-	uint32_t elasticbuffermode            : 1;  /**< Elastic buffer mode. Refer to the PIPE3 specificiation, table 5-3. */
+	uint32_t txswing                      : 1;  /**< TX swing. Refer to the PIPE3 specification. */
+	uint32_t txmargin                     : 3;  /**< TX margin. Refer to the PIPE3 specification, table 5-3. */
+	uint32_t txdeemphasis                 : 2;  /**< TX de-emphasis. The value driven to the PHY is controlled by the LTSSM during USB3
+                                                         compliance mode. Refer to the PIPE3 specification, table 5-3. */
+	uint32_t elasticbuffermode            : 1;  /**< Elastic buffer mode. Refer to the PIPE3 specification, table 5-3. */
 #else
 	uint32_t elasticbuffermode            : 1;
 	uint32_t txdeemphasis                 : 2;
@@ -4619,7 +4707,7 @@ union cvmx_uahcx_hccparams {
 	uint32_t ltc                          : 1;  /**< Latency tolerance messaging capability. */
 	uint32_t lhrc                         : 1;  /**< Light HC reset capability. */
 	uint32_t pind                         : 1;  /**< Port indicators. */
-	uint32_t ppc                          : 1;  /**< Port power control. Value is based on UCTL(0)_HOST_CFG[PPC_EN]. */
+	uint32_t ppc                          : 1;  /**< Port power control. Value is based on UCTL()_HOST_CFG[PPC_EN]. */
 	uint32_t csz                          : 1;  /**< Context size. */
 	uint32_t bnc                          : 1;  /**< BW negotiation capability. */
 	uint32_t ac64                         : 1;  /**< 64-bit addressing capability. */
@@ -4722,9 +4810,12 @@ typedef union cvmx_uahcx_hcsparams3 cvmx_uahcx_hcsparams3_t;
 /**
  * cvmx_uahc#_iman#
  *
- * See xHCI specification v1.0 section 5.5.2.1.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.1.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_imanx {
 	uint32_t u32;
@@ -4732,7 +4823,7 @@ union cvmx_uahcx_imanx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_2_31                : 30;
 	uint32_t ie                           : 1;  /**< Interrupt enable. */
-	uint32_t ip                           : 1;  /**< Interrupt pending. Throws UCTL_INTSN_E::UCTL(0)_UAHC_IMAN(0)_IP. */
+	uint32_t ip                           : 1;  /**< Interrupt pending. */
 #else
 	uint32_t ip                           : 1;
 	uint32_t ie                           : 1;
@@ -4746,9 +4837,12 @@ typedef union cvmx_uahcx_imanx cvmx_uahcx_imanx_t;
 /**
  * cvmx_uahc#_imod#
  *
- * See xHCI specification v1.0 section 5.5.2.2.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.2.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_imodx {
 	uint32_t u32;
@@ -4768,9 +4862,12 @@ typedef union cvmx_uahcx_imodx cvmx_uahcx_imodx_t;
 /**
  * cvmx_uahc#_mfindex
  *
- * See xHCI specification v1.0 section 5.5.1.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.1.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_mfindex {
 	uint32_t u32;
@@ -5995,18 +6092,31 @@ typedef union cvmx_uahcx_pagesize cvmx_uahcx_pagesize_t;
 /**
  * cvmx_uahc#_porthlpmc_20#
  *
- * See xHCI specification v1.? section ?.
- * INTERNAL: TODO (new unreleased xHCI errata!)
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST].
+ * For information on this register, refer to the xHCI Specification, v1.1, section 5.4.11.2.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_porthlpmc_20x {
 	uint32_t u32;
 	struct cvmx_uahcx_porthlpmc_20x_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_14_31               : 18;
-	uint32_t hirdd                        : 4;  /**< TODO unreleased xHCI errata */
-	uint32_t l1_timeout                   : 8;  /**< TODO: unreleased xHCI errata */
+	uint32_t hirdd                        : 4;  /**< See section 5.4.11.2 of the XHCI Spec 1.1.
+                                                         If UAHC()_SUPTPRT2_DW2[BLC] = 0, then HIRD timing is applied to this field.
+                                                         If UAHC()_SUPTPRT2_DW2[BLC] = 1, then BESL timing is applied to this field. */
+	uint32_t l1_timeout                   : 8;  /**< Timeout value for the L1 inactivity timer (LPM Timer). This field is set to 0x0 by the
+                                                         assertion of PR to 1. Refer to section 4.23.5.1.1.1 (in XHCI spec 1.1) for more
+                                                         information on L1 Timeout operation.
+                                                         The following are permissible values:
+                                                         0x0 =  128 us. (default).
+                                                         0x1 =  256 us.
+                                                         0x2 =  512 us.
+                                                         0x3 =  768 us.
+                                                         _ ...
+                                                         0xFF =  65280 us. */
 	uint32_t hirdm                        : 2;  /**< Host-initiated resume-duration mode. */
 #else
 	uint32_t hirdm                        : 2;
@@ -6022,10 +6132,13 @@ typedef union cvmx_uahcx_porthlpmc_20x cvmx_uahcx_porthlpmc_20x_t;
 /**
  * cvmx_uahc#_porthlpmc_ss#
  *
- * See xHCI specification v1.? section ?.
- * INTERNAL: TODO: (new unreleased xHCI errata!)
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST].
+ * The USB3 Port Hardware LPM Control register is reserved and shall be treated as RsvdP by
+ * software. See xHCI specification v1.1 section 5.4.11.1.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST].
  */
 union cvmx_uahcx_porthlpmc_ssx {
 	uint32_t u32;
@@ -6083,9 +6196,12 @@ typedef union cvmx_uahcx_portli_ssx cvmx_uahcx_portli_ssx_t;
 /**
  * cvmx_uahc#_portpmsc_20#
  *
- * See xHCI specification v1.0 section 5.4.9.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.9.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST].
  */
 union cvmx_uahcx_portpmsc_20x {
 	uint32_t u32;
@@ -6115,9 +6231,12 @@ typedef union cvmx_uahcx_portpmsc_20x cvmx_uahcx_portpmsc_20x_t;
 /**
  * cvmx_uahc#_portpmsc_ss#
  *
- * See xHCI specification v1.0 section 5.4.9.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.9.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST].
  */
 union cvmx_uahcx_portpmsc_ssx {
 	uint32_t u32;
@@ -6141,10 +6260,13 @@ typedef union cvmx_uahcx_portpmsc_ssx cvmx_uahcx_portpmsc_ssx_t;
 /**
  * cvmx_uahc#_portsc#
  *
- * See xHCI specification v1.0 section 5.4.8.
- * Port 1 is USB3.0 SuperSpeed link. Port 0 is USB2.0 HighSpeed/FullSpeed/LowSpeed link.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.8. Port 1
+ * is USB3.0 SuperSpeed link, Port 0 is USB2.0 high-speed/full-speed/low-speed link.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST].
  */
 union cvmx_uahcx_portscx {
 	uint32_t u32;
@@ -6308,8 +6430,8 @@ typedef union cvmx_uahcx_suptprt2_dw2 cvmx_uahcx_suptprt2_dw2_t;
 /**
  * cvmx_uahc#_suptprt2_dw3
  *
- * See xHCI specification v1.? section 7.2.
- * INTERNAL: TODO (new unreleased xHCI errata!)
+ * For information on this register, refer to the xHCI Specification, v1.1, section 7.2.
+ *
  */
 union cvmx_uahcx_suptprt2_dw3 {
 	uint32_t u32;
@@ -6338,9 +6460,8 @@ union cvmx_uahcx_suptprt3_dw0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t majorrev                     : 8;  /**< Major revision. */
 	uint32_t minorrev                     : 8;  /**< Minor revision. */
-	uint32_t nextcapptr                   : 8;  /**< Next capability pointer
-                                                         Value depends on UAHC(0)_GUCTL[EXTCAPSUPTEN].
-                                                         If EXTCAPSUPTEN = 0, value is 0x0. If = 1, value is 0x4. */
+	uint32_t nextcapptr                   : 8;  /**< Next capability pointer. Value depends on UAHC()_GUCTL[EXTCAPSUPTEN]. If EXTCAPSUPTEN =
+                                                         0, value is 0x0. If EXTCAPSUPTEN = 1, value is 0x4. */
 	uint32_t capid                        : 8;  /**< Capability ID = supported protocol. */
 #else
 	uint32_t capid                        : 8;
@@ -6400,8 +6521,8 @@ typedef union cvmx_uahcx_suptprt3_dw2 cvmx_uahcx_suptprt3_dw2_t;
 /**
  * cvmx_uahc#_suptprt3_dw3
  *
- * See xHCI specification v1.? section 7.2.
- * INTERNAL: TODO (new unreleased xHCI errata!)
+ * For information on this register, refer to the xHCI Specification, v1.1, section 7.2.
+ *
  */
 union cvmx_uahcx_suptprt3_dw3 {
 	uint32_t u32;
@@ -6421,9 +6542,12 @@ typedef union cvmx_uahcx_suptprt3_dw3 cvmx_uahcx_suptprt3_dw3_t;
 /**
  * cvmx_uahc#_usbcmd
  *
- * See xHCI specification v1.0 section 5.4.1.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.1.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_usbcmd {
 	uint32_t u32;
@@ -6461,10 +6585,13 @@ typedef union cvmx_uahcx_usbcmd cvmx_uahcx_usbcmd_t;
 /**
  * cvmx_uahc#_usblegctlsts
  *
- * See xHCI specification v1.0 section 7.1.2.
- * Note that the SMI interrupts are not connected to anything in an Octeon configuration.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.1.2. Note
+ * that the SMI interrupts are not connected to anything in a CNXXXX configuration.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_usblegctlsts {
 	uint32_t u32;
@@ -6473,14 +6600,16 @@ union cvmx_uahcx_usblegctlsts {
 	uint32_t smi_on_bar                   : 1;  /**< System management interrupt on BAR. Never generated. */
 	uint32_t smi_on_pci_command           : 1;  /**< System management interrupt on PCI command. Never generated. */
 	uint32_t smi_on_os_ownership          : 1;  /**< System management interrupt on OS ownership change. This bit is set to 1 whenever
-                                                         UAHC_USBLEGSUP[HC_OS_OWNED_SEMAPHORES] transitions. */
+                                                         UAHC()_USBLEGSUP[HC_OS_OWNED_SEMAPHORES] transitions. */
 	uint32_t reserved_21_28               : 8;
-	uint32_t smi_on_hostsystemerr         : 1;  /**< System-management interrupt on host-system error. Shadow bit of UAHC_USBSTS[HSE]. Refer to
+	uint32_t smi_on_hostsystemerr         : 1;  /**< System-management interrupt on host-system error. Shadow bit of UAHC()_USBSTS[HSE]. Refer
+                                                         to
                                                          xHCI Section 5.4.2 for definition and effects of the events associated with this bit being
                                                          set to 1.
-                                                         To clear this bit to a 0, system software must write a 1 to UAHC_USBSTS[HSE]. */
+                                                         To clear this bit to a 0, system software must write a 1 to UAHC()_USBSTS[HSE]. */
 	uint32_t reserved_17_19               : 3;
-	uint32_t smi_on_event_interrupt       : 1;  /**< System-management interrupt on event interrupt. Shadow bit of UAHC_USBSTS[EINT]. Refer to
+	uint32_t smi_on_event_interrupt       : 1;  /**< System-management interrupt on event interrupt. Shadow bit of UAHC()_USBSTS[EINT]. Refer
+                                                         to
                                                          xHCI Section 5.4.2 for definition. This bit automatically clears when [EINT] clears and
                                                          sets when [EINT] sets. */
 	uint32_t smi_on_bar_en                : 1;  /**< System-management interrupt on BAR enable. */
@@ -6514,9 +6643,12 @@ typedef union cvmx_uahcx_usblegctlsts cvmx_uahcx_usblegctlsts_t;
 /**
  * cvmx_uahc#_usblegsup
  *
- * See xHCI specification v1.0 section 7.1.1.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.1.1.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_usblegsup {
 	uint32_t u32;
@@ -6544,9 +6676,12 @@ typedef union cvmx_uahcx_usblegsup cvmx_uahcx_usblegsup_t;
 /**
  * cvmx_uahc#_usbsts
  *
- * See xHCI specification v1.0 section 5.4.2.
- * Reset by: IOI reset (srst_n) or UCTL(0)_CTL[UAHC_RESET] or UAHC(0)_GCTL[CORESOFTRESET] or
- * UAHC(0)_USBCMD[HCRST] or UAHC(0)_USBCMD[LHCRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.2.
+ *
+ * This register can be reset by IOI reset,
+ * or UCTL()_CTL[UAHC_RST],
+ * or UAHC()_GCTL[CORESOFTRESET],
+ * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
  */
 union cvmx_uahcx_usbsts {
 	uint32_t u32;
@@ -6561,8 +6696,7 @@ union cvmx_uahcx_usbsts {
 	uint32_t reserved_5_7                 : 3;
 	uint32_t pcd                          : 1;  /**< Port-change detect. */
 	uint32_t eint                         : 1;  /**< Event interrupt. */
-	uint32_t hse                          : 1;  /**< Host-system error. The typical software response to an HSE is to reset the core.
-                                                         Throws UCTL_INTSN_E::USBH_UAHC_USBSTS_HSE. */
+	uint32_t hse                          : 1;  /**< Host-system error. The typical software response to an HSE is to reset the core. */
 	uint32_t reserved_1_1                 : 1;
 	uint32_t hch                          : 1;  /**< HC halted. */
 #else
diff --git a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
index 974322b..eb8109b 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -1222,7 +1222,7 @@ static inline uint64_t CVMX_USBDRDX_UCTL_SPARE1(unsigned long block_id)
 /**
  * cvmx_usbdrd#_uahc_caplength
  *
- * See XHCI specification v1.0 section 5.3.1.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.3.1.
  *
  */
 union cvmx_usbdrdx_uahc_caplength {
@@ -1239,52 +1239,56 @@ union cvmx_usbdrdx_uahc_caplength {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_caplength_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_caplength_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_caplength cvmx_usbdrdx_uahc_caplength_t;
 
 /**
  * cvmx_usbdrd#_uahc_config
  *
- * See XHCI specification v1.0 section 5.4.7.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.7.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_config {
 	uint32_t u32;
 	struct cvmx_usbdrdx_uahc_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_8_31                : 24;
-	uint32_t maxslotsen                   : 8;  /**< Maximum device slots enabled */
+	uint32_t maxslotsen                   : 8;  /**< Maximum device slots enabled. */
 #else
 	uint32_t maxslotsen                   : 8;
 	uint32_t reserved_8_31                : 24;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_config_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_config_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_config cvmx_usbdrdx_uahc_config_t;
 
 /**
  * cvmx_usbdrd#_uahc_crcr
  *
- * See XHCI specification v1.0 section 5.4.5.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.5.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_crcr {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uahc_crcr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cmd_ring_ptr                 : 58; /**< Command ring pointer bits<63:6>. */
+	uint64_t cmd_ring_ptr                 : 58; /**< Command ring pointer. */
 	uint64_t reserved_4_5                 : 2;
 	uint64_t crr                          : 1;  /**< Command ring running. */
 	uint64_t ca                           : 1;  /**< Command abort. */
 	uint64_t cs                           : 1;  /**< Command stop. */
-	uint64_t rcs                          : 1;  /**< Ring Cycle State */
+	uint64_t rcs                          : 1;  /**< Ring cycle state. */
 #else
 	uint64_t rcs                          : 1;
 	uint64_t cs                           : 1;
@@ -1295,6 +1299,7 @@ union cvmx_usbdrdx_uahc_crcr {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_crcr_s       cn70xx;
+	struct cvmx_usbdrdx_uahc_crcr_s       cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_crcr cvmx_usbdrdx_uahc_crcr_t;
 
@@ -1303,10 +1308,11 @@ typedef union cvmx_usbdrdx_uahc_crcr cvmx_usbdrdx_uahc_crcr_t;
  *
  * This register indicates whether a USB endpoint is active in a given configuration or
  * interface.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST] or
+ * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
+ * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
+ * USBDRD()_UAHC_DCTL[CSFTRST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.1.
  */
 union cvmx_usbdrdx_uahc_dalepena {
@@ -1336,18 +1342,21 @@ union cvmx_usbdrdx_uahc_dalepena {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dalepena_s   cn70xx;
+	struct cvmx_usbdrdx_uahc_dalepena_s   cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dalepena cvmx_usbdrdx_uahc_dalepena_t;
 
 /**
  * cvmx_usbdrd#_uahc_db#
  *
- * See XHCI specification v1.0 section 5.6.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
- * INTERNAL: XHCI spec, page 32: there are USBDRD(0..1)_UAHC_HCSPARAMS1[MAXSLOTS]+1 doorbell
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.6.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
+ *
+ * INTERNAL: xHCI spec, page 32: there are USBDRD()_UAHC_HCSPARAMS1[MAXSLOTS]+1 doorbell
  * registers.
  */
 union cvmx_usbdrdx_uahc_dbx {
@@ -1364,13 +1373,14 @@ union cvmx_usbdrdx_uahc_dbx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dbx_s        cn70xx;
+	struct cvmx_usbdrdx_uahc_dbx_s        cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dbx cvmx_usbdrdx_uahc_dbx_t;
 
 /**
  * cvmx_usbdrd#_uahc_dboff
  *
- * See XHCI specification v1.0 section 5.3.7.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.3.7.
  *
  */
 union cvmx_usbdrdx_uahc_dboff {
@@ -1385,23 +1395,25 @@ union cvmx_usbdrdx_uahc_dboff {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dboff_s      cn70xx;
+	struct cvmx_usbdrdx_uahc_dboff_s      cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dboff cvmx_usbdrdx_uahc_dboff_t;
 
 /**
  * cvmx_usbdrd#_uahc_dcbaap
  *
- * See XHCI specification v1.0 section 5.4.6.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.6.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_dcbaap {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uahc_dcbaap_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dcbaap                       : 58; /**< Device context base address array pointer bits<63:6>. */
+	uint64_t dcbaap                       : 58; /**< Device context base address array pointer. */
 	uint64_t reserved_0_5                 : 6;
 #else
 	uint64_t reserved_0_5                 : 6;
@@ -1409,6 +1421,7 @@ union cvmx_usbdrdx_uahc_dcbaap {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dcbaap_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_dcbaap_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dcbaap cvmx_usbdrdx_uahc_dcbaap_t;
 
@@ -1417,7 +1430,8 @@ typedef union cvmx_usbdrdx_uahc_dcbaap cvmx_usbdrdx_uahc_dcbaap_t;
  *
  * This register configures the core in Device mode after power-on or after certain control
  * commands or enumeration. Do not make changes to this register after initial programming.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.1.
  */
 union cvmx_usbdrdx_uahc_dcfg {
@@ -1440,22 +1454,22 @@ union cvmx_usbdrdx_uahc_dcfg {
                                                          purposes of stream selection and does not search for another stream when
                                                          it receives DP(PP=0) or ACK(NumP=0, PP=0). This can enhance the
                                                          performance when the device system bus bandwidth is low */
-	uint32_t lpmcap                       : 1;  /**< LPM Capable
+	uint32_t lpmcap                       : 1;  /**< LPM Capable.
                                                          The application uses this bit to control the controller's core LPM
                                                          capabilities. If the core operates as a non-LPM-capable device, it cannot
                                                          respond to LPM transactions.
                                                            0x0: LPM capability is not enabled.
                                                            0x1: LPM capability is enabled. */
-	uint32_t nump                         : 5;  /**< Number of Receive Buffers
+	uint32_t nump                         : 5;  /**< Number of Receive Buffers.
                                                          This bit indicates the number of receive buffers to be reported in the ACK
                                                          TP.
-                                                         The DWC_usb3 controller uses this field if USBDRD(0..1)_UAHC_GRXTHRCFG[USBRXPKTCNTSEL]
+                                                         The DWC_usb3 controller uses this field if USBDRD()_UAHC_GRXTHRCFG[USBRXPKTCNTSEL]
                                                          is set to 0x0. The application can program this value based on RxFIFO size,
                                                          buffer sizes programmed in descriptors, and system latency.
                                                          For an OUT endpoint, this field controls the number of receive buffers
                                                          reported in the NumP field of the ACK TP transmitted by the core.
                                                          INTERNAL: Note: This bit is used in host mode when Debug Capability is enabled. */
-	uint32_t intrnum                      : 5;  /**< Interrupt number
+	uint32_t intrnum                      : 5;  /**< Interrupt number.
                                                          Indicates interrupt/EventQ number on which non-endpoint-specific device-related
                                                          interrupts (see DEVT) are generated. */
 	uint32_t reserved_10_11               : 2;
@@ -1463,14 +1477,14 @@ union cvmx_usbdrdx_uahc_dcfg {
                                                          The application must perform the following
                                                           - Program this field after every SetAddress request.
                                                           - Reset this field to zero after USB reset. */
-	uint32_t devspd                       : 3;  /**< Device Speed
+	uint32_t devspd                       : 3;  /**< Device Speed.
                                                          Indicates the speed at which the application requires the core to connect, or
                                                          the maximum speed the application can support. However, the actual bus
                                                          speed is determined only after the chirp sequence is completed, and is
                                                          based on the speed of the USB host to which the core is connected.
-                                                           - 0x4: SuperSpeed (USB 3.0 PHY clock is 125 MHz or 250 MHz)
-                                                           - 0x0: High-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)
-                                                           - 0x1: Full-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz) */
+                                                           - 0x0: High-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz).
+                                                           - 0x1: Full-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz).
+                                                           - 0x4: SuperSpeed (USB 3.0 PHY clock is 125 MHz or 250 MHz). */
 #else
 	uint32_t devspd                       : 3;
 	uint32_t devaddr                      : 7;
@@ -1483,14 +1497,16 @@ union cvmx_usbdrdx_uahc_dcfg {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dcfg_s       cn70xx;
+	struct cvmx_usbdrdx_uahc_dcfg_s       cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dcfg cvmx_usbdrdx_uahc_dcfg_t;
 
 /**
  * cvmx_usbdrd#_uahc_dctl
  *
- * This register controls the
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register controls devlice mode.
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.2.
  */
 union cvmx_usbdrdx_uahc_dctl {
@@ -1501,7 +1517,7 @@ union cvmx_usbdrdx_uahc_dctl {
                                                          The software writes 1 to this bit to start the device controller operation.
                                                          To stop the device controller operation, the software must remove any active
                                                          transfers and write 0 to this bit. When the controller is stopped, it sets the
-                                                         USBDRD(0..1)_UAHC_DSTS[DEVCTRLHLT] bit when the core is idle and the lower layer finishes
+                                                         USBDRD()_UAHC_DSTS[DEVCTRLHLT] bit when the core is idle and the lower layer finishes
                                                          the disconnect process.
                                                          The Run/Stop bit must be used in following cases as specified:
                                                             1. After power-on reset and CSR initialization, the software must write 1 to this bit
@@ -1513,7 +1529,7 @@ union cvmx_usbdrdx_uahc_dctl {
                                                             until the software writes 1 to this bit. The minimum duration of keeping this bit
                                                             cleared is 30ms in SuperSpeed and 10ms in High/Full/LowSpeed.
                                                             If the software attempts a connect after the soft disconnect or detects a
-                                                            disconnect event, it must set USBDRD(0..1)_UAHC_DCTL[ULSTCHNGREQ] to
+                                                            disconnect event, it must set USBDRD()_UAHC_DCTL[ULSTCHNGREQ] to
                                                             "Rx.Detect" before reasserting the Run/Stop bit.
                                                             INTERNAL: 3. When the USB or Link is in a lower power state and the Two Power Rails
                                                             configuration is selected, software writes 0 to this bit to indicate that it is going
@@ -1553,11 +1569,11 @@ union cvmx_usbdrdx_uahc_dctl {
                                                            - HIRD_Thres[4] is set to 1'b0. */
 	uint32_t appl1res                     : 1;  /**< LPM Response Programmed by Application.
                                                          Handshake response to LPM token specified by device application. Response
-                                                         depends on USBDRD(0..1)_UAHC_DCFG[LPMCap].
-                                                          LPMCap is 0x0 - The core always responds with Timeout (that is, no
+                                                         depends on USBDRD()_UAHC_DCFG[LPMCAP].
+                                                          LPMCAP is 0x0 - The core always responds with Timeout (that is, no
                                                           response).
-                                                          LPMCap is 0x1 - The core response is based on the value of this bit:
-                                                            - 0x0: The core responds with an ACK upon a successful LPM transaction,
+                                                          LPMCAP is 0x1 and this bit is 0:
+                                                          The core responds with an ACK upon a successful LPM transaction,
                                                               which requires all of the following are satisfied
                                                               - There are no PID/CRC5 errors in both the EXT token and the LPM token
                                                               (if not true, inactivity results in a timeout ERROR)
@@ -1565,7 +1581,8 @@ union cvmx_usbdrdx_uahc_dctl {
                                                               STALL)
                                                               - No data is pending in the Transmit FIFO and OUT endpoints not in flow
                                                               controlled state (else NYET)
-                                                           - 0x1: The core responds with an ACK upon a successful LPM, independent
+                                                          LPMCAP is 0x1 and this bit is 1:
+                                                         The core responds with an ACK upon a successful LPM, independent
                                                              of transmit FIFO status and OUT endpoint flow control state. The LPM
                                                              transaction is successful if all of the following are satisfied.
                                                              - There are no PID/CRC5 errors in both the EXT token and the LPM token
@@ -1578,41 +1595,41 @@ union cvmx_usbdrdx_uahc_dctl {
 	uint32_t l1hibernationen              : 1;  /**< Always write 0.
                                                          INTERNAL: Writing this bit to 0x1 does nothing since we don't have hibernation feature. */
 	uint32_t crs                          : 1;  /**< Controller Restore State.
-                                                         This command is similar to the USBDRD(0..1)_UAHC_USBCMD[CRS] bit in host mode and
+                                                         This command is similar to the USBDRD()_UAHC_USBCMD[CRS] bit in host mode and
                                                          initiates the restore process. When software sets this bit to 1, the controller
-                                                         immediately sets USBDRD(0..1)_UAHC_DSTS[RSS] to 1. When the controller has finished
-                                                         the restore process, it sets USBDRD(0..1)_UAHC_DSTS[RSS] to 0.
+                                                         immediately sets USBDRD()_UAHC_DSTS[RSS] to 1. When the controller has finished
+                                                         the restore process, it sets USBDRD()_UAHC_DSTS[RSS] to 0.
                                                          Note: When read, this field always returns 0. */
 	uint32_t css                          : 1;  /**< Controller Save State.
-                                                         This command is similar to the USBDRD(0..1)_UAHC_USBCMD[CSS] bit in host mode and
+                                                         This command is similar to the USBDRD()_UAHC_USBCMD[CSS] bit in host mode and
                                                          initiates the restore process. When software sets this bit to 1, the controller
-                                                         immediately sets USBDRD(0..1)_UAHC_DSTS[SSS] to 1. When the controller has finished
-                                                         the save process, it sets USBDRD(0..1)_UAHC_DSTS[SSS] to 0.
+                                                         immediately sets USBDRD()_UAHC_DSTS[SSS] to 1. When the controller has finished
+                                                         the save process, it sets USBDRD()_UAHC_DSTS[SSS] to 0.
                                                          Note: When read, this field always returns 0. */
 	uint32_t reserved_13_15               : 3;
 	uint32_t initu2ena                    : 1;  /**< Initiate U2 Enable.
-                                                         - 0: May not initiate U2 (default)
-                                                         - 1: May initiate U2
+                                                          0 = May not initiate U2 (default).
+                                                          1 = May initiate U2.
                                                          On USB reset, hardware clears this bit to 0. Software sets this bit after receiving
                                                          SetFeature(U2_ENABLE), and clears this bit when ClearFeature(U2_ENABLE) is
                                                          received.
-                                                         If USBDRD(0..1)_UAHC_DCTL[ACCEPTU2ENA] is 0, the link immediately exits U2 state. */
+                                                         If USBDRD()_UAHC_DCTL[ACCEPTU2ENA] is 0, the link immediately exits U2 state. */
 	uint32_t acceptu2ena                  : 1;  /**< Accept U2 Enable.
-                                                         - 0: Reject U2 except when Force_LinkPM_Accept bit is set (default)
-                                                         - 1: Core accepts transition to U2 state if nothing is pending on the
+                                                          0 = Reject U2 except when Force_LinkPM_Accept bit is set (default).
+                                                          1 = Core accepts transition to U2 state if nothing is pending on the
                                                              application side.
                                                          On USB reset, hardware clears this bit to 0. Software sets this bit after receiving
                                                          a SetConfiguration command. */
 	uint32_t initu1ena                    : 1;  /**< Initiate U1 Enable.
-                                                         - 0: May not initiate U1 (default)
-                                                         - 1: May initiate U1
+                                                          0 = May not initiate U1 (default).
+                                                          1 = May initiate U1.
                                                          On USB reset, hardware clears this bit to 0. Software sets this bit after receiving
                                                          SetFeature(U1_ENABLE), and clears this bit when ClearFeature(U1_ENABLE) is
                                                          received.
-                                                         If USBDRD(0..1)_UAHC_DCTL[ACCEPTU1ENA] is 0, the link immediately exits U1 state. */
+                                                         If USBDRD()_UAHC_DCTL[ACCEPTU1ENA] is 0, the link immediately exits U1 state. */
 	uint32_t acceptu1ena                  : 1;  /**< Accept U1 Enable.
-                                                         - 0: Reject U1 except when Force_LinkPM_Accept bit is set (default)
-                                                         - 1: Core accepts transition to U1 state if nothing is pending on the
+                                                          0 = Reject U1 except when Force_LinkPM_Accept bit is set (default)
+                                                          1 = Core accepts transition to U1 state if nothing is pending on the
                                                              application side.
                                                          On USB reset, hardware clears this bit to 0. Software sets this bit after receiving
                                                          a SetConfiguration command. */
@@ -1620,40 +1637,38 @@ union cvmx_usbdrdx_uahc_dctl {
                                                          Software writes this field to issue a USB/Link state change request. A change in
                                                          this field indicates a new request to the core. If software wants to issue the same
                                                          request back-to-back, it must write a 0 to this field between the two requests. The
-                                                         result of the state change request is reflected in USBDRD(0..1)_UAHC_DSTS[USBLNKST].
+                                                         result of the state change request is reflected in USBDRD()_UAHC_DSTS[USBLNKST].
                                                          These bits are self-cleared on the MAC Layer exiting suspended state.
-                                                         If software is updating other fields of the USBDRD(0..1)_UAHC_DCTL register and not
+                                                         If software is updating other fields of the USBDRD()_UAHC_DCTL register and not
                                                          intending to force any link state change, then it must write a 0 to this field.
                                                          SuperSpeed Compliance mode is normally entered and controlled by the remote link
                                                          partner. Refer to the USB3 specification. Alternatively, you can force the local link
                                                          directly into Compliance mode, by resetting the SuperSpeed link with the
-                                                         USBDRD(0..1)_UAHC_DCTL[RS] bit set to zero. If you then write 0xA to the ULSTCHNGREQ
-                                                         field and 1 to USBDRD(0..1)_UAHC_DCTL[RS], the Link will go to Compliance. Once you
+                                                         USBDRD()_UAHC_DCTL[RS] bit set to zero. If you then write 0xA to the ULSTCHNGREQ
+                                                         field and 1 to USBDRD()_UAHC_DCTL[RS], the Link will go to Compliance. Once you
                                                          are in Compliance, you may alternately write 0x0 and 0xA to this field to advance
                                                          the compliance pattern.
                                                          In SS mode:
-                                                           Value    Requested Link State Transition/Action
-                                                             0x0     No Action
-                                                             0x4     SS.Disabled
-                                                             0x5     Rx.Detect
-                                                             0x6     SS.Inactive
-                                                             0x8     Recovery
-                                                             0xA     Compliance
-                                                             Others  Reserved
+                                                             0x0 = No Action.
+                                                             0x4 = SS.Disabled.
+                                                             0x5 = Rx.Detect.
+                                                             0x6 = SS.Inactive.
+                                                             0x8 = Recovery.
+                                                             0xA = Compliance.
+                                                             Others = Reserved.
                                                          In HS/FS/LS mode:
-                                                           Value    Requested USB state transition
-                                                             0x8     Remote wakeup request
-                                                             Others  Reserved
+                                                             0x8 = Remote wakeup request.
                                                              The Remote wakeup request should be issued 2us after the device goes into
-                                                             suspend state (USBDRD(0..1)_UAHC_DSTS[USBLNKST] is 0x3). */
+                                                             suspend state (USBDRD()_UAHC_DSTS[USBLNKST] is 0x3).
+                                                             Others = Reserved. */
 	uint32_t tstctl                       : 4;  /**< Test Control.
-                                                         0x0    Test mode disabled
-                                                         0x1    Test_J mode
-                                                         0x2    Test_K mode
-                                                         0x3    Test_SE0_NAK mode
-                                                         0x4    Test_Packet mode
-                                                         0x5    Test_Force_Enable
-                                                         Others Reserved */
+                                                         0x0 = Test mode disabled.
+                                                         0x1 = Test_J mode.
+                                                         0x2 = Test_K mode.
+                                                         0x3 = Test_SE0_NAK mode.
+                                                         0x4 = Test_Packet mode.
+                                                         0x5 = Test_Force_Enable.
+                                                         Others = Reserved. */
 	uint32_t reserved_0_0                 : 1;
 #else
 	uint32_t reserved_0_0                 : 1;
@@ -1677,6 +1692,7 @@ union cvmx_usbdrdx_uahc_dctl {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dctl_s       cn70xx;
+	struct cvmx_usbdrdx_uahc_dctl_s       cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dctl cvmx_usbdrdx_uahc_dctl_t;
 
@@ -1685,16 +1701,18 @@ typedef union cvmx_usbdrdx_uahc_dctl cvmx_usbdrdx_uahc_dctl_t;
  *
  * This register enables software to issue physical endpoint-specific commands. This register
  * contains command, control, and status fields relevant to the current generic command,
- * while the USBDRD(0..1)_UAHC_DEPCMDPAR* registers provide command parameters and return
+ * while the USBDRD()_UAHC_DEPCMDPAR* registers provide command parameters and return
  * status information.
+ *
  * Several fields (including CMDTYPE) are write-only, so their read values are undefined. After
  * power-on, prior to issuing the first endpoint command, the read value of this register is
  * undefined. In particular, the CMDACT bit may be set after power-on. In this case, it is safe
  * to issue an endpoint command.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST] or
+ * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
+ * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
+ * USBDRD()_UAHC_DCTL[CSFTRST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.5.
  */
 union cvmx_usbdrdx_uahc_depcmdx {
@@ -1705,90 +1723,88 @@ union cvmx_usbdrdx_uahc_depcmdx {
                                                          When this register is written:
                                                            Command Parameters:
                                                              For Start Transfer command:
-                                                               - [31:16]: StreamID. The USB StreamID assigned to this transfer
+                                                             _  - [31:16]: StreamID. The USB StreamID assigned to this transfer
                                                              For Start Transfer command applied to an isochronous endpoint:
-                                                               - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to
+                                                             _  - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to
                                                                which the first TRB applies
                                                              For Update Transfer, End Transfer, and Start New Configuration
                                                              commands:
-                                                               - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned
+                                                             _  - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned
                                                                transfer resource index for the transfer, which was returned
                                                                in response to the Start Transfer command. The application
                                                                software-assigned transfer resource index for a Start New
                                                                Configuration command.
                                                          When this register is read:
-                                                           Event Parameters:
                                                              For XferNotReady, XferComplete, and Stream events on Bulk Endpoints:
-                                                               - [31:16]: StreamID. Applies only to bulk endpoints that support streams. This
+                                                             _  - [31:16]: StreamID. Applies only to bulk endpoints that support streams. This
                                                                           indicates the StreamID of the transfer for which the event is
                                                                           generated
                                                              For XferInProgress:
-                                                               - [31:16]: Isochronous Microframe Number (IsocMicroFrameNum): Indicates the
+                                                             _  - [31:16]: Isochronous Microframe Number (IsocMicroFrameNum): Indicates the
                                                                           microframe number of the beginning of the interval that generated
                                                                           the XferInProgress event (debug purposes only)
                                                              For XferNotReady events on Isochronous Endpoints:
-                                                               - [31:16]: Isochronous Microframe Number (IsocMicroFrameNum). Indicates the
+                                                             _  - [31:16]: Isochronous Microframe Number (IsocMicroFrameNum). Indicates the
                                                                           microframe number during which the endpoint was not ready
                                                                Note: controller core represents USB bus time as a 14-bit value on the bus and also
-                                                               in the DSTS register (USBDRD(0..1)_UAHC_DSTS[SOFFN]), but as a 16-bit value in the
+                                                               in the DSTS register (USBDRD()_UAHC_DSTS[SOFFN]), but as a 16-bit value in the
                                                                XferNotReady event. Use the 16-bit value to interact with Isochronous endpoints via
                                                                the StartXfer command. The extra two bits that the controller core produces will be
                                                                necessary for handling wrap-around conditions in the interaction between software
                                                                and hardware.
-                                                             EPCmdCmplt events
-                                                               For all EPCmdCmplt events
-                                                                 - [27:24]: Command Type. The command type that completed (Valid only in a DEPEVT
+                                                            For all EPCmdCmplt events
+                                                            _  - [27:24]: Command Type. The command type that completed (Valid only in a DEPEVT
                                                                             event. Undefined when read from the
-                                                                            USBDRD(0..1)_UAHC_DEPCMD(0..15)[COMMANDPARAM] field).
-                                                               For EPCmdCmplt event in response to Start Transfer command:
-                                                                 - [22:16]: Transfer Resource Index (XferRscIdx). The internal hardware transfer
+                                                                            USBDRD()_UAHC_DEPCMD()[COMMANDPARAM] field).
+                                                            For EPCmdCmplt event in response to Start Transfer command:
+                                                            _  - [22:16]: Transfer Resource Index (XferRscIdx). The internal hardware transfer
                                                                             resource index assigned to this transfer. This index must be used in
                                                                             all Update Transfer and End Transfer commands. */
 	uint32_t cmdstatus                    : 4;  /**< Command Completion Status.
                                                          Additional information about the completion of this command is available in
                                                          this field.
                                                          Within an XferNotReady event:
-                                                           [15]: Indicates the reason why the XferNotReady event is generated:
-                                                             - 0: XferNotActive: Host initiated a transfer, but the requested transfer is not
-                                                               present in the hardware
-                                                             - 1: XferActive: Host initiated a transfer, the transfer is present, but no valid TRBs
+                                                         _ [15]: Indicates the reason why the XferNotReady event is generated:
+                                                         _ [15] = 0: XferNotActive: Host initiated a transfer, but the requested transfer is not
+                                                               present in the hardware.
+                                                         _ [15] = 1: XferActive: Host initiated a transfer, the transfer is present, but no valid
+                                                         TRBs
                                                                are available
-                                                           [14]: Not Used
-                                                           [13:12]: For control endpoints, indicates what stage was requested when the transfer was
+                                                         _ [14]: Not Used
+                                                         _ [13:12]: For control endpoints, indicates what stage was requested when the transfer was
                                                            not ready:
-                                                             - 0x1: Control Data Request
-                                                             - 0x2: Control Status Request
+                                                         _ [13:12] = 0x1: Control Data Request
+                                                         _ [13:12] = 0x2: Control Status Request
                                                          Within an XferComplete or XferInProgress event:
-                                                           [15]: LST bit of the completed TRB (XferComplete only)
-                                                           [15]: MissedIsoc: Indicates the interval did not complete successfully (XferInProgress
+                                                         _ [15]: LST bit of the completed TRB (XferComplete only)
+                                                         _ [15]: MissedIsoc: Indicates the interval did not complete successfully (XferInProgress
                                                            only)
-                                                           [14]: IOC bit of the TRB that completed
-                                                           [13]: Indicates the TRB completed with a short packet reception or the last packet of an
+                                                         _ [14]: IOC bit of the TRB that completed.
+                                                         _ [13]: Indicates the TRB completed with a short packet reception or the last packet of an
                                                            isochronous interval
-                                                           [12]: Reserved
+                                                         _ [12]: Reserved.
                                                            If the host aborts the data stage of a control transfer, software may receive a
                                                            XferComplete event with the EventStatus field equal to 0. This is a valid event
                                                            that must be processed as a part of the Control Transfer Programming Model.
                                                          Within a Stream Event:
-                                                           [15:12]:
-                                                             - 0x2: StreamNotFound: This stream event is issued when the stream-capable endpoint
+                                                         _ [15:12] = 0x2: StreamNotFound: This stream event is issued when the stream-capable
+                                                         endpoint
                                                                performed a search in its transfer resource cache, but could not find an active
                                                                and ready stream.
-                                                             - 0x1: StreamFound: This stream event is issued when the stream-capable endpoint found
+                                                         _ [15:12] = 0x1: StreamFound: This stream event is issued when the stream-capable endpoint
+                                                         found
                                                                an active and ready stream in its transfer resource cache, and initiated traffic for
                                                                that stream to the host. The ID of the selected Stream is in the EventParam field.
                                                          In response to a Start Transfer command:
-                                                           [15:12]:
-                                                             - 0x2: Indicates expiry of the bus time reflected in the Start Transfer command.
-                                                             - 0x1: Indicates there is no transfer resource available on the endpoint.
+                                                         _ [15:12] = 0x2: Indicates expiry of the bus time reflected in the Start Transfer command.
+                                                         _ [15:12] = 0x1: Indicates there is no transfer resource available on the endpoint.
                                                          In response to a Set Transfer Resource (DEPXFERCFG) command:
-                                                           [15:12]:
-                                                             - 0x1: Indicates an error has occurred because software is requesting more transfer
+                                                         _ [15:12] = 0x1: Indicates an error has occurred because software is requesting more
+                                                         transfer
                                                                resources to be assigned than have been configured in the hardware.
                                                          In response to a End Transfer command:
-                                                           [15:12]:
-                                                             - 0x1: Indicates an invalid transfer resource was specified.
-                                                           INTERNAL: For abort handling, see also Synopsys DWC_usb3 Databook v2.50a, Section 8.4. */
+                                                         _ [15:12] = 0x1: Indicates an invalid transfer resource was specified.
+                                                         INTERNAL: For abort handling, see also Synopsys DWC_usb3 Databook v2.50a, Section 8.4. */
 	uint32_t hipri_forcerm                : 1;  /**< HighPriority: Only valid for Start Transfer command.
                                                          ForceRM: Only valid for End Transfer command. */
 	uint32_t cmdact                       : 1;  /**< Software sets this bit to 1 to enable the device endpoint controller to
@@ -1802,22 +1818,22 @@ union cvmx_usbdrdx_uahc_depcmdx {
                                                          Command Complete event after executing the command. Note that this
                                                          interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is
                                                          executed, the command interrupt on completion goes to the interrupt
-                                                         pointed by the USBDRD(0..1)_UAHC_DCFG[INTRNUM] in the current command.
-                                                         Note: This field must not set to 1 if the USBDRD(0..1)_UAHC_DCTL[RS] field is 0. */
+                                                         pointed by the USBDRD()_UAHC_DCFG[INTRNUM] in the current command.
+                                                         Note: This field must not set to 1 if the USBDRD()_UAHC_DCTL[RS] field is 0. */
 	uint32_t reserved_4_7                 : 4;
 	uint32_t cmdtyp                       : 4;  /**< Command Type.
                                                          Specifies the type of command the software driver is requesting the core to
                                                          perform.
-                                                         0x0: Reserved
-                                                         0x1: Set Endpoint Configuration (64 or 96-bit Parameter)
-                                                         0x2: Set Endpoint Transfer Resource Configuration (32-bit Parameter)
-                                                         0x3: Get Endpoint State (No Parameter Needed)
-                                                         0x4: Set Stall (No Parameter Needed)
-                                                         0x5: Clear Stall (see Set Stall, No Parameter Needed)
-                                                         0x6: Start Transfer (64-bit Parameter)
-                                                         0x7: Update Transfer (No Parameter Needed)
-                                                         0x8: End Transfer (No Parameter Needed)
-                                                         0x9: Start New Configuration (No Parameter Needed) */
+                                                         0x0 = Reserved.
+                                                         0x1 = Set Endpoint Configuration (64 or 96-bit Parameter).
+                                                         0x2 = Set Endpoint Transfer Resource Configuration (32-bit Parameter).
+                                                         0x3 = Get Endpoint State (No Parameter Needed).
+                                                         0x4 = Set Stall (No Parameter Needed).
+                                                         0x5 = Clear Stall (see Set Stall, No Parameter Needed).
+                                                         0x6 = Start Transfer (64-bit Parameter).
+                                                         0x7 = Update Transfer (No Parameter Needed).
+                                                         0x8 = End Transfer (No Parameter Needed).
+                                                         0x9 = Start New Configuration (No Parameter Needed). */
 #else
 	uint32_t cmdtyp                       : 4;
 	uint32_t reserved_4_7                 : 4;
@@ -1830,6 +1846,7 @@ union cvmx_usbdrdx_uahc_depcmdx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdx_s    cn70xx;
+	struct cvmx_usbdrdx_uahc_depcmdx_s    cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdx cvmx_usbdrdx_uahc_depcmdx_t;
 
@@ -1838,10 +1855,11 @@ typedef union cvmx_usbdrdx_uahc_depcmdx cvmx_usbdrdx_uahc_depcmdx_t;
  *
  * This register indicates the physical endpoint command Parameter 0. It must be programmed
  * before issuing the command.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST] or
+ * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
+ * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
+ * USBDRD()_UAHC_DCTL[CSFTRST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.4.
  */
 union cvmx_usbdrdx_uahc_depcmdpar0_x {
@@ -1854,6 +1872,7 @@ union cvmx_usbdrdx_uahc_depcmdpar0_x {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn70xx;
+	struct cvmx_usbdrdx_uahc_depcmdpar0_x_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar0_x cvmx_usbdrdx_uahc_depcmdpar0_x_t;
 
@@ -1862,10 +1881,11 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar0_x cvmx_usbdrdx_uahc_depcmdpar0_x_t;
  *
  * This register indicates the physical endpoint command Parameter 1. It must be programmed
  * before issuing the command.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST] or
+ * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
+ * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
+ * USBDRD()_UAHC_DCTL[CSFTRST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.3.
  */
 union cvmx_usbdrdx_uahc_depcmdpar1_x {
@@ -1878,6 +1898,7 @@ union cvmx_usbdrdx_uahc_depcmdpar1_x {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn70xx;
+	struct cvmx_usbdrdx_uahc_depcmdpar1_x_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar1_x cvmx_usbdrdx_uahc_depcmdpar1_x_t;
 
@@ -1886,10 +1907,11 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar1_x cvmx_usbdrdx_uahc_depcmdpar1_x_t;
  *
  * This register indicates the physical endpoint command Parameter 2. It must be programmed
  * before issuing the command.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST] or
+ * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
+ * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
+ * USBDRD()_UAHC_DCTL[CSFTRST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.2.
  */
 union cvmx_usbdrdx_uahc_depcmdpar2_x {
@@ -1902,6 +1924,7 @@ union cvmx_usbdrdx_uahc_depcmdpar2_x {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn70xx;
+	struct cvmx_usbdrdx_uahc_depcmdpar2_x_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_depcmdpar2_x cvmx_usbdrdx_uahc_depcmdpar2_x_t;
 
@@ -1910,7 +1933,8 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar2_x cvmx_usbdrdx_uahc_depcmdpar2_x_t;
  *
  * This register controls the generation of Device-Specific events.
  * If an enable bit is set to 0, the event will not be generated.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.2.
  */
 union cvmx_usbdrdx_uahc_devten {
@@ -1949,6 +1973,7 @@ union cvmx_usbdrdx_uahc_devten {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_devten_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_devten_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_devten cvmx_usbdrdx_uahc_devten_t;
 
@@ -1957,12 +1982,13 @@ typedef union cvmx_usbdrdx_uahc_devten cvmx_usbdrdx_uahc_devten_t;
  *
  * This register enables software to program the core using a single generic command interface to
  * send link management packets and notifications. This register contains command, control, and
- * status fields relevant to the current generic command, while the USBDRD(0..1)_UAHC_DGCMDPAR
+ * status fields relevant to the current generic command, while the USBDRD()_UAHC_DGCMDPAR
  * register provides the command parameter.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST] or
+ * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
+ * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
+ * USBDRD()_UAHC_DCTL[CSFTRST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.5.
  */
 union cvmx_usbdrdx_uahc_dgcmd {
@@ -1983,8 +2009,8 @@ union cvmx_usbdrdx_uahc_dgcmd {
 	uint32_t cmdioc                       : 1;  /**< Command Interrupt on Complete.
                                                          When this bit is set, the device controller issues a Generic Command
                                                          Completion event after executing the command. Note that this interrupt is
-                                                         mapped to USBDRD(0..1)_UAHC_DCFG[INTRNUM].
-                                                         Note: This field must not set to 1 if the USBDRD(0..1)_UAHC_DCTL[RS] field is 0. */
+                                                         mapped to USBDRD()_UAHC_DCFG[INTRNUM].
+                                                         Note: This field must not set to 1 if the USBDRD()_UAHC_DCTL[RS] field is 0. */
 	uint32_t cmdtyp                       : 8;  /**< Specifies the type of command the software driver is requesting the core to
                                                          perform. See USBDRD_UAHC_DGCMD_CMDTYPE_E for encodings and usage. */
 #else
@@ -1998,6 +2024,7 @@ union cvmx_usbdrdx_uahc_dgcmd {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dgcmd_s      cn70xx;
+	struct cvmx_usbdrdx_uahc_dgcmd_s      cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dgcmd cvmx_usbdrdx_uahc_dgcmd_t;
 
@@ -2005,11 +2032,13 @@ typedef union cvmx_usbdrdx_uahc_dgcmd cvmx_usbdrdx_uahc_dgcmd_t;
  * cvmx_usbdrd#_uahc_dgcmdpar
  *
  * This register indicates the device command parameter.
- * This must be programmed before or along with USBDRD(0..1)_UAHC_DGCMD.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * This must be programmed before or along with USBDRD()_UAHC_DGCMD.
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST] or
+ * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
+ * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
+ * USBDRD()_UAHC_DCTL[CSFTRST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.4.
  */
 union cvmx_usbdrdx_uahc_dgcmdpar {
@@ -2017,24 +2046,26 @@ union cvmx_usbdrdx_uahc_dgcmdpar {
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t param                        : 32; /**< Device Generic Command Parameter.
-                                                         Usage depends on which USBDRD(0..1)_UAHC_DGCMD[CMDTYPE] is used,
+                                                         Usage depends on which USBDRD()_UAHC_DGCMD[CMDTYPE] is used,
                                                          see usage notes in USBDRD_UAHC_DGCMD_CMDTYPE_E descriptions. */
 #else
 	uint32_t param                        : 32;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn70xx;
+	struct cvmx_usbdrdx_uahc_dgcmdpar_s   cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dgcmdpar cvmx_usbdrdx_uahc_dgcmdpar_t;
 
 /**
  * cvmx_usbdrd#_uahc_dnctrl
  *
- * See XHCI specification v1.0 section 5.4.4.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.4.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_dnctrl {
 	uint32_t u32;
@@ -2048,6 +2079,7 @@ union cvmx_usbdrdx_uahc_dnctrl {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dnctrl_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_dnctrl_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dnctrl cvmx_usbdrdx_uahc_dnctrl_t;
 
@@ -2056,7 +2088,8 @@ typedef union cvmx_usbdrdx_uahc_dnctrl cvmx_usbdrdx_uahc_dnctrl_t;
  *
  * This register indicates the status of the device controller with respect to USB-related
  * events.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ *
+ * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.3.
  */
 union cvmx_usbdrdx_uahc_dsts {
@@ -2067,17 +2100,17 @@ union cvmx_usbdrdx_uahc_dsts {
 	uint32_t dcnrd                        : 1;  /**< Device Controller Not Ready.
                                                          Will always read-as-zero.
                                                          INTERNAL: Bit is only used with hibernation. */
-	uint32_t sre                          : 1;  /**< Save/Restore Error
+	uint32_t sre                          : 1;  /**< Save/Restore Error.
                                                          This bit is currently not supported. */
 	uint32_t reserved_26_27               : 2;
 	uint32_t rss                          : 1;  /**< Restore State Status.
-                                                         This bit is similar to the USBDRD(0..1)_USBSTS[RSS] in host mode.
+                                                         This bit is similar to the USBDRD()_USBSTS[RSS] in host mode.
                                                          When the controller has finished the restore process, it will complete the
                                                          command by setting RSS to 0.
                                                          Will always read-as-zero.
                                                          INTERNAL: Bit is only used with hibernation. */
 	uint32_t sss                          : 1;  /**< Save State Status.
-                                                         This bit is similar to the USBDRD(0..1)_UAHC_USBSTS[SSS] in host mode.
+                                                         This bit is similar to the USBDRD()_UAHC_USBSTS[SSS] in host mode.
                                                          When the controller has finished the save process, it will complete the
                                                          command by setting SSS to 0.
                                                          Will always read-as-zero.
@@ -2090,53 +2123,53 @@ union cvmx_usbdrdx_uahc_dsts {
                                                          represents the changing state of the core and does not hold a static value. */
 	uint32_t devctrlhlt                   : 1;  /**< Device Controller Halted.
                                                          When 1, the core does not generate Device events.
-                                                         - This bit is set to 0 when the USBDRD(0..1)_UAHC_DCTL[RS] register is set to 1.
-                                                         - The core sets this bit to 1 when, after software sets USBDRD(0..1)_UAHC_DCTL[RS] to 0,
+                                                         - This bit is set to 0 when the USBDRD()_UAHC_DCTL[RS] register is set to 1.
+                                                         - The core sets this bit to 1 when, after software sets USBDRD()_UAHC_DCTL[RS] to 0,
                                                          the core is
                                                            idle and the lower layer finishes the disconnect process. */
 	uint32_t usblnkst                     : 4;  /**< USB/Link State.
                                                          In SuperSpeed mode, uses LTSSM State:
-                                                            - 0x0: U0
-                                                            - 0x1: U1
-                                                            - 0x2: U2
-                                                            - 0x3: U3
-                                                            - 0x4: SS_DIS
-                                                            - 0x5: RX_DET
-                                                            - 0x6: SS_INACT
-                                                            - 0x7: POLL
-                                                            - 0x8: RECOV
-                                                            - 0x9: HRESET
-                                                            - 0xa: CMPLY
-                                                            - 0xb: LPBK
-                                                            - 0xf: Resume/Reset
-                                                            - others: Reserved.
+                                                            0x0: U0.
+                                                            0x1: U1.
+                                                            0x2: U2.
+                                                            0x3: U3.
+                                                            0x4: SS_DIS.
+                                                            0x5: RX_DET.
+                                                            0x6: SS_INACT.
+                                                            0x7: POLL.
+                                                            0x8: RECOV.
+                                                            0x9: HRESET.
+                                                            0xa: CMPLY.
+                                                            0xb: LPBK.
+                                                            0xf: Resume/Reset.
+                                                            others: Reserved.
                                                          In High/Full/LowSpeed mode:
-                                                            - 0x0: On state
-                                                            - 0x2: Sleep (L1) state
-                                                            - 0x3: Suspend (L2) state
-                                                            - 0x4: Disconnected state (Default state)
-                                                            - 0x5: Early Suspend state
-                                                            - others: Reserved.
+                                                            0x0: On state.
+                                                            0x2: Sleep (L1) state.
+                                                            0x3: Suspend (L2) state.
+                                                            0x4: Disconnected state (Default state).
+                                                            0x5: Early Suspend state.
+                                                            others: Reserved.
                                                          The link state Resume/Reset indicates that the core received a resume or
                                                          USB reset request from the host while the link was in hibernation. Software
-                                                         must write '8' (Recovery) to the USBDRD(0..1)_UAHC_DCTL[ULSTCHNGREQ] field to acknowledge
+                                                         must write '8' (Recovery) to the USBDRD()_UAHC_DCTL[ULSTCHNGREQ] field to acknowledge
                                                          the resume/reset request. */
 	uint32_t rxfifoempty                  : 1;  /**< RxFIFO Empty Indication. */
 	uint32_t soffn                        : 14; /**< Frame/MicroFrame Number of the Received SOF.
                                                          When the core is operating at high-speed,
-                                                         - [16:6] indicates the frame number
-                                                         - [5:3] indicates the microframe number
+                                                         - [16:6] indicates the frame number.
+                                                         - [5:3] indicates the microframe number.
                                                          When the core is operating at full-speed,
                                                          - [16:14] is not used, software can ignore these 3 bits.
-                                                         - [13:3] indicates the frame number */
+                                                         - [13:3] indicates the frame number. */
 	uint32_t connectspd                   : 3;  /**< Connected Speed.
                                                          Indicates the speed at which the controller core has come up after speed
                                                          detection through a chirp sequence.
-                                                          0x4: SuperSpeed (PHY clock is running at 125 or 250 MHz)
-                                                          0x0: High-speed (PHY clock is running at 60 MHz)
-                                                          0x1: Full-speed (PHY clock is running at 60 MHz)
-                                                          0x2: Low-speed  (not supported)
-                                                          0x3: Full-speed (PHY clock is running at 48 MHz) */
+                                                          0x0 = High-speed (PHY clock is running at 60 MHz).
+                                                          0x1 = Full-speed (PHY clock is running at 60 MHz).
+                                                          0x2 = Low-speed  (not supported).
+                                                          0x3 = Full-speed (PHY clock is running at 48 MHz).
+                                                          0x4 = SuperSpeed (PHY clock is running at 125 or 250 MHz). */
 #else
 	uint32_t connectspd                   : 3;
 	uint32_t soffn                        : 14;
@@ -2153,23 +2186,25 @@ union cvmx_usbdrdx_uahc_dsts {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_dsts_s       cn70xx;
+	struct cvmx_usbdrdx_uahc_dsts_s       cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_dsts cvmx_usbdrdx_uahc_dsts_t;
 
 /**
  * cvmx_usbdrd#_uahc_erdp#
  *
- * See XHCI specification v1.0 section 5.5.2.3.3.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.3.3.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_erdpx {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uahc_erdpx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t erdp                         : 60; /**< Event ring dequeue pointer bits<63:4>. */
+	uint64_t erdp                         : 60; /**< Event ring dequeue pointer bits <63:4>. */
 	uint64_t ehb                          : 1;  /**< Event handler busy */
 	uint64_t desi                         : 3;  /**< Dequeue ERST segment index. */
 #else
@@ -2179,17 +2214,19 @@ union cvmx_usbdrdx_uahc_erdpx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_erdpx_s      cn70xx;
+	struct cvmx_usbdrdx_uahc_erdpx_s      cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_erdpx cvmx_usbdrdx_uahc_erdpx_t;
 
 /**
  * cvmx_usbdrd#_uahc_erstba#
  *
- * See XHCI specification v1.0 section 5.5.2.3.2.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.3.2.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_erstbax {
 	uint64_t u64;
@@ -2203,17 +2240,19 @@ union cvmx_usbdrdx_uahc_erstbax {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_erstbax_s    cn70xx;
+	struct cvmx_usbdrdx_uahc_erstbax_s    cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_erstbax cvmx_usbdrdx_uahc_erstbax_t;
 
 /**
  * cvmx_usbdrd#_uahc_erstsz#
  *
- * See XHCI specification v1.0 section 5.5.2.3.1.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.3.1.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_erstszx {
 	uint32_t u32;
@@ -2227,47 +2266,54 @@ union cvmx_usbdrdx_uahc_erstszx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_erstszx_s    cn70xx;
+	struct cvmx_usbdrdx_uahc_erstszx_s    cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
 
 /**
  * cvmx_usbdrd#_uahc_gbuserraddr
  *
- * When the AXI Master Bus returns "Error" response, the "SoC Bus Error" is generated. In the
- * Host mode, the host_system_err port indicates this condition. In addition, it is also
- * indicated in the USBSTS.HSE field.
- * Due to the nature of AXI, it is possible that multiple AXI transactions are active at a time.
- * The Host Controller does not keep track of the start address of all outstanding
- * transactions. Instead, it keeps track of the start address of the DMA transfer associated
- * with all active transactions. It is this address that is reported in the GBUSERRADDR when
- * a bus error occurs.
- * For example, if the Host Controller initiates a DMA transfer to write 1k of packet data
- * starting at buffer address 0xABCD0000, and this DMA is broken up into multiple 256B bursts
- * on the AXI, then if a bus error occurs on any of these associated AXI transfers, the
- * GBUSERRADDR reflects the DMA start address of 0xABCD0000 regardless of which AXI transaction
- * received the error.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * When the AXI Master Bus returns Error response, the SoC Bus Error is generated. In the host
+ * mode, the host_system_err port indicates this condition. In addition, it is also indicated in
+ * USBDRD()_UAHC_USBSTS[HSE]. Due to the nature of AXI, it is possible that multiple AXI
+ * transactions
+ * are active at a time. The host controller does not keep track of the start address of all
+ * outstanding transactions. Instead, it keeps track of the start address of the DMA transfer
+ * associated with all active transactions. It is this address that is reported in
+ * USBDRD()_UAHC_GBUSERRADDR when a bus error occurs. For example, if the host controller
+ * initiates
+ * a DMA
+ * transfer to write 1k of packet data starting at buffer address 0xABCD0000, and this DMA is
+ * broken up into multiple 256B bursts on the AXI, then if a bus error occurs on any of these
+ * associated AXI transfers, USBDRD()_UAHC_GBUSERRADDR reflects the DMA start address of
+ * 0xABCD0000
+ * regardless of which AXI transaction received the error.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.12.
  */
 union cvmx_usbdrdx_uahc_gbuserraddr {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t busaddr                      : 64; /**< Bus address bits<63:0>. Contains the lower 32 bits of the first bus address that
-                                                         encountered an SoC bus error. It is valid when USBDRD(0..1)_UAHC_GSTS[BUSERRADDRVLD] = 1.
-                                                         It can only be cleared by resetting the core. */
+	uint64_t busaddr                      : 64; /**< Bus address. Contains the first bus address that encountered an SoC bus error. It is valid
+                                                         when the USBDRD()_UAHC_GSTS[BUSERRADDRVLD] = 1. It can only be cleared by resetting the
+                                                         core. */
 #else
 	uint64_t busaddr                      : 64;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gbuserraddr_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gbuserraddr cvmx_usbdrdx_uahc_gbuserraddr_t;
 
 /**
  * cvmx_usbdrd#_uahc_gctl
  *
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.5.
  */
 union cvmx_usbdrdx_uahc_gctl {
@@ -2284,25 +2330,21 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          The minimum suspend-clock frequency is 32 KHz, and maximum suspend-clock frequency is 125
                                                          MHz.
                                                          The LTSSM uses Suspend clock for 12-ms and 100-ms timers during suspend mode. According to
-                                                         the USB 3.0 specification, the accuracy on these timers is 0% to +50%.
-                                                         12 ms + 0~+50% accuracy = 18 ms  (Range is  12 ms  - 18 ms)
+                                                         the USB 3.0 specification, the accuracy on these timers is 0% to +50%. 12 ms + 0~+50%
+                                                         accuracy = 18 ms (Range is 12 ms - 18 ms)
                                                          100 ms + 0~+50% accuracy = 150 ms (Range is 100 ms - 150 ms).
                                                          The suspend clock accuracy requirement is:
-                                                         ( 12,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period should be between 12,000 and
+                                                         _ (12,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period should be between 12,000 and
                                                          18,000
-                                                         (100,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period should be between 100,000 and
+                                                         _ (100,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period should be between 100,000 and
                                                          150,000
                                                          For example, if your suspend_clk frequency varies from 7.5 MHz to 10.5MHz, then the value
                                                          needs to programmed is: Power Down Scale = 10500/16 = 657 (rounded up; and fastest
-                                                         frequency used) */
-	uint32_t masterfiltbypass             : 1;  /**< Master Filter Bypass
-                                                         When this bit is set to 1, all the filters in the
-                                                         controller's filter module will be bypassed. The double
-                                                         synchronizers to mac_clk preceding the filters will also be
-                                                         bypassed. For enabling the filters, this bit should be 0. */
+                                                         frequency used). */
+	uint32_t masterfiltbypass             : 1;  /**< Master filter bypass. Not relevant for Cavium's configuration. */
 	uint32_t bypssetaddr                  : 1;  /**< Bypass SetAddress in Device Mode
                                                          Always set to 0.
-                                                         INTERNAL: When set, core uses the value in USBDRD(0..1)_UAHC_DCFG[DEVADDR] directly
+                                                         INTERNAL: When set, core uses the value in USBDRD()_UAHC_DCFG[DEVADDR] directly
                                                          for comparing the device address tokens. In simulation, this can be used to avoid
                                                          sending a SET_ADDRESS command. */
 	uint32_t u2rstecn                     : 1;  /**< If the SuperSpeed commenction fails during POLL or LMP exchange, the device connects
@@ -2310,96 +2352,92 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          connect at SuperSpeed, even if it previously failed to operate in SuperSpeed mode.
                                                          This bit is only applicable in device mode. */
 	uint32_t frmscldwn                    : 2;  /**< Frame scale down. Scales down device view of a SOF/USOF/ITP duration.
-                                                         For SuperSpeed/HighSpeed mode:
-                                                         0x3 = interval is 15.625 us
-                                                         0x2 = interval is 31.25 us
-                                                         0x1 = interval is 62.5 us
-                                                         0x0 = interval is 125 us
-                                                         For FullSpeed mode, the scale-down value is multiplied by 8. */
-	uint32_t prtcapdir                    : 2;  /**< 2'b01: for Host configurations
-                                                         2'b10: for Device configurations */
+                                                         For SuperSpeed/high-speed mode:
+                                                         0x0 = Interval is 125 us.
+                                                         0x1 = Interval is 62.5 us.
+                                                         0x2 = Interval is 31.25 us.
+                                                         0x3 = Interval is 15.625 us.
+                                                         For full-speed mode, the scale-down value is multiplied by 8. */
+	uint32_t prtcapdir                    : 2;  /**< 0x1: for Host configurations.
+                                                         0x2: for Device configurations. */
 	uint32_t coresoftreset                : 1;  /**< Core soft reset: 1 = soft reset to core, 0 = no soft reset.
-                                                         Clears the interrupts and all the USBDRD(0..1)_UAHC_* CSRs except the
-                                                         following registers: USBDRD(0..1)_UAHC_GCTL, USBDRD(0..1)_UAHC_GUCTL,
-                                                         USBDRD(0..1)_UAHC_GSTS,
-                                                         USBDRD(0..1)_UAHC_GRLSID, USBDRD(0..1)_UAHC_GGPIO, USBDRD(0..1)_UAHC_GUID,
-                                                         USBDRD(0..1)_UAHC_GUSB2PHYCFG[*],
-                                                         USBDRD(0..1)_UAHC_GUSB3PIPECTL[*].
-                                                         When you reset PHYs (using USBDRD(0..1)_UAHC_GUBS3PHYCFG or USBDRD(0..1)_UAHC_GUSB3PIPECTL
-                                                         registers), you must keep the core in reset state until PHY
-                                                         clocks are stable. This controls the bus, ram, and mac domain
-                                                         resets.
-                                                         Note: Under soft reset, accesses to USBDRD(0..1)_UAHC_* CSRs other than
-                                                         USBDRD(0..1)_UAHC_GCTL may fail (Timeout).
-                                                         Note: This bit is for debug purposes only. Use USBDRD(0..1)_UAHC_USBCMD.HCRESET in host
-                                                         mode and USBDRD(0..1)_UAHC_DCTL[CSFTRST] in device mode for soft reset.
-                                                         INTERNAL: Refer to Reset Generation on Synopsys Databook page 250. */
+                                                         Clears the interrupts and all the USBDRD()_UAHC_* CSRs except the
+                                                         following registers: USBDRD()_UAHC_GCTL, USBDRD()_UAHC_GUCTL, USBDRD()_UAHC_GSTS,
+                                                         USBDRD()_UAHC_GRLSID, USBDRD()_UAHC_GGPIO, USBDRD()_UAHC_GUID,
+                                                         USBDRD()_UAHC_GUSB2PHYCFG(),
+                                                         USBDRD()_UAHC_GUSB3PIPECTL().
+                                                         When you reset PHYs (using USBDRD()_UAHC_GUSB2PHYCFG() or USBDRD()_UAHC_GUSB3PIPECTL()),
+                                                         you
+                                                         must keep the
+                                                         core in reset state until PHY clocks are stable. This controls the bus, RAM, and MAC
+                                                         domain resets.
+                                                         INTERNAL: Refer to Reset Generation on Synopsys Databook page 250.
+                                                         Under soft reset, accesses to USBDRD()_UAHC_* CSRs other than USBDRD()_UAHC_GCTL may fail
+                                                         (timeout).
+                                                         This bit is for debug purposes only. Use USBDRD()_UAHC_USBCMD[HCRST] for soft reset. */
 	uint32_t sofitpsync                   : 1;  /**< Synchronize ITP to reference clock. In host mode, if this bit is set to:
-                                                         0 = the core keeps the UTMI/ULPI PHY on the first port in non-suspended state whenever
+                                                         0 = The core keeps the UTMI/ULPI PHY on the first port in non-suspended state whenever
                                                          there is a SuperSpeed port that is not in Rx.Detect, SS.Disable, and U3 state.
-                                                         1 = the core keeps the UTMI/ULPI PHY on the first port in non-suspended state whenever the
+                                                         1 = The core keeps the UTMI/ULPI PHY on the first port in non-suspended state whenever the
                                                          other non-SuperSpeed ports are not in suspended state.
                                                          This feature is useful because it saves power by suspending UTMI/ULPI when SuperSpeed only
                                                          is active and it helps resolve when the PHY does not transmit a host resume unless it is
                                                          placed in suspend state.
-                                                         This bit must be programmed as a part of initialization at power-on reset, and must not be
-                                                         dynamically changed afterwards.
-                                                         Note: USBDRD(0..1)_UAHC_USB2PHYCFG[*][SUSPHY] eventually decides to put the UTMI/ULPI PHY
-                                                         into suspend state. In addition, when this bit is set to 1, the core generates ITP off of
-                                                         the REF_CLK-based counter. Otherwise, ITP and SOF are generated off of UTMI/ULPI_CLK[0]
-                                                         based counter. To program the reference clock period inside the core, refer to
-                                                         USBDRD(0..1)_UAHC_GUCTL[REFCLKPER].
-                                                         Note: If you plan to enable hardware-based LPM (PORTPMSC.HLE = 1), this feature cannot be
-                                                         used. Turn off this feature by setting this bit to zero and use the
-                                                         USBDRD(0..1)_UAHC_GFLADJ[GFLADJ_REFCLK_LPM_SEL] feature.
-                                                         Note: If you set this bit to 1, the USBDRD(0..1)_UAHC_GUSB2PHYCFG[U2_FREECLK_EXISTS] bit
-                                                         must be set to zero.
-                                                         This bit is only used in host-mode.
-                                                         INTERNAL: If you do not plan to ever use this feature or the
-                                                         USBDRD(0..1)_UAHC_GFLADJ[GFLADJ_REFCLK_LPM_SEL] feature, the minimum frequence for the
-                                                         ref_clk can be as low as 32KHz. You can connect the SUSPEND_CLK (as low as 32 KHz) to
-                                                         REF_CLK. */
-	uint32_t u1u2timerscale               : 1;  /**< Disable U1/U2 timer scaledown. If set to 1, along with SCALEDOWN =0x1, disables the scale
+                                                         USBDRD()_UAHC_GUSB2PHYCFG()[SUSPHY] eventually decides to put the UTMI/ULPI PHY in to
+                                                         suspend
+                                                         state. In addition, when this bit is set to 1, the core generates ITP off of the REF_CLK-
+                                                         based counter. Otherwise, ITP and SOF are generated off of UTMI/ULPI_CLK[0] based counter.
+                                                         To program the reference clock period inside the core, refer to
+                                                         USBDRD()_UAHC_GUCTL[REFCLKPER].
+                                                         If you do not plan to ever use this feature or the
+                                                         USBDRD()_UAHC_GFLADJ[GFLADJ_REFCLK_LPM_SEL]
+                                                         feature, the minimum frequency for the ref_clk can be as low as 32KHz. You can connect the
+                                                         SUSPEND_CLK (as low as 32 KHz) to REF_CLK.
+                                                         If you plan to enable hardware-based LPM (PORTPMSC[HLE] = 1), this feature cannot be used.
+                                                         Turn off this feature by setting this bit to zero and use the
+                                                         USBDRD()_UAHC_GFLADJ[GFLADJ_REFCLK_LPM_SEL] feature.
+                                                         If you set this bit to 1, the USBDRD()_UAHC_GUSB2PHYCFG() [U2_FREECLK_EXISTS] bit must be
+                                                         set to
+                                                         0. */
+	uint32_t u1u2timerscale               : 1;  /**< Disable U1/U2 timer scaledown. If set to 1, along with SCALEDOWN = 0x1, disables the scale
                                                          down of U1/U2 inactive timer values.
                                                          This is for simulation mode only. */
 	uint32_t debugattach                  : 1;  /**< Debug attach. When this bit is set:
-                                                         SuperSpeed link proceeds directly to the polling-link state (USBDRD(0..1)_UAHC_DCTL[RS]
-                                                         register is asserted) without checking remote termination.
-                                                         Link LFPS polling timeout is infinite
-                                                         Polling timeout during TS1 is infinite (in case link is waiting for TXEQ to finish). */
+                                                         * SuperSpeed link proceeds directly to the polling-link state (USBDRD()_UAHC_DCTL[RS] = 1)
+                                                         without checking remote termination.
+                                                         * Link LFPS polling timeout is infinite
+                                                         * Polling timeout during TS1 is infinite (in case link is waiting for TXEQ to finish). */
 	uint32_t ramclksel                    : 2;  /**< RAM clock select. Always keep set to 0x0. */
 	uint32_t scaledown                    : 2;  /**< Scale-down mode. When scale-down mode is enabled for simulation, the core uses scaled-down
                                                          timing values, resulting in faster simulations. When scale-down mode is disabled, actual
                                                          timing values are used. This is required for hardware operation.
-                                                         HighSpeed/FullSpeed/LowSpeed modes:
-                                                         0x0 = disables all scale-downs. Actual timing values are used.
-                                                         0x1 = enables scale-down of all timing values. These include:
-                                                         speed enumeration
-                                                         HNP/SRP
-                                                         suspend and resume
+                                                         High-speed/full-speed/low-speed modes:
+                                                         0x0 = Disables all scale-downs. Actual timing values are used.
+                                                         0x1 = Enables scale-down of all timing values. These include:
+                                                         * Speed enumeration
+                                                         * HNP/SRP
+                                                         * Suspend and resume
                                                          0x2 = N/A
-                                                         0x3 = enables bits <0> and <1> scale-down timing values.
+                                                         0x3 = Enables bits <0> and <1> scale-down timing values.
                                                          SuperSpeed mode:
-                                                         0x0 = disables all scale-downs. Actual timing values are used.
-                                                         0x1 = enables scaled down SuperSpeed timing and repeat values including:
-                                                         number of TxEq training sequences reduce to eight
-                                                         LFPS polling burst time reduce to 100 ns
-                                                         LFPS warm reset receive reduce to 30 us.
-                                                         0x2 = no TxEq training sequences are sent. Overrides bit<4>.
-                                                         0x3 = enables bits<0> and <1> scale-down timing values.
+                                                         0x0 = Disables all scale-downs. Actual timing values are used.
+                                                         0x1 = Enables scaled down SuperSpeed timing and repeat values including:
+                                                         * Number of TxEq training sequences reduce to eight
+                                                         * LFPS polling burst time reduce to 100 ns
+                                                         * LFPS warm reset receive reduce to 30 us.
                                                          INTERNAL: Refer to the rtl_vip_scaledown_mapping.xls file under <workspace>/sim/SoC_sim
-                                                         directory for the complete list. */
+                                                         directory for the complete list.
+                                                         0x2 = No TxEq training sequences are sent. Overrides bit<4>.
+                                                         0x3 = Enables bits<0> and <1> scale-down timing values. */
 	uint32_t disscramble                  : 1;  /**< Disable scrambling. Transmit request to link partner on next transition to recovery or polling. */
-	uint32_t u2exit_lfps                  : 1;  /**< If this bit is,
-                                                         - 0: the link treats 248ns LFPS as a valid U2 exit.
-                                                         - 1: the link waits for 8us of LFPS before it detects a valid U2 exit.
-                                                          This bit is added to improve interoperability with a third party host
-                                                          controller. This host controller in U2 state while performing
-                                                          receiver detection generates an LFPS glitch of about 4s
-                                                          duration. This causes the device to exit from U2 state because
-                                                          the LFPS filter value is 248ns. With the new functionality enabled,
-                                                          the device can stay in U2 while ignoring this glitch from the host
-                                                          controller. */
+	uint32_t u2exit_lfps                  : 1;  /**< LFPS U2 exit.
+                                                         0 = The link treats 248ns LFPS as a valid U2 exit.
+                                                         1 = The link waits for 8us of LFPS before it detects a valid U2 exit.
+                                                         This bit is added to improve interoperability with a third party host controller. This
+                                                         host controller in U2 state while performing receiver detection generates an LFPS glitch
+                                                         of about 4s duration. This causes the device to exit from U2 state because the LFPS filter
+                                                         value is 248ns. With the new functionality enabled, the device can stay in U2 while
+                                                         ignoring this glitch from the host controller. */
 	uint32_t reserved_1_1                 : 1;
 	uint32_t dsblclkgtng                  : 1;  /**< Disable clock gating. When set to 1 and the core is in low-power mode, internal clock
                                                          gating is disabled, which means the clocks are always running. This bit can be set to 1
@@ -2424,14 +2462,17 @@ union cvmx_usbdrdx_uahc_gctl {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gctl_s       cn70xx;
+	struct cvmx_usbdrdx_uahc_gctl_s       cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gctl cvmx_usbdrdx_uahc_gctl_t;
 
 /**
  * cvmx_usbdrd#_uahc_gdbgbmu
  *
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.5.
  */
 union cvmx_usbdrdx_uahc_gdbgbmu {
@@ -2448,42 +2489,44 @@ union cvmx_usbdrdx_uahc_gdbgbmu {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn70xx;
+	struct cvmx_usbdrdx_uahc_gdbgbmu_s    cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgbmu cvmx_usbdrdx_uahc_gdbgbmu_t;
 
 /**
  * cvmx_usbdrd#_uahc_gdbgepinfo
  *
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.8.
- *           This register is for Synopsys internal use only.
+ * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  */
 union cvmx_usbdrdx_uahc_gdbgepinfo {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t endpt_dbg                    : 64; /**< Endpoint debug information, bits<63:0>. */
+	uint64_t endpt_dbg                    : 64; /**< Endpoint debug information. */
 #else
 	uint64_t endpt_dbg                    : 64;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gdbgepinfo_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgepinfo cvmx_usbdrdx_uahc_gdbgepinfo_t;
 
 /**
  * cvmx_usbdrd#_uahc_gdbgfifospace
  *
- * These registers are for debug purposes. They provide debug information on the internal status
- * and state machines.
- * Global Debug Registers have design-specific information, and are used by for
- * debugging purposes. These registers are not intended to be used by the customer. If any
- * debug assistance is needed for the silicon, contact Customer Support with a dump
- * of these registers.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register is for debug purposes. It provides debug information on the internal status and
+ * state machines. Global debug registers have design-specific information, and are used by state
+ * machines. Global debug registers have design-specific information, and are used for debugging
+ * purposes. These registers are not intended to be used by the customer. If any debug assistance
+ * is needed for the silicon, contact customer support with a dump of these registers.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.2.
- *           Contact Synopsys directly.
+ * INTERNAL: Contact Synopsys directly.
  */
 union cvmx_usbdrdx_uahc_gdbgfifospace {
 	uint32_t u32;
@@ -2495,15 +2538,15 @@ union cvmx_usbdrdx_uahc_gdbgfifospace {
                                                          FIFO/queue select: <7:5> indicates the FIFO/queue type; <4:0> indicates the FIFO/queue
                                                          number.
                                                          For example, 0x21 refers to RxFIFO_1, and 0x5E refers to TxReqQ_30.
-                                                         0x1F-0x0: TxFIFO_31 to TxFIFO_0
-                                                         0x3F-0x20: RxFIFO_31 to RxFIFO_0
-                                                         0x5F-0x40: TxReqQ_31 to TxReqQ_0
-                                                         0x7F-0x60: RxReqQ_31 to RxReqQ_0
-                                                         0x9F-0x80: RxInfoQ_31 to RxInfoQ_0
-                                                         0xA0: DescFetchQ
-                                                         0xA1: EventQ
-                                                         0xA2: ProtocolStatusQ
-                                                         Port-select: <3:0> selects the port-number when accessing USBDRD(0..1)_UAHC_GDBGLTSSM. */
+                                                         0x1F-0x0: TxFIFO_31 to TxFIFO_0.
+                                                         0x3F-0x20: RxFIFO_31 to RxFIFO_0.
+                                                         0x5F-0x40: TxReqQ_31 to TxReqQ_0.
+                                                         0x7F-0x60: RxReqQ_31 to RxReqQ_0.
+                                                         0x9F-0x80: RxInfoQ_31 to RxInfoQ_0.
+                                                         0xA0: DescFetchQ.
+                                                         0xA1: EventQ.
+                                                         0xA2: ProtocolStatusQ.
+                                                         Port-select: <3:0> selects the port-number when accessing USBDRD()_UAHC_GDBGLTSSM. */
 #else
 	uint32_t select                       : 8;
 	uint32_t reserved_8_15                : 8;
@@ -2511,14 +2554,17 @@ union cvmx_usbdrdx_uahc_gdbgfifospace {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gdbgfifospace_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgfifospace cvmx_usbdrdx_uahc_gdbgfifospace_t;
 
 /**
  * cvmx_usbdrd#_uahc_gdbglnmcc
  *
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.4.
  */
 union cvmx_usbdrdx_uahc_gdbglnmcc {
@@ -2526,8 +2572,8 @@ union cvmx_usbdrdx_uahc_gdbglnmcc {
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_9_31                : 23;
-	uint32_t lnmcc_berc                   : 9;  /**< This field indicates the bit error rate information for the port
-                                                         selected in the GDBGFIFOSPACE.PortSelect field.
+	uint32_t lnmcc_berc                   : 9;  /**< This field indicates the bit-error-rate information for the port selected in
+                                                         USBDRD()_UAHC_GDBGFIFOSPACE[SELECT] (port-select).
                                                          This field is for debug purposes only. */
 #else
 	uint32_t lnmcc_berc                   : 9;
@@ -2535,16 +2581,16 @@ union cvmx_usbdrdx_uahc_gdbglnmcc {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gdbglnmcc_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglnmcc cvmx_usbdrdx_uahc_gdbglnmcc_t;
 
 /**
  * cvmx_usbdrd#_uahc_gdbglsp
  *
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.7.
- *           This register is for Synopsys internal use only.
+ * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  */
 union cvmx_usbdrdx_uahc_gdbglsp {
 	uint32_t u32;
@@ -2556,16 +2602,19 @@ union cvmx_usbdrdx_uahc_gdbglsp {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn70xx;
+	struct cvmx_usbdrdx_uahc_gdbglsp_s    cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglsp cvmx_usbdrdx_uahc_gdbglsp_t;
 
 /**
  * cvmx_usbdrd#_uahc_gdbglspmux
  *
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.6.
- *           This register is for Synopsys internal use only.
+ * INTERNAL: This register is for Synopsys internal use only.
  */
 union cvmx_usbdrdx_uahc_gdbglspmux {
 	uint32_t u32;
@@ -2573,15 +2622,15 @@ union cvmx_usbdrdx_uahc_gdbglspmux {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
 	uint32_t latraceportmuxselect         : 8;  /**< logic_analyzer_trace port multiplexer select. Only bits<21:16> are used. For details on
-                                                         how the mux controls the debug traces, refer to the verilog file.
+                                                         how the mux controls the debug traces, refer to the Verilog file.
                                                          A value of 0x3F drives 0s on the logic_analyzer_trace signal. If you plan to OR (instead
                                                          using a mux) this signal with other trace signals in your system to generate a common
                                                          trace signal, you can use this feature. */
-	uint32_t endbc                        : 1;  /**< Enable debugging of the Debug Capability LSP. Use HOSTSELECT to select the DbC LSP debug
+	uint32_t endbc                        : 1;  /**< Enable debugging of the debug capability LSP. Use HOSTSELECT to select the DbC LSP debug
                                                          information presented in the GDBGLSP register.
                                                          INTERNAL: Note this can only be used if DebugCapabaility was enabled at compile. */
 	uint32_t reserved_14_14               : 1;
-	uint32_t hostselect                   : 14; /**< Host select. Selects the LSP debug information presented in USBDRD(0..1)_UAHC_GDBGLSP. */
+	uint32_t hostselect                   : 14; /**< Host select. Selects the LSP debug information presented in USBDRD()_UAHC_GDBGLSP. */
 #else
 	uint32_t hostselect                   : 14;
 	uint32_t reserved_14_14               : 1;
@@ -2591,17 +2640,20 @@ union cvmx_usbdrdx_uahc_gdbglspmux {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gdbglspmux_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gdbglspmux cvmx_usbdrdx_uahc_gdbglspmux_t;
 
 /**
  * cvmx_usbdrd#_uahc_gdbgltssm
  *
- * In multi-port host configuration, the port-number is defined by
- * USBDRD(0..1)_UAHC_GDBGFIFOSPACE[SELECT][3:0].
- * Value of this register may change immediately after reset.
- * See description in DBGFIFOSPACE.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * In multiport host configuration, the port number is defined by
+ * USBDRD()_UAHC_GDBGFIFOSPACE[SELECT]<3:0>. Value of this register may change immediately after
+ * reset.
+ * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.3.
  */
 union cvmx_usbdrdx_uahc_gdbgltssm {
@@ -2612,31 +2664,31 @@ union cvmx_usbdrdx_uahc_gdbgltssm {
 	uint32_t ltdbtimeout                  : 1;  /**< LTDB timeout. */
 	uint32_t ltdblinkstate                : 4;  /**< LTDB link state. */
 	uint32_t ltdbsubstate                 : 4;  /**< LTDB substate. */
-	uint32_t debugpipestatus              : 18; /**< Debug PIPE Status.
-                                                         <17> Elastic Buffer Mode
-                                                         <16> Tx Elec Idle
-                                                         <15> Rx Polarity
-                                                         <14> Tx Detect Rx/Loopback
-                                                         <13:11> LTSSM PHY command State
-                                                         0x0: PHY_IDLE (PHY command state is in IDLE. No PHY request pending)
-                                                         0x1: PHY_DET (Request to start Receiver detection)
-                                                         0x2: PHY_DET_3 (Wait for Phy_Status (Receiver detection))
-                                                         0x3: PHY_PWR_DLY (Delay Pipe3_PowerDown P0 -> P1/P2/P3 request)
-                                                         0x4: PHY_PWR_A (Delay for internal logic)
-                                                         0x5: PHY_PWR_B (Wait for Phy_Status(Power state change request))
-                                                         <10:9> Power Down
-                                                         <8> RxEq Train
-                                                         <7:6> Tx Deemphasis
-                                                         <5:3> LTSSM Clock State
-                                                         0x0: CLK_NORM (PHY is in non-P3 state and PCLK is running)
-                                                         0x1: CLK_TO_P3 (P3 entry request to PHY)
-                                                         0x2: CLK_WAIT1 (Wait for Phy_Status (P3 request))
-                                                         0x3: CLK_P3 (PHY is in P3 and PCLK is not running)
-                                                         0x4: CLK_TO_P0 (P3 exit request to PHY)
-                                                         0x5: CLK_WAIT2 (Wait for Phy_Status (P3 exit request))
-                                                         <2> Tx Swing
-                                                         <1> Rx Termination
-                                                         <0> Tx Ones/Zeros */
+	uint32_t debugpipestatus              : 18; /**< Debug PIPE status.
+                                                         _ <17> Elastic buffer mode.
+                                                         _ <16> TX elec idle.
+                                                         _ <15> RX polarity.
+                                                         _ <14> TX Detect RX/loopback.
+                                                         _ <13:11> LTSSM PHY command state.
+                                                         _ 0x0 = PHY_IDLE (PHY command state is in IDLE. No PHY request is pending.)
+                                                         _ 0x1 = PHY_DET (Request to start receiver detection).
+                                                         _ 0x2 = PHY_DET_3 (Wait for Phy_Status (receiver detection)).
+                                                         _ 0x3 = PHY_PWR_DLY (delay Pipe3_PowerDown P0 -> P1/P2/P3 request).
+                                                         _ 0x4 = PHY_PWR_A (delay for internal logic).
+                                                         _ 0x5 = PHY_PWR_B (wait for Phy_Status(Power-state change request)).
+                                                         _ <10:9> Power down.
+                                                         _ <8> RxEq train.
+                                                         _ <7:6> TX de-emphasis.
+                                                         _ <5:3> LTSSM clock state.
+                                                         _ 0x0 = CLK_NORM (PHY is in non-P3 state and PCLK is running).
+                                                         _ 0x1 = CLK_TO_P3 (P3 entry request to PHY).
+                                                         _ 0x2 = CLK_WAIT1 (wait for Phy_Status (P3 request)).
+                                                         _ 0x3 = CLK_P3 (PHY is in P3 and PCLK is not running).
+                                                         _ 0x4 = CLK_TO_P0 (P3 exit request to PHY).
+                                                         _ 0x5 = CLK_WAIT2 (Wait for Phy_Status (P3 exit request)).
+                                                         _ <2> TX swing.
+                                                         _ <1> RX termination.
+                                                         _ <0> TX 1s/0s. */
 #else
 	uint32_t debugpipestatus              : 18;
 	uint32_t ltdbsubstate                 : 4;
@@ -2646,6 +2698,7 @@ union cvmx_usbdrdx_uahc_gdbgltssm {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gdbgltssm_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gdbgltssm cvmx_usbdrdx_uahc_gdbgltssm_t;
 
@@ -2653,21 +2706,26 @@ typedef union cvmx_usbdrdx_uahc_gdbgltssm cvmx_usbdrdx_uahc_gdbgltssm_t;
  * cvmx_usbdrd#_uahc_gdmahlratio
  *
  * This register specifies the relative priority of the SuperSpeed FIFOs with respect to the
- * HighSpeed/FullSpeed/LowSpeed FIFOs. The DMA arbiter prioritizes the
- * HighSpeed/FullSpeed/LowSpeed round-robin arbiter group every DMA High-Low Priority Ratio
- * grants as indicated in the register separately for TX and RX.
+ * high-speed/full-speed/low-speed FIFOs. The DMA arbiter prioritizes the high-speed/full-speed
+ * /low-speed round-robin arbiter group every DMA high-low priority ratio grants as indicated in
+ * the register separately for TX and RX.
+ *
  * To illustrate, consider that all FIFOs are requesting access simultaneously, and the ratio is
- * 4. SuperSpeed gets priority for 4 packets, HighSpeed/FullSpeed/LowSpeed gets priority for 1
- * packet, SuperSpeed gets priority for 4 packets, HighSpeed/FullSpeed/LowSpeed gets priority for
- * 1 packet, and so on.
- * If FIFOs from both speed groups are not requesting access simultaneously then,
- *  * if SuperSpeed got grants 4 out of the last 4 times, then HighSpeed/FullSpeed/LowSpeed get
- *    the priority on any future request.
- *  * if HighSpeed/FullSpeed/LowSpeed got the grant last time, SuperSpeed gets the priority on
- *    the next request.
- *  * if there is a valid request on either SuperSpeed or HighSpeed/FullSpeed/LowSpeed, a grant
- *    is always awarded; there is no idle.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * 4. SuperSpeed gets priority for four packets, high-speed/full-speed/low-speed gets priority
+ * for one packet, SuperSpeed gets priority for four packets, high-speed/full-speed/low-speed
+ * gets priority for one packet, and so on.
+ *
+ * If FIFOs from both speed groups are not requesting access simultaneously then:
+ * * If SuperSpeed got grants four out of the last four times, then high-speed/full-speed/
+ * low-speed get the priority on any future request.
+ * * If high-speed/full-speed/low-speed got the grant last time, SuperSpeed gets the priority on
+ * the next request.
+ *
+ * If there is a valid request on either SuperSpeed or high-speed/full-speed/low-speed, a grant
+ * is always awarded; there is no idle.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.5.
  */
 union cvmx_usbdrdx_uahc_gdmahlratio {
@@ -2686,6 +2744,7 @@ union cvmx_usbdrdx_uahc_gdmahlratio {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gdmahlratio_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gdmahlratio cvmx_usbdrdx_uahc_gdmahlratio_t;
 
@@ -2696,11 +2755,13 @@ typedef union cvmx_usbdrdx_uahc_gdmahlratio cvmx_usbdrdx_uahc_gdmahlratio_t;
  * address once during power-on initialization. Software must not change the value of this
  * register after it is initialized.
  * Software must only use the GEVNTCOUNTn register for event processing. The lower n bits of the
- * address must be USBDRD(0..1)_UAHC_GEVNTSIZ_(0)[EVNTSIZ]-aligned.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * address must be USBDRD()_UAHC_GEVNTSIZ()[EVNTSIZ]-aligned.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.1.
  */
 union cvmx_usbdrdx_uahc_gevntadrx {
@@ -2715,6 +2776,7 @@ union cvmx_usbdrdx_uahc_gevntadrx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gevntadrx_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gevntadrx cvmx_usbdrdx_uahc_gevntadrx_t;
 
@@ -2726,16 +2788,19 @@ typedef union cvmx_usbdrdx_uahc_gevntadrx cvmx_usbdrdx_uahc_gevntadrx_t;
  * hardware writes a new event to the Event Buffer, it increments this count. Most events
  * are four bytes, but some events may span over multiple four byte entries. Whenever the
  * count is greater than zero, the hardware raises the corresponding interrupt
- * line (depending on the USBDRD(0..1)_UAHC_GEVNTSIZ(0)[EVNTINTMASK]). On an interrupt, software
+ * line (depending on the USBDRD()_UAHC_GEVNTSIZ()[EVNTINTMASK]). On an interrupt, software
  * processes one or more events out of the Event Buffer. Afterwards, software must write the
  * Event Count field with the number of bytes it processed.
+ *
  * Clock crossing delays may result in the interrupt's continual assertion after software
  * acknowledges the last event. Therefore, when the interrupt line is asserted, software must
  * read the GEVNTCOUNT register and only process events if the GEVNTCOUNT is greater than 0.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.3.
  */
 union cvmx_usbdrdx_uahc_gevntcountx {
@@ -2752,6 +2817,7 @@ union cvmx_usbdrdx_uahc_gevntcountx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gevntcountx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gevntcountx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gevntcountx cvmx_usbdrdx_uahc_gevntcountx_t;
 
@@ -2763,10 +2829,12 @@ typedef union cvmx_usbdrdx_uahc_gevntcountx cvmx_usbdrdx_uahc_gevntcountx_t;
  * the Event Buffer. The Event Interrupt Mask will mask the interrupt, but events are still
  * queued. After configuration, software must preserve the Event Buffer Size value when
  * changing the Event Interrupt Mask.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.2.
  */
 union cvmx_usbdrdx_uahc_gevntsizx {
@@ -2786,6 +2854,7 @@ union cvmx_usbdrdx_uahc_gevntsizx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gevntsizx_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gevntsizx_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gevntsizx cvmx_usbdrdx_uahc_gevntsizx_t;
 
@@ -2793,103 +2862,90 @@ typedef union cvmx_usbdrdx_uahc_gevntsizx cvmx_usbdrdx_uahc_gevntsizx_t;
  * cvmx_usbdrd#_uahc_gfladj
  *
  * This register provides options for the software to control the core behavior with respect to
- * SOF (Start of Frame) and ITP (Isochronous Timestamp Packet) timers and frame timer
- * functionality. It provides option to override the sideband signal fladj_30mhz_reg. In
- * addition, it enables running SOF or ITP frame timer counters completely off of the ref_clk.
+ * SOF (start of frame) and ITP (isochronous timestamp packet) timers and frame timer
+ * functionality. It provides the option to override the sideband signal fladj_30mhz_reg. In
+ * addition, it enables running SOF or ITP frame timer counters completely off of the REF_CLK.
  * This facilitates hardware LPM in host mode with the SOF or ITP counters being run off of the
- * ref_clk signal.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * REF_CLK signal.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.6.
  */
 union cvmx_usbdrdx_uahc_gfladj {
 	uint32_t u32;
 	struct cvmx_usbdrdx_uahc_gfladj_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t gfladj_refclk_240mhzdecr_pls1 : 1; /**< This field indicates that the decrement value that the controller applies for
-                                                         each ref_clk must be GFLADJ_REFCLK_240MHZ_DECR and
-                                                         GFLADJ_REFCLK_240MHZ_DECR +1 alternatively on each ref_clk.
-                                                         Set this bit to 1 only if GFLADJ_REFCLK_LPM_SEL is set to 1 and the
-                                                         fractional component of 240/ref_frequency is greater than or equal to 0.5.
+	uint32_t gfladj_refclk_240mhzdecr_pls1 : 1; /**< This field indicates that the decrement value that the controller applies for each REF_CLK
+                                                         must be GFLADJ_REFCLK_240MHZ_DECR and GFLADJ_REFCLK_240MHZ_DECR +1 alternatively on each
+                                                         REF_CLK. Set this bit to 1 only if GFLADJ_REFCLK_LPM_SEL is set to 1 and the fractional
+                                                         component of 240/ref_frequency is greater than or equal to 0.5.
                                                          Example:
-                                                           If the ref_clk is 19.2 MHz then,
-                                                           - GUCTL.REF_CLK_PERIOD = 52
-                                                           - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = (240/19.2) = 12.5
-                                                           - GFLADJ.GFLADJ_REFCLK_240MHZDECR_PLS1 = 1
-                                                           If the ref_clk is 24 MHz then,
-                                                           - GUCTL.REF_CLK_PERIOD = 41
-                                                           - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = (240/24) = 10
-                                                           - GFLADJ.GFLADJ_REFCLK_240MHZDECR_PLS1 = 0 */
-	uint32_t gfladj_refclk_240mhz_decr    : 7;  /**< This field indicates the decrement value that the controller applies for each
-                                                         ref_clk in order to derive a frame timer in terms of a 240-MHz clock. This
-                                                         field must be programmed to a non-zero value only if
-                                                         GFLADJ_REFCLK_LPM_SEL is set to 1.
+                                                         If the REF_CLK is 19.2 MHz then,
+                                                         * USBDRD()_UAHC_GUCTL[REFCLKPER] = 52.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = (240/19.2) = 12.5.
+                                                         * GFLADJ_REFCLK_240MHZDECR_PLS1 = 1.
+                                                         If the REF_CLK is 24 MHz then,
+                                                         * USBDRD()_UAHC_GUCTL[REFCLKPER] = 41.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = (240/24) = 10.
+                                                         * GFLADJ_REFCLK_240MHZDECR_PLS1 = 0. */
+	uint32_t gfladj_refclk_240mhz_decr    : 7;  /**< This field indicates the decrement value that the controller applies for each REF_CLK in
+                                                         order to derive a frame timer in terms of a 240-MHz clock. This field must be programmed
+                                                         to a non-zero value only if GFLADJ_REFCLK_LPM_SEL is set to 1.
                                                          The value is derived as follows:
-                                                           GFLADJ_REFCLK_240MHZ_DECR = 240/ref_clk_frequency
+                                                         _ GFLADJ_REFCLK_240MHZ_DECR = 240/ref_clk_frequency
                                                          Examples:
-                                                           If the ref_clk is 24 MHz then,
-                                                           - GUCTL.REF_CLK_PERIOD = 41
-                                                           - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/24 = 10
-                                                           If the ref_clk is 48 MHz then,
-                                                           - GUCTL.REF_CLK_PERIOD = 20
-                                                           - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/48 = 5
-                                                           If the ref_clk is 17 MHz then,
-                                                           - GUCTL.REF_CLK_PERIOD = 58
-                                                           - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/17 = 14 */
-	uint32_t gfladj_refclk_lpm_sel        : 1;  /**< This bit enables the functionality of running SOF/ITP counters on the
-                                                         ref_clk.
-                                                         This bit must not be set to 1 if USBDRD(0..1)_UAHC_GCTL[SOFITPSYNC] bit is set to 1.
-                                                         Similarly, if GFLADJ_REFCLK_LPM_SEL set to 1, USBDRD(0..1)_UAHC_GCTL[SOFITPSYNC]
-                                                         must not be set to 1. When GFLADJ_REFCLK_LPM_SEL is set to 1 the
-                                                         overloading of the suspend control of the USB 2.0 first port PHY
-                                                         (UTMI) with USB 3.0 port states is removed. Note that the
-                                                         ref_clk frequencies supported in this mode are
-                                                         16/17/19.2/20/24/39.7/40 MHz.
-                                                         Note: If you set this bit to 1, the GUSB2PHYCFG.U2_FREECLK_EXISTS
-                                                         bit must be set to 0.
-                                                         INTERNAL: The utmi_clk[0] signal of the core must be
-                                                         connected to the FREECLK of the PHY. */
+                                                         If the REF_CLK is 24 MHz then,
+                                                         * USBDRD()_UAHC_GUCTL[REFCLKPER] = 41.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = 240/24 = 10.
+                                                         If the REF_CLK is 48 MHz then,
+                                                         * USBDRD()_UAHC_GUCTL[REFCLKPER] = 20.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = 240/48 = 5.
+                                                         If the REF_CLK is 17 MHz then,
+                                                         * USBDRD()_UAHC_GUCTL[REFCLKPER] = 58.
+                                                         * GFLADJ_REFCLK_240MHZ_DECR = 240/17 = 14. */
+	uint32_t gfladj_refclk_lpm_sel        : 1;  /**< This bit enables the functionality of running SOF/ITP counters on the REF_CLK.
+                                                         This bit must not be set to 1 if USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1. Similarly, if
+                                                         GFLADJ_REFCLK_LPM_SEL = 1, USBDRD()_UAHC_GCTL[SOFITPSYNC] must not be set to 1.
+                                                         When GFLADJ_REFCLK_LPM_SEL = 1 the overloading of the suspend control of the USB 2.0 first
+                                                         port PHY (UTMI) with USB 3.0 port states is removed. Note that the REF_CLK frequencies
+                                                         supported in this mode are 16/17/19.2/20/24/39.7/40 MHz.
+                                                         INTERNAL: The utmi_clk[0] signal of the core must be connected to the FREECLK of the PHY.
+                                                         If you set this bit to 1, USBDRD()_UAHC_GUSB2PHYCFG()[U2_FREECLK_EXISTS] must be set to 0. */
 	uint32_t reserved_22_22               : 1;
-	uint32_t gfladj_refclk_fladj          : 14; /**< This field indicates the frame length adjustment to be applied when
-                                                         SOF/ITP counter is running off of the ref_clk.
-                                                         This register value is used to adjust
-                                                         - ITP interval when GCTL[SOFITPSYNC] is set to 1
-                                                         - both SOF and ITP interval when GLADJ.GFLADJ_REFCLK_LPM_SEL
-                                                           is set to 1.
-                                                         This field must be programmed to a non-zero value only if
-                                                         GFLADJ_REFCLK_LPM_SEL is set to 1 or GCTL.SOFITPSYNC is set to
-                                                         1.
+	uint32_t gfladj_refclk_fladj          : 14; /**< This field indicates the frame length adjustment to be applied when SOF/ITP counter is
+                                                         running off of the REF_CLK. This register value is used to adjust:.
+                                                         * ITP interval when USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1
+                                                         * both SOF and ITP interval when GFLADJ_REFCLK_LPM_SEL = 1.
+                                                         This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL = 1 or
+                                                         USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1.
                                                          The value is derived as below:
-                                                           FLADJ_REF_CLK_FLADJ=((125000/ref_clk_period_integer)-
-                                                           (125000/ref_clk_period)) * ref_clk_period
+                                                         _ FLADJ_REF_CLK_FLADJ = ((125000/ref_clk_period_integer) - (125000/ref_clk_period)) *
+                                                         ref_clk_period
                                                          where,
-                                                         - the ref_clk_period_integer is the integer value of the ref_clk period got
-                                                           by truncating the decimal (fractional) value that is programmed in the
-                                                           GUCTL.REF_CLK_PERIOD field
-                                                         - the ref_clk_period is the ref_clk period including the fractional value.
+                                                         * the ref_clk_period_integer is the integer value of the REF_CLK period got by truncating
+                                                         the decimal (fractional) value that is programmed in USBDRD()_UAHC_GUCTL[REFCLKPER].
+                                                         * the ref_clk_period is the REF_CLK period including the fractional value.
                                                          Examples:
-                                                           If the ref_clk is 24 MHz then,
-                                                           - GUCTL.REF_CLK_PERIOD = 41
-                                                           - GFLADJ.GLADJ_REFCLK_FLADJ = ((125000/41)-
-                                                           (125000/41.6666))*41.6666 = 2032 (ignoring the fractional value)
-                                                           If the ref_clk is 48 MHz then,
-                                                           - GUCTL.REF_CLK_PERIOD = 20
-                                                           - GFLADJ.GLADJ_REFCLK_FLADJ = ((125000/20)-
-                                                           (125000/20.8333))*20.8333 = 5208 (ignoring the fractional value) */
-	uint32_t gfladj_30mhz_reg_sel         : 1;  /**< This field selects whether to use the input signal fladj_30mhz_reg or the
-                                                         GFLADJ.GFLADJ_30MHZ to adjust the frame length for the SOF/ITP.
-                                                         When this bit is set to,
-                                                         1, the controller uses the register field GFLADJ.GFLADJ_30MHZ value
-                                                         0, the controller uses the input signal fladj_30mhz_reg value */
+                                                         If the REF_CLK is 24 MHz then,
+                                                         * USBDRD()_UAHC_GUCTL[REFCLKPER] = 41.
+                                                         * GLADJ_REFCLK_FLADJ = ((125000/41) -
+                                                         (125000/41.6666)) * 41.6666 = 2032 (ignoring the fractional value).
+                                                         If the REF_CLK is 48 MHz then,
+                                                         * USBDRD()_UAHC_GUCTL[REFCLKPER] = 20.
+                                                         * GLADJ_REFCLK_FLADJ = ((125000/20) -
+                                                         (125000/20.8333)) * 20.8333 = 5208 (ignoring the fractional value). */
+	uint32_t gfladj_30mhz_reg_sel         : 1;  /**< This field selects whether to use the input signal fladj_30mhz_reg or the GFLADJ_30MHZ to
+                                                         adjust the frame length for the SOF/ITP. When this bit is set to, 1, the controller uses
+                                                         GFLADJ_30MHZ value 0x0, the controller uses the input signal fladj_30mhz_reg value. */
 	uint32_t reserved_6_6                 : 1;
-	uint32_t gfladj_30mhz                 : 6;  /**< This field indicates the value that is used for frame length adjustment
-                                                         instead of considering from the sideband input signal fladj_30mhz_reg.
-                                                         This enables post-silicon frame length adjustment in case the input signal
-                                                         fladj_30mhz_reg is connected to a wrong value or is not valid. The
-                                                         controller uses this value if GFLADJ.GFLADJ_30MHZ_REG_SEL is set to
-                                                         1 and the SOF/ITP counters are running off of UTMI(ULPI) clock
-                                                         (GFLADJ_REFCLK_LPM_SEL is 0 and GCTL.SOFITPSYNC is 1 or 0). for
-                                                         For details on how to set this value, refer to section 5.2.4 Frame Length
-                                                         Adjustment Register (FLADJ) of the the xHCI Specification. */
+	uint32_t gfladj_30mhz                 : 6;  /**< This field indicates the value that is used for frame length adjustment instead of
+                                                         considering from the sideband input signal fladj_30mhz_reg. This enables post-silicon
+                                                         frame length adjustment in case the input signal fladj_30mhz_reg is connected to a wrong
+                                                         value or is not valid. The controller uses this value if GFLADJ_30MHZ_REG_SEL = 1 and the
+                                                         SOF/ITP counters are running off of UTMI(ULPI) clock (GFLADJ_REFCLK_LPM_SEL = 0 and
+                                                         USBDRD()_UAHC_GCTL[SOFITPSYNC] is 1 or 0). For details on how to set this value, refer to
+                                                         section 5.2.4 Frame Length Adjustment Register (FLADJ) of the xHCI Specification. */
 #else
 	uint32_t gfladj_30mhz                 : 6;
 	uint32_t reserved_6_6                 : 1;
@@ -2902,6 +2958,7 @@ union cvmx_usbdrdx_uahc_gfladj {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gfladj_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_gfladj_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gfladj cvmx_usbdrdx_uahc_gfladj_t;
 
@@ -2910,7 +2967,9 @@ typedef union cvmx_usbdrdx_uahc_gfladj cvmx_usbdrdx_uahc_gfladj_t;
  *
  * The application can use this register for general purpose input and output ports or for
  * debugging.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.9.
  */
 union cvmx_usbdrdx_uahc_ggpio {
@@ -2925,15 +2984,16 @@ union cvmx_usbdrdx_uahc_ggpio {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ggpio_s      cn70xx;
+	struct cvmx_usbdrdx_uahc_ggpio_s      cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ggpio cvmx_usbdrdx_uahc_ggpio_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams0
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.1.
  */
 union cvmx_usbdrdx_uahc_ghwparams0 {
 	uint32_t u32;
@@ -2955,15 +3015,16 @@ union cvmx_usbdrdx_uahc_ghwparams0 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams0_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams0_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams0 cvmx_usbdrdx_uahc_ghwparams0_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams1
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.2.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.2.
  */
 union cvmx_usbdrdx_uahc_ghwparams1 {
 	uint32_t u32;
@@ -2972,21 +3033,21 @@ union cvmx_usbdrdx_uahc_ghwparams1 {
 	uint32_t en_dbc                       : 1;  /**< Enable debug capability. */
 	uint32_t rm_opt_features              : 1;  /**< Remove optional features. */
 	uint32_t sync_rst                     : 1;  /**< Synchronous reset coding. */
-	uint32_t ram_bus_clks_sync            : 1;  /**< RAM_CLK and BUS_CLK are synchronous.
-                                                         INTERNAL: (appears to be orthogonal from the RAM_CLK_TO_BUS_CLK parameter) */
+	uint32_t ram_bus_clks_sync            : 1;  /**< RAM_CLK and BUS_CLK are synchronous. INTERNAL: (appears to be orthogonal from the
+                                                         RAM_CLK_TO_BUS_CLK parameter) */
 	uint32_t mac_ram_clks_sync            : 1;  /**< MAC3_CLK and RAM_CLK are synchronous. */
 	uint32_t mac_phy_clks_sync            : 1;  /**< MAC3_CLK and PHY_CLK are synchronous. */
-	uint32_t en_pwropt                    : 2;  /**< Power optimization mode.
-                                                         Bit <0>: clock-gating feature available.
-                                                         Bit <1>: hibernation feature available. */
+	uint32_t en_pwropt                    : 2;  /**< Power optimization mode:
+                                                         bit<0> = Clock-gating feature available.
+                                                         bit<1> = Hibernation feature available. */
 	uint32_t spram_typ                    : 1;  /**< SRAM type: one-port RAMs. */
 	uint32_t num_rams                     : 2;  /**< Number of RAMs. */
 	uint32_t device_num_int               : 6;  /**< Number of event buffers (and interrupts) in device-mode. */
 	uint32_t aspacewidth                  : 3;  /**< Native interface address-space port width. */
 	uint32_t reqinfowidth                 : 3;  /**< Native interface request/response-info port width. */
 	uint32_t datainfowidth                : 3;  /**< Native interface data-info port width. */
-	uint32_t burstwidth_m1                : 3;  /**< Width - 1 of AXI Length field. */
-	uint32_t idwidth_m1                   : 3;  /**< Width - 1 of AXI ID field. */
+	uint32_t burstwidth_m1                : 3;  /**< Width minus one of AXI length field. */
+	uint32_t idwidth_m1                   : 3;  /**< Width minus one of AXI ID field. */
 #else
 	uint32_t idwidth_m1                   : 3;
 	uint32_t burstwidth_m1                : 3;
@@ -3006,15 +3067,16 @@ union cvmx_usbdrdx_uahc_ghwparams1 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams1_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams1_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams1 cvmx_usbdrdx_uahc_ghwparams1_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams2
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.3.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.3.
  */
 union cvmx_usbdrdx_uahc_ghwparams2 {
 	uint32_t u32;
@@ -3026,13 +3088,15 @@ union cvmx_usbdrdx_uahc_ghwparams2 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams2_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams2_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams2 cvmx_usbdrdx_uahc_ghwparams2_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams3
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.4.
  */
 union cvmx_usbdrdx_uahc_ghwparams3 {
@@ -3047,8 +3111,8 @@ union cvmx_usbdrdx_uahc_ghwparams3 {
 	uint32_t vendor_ctl_interface         : 1;  /**< UTMI+ PHY vendor control interface enabled. */
 	uint32_t reserved_8_9                 : 2;
 	uint32_t hsphy_dwidth                 : 2;  /**< Data width of the UTMI+ PHY interface: 0x2 = 8-or-16 bits. */
-	uint32_t fsphy_interface              : 2;  /**< USB 1.1 FullSpeed serial transceiver interface. */
-	uint32_t hsphy_interface              : 2;  /**< HighSpeed PHY interface: 0x1 = UTMI+. */
+	uint32_t fsphy_interface              : 2;  /**< USB 1.1 full-speed serial transceiver interface. */
+	uint32_t hsphy_interface              : 2;  /**< High-speed PHY interface: 0x1 = UTMI+. */
 	uint32_t ssphy_interface              : 2;  /**< SuperSpeed PHY interface: 0x1 = PIPE3. */
 #else
 	uint32_t ssphy_interface              : 2;
@@ -3065,15 +3129,16 @@ union cvmx_usbdrdx_uahc_ghwparams3 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams3_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams3_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams3 cvmx_usbdrdx_uahc_ghwparams3_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams4
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.5.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.5.
  */
 union cvmx_usbdrdx_uahc_ghwparams4 {
 	uint32_t u32;
@@ -3083,7 +3148,7 @@ union cvmx_usbdrdx_uahc_ghwparams4 {
 	uint32_t bmu_ptl_depth_m1             : 4;  /**< Depth of the BMU-PTL source/sink buffers minus 1. */
 	uint32_t en_isoc_supt                 : 1;  /**< Isochronous support enabled. */
 	uint32_t reserved_22_22               : 1;
-	uint32_t ext_buff_control             : 1;  /**< Enables device external buffer control sideband controls */
+	uint32_t ext_buff_control             : 1;  /**< Enables device external buffer control sideband controls. */
 	uint32_t num_ss_usb_instances         : 4;  /**< Number of SuperSpeed bus instances. */
 	uint32_t hiber_scratchbufs            : 4;  /**< Number of hibernation scratchpad buffers. */
 	uint32_t reserved_6_12                : 7;
@@ -3101,15 +3166,16 @@ union cvmx_usbdrdx_uahc_ghwparams4 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams4_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams4_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams4 cvmx_usbdrdx_uahc_ghwparams4_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams5
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.6.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.6.
  */
 union cvmx_usbdrdx_uahc_ghwparams5 {
 	uint32_t u32;
@@ -3118,8 +3184,8 @@ union cvmx_usbdrdx_uahc_ghwparams5 {
 	uint32_t reserved_28_31               : 4;
 	uint32_t dfq_fifo_depth               : 6;  /**< Size of the BMU descriptor fetch-request queue. */
 	uint32_t dwq_fifo_depth               : 6;  /**< Size of the BMU descriptor write queue. */
-	uint32_t txq_fifo_depth               : 6;  /**< Size of the BMU Tx request queue. */
-	uint32_t rxq_fifo_depth               : 6;  /**< Size of the BMU Rx request queue. */
+	uint32_t txq_fifo_depth               : 6;  /**< Size of the BMU TX request queue. */
+	uint32_t rxq_fifo_depth               : 6;  /**< Size of the BMU RX request queue. */
 	uint32_t bmu_busgm_depth              : 4;  /**< Depth of the BMU-BUSGM source/sink buffers. */
 #else
 	uint32_t bmu_busgm_depth              : 4;
@@ -3131,15 +3197,16 @@ union cvmx_usbdrdx_uahc_ghwparams5 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams5_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams5_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams5 cvmx_usbdrdx_uahc_ghwparams5_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams6
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.7.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.7.
  */
 union cvmx_usbdrdx_uahc_ghwparams6 {
 	uint32_t u32;
@@ -3147,14 +3214,14 @@ union cvmx_usbdrdx_uahc_ghwparams6 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t ram0_depth                   : 16; /**< RAM0 Depth. */
 	uint32_t en_bus_filters               : 1;  /**< VBus filters support. */
-	uint32_t en_bc                        : 1;  /**< Battery-charging support. */
-	uint32_t en_otg_ss                    : 1;  /**< OTG SuperSpeed support. */
-	uint32_t en_adp                       : 1;  /**< ADP support. */
+	uint32_t en_bc                        : 1;  /**< Enable battery-charging support. */
+	uint32_t en_otg_ss                    : 1;  /**< Enable OTG SuperSpeed support. */
+	uint32_t en_adp                       : 1;  /**< Enable ADP support. */
 	uint32_t hnp_support                  : 1;  /**< HNP support. */
 	uint32_t srp_support                  : 1;  /**< SRP support. */
 	uint32_t reserved_8_9                 : 2;
-	uint32_t en_fpga                      : 1;  /**< FPGA implementation. */
-	uint32_t en_dbg_ports                 : 1;  /**< Debug ports for FGPA. */
+	uint32_t en_fpga                      : 1;  /**< Enable FPGA implementation. */
+	uint32_t en_dbg_ports                 : 1;  /**< Enable Debug ports for FGPA. */
 	uint32_t psq_fifo_depth               : 6;  /**< Size of the BMU-protocol status queue. */
 #else
 	uint32_t psq_fifo_depth               : 6;
@@ -3171,15 +3238,16 @@ union cvmx_usbdrdx_uahc_ghwparams6 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams6_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams6_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams6 cvmx_usbdrdx_uahc_ghwparams6_t;
 
 /**
  * cvmx_usbdrd#_uahc_ghwparams7
  *
- * These registers contain the hardware configuration options selected at compile-time.
+ * This register contains the hardware configuration options selected at compile-time.
  * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.8.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.8.
  */
 union cvmx_usbdrdx_uahc_ghwparams7 {
 	uint32_t u32;
@@ -3193,6 +3261,7 @@ union cvmx_usbdrdx_uahc_ghwparams7 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams7_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams7_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams7 cvmx_usbdrdx_uahc_ghwparams7_t;
 
@@ -3213,22 +3282,23 @@ union cvmx_usbdrdx_uahc_ghwparams8 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_ghwparams8_s cn70xx;
+	struct cvmx_usbdrdx_uahc_ghwparams8_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_ghwparams8 cvmx_usbdrdx_uahc_ghwparams8_t;
 
 /**
  * cvmx_usbdrd#_uahc_gpmsts
  *
- * This debug register gives information on which event caused the hibernation exit.
- * These registers are for debug purposes. They provide debug information on the internal status
- * and state machines.
- * Global Debug Registers have design-specific information, and are used by for
- * debugging purposes. These registers are not intended to be used by the customer. If any
- * debug assistance is needed for the silicon, contact Customer Support with a dump
- * of these registers.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This debug register gives information on which event caused the hibernation exit. These
+ * registers are for debug purposes. They provide debug information on the internal status and
+ * state machines. Global debug registers have design-specific information, and are used by for
+ * debugging purposes. These registers are not intended to be used by the customer. If any debug
+ * assistance is needed for the silicon, contact Customer Support with a dump of these registers.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.1.
- *           Contact Synopsys directly.
+ * INTERNAL: Contact Synopsys directly.
  */
 union cvmx_usbdrdx_uahc_gpmsts {
 	uint32_t u32;
@@ -3236,24 +3306,24 @@ union cvmx_usbdrdx_uahc_gpmsts {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t portsel                      : 4;  /**< This field selects the port number. Always 0x0. */
 	uint32_t reserved_17_27               : 11;
-	uint32_t u3wakeup                     : 5;  /**< This field gives the USB 3.0 port wakeup conditions
-                                                         Bit [12]: Overcurrent Detected
-                                                         Bit [13]: Resume Detected
-                                                         Bit [14]: Connect Detected
-                                                         Bit [15]: Disconnect Detected
-                                                         Bit [16]: Last Connection State */
+	uint32_t u3wakeup                     : 5;  /**< This field gives the USB 3.0 port wakeup conditions.
+                                                         bit<12> = Overcurrent detected.
+                                                         bit<13> = Resume detected.
+                                                         bit<14> = Connect detected.
+                                                         bit<15> = Disconnect detected.
+                                                         bit<16> = Last connection state. */
 	uint32_t reserved_10_11               : 2;
-	uint32_t u2wakeup                     : 10; /**< This field indicates the USB 2.0 port wakeup conditions
-                                                         Bit [0]: Overcurrent Detected
-                                                         Bit [1]: Resume Detected
-                                                         Bit [2]: Connect Detected
-                                                         Bit [3]: Disconnect Detected
-                                                         Bit [4]: Last Connection State
-                                                         Bit [5]: ID Change Detected
-                                                         Bit [6]: SRP Request Detected
-                                                         Bit [7]: ULPI Interrupt Detected
-                                                         Bit [8]: USB Reset Detected
-                                                         Bit [9]: Resume Detected Changed */
+	uint32_t u2wakeup                     : 10; /**< This field indicates the USB 2.0 port wakeup conditions.
+                                                         bit<0> = Overcurrent detected.
+                                                         bit<1> = Resume detected.
+                                                         bit<2> = Connect detected.
+                                                         bit<3> = Disconnect detected.
+                                                         bit<4> = Last connection state.
+                                                         bit<5> = ID change detected.
+                                                         bit<6> = SRP request detected.
+                                                         bit<7> = ULPI interrupt detected.
+                                                         bit<8> = USB reset detected.
+                                                         bit<9> = Resume detected changed. */
 #else
 	uint32_t u2wakeup                     : 10;
 	uint32_t reserved_10_11               : 2;
@@ -3263,6 +3333,7 @@ union cvmx_usbdrdx_uahc_gpmsts {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gpmsts_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_gpmsts_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gpmsts cvmx_usbdrdx_uahc_gpmsts_t;
 
@@ -3271,10 +3342,12 @@ typedef union cvmx_usbdrdx_uahc_gpmsts cvmx_usbdrdx_uahc_gpmsts_t;
  *
  * This register specifies the SuperSpeed USB instance number to which each USB 3.0 port is
  * connected. By default, USB 3.0 ports are evenly distributed among all SuperSpeed USB
- * instances. Software can program this register to specify how USB 3.0 ports are connected
- * to SuperSpeed USB instances.
- * The UAHC only implements one SuperSpeed bus-instance, so this register should always be 0.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * instances. Software can program this register to specify how USB 3.0 ports are connected to
+ * SuperSpeed USB instances. The UAHC only implements one SuperSpeed bus-instance, so this
+ * register should always be 0.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.2.1.
  */
 union cvmx_usbdrdx_uahc_gprtbimap {
@@ -3282,27 +3355,28 @@ union cvmx_usbdrdx_uahc_gprtbimap {
 	struct cvmx_usbdrdx_uahc_gprtbimap_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t binum1                       : 4;  /**< SuperSpeed USB instance number for port 1 */
+	uint64_t binum1                       : 4;  /**< SuperSpeed USB instance number for port 1. */
 #else
 	uint64_t binum1                       : 4;
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gprtbimap_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap cvmx_usbdrdx_uahc_gprtbimap_t;
 
 /**
  * cvmx_usbdrd#_uahc_gprtbimap_fs
  *
- * This register specifies the FullSpeed/LowSpeed USB instance number to which each USB 1.1 port
- * is connected. By default, USB 1.1 ports are evenly distributed among all FullSpeed/LowSpeed
- * USB instances.
- * Software can program this register to specify how USB 1.1 ports are connected to
- * FullSpeed/LowSpeed USB instances.
- * The UAHC only implements one FullSpeed/LowSpeed bus-instance, so this register should always
- * be 0.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register specifies the full-speed/low-speed USB instance number to which each USB 1.1
+ * port is connected. By default, USB 1.1 ports are evenly distributed among all full-speed/
+ * low-speed USB instances. Software can program this register to specify how USB 1.1 ports are
+ * connected to full-speed/low-speed USB instances. The UAHC only implements one full-speed/
+ * low-speed bus-instance, so this register should always be 0x0.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.2.3.
  */
 union cvmx_usbdrdx_uahc_gprtbimap_fs {
@@ -3310,25 +3384,28 @@ union cvmx_usbdrdx_uahc_gprtbimap_fs {
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t binum1                       : 4;  /**< FullSpeed USB instance number for port 1. */
+	uint64_t binum1                       : 4;  /**< Full-speed USB instance number for port 1. */
 #else
 	uint64_t binum1                       : 4;
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gprtbimap_fs_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap_fs cvmx_usbdrdx_uahc_gprtbimap_fs_t;
 
 /**
  * cvmx_usbdrd#_uahc_gprtbimap_hs
  *
- * This register specifies the HighSpeed USB instance number to which each USB 2.0 port is
- * connected. By default, USB 2.0 ports are evenly distributed among all HighSpeed USB
- * instances. Software can program this register to specify how USB 2.0 ports are connected
- * to HighSpeed USB instances.
- * The UAHC only implements one HighSpeed bus-instance, so this register should always be 0.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register specifies the high-speed USB instance number to which each USB 2.0 port is
+ * connected. By default, USB 2.0 ports are evenly distributed among all high-speed USB
+ * instances. Software can program this register to specify how USB 2.0 ports are connected to
+ * high-speed USB instances. The UAHC only implements one high-speed bus-instance, so this
+ * register should always be 0.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.2.2.
  */
 union cvmx_usbdrdx_uahc_gprtbimap_hs {
@@ -3336,13 +3413,14 @@ union cvmx_usbdrdx_uahc_gprtbimap_hs {
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t binum1                       : 4;  /**< HighSpeed USB instance number for port 1. */
+	uint64_t binum1                       : 4;  /**< High-speed USB instance number for port 1. */
 #else
 	uint64_t binum1                       : 4;
 	uint64_t reserved_4_63                : 60;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gprtbimap_hs_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gprtbimap_hs cvmx_usbdrdx_uahc_gprtbimap_hs_t;
 
@@ -3350,8 +3428,8 @@ typedef union cvmx_usbdrdx_uahc_gprtbimap_hs cvmx_usbdrdx_uahc_gprtbimap_hs_t;
  * cvmx_usbdrd#_uahc_grlsid
  *
  * This is a read-only register that contains the release number of the core.
- * INTERNAL: Original name: GSNPSID = Synopsys ID
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.8.
+ * INTERNAL: Original name: GSNPSID = Synopsys ID.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.8.
  */
 union cvmx_usbdrdx_uahc_grlsid {
 	uint32_t u32;
@@ -3367,29 +3445,36 @@ union cvmx_usbdrdx_uahc_grlsid {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_grlsid_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_grlsid_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_grlsid cvmx_usbdrdx_uahc_grlsid_t;
 
 /**
  * cvmx_usbdrd#_uahc_grxfifoprihst
  *
- * This register specifies the relative DMA priority level among the Host RXFIFOs (one per USB
- * bus instance) within the associated speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed).
- * When multiple RXFIFOs compete for DMA service at a given time, the RxXDMA arbiter grants
- * access on a packet-basis in the following manner:
- *   1. Among the FIFOs in the same speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed):
- *     a. High-priority RXFIFOs are granted access using round-robin arbitration
- *     b. Low-priority RXFIFOs are granted access using round-robin arbitration only after high-
- *        priority RXFIFOs have no further processing to do (i.e., either the RXQs are empty or
- *        the corresponding RXFIFOs do not have the required data).
- *   2. The RX DMA arbiter prioritizes the SuperSpeed group or HighSpeed/FullSpeed/LowSpeed group
- *      according to the ratio programmed in the USBDRD(0..1)_UAHC_GDMAHLRATIO register.
+ * This register specifies the relative DMA priority level among the host RXFIFOs (one per USB
+ * bus instance) within the associated speed group (SuperSpeed or high-speed/full-speed/
+ * low-speed). When multiple RXFIFOs compete for DMA service at a given time, the RXDMA arbiter
+ * grants access on a packet-basis in the following manner:
+ *
+ * Among the FIFOs in the same speed group (SuperSpeed or high-speed/full-speed/low-speed):
+ * * High-priority RXFIFOs are granted access using round-robin arbitration.
+ * * Low-priority RXFIFOs are granted access using round-robin arbitration only after high-
+ * priority
+ * RXFIFOs have no further processing to do (i.e., either the RXQs are empty or the corresponding
+ * RXFIFOs do not have the required data).
+ *
+ * The RX DMA arbiter prioritizes the SuperSpeed group or high-speed/full-speed/low-speed group
+ * according to the ratio programmed in
+ * USBDRD()_UAHC_GDMAHLRATIO.
+ *
  * For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until
- * the entire packet is completed.
- * The register size corresponds to the number of configured USB bus instances; for example, in
- * the default configuration, there are 3 USB bus instances (1 SuperSpeed, 1 HighSpeed, and 1
- * FullSpeed/LowSpeed).
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * the entire packet is completed. The register size corresponds to the number of configured USB
+ * bus instances; for example, in the default configuration, there are 3 USB bus instances (1
+ * SuperSpeed, 1 high-speed, and 1 full-speed/low-speed).
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.3.
  */
 union cvmx_usbdrdx_uahc_grxfifoprihst {
@@ -3397,14 +3482,14 @@ union cvmx_usbdrdx_uahc_grxfifoprihst {
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_3_31                : 29;
-	uint32_t rx_priority                  : 3;  /**< Each register bit[n] controls the priority (1: high, 0: low) of RXFIFO[n] within a speed
-                                                         group. */
+	uint32_t rx_priority                  : 3;  /**< Each register bit[n] controls the priority (1 = high, 0 = low) of RXFIFO[n] within a speed group. */
 #else
 	uint32_t rx_priority                  : 3;
 	uint32_t reserved_3_31                : 29;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn70xx;
+	struct cvmx_usbdrdx_uahc_grxfifoprihst_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_grxfifoprihst cvmx_usbdrdx_uahc_grxfifoprihst_t;
 
@@ -3412,70 +3497,61 @@ typedef union cvmx_usbdrdx_uahc_grxfifoprihst cvmx_usbdrdx_uahc_grxfifoprihst_t;
  * cvmx_usbdrd#_uahc_grxfifosiz#
  *
  * The application can program the internal RAM start address/depth of the each RxFIFO as shown
- * below. It is recommended that software use the default value. In Host mode, per-port
- * registers are implemented.
- * One register per FIFO.
- * Host reset values = 0:[0x0000_0084] 1:[0x0084_0104] 2:[0x0188_0180]
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * below. It is recommended that software use the default value. In Host mode, per-port registers
+ * are implemented. One register per FIFO.
+ *
+ * Reset values = 0:[0x0000_0084] 1:[0x0084_0104] 2:[0x0188_0180].
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.6.2.
- *           For more information, see the BMU section in Block Descriptions on Synopsys Databook
+ * INTERNAL: For more information, see the BMU section in Block Descriptions on Synopsys Databook
  * page 238.
  */
 union cvmx_usbdrdx_uahc_grxfifosizx {
 	uint32_t u32;
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t rxfstaddr                    : 16; /**< RxFIFOn RAM start address.  This field contains the memory start address for RxFIFOn.
-                                                         Device mode:
-                                                            RXFIFO0 : 0x0
-                                                            RXFIFO1 : 0x185
-                                                            RXFIFO2 : 0x185
-                                                         Host mode:
-                                                            RXFIFO0 : 0x0
-                                                            RXFIFO1 : 0x84
-                                                            RXFIFO2 : 0x188 */
+	uint32_t rxfstaddr                    : 16; /**< RxFIFOn RAM start address. This field contains the memory start address for RxFIFOn. The
+                                                         reset value is derived from configuration parameters. */
 	uint32_t rxfdep                       : 16; /**< RxFIFOn depth. This value is in terms of RX RAM Data width.
-                                                         minimum value = 0x20. maximum value = 0x4000.
-                                                         Device mode:
-                                                            RXFIFO0 : 0x185
-                                                            RXFIFO1 : 0x0
-                                                            RXFIFO2 : 0x0
-                                                         Host mode:
-                                                            RXFIFO0 : 0x84
-                                                            RXFIFO1 : 0x104
-                                                            RXFIFO2 : 0x180
+                                                         minimum value = 0x20, maximum value = 0x4000.
                                                          INTERNAL: For more information, see the Hardware Integration chapter of the Synopsys
-                                                         Databook. */
+                                                         Databook.
+                                                         The reset value is derived from configuration parameters. */
 #else
 	uint32_t rxfdep                       : 16;
 	uint32_t rxfstaddr                    : 16;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_grxfifosizx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_grxfifosizx cvmx_usbdrdx_uahc_grxfifosizx_t;
 
 /**
  * cvmx_usbdrd#_uahc_grxthrcfg
  *
- * In a normal case, an Rx burst will start as soon as 1-packet space is available.
- * This works well as long as the system bus is faster than the USB3.0 bus (a
- * 1024-bytes packet takes ~2.2 uS on the USB bus in SuperSpeed mode). If the system bus latency
- * is larger than 2.2 uS to access a 1024-byte packet, then starting a burst on 1-packet
- * condition leads to an early abort of the burst causing unnecessary performance reduction.
- * This register allows the configuration of threshold and burst size control. This feature
- * is enabled by USBRXPKTCNTSEL.
+ * In a normal case, an RX burst starts as soon as 1-packet space is available. This works well
+ * as long as the system bus is faster than the USB3.0 bus (a 1024-bytes packet takes ~2.2 us on
+ * the USB bus in SuperSpeed mode). If the system bus latency is larger than 2.2 us to access a
+ * 1024-byte packet, then starting a burst on 1-packet condition leads to an early abort of the
+ * burst causing unnecessary performance reduction. This register allows the configuration of
+ * threshold and burst size control. This feature is enabled by USBRXPKTCNTSEL.
+ *
  * Receive Path:
- * * The Rx Threshold is controlled by USBRXPKTCNT and the Rx burst size is controlled
- *   by USBMAXRXBURSTSIZE.
- * * Selecting optimal Rx FIFO size, Rx Threshold, and Rx burst size avoids Rx burst aborts due
- *   to overrun if the system bus is slower than USB. Once in a while overrun is OK, and there
- *   is no functional issue.
- * * Some devices do not support terminating ACK retry. With these devices Host cannot set ACK=0
- *   and Retry=0 and do retry later and you have to retry immediately. For such devices,
- *   minimize retry due to underrun. Setting threshold and burst size guarantees this.
- * * A larger Rx threshold affects the performance since the scheduler is idle during this time.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * * The RX threshold is controlled by USBRXPKTCNT and the RX burst size is controlled by
+ * USBMAXRXBURSTSIZE.
+ * * Selecting optimal RX FIFO size, RX Threshold, and RX burst size avoids RX burst aborts due
+ * to overrun if the system bus is slower than USB. Once in a while overrun is OK, and there is
+ * no functional issue.
+ * * Some devices do not support terminating ACK retry. With these devices, host cannot set ACK=0
+ * and Retry=0 and do retry later and you have to retry immediately. For such devices, minimize
+ * retry due to underrun. Setting threshold and burst size guarantees this.
+ * A larger RX threshold affects the performance since the scheduler is idle during this time.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.4.
  */
 union cvmx_usbdrdx_uahc_grxthrcfg {
@@ -3492,7 +3568,7 @@ union cvmx_usbdrdx_uahc_grxthrcfg {
                                                          This mode is only used for SuperSpeed.
                                                          In device mode, setting this bit to 1 also enables the functionality of reporting
                                                          NUMP in the ACK TP based on the RX FIFO space instead of reporting a fixed NUMP derived
-                                                         from USBDRD(0..1)_UAHC_DCFG[NUMP]. */
+                                                         from USBDRD()_UAHC_DCFG[NUMP]. */
 	uint32_t reserved_28_28               : 1;
 	uint32_t usbrxpktcnt                  : 4;  /**< USB receive-packet count.
                                                          In host-mode, specifies space (in number of packets) that must be available in
@@ -3500,10 +3576,10 @@ union cvmx_usbdrdx_uahc_grxthrcfg {
                                                          In device mode, specifies the space (in number of packets) that must be available in
                                                          the RX FIFO before the core can send ERDY for a flow-controlled enpoint.
                                                          This field is only valid when USBRXPKTCNTSEL = 1. The valid values are from 0x1 to 0xF.
-                                                         Note: This field must be less than or equal to the USBMAXRXBURSTSIZE field. */
-	uint32_t usbmaxrxburstsize            : 5;  /**< USB maximum receive-burst size.
-                                                         In host-mode, specifies the maximum bulk IN burst the core should do.
-                                                         When the system bus is slower than the USB, RX FIFO can overrun during a long burst.
+                                                         This field must be <= USBMAXRXBURSTSIZE. */
+	uint32_t usbmaxrxburstsize            : 5;  /**< USB maximum receive-burst size. In host-mode, specifies the maximum bulk IN burst the core
+                                                         should do. When the system bus is slower than the USB, RX FIFO can overrun during a long
+                                                         burst.
                                                          Program a smaller value to this field to limit the RX burst size that the core can do. It
                                                          only applies to SuperSpeed Bulk, Isochronous, and Interrupt IN endpoints in the host mode.
                                                          In device mode, specified the NUMP value that will be sent in ERDy for an OUT endpoint.
@@ -3519,6 +3595,7 @@ union cvmx_usbdrdx_uahc_grxthrcfg {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_grxthrcfg_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_grxthrcfg cvmx_usbdrdx_uahc_grxthrcfg_t;
 
@@ -3526,15 +3603,16 @@ typedef union cvmx_usbdrdx_uahc_grxthrcfg cvmx_usbdrdx_uahc_grxthrcfg_t;
  * cvmx_usbdrd#_uahc_gsbuscfg0
  *
  * This register can be used to configure the core after power-on or a change in mode of
- * operation. This register mainly contains AXI system-related configuration parameters.
- * Do not change this register after the initial programming. The application must program
- * this register before starting any transactions on AXI.
- * When INCRBRSTENA is enabled, it has the highest priority over other burst lengths. The
- * core always perform the largest burst when enabled.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * operation. This register mainly contains AXI system-related configuration parameters. Do not
+ * change this register after the initial programming. The application must program this register
+ * before starting any transactions on AXI. When INCRBRSTENA is enabled, it has the highest
+ * priority over other burst lengths. The core always performs the largest burst when enabled.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: The AXI cache signals are not connected in Cavium's hookup, so the *REQINFO fields
  * can be ignored.
- *           See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.1.
+ * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.1.
  */
 union cvmx_usbdrdx_uahc_gsbuscfg0 {
 	uint32_t u32;
@@ -3546,9 +3624,9 @@ union cvmx_usbdrdx_uahc_gsbuscfg0 {
 	uint32_t deswrreqinfo                 : 4;  /**< AXI-cache for descriptor-write operations. Always set to 0x0. */
 	uint32_t reserved_12_15               : 4;
 	uint32_t datbigend                    : 1;  /**< Data access is big-endian. Keep this set to 0 (little-endian) and use the
-                                                         USBDRD(0..1)_UCTL_SHIM_CFG[DMA_ENDIAN_MODE] setting instead. */
+                                                         USBDRD()_UCTL_SHIM_CFG[DMA_ENDIAN_MODE] setting instead. */
 	uint32_t descbigend                   : 1;  /**< Descriptor access is big-endian. Keep this set to 0 (little-endian) and use the
-                                                         USBDRD(0..1)_UCTL_SHIM_CFG[DMA_ENDIAN_MODE] setting instead. */
+                                                         USBDRD()_UCTL_SHIM_CFG[DMA_ENDIAN_MODE] setting instead. */
 	uint32_t reserved_8_9                 : 2;
 	uint32_t incr256brstena               : 1;  /**< INCR256 burst-type enable. Always set to 0. */
 	uint32_t incr128brstena               : 1;  /**< INCR128 burst-type enable. Always set to 0. */
@@ -3558,13 +3636,12 @@ union cvmx_usbdrdx_uahc_gsbuscfg0 {
 	uint32_t incr8brstena                 : 1;  /**< INCR8 burst-type enable. Allows the AXI master to generate INCR eight-beat bursts. */
 	uint32_t incr4brstena                 : 1;  /**< INCR4 burst-type enable. Allows the AXI master to generate INCR four-beat bursts. */
 	uint32_t incrbrstena                  : 1;  /**< Undefined-length INCR burst-type enable.
-                                                         This bit determines the set of burst lengths to be utilized by
-                                                         the master interface. It works in conjunction with the
-                                                         GSBUSCFG0[7:1] enables (INCR*BRSTENA).
-                                                         If disabled, the AXI master will use only the following burst lengths:
-                                                           1, 4, 8, 16 (assuming the INCR*BRSTENA are set to their reset values)
-                                                         If enabled, the AXI master uses any length less than or equal to the largest-enabled
-                                                         burst length based on the INCR*BRSTENA fields. */
+                                                         This bit determines the set of burst lengths to be utilized by the master interface. It
+                                                         works in conjunction with the GSBUSCFG0[7:1] enables (INCR*BRSTENA).
+                                                         If disabled, the AXI master will use only the burst lengths
+                                                         1, 4, 8, 16 (assuming the INCR*BRSTENA are set to their reset values).
+                                                         If enabled, the AXI master uses any length less than or equal to the largest-enabled burst
+                                                         length based on the INCR*BRSTENA fields. */
 #else
 	uint32_t incrbrstena                  : 1;
 	uint32_t incr4brstena                 : 1;
@@ -3585,6 +3662,7 @@ union cvmx_usbdrdx_uahc_gsbuscfg0 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gsbuscfg0_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gsbuscfg0 cvmx_usbdrdx_uahc_gsbuscfg0_t;
 
@@ -3592,10 +3670,12 @@ typedef union cvmx_usbdrdx_uahc_gsbuscfg0 cvmx_usbdrdx_uahc_gsbuscfg0_t;
  * cvmx_usbdrd#_uahc_gsbuscfg1
  *
  * This register can be used to configure the core after power-on or a change in mode of
- * operation. This register mainly contains AXI system-related configuration parameters.
- * Do not change this register after the initial programming. The application must program
- * this register before starting any transactions on AXI.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * operation. This register mainly contains AXI system-related configuration parameters. Do not
+ * change this register after the initial programming. The application must program this register
+ * before starting any transactions on AXI.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.2.
  */
 union cvmx_usbdrdx_uahc_gsbuscfg1 {
@@ -3604,20 +3684,20 @@ union cvmx_usbdrdx_uahc_gsbuscfg1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_13_31               : 19;
 	uint32_t en1kpage                     : 1;  /**< 1K page-boundary enable.
-                                                         0 = AXI breaks transfers at the 4K page boundary (default)
-                                                         1 = AXI breaks transfers at the 1K page boundary */
+                                                         0 = Break transfers at the 4K page boundary (default).
+                                                         1 = Break transfers at the 1K page boundary. */
 	uint32_t pipetranslimit               : 4;  /**< AXI pipelined transfers burst-request limit. Controls the number of outstanding pipelined
                                                          transfers requests the AXI master will push to the AXI slave. Once the AXI master reaches
                                                          this limit, it does not make more requests on the AXI ARADDR and AWADDR buses until the
                                                          associated data phases complete. This field is encoded as follows:
-                                                         0x0 = 1 request 0x8 = 9 requests
-                                                         0x1 = 2 requests 0x9 = 10 requests
-                                                         0x2 = 3 requests 0xA = 11 requests
-                                                         0x3 = 4 requests 0xB = 12 requests
-                                                         0x4 = 5 requests 0xC = 13 requests
-                                                         0x5 = 6 requests 0xD = 14 requests
-                                                         0x6 = 7 requests 0xE = 15 requests
-                                                         0x7 = 8 requests 0xF = 16 requests */
+                                                         0x0 = 1 request. 0x8 = 9 requests.
+                                                         0x1 = 2 requests. 0x9 = 10 requests.
+                                                         0x2 = 3 requests. 0xA = 11 requests.
+                                                         0x3 = 4 requests. 0xB = 12 requests.
+                                                         0x4 = 5 requests. 0xC = 13 requests.
+                                                         0x5 = 6 requests. 0xD = 14 requests.
+                                                         0x6 = 7 requests. 0xE = 15 requests.
+                                                         0x7 = 8 requests. 0xF = 16 requests. */
 	uint32_t reserved_0_7                 : 8;
 #else
 	uint32_t reserved_0_7                 : 8;
@@ -3627,13 +3707,15 @@ union cvmx_usbdrdx_uahc_gsbuscfg1 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gsbuscfg1_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gsbuscfg1 cvmx_usbdrdx_uahc_gsbuscfg1_t;
 
 /**
  * cvmx_usbdrd#_uahc_gsts
  *
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.6.
  */
 union cvmx_usbdrdx_uahc_gsts {
@@ -3641,16 +3723,16 @@ union cvmx_usbdrdx_uahc_gsts {
 	struct cvmx_usbdrdx_uahc_gsts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t cbelt                        : 12; /**< Current BELT value. In host mode, indicates the minimum value of all received device BELT
-                                                         values and the BELT value that is set by the Set Latency Tolerance Value command. */
+                                                         values and the BELT value that is set by the set latency tolerance value command. */
 	uint32_t reserved_8_19                : 12;
 	uint32_t host_ip                      : 1;  /**< Host interrupt pending. Indicates that there is a pending interrupt pertaining to xHC in
                                                          the host-event queue. */
 	uint32_t device_ip                    : 1;  /**< Device interrupt pending. Indicates that there is a pending interrupt pertaining to
                                                          peripheral (device) operation in the Device event queue. */
 	uint32_t csrtimeout                   : 1;  /**< CSR timeout. When set to 1, indicates that software performed a write or read operation to
-                                                         a core register that could not be completed within 0xFFFF host-controller clock cycles. */
-	uint32_t buserraddrvld                : 1;  /**< Bus-error address valid. Indicates that USBDRD(0..1)_UAHC_GBUSERRADDR_* is valid and
-                                                         reports the first bus address that encounters a bus error. */
+                                                         a core register that could not be completed within 0xFFFF controller-clock cycles. */
+	uint32_t buserraddrvld                : 1;  /**< Bus-error address valid. Indicates that USBDRD()_UAHC_GBUSERRADDR is valid and reports the
+                                                         first bus address that encounters a bus error. */
 	uint32_t reserved_2_3                 : 2;
 	uint32_t curmod                       : 2;  /**< Current mode of operation. 0x0 for device, 0x1 for host. */
 #else
@@ -3665,6 +3747,7 @@ union cvmx_usbdrdx_uahc_gsts {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gsts_s       cn70xx;
+	struct cvmx_usbdrdx_uahc_gsts_s       cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gsts cvmx_usbdrdx_uahc_gsts_t;
 
@@ -3677,20 +3760,27 @@ typedef union cvmx_usbdrdx_uahc_gsts cvmx_usbdrdx_uahc_gsts_t;
  * TXFIFOs compete for DMA service at a given time (i.e., multiple TXQs contain TX DMA requests
  * and their corresponding TXFIFOs have space available), the TX DMA arbiter grants access on a
  * packet-basis in the following manner:
+ *
  *   1. High-priority TXFIFOs are granted access using round-robin arbitration
+ *
  *   2. Low-priority TXFIFOs are granted access using round-robin arbitration only after the
  *      high-priority TXFIFOs have no further processing to do (i.e., either the TXQs are empty
  *      or the corresponding TXFIFOs are full).
+ *
  * For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until
  * the entire packet is completed.
+ *
  * When configuring periodic IN endpoints, software must set register bit[n]=1, where n is the
  * TXFIFO assignment. This ensures that the DMA for isochronous or interrupt IN endpoints are
  * prioritized over bulk or control IN endpoints.
+ *
  * This register is present only when the core is configured to operate in the device mode
  * (includes DRD and OTG modes). The register size corresponds to the number of Device IN
  * endpoints.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET].
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.1.
  */
 union cvmx_usbdrdx_uahc_gtxfifopridev {
@@ -3706,6 +3796,7 @@ union cvmx_usbdrdx_uahc_gtxfifopridev {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gtxfifopridev_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifopridev cvmx_usbdrdx_uahc_gtxfifopridev_t;
 
@@ -3716,19 +3807,27 @@ typedef union cvmx_usbdrdx_uahc_gtxfifopridev cvmx_usbdrdx_uahc_gtxfifopridev_t;
  * bus instance) within the associated speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed).
  * When multiple TXFIFOs compete for DMA service at a given time, the TXDMA arbiter grants access
  * on a packet-basis in the following manner:
+ *
  *   1. Among the FIFOs in the same speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed):
+ *
  *     a. High-priority TXFIFOs are granted access using round-robin arbitration
+ *
  *     b. Low-priority TXFIFOs are granted access using round-robin arbitration only after the
  *        high priority TXFIFOs have no further processing to do (i.e., either the TXQs are empty
  *        or thecorresponding TXFIFOs are full).
+ *
  *   2. The TX DMA arbiter prioritizes the SuperSpeed group or HighSpeed/FullSpeed/LowSpeed group
- *      according to the ratio programmed in the USBDRD(0..1)_UAHC_GDMAHLRATIO register.
+ *      according to the ratio programmed in the USBDRD()_UAHC_GDMAHLRATIO register.
+ *
  * For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until
  * the entire packet is completed.
  * The register size corresponds to the number of configured USB bus instances; for example, in
  * the default configuration, there are 3 USB bus instances (1 SuperSpeed, 1 HighSpeed, and 1
  * FullSpeed/LowSpeed).
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.2.
  */
 union cvmx_usbdrdx_uahc_gtxfifoprihst {
@@ -3736,7 +3835,7 @@ union cvmx_usbdrdx_uahc_gtxfifoprihst {
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_3_31                : 29;
-	uint32_t tx_priority                  : 3;  /**< Each register bit[n] controls the priority (1: high, 0: low) of TXFIFO[n] within a speed
+	uint32_t tx_priority                  : 3;  /**< Each register bit n controls the priority (1: high, 0: low) of TX FIFO<n> within a speed
                                                          group. */
 #else
 	uint32_t tx_priority                  : 3;
@@ -3744,6 +3843,7 @@ union cvmx_usbdrdx_uahc_gtxfifoprihst {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gtxfifoprihst_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifoprihst cvmx_usbdrdx_uahc_gtxfifoprihst_t;
 
@@ -3752,72 +3852,58 @@ typedef union cvmx_usbdrdx_uahc_gtxfifoprihst cvmx_usbdrdx_uahc_gtxfifoprihst_t;
  *
  * This register holds the internal RAM start address/depth of each TxFIFO implemented. Unless
  * packet size/buffer size for each endpoint is different and application-specific, it is
- * recommended that the software use the default value. One register per FIFO.
- * One register per FIFO.
- * Host reset values = 0:[0x0000_0082] 1:[0x0082_0103] 2:[0x0185_0205]
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * recommended that the software use the default value. One register per FIFO. One register per
+ * FIFO.
+ *
+ * Reset values = 0:[0x0000_0082] 1:[0x0082_0103] 2:[0x0185_0205].
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.6.1.
- *           For more information, refer to the BMU section in Block Descriptions on Synopsys
+ * INTERNAL: For more information, refer to the BMU section in Block Descriptions on Synopsys
  * Databook page 238.
  */
 union cvmx_usbdrdx_uahc_gtxfifosizx {
 	uint32_t u32;
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t txfstaddr                    : 16; /**< Transmit FIFOn RAM start address. Contains the memory start address for TxFIFOn.
-                                                         Reset values:
-                                                         Device mode:
-                                                            TXFIFO0 : 0x0
-                                                            TXFIFO1 : 0x42
-                                                            TXFIFO2 : 0x1c6
-                                                            TXFIFO3 : 0x34a
-                                                         Host mode:
-                                                            TXFIFO0 : 0x0
-                                                            TXFIFO1 : 0x82
-                                                            TXFIFO2 : 0x185
-                                                            TXFIFO3 : 0x38a */
+	uint32_t txfstaddr                    : 16; /**< Transmit FIFOn RAM start address. Contains the memory start address for TxFIFOn. The reset
+                                                         is value derived from configuration parameters. */
 	uint32_t txfdep                       : 16; /**< TxFIFOn depth. This value is in terms of TX RAM data width.
                                                          minimum value = 0x20, maximum value = 0x8000.
-                                                         Reset values:
-                                                         Device mode:
-                                                            TXFIFO0 : 0x42
-                                                            TXFIFO1 : 0x184
-                                                            TXFIFO2 : 0x184
-                                                            TXFIFO3 : 0x184
-                                                         Host mode:
-                                                            TXFIFO0 (FSLS) : 0x82
-                                                            TXFIFO1 (HS)   : 0x103
-                                                            TXFIFO2 (SS)   : 0x205
                                                          INTERNAL: For more information, see the Hardware Integration chapter of the Synopsys
-                                                         Databook. */
+                                                         Databook.
+                                                         The reset value derived from configuration parameters. */
 #else
 	uint32_t txfdep                       : 16;
 	uint32_t txfstaddr                    : 16;
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gtxfifosizx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gtxfifosizx cvmx_usbdrdx_uahc_gtxfifosizx_t;
 
 /**
  * cvmx_usbdrd#_uahc_gtxthrcfg
  *
- * In a normal case, a Tx burst will start as soon as one packet is prefetched.
- * This works well as long as the system bus is faster than the USB3.0 bus (a
- * 1024-bytes packet takes ~2.2 uS on the USB bus in SuperSpeed mode). If the system bus
- * latency is larger than 2.2 uS to access a 1024-byte packet, then starting a burst on 1-packet
- * condition leads to an early abort of the burst causing unnecessary performance reduction.
- * This register allows the configuration of threshold and burst size
- * control. This feature is enabled by [USBTXPKTCNTSEL].
+ * In a normal case, a TX burst starts as soon as one packet is prefetched. This works well as
+ * long as the system bus is faster than the USB3.0 bus (a 1024-bytes packet takes ~2.2 us on the
+ * USB bus in SuperSpeed mode). If the system bus latency is larger than 2.2 us to access a
+ * 1024-byte packet, then starting a burst on 1-packet condition leads to an early abort of the
+ * burst causing unnecessary performance reduction. This register allows the configuration of
+ * threshold and burst size control. This feature is enabled by [USBTXPKTCNTSEL].
+ *
  * Transmit Path:
- *   * The Tx Threshold is controlled by [USBTXPKTCNT], and the Tx burst size is
- *     controlled by [USBMAXTXBURSTSIZE].
- *   * Selecting optimal Tx FIFO size, Tx Threshold, and Tx burst size avoids Tx burst aborts due
- *     to an underrun if the system bus is slower than USB. Once in a while an underrun is OK,
- *     and there is no functional issue.
- *   * A larger threshold will affect the performance, since the scheduler is idle during this
- *     time.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * * The TX Threshold is controlled by [USBTXPKTCNT], and the TX burst size is controlled by
+ * [USBMAXTXBURSTSIZE].
+ * * Selecting optimal TX FIFO size, TX Threshold, and TX burst size avoids TX burst aborts due
+ * to an underrun if the system bus is slower than USB. Once in a while an underrun is OK, and
+ * there is no functional issue.
+ * * A larger threshold affects the performance, since the scheduler is idle during this time.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.3.
  */
 union cvmx_usbdrdx_uahc_gtxthrcfg {
@@ -3825,7 +3911,7 @@ union cvmx_usbdrdx_uahc_gtxthrcfg {
 	struct cvmx_usbdrdx_uahc_gtxthrcfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_30_31               : 2;
-	uint32_t usbtxpktcntsel               : 1;  /**< USB Transmit packet-count enable. Enables/disables the USB transmission multipacket
+	uint32_t usbtxpktcntsel               : 1;  /**< USB transmit packet-count enable. Enables/disables the USB transmission multipacket
                                                          thresholding:
                                                          0 = USB transmission multipacket thresholding is disabled, the core can only start
                                                          transmission on the USB after the entire packet has been fetched into the corresponding
@@ -3838,7 +3924,7 @@ union cvmx_usbdrdx_uahc_gtxthrcfg {
 	uint32_t usbtxpktcnt                  : 4;  /**< USB transmit-packet count. Specifies the number of packets that must be in the TXFIFO
                                                          before the core can start transmission for the corresponding USB transaction (burst). This
                                                          field is only valid when USBTXPKTCNTSEL = 1. Valid values are from 0x1 to 0xF.
-                                                         Note: This field must be less than or equal to the USBMAXTXBURSTSIZE field. */
+                                                         This field must be <= USBMAXTXBURSTSIZE. */
 	uint32_t usbmaxtxburstsize            : 8;  /**< USB maximum TX burst size. When USBTXPKTCNTSEL = 1, this field specifies the maximum bulk
                                                          OUT burst the core should do. When the system bus is slower than the USB, TX FIFO can
                                                          underrun during a long burst. Program a smaller value to this field to limit the TX burst
@@ -3855,16 +3941,18 @@ union cvmx_usbdrdx_uahc_gtxthrcfg {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_gtxthrcfg_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gtxthrcfg cvmx_usbdrdx_uahc_gtxthrcfg_t;
 
 /**
  * cvmx_usbdrd#_uahc_guctl
  *
- * This register provides a few options for the software to control the core behavior in the Host
- * mode.
- * Most of the options are used to improve host inter-operability with different devices.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register provides a few options for the software to control the core behavior in the host
+ * mode. Most of the options are used to improve host inter-operability with different devices.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.11.
  */
 union cvmx_usbdrdx_uahc_guctl {
@@ -3872,17 +3960,18 @@ union cvmx_usbdrdx_uahc_guctl {
 	struct cvmx_usbdrdx_uahc_guctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t refclkper                    : 10; /**< Reference-clock period. Indicates (in terms of ns) the period of REF_CLK. The default
-                                                         value is set to 0x8 (8 ns/125 MHz).
-                                                         This field needs to be updated during power on initialization if
-                                                         USBDRD(0..1)_UAHC_GCTL[SOFITPSYNC] = 1 or
-                                                         USBDRD(0..1)_UAHC_GFLADJ[GFLADJ_REFCLK_LPM_SEL] = 1. The progammable maximum value
-                                                         62 ns, and the minimum value is 8 ns. You use a reference clock with a period that is
-                                                         a integer multiple, so that ITP can meet the jitter margin of 32ns. The allowable
-                                                         REF_CLK frequencies whose period is not integer multiples are 16/17/19.2/24/39.7MHz.
+                                                         value is set to 0x8
+                                                         (8 ns/125 MHz). This field must be updated during power on initialization if
+                                                         USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1 or USBDRD()_UAHC_GFLADJ [GFLADJ_REFCLK_LPM_SEL] = 1.
+                                                         The
+                                                         programmable maximum value 62 ns, and the minimum value is 8 ns. You use a reference clock
+                                                         with a period that is a integer multiple, so that ITP can meet the jitter margin of 32 ns.
+                                                         The allowable REF_CLK frequencies whose period is not integer multiples are
+                                                         16/17/19.2/24/39.7 MHz.
                                                          This field should not be set to 0x0 at any time. If you do not plan to use this feature,
                                                          then you need to set this field to 0x8, the default value. */
 	uint32_t noextrdl                     : 1;  /**< No extra delay between SOF and the first packet.
-                                                         Some HighSpeed devices misbehave when the host sends a packet immediately after an SOF.
+                                                         Some high-speed devices misbehave when the host sends a packet immediately after an SOF.
                                                          However, adding an extra delay between an SOF and the first packet can reduce the USB data
                                                          rate and performance.
                                                          This bit is used to control whether the host should wait for 2 us before it sends the
@@ -3897,9 +3986,9 @@ union cvmx_usbdrdx_uahc_guctl {
                                                          transfers. Scheduling multiple transactions in one microframe/frame can cause these
                                                          devices to misbehave. If this bit is set to 1, the host controller schedules transactions
                                                          for a control transfer in different microframes/frames. */
-	uint32_t resbwhseps                   : 1;  /**< Reserving 85% bandwidth for HighSpeed periodic EPs. By default, host conroller reserves
-                                                         80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to
-                                                         85% to accommodate two HighSpeed, high-bandwidth ISOC EPs.
+	uint32_t resbwhseps                   : 1;  /**< Reserving 85% bandwidth for high-speed periodic EPs. By default, host controller reserves
+                                                         80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85%
+                                                         to accommodate two high-speed, high-bandwidth ISOC EPs.
                                                          USB 2.0 required 80% bandwidth allocated for ISOC traffic. If two high bandwidth ISOC
                                                          devices (HD webcams) are connected, and if each requires 1024-bytes * 3 packets per
                                                          microframe, then the bandwidth required is around 82%. If this bit is set to 1, it is
@@ -3907,9 +3996,9 @@ union cvmx_usbdrdx_uahc_guctl {
                                                          you may have to reduce the resolution of the webcams. */
 	uint32_t cmdevaddr                    : 1;  /**< Compliance mode for device address. When set to 1, slot ID can have different value than
                                                          device address if max_slot_enabled < 128.
-                                                         1 = increment device address on each address device command.
-                                                         0 = device address is equal to slot ID.
-                                                         The XHCI compliance requires this bit to be set to 1. The 0 mode is for debug purpose
+                                                         0 = Device address is equal to slot ID.
+                                                         1 = Increment device address on each address device command.
+                                                         The xHCI compliance requires this bit to be set to 1. The 0 mode is for debug purpose
                                                          only. This allows you to easily identify a device connected to a port in the Lecroy or
                                                          Eliisys trace during hardware debug.
                                                          This bit is used in host mode only. */
@@ -3919,56 +4008,54 @@ union cvmx_usbdrdx_uahc_guctl {
                                                          a non-terminating retry ACK (i.e. an ACK transaction packet with Retry = 1 and NumP != 0).
                                                          If the auto-retry feature is disabled (default), the core responds with a terminating
                                                          retry ACK (i.e. an ACK transaction packet with Retry = 1 and NumP = 0). */
-	uint32_t enoverlapchk                 : 1;  /**< Enable Check for LFPS Overlap During Remote Ux Exit.
-                                                         If this bit is set to:
-                                                          - 1: The SuperSpeed link when exiting U1/U2/U3 waits for either
-                                                           the remote link LFPS or TS1/TS2 training symbols before it
-                                                           confirms that the LFPS handshake is complete. This is done to
-                                                           handle the case where the LFPS glitch causes the link to start
-                                                           exiting from the low power state. Looking for the LFPS overlap
-                                                           makes sure that the link partner also sees the LFPS.
-                                                          - 0: When the link exists U1/U2/U3 because of a remote exit, it
-                                                           does not look for an LFPS overlap. */
-	uint32_t extcapsupten                 : 1;  /**< External Extended Capability Support Enable.
-                                                         If disabled, a read USBDRD(0..1)_UAHC_SUPTPRT3_DW0[NEXTCAPPTR]
-                                                         will return 0 in the Next Capability Pointer field. This
-                                                         indicates there are no more capabilities. If enabled, a read
-                                                         to USBDRD(0..1)_UAHC_SUPTPRT3_DW0[NEXTCAPPTR] will return 4 in the
-                                                         Next Capability Pointer field.
+	uint32_t enoverlapchk                 : 1;  /**< Enable check for LFPS overlap during remote Ux Exit. If this bit is set to:
+                                                         0 = When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS
+                                                         overlap.
+                                                         1 = The SuperSpeed link, when exiting U1/U2/U3, waits for either the remote link LFPS or
+                                                         TS1/TS2 training symbols before it confirms that the LFPS handshake is complete. This is
+                                                         done to handle the case where the LFPS glitch causes the link to start exiting from the
+                                                         low power state. Looking for the LFPS overlap makes sure that the link partner also sees
+                                                         the LFPS. */
+	uint32_t extcapsupten                 : 1;  /**< External extended capability support enable. If disabled, a read
+                                                         USBDRD()_UAHC_SUPTPRT3_DW0
+                                                         [NEXTCAPPTR] returns 0 in the next capability pointer field. This indicates there are no
+                                                         more capabilities. If enabled, a read to USBDRD()_UAHC_SUPTPRT3_DW0[NEXTCAPPTR] returns 4
+                                                         in
+                                                         the
+                                                         next capability pointer field.
                                                          Always set to 0x0. */
-	uint32_t insrtextrfsbodi              : 1;  /**< Insert extra delay between FullSpeed bulk OUT transactions. Some FullSpeed devices are
+	uint32_t insrtextrfsbodi              : 1;  /**< Insert extra delay between full-speed bulk OUT transactions. Some full-speed devices are
                                                          slow to receive bulk OUT data and can get stuck when there are consecutive bulk OUT
-                                                         transactionswith short inter-transaction delays. This bit is used to control whether the
-                                                         host inserts extra delay between consecutive bulk OUT transactions to a FullSpeed
+                                                         transactions with short inter-transaction delays. This bit is used to control whether the
+                                                         host inserts extra delay between consecutive bulk OUT transactions to a full-speed
                                                          endpoint.
-                                                         1 = host inserts about 12us extra delay between consecutive bulk OUT transactions to an
-                                                         FullSpeed endpoint to work around the device issue.
-                                                         0 = host does not insert extra delay.
-                                                         Setting this bit to 1 reduces the bulk OUT transfer performance for most of the FullSpeed
-                                                         devices. */
+                                                         0 = Host does not insert extra delay.
+                                                         Setting this bit to 1 reduces the bulk OUT transfer performance for most of the full-speed
+                                                         devices.
+                                                         1 = Host inserts about 12 us extra delay between consecutive bulk OUT transactions to an
+                                                         full-speed endpoint to work around the device issue. */
 	uint32_t dtct                         : 2;  /**< Device timeout coarse tuning. This field determines how long the host waits for a response
                                                          from device before considering a timeout.
                                                          The core first checks the DTCT value. If it is 0, then the timeout value is defined by the
                                                          DTFT. If it is non-zero, then it uses the following timeout values:
-                                                         0x0 = 0 us; use DTFT value instead
-                                                         0x1 = 500 us
-                                                         0x2 = 1.5 ms
-                                                         0x3 = 6.5 ms */
+                                                         0x0 = 0 us; use DTFT value instead.
+                                                         0x1 = 500 us.
+                                                         0x2 = 1.5 ms.
+                                                         0x3 = 6.5 ms. */
 	uint32_t dtft                         : 9;  /**< Device timeout fine tuning. This field determines how long the host waits for a response
                                                          from a device before considering a timeout. For DTFT to take effect, DTCT must be set to
                                                          0x0.
                                                          The DTFT value specifies the number of 125MHz clock cycles * 256 to count before
                                                          considering a device timeout. For the 125 MHz clock cycles (8 ns period), this is
                                                          calculated as follows:
-                                                         [DTFT value] * 256 * 8 (ns)
-                                                         DTFT Value Calculation Timeout
-                                                         0x2 2 * 256 * 8 4 us
-                                                         0x5 5 * 256 * 8 10 us
-                                                         0xA 10 * 256 * 8 20 us
-                                                         0x10 16 * 256 * 8 32 us
-                                                         0x19 25 * 256 * 8 51 us
-                                                         0x31 49 * 256 * 8 100 us
-                                                         0x62 98 * 256 * 8 200 us */
+                                                         _ [DTFT value] * 256 * 8 (ns)
+                                                         0x2 = 2 * 256 * 8 -> 4 us.
+                                                         0x5 = 5 * 256 * 8 -> 10 us.
+                                                         0xA = 10 * 256 * 8 -> 20 us.
+                                                         0x10 = 16 * 256 * 8 -> 32 us.
+                                                         0x19 = 25 * 256 * 8 -> 51 us.
+                                                         0x31 = 49 * 256 * 8 -> 100 us.
+                                                         0x62 = 98 * 256 * 8 -> 200 us. */
 #else
 	uint32_t dtft                         : 9;
 	uint32_t dtct                         : 2;
@@ -3985,13 +4072,15 @@ union cvmx_usbdrdx_uahc_guctl {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_guctl_s      cn70xx;
+	struct cvmx_usbdrdx_uahc_guctl_s      cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_guctl cvmx_usbdrdx_uahc_guctl_t;
 
 /**
  * cvmx_usbdrd#_uahc_guctl1
  *
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.7.
  */
 union cvmx_usbdrdx_uahc_guctl1 {
@@ -3999,10 +4088,10 @@ union cvmx_usbdrdx_uahc_guctl1 {
 	struct cvmx_usbdrdx_uahc_guctl1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_2_31                : 30;
-	uint32_t ovrld_l1_susp_com            : 1;  /**< Always set to 0x0. */
-	uint32_t loa_filter_en                : 1;  /**< If this bit is set the USB 2.0 port babble is checked at least three
-                                                         consecutive times before the port is disabled. This prevents false
-                                                         triggering of the babble condition when using low quality cables.
+	uint32_t ovrld_l1_susp_com            : 1;  /**< Always set to 0. */
+	uint32_t loa_filter_en                : 1;  /**< If this bit is set, the USB 2.0 port babble is checked at least three consecutive times
+                                                         before the port is disabled. This prevents false triggering of the babble condition when
+                                                         using low quality cables.
                                                          This bit is only valid in host mode. */
 #else
 	uint32_t loa_filter_en                : 1;
@@ -4011,6 +4100,7 @@ union cvmx_usbdrdx_uahc_guctl1 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_guctl1_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_guctl1_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_guctl1 cvmx_usbdrdx_uahc_guctl1_t;
 
@@ -4020,10 +4110,12 @@ typedef union cvmx_usbdrdx_uahc_guctl1 cvmx_usbdrdx_uahc_guctl1_t;
  * This is a read/write register containing the User ID. The power-on value for this register is
  * specified as the User Identification Register. This register can be used in the following
  * ways:
- *   * To store the version or revision of your system
- *   * To store hardware configurations that are outside the core
- *   * As a scratch register
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * * To store the version or revision of your system.
+ * * To store hardware configurations that are outside of the core.
+ * * As a scratch register.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.10.
  */
 union cvmx_usbdrdx_uahc_guid {
@@ -4036,14 +4128,17 @@ union cvmx_usbdrdx_uahc_guid {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_guid_s       cn70xx;
+	struct cvmx_usbdrdx_uahc_guid_s       cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_guid cvmx_usbdrdx_uahc_guid_t;
 
 /**
  * cvmx_usbdrd#_uahc_gusb2i2cctl#
  *
- * Reserved for future use.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * This register is reserved for future use.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.2.
  */
 union cvmx_usbdrdx_uahc_gusb2i2cctlx {
@@ -4056,6 +4151,7 @@ union cvmx_usbdrdx_uahc_gusb2i2cctlx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gusb2i2cctlx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gusb2i2cctlx cvmx_usbdrdx_uahc_gusb2i2cctlx_t;
 
@@ -4064,10 +4160,11 @@ typedef union cvmx_usbdrdx_uahc_gusb2i2cctlx cvmx_usbdrdx_uahc_gusb2i2cctlx_t;
  *
  * This register is used to configure the core after power-on. It contains USB 2.0 and USB 2.0
  * PHY-related configuration parameters. The application must program this register before
- * starting any transactions on either the SoC bus or the USB.
- * Per-port registers are implemented.
- * Note: Do not make changes to this register after the initial programming.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * starting any transactions on either the SoC bus or the USB. Per-port registers are
+ * implemented.
+ *
+ * Do not make changes to this register after the initial programming.
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.1.
  */
 union cvmx_usbdrdx_uahc_gusb2phycfgx {
@@ -4075,19 +4172,18 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t physoftrst                   : 1;  /**< PHY soft reset. Causes the usb2phy_reset signal to be asserted to reset a UTMI PHY. */
-	uint32_t u2_freeclk_exists            : 1;  /**< Specifies whether your USB 2.0 PHY provides a free-running
-                                                          PHY clock, which is active when the clock control input is active.
-                                                          If your USB 2.0 PHY provides a free-running PHY clock, it must
-                                                          be connected to the utmi_clk[0] input. The remaining utmi_clk[n]
-                                                          must be connected to the respective port clocks. The core uses
-                                                          the Port-0 clock for generating the internal mac2 clock.
-                                                         - 0: USB 2.0 free clock does not exist
-                                                         - 1: USB 2.0 free clock exists
-                                                          Note: This field must be set to zero if you enable ITP generation based
-                                                          on the ref_clk counter, GCTL.SOFITPSYNC=1, or GFLADJ.
-                                                          GFLADJ_REFCLK_LPM_SEL=1. */
-	uint32_t ulpi_lpm_with_opmode_chk     : 1;  /**< Support the LPM over ULPI without NOPID token to the ULPI PHY.
-                                                         Always 0x0. */
+	uint32_t u2_freeclk_exists            : 1;  /**< Specifies whether your USB 2.0 PHY provides a free-running PHY clock, which is active when
+                                                         the clock control input is active. If your USB 2.0 PHY provides a free-running PHY clock,
+                                                         it must be connected to the utmi_clk[0] input. The remaining utmi_clk[n] must be connected
+                                                         to the respective port clocks. The core uses the Port-0 clock for generating the internal
+                                                         mac2 clock.
+                                                         0 = USB 2.0 free clock does not exist.
+                                                         1 = USB 2.0 free clock exists.
+                                                         This field must be set to zero if you enable ITP generation based on the REF_CLK
+                                                         counter, USBDRD()_UAHC_GCTL[SOFITPSYNC] = 1, or USBDRD()_UAHC_GFLADJ
+                                                         [GFLADJ_REFCLK_LPM_SEL] =
+                                                         1. */
+	uint32_t ulpi_lpm_with_opmode_chk     : 1;  /**< Support the LPM over ULPI without NOPID token to the ULPI PHY. Always 0x0. */
 	uint32_t reserved_19_28               : 10;
 	uint32_t ulpiextvbusindicator         : 1;  /**< Reserved (unused in this configuration). */
 	uint32_t ulpiextvbusdrv               : 1;  /**< Reserved (unused in this configuration). */
@@ -4097,12 +4193,9 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
 	uint32_t usbtrdtim                    : 4;  /**< USB 2.0 turnaround time. Sets the turnaround time in PHY clock cycles. Specifies the
                                                          response time for a MAC request to the packet FIFO controller (PFC) to fetch data from the
                                                          DFIFO (SPRAM).
-                                                         The following are the required values for the minimum SoC bus frequency of 60 MHz. USB
-                                                         turnaround time is a critical certification criteria when using long cables and five hub
-                                                         levels.
-                                                         When the MAC interface is 8-bit UTMI+/ULPI, the required values for this field is 0x9.
-                                                         If SoC bus clock is less than 60 MHz, and USB turnaround time is not critical, this field
-                                                         can be set to a larger value. */
+                                                         USB turnaround time is a critical certification criteria when using long cables and five
+                                                         hub levels.
+                                                         When the MAC interface is 8-bit UTMI+/ULPI, the required values for this field is 0x9. */
 	uint32_t xcvrdly                      : 1;  /**< Transceiver Delay
                                                          Enables a delay between the assertion of the UTMI Transceiver Select signal (for
                                                          HighSpeed) and the assertion of the TxValid signal during a HighSpeed Chirp.
@@ -4112,16 +4205,15 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
                                                          This bit is only valid in device mode. */
 	uint32_t enblslpm                     : 1;  /**< Enable utmi_sleep_n and utmi_l1_suspend_n. The application uses this field to control
                                                          utmi_sleep_n and utmi_l1_suspend_n assertion to the PHY in the L1 state.
+                                                         0 = utmi_sleep_n and utmi_l1_suspend_n assertion from the core is not transferred to the
+                                                         external PHY.
                                                          1 = utmi_sleep_n and utmi_l1_suspend_n assertion from the core is transferred to the
                                                          external PHY.
-                                                         0 = utmi_sleep_n and utmi_l1_suspend_n assertion from the core is not transferred to
-                                                         the external PHY.
                                                          When hardware LPM is enabled, this bit should be set high for Port0. */
-	uint32_t physel                       : 1;  /**< USB 2.0 HighSpeed PHY or USB 1.1 FullSpeed Serial Transceiver Select */
-	uint32_t susphy                       : 1;  /**< Suspend USB2.0 HighSpeed/FullSpeed/LowSpeed PHY. When set, USB2.0 PHY enters suspend mode
-                                                         if suspend conditions are valid. Application needs to set this bit to 1 after the
-                                                         core initialization is completed. */
-	uint32_t fsintf                       : 1;  /**< FullSpeed serial-interface select. Always reads as 0x0. */
+	uint32_t physel                       : 1;  /**< USB 2.0 high-speed PHY or USB 1.1 full-speed serial transceiver select. */
+	uint32_t susphy                       : 1;  /**< Suspend USB2.0 high-speed/full-speed/low-speed PHY. When set, USB2.0 PHY enters suspend
+                                                         mode if suspend conditions are valid. */
+	uint32_t fsintf                       : 1;  /**< Full-speed serial-interface select. Always reads as 0x0. */
 	uint32_t ulpi_utmi_sel                : 1;  /**< ULPI or UTMI+ select. Always reads as 0x0, indicating UTMI+. */
 	uint32_t phyif                        : 1;  /**< PHY interface width: 1 = 16-bit, 0 = 8-bit.
                                                          All the enabled 2.0 ports should have the same clock frequency as Port0 clock frequency
@@ -4129,23 +4221,23 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
                                                          The UTMI 8-bit and 16-bit modes cannot be used together for different ports at the same
                                                          time (i.e., all the ports should be in 8-bit mode, or all of them should be in 16-bit
                                                          mode). */
-	uint32_t toutcal                      : 3;  /**< High/FullSpeed timeout calibration.
+	uint32_t toutcal                      : 3;  /**< High-speed/full-speed timeout calibration.
                                                          The number of PHY clock cycles, as indicated by the application in this field, is
-                                                         multiplied by a bit-time factor; this factor is added to the HighSpeed/FullSpeed
+                                                         multiplied by a bit-time factor; this factor is added to the high-speed/full-speed
                                                          interpacket timeout duration in the core to account for additional delays introduced by
                                                          the PHY. This might be required, since the delay introduced by the PHY in generating the
                                                          linestate condition can vary among PHYs.
-                                                         The USB standard timeout value for HighSpeed operation is 736 to 816 (inclusive) bit
-                                                         times. The USB standard timeout value for FullSpeed operation is 16 to 18 (inclusive) bit
+                                                         The USB standard timeout value for high-speed operation is 736 to 816 (inclusive) bit
+                                                         times. The USB standard timeout value for full-speed operation is 16 to 18 (inclusive) bit
                                                          times. The application must program this field based on the speed of connection.
                                                          The number of bit times added per PHY clock are:
-                                                         HighSpeed operation:
-                                                         - one 30-MHz PHY clock = 16 bit times
-                                                         - one 60-MHz PHY clock = 8 bit times
-                                                         FullSpeed operation:
-                                                         - one 30-MHz PHY clock = 0.4 bit times
-                                                         - one 60-MHz PHY clock = 0.2 bit times
-                                                         - one 48-MHz PHY clock = 0.25 bit times */
+                                                         * High-speed operation:
+                                                         - one 30-MHz PHY clock = 16 bit times.
+                                                         - one 60-MHz PHY clock = 8 bit times.
+                                                         * Full-speed operation:
+                                                         - one 30-MHz PHY clock = 0.4 bit times.
+                                                         - one 60-MHz PHY clock = 0.2 bit times.
+                                                         - one 48-MHz PHY clock = 0.25 bit times. */
 #else
 	uint32_t toutcal                      : 3;
 	uint32_t phyif                        : 1;
@@ -4168,6 +4260,7 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gusb2phycfgx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gusb2phycfgx cvmx_usbdrdx_uahc_gusb2phycfgx_t;
 
@@ -4176,66 +4269,65 @@ typedef union cvmx_usbdrdx_uahc_gusb2phycfgx cvmx_usbdrdx_uahc_gusb2phycfgx_t;
  *
  * This register is used to configure the core after power-on. It contains USB 3.0 and USB 3.0
  * PHY-related configuration parameters. The application must program this register before
- * starting any transactions on either the SoC bus or the USB.
- * Per-port registers are implemented.
- * Note: Do not make changes to this register after the initial programming.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET].
+ * starting any transactions on either the SoC bus or the USB. Per-port registers are
+ * implemented.
+ *
+ * Do not make changes to this register after the initial programming.
+ *
  * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.4.
  */
 union cvmx_usbdrdx_uahc_gusb3pipectlx {
 	uint32_t u32;
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t physoftrst                   : 1;  /**< USB3 PHY Soft Reset (PHYSoftRst)
-                                                         After setting this bit to 1, the software needs to clear this bit.
-                                                         INTERNAL: For more information, refer to Synopsys Databook Figure 5-8 on page 253. */
+	uint32_t physoftrst                   : 1;  /**< USB3 PHY soft reset (PHYSoftRst). When set to 1, initiates a PHY soft reset. After setting
+                                                         this bit to 1, the software needs to clear this bit. */
 	uint32_t hstprtcmpl                   : 1;  /**< Host port compliance. Setting this bit to 1 enables placing the SuperSpeed port link into
                                                          a compliance state, which allows testing of the PIPE PHY compliance patterns without
-                                                         having to have a test fixture on the USB 3.0 cable. By default, this bit should be set
-                                                         to 0.
+                                                         having to have a test fixture on the USB 3.0 cable. By default, this bit should be set to
+                                                         0.
                                                          In compliance-lab testing, the SuperSpeed port link enters compliance after failing the
-                                                         first polling sequence after power on. Set this bit to 0, when you run compliance tests.
+                                                         first polling sequence after power on. Set this bit to 0 when you run compliance tests.
                                                          The sequence for using this functionality is as follows:
-                                                         Disconnect any plugged in devices.
-                                                         Set USBDRD(0..1)_UAHC_USBCMD[HCRST] = 1 or power-on-chip reset.
-                                                         Set USBDRD(0..1)_UAHC_PORTSC[PP] = 0.
-                                                         Set HSTPRTCMPL = 1. This places the link into compliance state.
+                                                         * Disconnect any plugged-in devices.
+                                                         * Set USBDRD()_UAHC_USBCMD[HCRST] = 1 or power-on-chip reset.
+                                                         * Set USBDRD()_UAHC_PORTSC()[PP] = 0.
+                                                         * Set HSTPRTCMPL = 1. This places the link into compliance state.
                                                          To advance the compliance pattern, follow this sequence (toggle HSTPRTCMPL):
-                                                         Set HSTPRTCMPL = 0.
-                                                         Set HSTPRTCMPL = 1. Toggle the HSTPRTCMPL bit to advance the link to the next compliance
-                                                         pattern.
-                                                         To exit from the compliance state, set UAHC_USBCMD[HCRST = 1 or power-on-chip reset. */
-	uint32_t u2ssinactp3ok                : 1;  /**< P3 OK for U2/SSInactive:
-                                                         1 = during link state U2/SS.Inactive, put PHY in P3
-                                                         0 = during link state U2/SS.Inactive, put PHY in P2 (Default) */
+                                                         * Set HSTPRTCMPL = 0.
+                                                         * Set HSTPRTCMPL = 1. This advances the link to the next compliance pattern.
+                                                         To exit from the compliance state, set USBDRD()_UAHC_USBCMD[HCRST] = 1 or power-on-chip
+                                                         reset. */
+	uint32_t u2ssinactp3ok                : 1;  /**< P3 OK for U2/SS.Inactive:
+                                                         0 = During link state U2/SS.Inactive, put PHY in P2 (default).
+                                                         1 = During link state U2/SS.Inactive, put PHY in P3. */
 	uint32_t disrxdetp3                   : 1;  /**< Disables receiver detection in P3. If PHY is in P3 and the core needs to perform receiver
                                                          detection:
-                                                         1 = core changes the PHY power state to P2 and then performs receiver detection. After
-                                                         receiver detection, core changes PHY power state to P3.
-                                                         0 = core performs receiver detection in P3 (default) */
+                                                         0 = Core performs receiver detection in P3 (default).
+                                                         1 = Core changes the PHY power state to P2 and then performs receiver detection. After
+                                                         receiver detection, core changes PHY power state to P3. */
 	uint32_t ux_exit_in_px                : 1;  /**< UX exit in Px:
-                                                         1 = the core does U1/U2/U3 exit in PHY power state P1/P2/P3 respectively
-                                                         0 = the core does U1/U2/U3 exit in PHY power state P0 (default behavior)
-                                                         This bit is added for SuperSpeed PHY workaround where SuperSpeed PHY injects a glitch
-                                                         on pipe3_RxElecIdle while receiving Ux exit LFPS, and pipe3_PowerDown change is in
-                                                         progress.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         0 = Core does U1/U2/U3 exit in PHY power state P0 (default behavior).
+                                                         1 = Core does U1/U2/U3 exit in PHY power state P1/P2/P3 respectively.
+                                                         This bit is added for SuperSpeed PHY workaround where SuperSpeed PHY injects a glitch on
+                                                         pipe3_RxElecIdle while receiving Ux exit LFPS, and pipe3_PowerDown change is in progress.
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t ping_enchance_en             : 1;  /**< Ping enhancement enable. When set to 1, the downstream-port U1-ping-receive timeout
                                                          becomes 500 ms instead of 300 ms. Minimum Ping.LFPS receive duration is 8 ns (one mac3_clk
                                                          cycle). This field is valid for the downstream port only.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t u1u2exitfail_to_recov        : 1;  /**< U1U2exit fail to recovery. When set to 1, and U1/U2 LFPS handshake fails, the LTSSM
-                                                         transitions from U1/U2 to recovery instead of SS inactive.
+                                                         transitions from U1/U2 to recovery instead of SS.inactive.
                                                          If recovery fails, then the LTSSM can enter SS.Inactive. This is an enhancement only. It
                                                          prevents interoperability issue if the remote link does not do the proper handshake. */
 	uint32_t request_p1p2p3               : 1;  /**< Always request P1/P2/P3 for U1/U2/U3.
-                                                         1 = the core always requests PHY power change from P0 to P1/P2/P3 during U0 to U1/U2/U3
-                                                         transition.
                                                          0 = if immediate Ux exit (remotely initiated, or locally initiated) happens, the core does
                                                          not request P1/P2/P3 power state change.
-                                                         INTERNAL: Note: This bit should be set to '1' for Synopsys PHY. For third-party SuperSpeed
+                                                         1 = the core always requests PHY power change from P0 to P1/P2/P3 during U0 to U1/U2/U3
+                                                         transition.
+                                                         INTERNAL: Note: This bit should be set to 1 for Synopsys PHY. For third-party SuperSpeed
                                                          PHY, check with your PHY vendor. */
 	uint32_t startrxdetu3rxdet            : 1;  /**< Start receiver detection in U3/Rx.Detect.
                                                          If DISRXDETU3RXDET is set to 1 during reset, and the link is in U3 or Rx.Detect state, the
@@ -4255,65 +4347,63 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
                                                          INTERNAL: Should always be 0x1 for a Synopsys PHY. */
 	uint32_t delaypxtransenterux          : 1;  /**< Delay PHY power change from P0 to P1/P2/P3 when link state changing from U0 to U1/U2/U3
                                                          respectively.
-                                                         1 = when entering U1/U2/U3, delay the transition to P1/P2/P3 until the pipe3 signals,
-                                                         Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0
                                                          0 = when entering U1/U2/U3, transition to P1/P2/P3 without checking for Pipe3_RxElecIlde
                                                          and pipe3_RxValid.
+                                                         1 = when entering U1/U2/U3, delay the transition to P1/P2/P3 until the pipe3 signals,
+                                                         Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0.
                                                          INTERNAL: Note: This bit should be set to '1' for Synopsys PHY. It is also used by third-
                                                          party SuperSpeed PHY. */
 	uint32_t suspend_en                   : 1;  /**< Suspend USB3.0 SuperSpeed PHY (Suspend_en). When set to 1, and if suspend conditions are
-                                                         valid, the USB 3.0 PHY enters suspend mode. Application
-                                                         needs to set this bit to 1 after the core initialization is completed. */
+                                                         valid, the USB 3.0 PHY enters suspend mode. */
 	uint32_t datwidth                     : 2;  /**< PIPE data width.
-                                                         0x0 = 32 bits
-                                                         0x1 = 16 bits
-                                                         0x2 = 8 bits
-                                                         0x3 = reserved
+                                                         0x0 = 32 bits.
+                                                         0x1 = 16 bits.
+                                                         0x2 = 8 bits.
+                                                         0x3 = reserved.
                                                          One clock cycle after reset, these bits receive the value seen on the pipe3_DataBusWidth.
                                                          This will always be 0x0.
                                                          INTERNAL: The simulation testbench uses the coreConsultant parameter to configure the VIP.
-                                                                   These bits in the coreConsultant parameter should match your PHY data width and
+                                                         INTERNAL: These bits in the coreConsultant parameter should match your PHY data width and
                                                          the pipe3_DataBusWidth port. */
-	uint32_t abortrxdetinu2               : 1;  /**< Abort Rx Detect in U2.
-                                                         When set, and the link state is U2, then the core will abort receiver
+	uint32_t abortrxdetinu2               : 1;  /**< Abort RX Detect in U2. When set to 1, and the link state is U2, the core aborts receiver
                                                          detection if it receives U2 exit LFPS from the remote link partner.
                                                          This bit is for downstream port only.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t skiprxdet                    : 1;  /**< Skip RX detect. When set to 1, the core skips RX detection if pipe3_RxElecIdle is low.
                                                          Skip is defined as waiting for the appropriate timeout, then repeating the operation. */
 	uint32_t lfpsp0algn                   : 1;  /**< LFPS P0 align. When set to 1:
-                                                         the core deasserts LFPS transmission on the clock edge that it requests Phy power state 0
-                                                         when exiting U1, U2, or U3 low power states. Otherwise, LFPS transmission is asserted one
-                                                         clock earlier.
-                                                         the core requests symbol transmission two pipe3_rx_pclks periods after the PHY asserts
+                                                         * the core deasserts LFPS transmission on the clock edge that it requests Phy power state
+                                                         0 when exiting U1, U2, or U3 low power states. Otherwise, LFPS transmission is asserted
+                                                         one clock earlier.
+                                                         * the core requests symbol transmission two pipe3_rx_pclks periods after the PHY asserts
                                                          PhyStatus as a result of the PHY switching from P1 or P2 state to P0 state.
-                                                         For USB 3.0 Host, Device, and DRD cores this is not required. */
+                                                         For USB 3.0 host, this is not required. */
 	uint32_t p3p2tranok                   : 1;  /**< P3 P2 transitions OK.
-                                                         1 = the core transitions directly from Phy power state P2 to P3 or from state P3 to P2.
                                                          0 = P0 is always entered as an intermediate state during transitions between P2 and P3, as
                                                          defined in the PIPE3 specification.
+                                                         1 = the core transitions directly from Phy power state P2 to P3 or from state P3 to P2.
                                                          According to PIPE3 specification, any direct transition between P3 and P2 is illegal.
                                                          INTERNAL: This bit is used only for some non-Synopsys PHYs that cannot do LFPS in P3.
-                                                                   Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t p3exsigp2                    : 1;  /**< P3 exit signal in P2. When set to 1, the core always changes the PHY power state to P2,
                                                          before attempting a U3 exit handshake.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to '0'
-                                                         for Synopsys PHY. */
+                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
+                                                         Synopsys PHY. */
 	uint32_t lfpsfilt                     : 1;  /**< LFPS filter. When set to 1, filter LFPS reception with pipe3_RxValid in PHY power state
                                                          P0, ignore LFPS reception from the PHY unless both pipe3_Rxelecidle and pipe3_RxValid are
                                                          deasserted. */
-	uint32_t rxdet2polllfpsctrl           : 1;  /**< RX_DETECT to Polling.LFPS Control
-                                                         * 0x0 (Default): Enables a 400us delay to start Polling LFPS after
-                                                           RX_DETECT. This allows VCM offset to settle to a proper level.
-                                                         * 0x1: Disables the 400us delay to start Polling LFPS after RX_DETECT. */
+	uint32_t rxdet2polllfpsctrl           : 1;  /**< RX_DETECT to Polling.
+                                                         0 = Enables a 400 us delay to start polling LFPS after RX_DETECT. This allows VCM offset
+                                                         to settle to a proper level.
+                                                         1 = Disables the 400 us delay to start polling LFPS after RX_DETECT. */
 	uint32_t reserved_7_7                 : 1;
-	uint32_t txswing                      : 1;  /**< Tx swing. Refer to the PIPE3 specificiation. */
-	uint32_t txmargin                     : 3;  /**< Tx margin. Refer to the PIPE3 specificiation, table 5-3. */
-	uint32_t txdeemphasis                 : 2;  /**< Tx de-emphasis. The value driven to the PHY is controlled by the LTSSM during USB3
-                                                         compliance mode. Refer to the PIPE3 specificiation, table 5-3. */
-	uint32_t elasticbuffermode            : 1;  /**< Elastic buffer mode. Refer to the PIPE3 specificiation, table 5-3. */
+	uint32_t txswing                      : 1;  /**< TX swing. Refer to the PIPE3 specification. */
+	uint32_t txmargin                     : 3;  /**< TX margin. Refer to the PIPE3 specification, table 5-3. */
+	uint32_t txdeemphasis                 : 2;  /**< TX de-emphasis. The value driven to the PHY is controlled by the LTSSM during USB3
+                                                         compliance mode. Refer to the PIPE3 specification, table 5-3. */
+	uint32_t elasticbuffermode            : 1;  /**< Elastic buffer mode. Refer to the PIPE3 specification, table 5-3. */
 #else
 	uint32_t elasticbuffermode            : 1;
 	uint32_t txdeemphasis                 : 2;
@@ -4344,20 +4434,21 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_gusb3pipectlx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_gusb3pipectlx cvmx_usbdrdx_uahc_gusb3pipectlx_t;
 
 /**
  * cvmx_usbdrd#_uahc_hccparams
  *
- * See XHCI specification v1.0 section 5.3.6.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.3.6.
  *
  */
 union cvmx_usbdrdx_uahc_hccparams {
 	uint32_t u32;
 	struct cvmx_usbdrdx_uahc_hccparams_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t xecp                         : 16; /**< XHCI extended capabilities pointer. */
+	uint32_t xecp                         : 16; /**< xHCI extended capabilities pointer. */
 	uint32_t maxpsasize                   : 4;  /**< Maximum primary-stream-array size. */
 	uint32_t reserved_9_11                : 3;
 	uint32_t pae                          : 1;  /**< Parse all event data. */
@@ -4365,7 +4456,7 @@ union cvmx_usbdrdx_uahc_hccparams {
 	uint32_t ltc                          : 1;  /**< Latency tolerance messaging capability. */
 	uint32_t lhrc                         : 1;  /**< Light HC reset capability. */
 	uint32_t pind                         : 1;  /**< Port indicators. */
-	uint32_t ppc                          : 1;  /**< Port power control. Value is based on USBDRD(0..1)_UCTL_HOST_CFG[PPC_EN]. */
+	uint32_t ppc                          : 1;  /**< Port power control. Value is based on USBDRD()_UCTL_HOST_CFG[PPC_EN]. */
 	uint32_t csz                          : 1;  /**< Context size. */
 	uint32_t bnc                          : 1;  /**< BW negotiation capability. */
 	uint32_t ac64                         : 1;  /**< 64-bit addressing capability. */
@@ -4385,13 +4476,14 @@ union cvmx_usbdrdx_uahc_hccparams {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_hccparams_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_hccparams_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_hccparams cvmx_usbdrdx_uahc_hccparams_t;
 
 /**
  * cvmx_usbdrd#_uahc_hcsparams1
  *
- * See XHCI specification v1.0 section 5.3.3.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.3.3.
  *
  */
 union cvmx_usbdrdx_uahc_hcsparams1 {
@@ -4410,13 +4502,14 @@ union cvmx_usbdrdx_uahc_hcsparams1 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams1_s cn70xx;
+	struct cvmx_usbdrdx_uahc_hcsparams1_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams1 cvmx_usbdrdx_uahc_hcsparams1_t;
 
 /**
  * cvmx_usbdrd#_uahc_hcsparams2
  *
- * See XHCI specification v1.0 section 5.3.4.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.3.4.
  *
  */
 union cvmx_usbdrdx_uahc_hcsparams2 {
@@ -4439,13 +4532,14 @@ union cvmx_usbdrdx_uahc_hcsparams2 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams2_s cn70xx;
+	struct cvmx_usbdrdx_uahc_hcsparams2_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams2 cvmx_usbdrdx_uahc_hcsparams2_t;
 
 /**
  * cvmx_usbdrd#_uahc_hcsparams3
  *
- * See XHCI specification v1.0 section 5.3.5.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.3.5.
  *
  */
 union cvmx_usbdrdx_uahc_hcsparams3 {
@@ -4462,17 +4556,19 @@ union cvmx_usbdrdx_uahc_hcsparams3 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_hcsparams3_s cn70xx;
+	struct cvmx_usbdrdx_uahc_hcsparams3_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_hcsparams3 cvmx_usbdrdx_uahc_hcsparams3_t;
 
 /**
  * cvmx_usbdrd#_uahc_iman#
  *
- * See XHCI specification v1.0 section 5.5.2.1.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.1.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_imanx {
 	uint32_t u32;
@@ -4480,8 +4576,7 @@ union cvmx_usbdrdx_uahc_imanx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_2_31                : 30;
 	uint32_t ie                           : 1;  /**< Interrupt enable. */
-	uint32_t ip                           : 1;  /**< Interrupt pending.
-                                                         Throws USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_UAHC_IMAN(0..0)_IP. */
+	uint32_t ip                           : 1;  /**< Interrupt pending. */
 #else
 	uint32_t ip                           : 1;
 	uint32_t ie                           : 1;
@@ -4489,17 +4584,19 @@ union cvmx_usbdrdx_uahc_imanx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_imanx_s      cn70xx;
+	struct cvmx_usbdrdx_uahc_imanx_s      cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_imanx cvmx_usbdrdx_uahc_imanx_t;
 
 /**
  * cvmx_usbdrd#_uahc_imod#
  *
- * See XHCI specification v1.0 section 5.5.2.2.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.2.2.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_imodx {
 	uint32_t u32;
@@ -4513,17 +4610,19 @@ union cvmx_usbdrdx_uahc_imodx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_imodx_s      cn70xx;
+	struct cvmx_usbdrdx_uahc_imodx_s      cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_imodx cvmx_usbdrdx_uahc_imodx_t;
 
 /**
  * cvmx_usbdrd#_uahc_mfindex
  *
- * See XHCI specification v1.0 section 5.5.1.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.5.1.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_mfindex {
 	uint32_t u32;
@@ -4537,13 +4636,14 @@ union cvmx_usbdrdx_uahc_mfindex {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_mfindex_s    cn70xx;
+	struct cvmx_usbdrdx_uahc_mfindex_s    cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_mfindex cvmx_usbdrdx_uahc_mfindex_t;
 
 /**
  * cvmx_usbdrd#_uahc_pagesize
  *
- * See XHCI specification v1.0 section 5.4.3.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.3.
  *
  */
 union cvmx_usbdrdx_uahc_pagesize {
@@ -4558,25 +4658,38 @@ union cvmx_usbdrdx_uahc_pagesize {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_pagesize_s   cn70xx;
+	struct cvmx_usbdrdx_uahc_pagesize_s   cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_pagesize cvmx_usbdrdx_uahc_pagesize_t;
 
 /**
  * cvmx_usbdrd#_uahc_porthlpmc_20#
  *
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_DCTL[CSFTRST].
- * See XHCI specification v1.? section ?.
- * INTERNAL: TODO (new unreleased XHCI errata!)
+ * For information on this register, refer to the xHCI Specification, v1.1, section 5.4.11.2.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_porthlpmc_20x {
 	uint32_t u32;
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_14_31               : 18;
-	uint32_t hirdd                        : 4;  /**< TODO unreleased XHCI errata */
-	uint32_t l1_timeout                   : 8;  /**< TODO: unreleased XHCI errata */
+	uint32_t hirdd                        : 4;  /**< See section 5.4.11.2 of the XHCI Spec 1.1.
+                                                         If USBDRD()_UAHC_SUPTPRT2_DW2[BLC] = 0, then HIRD timing is applied to this field.
+                                                         If USBDRD()_UAHC_SUPTPRT2_DW2[BLC] = 1, then BESL timing is applied to this field. */
+	uint32_t l1_timeout                   : 8;  /**< Timeout value for the L1 inactivity timer (LPM Timer). This field is set to 0x0 by the
+                                                         assertion of PR to 1. Refer to section 4.23.5.1.1.1 (in XHCI spec 1.1) for more
+                                                         information on L1 Timeout operation.
+                                                         The following are permissible values:
+                                                         0x0 =  128 us. (default).
+                                                         0x1 =  256 us.
+                                                         0x2 =  512 us.
+                                                         0x3 =  768 us.
+                                                         _ ...
+                                                         0xFF =  65280 us. */
 	uint32_t hirdm                        : 2;  /**< Host-initiated resume-duration mode. */
 #else
 	uint32_t hirdm                        : 2;
@@ -4586,17 +4699,20 @@ union cvmx_usbdrdx_uahc_porthlpmc_20x {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn70xx;
+	struct cvmx_usbdrdx_uahc_porthlpmc_20x_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_porthlpmc_20x cvmx_usbdrdx_uahc_porthlpmc_20x_t;
 
 /**
  * cvmx_usbdrd#_uahc_porthlpmc_ss#
  *
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_DCTL[CSFTRST].
- * See XHCI specification v1.? section ?.
- * INTERNAL: TODO: (new unreleased XHCI errata!)
+ * The USB3 Port Hardware LPM Control register is reserved and shall be treated as RsvdP by
+ * software. See xHCI specification v1.1 section 5.4.11.1.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST].
  */
 union cvmx_usbdrdx_uahc_porthlpmc_ssx {
 	uint32_t u32;
@@ -4608,13 +4724,14 @@ union cvmx_usbdrdx_uahc_porthlpmc_ssx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_porthlpmc_ssx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_porthlpmc_ssx cvmx_usbdrdx_uahc_porthlpmc_ssx_t;
 
 /**
  * cvmx_usbdrd#_uahc_portli_20#
  *
- * See XHCI specification v1.0 section 5.4.10.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.10.
  *
  */
 union cvmx_usbdrdx_uahc_portli_20x {
@@ -4627,13 +4744,14 @@ union cvmx_usbdrdx_uahc_portli_20x {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_portli_20x_s cn70xx;
+	struct cvmx_usbdrdx_uahc_portli_20x_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_portli_20x cvmx_usbdrdx_uahc_portli_20x_t;
 
 /**
  * cvmx_usbdrd#_uahc_portli_ss#
  *
- * See XHCI specification v1.0 section 5.4.10.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.10.
  *
  */
 union cvmx_usbdrdx_uahc_portli_ssx {
@@ -4648,16 +4766,19 @@ union cvmx_usbdrdx_uahc_portli_ssx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_portli_ssx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_portli_ssx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_portli_ssx cvmx_usbdrdx_uahc_portli_ssx_t;
 
 /**
  * cvmx_usbdrd#_uahc_portpmsc_20#
  *
- * See XHCI specification v1.0 section 5.4.9.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.9.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST].
  */
 union cvmx_usbdrdx_uahc_portpmsc_20x {
 	uint32_t u32;
@@ -4681,16 +4802,19 @@ union cvmx_usbdrdx_uahc_portpmsc_20x {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn70xx;
+	struct cvmx_usbdrdx_uahc_portpmsc_20x_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_portpmsc_20x cvmx_usbdrdx_uahc_portpmsc_20x_t;
 
 /**
  * cvmx_usbdrd#_uahc_portpmsc_ss#
  *
- * See XHCI specification v1.0 section 5.4.9.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.9.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST].
  */
 union cvmx_usbdrdx_uahc_portpmsc_ssx {
 	uint32_t u32;
@@ -4708,17 +4832,20 @@ union cvmx_usbdrdx_uahc_portpmsc_ssx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn70xx;
+	struct cvmx_usbdrdx_uahc_portpmsc_ssx_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_portpmsc_ssx cvmx_usbdrdx_uahc_portpmsc_ssx_t;
 
 /**
  * cvmx_usbdrd#_uahc_portsc#
  *
- * See XHCI specification v1.0 section 5.4.8.
- * Port 1 is USB3.0 SuperSpeed link. Port 0 is USB2.0 HighSpeed/FullSpeed/LowSpeed link.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.8. Port 1
+ * is USB3.0 SuperSpeed link, Port 0 is USB2.0 high-speed/full-speed/low-speed link.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST].
  */
 union cvmx_usbdrdx_uahc_portscx {
 	uint32_t u32;
@@ -4776,13 +4903,14 @@ union cvmx_usbdrdx_uahc_portscx {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_portscx_s    cn70xx;
+	struct cvmx_usbdrdx_uahc_portscx_s    cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_portscx cvmx_usbdrdx_uahc_portscx_t;
 
 /**
  * cvmx_usbdrd#_uahc_rtsoff
  *
- * See XHCI specification v1.0 section 5.3.8.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.3.8.
  *
  */
 union cvmx_usbdrdx_uahc_rtsoff {
@@ -4797,13 +4925,14 @@ union cvmx_usbdrdx_uahc_rtsoff {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_rtsoff_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_rtsoff_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_rtsoff cvmx_usbdrdx_uahc_rtsoff_t;
 
 /**
  * cvmx_usbdrd#_uahc_suptprt2_dw0
  *
- * See XHCI specification v1.0 section 7.2.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.2.
  *
  */
 union cvmx_usbdrdx_uahc_suptprt2_dw0 {
@@ -4822,13 +4951,14 @@ union cvmx_usbdrdx_uahc_suptprt2_dw0 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn70xx;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw0_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw0 cvmx_usbdrdx_uahc_suptprt2_dw0_t;
 
 /**
  * cvmx_usbdrd#_uahc_suptprt2_dw1
  *
- * See XHCI specification v1.0 section 7.2.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.2.
  *
  */
 union cvmx_usbdrdx_uahc_suptprt2_dw1 {
@@ -4841,13 +4971,14 @@ union cvmx_usbdrdx_uahc_suptprt2_dw1 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn70xx;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw1_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw1 cvmx_usbdrdx_uahc_suptprt2_dw1_t;
 
 /**
  * cvmx_usbdrd#_uahc_suptprt2_dw2
  *
- * See XHCI specification v1.0 section 7.2.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.2.
  *
  */
 union cvmx_usbdrdx_uahc_suptprt2_dw2 {
@@ -4856,10 +4987,10 @@ union cvmx_usbdrdx_uahc_suptprt2_dw2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t psic                         : 4;  /**< Protocol speed ID count. */
 	uint32_t reserved_21_27               : 7;
-	uint32_t blc                          : 1;  /**< BESL LPM Capability. */
-	uint32_t hlc                          : 1;  /**< Hardware LMP Capability. */
+	uint32_t blc                          : 1;  /**< BESL LPM capability. */
+	uint32_t hlc                          : 1;  /**< Hardware LMP capability. */
 	uint32_t ihi                          : 1;  /**< Integrated hub implemented. */
-	uint32_t hso                          : 1;  /**< HighSpeed only. */
+	uint32_t hso                          : 1;  /**< High-speed only. */
 	uint32_t reserved_16_16               : 1;
 	uint32_t compatprtcnt                 : 8;  /**< Compatible port count. */
 	uint32_t compatprtoff                 : 8;  /**< Compatible port offset. */
@@ -4876,14 +5007,15 @@ union cvmx_usbdrdx_uahc_suptprt2_dw2 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn70xx;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw2_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw2 cvmx_usbdrdx_uahc_suptprt2_dw2_t;
 
 /**
  * cvmx_usbdrd#_uahc_suptprt2_dw3
  *
- * See XHCI specification v1.? section 7.2.
- * INTERNAL: TODO (new unreleased XHCI errata!)
+ * For information on this register, refer to the xHCI Specification, v1.1, section 7.2.
+ *
  */
 union cvmx_usbdrdx_uahc_suptprt2_dw3 {
 	uint32_t u32;
@@ -4897,13 +5029,14 @@ union cvmx_usbdrdx_uahc_suptprt2_dw3 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn70xx;
+	struct cvmx_usbdrdx_uahc_suptprt2_dw3_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt2_dw3 cvmx_usbdrdx_uahc_suptprt2_dw3_t;
 
 /**
  * cvmx_usbdrd#_uahc_suptprt3_dw0
  *
- * See XHCI specification v1.0 section 7.2.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.2.
  *
  */
 union cvmx_usbdrdx_uahc_suptprt3_dw0 {
@@ -4912,9 +5045,10 @@ union cvmx_usbdrdx_uahc_suptprt3_dw0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t majorrev                     : 8;  /**< Major revision. */
 	uint32_t minorrev                     : 8;  /**< Minor revision. */
-	uint32_t nextcapptr                   : 8;  /**< Next Capability Pointer
-                                                         Value depends on USBDRD(0..1)_UAHC_GUCTL[EXTCAPSUPTEN].
-                                                         If EXTCAPSUPTEN = 0, value is 0x0. If = 1, value is 0x4. */
+	uint32_t nextcapptr                   : 8;  /**< Next capability pointer. Value depends on USBDRD()_UAHC_GUCTL[EXTCAPSUPTEN]. If
+                                                         EXTCAPSUPTEN
+                                                         =
+                                                         0, value is 0x0. If EXTCAPSUPTEN = 1, value is 0x4. */
 	uint32_t capid                        : 8;  /**< Capability ID = supported protocol. */
 #else
 	uint32_t capid                        : 8;
@@ -4924,13 +5058,14 @@ union cvmx_usbdrdx_uahc_suptprt3_dw0 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn70xx;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw0_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw0 cvmx_usbdrdx_uahc_suptprt3_dw0_t;
 
 /**
  * cvmx_usbdrd#_uahc_suptprt3_dw1
  *
- * See XHCI specification v1.0 section 7.2.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.2.
  *
  */
 union cvmx_usbdrdx_uahc_suptprt3_dw1 {
@@ -4943,13 +5078,14 @@ union cvmx_usbdrdx_uahc_suptprt3_dw1 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn70xx;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw1_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw1 cvmx_usbdrdx_uahc_suptprt3_dw1_t;
 
 /**
  * cvmx_usbdrd#_uahc_suptprt3_dw2
  *
- * See XHCI specification v1.0 section 7.2.
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.2.
  *
  */
 union cvmx_usbdrdx_uahc_suptprt3_dw2 {
@@ -4968,14 +5104,15 @@ union cvmx_usbdrdx_uahc_suptprt3_dw2 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn70xx;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw2_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw2 cvmx_usbdrdx_uahc_suptprt3_dw2_t;
 
 /**
  * cvmx_usbdrd#_uahc_suptprt3_dw3
  *
- * See XHCI specification v1.? section 7.2.
- * INTERNAL: TODO (new unreleased XHCI errata!)
+ * For information on this register, refer to the xHCI Specification, v1.1, section 7.2.
+ *
  */
 union cvmx_usbdrdx_uahc_suptprt3_dw3 {
 	uint32_t u32;
@@ -4989,17 +5126,19 @@ union cvmx_usbdrdx_uahc_suptprt3_dw3 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn70xx;
+	struct cvmx_usbdrdx_uahc_suptprt3_dw3_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_suptprt3_dw3 cvmx_usbdrdx_uahc_suptprt3_dw3_t;
 
 /**
  * cvmx_usbdrd#_uahc_usbcmd
  *
- * See XHCI specification v1.0 section 5.4.1.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.1.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_usbcmd {
 	uint32_t u32;
@@ -5031,17 +5170,20 @@ union cvmx_usbdrdx_uahc_usbcmd {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_usbcmd_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_usbcmd_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_usbcmd cvmx_usbdrdx_uahc_usbcmd_t;
 
 /**
  * cvmx_usbdrd#_uahc_usblegctlsts
  *
- * See XHCI specification v1.0 section 7.1.2.
- * Note that the SMI interrupts are not connected to anything in an Octeon configuration.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.1.2. Note
+ * that the SMI interrupts are not connected to anything in a CNXXXX configuration.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_usblegctlsts {
 	uint32_t u32;
@@ -5050,15 +5192,17 @@ union cvmx_usbdrdx_uahc_usblegctlsts {
 	uint32_t smi_on_bar                   : 1;  /**< System management interrupt on BAR. Never generated. */
 	uint32_t smi_on_pci_command           : 1;  /**< System management interrupt on PCI command. Never generated. */
 	uint32_t smi_on_os_ownership          : 1;  /**< System management interrupt on OS ownership change. This bit is set to 1 whenever
-                                                         UAHC_USBLEGSUP[HC_OS_OWNED_SEMAPHORES] transitions. */
+                                                         USBDRD()_UAHC_USBLEGSUP[HC_OS_OWNED_SEMAPHORES] transitions. */
 	uint32_t reserved_21_28               : 8;
-	uint32_t smi_on_hostsystemerr         : 1;  /**< System-management interrupt on host-system error. Shadow bit of UAHC_USBSTS[HSE]. Refer to
-                                                         XHCI Section 5.4.2 for definition and effects of the events associated with this bit being
+	uint32_t smi_on_hostsystemerr         : 1;  /**< System-management interrupt on host-system error. Shadow bit of USBDRD()_UAHC_USBSTS[HSE].
+                                                         Refer to
+                                                         xHCI Section 5.4.2 for definition and effects of the events associated with this bit being
                                                          set to 1.
-                                                         To clear this bit to a 0, system software must write a 1 to UAHC_USBSTS[HSE]. */
+                                                         To clear this bit to a 0, system software must write a 1 to USBDRD()_UAHC_USBSTS[HSE]. */
 	uint32_t reserved_17_19               : 3;
-	uint32_t smi_on_event_interrupt       : 1;  /**< System-management interrupt on event interrupt. Shadow bit of UAHC_USBSTS[EINT]. Refer to
-                                                         XHCI Section 5.4.2 for definition. This bit automatically clears when [EINT] clears and
+	uint32_t smi_on_event_interrupt       : 1;  /**< System-management interrupt on event interrupt. Shadow bit of USBDRD()_UAHC_USBSTS[EINT].
+                                                         Refer to
+                                                         xHCI Section 5.4.2 for definition. This bit automatically clears when [EINT] clears and
                                                          sets when [EINT] sets. */
 	uint32_t smi_on_bar_en                : 1;  /**< System-management interrupt on BAR enable. */
 	uint32_t smi_on_pci_command_en        : 1;  /**< System-management interrupt on PCI command enable. */
@@ -5085,16 +5229,19 @@ union cvmx_usbdrdx_uahc_usblegctlsts {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn70xx;
+	struct cvmx_usbdrdx_uahc_usblegctlsts_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_usblegctlsts cvmx_usbdrdx_uahc_usblegctlsts_t;
 
 /**
  * cvmx_usbdrd#_uahc_usblegsup
  *
- * See XHCI specification v1.0 section 7.1.1.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 7.1.1.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_usblegsup {
 	uint32_t u32;
@@ -5104,7 +5251,7 @@ union cvmx_usbdrdx_uahc_usblegsup {
 	uint32_t hc_os_owned_semaphores       : 1;  /**< HC OS-owned semaphore. */
 	uint32_t reserved_17_23               : 7;
 	uint32_t hc_bios_owned_semaphores     : 1;  /**< HC BIOS-owned semaphore. */
-	uint32_t nextcapptr                   : 8;  /**< Next XHCI extended-capability pointer. */
+	uint32_t nextcapptr                   : 8;  /**< Next xHCI extended-capability pointer. */
 	uint32_t capid                        : 8;  /**< Capability ID = USB legacy support. */
 #else
 	uint32_t capid                        : 8;
@@ -5116,17 +5263,19 @@ union cvmx_usbdrdx_uahc_usblegsup {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_usblegsup_s  cn70xx;
+	struct cvmx_usbdrdx_uahc_usblegsup_s  cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_usblegsup cvmx_usbdrdx_uahc_usblegsup_t;
 
 /**
  * cvmx_usbdrd#_uahc_usbsts
  *
- * See XHCI specification v1.0 section 5.4.2.
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UAHC_RESET] or
- * USBDRD(0..1)_UAHC_GCTL[CORESOFTRESET] or
- * USBDRD(0..1)_UAHC_USBCMD[HCRST] or USBDRD(0..1)_UAHC_USBCMD[LHCRST] or
- * USBDRD(0..1)_UAHC_DCTL[CSFTRST].
+ * For information on this register, refer to the xHCI Specification, v1.0, section 5.4.2.
+ *
+ * This register can be reset by IOI reset,
+ * or USBDRD()_UCTL_CTL[UAHC_RST],
+ * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
+ * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
  */
 union cvmx_usbdrdx_uahc_usbsts {
 	uint32_t u32;
@@ -5141,8 +5290,7 @@ union cvmx_usbdrdx_uahc_usbsts {
 	uint32_t reserved_5_7                 : 3;
 	uint32_t pcd                          : 1;  /**< Port-change detect. */
 	uint32_t eint                         : 1;  /**< Event interrupt. */
-	uint32_t hse                          : 1;  /**< Host-system error. The typical software response to an HSE is to reset the core.
-                                                         Throws USBDRD_UCTL_INTSN_E::USBDRD_UAHC_USBSTS_HSE. */
+	uint32_t hse                          : 1;  /**< Host-system error. The typical software response to an HSE is to reset the core. */
 	uint32_t reserved_1_1                 : 1;
 	uint32_t hch                          : 1;  /**< HC halted. */
 #else
@@ -5161,16 +5309,15 @@ union cvmx_usbdrdx_uahc_usbsts {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uahc_usbsts_s     cn70xx;
+	struct cvmx_usbdrdx_uahc_usbsts_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uahc_usbsts cvmx_usbdrdx_uahc_usbsts_t;
 
 /**
  * cvmx_usbdrd#_uctl_bist_status
  *
- * Accessible by: always
- * Reset by: IOI reset (srst_n)
- * Results from BIST runs of USBDRD's memories.
- * Wait for NDONE==0, then look at defect indication.
+ * This register indicates the results from the built-in self-test (BIST) runs of USBH memories.
+ * A 0 indicates pass or never run, a 1 indicates fail. This register can be reset by IOI reset.
  */
 union cvmx_usbdrdx_uctl_bist_status {
 	uint64_t u64;
@@ -5208,42 +5355,45 @@ union cvmx_usbdrdx_uctl_bist_status {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_bist_status_s cn70xx;
+	struct cvmx_usbdrdx_uctl_bist_status_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_bist_status cvmx_usbdrdx_uctl_bist_status_t;
 
 /**
  * cvmx_usbdrd#_uctl_ctl
  *
- * Accessible by: always
- * Reset by: IOI reset (srst_n)
- * This register controls clocks, resets, power, and BIST for the USB.
+ * This register controls clocks, resets, power, and BIST.
+ *
+ * This register can be reset by IOI reset.
  */
 union cvmx_usbdrdx_uctl_ctl {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uctl_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t clear_bist                   : 1;  /**< BIST fast-clear mode select.
-                                                         There are 2 major modes of BIST: full and clear. Full BIST is run by the BIST state
-                                                         machine when clear_bist is deasserted during BIST. Clear BIST is run if clear_bist is
-                                                         asserted during BIST. A Clear BIST run will simply clear all entries in USBDRD RAMs to
-                                                         0x0.
+	uint64_t clear_bist                   : 1;  /**< BIST fast-clear mode select. A BIST run with this bit set clears all entries in USBH RAMs
+                                                         to 0x0.
+                                                         There are two major modes of BIST: full and clear. Full BIST is run by the BIST state
+                                                         machine when CLEAR_BIST is deasserted during BIST. Clear BIST is run if CLEAR_BIST is
+                                                         asserted during BIST.
                                                          To avoid race conditions, software must first perform a CSR write operation that puts the
-                                                         clear_bist setting into the correct state and then perform another CSR write operation to
-                                                         set the BIST trigger (keeping the clear_bist state constant).
-                                                         CLEAR BIST completion is indicated by USBDRD(0..1)_UCTL_BIST_STATUS[NDONE]. A BIST clear
-                                                         operation takes almost 2,000 host-controller-clock cycles for the largest RAM. */
+                                                         CLEAR_BIST setting into the correct state and then perform another CSR write operation to
+                                                         set the BIST trigger (keeping the CLEAR_BIST state constant).
+                                                         CLEAR BIST completion is indicated by USBDRD()_UCTL_BIST_STATUS. A BIST clear operation
+                                                         takes almost 2,000 controller-clock cycles for the largest RAM. */
 	uint64_t start_bist                   : 1;  /**< Rising edge starts BIST on the memories in USBDRD.
-                                                         To run BIST, both the host-controller clock must be configured and enabled, and should be
+                                                         To run BIST, the controller clock must be both configured and enabled, and should be
                                                          configured to the maximum available frequency given the available coprocessor clock and
                                                          dividers.
                                                          Also, the UCTL, UAHC, and UPHY should be held in software- initiated reset (using
                                                          UPHY_RST, UAHC_RST, UCTL_RST) until BIST is complete.
                                                          BIST defect status can be checked after FULL BIST completion, both of which are indicated
-                                                         in USBDRD(0..1)_UCTL_BIST_STATUS. The full BIST run takes almost 80,000 host-controller-
-                                                         clock cycles for the largest RAM. */
+                                                         in USBDRD()_UCTL_BIST_STATUS. The full BIST run takes almost 80,000 controller-clock
+                                                         cycles
+                                                         for
+                                                         the largest RAM. */
 	uint64_t ref_clk_sel                  : 2;  /**< Choose reference clock source for the SuperSpeed and HighSpeed PLL blocks.
-                                                           0x0 = Reference clock source for both PLLs is DLMC_REF_CLK0
-                                                           0x1 = Reference clock source for both PLLs is DLMC_REF_CLK1
+                                                           0x0 = Reference clock source for both PLLs is DLMC_REF_CLK0.
+                                                           0x1 = Reference clock source for both PLLs is DLMC_REF_CLK1.
                                                            0x2 = Reference clock source for SuperSpeed PLL is DLMC_REF_CLK0,
                                                                  reference clock source for HighSpeed PLL is PLL_REF_CLK.
                                                            0x3 = Reference clock source for SuperSpeed PLL is DLMC_REF_CLK1,
@@ -5253,24 +5403,24 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          This value can be changed only during UPHY_RST.
                                                          Note: If REF_CLK_SEL = 0x0 or 0x1, then the DLMC_REF_CLK* input chosen
                                                          cannot be spread-spectrum. */
-	uint64_t ssc_en                       : 1;  /**< Enables spread-spectrum clock production in the SuperSpeed function.
-                                                         If the DLMC_REF_CLK* inputs are already spread-spectrum, then do not enable this feature.
-                                                         The clocks sourced to the SuperSpeed function must have spread-spectrum to be compliant
-                                                         with the USB specification.
+	uint64_t ssc_en                       : 1;  /**< Spread-spectrum clock enable. Enables spread-spectrum clock production in the SuperSpeed
+                                                         function. If the input reference clock for the SuperSpeed PLL is already spread-spectrum,
+                                                         then do not enable this feature. The clocks sourced to the SuperSpeed function must have
+                                                         spread-spectrum to be compliant with the USB specification.
+                                                         The high-speed PLL cannot support a spread-spectrum input, so REF_CLK_SEL = 0x0 must
+                                                         enable this feature.
                                                          This value may only be changed during UPHY_RST. */
-	uint64_t ssc_range                    : 3;  /**< Selects the range of spread spectrum modulation when ssc_en is asserted and the PHY is
-                                                         spreading the SuperSpeed transmit clocks.
+	uint64_t ssc_range                    : 3;  /**< Spread-spectrum clock range. Selects the range of spread-spectrum modulation when SSC_EN
+                                                         is asserted and the PHY is spreading the SuperSpeed transmit clocks.
                                                          Applies a fixed offset to the phase accumulator.
-                                                           0x0 : -4980 ppm downspread of clock
-                                                           0x1 : -4492 ppm
-                                                           0x2 : -4003 ppm
-                                                           others: reserved
-                                                         All of these settings are within the USB 3.0 specification.
-                                                         The amount of EMI emission reduction might decrease as the
-                                                         SSC_RANGE increases; therefore, the SSC_RANGE settings can
-                                                         be registered to enable the amount of spreading to be adjusted
-                                                         on a per-application basis.
-                                                         This value may only be changed during UPHY_RST. */
+                                                         0x0 = -4980 ppm downspread of clock.
+                                                         0x1 = -4492 ppm.
+                                                         0x2 = -4003 ppm.
+                                                         0x3-0x7 = reserved.
+                                                         All of these settings are within the USB 3.0 specification. The amount of EMI emission
+                                                         reduction might decrease as the SSC_RANGE increases; therefore, the SSC_RANGE settings can
+                                                         be registered to enable the amount of spreading to be adjusted on a per-application basis.
+                                                         This value can be changed only during UPHY_RST. */
 	uint64_t ssc_ref_clk_sel              : 9;  /**< Enables non-standard oscillator frequencies to generate targeted MPLL output rates. Input
                                                          corresponds to the frequency-synthesis coefficient.
                                                          [55:53]: modulus - 1,
@@ -5332,8 +5482,8 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          enabled since this output clock is used to drive the UAHC suspend-mode clock during
                                                          low-power states.
                                                          This value can be changed only during UPHY_RST or during low-power states.
-                                                         The reference clock must be running and stable before UPHY_RST is deasserted, and
-                                                         before REF_SSP_EN is asserted. */
+                                                         The reference clock must be running and stable before UPHY_RST is deasserted and before
+                                                         REF_SSP_EN is asserted. */
 	uint64_t ref_clk_div2                 : 1;  /**< Divides the reference clock by 2 before feeding it into the REF_CLK_FSEL divider.
                                                          The legal values are:
                                                            If REF_CLK_SEL = 0x0 or 0x1, then:
@@ -5353,7 +5503,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                                        0x0 or 0x1 if DLMC_REF_CLK* is 104MHz (depending on MPLL_MULTIPLIER setting)
                                                                        0x0: if DLMC_REF_CLK* is another supported frequency (see list in
                                                                             MPLL_MULTIPLIER description). */
-	uint64_t ref_clk_fsel                 : 6;  /**< Selects the reference clock frequency for the SuperSpeed and HighSpeed PLL blocks.
+	uint64_t ref_clk_fsel                 : 6;  /**< Selects the reference clock frequency for the SuperSpeed and high-speed PLL blocks.
                                                          The legal values are:
                                                            If REF_CLK_SEL = 0x0 or 0x1, then:
                                                              0x27 = 100  MHz on DLMC_REF_CLK*
@@ -5372,22 +5522,31 @@ union cvmx_usbdrdx_uctl_ctl {
                                                                      If REF_CLK_SEL = 0x2 or 0x3, then:
                                                                        0x07 is the only legal value. */
 	uint64_t reserved_31_31               : 1;
-	uint64_t h_clk_en                     : 1;  /**< Hclk enable. When set to 1, the host-controller clock is generated. This
-                                                         also enables access to UCTL registers 0x30-0xF8. */
-	uint64_t h_clk_byp_sel                : 1;  /**< Select the bypass input to the hclk divider.
-                                                         0 = use the divided coprocessor clock from the H_CLKDIV divider
-                                                         1 = use the bypass clock from the GPIO pins
-                                                         This signal is just a multiplexer-select signal; it does not enable the host-controller
-                                                         clock. You must still set H_CLKDIV_EN separately. H_CLK_BYP_SEL select should not be
-                                                         changed unless H_CLKDIV_EN is disabled.
-                                                         The bypass clock can be selected and running even if the hclk dividers
-                                                         are not running.
+	uint64_t h_clk_en                     : 1;  /**< Controller-clock enable. When set to 1, the controller clock is generated. This also
+                                                         enables access to UCTL registers 0x30-0xF8. */
+	uint64_t h_clk_byp_sel                : 1;  /**< Select the bypass input to the controller-clock divider.
+                                                         0 = Use the divided coprocessor clock from the H_CLKDIV divider.
+                                                         1 = Use the bypass clock from the GPIO pins.
+                                                         This signal is just a multiplexer-select signal; it does not enable the controller clock.
+                                                         You must still set H_CLKDIV_EN separately. H_CLK_BYP_SEL select should not be changed
+                                                         unless H_CLKDIV_EN is disabled.
+                                                         The bypass clock can be selected and running even if the controller-clock dividers are not
+                                                         running.
                                                          INTERNAL: Generally bypass is only used for scan purposes. */
-	uint64_t h_clkdiv_rst                 : 1;  /**< Hclk divider reset. Divided clocks are not generated while the divider is
+	uint64_t h_clkdiv_rst                 : 1;  /**< Controller-clock divider reset. Divided clocks are not generated while the divider is
                                                          being reset.
                                                          This also resets the suspend-clock divider. */
 	uint64_t reserved_27_27               : 1;
 	uint64_t h_clkdiv_sel                 : 3;  /**< The hclk frequency is sclk frequency divided by H_CLKDIV_SEL.
+                                                         The divider values are the following:
+                                                         0x0 = divide by 1.
+                                                         0x1 = divide by 2.
+                                                         0x2 = divide by 4.
+                                                         0x3 = divide by 6.
+                                                         0x4 = divide by 8.
+                                                         0x5 = divide by 16.
+                                                         0x6 = divide by 24.
+                                                         0x7 = divide by 32.
                                                          The hclk frequency must be at or below 300MHz.
                                                          The hclk frequency must be at or above 150MHz for full-rate USB3
                                                          operation.
@@ -5400,11 +5559,6 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          If DRD_MODE = HOST, the hclk frequency must be at or above 62.5MHz
                                                          for any USB2 operation.
                                                          This field can be changed only when H_CLKDIV_RST = 1.
-                                                         The divider values are the following:
-                                                         0x0 = divide by 1 0x4 = divide by 8
-                                                         0x1 = divide by 2 0x5 = divide by 16
-                                                         0x2 = divide by 4 0x6 = divide by 24
-                                                         0x3 = divide by 6 0x7 = divide by 32
                                                          INTERNAL: 150MHz is from the maximum of:
                                                                      Synopsys DWC_usb3 Databook v2.50a, table A-16, row 1, col 12.
                                                                      Synopsys DWC_usb3 Databook v2.50a, table A-17, row 7, col 9.
@@ -5423,15 +5577,15 @@ union cvmx_usbdrdx_uctl_ctl {
 	uint64_t usb3_port_disable            : 1;  /**< Disables the USB3 (SuperSpeed) portion of this PHY. When set to 1, this signal stops
                                                          reporting connect/disconnect events on the port and keeps the port in disabled state. This
                                                          could be used for security reasons where hardware can disable a port regardless of whether
-                                                         XHCI driver enables a port or not.
-                                                         USBDRD(0..1)_UAHC_HCSPARAMS1[MAXPORTS] is not affected by this signal.
+                                                         xHCI driver enables a port or not.
+                                                         USBDRD()_UAHC_HCSPARAMS1[MAXPORTS] is not affected by this signal.
                                                          This is a strap signal; it should be modified only when UPHY_RST is asserted. */
 	uint64_t reserved_17_17               : 1;
-	uint64_t usb2_port_disable            : 1;  /**< Disables USB2 (HighSpeed/FullSpeed/LowSpeed) portion of this PHY. When set to 1, this
+	uint64_t usb2_port_disable            : 1;  /**< Disables USB2 (high-speed/full-speed/low-speed) portion of this PHY. When set to 1, this
                                                          signal stops reporting connect/disconnect events on the port and keeps the port in
                                                          disabled state. This could be used for security reasons where hardware can disable a port
-                                                         regardless of whether XHCI driver enables a port or not.
-                                                         USBDRD(0..1)_UAHC_HCSPARAMS1[MAXPORTS] is not affected by this signal.
+                                                         regardless of whether xHCI driver enables a port or not.
+                                                         USBDRD()_UAHC_HCSPARAMS1[MAXPORTS] is not affected by this signal.
                                                          This is a strap signal; it should only be modified when UPHY_RST is asserted.
                                                          If Port0 is required to be disabled, ensure that the utmi_clk[0] is running at the normal
                                                          speed. Also, all the enabled USB2.0 ports should have the same clock frequency as Port0. */
@@ -5439,7 +5593,7 @@ union cvmx_usbdrdx_uctl_ctl {
 	uint64_t ss_power_en                  : 1;  /**< PHY SuperSpeed block power enable.
                                                          This is a strap signal; it should only be modified when UPHY_RST is asserted. */
 	uint64_t reserved_13_13               : 1;
-	uint64_t hs_power_en                  : 1;  /**< PHY HighSpeed block power enable
+	uint64_t hs_power_en                  : 1;  /**< PHY high-speed block power enable.
                                                          This is a strap signal; it should only be modified when UPHY_RST is asserted. */
 	uint64_t reserved_5_11                : 7;
 	uint64_t csclk_en                     : 1;  /**< Turns on the USB UCTL interface clock (coprocessor clock). This enables access to UAHC
@@ -5450,14 +5604,14 @@ union cvmx_usbdrdx_uctl_ctl {
 	uint64_t uphy_rst                     : 1;  /**< PHY reset; resets UPHY; active-high. */
 	uint64_t uahc_rst                     : 1;  /**< Software reset; resets UAHC; active-high.
                                                          INTERNAL: Note that soft-resetting the UAHC while it is active may cause violations of RSL
-                                                         or NCB protocols. */
+                                                         or IOI protocols. */
 	uint64_t uctl_rst                     : 1;  /**< Software reset; resets UCTL; active-high.
                                                          Resets UAHC DMA and register shims. Resets UCTL RSL registers 0x30-0xF8.
                                                          Does not reset UCTL RSL registers 0x0-0x28.
-                                                         UCTL RSL registers starting from 0x30 can be accessed only after the host-controller clock
-                                                         is active and UCTL_RST is deasserted.
+                                                         UCTL RSL registers starting from 0x30 can be accessed only after the controller clock is
+                                                         active and UCTL_RST is deasserted.
                                                          INTERNAL: Note that soft-resetting the UCTL while it is active may cause violations of
-                                                         RSL, NCB, and CIB protocols. */
+                                                         RSL, IOI, and CIB protocols. */
 #else
 	uint64_t uctl_rst                     : 1;
 	uint64_t uahc_rst                     : 1;
@@ -5495,25 +5649,31 @@ union cvmx_usbdrdx_uctl_ctl {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_ctl_s        cn70xx;
+	struct cvmx_usbdrdx_uctl_ctl_s        cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_ctl cvmx_usbdrdx_uctl_ctl_t;
 
 /**
  * cvmx_usbdrd#_uctl_ecc
  *
- * Accessible by: only when H_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UCTL_RST]
- * This register can be used to disable ECC checks, insert ECC errors, and debug ECC failures.
- * Fields ECC_ERR* are captured when there are no outstanding ECC errors indicated in INTSTAT
- * and a new ECC error arrives. Prioritization for multiple events occurring on the same cycle is
- * indicated by the ECC_ERR_SOURCE enumeration: highest encoded value has highest priority.
- * Fields *ECC_DIS: Disables SBE detection/correction and DBE detection.
- * If ECC_DIS is 0x1, then no errors are detected.
- * Fields *ECC_FLIP_SYND:  Flip the syndrom[1:0] bits to generate 1-bit/2-bits error for testing.
- *   0x0: normal operation
- *   0x1: SBE on bit[0]
- *   0x2: SBE on bit[1]
- *   0x3: DBE on bit[1:0]
+ * Accessible by: only when H_CLKDIV_EN.
+ * This register can be used to disable ECC correction, insert ECC errors, and debug ECC
+ * failures.
+ * * The ECC_ERR* fields are captured when there are no outstanding ECC errors indicated in
+ * INTSTAT and a new ECC error arrives. Prioritization for multiple events occurring on the same
+ * cycle is indicated by the ECC_ERR_SOURCE enumeration: highest encoded value has highest
+ * priority.
+ * * The *ECC_*_DIS fields disable ECC correction; SBE and DBE errors are still reported. If
+ * *ECC_*_DIS = 0x1, then no data-correction occurs.
+ * * The *ECC_FLIP_SYND fields flip the syndrome<1:0> bits to generate single-bit/double-bit
+ * error for testing.
+ *
+ * 0x0 = normal operation.
+ * 0x1 = SBE on bit[0].
+ * 0x2 = SBE on bit[1].
+ * 0x3 = DBE on bit[1:0].
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_ecc {
 	uint64_t u64;
@@ -5545,17 +5705,19 @@ union cvmx_usbdrdx_uctl_ecc {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_ecc_s        cn70xx;
+	struct cvmx_usbdrdx_uctl_ecc_s        cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_ecc cvmx_usbdrdx_uctl_ecc_t;
 
 /**
  * cvmx_usbdrd#_uctl_host_cfg
  *
- * Accessible by: only when H_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UCTL_RST]
- * This register allows configuration of various host controller (UAHC) features.
- * Most of these are strap signals and should only be modified while the controller is not
- * running.
+ * Accessible by: only when H_CLKDIV_EN.
+ *
+ * This register allows configuration of various host controller (UAHC) features. Most of these
+ * are strap signals and should be modified only while the controller is not running.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_host_cfg {
 	uint64_t u64;
@@ -5565,13 +5727,13 @@ union cvmx_usbdrdx_uctl_host_cfg {
 	uint64_t host_current_belt            : 12; /**< This signal indicates the minimum value of all received BELT values and the BELT that is
                                                          set by the Set LTV command. */
 	uint64_t reserved_38_47               : 10;
-	uint64_t fla                          : 6;  /**< HighSpeed jitter adjustment. Indicates the correction required to accommodate mac3 clock
-                                                         and utmi clock jitter to measure 125us duration. With FLA tied to zero, the HighSpeed
+	uint64_t fla                          : 6;  /**< High-speed jitter adjustment. Indicates the correction required to accommodate mac3 clock
+                                                         and utmi clock jitter to measure 125us duration. With FLA tied to 0x0, the high-speed
                                                          125us micro-frame is counted for 123933ns. The value needs to be programmed in terms of
-                                                         HighSpeed bit times in a 30 MHz cycle. Default value that needs to be driven is 0x20
+                                                         high-speed bit times in a 30 MHz cycle. Default value that needs to be driven is 0x20
                                                          (assuming 30 MHz perfect clock).
-                                                         FLA connects to the FLADJ register defined in the XHCI spec in the PCI configuration
-                                                         space. Each count is equal to 16 HighSpeed bit times. By default when this register is
+                                                         FLA connects to the FLADJ register defined in the xHCI spec in the PCI configuration
+                                                         space. Each count is equal to 16 high-speed bit times. By default when this register is
                                                          set to 0x20, it gives 125us interval. Now, based on the clock accuracy, you can decrement
                                                          the count or increment the count to get the 125 us uSOF window.
                                                          This is a strap signal; it should only be modified when UAHC is in reset (soft-reset
@@ -5579,32 +5741,33 @@ union cvmx_usbdrdx_uctl_host_cfg {
 	uint64_t reserved_29_31               : 3;
 	uint64_t bme                          : 1;  /**< Bus-master enable. This signal is used to disable the bus-mastering capability of the
                                                          host. Disabling this capability stalls DMA accesses. */
-	uint64_t oci_en                       : 1;  /**< Overcurrent-indication enable.
-                                                         When enabled, OCI input to UAHC is taken from the MIO's GPIO signals and sense-converted
-                                                         based on OCI_ACTIVE_HIGH_EN. The MIO GPIO multiplexer must be programmed accordingly.
+	uint64_t oci_en                       : 1;  /**< Overcurrent-indication enable. When enabled, OCI input to UAHC is taken from the GPIO
+                                                         signals and sense-converted based on OCI_ACTIVE_HIGH_EN. The MIO GPIO multiplexer must be
+                                                         programmed accordingly.
                                                          When disabled, OCI input to UAHC is forced to the correct inactive state based on
                                                          OCI_ACTIVE_HIGH_EN.
                                                          This is a strap signal; it should only be modified when UAHC is in reset (soft-reset
                                                          okay). */
-	uint64_t oci_active_high_en           : 1;  /**< Overcurrent sense selection. The off-chip sense (high/low) is converted to match the host-
+	uint64_t oci_active_high_en           : 1;  /**< Overcurrent sense selection. The off-chip sense (high/low) is converted to match the
                                                          controller's active-high sense.
-                                                         1 = overcurrent indication from off-chip source is active-high.
-                                                         0 = overcurrent indication from off-chip source is active-low.
+                                                         0 = Overcurrent indication from off-chip source is active-low.
+                                                         1 = Overcurrent indication from off-chip source is active-high.
                                                          This is a strap signal; it should only be modified when UAHC is in reset (soft-reset
                                                          okay). */
 	uint64_t ppc_en                       : 1;  /**< Port-power-control enable.
-                                                         0 = USBDRD(0..1)_UAHC_HCCPARAMS[PPC] report port-power-control feature is unavailable.
-                                                         1 = USBDRD(0..1)_UAHC_HCCPARAMS[PPC] reports port-power-control feature is available. PPC
-                                                         output from UAHC is taken to the MIO's GPIO signals and sense-converted based on
-                                                         PPC_ACTIVE_HIGH_EN. The MIO GPIO multiplexer must be programmed accordingly.
-                                                         This is a strap signal; it should only be modified when UAHC is in reset (soft-reset
-                                                         okay). */
+                                                         0 = USBDRD()_UAHC_HCCPARAMS[PPC] report port-power-control feature is unavailable.
+                                                         1 = USBDRD()_UAHC_HCCPARAMS[PPC] reports port-power-control feature is available. PPC
+                                                         output
+                                                         from UAHC is taken to the GPIO signals and sense-converted based on PPC_ACTIVE_HIGH_EN.
+                                                         The MIO GPIO multiplexer must be programmed accordingly.
+                                                         This is a strap signal; it should only be modified when either the UCTL_CTL[UAHC] or
+                                                         UAHC_GCTL[CORESOFTRESET] is asserted. */
 	uint64_t ppc_active_high_en           : 1;  /**< Port power control sense selection. The active-high port-power-control output to off-chip
                                                          source is converted to match the off-chip sense.
-                                                         1 = port-power control to off-chip source is active-high.
-                                                         0 = port-power control to off-chip source is active-low.
-                                                         This is a strap signal; it should only be modified when UAHC is in reset (soft reset
-                                                         okay). */
+                                                         0 = Port-power control to off-chip source is active-low.
+                                                         1 = Port-power control to off-chip source is active-high.
+                                                         This is a strap signal; it should only be modified when either the UCTL_CTL[UAHC] or
+                                                         UAHC_GCTL[CORESOFTRESET] is asserted. */
 	uint64_t reserved_0_23                : 24;
 #else
 	uint64_t reserved_0_23                : 24;
@@ -5621,49 +5784,42 @@ union cvmx_usbdrdx_uctl_host_cfg {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_host_cfg_s   cn70xx;
+	struct cvmx_usbdrdx_uctl_host_cfg_s   cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_host_cfg cvmx_usbdrdx_uctl_host_cfg_t;
 
 /**
  * cvmx_usbdrd#_uctl_intstat
  *
- * Accessible by: always
- * Reset by: IOI reset (srst_n)
- * Summary of different bits of RSL interrupts.
- * DBE's are detected. SBE's are corrected. For debugging output for ECC DBE/SBE's,
- * see UCTL_ECC register.
+ * This register provides a summary of different bits of RSL interrupts. DBEs are detected and
+ * SBE are corrected. For debugging output for ECC DBEs/SBEs, see USBDRD()_UCTL_ECC. This
+ * register
+ * can
+ * be reset by IOI reset.
  */
 union cvmx_usbdrdx_uctl_intstat {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uctl_intstat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_22_63               : 42;
-	uint64_t ram2_dbe                     : 1;  /**< Detected double-bit error on the UAHC RxFIFO RAMs (RAM2). Throws
-                                                         USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_INTSTAT_RAM2_DBE. */
-	uint64_t ram2_sbe                     : 1;  /**< Detected single-bit error on the UAHC RxFIFO RAMs (RAM2). Throws
-                                                         USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_INTSTAT_RAM2_SBE. */
-	uint64_t ram1_dbe                     : 1;  /**< Detected double-bit error on the UAHC TxFIFO RAMs (RAM1). Throws
-                                                         USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_INTSTAT_RAM1_DBE. */
-	uint64_t ram1_sbe                     : 1;  /**< Detected single-bit error on the UAHC TxFIFO RAMs (RAM1). Throws
-                                                         USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_INTSTAT_RAM2_SBE. */
-	uint64_t ram0_dbe                     : 1;  /**< Detected double-bit error on the UAHC Desc/Reg Cache (RAM0). Throws
-                                                         USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_INTSTAT_RAM0_DBE. */
-	uint64_t ram0_sbe                     : 1;  /**< Detected single-bit error on the UAHC Desc/Reg Cache (RAM0). Throws
-                                                         USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_INTSTAT_RAM0_SBE. */
+	uint64_t ram2_dbe                     : 1;  /**< Detected double-bit error on the UAHC RxFIFO RAMs (RAM2). */
+	uint64_t ram2_sbe                     : 1;  /**< Detected single-bit error on the UAHC RxFIFO RAMs (RAM2). */
+	uint64_t ram1_dbe                     : 1;  /**< Detected double-bit error on the UAHC TxFIFO RAMs (RAM1). */
+	uint64_t ram1_sbe                     : 1;  /**< Detected single-bit error on the UAHC TxFIFO RAMs (RAM1). */
+	uint64_t ram0_dbe                     : 1;  /**< Detected double-bit error on the UAHC Desc/Reg Cache (RAM0). */
+	uint64_t ram0_sbe                     : 1;  /**< Detected single-bit error on the UAHC Desc/Reg Cache (RAM0). */
 	uint64_t reserved_3_15                : 13;
 	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. Error information is logged in
-                                                         USBDRD(0..1)_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates
+                                                         USBDRD()_UCTL_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates
                                                          the assumptions made by the AXI-to-IOI shim. Such scenarios include: illegal length/size
                                                          combinations and address out-of-bounds.
-                                                         For more information on exact failures, see description in
-                                                         USBDRD(0..1)_UCTL_SHIM_CFG[XM_BAD_DMA_TYPE].
-                                                         The hardware does not translate the request correctly and results may violate IOI
-                                                         protocols.
-                                                         Throws USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_INTSTAT_XM_BAD_DMA. */
+                                                         For more information on exact failures, see the description in
+                                                         USBDRD()_UCTL_SHIM_CFG[XM_BAD_DMA_TYPE]. The hardware does not translate the request
+                                                         correctly
+                                                         and results may violate IOI protocols. */
 	uint64_t xs_ncb_oob                   : 1;  /**< Detected out-of-bound register access to UAHC over IOI. The UAHC defines 1MB of register
                                                          space, starting at offset 0x0. Any accesses outside of this register space cause this bit
-                                                         to be set to 1. Error information is logged in USBDRD(0..1)_UCTL_SHIM_CFG[XS_NCB_OOB_*].
-                                                         Throws USBDRD_UCTL_INTSN_E::USBDRD(0..1)_UCTL_INTSTAT_XS_NCB_OOB. */
+                                                         to be set to 1. Error information is logged in USBDRD()_UCTL_SHIM_CFG[XS_NCB_OOB_*]. */
 	uint64_t reserved_0_0                 : 1;
 #else
 	uint64_t reserved_0_0                 : 1;
@@ -5680,15 +5836,18 @@ union cvmx_usbdrdx_uctl_intstat {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_intstat_s    cn70xx;
+	struct cvmx_usbdrdx_uctl_intstat_s    cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_intstat cvmx_usbdrdx_uctl_intstat_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cfg_hs
  *
- * Accessible by: only when H_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UCTL_RST]
- * This register controls configuration and test controls for the portX PHY.
+ * This register controls configuration and test controls for the HS port 0 PHY.
+ *
+ * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_portx_cfg_hs {
 	uint64_t u64;
@@ -5701,60 +5860,60 @@ union cvmx_usbdrdx_uctl_portx_cfg_hs {
                                                          threshold voltage level, while a negative binary bit setting change results in a -1.5%
                                                          incremental change in the threshold voltage level. */
 	uint64_t sq_rx_tune                   : 3;  /**< Squelch threshold adjustment. Adjusts the voltage level for the threshold used to detect
-                                                         valid HighSpeed data.
+                                                         valid high-speed data.
                                                          A positive binary bit setting change results in a -5% incremental change in threshold
                                                          voltage level, while a negative binary bit setting change results in a +5% incremental
                                                          change in threshold voltage level. */
-	uint64_t tx_fsls_tune                 : 4;  /**< FullSpeed/LowSpeed source impedance adjustment. Adjusts the LowSpeed and FullSpeed single-
-                                                         ended source
-                                                         impedance while driving high. This parameter control is encoded in thermometer code.
+	uint64_t tx_fsls_tune                 : 4;  /**< Low-speed/full-speed source impedance adjustment. Adjusts the low- and full-speed single-
+                                                         ended source impedance while driving high. This parameter control is encoded in
+                                                         thermometer code.
                                                          A positive thermometer code change results in a -2.5% incremental change in source
                                                          impedance. A negative thermometer code change results in +2.5% incremental change in
                                                          source impedance. Any non-thermometer code setting (that is, 0x9) is not supported and
                                                          reserved. */
 	uint64_t reserved_46_47               : 2;
-	uint64_t tx_hs_xv_tune                : 2;  /**< Transmitter HighSpeed crossover adjustment. This bus adjusts the voltage at which the DP0
-                                                         and DM0 signals cross while transmitting in HighSpeed mode.
-                                                         11 = default setting
-                                                         10 = +15 mV
-                                                         01 = -15 mV
-                                                         00 = reserved */
-	uint64_t tx_preemp_amp_tune           : 2;  /**< HighSpeed transmitter pre-emphasis current control. Controls the amount of current
-                                                         sourced to DP0 and DM0 after a J-to-K or K-to-J transition. The HighSpeed transmitter
-                                                         pre-emphasis current is defined in terms of unit amounts. One unit amount is approximately
-                                                         600 A and is defined as 1* pre-emphasis current.
-                                                         0x3 = HighSpeed TX pre-emphasis circuit sources 3* pre-emphasis current.
-                                                         0x2 = HighSpeed TX pre-emphasis circuit sources 2* pre-emphasis current.
-                                                         0x1 = HighSpeed TX pre-emphasis circuit sources 1* pre-emphasis current.
-                                                         0x0 = HighSpeed TX pre-emphasis is disabled.
+	uint64_t tx_hs_xv_tune                : 2;  /**< Transmitter high-speed crossover adjustment. This bus adjusts the voltage at which the DP0
+                                                         and DM0 signals cross while transmitting in high-speed mode.
+                                                         0x3 = default setting.
+                                                         0x2 = +15 mV.
+                                                         0x1 = -15 mV.
+                                                         0x0 = reserved. */
+	uint64_t tx_preemp_amp_tune           : 2;  /**< High-speed transmitter pre-emphasis current control. Controls the amount of current
+                                                         sourced to DP0 and DM0 after a J-to-K or K-to-J transition. The high-speed transmitter
+                                                         preemphasis current is defined in terms of unit amounts. One unit amount is approximately
+                                                         600 A and is defined as 1* preemphasis current.
+                                                         0x0 = High-speed TX preemphasis is disabled.
+                                                         0x1 = High-speed TX preemphasis circuit sources 1* preemphasis current.
+                                                         0x2 = High-speed TX preemphasis circuit sources 2* preemphasis current.
+                                                         0x3 = High-speed TX preemphasis circuit sources 3* preemphasis current.
                                                          If these signals are not used, set them to 0x0. */
 	uint64_t reserved_41_41               : 1;
-	uint64_t tx_preemp_pulse_tune         : 1;  /**< HighSpeed transmitter pre-emphasis duration control. Controls the duration for which the
-                                                         HighSpeed pre-emphasis current is sourced onto DP0 or DM0. The HighSpeed transmitter
-                                                         pre-emphasis duration is defined in terms of unit amounts. One unit of pre-emphasis
-                                                         duration is approximately 580 ps and is defined as 1* pre-emphasis duration. This signal
-                                                         is valid only if either TX_PREEMP_AMP_TUNE0[1] or TX_PREEMP_AMP_TUNE0[0] is set to 1.
-                                                         1 = 1*, short pre-emphasis current duration
-                                                         0 = 2*, long pre-emphasis current duration (design default)
+	uint64_t tx_preemp_pulse_tune         : 1;  /**< High-speed transmitter preemphasis duration control. Controls the duration for which the
+                                                         high-speed preemphasis current is sourced onto DP0 or DM0. The high-speed transmitter
+                                                         preemphasis duration is defined in terms of unit amounts. One unit of preemphasis duration
+                                                         is approximately 580 ps and is defined as 1* preemphasis duration. This signal is valid
+                                                         only if either TX_PREEMP_AMP_TUNE0[1] or TX_PREEMP_AMP_TUNE0[0] is set to 1.
+                                                         0 = 2*, long preemphasis current duration (design default)
+                                                         1 = 1*, short preemphasis current duration
                                                          If this signal is not used, set it to 0. */
 	uint64_t tx_res_tune                  : 2;  /**< USB source-impedance adjustment. Some applications require additional devices to be added
                                                          on the USB, such as a series switch, which can add significant series resistance. This bus
                                                          adjusts the driver source impedance to compensate for added series resistance on the USB.
-                                                           0x3: source impedence is decreased by approximately 4 ohms.
-                                                           0x2: source impedence is decreased by approximately 2 ohms.
-                                                           0x1: design default
-                                                           0x0: source impedence is increased by approximately 1.5 ohms.
-                                                         Note: Any setting other than the default can result in source-impedance variation across
+                                                         0x0 = source impedance is decreased by approximately 1.5 ohm.
+                                                         0x1 = design default.
+                                                         0x2 = source impedance is decreased by approximately 2 ohm.
+                                                         0x3 = source impedance is decreased by approximately 4 ohm.
+                                                         Any setting other than the default can result in source-impedance variation across
                                                          process, voltage, and temperature conditions that does not meet USB 2.0 specification
                                                          limits. If this bus is not used, leave it at the default setting. */
-	uint64_t tx_rise_tune                 : 2;  /**< HighSpeed transmitter rise-/fall-time adjustment. Adjusts the rise/fall times of the
-                                                         HighSpeed waveform. A positive binary bit setting change results in a -4% incremental
-                                                         change in the HighSpeed rise/fall time. A negative binary bit setting change results in a
-                                                         +4% incremental change in the HighSpeed rise/fall time. */
-	uint64_t tx_vref_tune                 : 4;  /**< HighSpeed DC voltage-level adjustment. Adjusts the HighSpeed DC level voltage.
-                                                         A positive binary bit setting change results in a +2.0% incremental change in HighSpeed
-                                                         DC voltage level, while a negative binary bit setting change results in a -2.0%
-                                                         incremental change in HighSpeed DC voltage level.
+	uint64_t tx_rise_tune                 : 2;  /**< High-speed transmitter rise-/fall-time adjustment. Adjusts the rise/fall times of the
+                                                         high-speed waveform. A positive binary bit setting change results in a -4% incremental
+                                                         change in the high-speed rise/fall time. A negative binary bit setting change results in a
+                                                         +4% incremental change in the high-speed rise/fall time. */
+	uint64_t tx_vref_tune                 : 4;  /**< High-speed DC voltage-level adjustment. Adjusts the high-speed DC level voltage.
+                                                         A positive binary-bit-setting change results in a +1.25% incremental change in high-speed
+                                                         DC voltage level, while a negative binary-bit-setting change results in a -1.25%
+                                                         incremental change in high-speed DC voltage level.
                                                          The default bit setting is intended to create a HighSpeed transmit
                                                          DC level of approximately 400mV. */
 	uint64_t reserved_7_31                : 25;
@@ -5767,18 +5926,18 @@ union cvmx_usbdrdx_uctl_portx_cfg_hs {
                                                          binary bit setting change results in a -3% incremental change
                                                          in threshold voltage level. " */
 	uint64_t vatest_enable                : 2;  /**< Analog test-pin select. Enables analog test voltages to be placed on the ID0 pin.
-                                                         0x0 = test functionality disabled
-                                                         0x1 = test functionality enabled
-                                                         0x2, 0x3 = reserved, invalid settings
+                                                         0x0 = test functionality disabled.
+                                                         0x1 = test functionality enabled.
+                                                         0x2, 0x3 = reserved, invalid settings.
                                                          See also the PHY databook for details on how to select which analog test voltage. */
-	uint64_t loopback_enable              : 1;  /**< Places the HighSpeed PHY in loopback mode, which concurrently enables HighSpeed receive
+	uint64_t loopback_enable              : 1;  /**< Places the high-speed PHY in loopback mode, which concurrently enables high-speed receive
                                                          and transmit logic. */
 	uint64_t atereset                     : 1;  /**< Per-PHY ATE reset. When the USB core is powered up (not in suspend mode), an automatic
                                                          tester can use this to disable PHYCLOCK and FREECLK, then re-enable them with an aligned
                                                          phase.
-                                                         1 = PHYCLOCK and FREECLK outputs are disabled.
                                                          0 = PHYCLOCK and FREECLK are available within a specific period after ATERESET is
-                                                         deasserted. */
+                                                         deasserted.
+                                                         1 = PHYCLOCK and FREECLK outputs are disabled. */
 #else
 	uint64_t atereset                     : 1;
 	uint64_t loopback_enable              : 1;
@@ -5800,15 +5959,19 @@ union cvmx_usbdrdx_uctl_portx_cfg_hs {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn70xx;
+	struct cvmx_usbdrdx_uctl_portx_cfg_hs_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cfg_hs cvmx_usbdrdx_uctl_portx_cfg_hs_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cfg_ss
  *
- * Accessible by: only when H_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UCTL_RST]
- * This register controls configuration and test controls for the portX PHY.
+ * Accessible by: only when H_CLKDIV_EN.
+ * This register controls configuration and test controls for the SS port 0 PHY.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
+ *
+ * INTERNAL: All these settings are for high-speed functionality, connect on DVDD power domain.
  */
 union cvmx_usbdrdx_uctl_portx_cfg_ss {
 	uint64_t u64;
@@ -5816,85 +5979,84 @@ union cvmx_usbdrdx_uctl_portx_cfg_ss {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t tx_vboost_lvl                : 3;  /**< TX voltage-boost level. Sets the boosted transmit launch amplitude (mVppd). The default
                                                          bit setting is intended to set the launch amplitude to approximately 1,008 mVppd. A
-                                                         single, positive binary bit setting change results in a +156 mVppd change in the Tx launch
+                                                         single, positive binary bit setting change results in a +156 mVppd change in the TX launch
                                                          amplitude.
-                                                         A single, negative binary bit setting change results in a -156 mVppd change in the Tx
+                                                         A single, negative binary bit setting change results in a -156 mVppd change in the TX
                                                          launch amplitude. All settings more than one binary bit change should not be used.
-                                                         0x3 = 0.844 V launch amplitude
-                                                         0x4 = 1.008 V launch amplitude
-                                                         0x5 = 1.156 V launch amplitude
+                                                         0x3 = 0.844 V launch amplitude.
+                                                         0x4 = 1.008 V launch amplitude.
+                                                         0x5 = 1.156 V launch amplitude.
                                                          All others values are invalid. */
 	uint64_t los_bias                     : 3;  /**< Loss-of-signal detector threshold-level control. A positive, binary bit setting change
                                                          results in a +15 mVp incremental change in the LOS threshold.
                                                          A negative binary bit setting change results in a -15 mVp incremental change in the LOS
                                                          threshold. The 0x0 setting is reserved and must not be used. The default 0x5 setting
                                                          corresponds to approximately 105 mVp.
-                                                             0x0: invalid
-                                                             0x1:  45 mV
-                                                             0x2:  60 mV
-                                                             0x3:  75 mV
-                                                             0x4:  90 mV
-                                                             0x5: 105 mV
-                                                             0x6: 120 mV
-                                                             0x7: 135 mV */
-	uint64_t lane0_ext_pclk_req           : 1;  /**< When asserted, this signal enables the pipe0_pclk output regardless of power state
-                                                         (along with the associated increase in power consumption). You can use this input
-                                                         to enable pipe0_pclk in the P3 state without going through a complete boot sequence. */
+                                                         0x0 = invalid.
+                                                         0x1 = 45 mV.
+                                                         0x2 = 60 mV.
+                                                         0x3 = 75 mV.
+                                                         0x4 = 90 mV.
+                                                         0x5 = 105 mV (default).
+                                                         0x6 = 120 mV.
+                                                         0x7 = 135 mV. */
+	uint64_t lane0_ext_pclk_req           : 1;  /**< When asserted, this signal enables the pipe0_pclk output regardless of power state (along
+                                                         with the associated increase in power consumption). You can use this input to enable
+                                                         pipe0_pclk in the P3 state without going through a complete boot sequence. */
 	uint64_t lane0_tx2rx_loopbk           : 1;  /**< When asserted, data from TX predriver is looped back to RX slicers. LOS is bypassed and
                                                          based on the tx0_en input so that rx0_los = !tx_data_en. */
 	uint64_t reserved_42_55               : 14;
-	uint64_t pcs_rx_los_mask_val          : 10; /**< Configurable Loss-of-Signal Mask Width.
-                                                         Sets the number of reference clock cycles to mask the incoming LFPS in U3 and U2 states.
-                                                         Masks the incoming LFPS for the number of reference clock cycles equal to the value of
-                                                         pcs_rx_los_mask_val<9:0>. This control filters out short, non-compliant LFPS glitches
-                                                         sent by a non-compliant host.
+	uint64_t pcs_rx_los_mask_val          : 10; /**< Configurable loss-of-signal mask width. Sets the number of reference clock cycles to mask
+                                                         the incoming LFPS in U3 and U2 states. Masks the incoming LFPS for the number of reference
+                                                         clock cycles equal to the value of pcs_rx_los_mask_val<9:0>. This control filters out
+                                                         short, non-compliant LFPS glitches sent by a noncompliant host.
                                                          For normal operation, set to a targeted mask interval of 10us (value = 10us / Tref_clk).
-                                                         If the USBDRD(0..1)_UCTL_CTL[REF_CLK_DIV2] is used, then (value = 10us / (2 * Tref_clk)).
-                                                         These equations are based on the SuperSpeed reference clock frequency.
-                                                         Setting this bus to 0x0 disables masking.
-                                                         The value should be defined when the PHY is in reset. Changing this value during operation
-                                                         might disrupt normal operation of the link.
-                                                         The value of PCS_RX_LOS_MASK_VAL should be:
-                                                                      Frequency DIV2 LOS_MASK
-                                                                       125  MHz    0    0x4E2
-                                                                       100  MHz    0    0x3E8
-                                                                        50  MHz    0    0x1F4
-                                                             INTERNAL: 200  MHz    1    0x3E8
-                                                                       104  MHz    0    0x410
-                                                                        96  MHz    0    0x3C0
-                                                                        76.8MHz    1    0x180
-                                                                        52  MHz    0    0x208
-                                                                        48  MHz    0    0x1E0
-                                                                        40  MHz    1    0x0C8
-                                                                        38.4MHz    0    0x180
-                                                                        26  MHz    0    0x104
-                                                                        25  MHz    0    0x0FA
-                                                                        24  MHz    0    0x0F0
-                                                                        20  MHz    0    0x0C8
-                                                                        19.2MHz    0    0x0C0 */
-	uint64_t pcs_tx_deemph_3p5db          : 6;  /**< Fine-tune transmitter driver de-emphasis when set to 3.5db.
-                                                         This static value sets the Tx driver de-emphasis value when pipeP_tx_deemph[1:0] is set to
-                                                         0x1 (according to the PIPE3 specification). The values for transmit de-emphasis are
-                                                         derived from the following equation:
-                                                         TX de-emphasis (db) =
-                                                         20 * log_base_10((128 - 2 * pcs_tx_deemph)/128)
+                                                         If the USBDRD()_UCTL_CTL[REF_CLK_DIV2] is used, then
+                                                         (value = 10us / (2 * Tref_clk)). These equations are based on the SuperSpeed reference
+                                                         clock frequency. The value of PCS_RX_LOS_MASK_VAL should be as follows:
+                                                         <pre>
+                                                              Frequency   DIV2  LOS_MASK
+                                                              ---------    ---  --------
+                                                              200   MHz      1     0x3E8
+                                                              125   MHz      0     0x4E2
+                                                              104   MHz      0     0x410
+                                                              100   MHz      0     0x3E8
+                                                               96   MHz      0     0x3C0
+                                                               76.8 MHz      1     0x180
+                                                               52   MHz      0     0x208
+                                                               50   MHz      0     0x1F4
+                                                               48   MHz      0     0x1E0
+                                                               40   MHz      1     0x0C8
+                                                               38.4 MHz      0     0x180
+                                                               26   MHz      0     0x104
+                                                               25   MHz      0     0x0FA
+                                                               24   MHz      0     0x0F0
+                                                               20   MHz      0     0x0C8
+                                                               19.2 MHz      0     0x0C0
+                                                         </pre>
+                                                         Setting this bus to 0x0 disables masking. The value should be defined when the PHY is in
+                                                         reset. Changing this value during operation might disrupt normal operation of the link. */
+	uint64_t pcs_tx_deemph_3p5db          : 6;  /**< Fine-tune transmitter driver deemphasis when set to 3.5db.
+                                                         This static value sets the TX driver deemphasis value when pipeP_tx_deemph[1:0] is set to
+                                                         0x1 (according to the PIPE3 specification). The values for transmit deemphasis are derived
+                                                         from the following equation:
+                                                         _ TX de-emphasis (db) = 20 * log_base_10((128 - 2 * pcs_tx_deemph)/128)
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
                                                          after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default Value is Package-Dependant. */
-	uint64_t pcs_tx_deemph_6db            : 6;  /**< Fine-tune transmitter driver de-emphasis when set to 6db.
-                                                         This static value sets the Tx driver de-emphasis value when pipeP_tx_deemph[1:0] is set to
+                                                         INTERNAL: Default value is package dependant. */
+	uint64_t pcs_tx_deemph_6db            : 6;  /**< Fine-tune transmitter driver deemphasis when set to 6db.
+                                                         This static value sets the TX driver deemphasis value when pipeP_tx_deemph[1:0] is set to
                                                          0x2 (according to the PIPE3 specification). This bus is provided for completeness and as a
-                                                         second potential launch amplitude. The values for transmit de-emphasis are derived from
-                                                         the following equation:
-                                                         TX de-emphasis (db) =
-                                                         20 * log_base_10((128 - 2 * pcs_tx_deemph)/128)
+                                                         second potential launch amplitude. The values for transmit deemphasis are derived from the
+                                                         following equation:
+                                                         _ TX de-emphasis (db) = 20 * log_base_10((128 - 2 * pcs_tx_deemph)/128)
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
                                                          after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default Value is Package-Dependant. */
+                                                         INTERNAL: Default value is package dependant. */
 	uint64_t pcs_tx_swing_full            : 7;  /**< Launch amplitude of the transmitter. Sets the launch amplitude of the transmitter. The
                                                          values for transmit amplitude are derived from the following equation:
                                                          TX amplitude (V) = vptx * ((pcs_tx_swing_full + 1)/128)
@@ -5902,13 +6064,13 @@ union cvmx_usbdrdx_uctl_portx_cfg_ss {
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
                                                          after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default Value is Package-Dependant. */
+                                                         INTERNAL: Default value is package dependant. */
 	uint64_t lane0_tx_term_offset         : 5;  /**< Transmitter termination offset. Reserved, set to 0x0. */
 	uint64_t reserved_6_7                 : 2;
-	uint64_t res_tune_ack                 : 1;  /**< While asserted, indicates a resistor tune is in progress. */
-	uint64_t res_tune_req                 : 1;  /**< Rising edge triggers a resistor tune request (if one is not already in progress). When
-                                                         asserted, RES_TUNE_ACK goes high until calibration of the termination impedance is
-                                                         complete.
+	uint64_t res_tune_ack                 : 1;  /**< Resistor tune acknowledge. While asserted, indicates a resistor tune is in progress. */
+	uint64_t res_tune_req                 : 1;  /**< Resistor tune request. The rising edge triggers a resistor tune request (if one is not
+                                                         already in progress). When asserted, RES_TUNE_ACK is asserted high until calibration of
+                                                         the termination impedance is complete.
                                                          Tuning disrupts the normal flow of data; therefore, assert RES_TUNE_REQ only when the PHY
                                                          is inactive. The PHY automatically performs a tune when coming out of PRST. */
 	uint64_t reserved_0_3                 : 4;
@@ -5930,6 +6092,7 @@ union cvmx_usbdrdx_uctl_portx_cfg_ss {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn70xx;
+	struct cvmx_usbdrdx_uctl_portx_cfg_ss_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cfg_ss cvmx_usbdrdx_uctl_portx_cfg_ss_t;
 
@@ -5937,9 +6100,13 @@ typedef union cvmx_usbdrdx_uctl_portx_cfg_ss cvmx_usbdrdx_uctl_portx_cfg_ss_t;
  * cvmx_usbdrd#_uctl_port#_cr_dbg_cfg
  *
  * Accessible by: only when H_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UCTL_RST]
- * This register allows indirect access to the configuration and test controls for the portX PHY.
  *
+ * This register allows indirect access to the configuration and test controls for the port 0
+ * PHY.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
+ *
+ * INTERNAL: (In body of HRM)
  * To access the PHY registers indirectly through the CR interface, the HCLK must be running,
  * UCTL_RST must be deasserted, and UPHY_RST must be deasserted. Software is responsible for
  * ensuring that only one indirect access is ongoing at a time.
@@ -6016,16 +6183,18 @@ union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn70xx;
+	struct cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg cvmx_usbdrdx_uctl_portx_cr_dbg_cfg_t;
 
 /**
  * cvmx_usbdrd#_uctl_port#_cr_dbg_status
  *
- * Accessible by: only when H_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UCTL_RST]
- * This register allows indirect access to the configuration and test controls for the portX PHY.
- * For usage, see above description in CR_DBG_CFG.
+ * Accessible by: only when H_CLKDIV_EN.
+ * This register allows indirect access to the configuration and test controls for the port 0
+ * PHY.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_portx_cr_dbg_status {
 	uint64_t u64;
@@ -6043,35 +6212,34 @@ union cvmx_usbdrdx_uctl_portx_cr_dbg_status {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn70xx;
+	struct cvmx_usbdrdx_uctl_portx_cr_dbg_status_s cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_portx_cr_dbg_status cvmx_usbdrdx_uctl_portx_cr_dbg_status_t;
 
 /**
  * cvmx_usbdrd#_uctl_shim_cfg
  *
- * Accessible by: only when H_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UCTL_RST]
- * This register allows configuration of various shim (UCTL) features.
- * Fields XS_NCB_OOB_* are captured when there are no outstanding OOB errors indicated in INTSTAT
- * and a new OOB error arrives.
- * Fields XS_BAD_DMA_* are captured when there are no outstanding DMA errors indicated in INTSTAT
- * and a new DMA error arrives.
+ * Accessible by: only when H_CLKDIV_EN.
+ * This register allows configuration of various shim (UCTL) features. The fields XS_NCB_OOB_*
+ * are captured when there are no outstanding OOB errors indicated in INTSTAT and a new OOB error
+ * arrives. The fields XS_BAD_DMA_* are captured when there are no outstanding DMA errors
+ * indicated in INTSTAT and a new DMA error arrives.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_shim_cfg {
 	uint64_t u64;
 	struct cvmx_usbdrdx_uctl_shim_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t xs_ncb_oob_wrn               : 1;  /**< Read/write error log for out-of-bound UAHC register access.
-                                                         0 = read, 1 = write */
+                                                         0 = read, 1 = write. */
 	uint64_t reserved_60_62               : 3;
 	uint64_t xs_ncb_oob_osrc              : 12; /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB
                                                          error.
-                                                         CSR bits Field bits Description
-                                                         [59:58] [11:10] chipID
-                                                         [57] [9] request source: 0 = core, 1 = IOI-device
-                                                         [56:51] [8:3] core/IOI-device number. Note that for
-                                                         IOI devices, [56]/[8] is always 0.
-                                                         [50:48] [2:0] SubID */
+                                                         <59:58> = chipID.
+                                                         <57> = Request source: 0 = core, 1 = NCB-device.
+                                                         <56:51> = Core/NCB-device number. Note that for NCB devices, <56> is always 0.
+                                                         <50:48> = SubID. */
 	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
                                                          0 = read error log, 1 = write error log */
 	uint64_t reserved_44_46               : 3;
@@ -6100,6 +6268,7 @@ union cvmx_usbdrdx_uctl_shim_cfg {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn70xx;
+	struct cvmx_usbdrdx_uctl_shim_cfg_s   cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_shim_cfg cvmx_usbdrdx_uctl_shim_cfg_t;
 
@@ -6107,7 +6276,7 @@ typedef union cvmx_usbdrdx_uctl_shim_cfg cvmx_usbdrdx_uctl_shim_cfg_t;
  * cvmx_usbdrd#_uctl_spare0
  *
  * Accessible by: always
- * Reset by: IOI reset (srst_n)
+ * This register can be reset by IOI reset.
  * This register is spare.
  */
 union cvmx_usbdrdx_uctl_spare0 {
@@ -6120,15 +6289,16 @@ union cvmx_usbdrdx_uctl_spare0 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_spare0_s     cn70xx;
+	struct cvmx_usbdrdx_uctl_spare0_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_spare0 cvmx_usbdrdx_uctl_spare0_t;
 
 /**
  * cvmx_usbdrd#_uctl_spare1
  *
- * Accessible by: only when H_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or USBDRD(0..1)_UCTL_CTL[UCTL_RST]
- * This register is spare.
+ * Accessible by: only when H_CLKDIV_EN.
+ *
+ * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
  */
 union cvmx_usbdrdx_uctl_spare1 {
 	uint64_t u64;
@@ -6140,6 +6310,7 @@ union cvmx_usbdrdx_uctl_spare1 {
 #endif
 	} s;
 	struct cvmx_usbdrdx_uctl_spare1_s     cn70xx;
+	struct cvmx_usbdrdx_uctl_spare1_s     cn70xxp1;
 };
 typedef union cvmx_usbdrdx_uctl_spare1 cvmx_usbdrdx_uctl_spare1_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-wqe.h b/arch/mips/include/asm/octeon/cvmx-wqe.h
index 785c7db..2ddabe0 100644
--- a/arch/mips/include/asm/octeon/cvmx-wqe.h
+++ b/arch/mips/include/asm/octeon/cvmx-wqe.h
@@ -141,7 +141,8 @@ enum cvmx_pki_layer_type {
 	CVMX_PKI_LTYPE_E_SW28                        = CVMX_PKI_LTYPE_E_SW28_M,
 	CVMX_PKI_LTYPE_E_SW29                        = CVMX_PKI_LTYPE_E_SW29_M,
 	CVMX_PKI_LTYPE_E_SW30                        = CVMX_PKI_LTYPE_E_SW30_M,
-	CVMX_PKI_LTYPE_E_SW31                        = CVMX_PKI_LTYPE_E_SW31_M
+	CVMX_PKI_LTYPE_E_SW31                        = CVMX_PKI_LTYPE_E_SW31_M,
+        CVMX_PKI_LTYPE_E_MAX                         = CVMX_PKI_LTYPE_E_SW31
 };
 
 
@@ -1101,9 +1102,9 @@ static inline void cvmx_wqe_set_grp(cvmx_wqe_t *work, int grp)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		unsigned node = cvmx_get_node_num();
 		/* legacy: GRP[0..2] :=QOS */
-		work->word1.cn78xx.grp = grp << 3;
-		work->word1.cn78xx.grp |= node;
-	} if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE))
+		work->word1.cn78xx.grp = 0xff & (grp << 3);
+		work->word1.cn78xx.grp |= (node << 8);
+	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE))
 		work->word1.cn68xx.grp = grp;
 	else
 		work->word1.cn38xx.grp = grp;
@@ -1283,7 +1284,7 @@ static inline void cvmx_wqe_set_aura(cvmx_wqe_t *work, int aura)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
 		work->word0.pki.aura = aura;
 	else
-		cvmx_dprintf("%s: ERROR: not supported for model\n",__func__);
+		work->packet_ptr.s.pool = aura;
 }
 
 static inline int cvmx_wqe_get_style(cvmx_wqe_t *work)
@@ -1502,7 +1503,7 @@ static inline int cvmx_wqe_get_bufs(cvmx_wqe_t *work)
 	else {
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 		/* Adjust for packet-in-WQE cases */
-		if(work->word2.s_cn38xx.bufs == 0)
+		if (work->word2.s_cn38xx.bufs == 0 && !work->word2.s.software)
 			(void) cvmx_wqe_get_packet_ptr(work);
 #endif
 		bufs = work->word2.s_cn38xx.bufs;
@@ -1545,6 +1546,34 @@ static inline bool cvmx_wqe_is_soft(cvmx_wqe_t *work)
 extern cvmx_wqe_t * cvmx_wqe_soft_create(void *data_p, unsigned data_sz);
 
 
+/* Errata (PKI-20776) PKI_BUFLINK_S's are endian-swapped
+   CN78XX pass 1.x has a bug where the packet pointer in each segment is
+   written in the opposite endianness of the configured mode. Fix these
+   here */
+static inline void cvmx_wqe_pki_errata_20776(cvmx_wqe_t *work)
+{
+        cvmx_wqe_78xx_t *wqe = (cvmx_wqe_78xx_t*) work;
+
+        if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && !wqe->pki_wqe_translated)
+        {
+                uint64_t bufs;
+                cvmx_buf_ptr_pki_t buffer_next;
+
+                bufs = wqe->word0.bufs;
+                buffer_next = wqe->packet_ptr;
+                while (bufs > 1) {
+                        cvmx_buf_ptr_pki_t next;
+                        void *nextaddr = cvmx_phys_to_ptr(buffer_next.addr - 8);
+                        memcpy (&next, nextaddr, sizeof(next));
+                        next.u64 = __builtin_bswap64(next.u64);
+                        memcpy (nextaddr, &next, sizeof(next));
+                        buffer_next = next;
+                        bufs--;
+                }
+        }
+        wqe->pki_wqe_translated = 1;
+}
+
 /**
  * @INTERNAL
  *
@@ -1554,14 +1583,14 @@ extern cvmx_wqe_t * cvmx_wqe_soft_create(void *data_p, unsigned data_sz);
  */
 static inline cvmx_buf_ptr_pki_t cvmx_wqe_get_pki_pkt_ptr(cvmx_wqe_t *work)
 {
-	cvmx_wqe_78xx_t * wqe = (void *) work;
-	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		cvmx_buf_ptr_pki_t x = {0};
-		return x;
-	}
-	return wqe->packet_ptr;
+        cvmx_wqe_78xx_t * wqe = (cvmx_wqe_78xx_t *) work;
+        if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+                cvmx_buf_ptr_pki_t x = {0};
+                return x;
+        }
+        cvmx_wqe_pki_errata_20776(work);
+        return wqe->packet_ptr;
 }
-
 /**
  * Set the buffer segment count for a packet.
  *
-- 
2.6.2

