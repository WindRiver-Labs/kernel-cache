From 770232967c70bd312334e28b2bf998f96eb9e7ef Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Tue, 22 Jul 2014 18:05:50 -0700
Subject: [PATCH 915/974] MIPS:OCTEON: Sync-up SE files

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c | 57 ++++++++--------------
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c | 14 ++++++
 .../cavium-octeon/executive/cvmx-helper-sgmii.c    |  5 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      | 10 ++--
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       | 31 +++++++++---
 arch/mips/include/asm/octeon/cvmx-app-init.h       |  4 +-
 arch/mips/include/asm/octeon/cvmx-pki.h            |  2 +-
 7 files changed, 68 insertions(+), 55 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 33060a3c..6546f2b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -136,7 +136,6 @@ int __cvmx_helper_bgx_enumerate(int xiface)
 	case CVMX_QLM_MODE_XAUI:
 	case CVMX_QLM_MODE_40G_KR4:
 	case CVMX_QLM_MODE_XLAUI:
-	case CVMX_QLM_MODE_RXAUI_1X2:
 		return 1;
 	case CVMX_QLM_MODE_RGMII_XAUI:
 	case CVMX_QLM_MODE_RGMII_40G_KR4:
@@ -147,26 +146,13 @@ int __cvmx_helper_bgx_enumerate(int xiface)
 	case CVMX_QLM_MODE_RGMII_SGMII_1X1:
 	case CVMX_QLM_MODE_10G_KR_1X2:
 	case CVMX_QLM_MODE_XFI_1X2:
+	case CVMX_QLM_MODE_RXAUI_1X2:
 		return 4;
 	default:
 		return 0;
 	}
 }
 
-static int __cvmx_helper_bgx_is_lmac_valid(int xiface, int index)
-{
-	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	cvmx_bgxx_cmrx_config_t cmr_config;
-
-	cmr_config.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
-	if (cmr_config.s.lane_to_sds == 0xe4
-	    && (cmr_config.s.lmac_type != 4
-		|| cmr_config.s.lmac_type != 1
-		|| cmr_config.s.lmac_type == 5))
-		return 0;
-	return 1;
-}
-
 /**
  * @INTERNAL
  * Disable the BGX port
@@ -496,7 +482,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_one_time(int xiface, int index)
 	cvmx_bgxx_gmp_pcs_miscx_ctl_t gmp_misc_ctl;
 	cvmx_bgxx_gmp_pcs_linkx_timer_t gmp_timer;
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xi.interface, index))
 		return 0;
 
 	if (debug)
@@ -582,7 +568,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init(int xiface, int num_ports)
 	for (index = start; index < end; index++) {
 		int xipd_port = cvmx_helper_get_ipd_port(xiface, index);
 
-		if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+		if (!cvmx_helper_is_port_valid(xiface, index))
 			continue;
 
 		__cvmx_helper_bgx_port_init(xipd_port, 0);
@@ -645,7 +631,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link(int xiface, int index)
 	int interface = xi.interface;
 	int node = xi.node;
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
 	if (debug)
@@ -727,7 +713,7 @@ static int __cvmx_helper_bgx_sgmii_hardware_init_link_speed(int xiface,
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int node = xi.node;
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
 	if (debug)
@@ -857,7 +843,7 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_sgmii_link_get(int xipd_port)
 
 	result.u64 = 0;
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return result;
 
 	if (debug)
@@ -888,7 +874,8 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_sgmii_link_get(int xipd_port)
 	}
 
 	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, xi.interface));
-	if (gmp_misc_ctl.s.mac_phy) {
+	if (gmp_misc_ctl.s.mac_phy ||
+	    cvmx_helper_get_port_force_link_up(xiface, index)) {
 		int qlm = cvmx_qlm_lmac(xiface, index);
 		int speed;
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX))
@@ -970,7 +957,7 @@ int __cvmx_helper_bgx_sgmii_link_set(int xipd_port,
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	int rc = 0;
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
 	if (debug)
@@ -1392,7 +1379,7 @@ int __cvmx_helper_bgx_sgmii_configure_loopback(int xipd_port, int enable_interna
 	cvmx_bgxx_gmp_pcs_mrx_control_t gmp_mrx_control;
 	cvmx_bgxx_gmp_pcs_miscx_ctl_t gmp_misc_ctl;
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
 	if (debug)
@@ -1449,20 +1436,14 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
 		cvmx_bgxx_spux_an_control_t spu_an_control;
+		cvmx_bgxx_spux_an_status_t spu_an_status;
 
 		spu_an_control.u64 = cvmx_read_csr_node(node,
 					CVMX_BGXX_SPUX_AN_CONTROL(index, interface));
 		if (spu_an_control.s.an_en) {
-			spu_int.u64 = cvmx_read_csr_node(node,
-						CVMX_BGXX_SPUX_INT(index, interface));
-			if (!spu_int.s.an_link_good) {
-				/* Clear the auto negotiation (W1C) */
-				spu_int.u64 = 0;
-				spu_int.s.an_complete = 1;
-				spu_int.s.an_link_good = 1;
-				spu_int.s.an_page_rx = 1;
-				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_INT(index, interface), spu_int.u64);
-
+			spu_an_status.u64 = cvmx_read_csr_node(node,
+						CVMX_BGXX_SPUX_AN_STATUS(index, interface));
+			if (!spu_an_status.s.an_complete) {
 				/* Restart auto negotiation */
 				spu_an_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_AN_CONTROL(index, interface));
 				spu_an_control.s.an_restart = 1;
@@ -1803,7 +1784,7 @@ int __cvmx_helper_bgx_mixed_enable(int xiface)
 		cvmx_bgxx_cmrx_config_t cmr_config;
 		int xipd_port, phy_pres = 0;
 
-		if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+		if (!cvmx_helper_is_port_valid(xiface, index))
 			continue;
 
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
@@ -2000,7 +1981,7 @@ void cvmx_helper_bgx_tx_options(unsigned node,
 	int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return;
 
 	if (debug)
@@ -2070,7 +2051,7 @@ void cvmx_helper_bgx_set_mac(int xipd_port, int bcst, int mcst, uint64_t mac)
 
 	index = cvmx_helper_get_interface_index_num(xipd_port);
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return;
 
 	if (debug)
@@ -2166,7 +2147,7 @@ void cvmx_helper_bgx_set_jabber(int xiface, unsigned index,
 	if (!octeon_has_feature(OCTEON_FEATURE_BGX))
 		return;
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return;
 
 	node = xi.node;
@@ -2204,7 +2185,7 @@ int cvmx_helper_bgx_shutdown_port(int xiface, int index)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
 		__func__, node, xi.interface, index);
 
-	if (!__cvmx_helper_bgx_is_lmac_valid(xiface, index))
+	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
 
 	/* Disable BGX CMR before we make any changes. */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index bb634ba..3e13adb 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -916,6 +916,20 @@ int __cvmx_helper_init_port_valid(void)
 		rc = __cvmx_helper_parse_bgx_dt(fdt_addr);
 		if (!rc && octeon_has_feature(OCTEON_FEATURE_BGX_XCV))
 			rc = __cvmx_helper_parse_bgx_rgmii_dt(fdt_addr);
+
+		/* Some ports are not in sequence, the device tree does not clear them */
+		for (i = 0; i < CVMX_HELPER_MAX_GMX; i++) {
+			int j;
+			for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
+				cvmx_bgxx_cmrx_config_t cmr_config;
+				cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(j, i));
+				if (cmr_config.s.lane_to_sds == 0xe4
+				    && cmr_config.s.lmac_type != 4
+				    && cmr_config.s.lmac_type != 1
+				    && cmr_config.s.lmac_type != 5)
+					cvmx_helper_set_port_valid(i, j, false);
+			}
+		}
 		return rc;
 	}
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
index 030c14c..0880e32 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
@@ -43,7 +43,7 @@
  * Functions for SGMII initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 107438 $<hr>
+ * <hr>$Revision: 122069 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -682,7 +682,8 @@ cvmx_helper_link_info_t __cvmx_helper_sgmii_link_get(int ipd_port)
 
 	pcsx_miscx_ctl_reg.u64 =
 		cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
-	if (pcsx_miscx_ctl_reg.s.mac_phy) {
+	if (pcsx_miscx_ctl_reg.s.mac_phy ||
+	    cvmx_helper_get_port_force_link_up(interface, index)) {
 		/* PHY Mode */
 		/* Note that this also works for 1000base-X mode */
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 91f832f..afe10e5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 122044 $<hr>
+ * <hr>$Revision: 122155 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1756,12 +1756,8 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		}
 	}
 
-	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
-		/* Disable Octeon's BAR0. We can't waste 8MB of address space */
-		CVMX_WRITE_CSR(CVMX_PEMX_P2N_BAR0_START(pcie_port), -1);
-	else
-		/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
-		CVMX_WRITE_CSR(CVMX_PEMX_P2N_BAR0_START(pcie_port), 0);
+	/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
+	CVMX_WRITE_CSR(CVMX_PEMX_P2N_BAR0_START(pcie_port), 0);
 
 	/* Set Octeon's BAR2 to decode 0-2^41. Bar0 and Bar1 take precedence
 	 * where they overlap. It also overlaps with the device addresses, so
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 75630b1..5baa497 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 122066 $<hr>
+ * <hr>$Revision: 122130 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1647,6 +1647,7 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 		}
 	} else if (gserx_cfg.s.bgx) {
 		cvmx_bgxx_cmrx_config_t cmr_config;
+		cvmx_bgxx_cmr_rx_lmacs_t bgx_cmr_rx_lmacs;
 		cvmx_bgxx_spux_br_pmd_control_t pmd_control;
 		int bgx = 0;
 		int start = 0, end = 4, index;
@@ -1679,11 +1680,17 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 			train_mask |= (pmd_control.s.train_en << (index * 4));
 		}
 
+		/* Need to include DLM5 lmacs when only DLM6 DLM is used */
+		if (mux == 2)
+			bgx_cmr_rx_lmacs.u64 = cvmx_read_csr(CVMX_BGXX_CMR_RX_LMACS(2));
 		switch(lane_mask) {
 		case 0:
-			if (mux == 1 || mux == 2)
+			if (mux == 1)
 				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII_2X1;
-			else
+			else if (mux == 2) {
+				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII_2X1;
+				bgx_cmr_rx_lmacs.s.lmacs = 4;
+			}
 				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII;
 			break;
 		case 0x1:
@@ -1698,7 +1705,10 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
 			break;
 		case 0x202:
-			if (mux == 2 || mux == 1)
+			if (mux == 2) {
+				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI_1X2; // RXAUI+RXAUI
+				bgx_cmr_rx_lmacs.s.lmacs = 4;
+			} else if (mux == 1)
 				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI_1X2; // RXAUI+RXAUI
 			else if (mux == 0)
 				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI;
@@ -1745,9 +1755,10 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 			break;
 
 		case 0x200:
-			if (mux == 2)
+			if (mux == 2) {
 				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI_1X2;
-			else
+				bgx_cmr_rx_lmacs.s.lmacs = 4;
+			} else
 		case 0x205:
 		case 0x233:
 		case 0x3302:
@@ -1765,6 +1776,7 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 					qlm_mode[qlm] = CVMX_QLM_MODE_10G_KR_1X2;
 				else
 					qlm_mode[qlm] = CVMX_QLM_MODE_XFI_1X2;
+				bgx_cmr_rx_lmacs.s.lmacs = 4;
 			} else
 				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
 			break;
@@ -1774,6 +1786,8 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 					qlm_mode[qlm] = CVMX_QLM_MODE_10G_KR_1X2;
 				else
 					qlm_mode[qlm] = CVMX_QLM_MODE_XFI_1X2;
+				if (mux == 2)
+					bgx_cmr_rx_lmacs.s.lmacs = 4;
 			} else
 				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
 			break;
@@ -1795,10 +1809,15 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 			qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
 			break;
 		}
+		if (mux == 2) {
+			cvmx_write_csr(CVMX_BGXX_CMR_RX_LMACS(2), bgx_cmr_rx_lmacs.u64);
+			cvmx_write_csr(CVMX_BGXX_CMR_TX_LMACS(2), bgx_cmr_rx_lmacs.u64);
+		}
 	} else if (gserx_cfg.s.sata)
 		qlm_mode[qlm] = CVMX_QLM_MODE_SATA_2X1;
 	else
 		qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
+
 	return qlm_mode[qlm];
 }
 
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index 07e4628..a0afda2 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 121038 $<hr>
+ * <hr>$Revision: 122068 $<hr>
  *
  */
 
@@ -293,6 +293,7 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_NIAGARA830 = 75,
 	CVMX_BOARD_TYPE_EBB7304 = 76,
 	CVMX_BOARD_TYPE_NIC73 = 77,	/* Liquid I/O */
+	CVMX_BOARD_TYPE_NIAGARA830_IM13166 = 78,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -438,6 +439,7 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA830)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7304)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC73)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA830_IM13166)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index ae3279c..3942da5 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -81,7 +81,7 @@ extern "C" {
 #define CVMX_PKI_NUM_INTERNAL_STYLE     (256)
 #define CVMX_PKI_NUM_FINAL_STYLE 	(64)
 #define CVMX_PKI_NUM_QPG_ENTRY		(2048)
-#define CVMX_PKI_NUM_MTAG_IDX	(32)
+#define CVMX_PKI_NUM_MTAG_IDX	(32 / 4) /*32 registers grouped by 4*/
 #define CVMX_PKI_NUM_LTYPE		(32)
 #define CVMX_PKI_NUM_PCAM_BANK		(2)
 #define CVMX_PKI_NUM_PCAM_ENTRY		(192)
-- 
2.6.2

