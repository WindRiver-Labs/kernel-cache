From c91a9904362d26340f22ddd3e3876a19324eadbc Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 17 Jul 2014 18:05:50 -0700
Subject: [PATCH 669/974] MIPS: OCTEON: Sync-up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |  16 +++
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c | 147 ++++++++++++++-------
 arch/mips/include/asm/octeon/cvmx-helper-cfg.h     |  15 ++-
 3 files changed, 131 insertions(+), 47 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 3814bb2..6d8bca1 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -1134,6 +1134,9 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
+	cvmx_helper_interface_mode_t mode;
+
+	mode = cvmx_helper_interface_get_mode(xiface);
 
 	__cvmx_bgx_common_init(xiface);
 	__cvmx_bgx_common_init_pknd(xiface);
@@ -1152,6 +1155,19 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 		smu_tx_thresh.s.cnt = 0x100;
 		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_THRESH(index, interface),
 					smu_tx_thresh.u64);
+		/* Set disparity for RXAUI interface as described in the
+		Marvell RXAUI Interface specification. */
+		if (mode == CVMX_HELPER_INTERFACE_MODE_RXAUI) {
+			if (cvmx_helper_get_port_phy_present(xiface, index)) {
+				cvmx_bgxx_spux_misc_control_t misc_control;
+				misc_control.u64 = cvmx_read_csr_node(node,
+						CVMX_BGXX_SPUX_MISC_CONTROL(index, interface));
+				misc_control.s.intlv_rdisp = 1;
+				cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, interface),
+						misc_control.u64);
+			}
+		}
+
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
 		cmr_config.s.enable = 1;
 		cmr_config.s.data_pkt_tx_en = 1;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index fde6197..4832c43 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -96,7 +96,8 @@ CVMX_SHARED struct cvmx_cfg_port_param cvmx_cfg_port[CVMX_MAX_NODES][CVMX_HELPER
 				.agl_rx_clk_delay_bypass = false,
 				.force_link_up = false,
 				.disable_an = false,
-				.link_down_pwr_dn = false
+				.link_down_pwr_dn = false,
+				.phy_present = false
 			}
 		}
 	};
@@ -300,7 +301,8 @@ int init_cvmx_pko_que_range(void)
 	queue_range_init = 1;
 	rv = cvmx_create_global_resource_range(CVMX_GR_TAG_PKO_QUEUES, CVMX_HELPER_CFG_MAX_PKO_QUEUES);
 	if (rv!=0) {
-		cvmx_dprintf("ERROR : Failed to initalize pko queues range\n");
+		cvmx_printf("ERROR: %s: Failed to initalize pko queues range\n",
+			__func__);
 	}
 	return rv;
 }
@@ -327,7 +329,7 @@ static int cvmx_pko_queue_alloc(uint64_t port, int count)
 
     if (cvmx_pko_queue_table[port].ccppp_num_queues > 0) {
 	    cvmx_printf("WARNING: %s port=%d already %d queues\n",
-		__func__, (int)port, 
+		__func__, (int)port,
 		(int)cvmx_pko_queue_table[port].ccppp_num_queues);
 	return -1;
     }
@@ -502,6 +504,7 @@ void cvmx_helper_cfg_set_jabber_and_frame_max()
 	int interface, port;
 
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		int ipd_port;
 
 		/*Set the frame max size and jabber size to 65535. */
 		for (interface = 0; interface < cvmx_helper_get_number_of_interfaces(); interface++) {
@@ -512,6 +515,12 @@ void cvmx_helper_cfg_set_jabber_and_frame_max()
 
 			switch (imode) {
 			case CVMX_HELPER_INTERFACE_MODE_SGMII:
+				for (port = 0; port < num_ports; port++) {
+					ipd_port = cvmx_helper_get_ipd_port(interface, port);
+					cvmx_pki_set_max_frm_len(ipd_port, -1);
+					cvmx_write_csr(CVMX_BGXX_GMP_GMI_RXX_JABBER(port, interface), 65535);
+				}
+				break;
 			case CVMX_HELPER_INTERFACE_MODE_XAUI:
 			case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 			case CVMX_HELPER_INTERFACE_MODE_XLAUI:
@@ -519,10 +528,9 @@ void cvmx_helper_cfg_set_jabber_and_frame_max()
 			case CVMX_HELPER_INTERFACE_MODE_10G_KR:
 			case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 				for (port = 0; port < num_ports; port++) {
-					int ipd_port;
 					ipd_port = cvmx_helper_get_ipd_port(interface, port);
 					cvmx_pki_set_max_frm_len(ipd_port, -1);
-					cvmx_write_csr(CVMX_BGXX_GMP_GMI_RXX_JABBER(port, interface), 65535);
+					cvmx_write_csr(CVMX_BGXX_SMUX_RX_JABBER(port, interface), 65535);
 				}
 				break;
 			default:
@@ -584,25 +592,39 @@ void cvmx_helper_cfg_set_jabber_and_frame_max()
 	}
 }
 
+/**
+ * Enable storing short packets only in the WQE
+ * unless NO_WPTR is set, which already has the same effect
+ */
 void cvmx_helper_cfg_store_short_packets_in_wqe()
 {
 	int interface, port;
+	cvmx_ipd_ctl_status_t ipd_ctl_status;
+	unsigned dyn_rs = 1;
 
-	if (!OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-		for (interface = 0; interface < cvmx_helper_get_number_of_interfaces(); interface++) {
-			int num_ports = cvmx_helper_ports_on_interface(interface);
-			/* Enable storing short packets only in the WQE */
-			for (port = 0; port < num_ports; port++) {
-				cvmx_pip_port_cfg_t port_cfg;
-				int pknd = port;
-				if (octeon_has_feature(OCTEON_FEATURE_PKND))
-					pknd = cvmx_helper_get_pknd(interface, port);
-				else
-					pknd = cvmx_helper_get_ipd_port(interface, port);
-				port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
-				port_cfg.s.dyn_rs = 1;
-				cvmx_write_csr(CVMX_PIP_PRT_CFGX(pknd), port_cfg.u64);
-			}
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+		return;
+
+	/* NO_WPTR combines WQE with 1st MBUF, RS is redundant */
+	ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	if (ipd_ctl_status.s.no_wptr) {
+		dyn_rs = 0;
+		/* Note: consider also setting 'ignrs' wtn NO_WPTR is set */
+	}
+
+	for (interface = 0; interface < cvmx_helper_get_number_of_interfaces();
+		 interface++) {
+		int num_ports = cvmx_helper_ports_on_interface(interface);
+		for (port = 0; port < num_ports; port++) {
+			cvmx_pip_port_cfg_t port_cfg;
+			int pknd = port;
+			if (octeon_has_feature(OCTEON_FEATURE_PKND))
+				pknd = cvmx_helper_get_pknd(interface, port);
+			else
+				pknd = cvmx_helper_get_ipd_port(interface, port);
+			port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
+			port_cfg.s.dyn_rs = dyn_rs;
+			cvmx_write_csr(CVMX_PIP_PRT_CFGX(pknd), port_cfg.u64);
 		}
 	}
 }
@@ -627,6 +649,14 @@ int __cvmx_helper_cfg_pko_port_eid(int pko_port)
 #define IPD2PKO_CACHE_Y(ipd_port)	(ipd_port) >> 8
 #define IPD2PKO_CACHE_X(ipd_port)	(ipd_port) & 0xff
 
+inline int __cvmx_helper_cfg_ipd2pko_cachex(int ipd_port)
+{
+	int ipd_x = IPD2PKO_CACHE_X(ipd_port);
+	if (ipd_port & 0x800)
+		ipd_x = (ipd_x >> 4) & 3;
+	return ipd_x;
+}
+
 /*
  * ipd_port to pko_port translation cache
  */
@@ -641,9 +671,9 @@ int __cvmx_helper_cfg_init_ipd2pko_cache(void)
 		for (j = 0; j < n; j++) {
 			ipd_port = cvmx_helper_get_ipd_port(i, j);
 			ipd_y = IPD2PKO_CACHE_Y(ipd_port);
-			ipd_x = IPD2PKO_CACHE_X(ipd_port);
+			ipd_x = __cvmx_helper_cfg_ipd2pko_cachex(ipd_port);
 			ipd2pko_port_cache[ipd_y]
-			    [(ipd_port & 0x800) ? ((ipd_x >> 4) & 3) : ipd_x] = (struct cvmx_cfg_pko_port_pair) {
+			    [ipd_x] = (struct cvmx_cfg_pko_port_pair) {
 			__cvmx_helper_cfg_pko_port_base(i, j), __cvmx_helper_cfg_pko_port_num(i, j)};
 		}
 	}
@@ -660,10 +690,9 @@ int cvmx_helper_cfg_ipd2pko_port_base(int ipd_port)
 		return ipd_port;
 
 	ipd_y = IPD2PKO_CACHE_Y(ipd_port);
-	ipd_x = IPD2PKO_CACHE_X(ipd_port);
+	ipd_x = __cvmx_helper_cfg_ipd2pko_cachex(ipd_port);
 
-	return ipd2pko_port_cache[ipd_y]
-	    [(ipd_port & 0x800) ? ((ipd_x >> 4) & 3) : ipd_x].ccppp_base_port;
+	return ipd2pko_port_cache[ipd_y][ipd_x].ccppp_base_port;
 }
 
 int cvmx_helper_cfg_ipd2pko_port_num(int ipd_port)
@@ -673,8 +702,7 @@ int cvmx_helper_cfg_ipd2pko_port_num(int ipd_port)
 	ipd_y = IPD2PKO_CACHE_Y(ipd_port);
 	ipd_x = IPD2PKO_CACHE_X(ipd_port);
 
-	return ipd2pko_port_cache[ipd_y]
-	    [(ipd_port & 0x800) ? ((ipd_x >> 4) & 3) : ipd_x].ccppp_nports;
+	return ipd2pko_port_cache[ipd_y][ipd_x].ccppp_nports;
 }
 
 /**
@@ -849,6 +877,20 @@ bool cvmx_helper_get_port_force_link_up(int xiface, int index)
 }
 EXPORT_SYMBOL(cvmx_helper_get_port_force_link_up);
 
+void cvmx_helper_set_port_phy_present(int xiface, int index, bool value)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	cvmx_cfg_port[xi.node][xi.interface][index].phy_present = value;
+}
+EXPORT_SYMBOL(cvmx_helper_set_port_phy_present);
+
+bool cvmx_helper_get_port_phy_present(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	return cvmx_cfg_port[xi.node][xi.interface][index].phy_present;
+}
+EXPORT_SYMBOL(cvmx_helper_get_port_phy_present);
+
 int __cvmx_helper_init_port_valid(void)
 {
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
@@ -960,6 +1002,7 @@ int __cvmx_helper_init_port_config_data(void)
 	int rv = 0;
 	int i, j, n;
 	int num_interfaces, interface;
+	int pknd = 0, bpid = 0;
 #if !defined(CVMX_BUILD_FOR_LINUX_KERNEL)
 	const int use_static_config = 1;
 #else
@@ -969,9 +1012,30 @@ int __cvmx_helper_init_port_config_data(void)
 	if (dbg)
 		cvmx_printf("%s:\n",__func__);
 
-	if (octeon_has_feature(OCTEON_FEATURE_PKND))
-	{
-		int pknd = 0, bpid = 0;
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		/* PKO3: only needs BPID, PKND to be setup,
+		 * while the rest of PKO3 init is done in cvmx-helper-pko3.c
+		 */
+		for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+			n = cvmx_helper_interface_enumerate(i);
+			if (cvmx_helper_interface_get_mode(i) !=
+				CVMX_HELPER_INTERFACE_MODE_NPI) {
+				for (j = 0; j < n; j++) {
+					cvmx_cfg_port[0][i][j].ccpp_pknd = pknd++;
+					cvmx_cfg_port[0][i][j].ccpp_bpid = bpid++;
+				}
+			} else {
+				for (j = 0; j < n; j++) {
+					cvmx_cfg_port[0][i][j].ccpp_pknd = pknd;
+					cvmx_cfg_port[0][i][j].ccpp_bpid = bpid;
+				}
+				pknd++;
+				bpid++;
+			}
+		} /* for i=0 */
+		cvmx_helper_cfg_assert(pknd <= CVMX_HELPER_CFG_MAX_PIP_PKND);
+		cvmx_helper_cfg_assert(bpid <= CVMX_HELPER_CFG_MAX_PIP_BPID);
+	} else if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
 
 		if (use_static_config)
 			cvmx_helper_cfg_init_pko_iports_and_queues_using_static_config();
@@ -979,29 +1043,22 @@ int __cvmx_helper_init_port_config_data(void)
 		/* Initialize pknd and bpid */
 		for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
                         n = cvmx_helper_interface_enumerate(i);
-                        if (cvmx_helper_interface_get_mode(i) == CVMX_HELPER_INTERFACE_MODE_NPI &&
-                            OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-                                for (j = 0; j < n; j++) {
-                                        cvmx_cfg_port[0][i][j].ccpp_pknd = pknd;
-                                        cvmx_cfg_port[0][i][j].ccpp_bpid = bpid;
-                                }
-                                pknd++;
-                                bpid++;
-                        } else {
-                                for (j = 0; j < n; j++) {
-                                        cvmx_cfg_port[0][i][j].ccpp_pknd = pknd++;
-                                        cvmx_cfg_port[0][i][j].ccpp_bpid = bpid++;
-                                }
-                        }
+			for (j = 0; j < n; j++) {
+				cvmx_cfg_port[0][i][j].ccpp_pknd = pknd++;
+				cvmx_cfg_port[0][i][j].ccpp_bpid = bpid++;
+			}
                 }
 		cvmx_helper_cfg_assert(pknd <= CVMX_HELPER_CFG_MAX_PIP_PKND);
 		cvmx_helper_cfg_assert(bpid <= CVMX_HELPER_CFG_MAX_PIP_BPID);
-
 	} else {
 		if (use_static_config)
 			cvmx_pko_queue_init_from_cvmx_config_non_pknd();
 	}
 
+	/* Remainder not used for PKO3 */
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
+		return 0;
+
 	/* init ports, queues which are not initialized */
 	num_interfaces = cvmx_helper_get_number_of_interfaces();
 	for (interface = 0; interface < num_interfaces; interface++) {
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
index 6f4afce..5e69df0 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -123,12 +123,11 @@ struct cvmx_phy_info;
 
 /*
  * Per physical port
+ * Note: This struct is passed between linux and SE apps.
  */
 struct cvmx_cfg_port_param {
-#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	int port_fdt_node;		/** Node offset in FDT of node */
 	int phy_fdt_node;		/** Node offset in FDT of PHY */
-#endif
 	struct cvmx_phy_info *phy_info;	/** Data structure with PHY information */
 	int8_t ccpp_pknd;
 	int8_t ccpp_bpid;
@@ -142,6 +141,7 @@ struct cvmx_cfg_port_param {
 	bool force_link_up:1;		/** Ignore PHY and always report link up */
 	bool disable_an:1;		/** true to disable autonegotiation */
 	bool link_down_pwr_dn:1;	/** Power PCS off when link is down */
+	bool phy_present:1;		/** true if PHY is present */
 };
 
 /*
@@ -500,6 +500,17 @@ extern void cvmx_helper_set_port_force_link_up(int interface, int index,
 
 /**
  * @INTERNAL
+ * Return true if PHY is present to the passed xiface
+ *
+ * @param interface the interface number
+ * @param index the port's index
+ */
+extern bool cvmx_helper_get_port_phy_present(int xiface, int index);
+extern void cvmx_helper_set_port_phy_present(int xiface, int index,
+					     bool value);
+
+/**
+ * @INTERNAL
  * Return the AGL port rx clock skew, only used
  * if agl_rx_clock_delay_bypass is set.
  *
-- 
2.6.2

