From d05e200cb4724e656f787b6051d86fe888b53324 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Thu, 12 Nov 2015 16:46:51 -0800
Subject: [PATCH 166/184] netdev: octeon-pow: Update wqe with packet
 information.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-pow-ethernet.c | 76 +++++++++++++----------
 1 file changed, 42 insertions(+), 34 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-pow-ethernet.c b/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
index 1b4a715..49a23c9 100644
--- a/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
@@ -14,8 +14,10 @@
 #include <linux/etherdevice.h>
 #include <linux/in.h>
 #include <linux/ip.h>
+#include <linux/ipv6.h>
 #include <linux/string.h>
 #include <linux/delay.h>
+#include <linux/if_vlan.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx.h>
@@ -315,12 +317,13 @@ static cvmx_wqe_t *octeon_skb_to_fpa_buf(struct net_device *dev,
 			*(uint64_t *)prev_packet_ptr = *(uint64_t *)packet_ptr;
 
 		num_segments++;
-		cvmx_wqe_set_bufs(work, num_segments);
 		len -= segment_len;
 		data_ptr += segment_len;
 		prev_packet_ptr = packet_ptr;
 	}
 
+	cvmx_wqe_set_bufs(work, num_segments);
+
 	return work;
 
  error:
@@ -377,52 +380,57 @@ static int octeon_pow_xmit(struct sk_buff *skb, struct net_device *dev)
 		cvmx_wqe_set_grp(work, send_group);
 		cvmx_wqe_set_tt(work, 2);
 		cvmx_wqe_set_tag(work, 0);
-
 		cvmx_wqe_set_aura(work, fpa_packet_pool);
 
+		if (skb->protocol == htons(ETH_P_8021Q)) {
+			struct vlan_hdr *vhdr;
+
+			cvmx_wqe_set_vlan(work, true);
+#if 0
+			work->word2.s.vlan_cfi = 0;	/* FIXME */
+			work->word2.s.vlan_id = 0;	/* FIXME */
+			work->word2.s.dec_ipcomp = 0;	/* FIXME */
+#endif
+			vhdr = (struct vlan_hdr *)(skb->data + ETH_HLEN);
+			vlan_set_encap_proto(skb, vhdr);
+		}
+
 		if (skb->protocol == htons(ETH_P_IP)) {
-			cvmx_wqe_set_l3_offset(work, 14);
-			cvmx_wqe_set_l4_udp(work, ip_hdr(skb)->protocol == IPPROTO_UDP);
-			if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE) ||
-				(ip_hdr(skb)->protocol == IPPROTO_TCP))
-				cvmx_wqe_set_l4_tcp(work, ip_hdr(skb)->protocol == IPPROTO_TCP);
+			cvmx_wqe_set_l3_ipv4(work, true);
+			cvmx_wqe_set_l3_offset(work,
+				(uint)(skb_network_header(skb) - skb->data));
+			if (ip_hdr(skb)->protocol == IPPROTO_UDP)
+				cvmx_wqe_set_l4_udp(work, true);
+			else if (ip_hdr(skb)->protocol == IPPROTO_TCP)
+				cvmx_wqe_set_l4_tcp(work, true);
 			cvmx_wqe_set_l3_frag(work, !((ip_hdr(skb)->frag_off == 0)
 						     || (ip_hdr(skb)->frag_off ==
 							 1 << 14)));
 			cvmx_wqe_set_l2_bcast(work, skb->pkt_type == PACKET_BROADCAST);
 			cvmx_wqe_set_l2_mcast(work, skb->pkt_type == PACKET_MULTICAST);
-#if 0
-			work->word2.s.vlan_valid = 0;	/* FIXME */
-			work->word2.s.vlan_cfi = 0;	/* FIXME */
-			work->word2.s.vlan_id = 0;	/* FIXME */
-			work->word2.s.dec_ipcomp = 0;	/* FIXME */
-			if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
-				work->word2.s.IP_exc = 0; /* Assume Linux is sending
-							     a good packet */
-			work->word2.s.IP_exc = 0; /* Assume Linux is sending
-						     a good packet */
-			work->word2.s.not_IP = 0; /* This is an IP packet */
-			work->word2.s.rcv_error = 0; /* No error, packet is
-							internal */
-			work->word2.s.err_code = 0;  /* No error, packet is
-							internal */
-#endif
 
 			/* When copying the data, include 4 bytes of the
 			   ethernet header to align the same way hardware does */
 			octeon_pow_copy_to(work->packet_data, skb->data + 10,
 			       sizeof(work->packet_data));
-		} else {
-#if 0
-			work->word2.snoip.is_rarp =
-				skb->protocol == htons(ETH_P_RARP);
-			work->word2.snoip.is_arp =
-				skb->protocol == htons(ETH_P_ARP);
-			work->word2.snoip.is_bcast =
-				(skb->pkt_type == PACKET_BROADCAST);
-			work->word2.snoip.is_mcast =
-				(skb->pkt_type == PACKET_MULTICAST);
-#endif
+		} else if (skb->protocol == htons(ETH_P_IPV6)) {
+			cvmx_wqe_set_l3_ipv6(work, 1);
+			cvmx_wqe_set_l3_offset(work,
+				(uint)(skb_network_header(skb) - skb->data));
+			if (ipv6_hdr(skb)->nexthdr == IPPROTO_UDP)
+				cvmx_wqe_set_l4_udp(work, true);
+			else if (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)
+				cvmx_wqe_set_l4_tcp(work, true);
+		} else if (skb->protocol == htons(ETH_P_ARP))
+			cvmx_wqe_set_l3_arp(work, true);
+		else {
+			if (skb->pkt_type == PACKET_BROADCAST)
+				cvmx_wqe_set_l2_bcast(work, true);
+			if (skb->pkt_type == PACKET_MULTICAST)
+				cvmx_wqe_set_l2_mcast(work, true);
+			if (skb->protocol == htons(ETH_P_RARP))
+				cvmx_wqe_set_l3_rarp(work, work);
+
 			cvmx_wqe_set_l3_ipv4(work, 0);
 			octeon_pow_copy_to(work->packet_data, skb->data,
 			       sizeof(work->packet_data));
-- 
1.9.1

