From 7002a1d02707919ae786deb1d50bdb19b51357a2 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sat, 5 Jul 2014 18:05:50 -0700
Subject: [PATCH 862/974] netdev: octeon-bgx: Fix race conditions in status
 polling work.

All locking is safe to do with a mutex, use that to make sure we can
cleanly shut down and restart the status polling work.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-port.c | 25 ++++++++++++++++++-------
 1 file changed, 18 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 78a82d6..f43cad4 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -54,11 +54,12 @@ struct bgx_port_priv {
 	struct phy_device *phydev;
 	struct device_node *phy_np;
 	struct net_device *netdev;
-	spinlock_t lock;
+	struct mutex lock;
 	unsigned int last_duplex;
 	unsigned int last_link;
 	unsigned int last_speed;
 	struct delayed_work dwork;
+	bool work_queued;
 };
 
 static struct workqueue_struct *check_state_wq;
@@ -227,9 +228,8 @@ static void bgx_port_adjust_link(struct net_device *netdev)
 	struct bgx_port_priv *p = bgx_port_netdev2priv(netdev);
 	int link_changed = 0;
 	unsigned int link, speed, duplex;
-	unsigned long flags;
 
-	spin_lock_irqsave(&p->lock, flags);
+	mutex_lock(&p->lock);
 
 	if (!p->phydev->link && p->last_link)
 		link_changed = -1;
@@ -245,7 +245,7 @@ static void bgx_port_adjust_link(struct net_device *netdev)
 	speed = p->last_speed = p->phydev->speed;
 	duplex = p->last_duplex = p->phydev->duplex;
 
-	spin_unlock_irqrestore(&p->lock, flags);
+	mutex_unlock(&p->lock);
 
 	if (link_changed != 0) {
 		cvmx_helper_link_info_t link_info;
@@ -289,7 +289,10 @@ static void bgx_port_check_state(struct work_struct *work)
 			pr_info("%s: Link is down\n", priv->netdev->name);
 	}
 
-	queue_delayed_work(check_state_wq, &priv->dwork, HZ);
+	mutex_lock(&priv->lock);
+	if (priv->work_queued)
+		queue_delayed_work(check_state_wq, &priv->dwork, HZ);
+	mutex_unlock(&priv->lock);
 }
 
 int bgx_port_enable(struct net_device *netdev)
@@ -371,8 +374,12 @@ int bgx_port_enable(struct net_device *netdev)
 		if (!check_state_wq)
 			return -ENOMEM;
 
+		mutex_lock(&priv->lock);
 		INIT_DELAYED_WORK(&priv->dwork, bgx_port_check_state);
 		queue_delayed_work(check_state_wq, &priv->dwork, 0);
+		priv->work_queued = true;
+		mutex_unlock(&priv->lock);
+
 		pr_info("%s: Link is not ready\n", netdev->name);
 
 		return 0;
@@ -407,8 +414,12 @@ int bgx_port_disable(struct net_device *netdev)
 	priv->last_link = 0;
 	cvmx_helper_link_set(priv->ipd_port, link_info);
 
-	if (priv->phy_np == NULL)
+	mutex_lock(&priv->lock);
+	if (priv->work_queued) {
 		cancel_delayed_work_sync(&priv->dwork);
+		priv->work_queued = false;
+	}
+	mutex_unlock(&priv->lock);
 
 	return 0;
 }
@@ -482,7 +493,7 @@ static int bgx_port_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	spin_lock_init(&priv->lock);
+	mutex_init(&priv->lock);
 	priv->numa_node = numa_node;
 	priv->bgx_interface = (addr >> 24) & 0xf;
 	priv->index = index;
-- 
2.6.2

