From 53af9819430016f98001c9498989fdded6b32b36 Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Sat, 19 Jul 2014 18:05:50 -0700
Subject: [PATCH 645/974] net: phy: qca833x cleanup, save/restore settings on
 reset

All interesting switch-specific or per-port state now saved before reset,
and re-applied after.
- allows full state recovery on PCS-cycle reset
- avoids the need to do platform-specific setup in phy driver
- allows extension to PM save/restore

Platform-specific setup (eg VLANs, routing, QoS) can be done in u-boot
or platform-init code, and it will be saved as driver launches, so it can
be re-applied when the power is cycled to fix link-state race.

Tables of save/restore registers have been built matching kernel/u-boot
footprint (every MII or qca833x-specific register ever written),
and if more registers are modified they can simply be added to table.

Also removed dead code & cleaned up naming.

Still does not support port0 of qca8337 on router7000 board
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/phy/qca833x.c | 205 +++++++++++++++++++++++++++++++++-------------
 drivers/net/phy/qca833x.h |  57 -------------
 2 files changed, 146 insertions(+), 116 deletions(-)

diff --git a/drivers/net/phy/qca833x.c b/drivers/net/phy/qca833x.c
index 0c035bf..30440a8 100644
--- a/drivers/net/phy/qca833x.c
+++ b/drivers/net/phy/qca833x.c
@@ -28,8 +28,8 @@ MODULE_DESCRIPTION("Qualcomm qca833x PHY driver");
 #define qports(phydev) (*(int*)&(phydev)->priv)
 
 /* compound read/write must hold mdio mutex */
-#define muget(phydev) mutex_lock(&(phydev)->bus->mdio_lock)
-#define muput(phydev) mutex_unlock(&(phydev)->bus->mdio_lock)
+#define qphy_muget(phydev) mutex_lock(&(phydev)->bus->mdio_lock)
+#define qphy_muput(phydev) mutex_unlock(&(phydev)->bus->mdio_lock)
 
 /* read/write given mdio addrs, caller holds mutex */
 static inline int __phy_read_addr(struct phy_device *phydev, u32 addr,
@@ -62,7 +62,7 @@ static uint32_t __used qphy_read32(struct phy_device *phydev, uint32_t reg_addr)
 
 	/* configure register high address */
 	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);	/* bit16-8 of reg address */
-	muget(phydev);
+	qphy_muget(phydev);
 	__phy_write_addr(phydev, 0x18, 0, phy_val);
 
 	/* For some registers such as MIBs, since it is read/clear, we should */
@@ -80,7 +80,7 @@ static uint32_t __used qphy_read32(struct phy_device *phydev, uint32_t reg_addr)
 	tmp_val = (uint32_t) __phy_read_addr(phydev, phy_addr, phy_reg);
 	reg_val |= (tmp_val << 16);
 
-	muput(phydev);
+	qphy_muput(phydev);
 
 	return reg_val;
 
@@ -99,7 +99,7 @@ static void qphy_write32(struct phy_device *phydev, uint32_t reg_addr,
 
 	/* configure register high address */
 	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);	/* bit16-8 of reg address */
-	muget(phydev);
+	qphy_muget(phydev);
 	__phy_write_addr(phydev, 0x18, 0, phy_val);
 
 	/* For some registers such as ARL and VLAN, since they include BUSY bit */
@@ -119,56 +119,138 @@ static void qphy_write32(struct phy_device *phydev, uint32_t reg_addr,
 	phy_reg = (uint8_t) (reg_word_addr & 0x1f);	/* bit4-0 of reg address */
 	phy_val = (uint16_t) (reg_val & 0xffff);
 	__phy_write_addr(phydev, phy_addr, phy_reg, phy_val);
-	muput(phydev);
+	qphy_muput(phydev);
 
 	pr_debug("%s %x := %x\n", __func__, reg_addr, reg_val);
 }
 
 
-#ifdef notdef
 /*
- * V-lan configuration given by Switch team
- * Vlan 1:PHY0,1,2,3 and Mac 0 of s17
- * Vlam 2:PHY4 and Mac 6 of s17
+ * mii per-port config, captured at before reset to re-impose after reset
+ * see net: phy: at803x: Add support for hardware reset (13a56b44)
+ * where at803x driver is fixed to save/restore modes over reset:
+ *   "The AT8030 will enter a FIFO error mode if a packet is transmitted while
+ *   the cable is unplugged. This hardware issue is acknowledged by the
+ *   vendor, and the only proposed solution is to conduct a hardware reset
+ *   via the external pin each time the link goes down. There is apparantly
+ *   no way to fix up the state via the register set."
+ * The qca833x also needs this, but for each of its qports(phydev) ports
  */
 
-static void qphy_vlan_config(struct phy_device *phydev)
-{
-
-	qphy_write32(phydev, S17_P0LOOKUP_CTRL_REG, 0x0014001e);
-	qphy_write32(phydev, S17_P0VLAN_CTRL0_REG, 0x10001);
-
-	qphy_write32(phydev, S17_P1LOOKUP_CTRL_REG, 0x0014001d);
-	qphy_write32(phydev, S17_P1VLAN_CTRL0_REG, 0x10001);
-
-	qphy_write32(phydev, S17_P2LOOKUP_CTRL_REG, 0x0014001b);
-	qphy_write32(phydev, S17_P2VLAN_CTRL0_REG, 0x10001);
-
-	qphy_write32(phydev, S17_P3LOOKUP_CTRL_REG, 0x00140017);
-	qphy_write32(phydev, S17_P3VLAN_CTRL0_REG, 0x10001);
+struct port_context {
+	u16 bmcr;
+	u16 advertise;
+	u16 control1000;
+	u16 int_enable;
+	u16 phy_spec;
+	u16 led_control;
+};
+static struct port_context port_context[7]; /* should be in phydev->priv */
 
-	qphy_write32(phydev, S17_P4LOOKUP_CTRL_REG, 0x0014000f);
-	qphy_write32(phydev, S17_P4VLAN_CTRL0_REG, 0x10001);
+/* save relevant PHY registers to private copy */
+static void port_context_save(struct phy_device *phydev, int addr,
+				struct port_context *context)
+{
+	qphy_muget(phydev);
+	context->bmcr = __phy_read_addr(phydev, addr, MII_BMCR);
+	context->advertise = __phy_read_addr(phydev, addr, MII_ADVERTISE);
+	context->control1000 = __phy_read_addr(phydev, addr, MII_CTRL1000);
+	context->int_enable = __phy_read_addr(phydev, addr, S17_PHY_INT_EN_REG);
+	context->phy_spec = __phy_read_addr(phydev, addr, ATHR_PHY_SPEC_CONTROL);
+	qphy_muput(phydev);
+}
 
-	qphy_write32(phydev, S17_P5LOOKUP_CTRL_REG, 0x00140040);
-	qphy_write32(phydev, S17_P5VLAN_CTRL0_REG, 0x20001);
+/* restore relevant PHY registers from private copy */
+static void port_context_restore(struct phy_device *phydev, int addr,
+				   const struct port_context *context)
+{
+	qphy_muget(phydev);
+	__phy_write_addr(phydev, addr, MII_BMCR, context->bmcr);
+	__phy_write_addr(phydev, addr, MII_ADVERTISE, context->advertise);
+	__phy_write_addr(phydev, addr, MII_CTRL1000, context->control1000);
+	__phy_write_addr(phydev, addr, S17_PHY_INT_EN_REG, context->int_enable);
+	__phy_write_addr(phydev, addr, ATHR_PHY_SPEC_CONTROL, context->phy_spec);
+	qphy_muput(phydev);
+}
 
-	qphy_write32(phydev, S17_P6LOOKUP_CTRL_REG, 0x00140020);
-	qphy_write32(phydev, S17_P6VLAN_CTRL0_REG, 0x20001);
+/*
+ * But qca833x also has non-mii switch config (vlan/etc)
+ * This is captured at _init to re-impose after reset
+ */
+static struct qmodes {
+	u32 addr;
+	u32 val;
+	bool saved;
+} qmodes[] = {
+	{ S17_MASK_CTRL_REG },
+	{ S17_P0PAD_MODE_REG },
+	{ S17_P0STATUS_REG },
+	{ S17_P0PAD_MODE_REG },
+	{ S17_P6PAD_MODE_REG },
+	{ S17_P6STATUS_REG },
+	{ S17_GLOFW_CTRL1_REG },
+	{ S17_SGMII_CTRL_REG },
+	{ S17_P0LOOKUP_CTRL_REG },
+	{ S17_P0VLAN_CTRL0_REG },
+	{ S17_P1LOOKUP_CTRL_REG },
+	{ S17_P1VLAN_CTRL0_REG },
+	{ S17_P2LOOKUP_CTRL_REG },
+	{ S17_P2VLAN_CTRL0_REG },
+	/* rest are 8337-only? */
+	{ S17_P3LOOKUP_CTRL_REG },
+	{ S17_P3VLAN_CTRL0_REG },
+	{ S17_P4LOOKUP_CTRL_REG },
+	{ S17_P4VLAN_CTRL0_REG },
+	{ S17_P5LOOKUP_CTRL_REG },
+	{ S17_P5VLAN_CTRL0_REG },
+	{ S17_P6LOOKUP_CTRL_REG },
+	{ S17_P6VLAN_CTRL0_REG },
+	{ 0 },
+}; /* should be in phydev->priv */
+
+/* save u-boot/platform generated modes to re-impose after reset */
+static void qca833x_save_init(struct phy_device *phydev)
+{
+	struct qmodes *m;
+	for (m = qmodes; m->addr; m++) {
+		if (m->saved)
+			continue;
+		m->val = qphy_read32(phydev, m->addr);
+		m->saved = true;
+	}
 }
-#endif /*notdef*/
 
-static int qca8334_re_init(struct phy_device *phydev)
+static int qca833x_re_init(struct phy_device *phydev)
 {
 	int val;
 	u32 features;
-	int status;
-
-	qphy_write32(phydev, S17_P0PAD_MODE_REG, S17_MAC0_SGMII_EN);
+	struct qmodes *m;
+
+	/* Reset the PHY */
+	val = qphy_read32(phydev, S17_MASK_CTRL_REG);
+	val |= S17_MASK_CTRL_SOFT_RESET;
+	qphy_write32(phydev, S17_MASK_CTRL_REG, val);
+
+	/* wait for ready */
+	while (qphy_read32(phydev, S17_MASK_CTRL_REG)
+			& S17_MASK_CTRL_SOFT_RESET)
+		msleep(10);
+
+	/*
+	 * force initial mode on port 0: SGMII, RX clock on falling edge,
+	 * Speed 1000M, Tx MAC enable, Rx MAC enable, Tx MAC flow enable,
+	 * Rx MAC flow enable, Full duplex mode
+	 */
+	qphy_write32(phydev, S17_P0PAD_MODE_REG,
+				S17_MAC0_SGMII_EN);
 	qphy_write32(phydev, S17_P0STATUS_REG, 0x0000007e);
-	qphy_write32(phydev, S17_P0PAD_MODE_REG, S17_MAC0_SGMII_EN|S17_MAC0_SGMII_125MHX_RX_FALL);
-	qphy_write32(phydev, S17_GLOFW_CTRL1_REG, 0x007f7f7f);
-	qphy_write32(phydev, S17_SGMII_CTRL_REG, 0xc74164de);	/* PHY-mode SGMII control */
+
+	/* now unroll the real modes as saved earlier */
+	for (m = qmodes; m->addr; m++) {
+		if (!m->saved)
+			continue;
+		qphy_write32(phydev, m->addr, m->val);
+	}
 
 	features = SUPPORTED_TP | SUPPORTED_MII | SUPPORTED_AUI |
 	    SUPPORTED_FIBRE | SUPPORTED_BNC;
@@ -202,17 +284,13 @@ static int qca8334_re_init(struct phy_device *phydev)
 	phydev->supported = features;
 	phydev->advertising = features;
 
-	status = phy_write(phydev, S17_PHY_INT_EN_REG, ATHR_CTRL_SOFTWARE_RESET);
-
 	pr_debug(KERN_ERR "%s: complete\n", __func__);
 	return 0;
 }
 
-static int qca8334_config_init(struct phy_device *phydev)
+static int qca833x_config_init(struct phy_device *phydev)
 {
 	int val;
-	u32 features;
-	int status;
 	static bool once;
 
 	val = phy_read(phydev, MII_PHYSID2);
@@ -239,12 +317,18 @@ static int qca8334_config_init(struct phy_device *phydev)
 		pr_info("qca833x %d-port switch\n", qports(phydev));
 	once = true;
 
-	return qca8334_re_init(phydev);
+	qca833x_save_init(phydev);
+	return qca833x_re_init(phydev);
 }
 
 static void force_reset(struct phy_device *phydev)
 {
-	muget(phydev);
+	int port;
+
+	for (port = 0; port < qports(phydev); port++)
+		port_context_save(phydev, port, &port_context[port]);
+
+	qphy_muget(phydev);
 	if (phydev->attached_dev
 	    && phydev->attached_dev->ethtool_ops
 	    && phydev->attached_dev->ethtool_ops->reset) {
@@ -252,17 +336,20 @@ static void force_reset(struct phy_device *phydev)
 		phydev->attached_dev->ethtool_ops->reset(
 			phydev->attached_dev, &flags);
 	}
-	muput(phydev);
-	qca8334_re_init(phydev);
+	qphy_muput(phydev);
+	qca833x_re_init(phydev);
+
+	for (port = 0; port < qports(phydev); port++)
+		port_context_restore(phydev, port, &port_context[port]);
 }
 
-static int qca8334_read_status(struct phy_device *phydev)
+static int qca833x_read_status(struct phy_device *phydev)
 {
 	int phy_status = 0;
 	int port = 0;
 	int was;
 
-	muget(phydev);
+	qphy_muget(phydev);
 	was = phydev->link;
 	phydev->link = 0;
 
@@ -300,7 +387,7 @@ static int qca8334_read_status(struct phy_device *phydev)
 			phydev->asym_pause = 1;
 		}
 	}
-	muput(phydev);
+	qphy_muput(phydev);
 
 	/* when link goes down, reset qca833x by pulsing PCS off */
 	if (was && !phydev->link)
@@ -310,7 +397,7 @@ static int qca8334_read_status(struct phy_device *phydev)
 
 
 #ifdef QCA833X_IRQ
-static int qca8334_ack_interrupt(struct phy_device *phydev)
+static int qca833x_ack_interrupt(struct phy_device *phydev)
 {
 	int err;
 
@@ -319,7 +406,7 @@ static int qca8334_ack_interrupt(struct phy_device *phydev)
 	return (err < 0) ? err : 0;
 }
 
-static int qca8334_config_interrupt(struct phy_device *phydev)
+static int qca833x_config_interrupt(struct phy_device *phydev)
 {
 	return phy_write(phydev, S17_PHY_INT_EN_REG,
 		(phydev->interrupts == PHY_INTERRUPT_ENABLED)
@@ -328,17 +415,17 @@ static int qca8334_config_interrupt(struct phy_device *phydev)
 #endif /* QCA833X_IRQ */
 
 /* QUALCOMM/ATHEROS QCA8334/QCA8337 */
-static struct phy_driver qca8334_driver = {
+static struct phy_driver qca833x_driver = {
 	.name = "Atheros 8334/8337 ethernet",
 	.phy_id = 0x004dd036,
 	.phy_id_mask = 0xfffffff0,
 	.features = PHY_GBIT_FEATURES,
-	.config_init = qca8334_config_init,
+	.config_init = qca833x_config_init,
 	.config_aneg = genphy_config_aneg,
-	.read_status = qca8334_read_status,
+	.read_status = qca833x_read_status,
 #ifdef QCA833X_IRQ
-	.ack_interrupt = qca8334_ack_interrupt,
-	.config_intr = qca8334_config_interrupt,
+	.ack_interrupt = qca833x_ack_interrupt,
+	.config_intr = qca833x_config_interrupt,
 	.flags = PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
 #else /* !QCA833X_IRQ */
 	.flags = PHY_HAS_MAGICANEG,
@@ -348,12 +435,12 @@ static struct phy_driver qca8334_driver = {
 
 static int __init qca833x_init(void)
 {
-	return phy_driver_register(&qca8334_driver);
+	return phy_driver_register(&qca833x_driver);
 }
 
 static void __exit qca833x_exit(void)
 {
-	phy_driver_unregister(&qca8334_driver);
+	phy_driver_unregister(&qca833x_driver);
 }
 
 module_init(qca833x_init);
diff --git a/drivers/net/phy/qca833x.h b/drivers/net/phy/qca833x.h
index 4c01688..04fd0f2 100644
--- a/drivers/net/phy/qca833x.h
+++ b/drivers/net/phy/qca833x.h
@@ -562,64 +562,7 @@
 #undef HEADER_EN
 #endif
 
-#define ATHR_LAN_PORT_VLAN	1
-#define ATHR_WAN_PORT_VLAN	2
-
-#define ENET_UNIT_GE0		0
-#define ENET_UNIT_GE1		1
-
-#define ATHR_PHY0_ADDR		0x0
-#define ATHR_PHY1_ADDR		0x1
-#define ATHR_PHY2_ADDR		0x2
-#define ATHR_PHY3_ADDR		0x3
-#define ATHR_PHY4_ADDR		0x4
-#define ATHR_IND_PHY		4
-
 #define MODULE_NAME "qca833x"
 #define S17_PHY_DEBUG 1
 
-#if defined(ATH_S17_MAC0_SGMII)
-# define ENET_UNIT		ENET_UNIT_GE1
-# define ENET_UNIT_WAN		ENET_UNIT_GE0
-#else
-# define ENET_UNIT		ENET_UNIT_GE0
-# define ENET_UNIT_WAN		ENET_UNIT_GE1
-#endif
-
-/* Convenience macros to access myPhyInfo */
-#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
-#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
-#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
-#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
-#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
-#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
-
-#define ATHR_IS_ETHUNIT(phyUnit, ethUnit)	\
-	(ATHR_IS_ENET_PORT(phyUnit) &&		\
-	 ATHR_ETHUNIT(phyUnit) == (ethUnit))
-
-#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_GE0))
-
-//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
-//#define ATHR_PHY_MAX 5
-#define ATHR_PHY_MAX 4
-
-/* Range of valid PHY IDs is [MIN..MAX] */
-#define ATHR_ID_MIN 0
-#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
-#define _1000BASET 1000
-#define _100BASET  100
-#define _10BASET   10
-
-extern int qca8334_17_reg_read(struct phy_device *phydev, u32 reg_addr);
-extern int qca8334_17_reg_write(struct phy_device *phydev, u32 reg_addr,
-				u32 reg_val);
-extern int phy_qca8334_init(void);
-extern void qca8334_vlan_config(struct phy_device *phydev);
-extern void __qca8334_vlan_config(struct phy_device *phydev);
-extern void qca8334_17_reg_init_wan(struct phy_device *phydev);
-extern void __qca8334_17_reg_init_wan(struct phy_device *phydev);
-int qca8334_config(struct phy_device *phydev);
-int __qca8334_config(struct phy_device *phydev);
-
 #endif
-- 
2.6.2

