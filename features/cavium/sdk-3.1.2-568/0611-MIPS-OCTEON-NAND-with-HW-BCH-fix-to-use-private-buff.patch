From 5f92788702a6a2e4174c051c9918d9630fb2cf62 Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Wed, 2 Jul 2014 14:39:04 -0700
Subject: [PATCH 611/974] MIPS: OCTEON: NAND with HW BCH: fix to use private
 buffer for BCH The caller's buffer can be vmalloced(), which can not be
 translated into phys addresses for BCH hardware to access, therefore, the
 priv->data page buffer already used throughout the driver is now also used
 for source and destination of BCH HW operations.

Also, sync cvmx-bch.c from SE at TOT (minor cleanup)

Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bch.c | 58 ++++++++--------------------
 arch/mips/cavium-octeon/octeon-nand.c        | 51 +++++++++++++++++-------
 2 files changed, 54 insertions(+), 55 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index fb839e5..c90a78d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -20,7 +20,7 @@
  *     derived from this software without specific prior written
  *     permission.
  *
- * This Software, including technical data, may be subject to U.S. export control
+ * This Software, including technical data, may be subject to U.S. export  control
  * laws, including the U.S. Export Administration Act and its  associated
  * regulations, and may be subject to export or import  regulations in other
  * countries.
@@ -28,8 +28,8 @@
  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION
- * OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
@@ -45,7 +45,6 @@
  * <hr>$Revision: 79788 $<hr>
  */
 
-
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 # include <asm/octeon/cvmx.h>
 # include <asm/octeon/cvmx-config.h>
@@ -54,11 +53,7 @@
 # include <asm/octeon/cvmx-fpa1.h>
 # include <asm/octeon/cvmx-helper-fpa.h>
 # include <asm/octeon/cvmx-cmd-queue.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-
 #elif defined(CVMX_BUILD_FOR_UBOOT)
-
 # include <common.h>
 # include <asm/arch/cvmx.h>
 # include <asm/arch/cvmx-bch-defs.h>
@@ -89,6 +84,7 @@ CVMX_SHARED cvmx_bch_app_config_t bch_config = {
 };
 
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+extern int cvm_oct_mem_fill_fpa(int pool, int elements);
 extern int cvm_oct_alloc_fpa_pool(int pool, int size);
 #endif
 
@@ -107,7 +103,6 @@ int cvmx_bch_initialize(void)
 
 	/* Initialize FPA pool for BCH pool buffers */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	int i;
 	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
 	bch_pool_size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE;
 
@@ -117,13 +112,10 @@ int cvmx_bch_initialize(void)
 
 	bch_pool = cvm_oct_alloc_fpa_pool(bch_pool, bch_pool_size);
 	if (bch_pool < 0) {
-		pr_err("cvm_oct_alloc_fpa_pool(%d, %lld)\n",
-		       bch_pool, bch_pool_size);
+		pr_err("cvm_oct_alloc_fpa_pool(%d, %lld)\n", bch_pool, bch_pool_size);
 		return -ENOMEM;
 	}
-
-	for (i = 0; i < 16; i++)
-		cvmx_fpa1_free(kmalloc(bch_pool_size, GFP_KERNEL), bch_pool, 0);
+	cvm_oct_mem_fill_fpa(bch_pool, 128);
 #else
 	bch_pool = (int)cvmx_fpa_get_bch_pool();
 	bch_pool_size = cvmx_fpa_get_bch_pool_block_size();
@@ -155,8 +147,8 @@ int cvmx_bch_initialize(void)
 	bch_cmd_buf.s.dwb = bch_pool_size / 128;
 	bch_cmd_buf.s.pool = bch_pool;
 	bch_cmd_buf.s.size = bch_pool_size / 8;
-	bch_cmd_buf.s.ptr = cvmx_ptr_to_phys(
-		cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_BCH)) >> 7;
+	bch_cmd_buf.s.ptr =
+		cvmx_ptr_to_phys(cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_BCH)) >> 7;
 	cvmx_write_csr(CVMX_BCH_CMD_BUF, bch_cmd_buf.u64);
 	cvmx_write_csr(CVMX_BCH_GEN_INT, 7);
 	cvmx_write_csr(CVMX_BCH_GEN_INT_EN, 0);
@@ -178,7 +170,6 @@ EXPORT_SYMBOL(cvmx_bch_initialize);
 int cvmx_bch_shutdown(void)
 {
 	cvmx_bch_ctl_t bch_ctl;
-	int bch_pool;
 
 	debug("%s: ENTER\n", __func__);
 	bch_ctl.u64 = cvmx_read_csr(CVMX_BCH_CTL);
@@ -186,24 +177,8 @@ int cvmx_bch_shutdown(void)
 	cvmx_write_csr(CVMX_BCH_CTL, bch_ctl.u64);
 	cvmx_wait(4);
 
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
-#else
-	bch_pool = (int)cvmx_fpa_get_bch_pool();
-#endif
 	cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_BCH);
 
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	/* FIXME: BCH cleanup in SE : AJ */
-	{
-		int i;
-		for (i = 0; i < 16; i++)
-			kfree(cvmx_fpa1_alloc(bch_pool));
-	}
-#else
-	cvmx_fpa_shutdown_pool(bch_pool);
-#endif
-	/* AJ: Fix for FPA3 */
 	return 0;
 }
 EXPORT_SYMBOL(cvmx_bch_shutdown);
@@ -214,7 +189,7 @@ EXPORT_SYMBOL(cvmx_bch_shutdown);
  * @param buffer_size	buffer size of pool
  * @param buffer_count	number of buffers to allocate to pool
  */
-void cvmx_bch_set_cmd_que_pool_config(int64_t pool, uint64_t buffer_size,
+void cvmx_bch_set_cmd_que_pool_config (int64_t pool, uint64_t buffer_size,
 				       uint64_t buffer_count)
 {
 	bch_config.command_queue_pool.pool_num = pool;
@@ -237,8 +212,8 @@ void cvmx_bch_get_cmd_que_pool_config(cvmx_fpa_pool_config_t *bch_pool)
  * @param[in] block	8-byte aligned pointer to data block to calculate ECC
  * @param block_size	Size of block in bytes, must be a multiple of two.
  * @param ecc_level	Number of errors that must be corrected.  The number of
- *			parity bytes is equal to ((15 * ecc_level) + 7) / 8.
- *			Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * 			parity bytes is equal to ((15 * ecc_level) + 7) / 8.
+ * 			Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
  * @param[out] ecc	8-byte aligned pointer to where ecc data should go
  * @param[in] response	pointer to where responses will be written.
  *
@@ -260,8 +235,9 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 	command.s.cword.size = block_size;
 
 	command.s.oword.ptr = cvmx_ptr_to_phys(ecc);
+	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);
 	command.s.resp.ptr = cvmx_ptr_to_phys((void *)response);
-	debug("Cmd: cword:0x%llx, oword:0x%llx, iword:0x%llx, resp:0x%llx\n",
+	debug("Command: cword: 0x%llx, oword: 0x%llx, iword: 0x%llx, resp: 0x%llx\n",
 	      command.u64[0], command.u64[1], command.u64[2], command.u64[3]);
 	result = cvmx_cmd_queue_write(CVMX_CMD_QUEUE_BCH, 1,
 				      sizeof(command) / sizeof(uint64_t),
@@ -287,9 +263,9 @@ EXPORT_SYMBOL(cvmx_bch_encode);
  * @param ecc_level		Number of errors that must be corrected.  The
  *				number of parity bytes is equal to
  *				((15 * ecc_level) + 7) / 8.
- *				Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * 				Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
  * @param[out] block_out	8-byte aligned pointer to corrected data buffer.
- *				This should not be the same as block_ecc_in.
+ * 				This should not be the same as block_ecc_in.
  * @param[in] response		pointer to where responses will be written.
  *
  * @return Zero on success, negative on failure.
@@ -310,9 +286,9 @@ int cvmx_bch_decode(const void *block_ecc_in, uint16_t block_size,
 	command.s.cword.size = block_size;
 
 	command.s.oword.ptr = cvmx_ptr_to_phys((void *)block_out);
-	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block_ecc_in);
+ 	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block_ecc_in);
 	command.s.resp.ptr = cvmx_ptr_to_phys((void *)response);
-	debug("Cmd: cword:0x%llx, oword:0x%llx, iword:0x%llx, resp:0x%llx\n",
+	debug("Command: cword: 0x%llx, oword: 0x%llx, iword: 0x%llx, resp: 0x%llx\n",
 	      command.u64[0], command.u64[1], command.u64[2], command.u64[3]);
 	result = cvmx_cmd_queue_write(CVMX_CMD_QUEUE_BCH, 1,
 				      sizeof(command) / sizeof(uint64_t),
diff --git a/arch/mips/cavium-octeon/octeon-nand.c b/arch/mips/cavium-octeon/octeon-nand.c
index 63dd681..7dd322f 100644
--- a/arch/mips/cavium-octeon/octeon-nand.c
+++ b/arch/mips/cavium-octeon/octeon-nand.c
@@ -27,6 +27,7 @@
 #include <linux/mtd/partitions.h>
 #include <linux/of.h>
 #include <linux/slab.h>
+#include <linux/mm.h>
 #include <net/irda/parameters.h>
 
 
@@ -219,15 +220,18 @@ static int octeon_nand_hw_bch_read_page(struct mtd_info *mtd,
 	int i, eccsize = chip->ecc.size;
 	int eccbytes = chip->ecc.bytes;
 	int eccsteps = chip->ecc.steps;
-	uint8_t *p = buf;
+	uint8_t *p;
 	uint8_t *ecc_code = chip->buffers->ecccode;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
 
 	DEV_DBG(DEBUG_READ, priv->dev, "%s(%p, %p, %p, %d, %d)\n", __func__,
 		mtd, chip, buf, oob_required, page);
 
-	chip->read_buf(mtd, buf, mtd->writesize);
-	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	/* chip->read_buf() insists on sequential order, we do OOB first */
+	memcpy(chip->oob_poi, priv->data + mtd->writesize, mtd->oobsize);
+
+	/* Use private->data buffer as input for ECC correction */
+	p = priv->data;
 
 	for (i = 0; i < chip->ecc.total; i++)
 		ecc_code[i] = chip->oob_poi[eccpos[i]];
@@ -239,6 +243,7 @@ static int octeon_nand_hw_bch_read_page(struct mtd_info *mtd,
 			"Correcting block offset %ld, ecc offset %d\n",
 			p - buf, i);
 		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
+
 		if (stat < 0) {
 			mtd->ecc_stats.failed++;
 			DEV_DBG(DEBUG_ALL, priv->dev,
@@ -247,6 +252,10 @@ static int octeon_nand_hw_bch_read_page(struct mtd_info *mtd,
 			mtd->ecc_stats.corrected += stat;
 		}
 	}
+
+	/* Copy corrected data to caller's buffer now */
+	memcpy(buf, priv->data, mtd->writesize);
+
 	return 0;
 }
 
@@ -258,7 +267,7 @@ static int octeon_nand_hw_bch_write_page(struct mtd_info *mtd,
 	int i, eccsize = chip->ecc.size;
 	int eccbytes = chip->ecc.bytes;
 	int eccsteps = chip->ecc.steps;
-	const uint8_t *p = buf;
+	const uint8_t *p;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
 	uint8_t *ecc_calc = chip->buffers->ecccalc;
 
@@ -267,6 +276,11 @@ static int octeon_nand_hw_bch_write_page(struct mtd_info *mtd,
 	for (i = 0; i < chip->ecc.total; i++)
 		ecc_calc[i] = 0xFF;
 
+	/* Copy the page data from caller's buffers to private buffer */
+	chip->write_buf(mtd, buf, mtd->writesize);
+	/* Use private date as source for ECC calculation */
+	p = priv->data;
+
 	/* Hardware ECC calculation */
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int ret;
@@ -285,7 +299,7 @@ static int octeon_nand_hw_bch_write_page(struct mtd_info *mtd,
 	for (i = 0; i < chip->ecc.total; i++)
 		chip->oob_poi[eccpos[i]] = ecc_calc[i];
 
-	chip->write_buf(mtd, buf, mtd->writesize);
+	/* Store resulting OOB into private buffer, will be sent to HW */
 	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
 
 	return 0;
@@ -476,6 +490,7 @@ static void octeon_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
 			"SEQIN column=%d page_addr=0x%x\n", column, page_addr);
 		/* If we don't seem to be doing sequential writes then erase
 			all data assuming it is old */
+		/* FIXME: if (priv->selected_page != page_addr) */
 		if (priv->data_index != column)
 			memset(priv->data, 0xff, sizeof(priv->data));
 		priv->data_index = column;
@@ -535,11 +550,15 @@ static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
 						  uint8_t *code)
 {
 	struct nand_chip *nand_chip = &priv->nand;
-	static volatile cvmx_bch_response_t response;
+	static cvmx_bch_response_t response;
 	int rc;
 	int i;
 	static uint8_t *ecc_buffer;
 
+	/* Can only use logical or xkphys pointers */
+	WARN_ON(is_vmalloc_or_module_addr(buf));
+	WARN_ON(is_vmalloc_or_module_addr(code));
+
 	if (!ecc_buffer)
 		ecc_buffer = kmalloc(1024, GFP_KERNEL);
 	if ((ulong)buf % 8)
@@ -548,7 +567,7 @@ static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
 	memset(ecc_buffer, 0, nand_chip->ecc.bytes);
 
 	response.u16 = 0;
-
+	barrier();
 
 	rc = cvmx_bch_encode((void *)buf, nand_chip->ecc.size,
 			     nand_chip->ecc.strength,
@@ -560,9 +579,9 @@ static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
 	}
 
 	udelay(10);
+	barrier();
 
 	if (!response.s.done) {
-		DEV_DBG(DEBUG_ALL, priv->dev,
 			"octeon_bch_encode timed out, response done: %d, "
 			 "uncorrectable: %d, num_errors: %d, erased: %d\n",
 			response.s.done, response.s.uncorrectable,
@@ -598,8 +617,6 @@ static int octeon_nand_bch_calculate(struct mtd_info *mtd,
 
 	return ret;
 }
-
-
 /*
  * Detect and correct multi-bit ECC for a page
  *
@@ -615,13 +632,16 @@ static int octeon_nand_bch_correct(struct mtd_info *mtd, u_char *dat,
 {
 	struct octeon_nand *priv = container_of(mtd, struct octeon_nand, mtd);
 	struct nand_chip *nand_chip = &priv->nand;
-	static volatile cvmx_bch_response_t response;
+	static cvmx_bch_response_t response;
 	int rc;
 	int i = nand_chip->ecc.size + nand_chip->ecc.bytes;
 	static uint8_t *data_buffer;
 	static int buffer_size;
 	int max_time = 100;
 
+	/* Can only use logical or xkphys pointers */
+	WARN_ON(is_vmalloc_or_module_addr(dat));
+
 	if (i > buffer_size) {
 		kfree(data_buffer);
 		data_buffer = kmalloc(i, GFP_KERNEL);
@@ -641,6 +661,7 @@ static int octeon_nand_bch_correct(struct mtd_info *mtd, u_char *dat,
 		data_buffer[nand_chip->ecc.size + i] ^= priv->eccmask[i];
 
 	response.u16 = 0;
+	barrier();
 
 	rc = cvmx_bch_decode(data_buffer, nand_chip->ecc.size,
 			     nand_chip->ecc.strength, dat, &response);
@@ -651,8 +672,10 @@ static int octeon_nand_bch_correct(struct mtd_info *mtd, u_char *dat,
 	}
 
 	/* Wait for BCH engine to finsish */
-	while (!response.s.done && max_time--)
+	while (!response.s.done && max_time--) {
 		udelay(1);
+		barrier();
+	}
 
 	if (!response.s.done) {
 		dev_err(priv->dev, "Error: BCH engine timeout\n");
@@ -1151,6 +1174,7 @@ static int octeon_nand_hw_bch_init(struct octeon_nand *priv)
 	unsigned int eccbytes = chip->ecc.bytes;
 	uint8_t erased_ecc[eccbytes];
 
+	/* Without HW BCH, the ECC callbacks would have not been installed */
 	if (!octeon_has_feature(OCTEON_FEATURE_BCH))
 		return 0;
 
@@ -1195,9 +1219,8 @@ static int octeon_nand_hw_bch_init(struct octeon_nand *priv)
 	return 0;
 
 fail:
-	if (priv->eccmask)
-		priv->eccmask = NULL;
 	kfree(priv->eccmask);
+	priv->eccmask = NULL;
 
 	kfree(erased_page);
 
-- 
2.6.2

