From 99a8e73704d0ed7267f169f6359bb37eae0faeed Mon Sep 17 00:00:00 2001
From: Taras Kondratiuk <takondra@cisco.com>
Date: Wed, 10 Jun 2015 19:35:19 -0700
Subject: [PATCH 163/184] MIPS: traps: call crash_kexec() before panic() when
 dying

In general crash_kexec() can be called from two places:
- from die() in case of exception route
- from panic() when it is invoked explicitly

In a current MIPS code in most cases execution won't reach crash_kexec()
call in die(), because it gets intercepted by panic(). Unfortunately
panic() cannot pass stored registers to crash_kexec(), so backtrace in
the coredump won't start from a crash point. Instead it will be in an
exception context.

There are at least two reasons to fix it:
- it complicates crashdump analysis and further debugging
- it doesn't match with behavior of other architectures

Change-Id: I4924264e6b17925738fba074ba68c58e3830c547
Bug-Id: CSCuu82009
Signed-off-by: Taras Kondratiuk <takondra@cisco.com>
Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/kernel/traps.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index ff51e43..b62daec 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -399,15 +399,15 @@ void __noreturn die(const char *str, struct pt_regs *regs)
 
 	oops_exit();
 
+	if (regs && kexec_should_crash(current))
+		crash_kexec(regs);
+
 	if (in_interrupt())
 		panic("Fatal exception in interrupt");
 
 	if (panic_on_oops)
 		panic("Fatal exception");
 
-	if (regs && kexec_should_crash(current))
-		crash_kexec(regs);
-
 	do_exit(sig);
 }
 
-- 
1.9.1

