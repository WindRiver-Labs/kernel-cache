From 189f2b8e8e847ec6ae64804163d731da900e3a78 Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Sat, 29 Aug 2015 19:32:18 -0700
Subject: [PATCH 144/184] mips: octeon-irq correct edge/level-trigger confusion

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 07e7ede370085b901e832b001d793246c54af94e
Description:

Some IRQs were marked level-triggered in old device-trees, but hardware
is actually edge-triggered. This "worked", in that irq_modify_status()
was actually clearing all the trigger-type bits, so the code
  if (!(type & IRQ_TYPE_LEVEL_MASK)) .. do edge-required ack ...
actually worked.

Add a local trigger-type copy to private ciu/ciu2/ciu3 data,
saved by custom .set_trigger_type entry.
This avoids type==0 issues from possible zeroing of trigger_type bits
by irq_modify_status().

Speed up ciu3 irq handling by calling the handle_edge/level_irq()
generics directly, rather than consulting trigger-type at irq-time.
The .set_trigger_type hook, invoked by irq_set_irq_type(),
changes handler handler binding to one of these generic handlers,
rather than making this decision at each irq-time.

The new edge_startup() function ACKs any pending event,
clearing its RAW bit, so a new event will generate an edge-trigger.
Its irq_enable call mirrors irq_startup()'s behavior when .irq_startup == NULL.

Missing edge-triggered interrupts had been seen on native SATA
at startup, after a warm boot (SysRQ-B, not orderly reboot),
producing the polled timeout response:
   ata4.00: exception Emask 0x0 SAct 0x7 SErr 0x0 action 0x6 frozen
Now we ack any pending edge-irq at startup, so there is always
an _edge_ to fire on when the event reappears.
Otherwise un-acked event from before a warm boot can
prevent delivery of a new event.

Added no-op .irq_ack entries where missing so bad device-tree trigger-type
properties will not cause handle_edge_irq() to call thru NULL.
May not be needed in all cases, but causes no extra code.

The edge/level common helpers now test for the presence of EDGE,
rather than the absence of LEVEL, before doing the state-destroying ack.
This changes the reponse to zero'd trigger-type bits, from missing-irq
hang, to continuous-irq, which is more easily diagnosed.

Make all device-tree parsing trigger-type defaults consistent:
- gpio pins default to LEVEL_LOW if no type specified
- other irqs default to EDGE_RISING if no type specified

Signed-off-by: Peter Swain <pswain@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c  | 101 ++++++++++++++++++++++++++--------
 arch/mips/include/asm/octeon/octeon.h |   2 +
 arch/mips/pci/msi-octeon.c            |   1 +
 3 files changed, 81 insertions(+), 23 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index d099a91..88b2659 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -700,11 +700,36 @@ static void octeon_irq_ciu_enable_all_v2(struct irq_data *data)
 	}
 }
 
+/* set edge/level type and corresponding handler */
+int octeon_irq_ciu_set_type(struct irq_data *data, unsigned int flow_type)
+{
+	struct octeon_ciu_chip_data *cd = irq_data_get_irq_chip_data(data);
+
+	cd->trigger_type = flow_type;
+	irqd_set_trigger_type(data, flow_type);
+
+	if (flow_type & IRQ_TYPE_LEVEL_MASK)
+		__irq_set_handler_locked(data->irq, handle_level_irq);
+	else
+		__irq_set_handler_locked(data->irq, handle_edge_irq);
+
+	return IRQ_SET_MASK_OK;
+}
+EXPORT_SYMBOL(octeon_irq_ciu_set_type); /* visible for msi setup */
+
+/* get local copy of trigger-type */
+static inline u32 ciu_get_trigger_type(struct irq_data *data)
+{
+	struct octeon_ciu_chip_data *cd = irq_data_get_irq_chip_data(data);
+
+	return cd->trigger_type;
+}
+
 static void octeon_irq_gpio_setup(struct irq_data *data)
 {
 	union cvmx_gpio_bit_cfgx cfg;
 	struct octeon_ciu_chip_data *cd;
-	u32 t = irqd_get_trigger_type(data);
+	u32 t = ciu_get_trigger_type(data);
 
 	cd = irq_data_get_irq_chip_data(data);
 
@@ -734,7 +759,7 @@ static void octeon_irq_ciu_enable_gpio(struct irq_data *data)
 
 static int octeon_irq_ciu_gpio_set_type(struct irq_data *data, unsigned int t)
 {
-	irqd_set_trigger_type(data, t);
+	octeon_irq_ciu_set_type(data, t);
 	octeon_irq_gpio_setup(data);
 
 	return IRQ_SET_MASK_OK;
@@ -772,14 +797,6 @@ static void octeon_irq_ciu_gpio_ack(struct irq_data *data)
 	cvmx_read_csr(CVMX_GPIO_INT_CLR);
 }
 
-static void octeon_irq_handle_trigger(unsigned int irq, struct irq_desc *desc)
-{
-	if (irq_get_trigger_type(irq) & IRQ_TYPE_EDGE_BOTH)
-		handle_edge_irq(irq, desc);
-	else
-		handle_level_irq(irq, desc);
-}
-
 #ifdef CONFIG_SMP
 
 static void octeon_irq_cpu_offline_ciu(struct irq_data *data)
@@ -940,6 +957,24 @@ static int octeon_irq_ciu_set_affinity_sum2(struct irq_data *data,
 }
 #endif
 
+static void nop_ack(struct irq_data *data)
+{
+	/*
+	 * ensure bad device-tree trigger-type properties on a level-only
+	 * chip type will not cause handle_edge_irq() to call thru NULL
+	 */
+}
+
+static unsigned int edge_startup(struct irq_data *data)
+{
+	/* ack any pending edge-irq at startup, so there is
+	 * an _edge_ to fire on when the event reappears.
+	 */
+	data->chip->irq_ack(data);
+	data->chip->irq_enable(data);
+	return 0;
+}
+
 /*
  * Newer octeon chips have support for lockless CIU operation.
  */
@@ -949,6 +984,7 @@ static struct irq_chip octeon_irq_chip_ciu_v2 = {
 	.irq_disable = octeon_irq_ciu_disable_all_v2,
 	.irq_mask = octeon_irq_ciu_disable_local_v2,
 	.irq_unmask = octeon_irq_ciu_enable_v2,
+	.irq_ack = nop_ack,
 #ifdef CONFIG_SMP
 	.irq_set_affinity = octeon_irq_ciu_set_affinity_v2,
 	.irq_cpu_offline = octeon_irq_cpu_offline_ciu,
@@ -957,6 +993,7 @@ static struct irq_chip octeon_irq_chip_ciu_v2 = {
 
 static struct irq_chip octeon_irq_chip_ciu_v2_edge = {
 	.name = "CIU",
+	.irq_startup = edge_startup,
 	.irq_enable = octeon_irq_ciu_enable_v2,
 	.irq_disable = octeon_irq_ciu_disable_all_v2,
 	.irq_ack = octeon_irq_ciu_ack,
@@ -977,6 +1014,7 @@ static struct irq_chip octeon_irq_chip_ciu_sum2 = {
 	.irq_disable = octeon_irq_ciu_disable_all_sum2,
 	.irq_mask = octeon_irq_ciu_disable_local_sum2,
 	.irq_unmask = octeon_irq_ciu_enable_sum2,
+	.irq_ack = nop_ack,
 #ifdef CONFIG_SMP
 	.irq_set_affinity = octeon_irq_ciu_set_affinity_sum2,
 	.irq_cpu_offline = octeon_irq_cpu_offline_ciu,
@@ -985,6 +1023,7 @@ static struct irq_chip octeon_irq_chip_ciu_sum2 = {
 
 static struct irq_chip octeon_irq_chip_ciu_sum2_edge = {
 	.name = "CIU",
+	.irq_startup = edge_startup,
 	.irq_enable = octeon_irq_ciu_enable_sum2,
 	.irq_disable = octeon_irq_ciu_disable_all_sum2,
 	.irq_ack = octeon_irq_ciu_ack_sum2,
@@ -1002,6 +1041,7 @@ static struct irq_chip octeon_irq_chip_ciu = {
 	.irq_disable = octeon_irq_ciu_disable_all,
 	.irq_mask = octeon_irq_ciu_disable_local,
 	.irq_unmask = octeon_irq_ciu_enable,
+	.irq_ack = nop_ack,
 #ifdef CONFIG_SMP
 	.irq_set_affinity = octeon_irq_ciu_set_affinity,
 	.irq_cpu_offline = octeon_irq_cpu_offline_ciu,
@@ -1010,6 +1050,7 @@ static struct irq_chip octeon_irq_chip_ciu = {
 
 static struct irq_chip octeon_irq_chip_ciu_edge = {
 	.name = "CIU",
+	.irq_startup = edge_startup,
 	.irq_enable = octeon_irq_ciu_enable,
 	.irq_disable = octeon_irq_ciu_disable_all,
 	.irq_ack = octeon_irq_ciu_ack,
@@ -1279,8 +1320,13 @@ static int octeon_irq_gpio_map(struct irq_domain *d,
 		octeon_irq_ciu_to_irq[line][bit] != 0)
 		return -EINVAL;
 
+	/*
+	 * Default handler matches gpio default IRQ_TYPE_LEVEL_LOW,
+	 * Use irq_set_irq_type() to update type/handler
+	 */
 	r = octeon_irq_set_ciu_mapping(virq, line, bit, hw,
-		octeon_irq_gpio_chip, octeon_irq_handle_trigger);
+				       octeon_irq_gpio_chip, handle_level_irq);
+
 	return r;
 }
 
@@ -1853,6 +1899,7 @@ static struct irq_chip octeon_irq_chip_ciu2 = {
 	.irq_disable = octeon_irq_ciu2_disable_all,
 	.irq_mask = octeon_irq_ciu2_disable_local,
 	.irq_unmask = octeon_irq_ciu2_enable,
+	.irq_ack = nop_ack,
 #ifdef CONFIG_SMP
 	.irq_set_affinity = octeon_irq_ciu2_set_affinity,
 	.irq_cpu_offline = octeon_irq_cpu_offline_ciu,
@@ -1861,6 +1908,7 @@ static struct irq_chip octeon_irq_chip_ciu2 = {
 
 static struct irq_chip octeon_irq_chip_ciu2_edge = {
 	.name = "CIU2-E",
+	.irq_startup = edge_startup,
 	.irq_enable = octeon_irq_ciu2_enable,
 	.irq_disable = octeon_irq_ciu2_disable_all,
 	.irq_ack = octeon_irq_ciu2_ack,
@@ -1890,6 +1938,7 @@ static struct irq_chip octeon_irq_chip_ciu2_wd = {
 	.irq_disable = octeon_irq_ciu2_disable_all,
 	.irq_mask = octeon_irq_ciu2_disable_local,
 	.irq_unmask = octeon_irq_ciu2_enable_local,
+	.irq_ack = nop_ack,
 };
 
 static struct irq_chip octeon_irq_chip_ciu2_gpio = {
@@ -2186,13 +2235,13 @@ void octeon_irq_ciu3_ack(struct irq_data *data)
 	u64 isc_w1c_addr;
 	union cvmx_ciu3_iscx_w1c isc_w1c;
 	struct octeon_ciu_chip_data *cd;
-	u32 trigger_type = irqd_get_trigger_type(data);
+	u32 trigger_type = ciu_get_trigger_type(data);
 
 	/*
 	 * We use a single irq_chip, so we have to do nothing to ack a
 	 * level interrupt.
 	 */
-	if (trigger_type & IRQ_TYPE_LEVEL_MASK)
+	if (!(trigger_type & IRQ_TYPE_EDGE_BOTH))
 		return;
 
 	cd = irq_data_get_irq_chip_data(data);
@@ -2226,7 +2275,7 @@ void octeon_irq_ciu3_mask_ack(struct irq_data *data)
 	union cvmx_ciu3_iscx_w1c isc_w1c;
 	u64 isc_w1c_addr;
 	struct octeon_ciu_chip_data *cd;
-	u32 trigger_type = irqd_get_trigger_type(data);
+	u32 trigger_type = ciu_get_trigger_type(data);
 
 	cd = irq_data_get_irq_chip_data(data);
 
@@ -2237,7 +2286,7 @@ void octeon_irq_ciu3_mask_ack(struct irq_data *data)
 	 * We use a single irq_chip, so only ack an edge (!level)
 	 * interrupt.
 	 */
-	if (!(trigger_type & IRQ_TYPE_LEVEL_MASK))
+	if (trigger_type & IRQ_TYPE_EDGE_BOTH)
 		isc_w1c.s.raw = 1;
 
 	isc_w1c_addr = cd->ciu3_addr + CIU3_ISC_W1C(cd->intsn);
@@ -2285,12 +2334,14 @@ int octeon_irq_ciu3_set_affinity(struct irq_data *data,
 
 static struct irq_chip octeon_irq_chip_ciu3 = {
 	.name = "CIU3",
+	.irq_startup = edge_startup,
 	.irq_enable = octeon_irq_ciu3_enable,
 	.irq_disable = octeon_irq_ciu3_disable,
 	.irq_ack = octeon_irq_ciu3_ack,
 	.irq_mask = octeon_irq_ciu3_mask,
 	.irq_mask_ack = octeon_irq_ciu3_mask_ack,
 	.irq_unmask = octeon_irq_ciu3_enable,
+	.irq_set_type = octeon_irq_ciu_set_type,
 #ifdef CONFIG_SMP
 	.irq_set_affinity = octeon_irq_ciu3_set_affinity,
 	.irq_cpu_offline = octeon_irq_cpu_offline_ciu,
@@ -2307,6 +2358,8 @@ int octeon_irq_ciu3_xlat(struct irq_domain *d,
 	struct octeon_ciu3_info *ciu3_info = d->host_data;
 	unsigned int hwirq, type, intsn_major;
 	union cvmx_ciu3_iscx_ctl isc;
+	if (intsize < 2)
+		return -EINVAL;
 	hwirq = intspec[0];
 	type = intspec[1];
 
@@ -2326,10 +2379,10 @@ int octeon_irq_ciu3_xlat(struct irq_domain *d,
 		return -EINVAL;
 
 	switch (type) {
-	case 0: /* unofficial value, but we might as well let it work. */
 	case 4: /* official value for level triggering. */
 		*out_type = IRQ_TYPE_LEVEL_HIGH;
 		break;
+	case 0: /* unofficial value, but we might as well let it work. */
 	case 1: /* official value for edge triggering. */
 		*out_type = IRQ_TYPE_EDGE_RISING;
 		break;
@@ -2354,8 +2407,8 @@ int octeon_irq_ciu3_mapx(struct irq_domain *d, unsigned int virq,
 	cd->current_cpu = -1;
 	cd->ciu3_addr = ciu3_info->ciu3_addr;
 	cd->ciu_node = ciu3_info->node;
-
-	irq_set_chip_and_handler(virq, chip, octeon_irq_handle_trigger);
+	cd->trigger_type = IRQ_TYPE_EDGE_RISING;
+	irq_set_chip_and_handler(virq, chip, handle_edge_irq);
 	irq_set_chip_data(virq, cd);
 
 	return 0;
@@ -2778,6 +2831,7 @@ int octeon_ciu3_errbits_enable_intsn(int node, int intsn)
 		cd = kzalloc_node(sizeof(*cd), GFP_KERNEL, node);
 		cd->ciu3_addr = ciu3_addr;
 		cd->idt = cfg->idt;
+		cd->trigger_type = IRQ_TYPE_LEVEL_HIGH;
 		irq_set_chip_and_handler(irq, &octeon_irq_chip_ciu3_errbits, handle_level_irq);
 		irq_set_chip_data(irq, cd);
 
@@ -2995,7 +3049,7 @@ static int octeon_irq_cib_map(struct irq_domain *d,
 	cd->bit = hw;
 
 	irq_set_chip_and_handler(virq, &octeon_irq_chip_cib,
-				 octeon_irq_handle_trigger);
+				 handle_simple_irq);
 	irq_set_chip_data(virq, cd);
 	return 0;
 }
@@ -3146,9 +3200,9 @@ void octeon_irq_ciu3_gpio_mask_ack(struct irq_data *data)
 	union cvmx_ciu3_iscx_w1c isc_w1c;
 	u64 isc_w1c_addr;
 	struct octeon_ciu_chip_data *cd;
-	u32 trigger_type = irqd_get_trigger_type(data);
+	u32 trigger_type = ciu_get_trigger_type(data);
 
-	if (!(trigger_type & IRQ_TYPE_LEVEL_MASK))
+	if (trigger_type & IRQ_TYPE_EDGE_BOTH)
 		octeon_irq_ciu3_gpio_ack(data);
 
 	cd = irq_data_get_irq_chip_data(data);
@@ -3163,6 +3217,7 @@ void octeon_irq_ciu3_gpio_mask_ack(struct irq_data *data)
 
 static struct irq_chip octeon_irq_chip_ciu3_gpio = {
 	.name = "CIU3-GPIO",
+	.irq_startup	= edge_startup,
 	.irq_enable	= octeon_irq_ciu3_enable_gpio,
 	.irq_disable	= octeon_irq_ciu3_disable_gpio,
 	.irq_ack	= octeon_irq_ciu3_gpio_ack,
@@ -3194,8 +3249,8 @@ static int octeon_irq_gpio78_map(struct irq_domain *d,
 	cd->current_cpu = -1;
 	cd->ciu3_addr = ciu3_info->ciu3_addr;
 	cd->ciu_node = ciu3_info->node;
-
-	irq_set_chip_and_handler(virq, &octeon_irq_chip_ciu3_gpio, octeon_irq_handle_trigger);
+	cd->trigger_type = IRQ_TYPE_LEVEL_LOW;
+	irq_set_chip_and_handler(virq, &octeon_irq_chip_ciu3_gpio, handle_level_irq);
 	irq_set_chip_data(virq, cd);
 
 	return 0;
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 13ef8f6..3816518 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -330,6 +330,7 @@ struct octeon_ciu_chip_data {
 	int gpio_line;
 	int current_cpu;	/* Next CPU expected to take this irq */
 	int ciu_node; /* NUMA node number of the CIU */
+	int trigger_type;
 };
 
 extern void octeon_write_lcd(const char *s);
@@ -409,6 +410,7 @@ void octeon_irq_ciu3_disable(struct irq_data *data);
 void octeon_irq_ciu3_mask(struct irq_data *data);
 void octeon_irq_ciu3_ack(struct irq_data *data);
 void octeon_irq_ciu3_mask_ack(struct irq_data *data);
+int octeon_irq_ciu_set_type(struct irq_data *data, unsigned int flow_type);
 int octeon_irq_ciu3_set_affinity(struct irq_data *data,
 				 const struct cpumask *dest, bool force);
 void octeon_irq_free_cd(struct irq_domain *d, unsigned int irq);
diff --git a/arch/mips/pci/msi-octeon.c b/arch/mips/pci/msi-octeon.c
index 06f14e0..dd3bb08 100644
--- a/arch/mips/pci/msi-octeon.c
+++ b/arch/mips/pci/msi-octeon.c
@@ -641,6 +641,7 @@ static struct irq_chip octeon_irq_msi_chip_ciu3 = {
 	.irq_mask = octeon_irq_ciu3_mask,
 	.irq_mask_ack = octeon_msi_ciu3_mask_ack,
 	.irq_unmask = octeon_irq_ciu3_enable,
+	.irq_set_type = octeon_irq_ciu_set_type,
 #ifdef CONFIG_SMP
 	.irq_set_affinity = octeon_irq_ciu3_set_affinity,
 #endif
-- 
1.9.1

