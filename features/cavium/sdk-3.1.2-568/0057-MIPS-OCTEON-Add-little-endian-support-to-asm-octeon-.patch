From b9aa012c9ced5bd3f031ad205534f6ced33d46af Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 26 Sep 2012 14:56:58 -0700
Subject: [PATCH 057/974] MIPS: OCTEON: Add little-endian support to
 asm/octeon/octeon.h

Also update union octeon_cvmemctl with new OCTEON II fields.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/octeon/octeon.h | 107 +++++++++++++++++++++++++++++++++-
 1 file changed, 106 insertions(+), 1 deletion(-)

diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 020a03e..51c8599 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -59,6 +59,7 @@ extern void octeon_io_clk_delay(unsigned long);
 #define OCTOEN_SERIAL_LEN	20
 
 struct octeon_boot_descriptor {
+#ifdef __BIG_ENDIAN_BITFIELD
 	/* Start of block referenced by assembly code - do not change! */
 	uint32_t desc_version;
 	uint32_t desc_size;
@@ -110,11 +111,64 @@ struct octeon_boot_descriptor {
 	uint8_t mac_addr_base[6];
 	uint8_t mac_addr_count;
 	uint64_t cvmx_desc_vaddr;
+#else
+	uint32_t desc_size;
+	uint32_t desc_version;
+	uint64_t stack_top;
+	uint64_t heap_base;
+	uint64_t heap_end;
+	/* Only used by bootloader */
+	uint64_t entry_point;
+	uint64_t desc_vaddr;
+	/* End of This block referenced by assembly code - do not change! */
+	uint32_t stack_size;
+	uint32_t exception_base_addr;
+	uint32_t argc;
+	uint32_t heap_size;
+	/* Argc count for application. Warning low bit scrambled in little-endian. */
+	uint32_t argv[OCTEON_ARGV_MAX_ARGS];
+
+#define  BOOT_FLAG_INIT_CORE		(1 << 0)
+#define  OCTEON_BL_FLAG_DEBUG		(1 << 1)
+#define  OCTEON_BL_FLAG_NO_MAGIC	(1 << 2)
+	/* If set, use uart1 for console */
+#define  OCTEON_BL_FLAG_CONSOLE_UART1	(1 << 3)
+	/* If set, use PCI console */
+#define  OCTEON_BL_FLAG_CONSOLE_PCI	(1 << 4)
+	/* Call exit on break on serial port */
+#define  OCTEON_BL_FLAG_BREAK		(1 << 5)
+
+	uint32_t core_mask;
+	uint32_t flags;
+	/* physical address of free memory descriptor block. */
+	uint32_t phy_mem_desc_addr;
+	/* DRAM size in megabyes. */
+	uint32_t dram_size;
+	/* CPU clock speed, in hz. */
+	uint32_t eclock_hz;
+	/* used to pass flags from app to debugger. */
+	uint32_t debugger_flags_base_addr;
+	/* SPI4 clock in hz. */
+	uint32_t spi_clock_hz;
+	/* DRAM clock speed, in hz. */
+	uint32_t dclock_hz;
+	uint8_t chip_rev_minor;
+	uint8_t chip_rev_major;
+	uint16_t chip_type;
+	uint8_t board_rev_minor;
+	uint8_t board_rev_major;
+	uint16_t board_type;
+
+	uint64_t unused1[4]; /* Not even filled in by bootloader. */
+
+	uint64_t cvmx_desc_vaddr;
+#endif
 };
 
 union octeon_cvmemctl {
 	uint64_t u64;
 	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
 		/* RO 1 = BIST fail, 0 = BIST pass */
 		uint64_t tlbbist:1;
 		/* RO 1 = BIST fail, 0 = BIST pass */
@@ -128,7 +182,23 @@ union octeon_cvmemctl {
 		/* RO 1 = BIST fail, 0 = BIST pass */
 		uint64_t wbfbist:1;
 		/* Reserved */
-		uint64_t reserved:22;
+		uint64_t reserved:17;
+		/* OCTEON II - TLB replacement policy: 0 = bitmask LRU; 1 = NLU.
+		 * This field selects between the TLB replacement policies:
+		 * bitmask LRU or NLU. Bitmask LRU maintains a mask of
+		 * recently used TLB entries and avoids them as new entries
+		 * are allocated. NLU simply guarantees that the next
+		 * allocation is not the last used TLB entry. */
+		uint64_t tlbnlu:1;
+		/* OCTEON II - Selects the bit in the counter used for releasing
+		 * a PAUSE. This counter trips every 2(8+PAUSETIME) cycles. If
+		 * not already released, the cnMIPS II core will always release
+		 * a given PAUSE instruction within 2(8+PAUSETIME). If the
+		 * counter trip happens to line up, the cnMIPS II core may
+		 * release the PAUSE instantly. */
+		uint64_t pausetime:3;
+		/* OCTEON II - This field is an extension of CvmMemCtl[DIDTTO] */
+		uint64_t didtto2:1;
 		/* R/W If set, marked write-buffer entries time out
 		 * the same as as other entries; if clear, marked
 		 * write-buffer entries use the maximum timeout. */
@@ -207,6 +277,41 @@ union octeon_cvmemctl {
 		/* R/W Size of local memory in cache blocks, 54 (6912
 		 * bytes) is max legal value. */
 		uint64_t lmemsz:6;
+#else
+		uint64_t lmemsz:6;
+		uint64_t cvmsegenau:1;
+		uint64_t cvmsegenas:1;
+		uint64_t cvmsegenak:1;
+		uint64_t reserved2:2;
+		uint64_t wbthresh:4;
+		uint64_t istrnol2:1;
+		uint64_t wbfltime:3;
+		uint64_t mclkalwys:1;
+		uint64_t csrckalwys:1;
+		uint64_t didtto:2;
+		uint64_t nomerge:1;
+		uint64_t allsyncw:1;
+		uint64_t xkioenau:1;
+		uint64_t xkioenas:1;
+		uint64_t xkmemenau:1;
+		uint64_t xkmemenas:1;
+		uint64_t diswbfst:1;
+		uint64_t dissyncws:1;
+		uint64_t syncwsmarked:1;
+		uint64_t iobdmascrmsb:2;
+		uint64_t dismrgclrwbto:1;
+		uint64_t dismarkwblongto:1;
+		uint64_t didtto2:1;
+		uint64_t pausetime:3;
+		uint64_t tlbnlu:1;
+		uint64_t reserved:17;
+		uint64_t wbfbist:1;
+		uint64_t ptgbist:1;
+		uint64_t dcmbist:1;
+		uint64_t l1dbist:1;
+		uint64_t l1cbist:1;
+		uint64_t tlbbist:1;
+#endif
 	} s;
 };
 
-- 
2.6.2

