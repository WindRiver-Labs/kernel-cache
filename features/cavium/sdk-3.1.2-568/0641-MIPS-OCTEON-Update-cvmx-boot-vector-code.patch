From eab1a78682aa5e384f75bdb5f805b5a6caa76405 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 18 Jul 2014 18:05:50 -0700
Subject: [PATCH 641/974] MIPS: OCTEON: Update cvmx-boot-vector code.

Fix usage in smp and watchdog code.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../cavium-octeon/executive/cvmx-boot-vector.c     | 15 ++++-----
 arch/mips/cavium-octeon/smp.c                      |  4 +--
 arch/mips/cavium-octeon/unplug-cpu.c               |  4 +--
 arch/mips/include/asm/octeon/cvmx-boot-vector.h    | 39 +++++++++++++++++++++-
 drivers/watchdog/octeon-wdt-main.c                 |  4 +--
 5 files changed, 51 insertions(+), 15 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-boot-vector.c b/arch/mips/cavium-octeon/executive/cvmx-boot-vector.c
index 1f2b1f6..a09c102 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-boot-vector.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-boot-vector.c
@@ -50,7 +50,7 @@ reset_vector:
 	andi	$k1, 0x3ff	# mask out core ID
 
 	mtc0	$k0, $12, 0	# Status
-	sll	$k1, 3
+	sll	$k1, 5
 
 	lui	$k0, 0xbfc0
 	cache	17, 0($0)	# Core-14345, clear L1 Dcache virtual tags if the core hit an NMI
@@ -95,7 +95,7 @@ wait_loop:
   14:	337b03ff	andi	k1,k1,0x3ff
 
   18:	409a6000	mtc0	k0,c0_status
-  1c:	001bd8c0	sll	k1,k1,0x3
+  1c:	001bd940 	sll	k1,k1,0x5
 
   20:	3c1abfc0	lui	k0,0xbfc0
   24:	bc110000	cache	0x11,0(zero)
@@ -131,7 +131,6 @@ wait_loop:
  */
 
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-#include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-boot-vector.h>
 #else
 #include "cvmx-boot-vector.h"
@@ -141,7 +140,7 @@ static CVMX_SHARED unsigned long long _cvmx_bootvector_data[16] = {
 	0x40baf80040bbf803ull,  /* patch low order 8-bits if no KScratch*/
 	0x401a6000401b7801ull,
 	0x375a0084337b03ffull,
-	0x409a6000001bd8c0ull,
+	0x409a6000001bd940ull,
 	0x3c1abfc0bc110000ull,
 	0xdf5a0078041f0000ull,
 	0x035bd02d00000000ull,
@@ -156,8 +155,8 @@ static CVMX_SHARED unsigned long long _cvmx_bootvector_data[16] = {
 	0 /* To be filled in with address of vector block*/
 };
 
-/* 2^10 CPUs * 8-bytes/CPU */
-#define VECTOR_TABLE_SIZE 8192
+/* 2^10 CPUs */
+#define VECTOR_TABLE_SIZE (1024 * sizeof(struct cvmx_boot_vector_element))
 
 static void cvmx_boot_vector_init(void *mem)
 {
@@ -182,9 +181,9 @@ static void cvmx_boot_vector_init(void *mem)
  * Get a pointer to the per-core table of reset vector pointers
  *
  */
-void **cvmx_boot_vector_get(void)
+struct cvmx_boot_vector_element *cvmx_boot_vector_get(void)
 {
-	void **ret;
+	struct cvmx_boot_vector_element*ret;
 
 	ret = cvmx_bootmem_alloc_named_range_once(VECTOR_TABLE_SIZE, 0, (1ull << 32) - 1, 8,
 						  "__boot_vector1__", cvmx_boot_vector_init);
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index 77f2a7e..323f46f 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -25,7 +25,7 @@ __cpuinitdata unsigned long octeon_processor_sp;
 __cpuinitdata unsigned long octeon_processor_gp;
 
 #ifdef CONFIG_HOTPLUG_CPU
-static void **octeon_bootvector;
+static struct cvmx_boot_vector_element *octeon_bootvector;
 static void *octeon_hotplug_entry_raw;
 extern asmlinkage void octeon_hotplug_entry(void);
 
@@ -372,7 +372,7 @@ static int octeon_up_prepare(unsigned int cpu)
 	int node;
 
 	per_cpu(cpu_state, smp_processor_id()) = CPU_UP_PREPARE;
-	octeon_bootvector[coreid] = octeon_hotplug_entry_raw;
+	octeon_bootvector[coreid].target_ptr = (uint64_t)octeon_hotplug_entry_raw;
 	mb();
 	/* Convert coreid to node,core spair and send NMI to target core */
 	node = cvmx_coremask_core_to_node(coreid);
diff --git a/arch/mips/cavium-octeon/unplug-cpu.c b/arch/mips/cavium-octeon/unplug-cpu.c
index 8a3943f..fdaca18 100644
--- a/arch/mips/cavium-octeon/unplug-cpu.c
+++ b/arch/mips/cavium-octeon/unplug-cpu.c
@@ -16,7 +16,7 @@
 #include <asm/octeon/cvmx-app-hotplug.h>
 #include <asm/octeon/cvmx-spinlock.h>
 
-static void **octeon_bootvector;
+static struct cvmx_boot_vector_element *octeon_bootvector;
 static void *octeon_replug_ll_raw;
 asmlinkage void octeon_replug_ll(void);
 
@@ -61,7 +61,7 @@ static ssize_t __ref plug_cpu_store(struct device *dev,
 			goto not_available_out;
 		}
 
-		octeon_bootvector[coreid] = octeon_replug_ll_raw;
+		octeon_bootvector[coreid].target_ptr = (uint64_t)octeon_replug_ll_raw;
 		mb();
 		node = cvmx_coremask_core_to_node(coreid);
 		coreid = cvmx_coremask_core_on_node(coreid);
diff --git a/arch/mips/include/asm/octeon/cvmx-boot-vector.h b/arch/mips/include/asm/octeon/cvmx-boot-vector.h
index 3f7abd2..962202e 100644
--- a/arch/mips/include/asm/octeon/cvmx-boot-vector.h
+++ b/arch/mips/include/asm/octeon/cvmx-boot-vector.h
@@ -35,12 +35,49 @@
 #ifndef __CVMX_BOOT_VECTOR_H__
 #define __CVMX_BOOT_VECTOR_H__
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <asm/octeon/octeon.h>
+#else
+#include "cvmx.h"
+#endif
+
+/*
+ * The boot vector table is made up of an array of 1024 elements of
+ * struct cvmx_boot_vector_element.  There is one entry for each
+ * possible MIPS CPUNum, indexed by the CPUNum.
+ *
+ * Once cvmx_boot_vector_get() returns a non-NULL value (indicating
+ * success), NMI to a core will cause execution to transfer to the
+ * target_ptr location for that core's entry in the vector table.
+ *
+ * The struct cvmx_boot_vector_element fields app0, app1, and app2 can
+ * be used by the application that has set the target_ptr in any
+ * application specific manner, they are not touched by the vectoring
+ * code.
+ *
+ * The boot vector code clobbers the CP0_DESAVE register, and on
+ * OCTEON II and later CPUs also clobbers CP0_KScratch2.  All GP
+ * registers are preserved, except on pre-OCTEON II CPUs, where k1 is
+ * clobbered.
+ *
+ */
+
+
 /*
  * Applications install the boot bus code in cvmx-boot-vector.c, which
  * uses this magic:
  */
 #define OCTEON_BOOT_MOVEABLE_MAGIC1 0xdb00110ad358eacdull
 
-void **cvmx_boot_vector_get(void);
+struct cvmx_boot_vector_element {
+	/* kseg0 or xkphys address of target code. */
+	uint64_t target_ptr;
+	/* Three application specific arguments. */
+	uint64_t app0;
+	uint64_t app1;
+	uint64_t app2;
+};
+
+struct cvmx_boot_vector_element *cvmx_boot_vector_get(void);
 
 #endif /* __CVMX_BOOT_VECTOR_H__ */
diff --git a/drivers/watchdog/octeon-wdt-main.c b/drivers/watchdog/octeon-wdt-main.c
index 03fbf75..2c5dbad 100644
--- a/drivers/watchdog/octeon-wdt-main.c
+++ b/drivers/watchdog/octeon-wdt-main.c
@@ -117,7 +117,7 @@ MODULE_PARM_DESC(disable,
 
 static unsigned long octeon_wdt_is_open;
 static char expect_close;
-static void **octeon_wdt_bootvector;
+static struct cvmx_boot_vector_element *octeon_wdt_bootvector;
 
 void octeon_wdt_nmi_stage2(void);
 
@@ -346,7 +346,7 @@ static void octeon_wdt_setup_interrupt(int cpu)
 	core = cpu2core(cpu);
 	node = cpu_to_node(cpu);
 
-	octeon_wdt_bootvector[core] = octeon_wdt_nmi_stage2;
+	octeon_wdt_bootvector[core].target_ptr = (uint64_t)octeon_wdt_nmi_stage2;
 
 	/* Disable it before doing anything with the interrupts. */
 	ciu_wdog.u64 = 0;
-- 
2.6.2

