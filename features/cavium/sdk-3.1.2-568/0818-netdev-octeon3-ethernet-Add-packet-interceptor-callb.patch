From 92e0e52ce0c941f75aed6bab5b5ee5617c2dd0dc Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Tue, 8 Jul 2014 18:05:50 -0700
Subject: [PATCH 818/974] netdev: octeon3-ethernet: Add packet interceptor
 callback.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon3-ethernet.c | 71 +++++++++++++++++++++++++-
 1 file changed, 69 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index eedd365..488eb1d 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -48,6 +48,7 @@
 
 #include <asm/octeon/cvmx-fpa-defs.h>
 #include <asm/octeon/cvmx-sso-defs.h>
+#include <asm/octeon/octeon-ethernet-user.h>
 
 #include "octeon-bgx.h"
 
@@ -197,6 +198,7 @@ struct octeon3_ethernet {
 	int rx_buf_count;
 	int tx_complete_grp;
 	spinlock_t stat_lock;
+	cvm_oct_callback_t intercept_cb;
 	u64 last_packets;
 	u64 last_octets;
 	u64 last_dropped;
@@ -282,6 +284,45 @@ MODULE_PARM_DESC(rx_contexts, "Number of RX threads per port.");
 static struct octeon3_ethernet_node octeon3_eth_node[OCTEON3_ETH_MAX_NUMA_NODES];
 static struct kmem_cache *octeon3_eth_sso_pko_cache;
 
+/**
+ * octeon3_register_callback:	Register a intercept callback for the named
+ *				device.
+ *
+ * It returns the net_device structure for the ethernet port. Usign a
+ * callback of NULL will remove the callback. Note that this callback
+ * must not disturb scratch. It will be called with SYNCIOBDMAs in
+ * progress and userspace may be using scratch. It also must not
+ * disturb the group mask.
+ *
+ * @device_name: Device name to register for. (Example: "eth0")
+ * @callback: Intercept callback to set.
+ *
+ * Returns the net_device structure for the ethernet port or NULL on failure.
+ */
+struct net_device *octeon3_register_callback(const char		*device_name,
+					     cvm_oct_callback_t	callback)
+{
+	struct octeon3_ethernet	*priv;
+	int			node;
+
+	rcu_read_lock();
+	for (node = 0; node < OCTEON3_ETH_MAX_NUMA_NODES; node++) {
+		list_for_each_entry_rcu(priv,
+					&octeon3_eth_node[node].device_list,
+					list) {
+			if (strcmp(device_name, priv->netdev->name) == 0) {
+				priv->intercept_cb = callback;
+				rcu_read_unlock();
+				return priv->netdev;
+			}
+		}
+	}
+
+	rcu_read_unlock();
+	return NULL;
+}
+EXPORT_SYMBOL(octeon3_register_callback);
+
 /* octeon3_eth_sso_pass1_limit:	Near full TAQ can cause hang. When the TAQ
  *				(Transitory Admission Queue) is near-full, it is
  *				possible for SSO to hang.
@@ -1140,10 +1181,36 @@ static int octeon3_eth_rx_one(struct octeon3_rx *rx, bool is_async,
 			     work->word2.lf_hdr_type == CVMX_PKI_LTYPE_E_SCTP))
 				if (work->word2.err_code == 0)
 					skb->ip_summed = CHECKSUM_UNNECESSARY;
+		}
 
+		if (unlikely(priv->intercept_cb)) {
+			enum cvm_oct_callback_result cb_result;
 
-		}
-		netif_receive_skb(skb);
+			cb_result = priv->intercept_cb(priv->netdev, work, skb);
+			switch (cb_result) {
+			case CVM_OCT_PASS:
+				netif_receive_skb(skb);
+				break;
+			case CVM_OCT_DROP:
+				atomic64_inc(&priv->rx_dropped);
+				dev_kfree_skb_any(skb);
+				break;
+			case CVM_OCT_TAKE_OWNERSHIP_WORK:
+				/* Interceptor took our work, but we need to
+				 * free the skbuff. This case is not supported
+				 * as it's impossible to free the skb without
+				 * freeing the work.
+				 */
+				WARN_ONCE(true,
+					  "unsupported intercept result %d",
+					  cb_result);
+				break;
+			case CVM_OCT_TAKE_OWNERSHIP_SKB:
+				/* Interceptor took our packet */
+				break;
+			}
+		} else
+			netif_receive_skb(skb);
 	} else {
 		/* Drop any packet received for a device that isn't up */
 		atomic64_inc(&priv->rx_dropped);
-- 
2.6.2

