From 8df32f1d6024e14dc81fcefa82d55e3c6393c694 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Tue, 15 Dec 2015 14:38:50 -0800
Subject: [PATCH 04/13] netdev/phy: Initial support for Vitesse vsc8490 phy.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from patch set for OCTEON SDK 3.1.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/ethernet.c |   24 +++-
 drivers/net/phy/Kconfig                |    6 +
 drivers/net/phy/Makefile               |    1 +
 drivers/net/phy/vsc8490.c              |  257 ++++++++++++++++++++++++++++++++
 4 files changed, 286 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/phy/vsc8490.c

diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index c47077a..879cad7 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -759,6 +759,25 @@ static struct device_node *cvm_oct_node_for_port(struct device_node *pip,
 	return np;
 }
 
+static bool cvm_is_phy_sgmii(struct device_node *node)
+{
+	struct device_node	*phy_node;
+	const char		*p;
+	bool			rc = false;
+
+	phy_node = of_parse_phandle(node, "phy-handle", 0);
+	if (phy_node == NULL)
+		return rc;
+
+	if (!of_property_read_string(phy_node, "vitesse,phy-mode", &p)) {
+		if (!strcmp(p, "sgmii"))
+			rc = true;
+	}
+	of_node_put(phy_node);
+
+	return rc;
+}
+
 static int cvm_oct_get_port_status(struct device_node *pip)
 {
 	int i, j;
@@ -801,8 +820,9 @@ static int cvm_oct_get_port_status(struct device_node *pip)
 				cvmx_helper_set_mac_phy_mode(i, j, false);
 				cvmx_helper_set_1000x_mode(i, j, false);
 				if (port_node) {
-					if (of_get_property(port_node, 
-					    "cavium,sgmii-mac-phy-mode", NULL) != NULL)
+					if ((of_get_property(port_node,
+					     "cavium,sgmii-mac-phy-mode", NULL) != NULL) ||
+					    cvm_is_phy_sgmii(port_node))
 						cvmx_helper_set_mac_phy_mode(i, j, true);
 					if (of_get_property(port_node, 
 					    "cavium,sgmii-mac-1000x-mode", NULL) 
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 2747db8..158a36f 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -66,6 +66,12 @@ config VSC848X_PHY
 	  Driver for Vitesse vsc848x single, dual and quad 10G PHY devices.
 	  Currently supports the vsc8488, vsc8486 and vsc8484 chips
 
+config VSC8490_PHY
+	tristate "Driver for the Vitesse dual channel 10G PHY"
+	help
+	  Driver for the Vitesse vsc8490 dual 10G PHY device.
+          Currently supports the vsc8490
+
 config TLK10232_PHY
 	tristate "Drivers for the TI tlk10232 dual 10G PHY"
 	help
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index d6f7c15..7725958 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
 obj-$(CONFIG_SMSC_PHY)		+= smsc.o
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_VSC848X_PHY)	+= vsc848x.o
+obj-$(CONFIG_VSC8490_PHY)	+= vsc8490.o
 obj-$(CONFIG_TLK10232_PHY)	+= tlk10232.o
 obj-$(CONFIG_BROADCOM_PHY)	+= broadcom.o
 obj-$(CONFIG_BCM63XX_PHY)	+= bcm63xx.o
diff --git a/drivers/net/phy/vsc8490.c b/drivers/net/phy/vsc8490.c
new file mode 100644
index 0000000..610bb08
--- /dev/null
+++ b/drivers/net/phy/vsc8490.c
@@ -0,0 +1,257 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2015 Cavium, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_mdio.h>
+#include <linux/phy.h>
+
+#define PHY_ID_VSC8490			0x0000070400
+
+#define PMA_CTRL1			(MII_ADDR_C45 | 0x01 << 16 | 0x0000)
+#define PMA_STATUS			(MII_ADDR_C45 | 0x01 << 16 | 0x000a)
+
+#define PCS_STATUS			(MII_ADDR_C45 | 0x03 << 16 | 0xe10d)
+
+#define PHYXS_STATUS			(MII_ADDR_C45 | 0x04 << 16 | 0x0018)
+
+
+enum channel_mode {
+	INVALID,
+	RXAUI,
+	XAUI,
+	SGMII
+};
+
+
+struct vsc8490_phy_info {
+	enum channel_mode	mode;
+};
+
+struct vsc8490_nexus_mdiobus {
+	struct mii_bus *mii_bus;
+	struct mii_bus *parent_mii_bus;
+	int reg_offset;
+	struct mutex lock;	/* Lock used for global register sequences */
+	int phy_irq[PHY_MAX_ADDR];
+};
+
+static int vsc8490_probe(struct phy_device *phydev)
+{
+	struct vsc8490_phy_info	*dev_info;
+	const char		*p;
+	int			rc;
+
+	dev_info = devm_kzalloc(&phydev->dev, sizeof(*dev_info), GFP_KERNEL);
+	if (dev_info == NULL)
+		return -ENOMEM;
+
+	rc = of_property_read_string(phydev->dev.of_node, "vitesse,phy-mode",
+				     &p);
+	if (rc) {
+		kfree(dev_info);
+		return -ENODEV;
+	}
+
+	if (!strcmp(p, "sgmii"))
+		dev_info->mode = SGMII;
+	else  if (!strcmp(p, "rxaui"))
+		dev_info->mode = RXAUI;
+	else  if (!strcmp(p, "xaui"))
+		dev_info->mode = XAUI;
+	else
+		dev_info->mode = INVALID;
+
+	phydev->priv = dev_info;
+
+	return 0;
+}
+
+static void vsc8490_remove(struct phy_device *phydev)
+{
+	struct vsc8490_phy_info *dev_info = phydev->priv;
+
+	dev_info(&phydev->dev, "%s Exiting\n", phydev->dev.of_node->full_name);
+	kfree(dev_info);
+}
+
+static int vsc8490_config_aneg(struct phy_device *phydev)
+{
+	return 0;
+}
+
+static int vsc8490_read_status(struct phy_device *phydev)
+{
+	struct vsc8490_phy_info	*dev_info = phydev->priv;
+	int			reg;
+
+	phydev->duplex = 1;
+	phydev->link = 0;
+
+	if (dev_info->mode == XAUI || dev_info->mode == RXAUI) {
+		phydev->speed = 10000;
+
+		reg = phy_read(phydev, PMA_CTRL1);
+		if ((reg & 0x207c) == 0x2040) {
+			reg = phy_read(phydev, PMA_STATUS);
+			if (reg & 1) {
+				reg = phy_read(phydev, PHYXS_STATUS);
+				if (reg & 0x1000)
+					phydev->link = 1;
+			}
+		}
+	} else if (dev_info->mode == SGMII) {
+		phydev->speed = 1000;
+
+		reg = phy_read(phydev, PCS_STATUS);
+		if ((reg & 0x111) == 0x111)
+			phydev->link = 1;
+	}
+
+	return 0;
+}
+
+static int vsc8490_match_phy_device(struct phy_device *phydev)
+{
+	return (phydev->c45_ids.device_ids[1] & 0xfffffff0) == PHY_ID_VSC8490;
+}
+
+static struct phy_driver vsc8490_driver = {
+	.phy_id			= 0,
+	.phy_id_mask		= 0,
+	.name			= "Vitesse VSC8490",
+	.probe			= vsc8490_probe,
+	.remove			= vsc8490_remove,
+	.config_aneg		= vsc8490_config_aneg,
+	.read_status		= vsc8490_read_status,
+	.match_phy_device	= vsc8490_match_phy_device,
+	.driver			= {
+		.owner = THIS_MODULE,
+	},
+};
+
+static int vsc8490_nexus_read(struct mii_bus *bus, int phy_id, int regnum)
+{
+	struct vsc8490_nexus_mdiobus *p = bus->priv;
+	return p->parent_mii_bus->read(p->parent_mii_bus,
+				       phy_id + p->reg_offset,
+				       regnum);
+}
+
+static int vsc8490_nexus_write(struct mii_bus *bus, int phy_id,
+			       int regnum, u16 val)
+{
+	struct vsc8490_nexus_mdiobus *p = bus->priv;
+	return p->parent_mii_bus->write(p->parent_mii_bus,
+					phy_id + p->reg_offset,
+					regnum, val);
+}
+
+static int vsc8490_nexus_probe(struct platform_device *pdev)
+{
+	struct vsc8490_nexus_mdiobus *bus;
+	const char *bus_id;
+	int len;
+	int err = 0;
+
+	bus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);
+	if (!bus)
+		return -ENOMEM;
+
+	bus->parent_mii_bus = container_of(pdev->dev.parent,
+					   struct mii_bus, dev);
+
+	/* The PHY nexux  must have a reg property in the range [0-31] */
+	err = of_property_read_u32(pdev->dev.of_node, "reg", &bus->reg_offset);
+	if (err) {
+		dev_err(&pdev->dev, "%s has invalid PHY address\n",
+			pdev->dev.of_node->full_name);
+		return err;
+	}
+
+	bus->mii_bus = mdiobus_alloc();
+	if (!bus->mii_bus)
+		return -ENOMEM;
+
+	bus->mii_bus->priv = bus;
+	bus->mii_bus->irq = bus->phy_irq;
+	bus->mii_bus->name = "vsc8490_nexus";
+	bus_id = bus->parent_mii_bus->id;
+	len = strlen(bus_id);
+	if (len > MII_BUS_ID_SIZE - 4)
+		bus_id += len - (MII_BUS_ID_SIZE - 4);
+	snprintf(bus->mii_bus->id, MII_BUS_ID_SIZE, "%s:%02x",
+		 bus_id, bus->reg_offset);
+	bus->mii_bus->parent = &pdev->dev;
+
+	bus->mii_bus->read = vsc8490_nexus_read;
+	bus->mii_bus->write = vsc8490_nexus_write;
+	mutex_init(&bus->lock);
+
+	dev_set_drvdata(&pdev->dev, bus);
+
+	err = of_mdiobus_register(bus->mii_bus, pdev->dev.of_node);
+	if (err) {
+		dev_err(&pdev->dev, "Error registering with device tree\n");
+		goto fail_register;
+	}
+
+	return 0;
+
+fail_register:
+	dev_err(&pdev->dev, "Failed to register\n");
+	mdiobus_free(bus->mii_bus);
+	return err;
+}
+
+static int vsc8490_nexus_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct of_device_id vsc8490_nexus_match[] = {
+	{
+		.compatible = "vitesse,vsc8490-nexus",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, vsc8490_nexus_match);
+
+static struct platform_driver vsc8490_nexus_driver = {
+	.driver = {
+		.name		= "vsc8490-nexus",
+		.owner		= THIS_MODULE,
+		.of_match_table = vsc8490_nexus_match,
+	},
+	.probe		= vsc8490_nexus_probe,
+	.remove		= vsc8490_nexus_remove,
+};
+
+static int __init vsc8490_init(void)
+{
+	int	rc;
+
+	rc = platform_driver_register(&vsc8490_nexus_driver);
+	if (rc)
+		return rc;
+
+	rc = phy_driver_register(&vsc8490_driver);
+
+	return rc;
+}
+module_init(vsc8490_init);
+
+static void __exit vsc8490_exit(void)
+{
+	phy_driver_unregister(&vsc8490_driver);
+}
+module_exit(vsc8490_exit);
+
+MODULE_AUTHOR("Carlos Munoz <cmunoz@caviumnetworks.com>");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

