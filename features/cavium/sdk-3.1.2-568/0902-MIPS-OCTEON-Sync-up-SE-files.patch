From ac564bcf9d3c6ee545d05f0028ce4666e3e45a18 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 3 Jul 2014 18:05:50 -0700
Subject: [PATCH 902/974] MIPS: OCTEON: Sync-up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |  55 ++-
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |   7 +
 .../mips/cavium-octeon/executive/cvmx-helper-ilk.c |  12 +
 .../mips/cavium-octeon/executive/cvmx-helper-npi.c |   9 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     | 274 +++++++++--
 .../cavium-octeon/executive/cvmx-helper-util.c     |   2 +-
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |   4 +-
 arch/mips/cavium-octeon/executive/cvmx-pki.c       |  16 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      | 159 ++++++
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |  67 ++-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |   4 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      | 350 ++++++-------
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h       |   3 +-
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       |  87 ++++
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h       |  20 +-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-fpa.h            |  22 +-
 arch/mips/include/asm/octeon/cvmx-fpa1.h           |  11 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     | 105 +++-
 arch/mips/include/asm/octeon/cvmx-helper-cfg.h     |   2 +
 arch/mips/include/asm/octeon/cvmx-iobn-defs.h      |  48 ++
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |  20 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      | 405 +++++++++++++--
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       | 327 ++++++++----
 arch/mips/include/asm/octeon/cvmx-mpi-defs.h       | 117 +++--
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |   6 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |  97 ++--
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |   4 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      | 547 +++++++++++++++------
 arch/mips/include/asm/octeon/cvmx-pki-cluster.h    | 204 +++++---
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  18 +-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 110 +++--
 arch/mips/include/asm/octeon/cvmx-pko3.h           |   2 +
 arch/mips/include/asm/octeon/cvmx-qlm.h            |   4 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |  52 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       |  52 +-
 .../mips/include/asm/octeon/cvmx-sriomaintx-defs.h |  40 +-
 arch/mips/include/asm/octeon/cvmx-sriox-defs.h     |  31 +-
 39 files changed, 2337 insertions(+), 960 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index e8a8910..7f169c1 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -143,7 +143,7 @@ int __cvmx_helper_bgx_enumerate(int xiface)
 	case CVMX_QLM_MODE_RGMII_XLAUI:
 	case CVMX_QLM_MODE_RXAUI:
 	case CVMX_QLM_MODE_RGMII_RXAUI:
-	case CVMX_QLM_MODE_SGMII_1X2:
+	case CVMX_QLM_MODE_SGMII_2X1:
 	case CVMX_QLM_MODE_RGMII_SGMII_1X1:
 	case CVMX_QLM_MODE_10G_KR_1X2:
 	case CVMX_QLM_MODE_XFI_1X2:
@@ -1306,11 +1306,15 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 	cvmx_bgxx_cmrx_config_t cmr_config;
 	cvmx_helper_interface_mode_t mode;
 	int use_training = 0;
+	int rgmii_first = 0;
 
 	if (debug)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
 		__func__, xi.node, xi.interface, index);
 
+	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, xi.interface));
+	rgmii_first = (cmr_config.s.lmac_type == 5);
+
 	mode = cvmx_helper_interface_get_mode(xiface);
 
 	if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4)
@@ -1374,13 +1378,29 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 			return -1;
 		}
 
-		/* With XFI and XLAUI, we need to perform RX equalization when the
-		   link is receiving data the first time */
-		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI
-		    || mode == CVMX_HELPER_INTERFACE_MODE_XLAUI) {
+		/* (GSER-21957) GSER RX Equalization may make >= 5gbaud non-KR
+		   channel with DXAUI, RXAUI, XFI and XLAUI, we need to perform
+		   RX equalization when the link is receiving data the first time */
+		if (use_training == 0) {
 			int qlm = cvmx_qlm_interface(xiface);
-			__cvmx_qlm_rx_equalization(node, qlm,
-				(mode == CVMX_HELPER_INTERFACE_MODE_XLAUI ? -1 : index));
+			int lane = index;
+			cmr_config.u64 = cvmx_read_csr_node(node,
+					CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
+			if (cmr_config.s.lmac_type == 4
+			    || cmr_config.s.lmac_type == 1) { // XLAUI/DXAUI
+				lane = -1;
+				__cvmx_qlm_rx_equalization(node, qlm, lane);
+			} else if (cmr_config.s.lmac_type == 2) { // RXAUI
+				lane = index * 2;
+				if (rgmii_first)
+					lane--;
+				__cvmx_qlm_rx_equalization(node, qlm, lane);
+				__cvmx_qlm_rx_equalization(node, qlm, lane + 1);
+			} else if (cmr_config.s.lmac_type != 5) { // !RGMII
+				if (rgmii_first)
+					lane--;
+				__cvmx_qlm_rx_equalization(node, qlm, lane);
+			}
 		}
 
 		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI
@@ -2111,7 +2131,7 @@ int cvmx_dump_bgx_status_node(unsigned node, unsigned bgx);
  * for up to 4 LMACs of single BGX device (same macros used for GSER)
  * MACROS automaticaly handle data types ('unsigned' or 'const char *') and
  * indexing (by predefined 'ind' string used as index).
- * NOTE that there different groups of macros:
+ * NOTE that there are different groups of macros:
  *  'PRn' 	means it prints unconditionaly, data are 'unsigned' type
  *  'PRns'	means it prints unconditionaly, data are 'const char *' type
  *  'PRc' 	means it print only if 'cond' argument is 'true'
@@ -2382,7 +2402,8 @@ int cvmx_helper_bgx_number_rx_tx_lmacs(unsigned node, unsigned bgx, unsigned *pN
 		*pN = rx_lmacs.s.lmacs;
 		return 0;
 	} else { /* This can happen only if BGX_config is wrong, so report it */
-		N = __cvmx_helper_bgx_enumerate(cvmx_helper_node_interface_to_xiface(node, bgx));
+		N = __cvmx_helper_bgx_enumerate(
+			cvmx_helper_node_interface_to_xiface(node, bgx) );
 		cvmx_dprintf("<<<WARNING>>>: RX_LMACS != TX_LMACS;"
 			" return  __cvmx_helper_bgx_enumerate(xiface)=%d\n", N);
 		if (N >= 0)
@@ -2531,6 +2552,8 @@ int cvmx_helper_bgx_link_status(int node, int bgx, unsigned N)
 		lmac_type = lmac[ind].cmr_config.s.lmac_type;
 		switch (lmac_type) {
 			case 0: /* SGMII/1000BASE-X */
+				/* the first read reads/clears the old lnk_st;
+					repeat this func to see the current lnk_st value */
 				lmac[ind].gmp_pcs_mr_status.u64 = cvmx_read_csr_node(node,
 					CVMX_BGXX_GMP_PCS_MRX_STATUS(ind, bgx));
 				break;
@@ -3288,11 +3311,11 @@ int cvmx_dump_bgx_config_node(unsigned node, unsigned bgx)
 
 
 	cvmx_dprintf("/*=== BGX MISC CONFIG Parameters ===*/\n");
-	PRns("Link Status (typically from external PHY ANEG)",N,"      %4s     ",
-		lmac[ind].link_info.s.link_up ? " Up " : "Down");
-	PRns("Link Duplex",		N, "      %4s     ",
+	PRns("Link Status (from (external) PHY ANEG)[SE API]", N,
+	     "      %4s     ", lmac[ind].link_info.s.link_up ? " Up " : "Down");
+	PRns("Link Duplex [SE API]",		N, "      %4s     ",
 		lmac[ind].link_info.s.full_duplex ? "Full" : "Half");
-	PRn("Link Speed (MBps)",	N, "      %5d    ",
+	PRn("Link Speed (MBps) [SE API]",	N, "      %5d    ",
 	       lmac[ind].link_info.s.speed);
 	PRns("Data Packet Receive (data_pkt_rx_en)", N, "   %8s    ",
 	       lmac[ind].cmr_config.s.data_pkt_rx_en ? " Enabled" : "Disabled");
@@ -3551,11 +3574,11 @@ int cvmx_dump_bgx_status_node(unsigned node, unsigned bgx)
 	}
 
 	PRn("LMAC:",			N, "     lmac%d     ", ind);
-	PRns("Link Status (from ANEG)",N,"      %4s     ",
+	PRns("Link Status (from ANEG)[SE API]",N,"      %4s     ",
 		lmac[ind].link_info.s.link_up ? " Up " : "Down");
-	PRns("Link Duplex",		N, "      %4s     ",
+	PRns("Link Duplex [SE API]",		N, "      %4s     ",
 		lmac[ind].link_info.s.full_duplex ? "Full" : "Half");
-	PRn("Link Speed (MBps)",	N, "     %5d     ",
+	PRn("Link Speed (MBps) [SE API]",	N, "     %5d     ",
 		lmac[ind].link_info.s.speed);
 	cvmx_helper_bgx_link_status(node, bgx, N);
 	PRn("RX FIFO LEN(fifo_len)", N, "     %5d     ",
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index 089724d..ae1b70d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -78,6 +78,8 @@
 # define min( a, b ) ( ( a ) < ( b ) ) ? ( a ) : ( b )
 #endif
 
+int cvmx_npi_max_pknds;
+
 CVMX_SHARED struct cvmx_cfg_port_param cvmx_cfg_port[CVMX_MAX_NODES][CVMX_HELPER_MAX_IFACE][CVMX_HELPER_CFG_MAX_PORT_PER_IFACE] =
 	{[0 ... CVMX_MAX_NODES - 1][0 ... CVMX_HELPER_MAX_IFACE - 1] =
 		{[0 ... CVMX_HELPER_CFG_MAX_PORT_PER_IFACE - 1] =
@@ -1036,6 +1038,11 @@ int __cvmx_helper_init_port_config_data(int node)
 				}
 			} else {
 				for (j = 0; j < n; j++) {
+
+					if (j == n/cvmx_npi_max_pknds) {
+						pknd++;
+						bpid++;
+					}
 					cvmx_cfg_port[node][i][j].ccpp_pknd = pknd;
 					cvmx_cfg_port[node][i][j].ccpp_bpid = bpid;
 				}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c b/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
index 7ac0e5e..63e1af0 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
@@ -728,6 +728,18 @@ retry:
 	ilk_rxx_int.u64 = cvmx_read_csr_node(node, CVMX_ILK_RXX_INT(interface));
 
 	if (ilk_rxx_cfg1.s.rx_bdry_lock_ena == 0) {
+		/* (GSER-21957) GSER RX Equalization may make >= 5gbaud non-KR
+		   channel better */
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+			int qlm, lane_mask;
+			for (qlm = 4; qlm < 8; qlm++) {
+				lane_mask = 1 << (qlm - 4) * 4;
+				if (lane_mask & cvmx_ilk_lane_mask[node][interface]) {
+					__cvmx_qlm_rx_equalization(node, qlm, -1);
+				}
+			}
+		}
+
 		/* Clear the boundary lock status bit */
 		ilk_rxx_int.u64 = 0;
 		ilk_rxx_int.s.word_sync_done = 1;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
index 657f946..4559307 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
@@ -43,7 +43,7 @@
  * Functions for NPI initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 115697 $<hr>
+ * <hr>$Revision: 120569 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -84,9 +84,10 @@ void cvmx_npi_config_set_num_pipes(int num_pipes)
 int __cvmx_helper_npi_probe(int interface)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
-			return 32;
-        } else if (OCTEON_IS_MODEL(OCTEON_CN78XX)
-		   || OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		return 32;
+        } else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		return 128;
+        } else if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
                 return 64;
         } else if (!(OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1_X) ||
 		   OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_X) ||
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 18f6f0d..fe7abab 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -909,10 +909,8 @@ int cvmx_helper_pko3_init_interface(int xiface)
 	}
 
 	/* Force 8 DQs per port for pass 1.0 to circumvent limitations */
-	if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0)) {
+	if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0))
 		num_queues = 8;
-		qos = true;
-	}
 
 	/* For ILK there is one IPD port per channel */
 	if ((mode == CVMX_HELPER_INTERFACE_MODE_ILK))
@@ -1387,30 +1385,30 @@ do { \
 	cvmx_printf("%s %s\n", lines[0], lines[1]); \
 } while (0)
 
-#define PARPRINT(__head, __format, ...) \
+#define PARPRINT(__offs, __head, __format, ...) \
 do {\
-	cvmx_printf("%4s%-*s", "", PKO_PRN_HEADLEN - 4, __head); \
+	cvmx_printf("%*s%-*s", __offs, "", PKO_PRN_HEADLEN - __offs, __head); \
 	cvmx_printf(__format, ## __VA_ARGS__); \
 } while (0)
 
 #define PKO_MAC_NUM	32
 char *pko_macmap[PKO_MAC_NUM][3] = {
 			/*CN78XX		CN73XX			CNF75XX*/
-	[0]  = {"LBK",			"LBK",			"LBK"},
-	[1]  = {"DPI",			"DPI",			"DPI"},
-	[2]  = {"ILK0",			"BGX0:MAC0",	"BGX0:MAC0"},
-	[3]  = {"ILK1",			"BGX0:MAC1",	"BGX0:MAC1"},
+	[0]  = {"LBK      ",	"LBK      ",	"LBK      "},
+	[1]  = {"DPI      ",	"DPI      ",	"DPI      "},
+	[2]  = {"ILK0     ",	"BGX0:MAC0",	"BGX0:MAC0"},
+	[3]  = {"ILK1     ",	"BGX0:MAC1",	"BGX0:MAC1"},
 	[4]  = {"BGX0:MAC0",	"BGX0:MAC2",	"BGX0:MAC2"},
 	[5]  = {"BGX0:MAC1",	"BGX0:MAC3",	"BGX0:MAC3"},
-	[6]  = {"BGX0:MAC2",	"BGX1:MAC0",	"SRIO0-0"},
-	[7]  = {"BGX0:MAC3",	"BGX1:MAC1",	"SRIO0-1"},
-	[8]  = {"BGX1:MAC0",	"BGX1:MAC2",	"SRIO1-0"},
-	[9]  = {"BGX1:MAC1",	"BGX1:MAC3",	"SRIO1-1"},
-	[10] = {"BGX1:MAC2",	"BGX2:MAC0",	"NULL"},
+	[6]  = {"BGX0:MAC2",	"BGX1:MAC0",	"SRIO0-0  "},
+	[7]  = {"BGX0:MAC3",	"BGX1:MAC1",	"SRIO0-1  "},
+	[8]  = {"BGX1:MAC0",	"BGX1:MAC2",	"SRIO1-0  "},
+	[9]  = {"BGX1:MAC1",	"BGX1:MAC3",	"SRIO1-1  "},
+	[10] = {"BGX1:MAC2",	"BGX2:MAC0",	"NULL     "},
 	[11] = {"BGX1:MAC3",	"BGX2:MAC1",	NULL},
 	[12] = {"BGX2:MAC0",	"BGX2:MAC2",	NULL},
 	[13] = {"BGX2:MAC1",	"BGX2:MAC3",	NULL},
-	[14] = {"BGX2:MAC2",	"NULL",			NULL},
+	[14] = {"BGX2:MAC2",	"NULL     ",	NULL},
 	[15] = {"BGX2:MAC3",	NULL,			NULL},
 	[16] = {"BGX3:MAC0",	NULL,			NULL},
 	[17] = {"BGX3:MAC1",	NULL,			NULL},
@@ -1424,7 +1422,7 @@ char *pko_macmap[PKO_MAC_NUM][3] = {
 	[25] = {"BGX5:MAC1",	NULL,			NULL},
 	[26] = {"BGX5:MAC2",	NULL,			NULL},
 	[27] = {"BGX5:MAC3",	NULL,			NULL},
-	[28] = {"NULL",			NULL,			NULL},
+	[28] = {"NULL     ",	NULL,			NULL},
 	[29] = {NULL,			NULL,			NULL},
 	[30] = {NULL,			NULL,			NULL},
 	[31] = {NULL,			NULL,			NULL}
@@ -1446,9 +1444,28 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 	cvmx_pko_l3_sqx_schedule_t l3sch;
 	cvmx_pko_l2_sqx_schedule_t l2sch;
 	cvmx_pko_l1_sqx_schedule_t l1sch;
+	cvmx_pko_dqx_shape_t dqshape;
+	cvmx_pko_l5_sqx_shape_t l5shape;
+	cvmx_pko_l4_sqx_shape_t l4shape;
+	cvmx_pko_l3_sqx_shape_t l3shape;
+	cvmx_pko_l2_sqx_shape_t l2shape;
+	cvmx_pko_l1_sqx_shape_t l1shape;
+	cvmx_pko_dqx_cir_t dqcir;
+	cvmx_pko_l5_sqx_cir_t l5cir;
+	cvmx_pko_l4_sqx_cir_t l4cir;
+	cvmx_pko_l3_sqx_cir_t l3cir;
+	cvmx_pko_l2_sqx_cir_t l2cir;
+	cvmx_pko_l1_sqx_cir_t l1cir;
+	cvmx_pko_dqx_pir_t dqpir;
+	cvmx_pko_l5_sqx_pir_t l5pir;
+	cvmx_pko_l4_sqx_pir_t l4pir;
+	cvmx_pko_l3_sqx_pir_t l3pir;
+	cvmx_pko_l2_sqx_pir_t l2pir;
 	cvmx_pko_macx_cfg_t maccfg;
 	cvmx_pko_l3_l2_sqx_channel_t chcfg;
 	cvmx_pko_channel_level_t chlvl;
+	cvmx_pko_shaper_cfg_t shapercfg;
+	cvmx_pko_l1_sqx_link_t l1link;
 	uint32_t crc32, pcrc32;
 	char lines[4][128];
 
@@ -1458,11 +1475,18 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		cvmx_printf("PKO3 Config Dump is not supported on this OCTEON model\n");
 		return 0;
 	}
-	chlvl.u64 = cvmx_read_csr_node(node, CVMX_PKO_CHANNEL_LEVEL);
 	memset(lines[3], '*', PKO_PRN_LINELEN);  lines[3][PKO_PRN_LINELEN] = '\0';
 	cvmx_printf("\n%s\n", lines[3]);
 	cvmx_printf("   PKO Configuration (Node %d)\n", node);
 	cvmx_printf("%s\n", lines[3]);
+
+	/* Global parameters: */
+	chlvl.u64 = cvmx_read_csr_node(node, CVMX_PKO_CHANNEL_LEVEL);
+	shapercfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_SHAPER_CFG);
+	PARPRINT(0, "CC Level", "%*d\n", PKO_PRN_DPLEN(1), chlvl.s.cc_level + 2);
+	PARPRINT(0, "Color Aware", "%*s\n", PKO_PRN_DPLEN(1), (shapercfg.s.color_aware == 1) ? "Yes":"No");
+
+	/* Queues: */
 	cvmx_printf("%-*s%*s%*s%*s%*s%*s%*s%*s%*s\n", PKO_PRN_HEADLEN, "",
 		PKO_PRN_DPLEN(8), "DQ", PKO_PRN_DPLEN(8), "L5", PKO_PRN_DPLEN(8), "L4",
 		PKO_PRN_DPLEN(8), "L3", PKO_PRN_DPLEN(8),"L2", PKO_PRN_DPLEN(8), "L1",
@@ -1480,6 +1504,12 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		CVMX_MT_CRC_DWORD(dqtop.u64);
 		dqsch.u64 = cvmx_read_csr_node(node, CVMX_PKO_DQX_SCHEDULE(queue));
 		CVMX_MT_CRC_DWORD(dqsch.u64);
+		dqshape.u64 = cvmx_read_csr_node(node, CVMX_PKO_DQX_SHAPE(queue));
+		CVMX_MT_CRC_DWORD(dqshape.u64);
+		dqcir.u64 = cvmx_read_csr_node(node, CVMX_PKO_DQX_CIR(queue));
+		CVMX_MT_CRC_DWORD(dqcir.u64);
+		dqpir.u64 = cvmx_read_csr_node(node, CVMX_PKO_DQX_PIR(queue));
+		CVMX_MT_CRC_DWORD(dqpir.u64);
 
 		/* L5-L3 Queue Levels: */
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) { 
@@ -1496,6 +1526,27 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 			CVMX_MT_CRC_DWORD(l4sch.u64);
 			l3sch.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_SCHEDULE(l4top.s.parent));
 			CVMX_MT_CRC_DWORD(l3sch.u64);
+
+			l5shape.u64 = cvmx_read_csr_node(node, CVMX_PKO_L5_SQX_SHAPE(dqtop.s.parent));
+			CVMX_MT_CRC_DWORD(l5shape.u64);
+			l4shape.u64 = cvmx_read_csr_node(node, CVMX_PKO_L4_SQX_SHAPE(l5top.s.parent));
+			CVMX_MT_CRC_DWORD(l4shape.u64);
+			l3shape.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_SHAPE(l4top.s.parent));
+			CVMX_MT_CRC_DWORD(l3shape.u64);
+
+			l5cir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L5_SQX_CIR(dqtop.s.parent));
+			CVMX_MT_CRC_DWORD(l5cir.u64);
+			l4cir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L4_SQX_CIR(l5top.s.parent));
+			CVMX_MT_CRC_DWORD(l4cir.u64);
+			l3cir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_CIR(l4top.s.parent));
+			CVMX_MT_CRC_DWORD(l3cir.u64);
+
+			l5pir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L5_SQX_PIR(dqtop.s.parent));
+			CVMX_MT_CRC_DWORD(l5pir.u64);
+			l4pir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L4_SQX_PIR(l5top.s.parent));
+			CVMX_MT_CRC_DWORD(l4pir.u64);
+			l3pir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_PIR(l4top.s.parent));
+			CVMX_MT_CRC_DWORD(l3pir.u64);
 		}
 		else {
 			l5top.u64 = l4top.u64 = 0;
@@ -1505,6 +1556,16 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 			l5sch.u64 = l4sch.u64 = 0;
 			l3sch.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_SCHEDULE(dqtop.s.parent));
 			CVMX_MT_CRC_DWORD(l3sch.u64);
+
+			l5shape.u64 = l4shape.u64 = 0;
+			l3shape.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_SHAPE(dqtop.s.parent));
+			CVMX_MT_CRC_DWORD(l3shape.u64);
+
+			l5cir.u64 = l4cir.u64 = l5pir.u64 = l4pir.u64 = 0;
+			l3cir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_CIR(dqtop.s.parent));
+			CVMX_MT_CRC_DWORD(l3cir.u64);
+			l3pir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_PIR(dqtop.s.parent));
+			CVMX_MT_CRC_DWORD(l3pir.u64);
 		}
 		/* L2-L1 Queue Levels: */
 		l2top.u64 = cvmx_read_csr_node(node, CVMX_PKO_L2_SQX_TOPOLOGY(l3top.s.parent));
@@ -1517,6 +1578,22 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		l1sch.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_SCHEDULE(l2top.s.parent));
 		CVMX_MT_CRC_DWORD(l1sch.u64);
 
+		l2shape.u64 = cvmx_read_csr_node(node, CVMX_PKO_L2_SQX_SHAPE(l3top.s.parent));
+		CVMX_MT_CRC_DWORD(l2shape.u64);
+		l1shape.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_SHAPE(l2top.s.parent));
+		CVMX_MT_CRC_DWORD(l1shape.u64);
+
+		l2cir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L2_SQX_CIR(l3top.s.parent));
+		CVMX_MT_CRC_DWORD(l2cir.u64);
+		l1cir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_CIR(l2top.s.parent));
+		CVMX_MT_CRC_DWORD(l1cir.u64);
+
+		l2pir.u64 = cvmx_read_csr_node(node, CVMX_PKO_L2_SQX_PIR(l3top.s.parent));
+		CVMX_MT_CRC_DWORD(l2pir.u64);
+
+		l1link.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_LINK(l2top.s.parent));
+		CVMX_MT_CRC_DWORD(l1link.u64 & (0x1Full << 44 | 0x2ull));
+
 		/* MAC/FIFO Level: */
 		if (l1top.s.link > nmacs) {
 			maccfg.u64 = 0;
@@ -1539,12 +1616,15 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		CVMX_MT_CRC_DWORD(maccfg.u64);
 
 		if (chlvl.s.cc_level == 0) { /* Level 2 as the Channel Level?*/
-			chcfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_L2_SQX_CHANNEL(l2top.s.parent));
+			chcfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_L2_SQX_CHANNEL(l3top.s.parent));
 			sprintf(lines[2], "%s", "--");
 			sprintf(lines[3], "%d", chcfg.s.cc_channel);
 		}
 		else {
-			chcfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_L2_SQX_CHANNEL(l3top.s.parent));
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				chcfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_L2_SQX_CHANNEL(l4top.s.parent));
+			else
+				chcfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_L2_SQX_CHANNEL(dqtop.s.parent));
 			sprintf(lines[2], "%d", chcfg.s.cc_channel);
 			sprintf(lines[3], "%s", "--");
 		}
@@ -1560,64 +1640,136 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		pcrc32 = crc32;
 		base = queue;
 		cvmx_printf("DQ%d:\n", queue);
+		PARPRINT(4, "Channel", "%*s%-*s%*s%*s%*s%*s%-*s%*s\n",
+			PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8) + 1, lines[0],
+			PKO_PRN_DPLEN(8) - 1, "", PKO_PRN_DPLEN(8), lines[2],
+			PKO_PRN_DPLEN(8), lines[3], PKO_PRN_DPLEN(8), "",
+			PKO_PRN_DPLEN(8), chcfg.s.cc_enable ? "CC-En" : "CC-Dis",
+			PKO_PRN_DPLEN(8), l1link.s.cc_enable ? "LC-En" : "LC-Dis");
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-			PARPRINT("Path", "%*s%*d%*d%*d%*d%*d%*d%*s\n",
+			PARPRINT(4, "Path", "%*s%*d%*d%*d%*d%*d%*d%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), dqtop.s.parent,
 				PKO_PRN_DPLEN(8), l5top.s.parent, PKO_PRN_DPLEN(8), l4top.s.parent,
 				PKO_PRN_DPLEN(8), l3top.s.parent, PKO_PRN_DPLEN(8), l2top.s.parent,
 				PKO_PRN_DPLEN(8), l1top.s.link, PKO_PRN_DPLEN(8), lines[1]);
-			PARPRINT("Prio-Anchor", "%*s%*d%*d%*d%*d%*d%*s%*s\n",
+			PARPRINT(4, "Prio-Anchor", "%*s%*d%*d%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), l5top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), l4top.s.prio_anchor, PKO_PRN_DPLEN(8), l3top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), l2top.s.prio_anchor, PKO_PRN_DPLEN(8), l1top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT("Prio", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+			PARPRINT(4, "Prio", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqsch.s.prio, PKO_PRN_DPLEN(8), l5sch.s.prio,
 				PKO_PRN_DPLEN(8), l4sch.s.prio, PKO_PRN_DPLEN(8), l3sch.s.prio,
 				PKO_PRN_DPLEN(8), l2sch.s.prio, PKO_PRN_DPLEN(8), "--",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT("RR-Prio", "%*s%*d%*d%*d%*d%*d%*s%*s\n",
+			PARPRINT(4, "RR-Prio", "%*s%*d%*d%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), l5top.s.rr_prio,
 				PKO_PRN_DPLEN(8), l4top.s.rr_prio, PKO_PRN_DPLEN(8), l3top.s.rr_prio,
 				PKO_PRN_DPLEN(8), l2top.s.rr_prio, PKO_PRN_DPLEN(8), l1top.s.rr_prio,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT("RR-Quantum", "%*x%*x%*x%*x%*x%*x%*s%*s\n",
+			PARPRINT(4, "RR-Quantum", "%*x%*x%*x%*x%*x%*x%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqsch.s.rr_quantum, PKO_PRN_DPLEN(8), l5sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), l4sch.s.rr_quantum, PKO_PRN_DPLEN(8), l3sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), l2sch.s.rr_quantum, PKO_PRN_DPLEN(8), l1sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), "(hex)", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "Length Dis", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.length_disable, PKO_PRN_DPLEN(8), l5shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l4shape.s.length_disable, PKO_PRN_DPLEN(8), l3shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l2shape.s.length_disable, PKO_PRN_DPLEN(8), l1shape.s.length_disable,
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "Adjust", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.adjust, PKO_PRN_DPLEN(8), l5shape.s.adjust,
+				PKO_PRN_DPLEN(8), l4shape.s.adjust, PKO_PRN_DPLEN(8), l3shape.s.adjust,
+				PKO_PRN_DPLEN(8), l2shape.s.adjust, PKO_PRN_DPLEN(8), l1shape.s.adjust,
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "YELLOW Dis", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.yellow_disable, PKO_PRN_DPLEN(8), l5shape.s.yellow_disable,
+				PKO_PRN_DPLEN(8), l4shape.s.yellow_disable, PKO_PRN_DPLEN(8), l3shape.s.yellow_disable,
+				PKO_PRN_DPLEN(8), l2shape.s.yellow_disable, PKO_PRN_DPLEN(8), "--",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "RED Dis", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.red_disable, PKO_PRN_DPLEN(8), l5shape.s.red_disable,
+				PKO_PRN_DPLEN(8), l4shape.s.red_disable, PKO_PRN_DPLEN(8), l3shape.s.red_disable,
+				PKO_PRN_DPLEN(8), l2shape.s.red_disable, PKO_PRN_DPLEN(8), "--",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "RED Algo", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.red_algo, PKO_PRN_DPLEN(8), l5shape.s.red_algo,
+				PKO_PRN_DPLEN(8), l4shape.s.red_algo, PKO_PRN_DPLEN(8), l3shape.s.red_algo,
+				PKO_PRN_DPLEN(8), l2shape.s.red_algo, PKO_PRN_DPLEN(8), "--",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "PIR Enable", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqpir.s.enable, PKO_PRN_DPLEN(8), l5pir.s.enable,
+				PKO_PRN_DPLEN(8), l4pir.s.enable, PKO_PRN_DPLEN(8), l3pir.s.enable,
+				PKO_PRN_DPLEN(8), l2pir.s.enable, PKO_PRN_DPLEN(8), "--",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "CIR Enable", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqcir.s.enable, PKO_PRN_DPLEN(8), l5cir.s.enable,
+				PKO_PRN_DPLEN(8), l4cir.s.enable, PKO_PRN_DPLEN(8), l3cir.s.enable,
+				PKO_PRN_DPLEN(8), l2cir.s.enable, PKO_PRN_DPLEN(8), l1cir.s.enable,
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
 		}
 		else {
-			PARPRINT("Path", "%*s%*s%*s%*d%*d%*d%*d%*s\n",
+			PARPRINT(4, "Path", "%*s%*s%*s%*d%*d%*d%*d%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), dqtop.s.parent,
 				PKO_PRN_DPLEN(8), l3top.s.parent, PKO_PRN_DPLEN(8), l2top.s.parent,
 				PKO_PRN_DPLEN(8), l1top.s.link, PKO_PRN_DPLEN(8), lines[1]);
-			PARPRINT("Prio-Anchor", "%*s%*s%*s%*d%*d%*d%*s%*s\n",
+			PARPRINT(4, "Prio-Anchor", "%*s%*s%*s%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), l2top.s.prio_anchor, PKO_PRN_DPLEN(8), l1top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT("Prio", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+			PARPRINT(4, "Prio", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqsch.s.prio, PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3sch.s.prio,
 				PKO_PRN_DPLEN(8), l2sch.s.prio, PKO_PRN_DPLEN(8), "--",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT("RR-Prio", "%*s%*s%*s%*d%*d%*d%*s%*s\n",
+			PARPRINT(4, "RR-Prio", "%*s%*s%*s%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3top.s.rr_prio,
 				PKO_PRN_DPLEN(8), l2top.s.rr_prio, PKO_PRN_DPLEN(8), l1top.s.rr_prio,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT("RR-Quantum", "%*x%*s%*s%*x%*x%*x%*s%*s\n",
+			PARPRINT(4, "RR-Quantum", "%*x%*s%*s%*x%*x%*x%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqsch.s.rr_quantum, PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), l2sch.s.rr_quantum, PKO_PRN_DPLEN(8), l1sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), "(hex)", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "Length Dis", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.length_disable, PKO_PRN_DPLEN(8), "",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l2shape.s.length_disable, PKO_PRN_DPLEN(8), l1shape.s.length_disable,
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "Adjust", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.adjust, PKO_PRN_DPLEN(8), "",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.adjust,
+				PKO_PRN_DPLEN(8), l2shape.s.adjust, PKO_PRN_DPLEN(8), l1shape.s.adjust,
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "YELLOW Dis", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.yellow_disable, PKO_PRN_DPLEN(8), "",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.yellow_disable,
+				PKO_PRN_DPLEN(8), l2shape.s.yellow_disable, PKO_PRN_DPLEN(8), "--",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "RED Dis", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.red_disable, PKO_PRN_DPLEN(8), "",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.red_disable,
+				PKO_PRN_DPLEN(8), l2shape.s.red_disable, PKO_PRN_DPLEN(8), "--",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "RED Algo", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqshape.s.red_algo, PKO_PRN_DPLEN(8), "",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.red_algo,
+				PKO_PRN_DPLEN(8), l2shape.s.red_algo, PKO_PRN_DPLEN(8), "--",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "PIR Enable", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqpir.s.enable, PKO_PRN_DPLEN(8), "",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3pir.s.enable,
+				PKO_PRN_DPLEN(8), l2pir.s.enable, PKO_PRN_DPLEN(8), "--",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			PARPRINT(4, "CIR Enable", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
+				PKO_PRN_DPLEN(8), dqcir.s.enable, PKO_PRN_DPLEN(8), "",
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3cir.s.enable,
+				PKO_PRN_DPLEN(8), l2cir.s.enable, PKO_PRN_DPLEN(8), l1cir.s.enable,
+				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
 		}
-		PARPRINT("Channel", "%*s%*s%*s%*s%*s%*s(%s)\n",
-			PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "",
-			PKO_PRN_DPLEN(8), lines[2], PKO_PRN_DPLEN(8), lines[3],
-			PKO_PRN_DPLEN(21), "", lines[0]);
 	}
 	if ((queue - 1) != base)
 		cvmx_printf("\nDQ(s) %02d-%02d -- same as DQ %02d\n",
@@ -1646,8 +1798,8 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		base = group;
 		cvmx_printf("Group %d: (%d, %d, %d, %d)\n",
 			group, group * 4, group * 4 + 1, group * 4 + 2, group * 4 + 3);
-		PARPRINT("Size", "%*d\n", PKO_PRN_DPLEN(1), fgcfg.s.size);
-		PARPRINT("Rate", "%*d\n", PKO_PRN_DPLEN(1), fgcfg.s.rate);
+		PARPRINT(4, "Size", "%*d\n", PKO_PRN_DPLEN(1), fgcfg.s.size);
+		PARPRINT(4, "Rate", "%*d\n", PKO_PRN_DPLEN(1), fgcfg.s.rate);
 	}
 	if ((group - 1) != base)
 		cvmx_printf("\nGROUP(s) %02d-%02d -- same as GROUP %02d\n",
@@ -1666,6 +1818,7 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 	cvmx_pko_dqx_bytes_t dq_bytes;
 	cvmx_pko_dqx_dropped_packets_t dq_drppkts;
 	cvmx_pko_dqx_dropped_bytes_t dq_drpbytes;
+	cvmx_pko_dqx_shape_state_t dq_shape_stat;
 	cvmx_pko_l1_sqx_dropped_packets_t l1_drppkts;
 	cvmx_pko_l1_sqx_dropped_bytes_t l1_drpbytes;
 	cvmx_pko_l1_sqx_red_packets_t l1_redpkts;
@@ -1674,6 +1827,9 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 	cvmx_pko_l1_sqx_yellow_bytes_t l1_yelbytes;
 	cvmx_pko_l1_sqx_green_packets_t l1_grnpkts;
 	cvmx_pko_l1_sqx_green_bytes_t l1_grnbytes;
+	cvmx_pko_l1_sqx_topology_t l1top;
+	cvmx_pko_l1_sqx_shape_state_t l1_shape_stat;
+	cvmx_pko_macx_cfg_t maccfg;
 	char lines[4][256];
 
 	memset(lines[3], '*', PKO_PRN_LINELEN);  lines[3][PKO_PRN_LINELEN] = '\0';
@@ -1691,14 +1847,24 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 		if (n == 0)
 			continue;
 		cvmx_printf("DQ%d:\n", queue);
+		dq_shape_stat.u64 = cvmx_read_csr_node(node, CVMX_PKO_DQX_SHAPE_STATE(queue));
+		switch (dq_shape_stat.s.color) {
+		case 0: sprintf(lines[0], "Green"); break;
+		case 1: sprintf(lines[0], "Yellow"); break;
+		case 2: sprintf(lines[0], "Red"); break;
+		default: sprintf(lines[0], "Undef"); break;
+		}
+		PARPRINT(4, "Color", "%*s\n", PKO_PRN_DPLEN(1), lines[0]);
+		PARPRINT(4, "PIR Accum", "%*d\n", PKO_PRN_DPLEN(1), dq_shape_stat.s.pir_accum);
+		PARPRINT(4, "CIR Accum", "%*d\n", PKO_PRN_DPLEN(1), dq_shape_stat.s.cir_accum);
 		if (dq_pkts.s.count)
-			PARPRINT("Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_pkts.s.count);
+			PARPRINT(4, "Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_pkts.s.count);
 		if (dq_bytes.s.count)
-			PARPRINT("Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_bytes.s.count);
+			PARPRINT(4, "Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_bytes.s.count);
 		if (dq_drppkts.s.count)
-			PARPRINT("Dropped Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_drppkts.s.count);
+			PARPRINT(4, "Dropped Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_drppkts.s.count);
 		if (dq_drpbytes.s.count)
-			PARPRINT("Dropped Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_drpbytes.s.count);
+			PARPRINT(4, "Dropped Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_drpbytes.s.count);
 	}
 	DLMPRINT("Port(L1) Queues:");
 	nqueues = cvmx_pko3_num_level_queues(CVMX_PKO_PORT_QUEUES);
@@ -1713,23 +1879,35 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 			l1_redpkts.s.count + l1_redbytes.s.count + l1_drppkts.s.count + l1_drpbytes.s.count;
 		if (n == 0)
 			continue;
-		cvmx_printf("L1-SQ%d:\n", queue);
+
+		l1_shape_stat.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_SHAPE_STATE(queue));
+		l1top.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_TOPOLOGY(queue));
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+			sprintf(lines[0], "%s", pko_macmap[l1top.s.link][0]);
+		else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+			sprintf(lines[0], "%s", pko_macmap[l1top.s.link][1]);
+		else if (OCTEON_IS_MODEL(OCTEON_CNF75XX))
+			sprintf(lines[0], "%s", pko_macmap[l1top.s.link][2]);
+		maccfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(l1top.s.link));
+		cvmx_printf("L1-SQ%d => MAC%d (%s) => FIFO%d:\n", queue, l1top.s.link, lines[0], maccfg.s.fifo_num);
+		PARPRINT(4, "Color", "%*s\n", PKO_PRN_DPLEN(1), (l1_shape_stat.s.color == 0) ? "Green" : "Red");
+		PARPRINT(4, "CIR Accum", "%*d\n", PKO_PRN_DPLEN(1), l1_shape_stat.s.cir_accum);
 		if (l1_grnpkts.s.count)
-			PARPRINT("Green Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_grnpkts.s.count);
+			PARPRINT(4, "Green Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_grnpkts.s.count);
 		if (l1_grnbytes.s.count)
-			PARPRINT("Green Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_grnbytes.s.count);
+			PARPRINT(4, "Green Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_grnbytes.s.count);
 		if (l1_yelpkts.s.count)
-			PARPRINT("Yellow Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_yelpkts.s.count);
+			PARPRINT(4, "Yellow Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_yelpkts.s.count);
 		if (l1_yelbytes.s.count)
-			PARPRINT("Yellow Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_yelbytes.s.count);
+			PARPRINT(4, "Yellow Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_yelbytes.s.count);
 		if (l1_redpkts.s.count)
-			PARPRINT("Red Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_redpkts.s.count);
+			PARPRINT(4, "Red Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_redpkts.s.count);
 		if (l1_redbytes.s.count)
-			PARPRINT("Red Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_redbytes.s.count);
+			PARPRINT(4, "Red Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_redbytes.s.count);
 		if (l1_drppkts.s.count)
-			PARPRINT("Dropped Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_drppkts.s.count);
+			PARPRINT(4, "Dropped Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_drppkts.s.count);
 		if (l1_drpbytes.s.count)
-			PARPRINT("Dropped Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_drpbytes.s.count);
+			PARPRINT(4, "Dropped Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_drpbytes.s.count);
 	}
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 68d9bc0..1beaae0 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -171,7 +171,7 @@ static const struct ipd_port_map ipd_port_map_73xx[CVMX_HELPER_MAX_IFACE] = {
 	{GMII,	0x800,	0x83f,	0x00},		/* Interface 0 - BGX(0,0-3) */
 	{GMII,	0x900,	0x93f,	0x00},		/* Interface 1  -BGX(1,0-3) */
 	{GMII,	0xa00,	0xa3f,	0x00},		/* Interface 2  -BGX(2,0-3) */
-	{NPI,	0x100,	0x13f,	0x00},		/* Interface 3 - DPI */
+	{NPI,	0x100,	0x17f,	0x00},		/* Interface 3 - DPI */
 	{LB,	0x000,	0x03f,	0x00},		/* Interface 4 - LOOPBACK */
 };
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index 9213adf..b56104c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -946,7 +946,7 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn73xx(int xiface)
 
 		switch (qlm_mode) {
 		case CVMX_QLM_MODE_SGMII:
-		case CVMX_QLM_MODE_SGMII_1X2:
+		case CVMX_QLM_MODE_SGMII_2X1:
 		case CVMX_QLM_MODE_RGMII_SGMII:
 		case CVMX_QLM_MODE_RGMII_SGMII_1X1:
 			iface_ops[interface] = &iface_ops_bgx_sgmii;
@@ -1023,7 +1023,7 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cnf75xx(int xiface)
 
 		switch (qlm_mode) {
 		case CVMX_QLM_MODE_SGMII:
-		case CVMX_QLM_MODE_SGMII_1X2:
+		case CVMX_QLM_MODE_SGMII_2X1:
 			iface_ops[interface] = &iface_ops_bgx_sgmii;
 			break;
 		case CVMX_QLM_MODE_XFI_1X2:
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki.c b/arch/mips/cavium-octeon/executive/cvmx-pki.c
index 2e0a20a..eb40e3d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki.c
@@ -759,7 +759,7 @@ int cvmx_pki_enable_aura_qos(int node, int aura, bool ena_red,
  */
 int cvmx_pki_write_aura_bpid(int node, int aura, int bpid)
 {
-	int i, cnt;
+	int i, cnt, ena_bp;
 	cvmx_pki_aurax_cfg_t pki_aura_cfg;
 
 	if (aura >= CVMX_PKI_NUM_AURA || bpid >= CVMX_PKI_NUM_BPID) {
@@ -767,12 +767,17 @@ int cvmx_pki_write_aura_bpid(int node, int aura, int bpid)
 		return -1;
 	}
 	if(OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-		/* Errata PKI-24364.
-		 * Workaround: Inform about assigning the same bpid to multiple auras.
+		/* Workaround for Errata PKI-24364:
+		 * Inform about assigning the same BPID to multiple auras
+		 * having different ENA_BP.
 		 */
+		pki_aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(aura));
+		ena_bp = pki_aura_cfg.s.ena_bp;
 		for (i = 0, cnt = 1; i < CVMX_PKI_NUM_AURA; i++) {
+			if (i == aura)
+				continue;
 			pki_aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(i));
-			if (pki_aura_cfg.s.bpid == bpid && i != aura)
+			if (pki_aura_cfg.s.bpid == bpid && pki_aura_cfg.s.ena_bp != ena_bp)
 				cnt++;
 		}
 		if (cnt > 1)
@@ -1380,6 +1385,9 @@ int cvmx_pki_config_dump(unsigned node)
 		NSPRINT(nclusters, __i, sprintf(lines[__i], "Cluster%d", __i));
 		NMPRINT(nclusters, mask, __i, 0, "", "%*s", lines[__i]);
 		NMPRINT(nclusters, mask, __i, 0, "Strip FCS", "%*s", stcfg[__i].s.fcs_strip ? "Yes":"No");
+		NMPRINT(nclusters, mask, __i, 0, "Drop", "%*d", stcfg[__i].s.drop);
+		NMPRINT(nclusters, mask, __i, 0, "No Drop", "%*d", stcfg[__i].s.nodrop);
+		NMPRINT(nclusters, mask, __i, 0, "Raw Drop", "%*d", stcfg[__i].s.rawdrp);
 		cvmx_printf("Tag:\n");
 		NMPRINT(nclusters, mask, __i, 1, "Tag Type", "%*s", tagtype_map[stalg[__i].s.tt]);
 		if (NMCMPEQ(0, ((stcfg2[__i].u64 >> 18) & 0x3F), 4, mask, __i) != 0) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 90e7e07..7f5d570 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -1139,6 +1139,165 @@ cvmx_pko3_port_fifo_size(unsigned int xiface, unsigned index)
 }
 EXPORT_SYMBOL(cvmx_pko3_port_fifo_size);
 
+/**
+ * @INTERNAL
+ *
+ * Stop an interface port transmission and wait until its FIFO is emopty.
+ *
+ */
+int cvmx_pko3_port_xoff(unsigned int xiface, unsigned index)
+{
+	cvmx_pko_l1_sqx_topology_t pko_l1_topology;
+	cvmx_pko_l1_sqx_sw_xoff_t pko_l1_xoff;
+	cvmx_pko_ptfx_status_t pko_ptfx_status;
+	cvmx_pko_macx_cfg_t pko_mac_cfg;
+	cvmx_pko_mci1_cred_cntx_t cred_cnt;
+	unsigned node, pq, num_pq, mac_num, fifo_num;
+	int ret;
+	cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
+
+	node = xi.node;
+	ret = __cvmx_pko3_get_mac_num(xiface, index);
+
+	if (debug)
+		cvmx_dprintf("%s: iface=%u:%u/%u mac %d\n",
+			__func__, xi.node, xi.interface, index, ret);
+
+	if (ret < 0)
+		return ret;
+
+	mac_num = ret;
+
+	if (mac_num == 0x1f)
+		return 0;
+
+	pko_mac_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(mac_num));
+	fifo_num = pko_mac_cfg.s.fifo_num;
+
+	/* Verify the FIFO number is correct */
+	pko_ptfx_status.u64 = cvmx_read_csr_node(node,
+			CVMX_PKO_PTFX_STATUS(fifo_num));
+
+	if (debug)
+		cvmx_dprintf("%s: mac %d fifo %d, fifo mac %d\n",
+		__func__, mac_num, fifo_num, pko_ptfx_status.s.mac_num);
+
+	cvmx_warn_if (pko_ptfx_status.s.mac_num != mac_num,
+		"PKO3 FIFO number does not match MAC\n");
+
+	num_pq = cvmx_pko3_num_level_queues(CVMX_PKO_PORT_QUEUES);
+	/* Fint the L1/PQ connected to the MAC for this interface */
+	for (pq = 0; pq < num_pq; pq ++) {
+		pko_l1_topology.u64 = cvmx_read_csr_node(node,
+			CVMX_PKO_L1_SQX_TOPOLOGY(pq));
+		if (pko_l1_topology.s.link == mac_num)
+			break;
+	}
+
+
+	if (debug)
+		cvmx_dprintf("%s: L1_PQ%u LINK %d MAC_NUM %d\n",
+			__func__, pq, pko_l1_topology.s.link, mac_num);
+
+	if (pq >= num_pq)
+		return -1;
+
+	if (debug) {
+		pko_ptfx_status.u64 = cvmx_read_csr_node(node,
+			CVMX_PKO_PTFX_STATUS(fifo_num));
+		ret = pko_ptfx_status.s.in_flight_cnt;
+		cvmx_dprintf("%s: FIFO %d in-flight %d packets\n",
+		    __func__, fifo_num, ret);
+	}
+
+	/* Turn the XOFF bit on */
+	pko_l1_xoff.u64 = cvmx_read_csr_node(node,
+		CVMX_PKO_L1_SQX_SW_XOFF(pq));
+	pko_l1_xoff.s.xoff = 1;
+	cvmx_write_csr_node(node,
+		CVMX_PKO_L1_SQX_SW_XOFF(pq), pko_l1_xoff.u64);
+
+	ret = 1 << 22;
+	/* Wait for PKO TX FIFO to drain */
+	do {
+		CVMX_SYNC;
+		pko_ptfx_status.u64 = cvmx_read_csr_node(node,
+			CVMX_PKO_PTFX_STATUS(fifo_num));
+	} while (pko_ptfx_status.s.in_flight_cnt != 0 && ret--);
+
+	if (pko_ptfx_status.s.in_flight_cnt != 0) {
+		cvmx_warn("%s: FIFO %d failed to drain\n",
+		    __func__, fifo_num);
+	}
+
+	if (debug)
+		cvmx_dprintf("%s: FIFO %d drained in %d cycles\n",
+		    __func__, fifo_num, (1 << 22) - ret);
+
+	/* Wait for MAC TX FIFO to drain. */
+	do {
+		cred_cnt.u64 = cvmx_read_csr_node(node, CVMX_PKO_MCI1_CRED_CNTX(mac_num));
+	} while (cred_cnt.s.cred_cnt != 0);
+
+	return 0;
+}
+
+/**
+ * @INTERNAL
+ *
+ * Resume transmission on an interface port.
+ *
+ */
+int cvmx_pko3_port_xon(unsigned int xiface, unsigned index)
+{
+	cvmx_pko_l1_sqx_topology_t pko_l1_topology;
+	cvmx_pko_l1_sqx_sw_xoff_t pko_l1_xoff;
+	unsigned node, pq, num_pq, mac_num;
+	int ret;
+        cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
+
+	num_pq = cvmx_pko3_num_level_queues(CVMX_PKO_PORT_QUEUES);
+	node = xi.node;
+	ret = __cvmx_pko3_get_mac_num(xiface, index);
+
+	if (debug)
+		cvmx_dprintf("%s: iface=%u:%u/%u mac %d\n",
+			__func__, xi.node, xi.interface, index, ret);
+
+	if (ret < 0)
+		return ret;
+
+	mac_num = ret;
+
+	if (mac_num == 0x1f)
+		return 0;
+
+	/* Fint the L1/PQ connected to the MAC for this interface */
+	for (pq = 0; pq < num_pq; pq ++) {
+		pko_l1_topology.u64 = cvmx_read_csr_node(node,
+			CVMX_PKO_L1_SQX_TOPOLOGY(pq));
+		if (pko_l1_topology.s.link == mac_num)
+			break;
+	}
+
+	if (debug)
+		cvmx_dprintf("%s: L1_PQ%u LINK %d MAC_NUM %d\n",
+			__func__, pq, pko_l1_topology.s.link, mac_num);
+
+	if (pq >= num_pq)
+		return -1;
+
+	/* Turn the XOFF bit off */
+	pko_l1_xoff.u64 = cvmx_read_csr_node(node,
+		CVMX_PKO_L1_SQX_SW_XOFF(pq));
+	ret = pko_l1_xoff.s.xoff;
+	pko_l1_xoff.s.xoff = 0;
+	cvmx_write_csr_node(node,
+		CVMX_PKO_L1_SQX_SW_XOFF(pq), pko_l1_xoff.u64);
+
+	return ret;
+}
+
 /******************************************************************************
 *
 * New PKO3 API - Experimental
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 3e1a572..b93dec6 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 118803 $<hr>
+ * <hr>$Revision: 120751 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1368,6 +1368,7 @@ static enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn6xxx(int qlm)
 void __cvmx_qlm_set_mult(int qlm, int baud_mhz, int old_multiplier)
 {
 	cvmx_gserx_dlmx_mpll_multiplier_t mpll_multiplier;
+	cvmx_gserx_dlmx_ref_clkdiv2_t clkdiv;
 	uint64_t meas_refclock, mult;
 
 	if (!OCTEON_IS_MODEL(OCTEON_CN70XX))
@@ -1382,9 +1383,18 @@ void __cvmx_qlm_set_mult(int qlm, int baud_mhz, int old_multiplier)
 		return;
 	}
 
-	mult = (uint64_t)baud_mhz * 1000000 + (meas_refclock/2);
+	mult = (uint64_t)baud_mhz * 1000000 + (meas_refclock / 2);
 	mult /= meas_refclock;
 
+	/* The baud rate multiplier needs to be adjusted on the CN70XX if
+	 * the reference clock is > 100MHz.
+	 */
+	if (qlm == 0) {
+		clkdiv.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_REF_CLKDIV2(qlm, 0));
+		if (clkdiv.s.ref_clkdiv2)
+			mult *= 2;
+	}
+
 #ifdef CVMX_BUILD_FOR_UBOOT
 	/* For simulator just write the multiplier directly, to make it
 	   faster to boot. */
@@ -1501,9 +1511,11 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 				qlm_mode[node][qlm] = CVMX_QLM_MODE_10G_KR;
 			else
 				qlm_mode[node][qlm] = CVMX_QLM_MODE_XFI;
+#ifndef CVMX_BUILD_FOR_UBOOT
 			pmd_control.s.train_en = 0;
 			cvmx_write_csr_node(node,
 				CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx), pmd_control.u64);
+#endif
 			break;
 		case 4:
 			/* Use training to determine if we're in 40GBASE-KR or XLAUI */
@@ -1511,9 +1523,11 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 				qlm_mode[node][qlm] = CVMX_QLM_MODE_40G_KR4;
 			else
 				qlm_mode[node][qlm] = CVMX_QLM_MODE_XLAUI;
+#ifndef CVMX_BUILD_FOR_UBOOT
 			pmd_control.s.train_en = 0;
 			cvmx_write_csr_node(node,
 				CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx), pmd_control.u64);
+#endif
 			break;
 		default:
 			qlm_mode[node][qlm] = CVMX_QLM_MODE_DISABLED;
@@ -1601,11 +1615,11 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 			} else if (gser1.s.bgx) {
 				start = 0;
 				end = 2;
-				mux = 1;
+				mux = 1;  // BGX2 is using DLM5 only
 			} else if (gser2.s.bgx) {
 				start = 2;
 				end = 4;
-				mux = 2;
+				mux = 2;  // BGX2 is using DLM6 only
 			} else {
 				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
 				return qlm_mode[qlm];
@@ -1623,7 +1637,7 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 		switch(lane_mask) {
 		case 0:
 			if (mux == 1 || mux == 2)
-				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII_1X2;
+				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII_2X1;
 			else
 				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII;
 			break;
@@ -1796,7 +1810,7 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cnf75xx(int qlm)
 		switch(lane_mask) {
 		case 0:
 			if (mux == 1 || mux == 2)
-				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII_1X2;
+				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII_2X1;
 			else
 				qlm_mode[qlm] = CVMX_QLM_MODE_SGMII;
 			break;
@@ -1988,6 +2002,13 @@ int __cvmx_qlm_rx_equalization(int node, int qlm, int lane)
 	cvmx_gserx_spd_t gserx_spd;
 	int fail, gbaud, l;
 	enum cvmx_qlm_mode mode;
+	int max_lanes = 4;
+
+	/* Errata (GSER-20075) GSER(0..13)_BR_RX3_EER[RXT_ERR] is
+	   GSER(0..13)_BR_RX2_EER[RXT_ERR]. Since lanes 2-3 are tied together,
+	   we only do RX equalization on 2 and ignore 3 */
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+		max_lanes = 3;
 
 	/* Don't touch QLMs if it is reset or powered down */
 	phy_ctl.u64 = cvmx_read_csr_node(node, CVMX_GSERX_PHY_CTL(qlm));
@@ -2001,7 +2022,7 @@ int __cvmx_qlm_rx_equalization(int node, int qlm, int lane)
 
 	/* Apply RX Equalization for speed >= 8G */
 	if (qlm < 8) {
-		if (gbaud < 8000)
+		if (gbaud < 6250)
 			return 0;
 	} else { // OCI
 		gserx_spd.u64 = cvmx_read_csr_node(node, CVMX_GSERX_SPD(qlm));
@@ -2025,7 +2046,7 @@ int __cvmx_qlm_rx_equalization(int node, int qlm, int lane)
 
 	fail = 0;
 
-	for (l = 0; l < 4; l++) {
+	for (l = 0; l < max_lanes; l++) {
 		cvmx_gserx_br_rxx_ctl_t rxx_ctl;
 		cvmx_gserx_br_rxx_eer_t rxx_eer;
 
@@ -2045,35 +2066,28 @@ int __cvmx_qlm_rx_equalization(int node, int qlm, int lane)
 	}
 
 	/* Wait for RX equalization to complete */
-	for (l = 0; l < 4; l++) {
+	for (l = 0; l < max_lanes; l++) {
 		cvmx_gserx_br_rxx_eer_t rxx_eer;
+		cvmx_gserx_br_rxx_ctl_t rxx_ctl;
 
 		if ((lane != -1) && (lane != l))
 			continue;
 
 		CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_GSERX_BR_RXX_EER(l, qlm),
-				cvmx_gserx_br_rxx_eer_t, rxt_esv, ==, 1, 100000);
+				cvmx_gserx_br_rxx_eer_t, rxt_esv, ==, 1, 1000000);
 		rxx_eer.u64 = cvmx_read_csr_node(node, CVMX_GSERX_BR_RXX_EER(l, qlm));
+		/* Switch back to hardware control */
+		rxx_ctl.u64 = cvmx_read_csr_node(node, CVMX_GSERX_BR_RXX_CTL(l, qlm));
+		rxx_ctl.s.rxt_swm = 0;
+		cvmx_write_csr_node(node, CVMX_GSERX_BR_RXX_CTL(l, qlm), rxx_ctl.u64);
 		if (!rxx_eer.s.rxt_esv) {
 			//cvmx_dprintf("%d:QLM%d: Lane %d RX equalization timeout\n", node, qlm, lane);
 			fail = 1;
 		}
 	}
 
-	/* Switch back to hardware control */
-	for (l = 0; l < 4; l++) {
-		cvmx_gserx_br_rxx_ctl_t rxx_ctl;
-
-		if ((lane != -1) && (lane != l))
-			continue;
-
-		rxx_ctl.u64 = cvmx_read_csr_node(node, CVMX_GSERX_BR_RXX_CTL(l, qlm));
-		rxx_ctl.s.rxt_swm = 0;
-		cvmx_write_csr_node(node, CVMX_GSERX_BR_RXX_CTL(l, qlm), rxx_ctl.u64);
-	}
-
 	return (fail) ? -1 : 0;
-} 
+}
 
 void cvmx_qlm_display_registers(int qlm)
 {
@@ -2642,7 +2656,7 @@ int cvmx_dump_gser_common_config(unsigned node, unsigned gser, unsigned N)
 	gser_mode = cvmx_qlm_get_mode(gser);
 
 	cvmx_dprintf("/* GSER%d common configuration */\n", gser);
-	
+
 	/* check that only one of the model supported modes is set */
 	cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(gser));
 
@@ -2815,7 +2829,7 @@ int cvmx_dump_gser_common_status(unsigned node, unsigned gser, unsigned N)
 	PRns("GSER mode is", 1, " %s", qlm_mode_name(gser_mode));
 	PRns("GSER Number of Lanes is", 1, "        %1d      ", N);
 	spd_mhz = cvmx_qlm_get_gbaud_mhz_node(node, gser);
-	PRns("GSER%d Speed [MHz] is", 1, "     %5d     ", spd_mhz);
+	PRns("GSER Speed [MHz] is", 1, "     %5d     ", spd_mhz);
 
 	/* GSERX_QLM_STAT */
 	qlm_stat.u64 = cvmx_read_csr_node(node, CVMX_GSERX_QLM_STAT(gser));
@@ -2866,8 +2880,9 @@ int cvmx_dump_gser_config_node(unsigned node, unsigned gser)
 	cvmx_dump_gser_lane_config(node, gser, N);
 	if (cfg.s.pcie)
 		cvmx_dump_gser_pcie_config(node, gser, N);
-	
+
 	else if (OCTEON_IS_MODEL(OCTEON_CN73XX) && cfg.s.sata)
+
 		/* NOTE: 78xx, 76xx and 75xx GSERs do not support SATA */
 		cvmx_dump_gser_sata_config(node, gser, N);
 
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index d0df01e..5d46843 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 116553 $<hr>
+ * <hr>$Revision: 119392 $<hr>
  *
  */
 
@@ -290,6 +290,7 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_SWORDFISH = 72,
 	CVMX_BOARD_TYPE_SFF7800 = 73,	/* Embedded Planet board */
 	CVMX_BOARD_TYPE_WAVE2 = 74,
+	CVMX_BOARD_TYPE_NIAGARA830 = 75,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -432,6 +433,7 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SWORDFISH)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SFF7800)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_WAVE2)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA830)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 71e7cfe..117ef13 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -58,7 +58,7 @@ static inline uint64_t CVMX_BGXX_CMRX_CONFIG(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_CONFIG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -71,7 +71,7 @@ static inline uint64_t CVMX_BGXX_CMRX_INT(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -84,7 +84,7 @@ static inline uint64_t CVMX_BGXX_CMRX_PRT_CBFC_CTL(unsigned long offset, unsigne
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_PRT_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000408ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -97,7 +97,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ADR_CTL(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ADR_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000A0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -110,7 +110,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_DROP(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_DROP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -123,7 +123,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_OFF(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_OFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000090ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -136,7 +136,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_ON(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_ON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000088ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -149,7 +149,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_STATUS(unsigned long offset, unsigne
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000A8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -162,7 +162,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_FIFO_LEN(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000C0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -175,7 +175,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ID_MAP(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ID_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -188,7 +188,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XOFF(unsigned long offset, unsigne
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XOFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000B0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -201,7 +201,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XON(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00000B8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -214,7 +214,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long offset, u
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -227,7 +227,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT0(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -240,7 +240,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT1(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -253,7 +253,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT2(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -266,7 +266,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT3(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -279,7 +279,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT4(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -292,7 +292,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT5(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -305,7 +305,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT6(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -318,7 +318,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT7(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -331,7 +331,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT8(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -344,7 +344,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_WEIGHT(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_WEIGHT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000098ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -357,7 +357,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_CHANNEL(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_CHANNEL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000400ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -370,7 +370,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_FIFO_LEN(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000418ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -383,7 +383,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_HG2_STATUS(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_HG2_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000410ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -396,7 +396,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_OVR_BP(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_OVR_BP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000420ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -409,7 +409,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT0(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000508ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -422,7 +422,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT1(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000510ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -435,7 +435,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT10(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT10(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000558ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -448,7 +448,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT11(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT11(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000560ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -461,7 +461,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT12(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT12(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000568ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -474,7 +474,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT13(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT13(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000570ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -487,7 +487,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT14(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT14(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000578ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -500,7 +500,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT15(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT15(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000580ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -513,7 +513,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT16(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT16(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000588ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -526,7 +526,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT17(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT17(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000590ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -539,7 +539,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT2(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000518ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -552,7 +552,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT3(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000520ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -565,7 +565,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT4(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000528ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -578,7 +578,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT5(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000530ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -591,7 +591,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT6(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000538ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -604,7 +604,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT7(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000540ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -617,7 +617,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT8(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000548ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -630,7 +630,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT9(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT9(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000550ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -643,7 +643,7 @@ static inline uint64_t CVMX_BGXX_CMR_BAD(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_BAD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0001020ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -656,7 +656,7 @@ static inline uint64_t CVMX_BGXX_CMR_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000300ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -669,7 +669,7 @@ static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_AND(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_AND(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000200ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -682,7 +682,7 @@ static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_OR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_OR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -695,7 +695,7 @@ static inline uint64_t CVMX_BGXX_CMR_ECO(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_ECO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0001028ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -708,7 +708,7 @@ static inline uint64_t CVMX_BGXX_CMR_GLOBAL_CONFIG(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_GLOBAL_CONFIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -721,7 +721,7 @@ static inline uint64_t CVMX_BGXX_CMR_MEM_CTRL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_MEM_CTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000018ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -734,7 +734,7 @@ static inline uint64_t CVMX_BGXX_CMR_MEM_INT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_MEM_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000010ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -747,7 +747,7 @@ static inline uint64_t CVMX_BGXX_CMR_NXC_ADR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_NXC_ADR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0001018ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -760,7 +760,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_ADRX_CAM(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 31)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 31)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 31)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 31)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_ADRX_CAM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0000100ull) + (((offset) & 31) + ((block_id) & 7) * 0x200000ull) * 8;
 }
@@ -773,7 +773,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_LMACS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_LMACS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000308ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -786,7 +786,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_OVR_BP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_OVR_BP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0000318ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -799,7 +799,7 @@ static inline uint64_t CVMX_BGXX_CMR_TX_LMACS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_TX_LMACS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0001000ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -812,7 +812,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_PRTX_CFG(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_PRTX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -825,7 +825,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_DECISION(unsigned long offset, unsi
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -838,7 +838,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -851,7 +851,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -864,7 +864,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_IFG(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -877,7 +877,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_INT(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -890,7 +890,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_JABBER(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -903,7 +903,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -916,7 +916,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_SMACX(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_SMACX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038230ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -929,7 +929,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_APPEND(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -942,7 +942,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_BURST(unsigned long offset, unsigne
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_BURST(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038228ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -955,7 +955,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_CTL(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038270ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -968,7 +968,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_INT(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038500ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -981,7 +981,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038240ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -994,7 +994,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long of
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038248ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1007,7 +1007,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long offset
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038238ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1020,7 +1020,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long offset, un
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038258ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1033,7 +1033,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long offset, un
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038260ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1046,7 +1046,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long offset, uns
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038300ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1059,7 +1059,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SLOT(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SLOT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038220ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1072,7 +1072,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long offset, un
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038250ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1085,7 +1085,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_THRESH(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0038210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1098,7 +1098,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039010ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -1111,7 +1111,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_IFG(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_IFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039000ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -1124,7 +1124,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_JAM(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_JAM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039008ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -1137,7 +1137,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_LFSR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_LFSR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039028ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -1150,7 +1150,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039018ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -1163,7 +1163,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0039020ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -1176,7 +1176,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_ADV(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1189,7 +1189,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_EXT_ST(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_EXT_ST(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1202,7 +1202,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1215,7 +1215,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_RESULTS(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_RESULTS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1228,7 +1228,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_INTX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_INTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1241,7 +1241,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_LINKX_TIMER(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_LINKX_TIMER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1254,7 +1254,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MISCX_CTL(unsigned long offset, unsigne
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MISCX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1267,7 +1267,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_CONTROL(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1280,7 +1280,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_STATUS(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1293,7 +1293,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_STATES(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1306,7 +1306,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_SYNC(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_SYNC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1319,7 +1319,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1332,7 +1332,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1345,7 +1345,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TXX_STATES(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1358,7 +1358,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long offset, u
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0030048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1371,7 +1371,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CBFC_CTL(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1384,7 +1384,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CTRL(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020200ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1397,7 +1397,7 @@ static inline uint64_t CVMX_BGXX_SMUX_EXT_LOOPBACK(unsigned long offset, unsigne
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_EXT_LOOPBACK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020208ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1410,7 +1410,7 @@ static inline uint64_t CVMX_BGXX_SMUX_HG2_CONTROL(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_HG2_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020210ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1423,7 +1423,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_HI(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_HI(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1436,7 +1436,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_LO(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_LO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1449,7 +1449,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_CTL(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1462,7 +1462,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_DECISION(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1475,7 +1475,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CHK(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1488,7 +1488,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CTL(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1501,7 +1501,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_INT(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1514,7 +1514,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_JABBER(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1527,7 +1527,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_UDD_SKP(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1540,7 +1540,7 @@ static inline uint64_t CVMX_BGXX_SMUX_SMAC(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_SMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020108ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1553,7 +1553,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_APPEND(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020100ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1566,7 +1566,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_CTL(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020160ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1579,7 +1579,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_IFG(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020148ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1592,7 +1592,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_INT(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020140ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1605,7 +1605,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_MIN_PKT(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020118ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1618,7 +1618,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long offset, un
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020150ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1631,7 +1631,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long offset
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020120ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1644,7 +1644,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long offset, un
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020110ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1657,7 +1657,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long offset, un
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020158ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1670,7 +1670,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_TOGO(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020130ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1683,7 +1683,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_ZERO(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020138ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1696,7 +1696,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_SOFT_PAUSE(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020128ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1709,7 +1709,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_THRESH(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0020168ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1722,7 +1722,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_ADV(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100D8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1735,7 +1735,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_BP_STATUS(unsigned long offset, unsigne
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100F8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1748,7 +1748,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_CONTROL(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100C8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1761,7 +1761,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_BASE(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_BASE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100E0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1774,7 +1774,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_XNP(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_XNP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100F0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1787,7 +1787,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_STATUS(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100D0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1800,7 +1800,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_XNP_TX(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_XNP_TX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100E8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1813,7 +1813,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_ALGN_STATUS(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_ALGN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010050ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1826,7 +1826,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010058ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1839,7 +1839,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_LANE_MAP(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_LANE_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010060ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1852,7 +1852,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_CONTROL(unsigned long offset, unsig
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010068ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1865,7 +1865,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_CUP(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010088ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1878,7 +1878,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_REP(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010090ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1891,7 +1891,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_CUP(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010078ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1904,7 +1904,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_REP(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010080ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1917,7 +1917,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_STATUS(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010070ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1930,7 +1930,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS1(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010030ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1943,7 +1943,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS2(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010038ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1956,7 +1956,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_CONTROL(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010040ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1969,7 +1969,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_ERR_CNT(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010048ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1982,7 +1982,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BX_STATUS(unsigned long offset, unsigned l
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010028ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -1995,7 +1995,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL1(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010000ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2008,7 +2008,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL2(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010018ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2021,7 +2021,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_ABIL(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010098ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2034,7 +2034,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CONTROL(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100A0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2047,7 +2047,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS01(unsigned long offset, unsi
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100A8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2060,7 +2060,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS23(unsigned long offset, unsi
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100B0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2073,7 +2073,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(unsigned long offset, un
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100B8ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2086,7 +2086,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(unsigned long offset, un
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E00100C0ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2099,7 +2099,7 @@ static inline uint64_t CVMX_BGXX_SPUX_INT(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010220ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2112,7 +2112,7 @@ static inline uint64_t CVMX_BGXX_SPUX_LPCS_STATES(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_LPCS_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010208ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2125,7 +2125,7 @@ static inline uint64_t CVMX_BGXX_SPUX_MISC_CONTROL(unsigned long offset, unsigne
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_MISC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010218ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2138,7 +2138,7 @@ static inline uint64_t CVMX_BGXX_SPUX_SPD_ABIL(unsigned long offset, unsigned lo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_SPD_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010010ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2151,7 +2151,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS1(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010008ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2164,7 +2164,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS2(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010020ull) + (((offset) & 3) + ((block_id) & 7) * 0x10ull) * 1048576;
 }
@@ -2177,7 +2177,7 @@ static inline uint64_t CVMX_BGXX_SPU_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_SPU_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0010318ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -2190,7 +2190,7 @@ static inline uint64_t CVMX_BGXX_SPU_DBG_CONTROL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_SPU_DBG_CONTROL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0010300ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -2203,7 +2203,7 @@ static inline uint64_t CVMX_BGXX_SPU_MEM_INT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_SPU_MEM_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0010310ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -2216,7 +2216,7 @@ static inline uint64_t CVMX_BGXX_SPU_MEM_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_SPU_MEM_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800E0010308ull) + ((offset) & 7) * 0x1000000ull;
 }
@@ -2229,7 +2229,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_SKEW_STATUS(unsigned long offset, unsi
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_SKEW_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010320ull) + (((offset) & 3) + ((block_id) & 7) * 0x200000ull) * 8;
 }
@@ -2242,7 +2242,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800E0010340ull) + (((offset) & 3) + ((block_id) & 7) * 0x200000ull) * 8;
 }
@@ -2325,7 +2325,7 @@ union cvmx_bgxx_cmrx_config {
                                                          LMACs 2 and 3. Setting it will pipe the LMAC to and from the MIX interface (LMAC0 to/from
                                                          MIX0, LMAC1 to/from MIX1). LMAC_TYPE must be 0 (SGMII) then this bit is set. Note that at
                                                          most one BGX can be attached to each of MIX0 and MIX1, i.e. at most one
-                                                         BGX(0..2)_CMR(0)_CONFIG[MIX_EN] bit and one BGX(0..2)_CMR(1)_CONFIG[MIX_EN] bit can be
+                                                         BGX(0)_CMR(0)_CONFIG[MIX_EN] bit and one BGX(0)_CMR(1)_CONFIG[MIX_EN] bit can be
                                                          set.
                                                          This field must be programmed to its final value before [ENABLE] is set, and must not
                                                          be changed when [ENABLE]=1. */
@@ -3883,10 +3883,10 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
                                                          any of the four SGMII MACs or the 10G/40G MACs using these register bits.
                                                          A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                          using the following settings:
-                                                         * LMAC interface 0: BGX(0..2)_CMR_RX_ADR(0..7)_CAM[ID] = 0x0.
-                                                         * LMAC interface 1: BGX(0..2)_CMR_RX_ADR(8..15)_CAM[ID] = 0x1.
-                                                         * LMAC interface 2: BGX(0..2)_CMR_RX_ADR(16..23)_CAM[ID] = 0x2.
-                                                         * LMAC interface 3: BGX(0..2)_CMR_RX_ADR(24..31)_CAM[ID] = 0x3. */
+                                                         * LMAC interface 0: BGX(0)_CMR_RX_ADR(0..7)_CAM[ID] = 0x0.
+                                                         * LMAC interface 1: BGX(0)_CMR_RX_ADR(8..15)_CAM[ID] = 0x1.
+                                                         * LMAC interface 2: BGX(0)_CMR_RX_ADR(16..23)_CAM[ID] = 0x2.
+                                                         * LMAC interface 3: BGX(0)_CMR_RX_ADR(24..31)_CAM[ID] = 0x3. */
 	uint64_t reserved_49_51               : 3;
 	uint64_t en                           : 1;  /**< CAM entry enable for this DMAC address.
                                                          1 = Include this address in the matching algorithm.
@@ -4258,7 +4258,7 @@ union cvmx_bgxx_gmp_gmi_rxx_ifg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t ifg                          : 4;  /**< Min IFG (in IFG * 8 bits) between packets used to determine IFGERR. Normally IFG is 96
-                                                         bits.
+                                                         bits. Values 0x1 or smaller are illegal.
                                                          Note that in some operating modes, IFG cycles can be inserted or removed in order to
                                                          achieve clock rate adaptation. For these reasons, the default value is slightly
                                                          conservative and does not check up to the full 96 bits of IFG.
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index 5e7b63c..3c18811 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -3886,7 +3886,8 @@ union cvmx_ciu_fuse {
 	struct cvmx_ciu_fuse_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t fuse                         : 48; /**< Each bit set indicates a physical core is present. */
+	uint64_t fuse                         : 48; /**< Each bit set indicates a physical core is present. FUSE bits <15..0> correspond to PP core
+                                                         PP15, 14, 13 ... 2, 1, 0. */
 #else
 	uint64_t fuse                         : 48;
 	uint64_t reserved_48_63               : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index bc9d2c6..f04deb3 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -618,6 +618,28 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR_INFO(unsigned long offset)
 #define CVMX_DPI_SLI_PRTX_ERR_INFO(offset) (CVMX_ADD_IO_SEG(0x0001DF0000000940ull) + ((offset) & 3) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DPI_SRIO_RX_BELLX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_DPI_SRIO_RX_BELLX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001DF0000080200ull) + ((offset) & 31) * 8;
+}
+#else
+#define CVMX_DPI_SRIO_RX_BELLX(offset) (CVMX_ADD_IO_SEG(0x0001DF0000080200ull) + ((offset) & 31) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DPI_SRIO_RX_BELL_SEQX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
+		cvmx_warn("CVMX_DPI_SRIO_RX_BELL_SEQX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001DF0000080400ull) + ((offset) & 31) * 8;
+}
+#else
+#define CVMX_DPI_SRIO_RX_BELL_SEQX(offset) (CVMX_ADD_IO_SEG(0x0001DF0000080400ull) + ((offset) & 31) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_DPI_SWA_Q_VMID CVMX_DPI_SWA_Q_VMID_FUNC()
 static inline uint64_t CVMX_DPI_SWA_Q_VMID_FUNC(void)
 {
@@ -3448,6 +3470,71 @@ union cvmx_dpi_sli_prtx_err_info {
 typedef union cvmx_dpi_sli_prtx_err_info cvmx_dpi_sli_prtx_err_info_t;
 
 /**
+ * cvmx_dpi_srio_rx_bell#
+ *
+ * Reading this register pops an entry off the corresponding SRIO RX doorbell FIFO.
+ * The chip supports 16 FIFOs per SRIO interface for a total of 32 FIFOs/Registers.
+ * The MSB of the registers indicates the MAC while the 4 LSBs indicate the FIFO.
+ * Information on the doorbell allocation can be found in SRIO()_RX_BELL_CTRL.
+ */
+union cvmx_dpi_srio_rx_bellx {
+	uint64_t u64;
+	struct cvmx_dpi_srio_rx_bellx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t data                         : 16; /**< Information field from received doorbell. */
+	uint64_t sid                          : 16; /**< Doorbell source device ID <15:0>. */
+	uint64_t count                        : 8;  /**< RX bell FIFO count.
+                                                         Count must be > 0x0 for entry to be valid. */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t dest_id                      : 1;  /**< Destination device ID. 0=Primary, 1=Secondary. */
+	uint64_t id16                         : 1;  /**< Transaction type. 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t dpriority                    : 2;  /**< Doorbell priority. */
+#else
+	uint64_t dpriority                    : 2;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t id16                         : 1;
+	uint64_t dest_id                      : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t count                        : 8;
+	uint64_t sid                          : 16;
+	uint64_t data                         : 16;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_dpi_srio_rx_bellx_s       cnf75xx;
+};
+typedef union cvmx_dpi_srio_rx_bellx cvmx_dpi_srio_rx_bellx_t;
+
+/**
+ * cvmx_dpi_srio_rx_bell_seq#
+ *
+ * This register contains the value of the sequence counter when the doorbell
+ * was received and a shadow copy of the Bell FIFO Count that can be read without
+ * emptying the FIFO.  This register must be read prior to corresponding
+ * DPI_SRIO_RX_BELL register to link the doorbell and sequence number.
+ *
+ * Information on the Doorbell Allocation can be found in SRIO()_RX_BELL_CTRL.
+ */
+union cvmx_dpi_srio_rx_bell_seqx {
+	uint64_t u64;
+	struct cvmx_dpi_srio_rx_bell_seqx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t count                        : 8;  /**< FIFO count. */
+	uint64_t sid                          : 32; /**< Sequence. */
+#else
+	uint64_t sid                          : 32;
+	uint64_t count                        : 8;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} s;
+	struct cvmx_dpi_srio_rx_bell_seqx_s   cnf75xx;
+};
+typedef union cvmx_dpi_srio_rx_bell_seqx cvmx_dpi_srio_rx_bell_seqx_t;
+
+/**
  * cvmx_dpi_swa_q_vmid
  *
  * Not used.
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
index 1c56e0b..8541b37 100644
--- a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -391,7 +391,7 @@ static inline uint64_t CVMX_DTX_BGXX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DTX_BGXX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE700080ull) + ((offset) & 7) * 32768;
 }
@@ -404,7 +404,7 @@ static inline uint64_t CVMX_DTX_BGXX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DTX_BGXX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE700060ull) + ((offset) & 7) * 32768;
 }
@@ -417,7 +417,7 @@ static inline uint64_t CVMX_DTX_BGXX_DATX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_BGXX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
 }
@@ -430,7 +430,7 @@ static inline uint64_t CVMX_DTX_BGXX_ENAX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_BGXX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
 }
@@ -443,7 +443,7 @@ static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_BGXX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE700000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
 }
@@ -1116,7 +1116,7 @@ static inline uint64_t CVMX_DTX_GSERX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 6)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_DTX_GSERX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE480080ull) + ((offset) & 15) * 32768;
 }
@@ -1129,7 +1129,7 @@ static inline uint64_t CVMX_DTX_GSERX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 6)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_DTX_GSERX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE480060ull) + ((offset) & 15) * 32768;
 }
@@ -1142,7 +1142,7 @@ static inline uint64_t CVMX_DTX_GSERX_DATX(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_DTX_GSERX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480040ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
 }
@@ -1155,7 +1155,7 @@ static inline uint64_t CVMX_DTX_GSERX_ENAX(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_DTX_GSERX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480020ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
 }
@@ -1168,7 +1168,7 @@ static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_DTX_GSERX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE480000ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index e3eca6f..342c855 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -1069,7 +1069,7 @@ union cvmx_fpa_aurax_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t thresh                       : 1;  /**< Watermark interrupt pending. Set and throws FPA_INTSN_E::FPA_AURA()_THRESH when
-                                                         FPA_AURA()_INT, after being modified, is equal to or crosses
+                                                         FPA_AURA()_CNT, after being modified, is equal to or crosses
                                                          FPA_AURA()_CNT_THRESHOLD (i.e. value was greater than, then becomes less then, or
                                                          value was less than, and becomes greater than). */
 #else
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa.h b/arch/mips/include/asm/octeon/cvmx-fpa.h
index b8b43d8..e892dcc 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa.h
@@ -42,7 +42,7 @@
  *
  * Interface to the hardware Free Pool Allocator.
  *
- * <hr>$Revision: 113385 $<hr>
+ * <hr>$Revision: 120123 $<hr>
  *
  */
 
@@ -89,26 +89,6 @@ typedef struct cvmx_fpa_pool_config cvmx_fpa_pool_config_t;
 const char *cvmx_fpa_get_name(int pool_num);
 
 /**
- * Return the base of the pool
- *
- * @param pool   Pool to get the base of
- * @return The base
- */
-void *cvmx_fpa_get_base(int pool);
-
-/**
- * Check if a pointer belongs to an FPA pool. Return non-zero
- * if the supplied pointer is inside the memory controlled by
- * an FPA pool.
- *
- * @param pool   Pool to check
- * @param ptr    Pointer to check
- * @return Non-zero if pointer is in the pool. Zero if not
- */
-int cvmx_fpa_is_member(int pool, void *ptr);
-
-
-/**
  * Initialize FPA per node
  */
 int cvmx_fpa_global_init_node(int node);
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa1.h b/arch/mips/include/asm/octeon/cvmx-fpa1.h
index 73df32e..b8c6b6e 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa1.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa1.h
@@ -43,7 +43,7 @@
  * Interface to the hardware Free Pool Allocator on Octeon chips.
  * These are the legacy models, i.e. prior to CN78XX/CN76XX.
  *
- * <hr>$Revision: 115744 $<hr>
+ * <hr>$Revision: 120123 $<hr>
  *
  */
 
@@ -71,15 +71,6 @@ typedef	int cvmx_fpa1_pool_t;
 #define CVMX_FPA1_INVALID_POOL ((cvmx_fpa1_pool_t)-1)
 #define	CVMX_FPA1_NAME_SIZE	16
 
-/* FIXME: To be reworked for named blocks */
-typedef struct {
-	char name[CVMX_FPA1_NAME_SIZE];
-/*	uint64_t buffer_size; */
-	uint64_t size; /* Block size of pool buffers */
-	uint64_t buffer_count;
-	uint64_t base_paddr; /* Base of buffer is allocated at initialization */
-} cvmx_fpa1_pool_info_t;
-
 /**
  * Structure describing the data format used for stores to the FPA.
  */
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 2f6f6b0..c7578b8 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -535,6 +535,17 @@ static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long offset)
 #define CVMX_GSERX_EQ_WAIT_TIME(offset) (CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_3(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_3(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460018ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_GLBL_PLL_CFG_3(offset) (CVMX_ADD_IO_SEG(0x0001180090460018ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_GLBL_PLL_MONITOR(unsigned long offset)
 {
 	if (!(
@@ -694,7 +705,9 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_2(unsigned long offset, unsig
 static inline uint64_t CVMX_GSERX_LANEX_PCS_MACIFC_MON_2(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_MACIFC_MON_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800904C0118ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
 }
@@ -2398,7 +2411,7 @@ union cvmx_gserx_br_rxx_ctl {
 	uint64_t reserved_3_63                : 61;
 #endif
 	} cn78xx;
-	struct cvmx_gserx_br_rxx_ctl_cn78xx   cn78xxp2;
+	struct cvmx_gserx_br_rxx_ctl_s        cn78xxp2;
 	struct cvmx_gserx_br_rxx_ctl_s        cnf75xx;
 };
 typedef union cvmx_gserx_br_rxx_ctl cvmx_gserx_br_rxx_ctl_t;
@@ -3538,6 +3551,49 @@ union cvmx_gserx_eq_wait_time {
 typedef union cvmx_gserx_eq_wait_time cvmx_gserx_eq_wait_time_t;
 
 /**
+ * cvmx_gser#_glbl_pll_cfg_3
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_glbl_pll_cfg_3 {
+	uint64_t u64;
+	struct cvmx_gserx_glbl_pll_cfg_3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t pcs_sds_pll_vco_amp          : 2;  /**< Adjusts the VCO amplitude control current.
+                                                         For diagnostic use only.
+                                                         0x0 = Add 25 uA.
+                                                         0x1 = OFF (default).
+                                                         0x2 = Sink 25uA.
+                                                         0x3 = Sink 50uA. */
+	uint64_t pll_bypass_uq                : 1;  /**< PLL bypass enable. When asserted, multiplexes in the feedback divider clock.
+                                                         For diagnostic use only. */
+	uint64_t pll_vctrl_sel_ovrrd_en       : 1;  /**< Override enable for selecting current for Vctrl in open loop operation.
+                                                         For diagnostic use only. */
+	uint64_t pll_vctrl_sel_ovrrd_val      : 2;  /**< Override value for selecting current for Vctrl in open loop operation.
+                                                         For diagnostic use only. */
+	uint64_t pll_vctrl_sel_lcvco_val      : 2;  /**< Selects current for Vctrl in open loop operation for LC-tank VCO.
+                                                         For diagnostic use only. */
+	uint64_t pll_vctrl_sel_rovco_val      : 2;  /**< Selects current for Vctrl in open loop operation for ring oscillator VCO.
+                                                         For diagnostic use only. */
+#else
+	uint64_t pll_vctrl_sel_rovco_val      : 2;
+	uint64_t pll_vctrl_sel_lcvco_val      : 2;
+	uint64_t pll_vctrl_sel_ovrrd_val      : 2;
+	uint64_t pll_vctrl_sel_ovrrd_en       : 1;
+	uint64_t pll_bypass_uq                : 1;
+	uint64_t pcs_sds_pll_vco_amp          : 2;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_gserx_glbl_pll_cfg_3_s    cn78xx;
+	struct cvmx_gserx_glbl_pll_cfg_3_s    cn78xxp2;
+};
+typedef union cvmx_gserx_glbl_pll_cfg_3 cvmx_gserx_glbl_pll_cfg_3_t;
+
+/**
  * cvmx_gser#_glbl_pll_monitor
  *
  * These registers are for diagnostic use only.
@@ -3695,7 +3751,7 @@ union cvmx_gserx_glbl_tm_admon {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_glbl_tm_admon_s     cn78xx;
-	struct cvmx_gserx_glbl_tm_admon_s     cn78xxp2;
+	struct cvmx_gserx_glbl_tm_admon_cn73xx cn78xxp2;
 	struct cvmx_gserx_glbl_tm_admon_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_glbl_tm_admon cvmx_gserx_glbl_tm_admon_t;
@@ -3969,7 +4025,7 @@ union cvmx_gserx_lanex_misc_cfg_1 {
 	uint64_t reserved_13_63               : 51;
 #endif
 	} cn73xx;
-	struct cvmx_gserx_lanex_misc_cfg_1_cn73xx cn78xx;
+	struct cvmx_gserx_lanex_misc_cfg_1_s  cn78xx;
 	struct cvmx_gserx_lanex_misc_cfg_1_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_misc_cfg_1_cn73xx cnf75xx;
 };
@@ -4077,7 +4133,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_1 {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn78xx;
-	struct cvmx_gserx_lanex_pcs_ctlifc_1_s cn78xxp2;
+	struct cvmx_gserx_lanex_pcs_ctlifc_1_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_pcs_ctlifc_1_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_1 cvmx_gserx_lanex_pcs_ctlifc_1_t;
@@ -4188,7 +4244,7 @@ union cvmx_gserx_lanex_pcs_ctlifc_2 {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn78xx;
-	struct cvmx_gserx_lanex_pcs_ctlifc_2_s cn78xxp2;
+	struct cvmx_gserx_lanex_pcs_ctlifc_2_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_pcs_ctlifc_2_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_lanex_pcs_ctlifc_2 cvmx_gserx_lanex_pcs_ctlifc_2_t;
@@ -4224,8 +4280,10 @@ union cvmx_gserx_lanex_pcs_macifc_mon_2 {
 	uint64_t reserved_16_63               : 48;
 #endif
 	} s;
+	struct cvmx_gserx_lanex_pcs_macifc_mon_2_s cn73xx;
 	struct cvmx_gserx_lanex_pcs_macifc_mon_2_s cn78xx;
 	struct cvmx_gserx_lanex_pcs_macifc_mon_2_s cn78xxp2;
+	struct cvmx_gserx_lanex_pcs_macifc_mon_2_s cnf75xx;
 };
 typedef union cvmx_gserx_lanex_pcs_macifc_mon_2 cvmx_gserx_lanex_pcs_macifc_mon_2_t;
 
@@ -4394,7 +4452,7 @@ union cvmx_gserx_lanex_pwr_ctrl {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_lanex_pwr_ctrl_s    cn78xx;
-	struct cvmx_gserx_lanex_pwr_ctrl_s    cn78xxp2;
+	struct cvmx_gserx_lanex_pwr_ctrl_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_pwr_ctrl_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_lanex_pwr_ctrl cvmx_gserx_lanex_pwr_ctrl_t;
@@ -5166,7 +5224,7 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t reserved_14_63               : 50;
 #endif
 	} cn78xx;
-	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn78xxp2;
+	struct cvmx_gserx_lanex_rx_misc_ovrrd_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_rx_misc_ovrrd_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_lanex_rx_misc_ovrrd cvmx_gserx_lanex_rx_misc_ovrrd_t;
@@ -5549,7 +5607,7 @@ union cvmx_gserx_lanex_sds_pin_mon_0 {
 	uint64_t reserved_10_63               : 54;
 #endif
 	} cn73xx;
-	struct cvmx_gserx_lanex_sds_pin_mon_0_s cn78xxp2;
+	struct cvmx_gserx_lanex_sds_pin_mon_0_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_sds_pin_mon_0_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_lanex_sds_pin_mon_0 cvmx_gserx_lanex_sds_pin_mon_0_t;
@@ -5698,7 +5756,7 @@ union cvmx_gserx_lanex_tx_cfg_0 {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_0_s    cn78xx;
-	struct cvmx_gserx_lanex_tx_cfg_0_s    cn78xxp2;
+	struct cvmx_gserx_lanex_tx_cfg_0_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_tx_cfg_0_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_0 cvmx_gserx_lanex_tx_cfg_0_t;
@@ -5813,7 +5871,7 @@ union cvmx_gserx_lanex_tx_cfg_2 {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_2_s    cn78xx;
-	struct cvmx_gserx_lanex_tx_cfg_2_s    cn78xxp2;
+	struct cvmx_gserx_lanex_tx_cfg_2_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_tx_cfg_2_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_2 cvmx_gserx_lanex_tx_cfg_2_t;
@@ -5864,7 +5922,7 @@ union cvmx_gserx_lanex_tx_cfg_3 {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_lanex_tx_cfg_3_s    cn78xx;
-	struct cvmx_gserx_lanex_tx_cfg_3_s    cn78xxp2;
+	struct cvmx_gserx_lanex_tx_cfg_3_cn73xx cn78xxp2;
 	struct cvmx_gserx_lanex_tx_cfg_3_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_lanex_tx_cfg_3 cvmx_gserx_lanex_tx_cfg_3_t;
@@ -5944,11 +6002,11 @@ union cvmx_gserx_lane_mode {
                                                          0x1: R_5G_REFCLK100.
                                                          0x2: R_8G_REFCLK100.
                                                          0x3: R_125G_REFCLK15625_KX (not supported).
-                                                         0x4: R_3125G_REFCLK15625_XAUI.
+                                                         0x4: R_3125G_REFCLK15625_XAUI (not supported).
                                                          0x5: R_103125G_REFCLK15625_KR.
                                                          0x6: R_125G_REFCLK15625_SGMII.
                                                          0x7: R_5G_REFCLK15625_QSGMII (not supported).
-                                                         0x8: R_625G_REFCLK15625_RXAUI.
+                                                         0x8: R_625G_REFCLK15625_RXAUI (not supported).
                                                          0x9: R_25G_REFCLK125.
                                                          0xA: R_5G_REFCLK125.
                                                          0xB: R_8G_REFCLK125.
@@ -8704,7 +8762,7 @@ union cvmx_gserx_slicex_rx_sdll_ctrl {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn78xx;
-	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn78xxp2;
+	struct cvmx_gserx_slicex_rx_sdll_ctrl_cn73xx cn78xxp2;
 	struct cvmx_gserx_slicex_rx_sdll_ctrl_cn73xx cnf75xx;
 };
 typedef union cvmx_gserx_slicex_rx_sdll_ctrl cvmx_gserx_slicex_rx_sdll_ctrl_t;
@@ -8757,7 +8815,7 @@ union cvmx_gserx_slice_cfg {
 #endif
 	} cn73xx;
 	struct cvmx_gserx_slice_cfg_s         cn78xx;
-	struct cvmx_gserx_slice_cfg_s         cn78xxp2;
+	struct cvmx_gserx_slice_cfg_cn73xx    cn78xxp2;
 	struct cvmx_gserx_slice_cfg_cn73xx    cnf75xx;
 };
 typedef union cvmx_gserx_slice_cfg cvmx_gserx_slice_cfg_t;
@@ -8773,9 +8831,8 @@ union cvmx_gserx_spd {
 	struct cvmx_gserx_spd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t spd                          : 4;  /**< For SRIO links (i.e. GSER(2..3), the hardware loads this CSR field from the SRIO_SPD<3:0>
-                                                         signals from the SRIO MAC during chip cold reset. For non-SRIO links, this field is not
-                                                         used.
+	uint64_t spd                          : 4;  /**< For CCPI links (i.e. GSER8..13), the hardware loads this CSR field from the OCI_SPD<3:0>
+                                                         pins during chip cold reset. For non-CCPI links, this field is not used.
                                                          For SPD settings that configure a non-default reference clock, hardware updates the PLL
                                                          settings of the specific lane mode (LMODE) table entry to derive the correct link rate.
                                                          <pre>
@@ -8797,11 +8854,11 @@ union cvmx_gserx_spd {
                                                          0xE:  156.25 MHz  10.3125 Gb  R_103125G_REFCLK15625_KR
                                                          0xF:                          SW_MODE
                                                          </pre>
-                                                         Note that a value of 0xF is called SW_MODE. The SRIO link does not come up configured in
+                                                         Note that a value of 0xF is called SW_MODE. The CCPI link does not come up configured in
                                                          SW_MODE.
-                                                         (Software must do all the SRIO GSER configuration to use SRIO in the case of SW_MODE.)
+                                                         (Software must do all the CCPI GSER configuration to use CCPI in the case of SW_MODE.)
                                                          When SPD!=SW_MODE after a chip cold reset, the hardware has initialized the following
-                                                         registers (based on the SRIO_SPD selection):
+                                                         registers (based on the OCI_SPD selection):
                                                           * GSER()_LANE_MODE[LMODE]=Z.
                                                           * GSER()_PLL_P()_MODE_0.
                                                           * GSER()_PLL_P()_MODE_1.
@@ -8810,7 +8867,7 @@ union cvmx_gserx_spd {
                                                           * GSER()_LANE()_RX_VALBBD_CTRL_0.
                                                           * GSER()_LANE()_RX_VALBBD_CTRL_1.
                                                           * GSER()_LANE()_RX_VALBBD_CTRL_2.
-                                                          where in "GSER(x)", x is 0..8, and in "P(z)", z equals LMODE. */
+                                                          where in "GSER(x)", x is 8..13, and in "P(z)", z equals LMODE. */
 #else
 	uint64_t spd                          : 4;
 	uint64_t reserved_4_63                : 60;
@@ -8825,7 +8882,7 @@ union cvmx_gserx_spd {
 	} cn73xx;
 	struct cvmx_gserx_spd_s               cn78xx;
 	struct cvmx_gserx_spd_s               cn78xxp2;
-	struct cvmx_gserx_spd_s               cnf75xx;
+	struct cvmx_gserx_spd_cn73xx          cnf75xx;
 };
 typedef union cvmx_gserx_spd cvmx_gserx_spd_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
index 8daae81..bdb0cda 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -93,6 +93,8 @@ extern "C" {
 	    }								\
 	} while (0)
 
+extern int cvmx_npi_max_pknds;
+
 /*
  * Config Options
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
index 8dcdb24..91c2dc0 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
@@ -186,6 +186,17 @@ static inline uint64_t CVMX_IOBN_PP_BIST_STATUS_FUNC(void)
 #else
 #define CVMX_IOBN_PP_BIST_STATUS (CVMX_ADD_IO_SEG(0x00011800F0000700ull))
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_IOBN_ROC_DLL CVMX_IOBN_ROC_DLL_FUNC()
+static inline uint64_t CVMX_IOBN_ROC_DLL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_IOBN_ROC_DLL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800F0001010ull);
+}
+#else
+#define CVMX_IOBN_ROC_DLL (CVMX_ADD_IO_SEG(0x00011800F0001010ull))
+#endif
 
 /**
  * cvmx_iobn_bist_status
@@ -875,4 +886,41 @@ union cvmx_iobn_pp_bist_status {
 };
 typedef union cvmx_iobn_pp_bist_status cvmx_iobn_pp_bist_status_t;
 
+/**
+ * cvmx_iobn_roc_dll
+ *
+ * Status of the ROC core-clock DLL.
+ *
+ */
+union cvmx_iobn_roc_dll {
+	uint64_t u64;
+	struct cvmx_iobn_roc_dll_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t max_dll_setting              : 12; /**< Max reported DLL setting. */
+	uint64_t min_dll_setting              : 12; /**< Min reported DLL setting. */
+	uint64_t reserved_32_35               : 4;
+	uint64_t pdr_rclk_refclk              : 1;  /**< Synchronized pdr_rclk_refclk from ROC core-clock DLL cmb0 phase detectors. */
+	uint64_t pdl_rclk_refclk              : 1;  /**< Synchronized pdl_rclk_refclk from ROC core-clock DLL cmb0 phase detectors. */
+	uint64_t pd_pos_rclk_refclk           : 1;  /**< Synchronized pd_pos_rclk_refclk from ROC core-clock DLL cmb0 phase detectors. */
+	uint64_t dll_lock                     : 1;  /**< The dll_lock signal from ROC core-clock DLL, from the positive edge of refclk. */
+	uint64_t dll_dly_elem_en              : 16; /**< The ROC core-clock delay element enable setting, from the negative edge of refclk. */
+	uint64_t dll_setting                  : 12; /**< The ROC core-clock DLL setting, from the negative edge of refclk. */
+#else
+	uint64_t dll_setting                  : 12;
+	uint64_t dll_dly_elem_en              : 16;
+	uint64_t dll_lock                     : 1;
+	uint64_t pd_pos_rclk_refclk           : 1;
+	uint64_t pdl_rclk_refclk              : 1;
+	uint64_t pdr_rclk_refclk              : 1;
+	uint64_t reserved_32_35               : 4;
+	uint64_t min_dll_setting              : 12;
+	uint64_t max_dll_setting              : 12;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} s;
+	struct cvmx_iobn_roc_dll_s            cnf75xx;
+};
+typedef union cvmx_iobn_roc_dll cvmx_iobn_roc_dll_t;
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 5b57f15..80eca5a 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -677,7 +677,7 @@ static inline uint64_t CVMX_L2C_MCIX_BIST_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_MCIX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((offset) & 3) * 0x40000ull;
 }
@@ -691,7 +691,7 @@ static inline uint64_t CVMX_L2C_MCIX_ERR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_MCIX_ERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((offset) & 3) * 0x40000ull;
 }
@@ -705,7 +705,7 @@ static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_MCIX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080C00028ull) + ((offset) & 3) * 0x40000ull;
 }
@@ -7513,9 +7513,10 @@ union cvmx_l2c_tadx_err {
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. If CMD[7]==0, this field is
                                                          unpredictable. */
 	uint64_t node                         : 4;  /**< Reserved.  Will always be 0. */
-	uint64_t addr                         : 40; /**< XMC address causing the error. This field is the physical address after hole removal and
-                                                         index aliasing (if enabled). (The hole is between DR0 and DR1. Remove the hole by
-                                                         subtracting 256MB from all L2/DRAM physical addresses >= 512 MB.) */
+	uint64_t addr                         : 40; /**< XMC address causing the error. ADDR<6:0> is unpredictable for *DISOCI and BIG*
+                                                         errors. This field is the physical address after hole removal and index aliasing
+                                                         (if enabled). (The hole is between DR0 and DR1. Remove the hole by subtracting
+                                                         256MB from all L2/DRAM physical addresses >= 512 MB.) */
 #else
 	uint64_t addr                         : 40;
 	uint64_t node                         : 4;
@@ -7566,9 +7567,10 @@ union cvmx_l2c_tadx_err {
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. If CMD[7]==0, this field is
                                                          unpredictable. */
 	uint64_t node                         : 4;  /**< Reserved.  Will always be 0. */
-	uint64_t addr                         : 40; /**< XMC address causing the error. This field is the physical address after hole removal and
-                                                         index aliasing (if enabled). (The hole is between DR0 and DR1. Remove the hole by
-                                                         subtracting 256MB from all L2/DRAM physical addresses >= 512 MB.) */
+	uint64_t addr                         : 40; /**< XMC address causing the error. ADDR<6:0> is unpredictable for *DISOCI and BIG*
+                                                         errors. This field is the physical address after hole removal and index aliasing
+                                                         (if enabled). (The hole is between DR0 and DR1. Remove the hole by subtracting
+                                                         256MB from all L2/DRAM physical addresses >= 512 MB.) */
 #else
 	uint64_t addr                         : 40;
 	uint64_t node                         : 4;
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index 9d00c03..74a1f25 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -56,7 +56,8 @@
 static inline uint64_t CVMX_LMCX_BANK_CONFLICT1(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_BANK_CONFLICT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000360ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -67,7 +68,8 @@ static inline uint64_t CVMX_LMCX_BANK_CONFLICT1(unsigned long offset)
 static inline uint64_t CVMX_LMCX_BANK_CONFLICT2(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_BANK_CONFLICT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180088000368ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -1311,6 +1313,18 @@ static inline uint64_t CVMX_LMCX_PHY_CTL(unsigned long offset)
 #define CVMX_LMCX_PHY_CTL(offset) (CVMX_ADD_IO_SEG(0x0001180088000210ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_LMCX_PHY_CTL2(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_LMCX_PHY_CTL2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180088000250ull) + ((offset) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_LMCX_PHY_CTL2(offset) (CVMX_ADD_IO_SEG(0x0001180088000250ull) + ((offset) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_LMCX_PLL_BWCTL(unsigned long offset)
 {
 	if (!(
@@ -1954,13 +1968,14 @@ union cvmx_lmcx_bank_conflict1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t cnt                          : 64; /**< Bank conflict counter. A 64-bit counter that increments at every dclk
                                                          cycles when LMC could not issue R/W operations to the DRAM due to
-                                                         bank conflict. This increments when all 8 in-flight buffers are not
+                                                         bank conflict. This increments when all 8 In-Flight buffers are not
                                                          utilized. */
 #else
 	uint64_t cnt                          : 64;
 #endif
 	} s;
 	struct cvmx_lmcx_bank_conflict1_s     cn78xxp2;
+	struct cvmx_lmcx_bank_conflict1_s     cnf75xx;
 };
 typedef union cvmx_lmcx_bank_conflict1 cvmx_lmcx_bank_conflict1_t;
 
@@ -1976,13 +1991,14 @@ union cvmx_lmcx_bank_conflict2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t cnt                          : 64; /**< Bank conflict counter. A 64-bit counter that increments at every dclk
                                                          cycles when LMC could not issue R/W operations to the DRAM due to
-                                                         bank conflict. This increments only when there are less than 4 in-flight
-                                                         buffers that are not utilized. */
+                                                         bank conflict. This increments only when there are less than 4 In-Flight
+                                                         buffers occupied. */
 #else
 	uint64_t cnt                          : 64;
 #endif
 	} s;
 	struct cvmx_lmcx_bank_conflict2_s     cn78xxp2;
+	struct cvmx_lmcx_bank_conflict2_s     cnf75xx;
 };
 typedef union cvmx_lmcx_bank_conflict2 cvmx_lmcx_bank_conflict2_t;
 
@@ -4486,9 +4502,8 @@ union cvmx_lmcx_control {
                                                          every LMC()_CONFIG [REF_ZQCS_INT] CK cycles. */
 	uint64_t auto_dclkdis                 : 1;  /**< When 1, LMC automatically shuts off its internal clock to conserve power when there is no
                                                          traffic. Note that this has no effect on the DDR3/DDR4 PHY and pads clocks. */
-	uint64_t xor_bank                     : 1;  /**< XOR the bank bits.
-                                                         - 0: bank<2:0> = address<9:7>.
-                                                         - 1: bank<2:0> = address<9:7> ^ address<14:12>. */
+	uint64_t xor_bank                     : 1;  /**< Enable signal to XOR the bank bits. See LMC()_EXT_CONFIG2 on how LMC selects the L2C-LMC
+                                                         address bits. */
 	uint64_t max_write_batch              : 4;  /**< Maximum number of consecutive write operations to service before forcing read operations
                                                          to interrupt. */
 	uint64_t nxm_write_en                 : 1;  /**< NXM write mode. When clear, LMC discards write operations to addresses that don't exist in
@@ -5705,7 +5720,9 @@ union cvmx_lmcx_dbtrain_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_dbtrain_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_60_63               : 4;
+	uint64_t reserved_62_63               : 2;
+	uint64_t cmd_count_ext                : 2;  /**< Extension bits to the field DBTRAIN_CTL[READ_CMD_COUNT]. This enables the data
+                                                         buffer training sequence to send up to 128 read commmands. */
 	uint64_t db_output_impedance          : 3;  /**< Host Interface DQ/DQS Output Driver Impedance control.
                                                          This is the default value used during Host Interface Write Leveling in LRDIMM
                                                          environment, i.e., CONFIG[LRDIMM_ENA] = 1, SEQ_CTL[SEQ_SEL] = 0x6.
@@ -5739,7 +5756,7 @@ union cvmx_lmcx_dbtrain_ctl {
                                                          Read commands to accommodate for the DWL training mode. */
 	uint64_t write_ena                    : 1;  /**< Enables the write operation. This is mainly used to accomplish the MWD
                                                          training sequence of the data buffer.
-                                                         DBTRAIN_CTL[ACTIVATE] must be set to 1 for this to take effect. */
+                                                         LMC()_DBTRAIN_CTL[ACTIVATE] must be set to 1 for this to take effect. */
 	uint64_t activate                     : 1;  /**< Enables the activate command during the data buffer training sequence. */
 	uint64_t prank                        : 2;  /**< Physical Rank bits for Read/Write/Activate operation during the data buffer
                                                          training. */
@@ -5766,10 +5783,76 @@ union cvmx_lmcx_dbtrain_ctl {
 	uint64_t tccd_sel                     : 1;
 	uint64_t db_sel                       : 1;
 	uint64_t db_output_impedance          : 3;
-	uint64_t reserved_60_63               : 4;
+	uint64_t cmd_count_ext                : 2;
+	uint64_t reserved_62_63               : 2;
 #endif
 	} s;
-	struct cvmx_lmcx_dbtrain_ctl_s        cn73xx;
+	struct cvmx_lmcx_dbtrain_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_60_63               : 4;
+	uint64_t db_output_impedance          : 3;  /**< Host Interface DQ/DQS Output Driver Impedance control.
+                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
+                                                         environment, i.e., LMC()_CONFIG[LRDIMM_ENA] = 1, LMC()_SEQ_CTL[SEQ_SEL] = 0x6.
+                                                         0x0 = RZQ/6 (40 ohm).
+                                                         0x1 = RZQ/7 (34 ohm).
+                                                         0x2 = RZQ/5 (48 ohm).
+                                                         0x3-0x7 = Reserved. */
+	uint64_t db_sel                       : 1;  /**< Used when running Host Interface Write Leveling.
+                                                         0 = selects DIMM0's Data Buffer.
+                                                         1 = selects DIMM1's Data Buffer. */
+	uint64_t tccd_sel                     : 1;  /**< When set, the sequence uses MODEREG_PARAMS3[TCCD_L] to space out
+                                                         back-to-back read commands. Otherwise it will space out back-to-back
+                                                         reads with a default value of 4 cycles.
+                                                         While in DRAM MPR mode, reads from Page 0 may use tCCD_S or tCCD_L.
+                                                         Reads from Pages 1, 2 or 3 however must use tCCD_L, thereby requring
+                                                         this bit to be set. */
+	uint64_t rw_train                     : 1;  /**< When set, the DBTRAIN sequence will perform a Write to the DRAM
+                                                         memory array using burst patern that are set in the CSRs
+                                                         LMC()_GENERAL_PURPOSE0[DATA]<61:0>, LMC()_GENERAL_PURPOSE1[DATA]<61:0> and
+                                                         LMC()_GENERAL_PURPOSE2[DATA]<15:0>.
+                                                         This burst pattern gets shifted by one byte at every cycle.
+                                                         The sequence will then do the reads to the same location and compare
+                                                         the data coming back with this pattern.
+                                                         The bit-wise comparison result gets stored in
+                                                         LMC()_MPR_DATA0[MPR_DATA]<63:0> and LMC()_MPR_DATA1[MPR_DATA]<7:0>. */
+	uint64_t read_dq_count                : 7;  /**< The amount of cycles until a pulse is issued to sample the DQ into the
+                                                         MPR register. This bits control the timing of when to sample the data
+                                                         buffer training result. */
+	uint64_t read_cmd_count               : 5;  /**< The amount of Read Commands to be sent during the data buffer training.
+                                                         This can be set to zero in which case the sequence does not send any
+                                                         Read commands to accommodate for the DWL training mode. */
+	uint64_t write_ena                    : 1;  /**< Enables the write operation. This is mainly used to accomplish the MWD
+                                                         training sequence of the data buffer.
+                                                         LMC()_DBTRAIN_CTL[ACTIVATE] must be set to 1 for this to take effect. */
+	uint64_t activate                     : 1;  /**< Enables the activate command during the data buffer training sequence. */
+	uint64_t prank                        : 2;  /**< Physical Rank bits for Read/Write/Activate operation during the data buffer
+                                                         training. */
+	uint64_t lrank                        : 3;  /**< Logical Rank bits for Read/Write/Activate operation during the data buffer
+                                                         training. */
+	uint64_t row_a                        : 18; /**< The row address for the Activate command during dbtrain. */
+	uint64_t bg                           : 2;  /**< The Bank Group that the commands are directed to while in data buffer
+                                                         training sequence. */
+	uint64_t ba                           : 2;  /**< The bank address for the commands while in data buffer training sequence. */
+	uint64_t column_a                     : 13; /**< Column address for the Read/Write operation during the data buffer
+                                                         training. */
+#else
+	uint64_t column_a                     : 13;
+	uint64_t ba                           : 2;
+	uint64_t bg                           : 2;
+	uint64_t row_a                        : 18;
+	uint64_t lrank                        : 3;
+	uint64_t prank                        : 2;
+	uint64_t activate                     : 1;
+	uint64_t write_ena                    : 1;
+	uint64_t read_cmd_count               : 5;
+	uint64_t read_dq_count                : 7;
+	uint64_t rw_train                     : 1;
+	uint64_t tccd_sel                     : 1;
+	uint64_t db_sel                       : 1;
+	uint64_t db_output_impedance          : 3;
+	uint64_t reserved_60_63               : 4;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_dbtrain_ctl_s        cn78xxp2;
 	struct cvmx_lmcx_dbtrain_ctl_s        cnf75xx;
 };
@@ -7577,25 +7660,36 @@ union cvmx_lmcx_ext_config2 {
 	uint64_t u64;
 	struct cvmx_lmcx_ext_config2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_16_63               : 48;
+	uint64_t reserved_21_63               : 43;
+	uint64_t delay_unload_r3              : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle later for Rank 0 reads.
+                                                         Setting this field has priority over LMC()_CONFIG[EARLY_UNLOAD_D1_R1]. */
+	uint64_t delay_unload_r2              : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle later for Rank 0 reads.
+                                                         Setting this field has priority over LMC()_CONFIG[EARLY_UNLOAD_D1_R0]. */
+	uint64_t delay_unload_r1              : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle later for Rank 0 reads.
+                                                         Setting this field has priority over LMC()_CONFIG[EARLY_UNLOAD_D0_R1]. */
+	uint64_t delay_unload_r0              : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle later for Rank 0 reads.
+                                                         Setting this field has priority over LMC()_CONFIG[EARLY_UNLOAD_D0_R0]. */
+	uint64_t early_dqx2                   : 1;  /**< Similar to LMC()_CONFIG[EARLY_DQX]. This field provides an additional setting to send DQx
+                                                         signals one more CK cycle earlier on top of LMC()_CONFIG[EARLY_DQX]. */
 	uint64_t xor_bank_sel                 : 4;  /**< When LMC()_CONTROL[XOR_BANK] is set to 1, this field selects which
-                                                         L2C-LMC address bits are used to XOR the bank bits with.
-                                                         0x0: bank<3:0> = address<10:7> ^ address<15:12>.
-                                                         0x1: bank<3:0> = address<10:7> ^ address<13:10>.
-                                                         0x2: bank<3:0> = address<10:7> ^ address<14:11>.
-                                                         0x3: bank<3:0> = address<10:7> ^ address<15:12>.
-                                                         0x4: bank<3:0> = address<10:7> ^ address<16:13>.
-                                                         0x5: bank<3:0> = address<10:7> ^ address<17:14>.
-                                                         0x6: bank<3:0> = address<10:7> ^ address<18:15>.
-                                                         0x7: bank<3:0> = address<10:7> ^ address<22:19>.
-                                                         0x8: bank<3:0> = address<10:7> ^ address<23:20>.
-                                                         0x9: bank<3:0> = address<10:7> ^ address<26:23>.
-                                                         0xA: bank<3:0> = address<10:7> ^ address<27:24>.
-                                                         0xB: bank<3:0> = address<10:7> ^ address<30:27>.
-                                                         0xC: bank<3:0> = address<10:7> ^ address<31:28>.
-                                                         0xD: bank<3:0> = address<10:7> ^ address<32:29>.
-                                                         0xE: bank<3:0> = address<10:7> ^ address<35:32>.
-                                                         0xF: bank<3:0> = address<10:7> ^ address<36:33>. */
+                                                          L2C-LMC address bits are used to XOR the bank bits with.
+                                                          The address selection is as follows:
+                                                         - 0:  bank<3:0> = address<10:7> ^ address<15:12>
+                                                         - 1:  bank<3:0> = address<10:7> ^ address<14:11>
+                                                         - 2:  bank<3:0> = address<10:7> ^ address<16:13>
+                                                         - 3:  bank<3:0> = address<10:7> ^ address<17:14>
+                                                         - 4:  bank<3:0> = address<10:7> ^ address<18:15>
+                                                         - 5:  bank<3:0> = address<10:7> ^ address<19:16>
+                                                         - 6:  bank<3:0> = address<10:7> ^ address<23:20>
+                                                         - 7:  bank<3:0> = address<10:7> ^ address<24:21>
+                                                         - 8:  bank<3:0> = address<10:7> ^ address<27:24>
+                                                         - 9:  bank<3:0> = address<10:7> ^ address<28:25>
+                                                          - 10: bank<3:0> = address<10:7> ^ address<31:28>
+                                                          - 11: bank<3:0> = address<10:7> ^ address<32:29>
+                                                          - 12: bank<3:0> = address<10:7> ^ address<33:30>
+                                                          - 13: bank<3:0> = address<10:7> ^ address<36:33>
+                                                          - 14: bank<3:0> = address<10:7> ^ address<37:34>
+                                                          - 15: Reserved. */
 	uint64_t reserved_10_11               : 2;
 	uint64_t row_col_switch               : 1;  /**< When set, the memory address bit position that represents bit 4 of the COLUMN
                                                          address (bit 5 in 32-bit mode) becomes the low order DDR ROW address bit.
@@ -7632,7 +7726,12 @@ union cvmx_lmcx_ext_config2 {
 	uint64_t row_col_switch               : 1;
 	uint64_t reserved_10_11               : 2;
 	uint64_t xor_bank_sel                 : 4;
-	uint64_t reserved_16_63               : 48;
+	uint64_t early_dqx2                   : 1;
+	uint64_t delay_unload_r0              : 1;
+	uint64_t delay_unload_r1              : 1;
+	uint64_t delay_unload_r2              : 1;
+	uint64_t delay_unload_r3              : 1;
+	uint64_t reserved_21_63               : 43;
 #endif
 	} s;
 	struct cvmx_lmcx_ext_config2_cn73xx {
@@ -7675,7 +7774,7 @@ union cvmx_lmcx_ext_config2 {
 #endif
 	} cn73xx;
 	struct cvmx_lmcx_ext_config2_s        cn78xxp2;
-	struct cvmx_lmcx_ext_config2_cn73xx   cnf75xx;
+	struct cvmx_lmcx_ext_config2_s        cnf75xx;
 };
 typedef union cvmx_lmcx_ext_config2 cvmx_lmcx_ext_config2_t;
 
@@ -9042,7 +9141,7 @@ union cvmx_lmcx_modereg_params1 {
 	uint64_t rtt_wr_00_ext                : 1;  /**< RTT_WR rank 0 extension bit for DDR4. */
 	uint64_t db_output_impedance          : 3;  /**< Host Interface DQ/DQS Output Driver Impedance control for DIMM0's Data Buffer.
                                                          This is the default value used during Host Interface Write Leveling in LRDIMM
-                                                         environment, i.e., CONFIG[LRDIMM_ENA] = 1, SEQ_CTL[SEQ_SEL] = 0x6.
+                                                         environment, i.e., LMC()_CONFIG[LRDIMM_ENA] = 1, LMC()_SEQ_CTL[SEQ_SEL] = 0x6.
                                                          0x0 = RZQ/6 (40 ohm).
                                                          0x1 = RZQ/7 (34 ohm).
                                                          0x2 = RZQ/5 (48 ohm).
@@ -10152,7 +10251,21 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_phy_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_58_63               : 6;
+	uint64_t reserved_61_63               : 3;
+	uint64_t dsk_dbg_load_dis             : 1;  /**< Reserved. INTERNAL: When set, LMC prevents PHY from loading the deskew shift
+                                                         registers with its internal settings. When Read Deskew sequence is kicked off
+                                                         by setting DSK_DBG_RD_START = 1 and DSK_DBG_WR_MODE = 0, this field determines
+                                                         whether or not to load the shift register with PHY's internal settings before
+                                                         the shifting process. */
+	uint64_t dsk_dbg_overwrt_ena          : 1;  /**< Reserved. INTERNAL:  When set high, PHY selects all of the preloaded data
+                                                         when configuring the read deskew settings. */
+	uint64_t dsk_dbg_wr_mode              : 1;  /**< Reserved. INTERNAL: When set high along with DSK_DBG_RD_START, LMC kicks off Deskew
+                                                         Overwrite sequence to shift out a 10-bits setting for a single DQ.
+                                                         Note that there are a total of 9 bytes and the chain structure are split into two
+                                                         halves such that the top chain covers Byte 7,6,5,4 and bottom chain cover Byte
+                                                         ECC,3,2,1,0.
+                                                         Each byte has 10 DQs (DQ7,DQ6,DQ5,DQ4,DBI,DAC,DQ3,DQ2,DQ1,DQ0) and that each
+                                                         DQ has 10-bits deskew setting. */
 	uint64_t data_rate_loopback           : 1;  /**< Reserved. INTERNAL: DQ data rate loopback, working in conjunction with LOOPBACK assertion.
                                                          When asserted, incoming PRBS at even DQ can be set at data rate, and the data is loop
                                                          backed out through odd DQ at the same rate.
@@ -10267,7 +10380,10 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t dm_disable                   : 1;
 	uint64_t dq_shallow_loopback          : 1;
 	uint64_t data_rate_loopback           : 1;
-	uint64_t reserved_58_63               : 6;
+	uint64_t dsk_dbg_wr_mode              : 1;
+	uint64_t dsk_dbg_overwrt_ena          : 1;
+	uint64_t dsk_dbg_load_dis             : 1;
+	uint64_t reserved_61_63               : 3;
 #endif
 	} s;
 	struct cvmx_lmcx_phy_ctl_cn61xx {
@@ -10421,7 +10537,126 @@ union cvmx_lmcx_phy_ctl {
 #endif
 	} cn70xx;
 	struct cvmx_lmcx_phy_ctl_cn70xx       cn70xxp1;
-	struct cvmx_lmcx_phy_ctl_s            cn73xx;
+	struct cvmx_lmcx_phy_ctl_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_58_63               : 6;
+	uint64_t data_rate_loopback           : 1;  /**< Reserved. INTERNAL: DQ data rate loopback, working in conjunction with LOOPBACK assertion.
+                                                         When asserted, incoming PRBS at even DQ can be set at data rate, and the data is loop
+                                                         backed out through odd DQ at the same rate.
+                                                         When de-asserted, LOOPBACK assertion is working along with LOOPBACK_POS to check on even
+                                                         DQ against each DQS edge seperately. This is done at the clock rate. */
+	uint64_t dq_shallow_loopback          : 1;  /**< Reserved. INTERNAL: DQ shallow loopback, working in conjunction with LOOPBACK assertion.
+                                                         When asserted, even DQ inputs can be loop-backed out through its adjacent odd DQ outputs
+                                                         without being flop'd by DQS. */
+	uint64_t dm_disable                   : 1;  /**< Write to 1 to disable the DRAM Data Mask feature by having LMC driving a constant value on
+                                                         the
+                                                         DDRX_DQS<17:9>_P pins of the chip during write operations. LMC drives a constant 0 in DDR3
+                                                         and drives a constant 1 in DDR4.
+                                                         Note that setting this field high is NOT allowed when LMC has the Write DBI feature turned
+                                                         on
+                                                         (MODEREG_PARAMS3[WR_DBI]=1). */
+	uint64_t c1_sel                       : 2;  /**< 0x0 = C1 is not routed to any output pin.
+                                                         0x1 = C1 is routed to CS3.
+                                                         0x2 = C1 is routed to A17 address pin.
+                                                         0x3 = C1 is not routed to any output pin. */
+	uint64_t c0_sel                       : 2;  /**< 0x0 = C0 is not routed to any output pin.
+                                                         0x1 = C0 is routed to CS2.
+                                                         0x2 = C0 is routed to TEN output pin.
+                                                         0x3 = C0 is not routed to any output pin. */
+	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
+                                                         clear to value of 0. */
+	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
+                                                         operation is started, then set to 1 when operation is complete. */
+	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. INTERNAL: Data from a deskew read operation. Only valid when the
+                                                         LMC()_PHY_CTL[DSK_DBG_RD_COMPLETE] bit is set. */
+	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. INTERNAL: Write 1 to start deskew data read operation, will automatically clear
+                                                         to 0. Write to 1 will also clear the complete bit. */
+	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. INTERNAL: Adjust clock toggle rate for reading deskew debug information:
+                                                         0x0 = Deskew read clock toggles every 4 DCLKs.
+                                                         0x1 = Deskew read clock toggles every 8 DCLKs.
+                                                         0x2 = Deskew read clock toggles every 12 DCLKs.
+                                                         0x3 = Deskew read clock toggles every 16 DCLKs. */
+	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
+                                                         DDR PHY. */
+	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
+                                                         0 = 8 bits per byte lane, no DBI, no DAC debug. (mainly for o70)
+                                                         1 = 10 bits per byte lane, including DBI and DAC. (must be set to 1, sinc o73 has DBI
+                                                         and DAC bypass). */
+	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
+                                                         byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
+	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation.
+                                                         0x0 = DQ0.
+                                                         0x1 = DQ1.
+                                                         0x2 = DQ2.
+                                                         0x3 = DQ3.
+                                                         0x4 = DAC.
+                                                         0x5 = DBI.
+                                                         0x6 = DQ4.
+                                                         0x7 = DQ5.
+                                                         0x8 = DQ6.
+                                                         0x9 = DQ7. */
+	uint64_t dbi_mode_ena                 : 1;  /**< Enable DBI mode for PHY. */
+	uint64_t ddr_error_n_ena              : 1;  /**< Enable error_alert_n signal for PHY. */
+	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
+	uint64_t dac_on                       : 1;  /**< Reserved. INTERNAL: PHY DAC on. */
+	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMC()_PHY_CTL[PHY_DSK_BYP]
+                                                         when loopback is enabled. */
+	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. INTERNAL: PHY loopback enable. */
+	uint64_t phy_dsk_reset                : 1;  /**< PHY deskew reset. When set, the deskew reset signal goes active if the Vrefint/deskew
+                                                         training sequence is in the idle state. */
+	uint64_t phy_dsk_byp                  : 1;  /**< PHY deskew bypass. */
+	uint64_t phy_pwr_save_disable         : 1;  /**< DDR PHY power save disable. */
+	uint64_t ten                          : 1;  /**< DDR PHY test enable pin. */
+	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. INTERNAL: Set to force read_enable to PHY active all the time. */
+	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. INTERNAL: Low Voltage Mode (1.35V.) */
+	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
+	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
+	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
+	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
+	uint64_t loopback                     : 1;  /**< Reserved; must be zero. INTERNAL: Loopback enable. */
+	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. INTERNAL: Loopback pos mode. */
+	uint64_t ts_stagger                   : 1;  /**< TS stagger mode. This mode configures output drivers with two-stage drive strength to
+                                                         avoid undershoot issues on the bus when strong drivers are suddenly turned on. When this
+                                                         mode is asserted, CNXXXX will configure output drivers to be weak drivers (60ohm output
+                                                         impedance) at the first CK cycle, and change drivers to the designated drive strengths
+                                                         specified in LMC()_COMP_CTL2[CMD_CTL/CK_CTL/DQX_CTL] starting at the following cycle. */
+#else
+	uint64_t ts_stagger                   : 1;
+	uint64_t loopback_pos                 : 1;
+	uint64_t loopback                     : 1;
+	uint64_t ck_dlyout0                   : 4;
+	uint64_t ck_tune0                     : 1;
+	uint64_t ck_dlyout1                   : 4;
+	uint64_t ck_tune1                     : 1;
+	uint64_t lv_mode                      : 1;
+	uint64_t rx_always_on                 : 1;
+	uint64_t ten                          : 1;
+	uint64_t phy_pwr_save_disable         : 1;
+	uint64_t phy_dsk_byp                  : 1;
+	uint64_t phy_dsk_reset                : 1;
+	uint64_t int_phy_loopback_ena         : 1;
+	uint64_t int_pad_loopback_ena         : 1;
+	uint64_t dac_on                       : 1;
+	uint64_t ref_pin_on                   : 1;
+	uint64_t ddr_error_n_ena              : 1;
+	uint64_t dbi_mode_ena                 : 1;
+	uint64_t dsk_dbg_bit_sel              : 4;
+	uint64_t dsk_dbg_byte_sel             : 4;
+	uint64_t dsk_dbg_num_bits_sel         : 1;
+	uint64_t dsk_dbg_offset               : 2;
+	uint64_t dsk_dbg_clk_scaler           : 2;
+	uint64_t dsk_dbg_rd_start             : 1;
+	uint64_t dsk_dbg_rd_data              : 10;
+	uint64_t dsk_dbg_rd_complete          : 1;
+	uint64_t phy_reset                    : 1;
+	uint64_t c0_sel                       : 2;
+	uint64_t c1_sel                       : 2;
+	uint64_t dm_disable                   : 1;
+	uint64_t dq_shallow_loopback          : 1;
+	uint64_t data_rate_loopback           : 1;
+	uint64_t reserved_58_63               : 6;
+#endif
+	} cn73xx;
 	struct cvmx_lmcx_phy_ctl_s            cn78xx;
 	struct cvmx_lmcx_phy_ctl_s            cn78xxp2;
 	struct cvmx_lmcx_phy_ctl_cn61xx       cnf71xx;
@@ -10430,6 +10665,53 @@ union cvmx_lmcx_phy_ctl {
 typedef union cvmx_lmcx_phy_ctl cvmx_lmcx_phy_ctl_t;
 
 /**
+ * cvmx_lmc#_phy_ctl2
+ *
+ * Added in pass 2.0.
+ *
+ */
+union cvmx_lmcx_phy_ctl2 {
+	uint64_t u64;
+	struct cvmx_lmcx_phy_ctl2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_27_63               : 37;
+	uint64_t dqs8_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of the ECC byte.
+                                                         The default value should be 0x4. */
+	uint64_t dqs7_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of Byte 7.
+                                                         The default value should be 0x4. */
+	uint64_t dqs6_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of Byte 6.
+                                                         The default value should be 0x4. */
+	uint64_t dqs5_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of Byte 5.
+                                                         The default value should be 0x4. */
+	uint64_t dqs4_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of Byte 4.
+                                                         The default value should be 0x4. */
+	uint64_t dqs3_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of Byte 3.
+                                                         The default value should be 0x4. */
+	uint64_t dqs2_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of Byte2.
+                                                         The default value should be 0x4. */
+	uint64_t dqs1_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of Byte 1.
+                                                         The default value should be 0x4. */
+	uint64_t dqs0_dsk_adj                 : 3;  /**< Provides adjustable deskew settings for DQS signal of Byte 0.
+                                                         The default value should be 0x4. */
+#else
+	uint64_t dqs0_dsk_adj                 : 3;
+	uint64_t dqs1_dsk_adj                 : 3;
+	uint64_t dqs2_dsk_adj                 : 3;
+	uint64_t dqs3_dsk_adj                 : 3;
+	uint64_t dqs4_dsk_adj                 : 3;
+	uint64_t dqs5_dsk_adj                 : 3;
+	uint64_t dqs6_dsk_adj                 : 3;
+	uint64_t dqs7_dsk_adj                 : 3;
+	uint64_t dqs8_dsk_adj                 : 3;
+	uint64_t reserved_27_63               : 37;
+#endif
+	} s;
+	struct cvmx_lmcx_phy_ctl2_s           cn78xxp2;
+	struct cvmx_lmcx_phy_ctl2_s           cnf75xx;
+};
+typedef union cvmx_lmcx_phy_ctl2 cvmx_lmcx_phy_ctl2_t;
+
+/**
  * cvmx_lmc#_pll_bwctl
  *
  * LMC_PLL_BWCTL  = DDR PLL Bandwidth Control Register
@@ -11036,7 +11318,10 @@ union cvmx_lmcx_rlevel_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_rlevel_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_32_63               : 32;
+	uint64_t reserved_33_63               : 31;
+	uint64_t tccd_sel                     : 1;  /**< When set, the read leveling sequence uses MODEREG_PARAMS3[TCCD_L] to
+                                                         space out back-to-back read commands. Otherwise the back-to-back
+                                                         reads commands are spaced out by a default 4 cycles. */
 	uint64_t pattern                      : 8;  /**< Sets the data pattern used to match in read-leveling operations. */
 	uint64_t reserved_22_23               : 2;
 	uint64_t delay_unload_3               : 1;  /**< Reserved, must be set.  INTERNAL: When set, unload the PHY silo one cycle later during
@@ -11073,7 +11358,8 @@ union cvmx_lmcx_rlevel_ctl {
 	uint64_t delay_unload_3               : 1;
 	uint64_t reserved_22_23               : 2;
 	uint64_t pattern                      : 8;
-	uint64_t reserved_32_63               : 32;
+	uint64_t tccd_sel                     : 1;
+	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
 	struct cvmx_lmcx_rlevel_ctl_cn61xx {
@@ -11147,9 +11433,46 @@ union cvmx_lmcx_rlevel_ctl {
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cn66xx;
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cn68xx;
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cn68xxp1;
-	struct cvmx_lmcx_rlevel_ctl_s         cn70xx;
-	struct cvmx_lmcx_rlevel_ctl_s         cn70xxp1;
-	struct cvmx_lmcx_rlevel_ctl_s         cn73xx;
+	struct cvmx_lmcx_rlevel_ctl_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t pattern                      : 8;  /**< Sets the data pattern used to match in read-leveling operations. */
+	uint64_t reserved_22_23               : 2;
+	uint64_t delay_unload_3               : 1;  /**< When set, unload the PHY silo one cycle later during read-leveling if
+                                                         LMC(0..0)_RLEVEL_RANK(0..1)[BYTE*<1:0>] = 3. DELAY_UNLOAD_3 should normally be set. */
+	uint64_t delay_unload_2               : 1;  /**< When set, unload the PHY silo one cycle later during read-leveling if
+                                                         LMC(0..0)_RLEVEL_RANK(0..1)[BYTE*<1:0>] = 2. DELAY_UNLOAD_2 should normally be set. */
+	uint64_t delay_unload_1               : 1;  /**< When set, unload the PHY silo one cycle later during read-leveling if
+                                                         LMC(0..0)_RLEVEL_RANK(0..1)[BYTE*<1:0>] = 1. DELAY_UNLOAD_1 should normally be set. */
+	uint64_t delay_unload_0               : 1;  /**< When set, unload the PHY silo one cycle later during read-leveling if
+                                                         LMC(0..0)_RLEVEL_RANK(0..1)[BYTE*<1:0>] = 0. DELAY_UNLOAD_0 should normally be set. */
+	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which read-leveling feedback is returned when OR_DIS is set to 1. */
+	uint64_t or_dis                       : 1;  /**< Disable ORing of bits in a byte lane when computing the read-leveling bitmask. OR_DIS
+                                                         should normally not be set. */
+	uint64_t offset_en                    : 1;  /**< When set, LMC attempts to select the read-leveling setting that is
+                                                         LMC(0..0)_RLEVEL_CTL[OFFSET] settings earlier than the last passing read-leveling setting
+                                                         in the largest contiguous sequence of passing settings. When clear, or if the setting
+                                                         selected by LMC(0..0)_RLEVEL_CTL[OFFSET] did not pass, LMC selects the middle setting in
+                                                         the largest contiguous sequence of passing settings, rounding earlier when necessary. */
+	uint64_t offset                       : 4;  /**< The offset used when LMC(0..0)_RLEVEL_CTL[OFFSET] is set. */
+	uint64_t byte                         : 4;  /**< 0 <= BYTE <= 8. Byte index for which bitmask results are saved in LMC(0..0)_RLEVEL_DBG. */
+#else
+	uint64_t byte                         : 4;
+	uint64_t offset                       : 4;
+	uint64_t offset_en                    : 1;
+	uint64_t or_dis                       : 1;
+	uint64_t bitmask                      : 8;
+	uint64_t delay_unload_0               : 1;
+	uint64_t delay_unload_1               : 1;
+	uint64_t delay_unload_2               : 1;
+	uint64_t delay_unload_3               : 1;
+	uint64_t reserved_22_23               : 2;
+	uint64_t pattern                      : 8;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} cn70xx;
+	struct cvmx_lmcx_rlevel_ctl_cn70xx    cn70xxp1;
+	struct cvmx_lmcx_rlevel_ctl_cn70xx    cn73xx;
 	struct cvmx_lmcx_rlevel_ctl_s         cn78xx;
 	struct cvmx_lmcx_rlevel_ctl_s         cn78xxp2;
 	struct cvmx_lmcx_rlevel_ctl_cn61xx    cnf71xx;
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index dcd8bd2..9dbbad5 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -1205,119 +1205,272 @@ static inline uint64_t CVMX_MIO_RST_INT_EN_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_MIO_TWSX_INT(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 1) * 512;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 1) * 512;
+			break;
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 0) * 512;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 3) * 256;
+			break;
+	}
+	cvmx_warn("CVMX_MIO_TWSX_INT (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 3) * 256;
 }
 #else
-#define CVMX_MIO_TWSX_INT(offset) (CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 1) * 512)
+static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001010ull) + (offset) * 512;
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001010ull) + (offset) * 512;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001010ull) + (offset) * 256;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180000001010ull) + (offset) * 256;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_TWSX_INT_W1S(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_MIO_TWSX_INT_W1S(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 3) * 256;
+			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512;
+			break;
+	}
+	cvmx_warn("CVMX_MIO_TWSX_INT_W1S (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 3) * 256;
 }
 #else
-#define CVMX_MIO_TWSX_INT_W1S(offset) (CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512)
+static inline uint64_t CVMX_MIO_TWSX_INT_W1S(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001020ull) + (offset) * 256;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001020ull) + (offset) * 512;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180000001020ull) + (offset) * 256;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_MIO_TWSX_SW_TWSI(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset) & 1) * 512;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset) & 1) * 512;
+			break;
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset) & 0) * 512;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset) & 3) * 256;
+			break;
+	}
+	cvmx_warn("CVMX_MIO_TWSX_SW_TWSI (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset) & 3) * 256;
 }
 #else
-#define CVMX_MIO_TWSX_SW_TWSI(offset) (CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset) & 1) * 512)
+static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001000ull) + (offset) * 512;
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001000ull) + (offset) * 512;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001000ull) + (offset) * 256;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180000001000ull) + (offset) * 256;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_TWSX_SW_TWSI_EXT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_MIO_TWSX_SW_TWSI_EXT(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset) & 1) * 512;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset) & 1) * 512;
+			break;
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset) & 0) * 512;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset) & 3) * 256;
+			break;
+	}
+	cvmx_warn("CVMX_MIO_TWSX_SW_TWSI_EXT (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset) & 3) * 256;
 }
 #else
-#define CVMX_MIO_TWSX_SW_TWSI_EXT(offset) (CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset) & 1) * 512)
+static inline uint64_t CVMX_MIO_TWSX_SW_TWSI_EXT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001018ull) + (offset) * 512;
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001018ull) + (offset) * 512;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001018ull) + (offset) * 256;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180000001018ull) + (offset) * 256;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_MIO_TWSX_TWSI_SW(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN30XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN31XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN38XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN50XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN52XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN56XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN58XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_MIO_TWSX_TWSI_SW(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset) & 1) * 512;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset) & 1) * 512;
+			break;
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset) & 0) * 512;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset) & 3) * 256;
+			break;
+	}
+	cvmx_warn("CVMX_MIO_TWSX_TWSI_SW (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset) & 3) * 256;
 }
 #else
-#define CVMX_MIO_TWSX_TWSI_SW(offset) (CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset) & 1) * 512)
+static inline uint64_t CVMX_MIO_TWSX_TWSI_SW(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001008ull) + (offset) * 512;
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001008ull) + (offset) * 512;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001180000001008ull) + (offset) * 256;
+	}
+	return CVMX_ADD_IO_SEG(0x0001180000001008ull) + (offset) * 256;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_MIO_UART2_DLH CVMX_MIO_UART2_DLH_FUNC()
diff --git a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
index 69e2eee..891deef 100644
--- a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_MPI_CFG CVMX_MPI_CFG_FUNC()
 static inline uint64_t CVMX_MPI_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001000ull);
 }
@@ -75,8 +75,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 8))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 8))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_MPI_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000001080ull) + ((offset) & 15) * 8;
 }
@@ -87,7 +86,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 #define CVMX_MPI_STS CVMX_MPI_STS_FUNC()
 static inline uint64_t CVMX_MPI_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001008ull);
 }
@@ -98,7 +97,7 @@ static inline uint64_t CVMX_MPI_STS_FUNC(void)
 #define CVMX_MPI_STS_W1S CVMX_MPI_STS_W1S_FUNC()
 static inline uint64_t CVMX_MPI_STS_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MPI_STS_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001018ull);
 }
@@ -109,7 +108,7 @@ static inline uint64_t CVMX_MPI_STS_W1S_FUNC(void)
 #define CVMX_MPI_TX CVMX_MPI_TX_FUNC()
 static inline uint64_t CVMX_MPI_TX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_TX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001010ull);
 }
@@ -120,7 +119,7 @@ static inline uint64_t CVMX_MPI_TX_FUNC(void)
 #define CVMX_MPI_WIDE_DAT CVMX_MPI_WIDE_DAT_FUNC()
 static inline uint64_t CVMX_MPI_WIDE_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_MPI_WIDE_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001040ull);
 }
@@ -143,9 +142,8 @@ union cvmx_mpi_cfg {
 	struct cvmx_mpi_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_29_63               : 35;
-	uint64_t clkdiv                       : 13; /**< Clock divisor.
-                                                         _ SPI_CK = coprocessor clock / (2 * CLKDIV)
-                                                         _ CLKDIV = coprocessor clock / (2 * SPI_CK) */
+	uint64_t clkdiv                       : 13; /**< Fspi_clk = Fsclk / (2 * CLKDIV)                    |          NS
+                                                         CLKDIV = Fsclk / (2 * Fspi_clk) */
 	uint64_t csena3                       : 1;  /**< SPI_CS3_L enable:
                                                          0 = UART1_RTS_L/SPI_CS3_L pin is UART pin.
                                                          1 = UART1_RTS_L/SPI_CS3_L pin is MPI/SPI pin.
@@ -154,45 +152,48 @@ union cvmx_mpi_cfg {
                                                          0 = UART1_CTS_L/SPI_CS2_L pin is UART pin.
                                                          1 = UART1_CTS_L/SPI_CS2_L pin is MPI/SPI pin.
                                                          SPI_CS2_L drives UART1_CTS_L/SPI_CS2_L. */
-	uint64_t csena1                       : 1;  /**< SPI_CS1_L enable:
-                                                         0 = BOOT_CE_N<7>/SPI_CS1_L pin is boot-bus pin.
-                                                         1 = BOOT_CE_N<7>/SPI_CS1_L pin is MPI/SPI pin.
-                                                         SPI_CS1_L drives BOOT_CE_N<7>/SPI_CS1_L. */
-	uint64_t csena0                       : 1;  /**< SPI_CS0_L enable:
-                                                         0 = BOOT_CE_N<6>/SPI_CS0_L pin is boot-bus pin.
-                                                         1 = BOOT_CE_N<6>/SPI_CS0_L pin is MPI/SPI pin.
-                                                         SPI_CS0_L drives BOOT_CE_N<6>/SPI_CS0_L. */
-	uint64_t cslate                       : 1;  /**< SPI_CSn_L late.
-                                                         0 = SPI_CSn_L asserts 1/2 coprocessor-clock cycle before the transaction.
-                                                         1 = SPI_CSn_L asserts coincident with the transaction. */
-	uint64_t tritx                        : 1;  /**< Tristate TX. Used only when WIREOR = 1
-                                                         0 = SPI_DO pin is driven when slave is not expected to be driving.
-                                                         1 = SPI_DO pin is tristated when not transmitting. */
-	uint64_t idleclks                     : 2;  /**< Idle clocks. When set, guarantees idle coprocessor-clock cycles between commands. */
-	uint64_t cshi                         : 1;  /**< SPI_CSn_L high: 1 = SPI_CSn_L is asserted high, 0 = SPI_CSn_L is asserted low. */
+	uint64_t csena1                       : 1;  /**< If 0, BOOT_CE_N<7>/SPI_CS1_L pin is BOOT pin       |          NS
+                                                         1, BOOT_CE_N<7>/SPI_CS1_L pin is SPI pin
+                                                            SPI_CS1_L drives BOOT_CE_N<7>/SPI_CS1_L */
+	uint64_t csena0                       : 1;  /**< If 0, BOOT_CE_N<6>/SPI_CS0_L pin is BOOT pin       |          NS
+                                                         1, BOOT_CE_N<6>/SPI_CS0_L pin is SPI pin
+                                                            SPI_CS0_L drives BOOT_CE_N<6>/SPI_CS0_L */
+	uint64_t cslate                       : 1;  /**< If 0, SPI_CS asserts 1/2 SCLK before transaction   |          NS
+                                                            1, SPI_CS assert coincident with transaction
+                                                         NOTE: This control apply for 2 CSs */
+	uint64_t tritx                        : 1;  /**< If 0, SPI_DO pin is driven when slave is not       |          NS
+                                                               expected to be driving
+                                                            1, SPI_DO pin is tristated when not transmitting
+                                                         NOTE: only used when WIREOR==1 */
+	uint64_t idleclks                     : 2;  /**< Guarantee IDLECLKS idle sclk cycles between        |          NS
+                                                         commands. */
+	uint64_t cshi                         : 1;  /**< If 0, CS is low asserted                           |          NS
+                                                         1, CS is high asserted */
 	uint64_t csena                        : 1;  /**< If 0, the MPI_CS is a GPIO, not used by MPI_TX
                                                          1, CS is driven per MPI_TX intruction */
 	uint64_t int_ena                      : 1;  /**< If 0, polling is required                          |          NS
                                                          1, MPI engine interrupts X end of transaction */
-	uint64_t lsbfirst                     : 1;  /**< Shift LSB first: 0 = shift MSB first, 1 = shift LSB first. */
-	uint64_t wireor                       : 1;  /**< Wire-OR DO and DI.
-                                                         0 = SPI_DO and SPI_DI are separate wires (SPI). SPI_DO pin is always driven.
-                                                         1 = SPI_DO/DI is all from SPI_DO pin (MPI). SPI_DO pin is tristated when not transmitting.
-                                                         If WIREOR = 1, SPI_DI pin is not used by the MPI/SPI engine. */
-	uint64_t clk_cont                     : 1;  /**< Clock control.
-                                                         0 = clock idles to value given by IDLELO after completion of MPI/SPI transaction.
-                                                         1 = clock never idles, requires SPI_CSn_L deassertion/assertion between commands. */
-	uint64_t idlelo                       : 1;  /**< Clock idle low/clock invert.
-                                                         0 = SPI_CK idles high, first transition is high-to-low. This mode corresponds to SPI Block
-                                                         Guide options CPOL = 1, CPHA = 1.
-                                                         1 = SPI_CK idles low, first transition is low-to-high. This mode corresponds to SPI Block
-                                                         Guide options CPOL = 0, CPHA = 0. */
-	uint64_t enable                       : 1;  /**< MPI/SPI enable.
-                                                         0 = UART0_DTR_L/SPI_DO, UART0_DCD_L/SPI_DI, UART1_CTS_L/SPI_CS2_L, UART1_RTS_L/SPI_CS3_L
-                                                         pins are UART pins.
-                                                         1 = UART0_DTR_L/SPI_DO and UART0_DCD_L/SPI_DI pins are MPI/SPI pins.
-                                                         UART1_CTS_L/SPI_CS2_L is an MPI/SPI pin if CSENA2 = 1
-                                                         UART1_RTS_L/SPI_CS3_L is an MPI/SPI pin if CSENA3 = 1 */
+	uint64_t lsbfirst                     : 1;  /**< If 0, shift MSB first                              |          NS
+                                                         1, shift LSB first */
+	uint64_t wireor                       : 1;  /**< If 0, SPI_DO and SPI_DI are separate wires (SPI)   |          NS
+                                                               SPI_DO pin is always driven
+                                                            1, SPI_DO/DI is all from SPI_DO pin (MPI)
+                                                               SPI_DO pin is tristated when not transmitting
+                                                         NOTE: if WIREOR==1, SPI_DI pin is not used by the
+                                                               MPI engine */
+	uint64_t clk_cont                     : 1;  /**< If 0, clock idles to value given by IDLELO after   |          NS
+                                                            completion of MPI transaction
+                                                         1, clock never idles, requires CS deassertion
+                                                            assertion between commands */
+	uint64_t idlelo                       : 1;  /**< If 0, SPI_CLK idles high, 1st transition is hi->lo |          NS
+                                                         1, SPI_CLK idles low, 1st transition is lo->hi */
+	uint64_t enable                       : 1;  /**< If 0, UART0_DTR_L/SPI_DO, UART0_DCD_L/SPI_DI       |          NS
+                                                            BOOT_CE_N<7:6>/SPI_CSx_L
+                                                            pins are UART/BOOT pins
+                                                         1, UART0_DTR_L/SPI_DO and UART0_DCD_L/SPI_DI
+                                                            pins are SPI/MPI pins.
+                                                            BOOT_CE_N<6>/SPI_CS0_L is SPI pin if CSENA0=1
+                                                            BOOT_CE_N<7>/SPI_CS1_L is SPI pin if CSENA1=1 */
 #else
 	uint64_t enable                       : 1;
 	uint64_t idlelo                       : 1;
@@ -594,7 +595,6 @@ union cvmx_mpi_cfg {
 	struct cvmx_mpi_cfg_cn73xx            cn78xx;
 	struct cvmx_mpi_cfg_cn73xx            cn78xxp2;
 	struct cvmx_mpi_cfg_cn61xx            cnf71xx;
-	struct cvmx_mpi_cfg_cn73xx            cnf75xx;
 };
 typedef union cvmx_mpi_cfg cvmx_mpi_cfg_t;
 
@@ -606,7 +606,7 @@ union cvmx_mpi_datx {
 	struct cvmx_mpi_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t data                         : 8;  /**< Data to transmit/receive. */
+	uint64_t data                         : 8;  /**< Data to transmit/received                          |           NS */
 #else
 	uint64_t data                         : 8;
 	uint64_t reserved_8_63                : 56;
@@ -623,7 +623,6 @@ union cvmx_mpi_datx {
 	struct cvmx_mpi_datx_s                cn78xx;
 	struct cvmx_mpi_datx_s                cn78xxp2;
 	struct cvmx_mpi_datx_s                cnf71xx;
-	struct cvmx_mpi_datx_s                cnf75xx;
 };
 typedef union cvmx_mpi_datx cvmx_mpi_datx_t;
 
@@ -635,12 +634,11 @@ union cvmx_mpi_sts {
 	struct cvmx_mpi_sts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t rxnum                        : 5;  /**< Number of bytes written for the transaction. */
+	uint64_t rxnum                        : 5;  /**< Number of bytes written for transaction            |          NS */
 	uint64_t reserved_2_7                 : 6;
 	uint64_t mpi_intr                     : 1;  /**< MPI interrupt on transaction done. Throws MPI_INTSN_E::MPI_STS_INTR. */
-	uint64_t busy                         : 1;  /**< Busy.
-                                                         0 = no MPI/SPI transaction in progress.
-                                                         1 = MPI/SPI engine is processing a transaction. */
+	uint64_t busy                         : 1;  /**< If 0, no MPI transaction in progress               |          NS
+                                                         1, MPI engine is processing a transaction */
 #else
 	uint64_t busy                         : 1;
 	uint64_t mpi_intr                     : 1;
@@ -673,7 +671,6 @@ union cvmx_mpi_sts {
 	struct cvmx_mpi_sts_s                 cn78xx;
 	struct cvmx_mpi_sts_s                 cn78xxp2;
 	struct cvmx_mpi_sts_cn30xx            cnf71xx;
-	struct cvmx_mpi_sts_s                 cnf75xx;
 };
 typedef union cvmx_mpi_sts cvmx_mpi_sts_t;
 
@@ -698,7 +695,6 @@ union cvmx_mpi_sts_w1s {
 	} s;
 	struct cvmx_mpi_sts_w1s_s             cn73xx;
 	struct cvmx_mpi_sts_w1s_s             cn78xxp2;
-	struct cvmx_mpi_sts_w1s_s             cnf75xx;
 };
 typedef union cvmx_mpi_sts_w1s cvmx_mpi_sts_w1s_t;
 
@@ -710,15 +706,14 @@ union cvmx_mpi_tx {
 	struct cvmx_mpi_tx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_22_63               : 42;
-	uint64_t csid                         : 2;  /**< Which CS to assert for this transaction */
+	uint64_t csid                         : 2;  /**< Which CS to assert for this transaction            |          NS */
 	uint64_t reserved_17_19               : 3;
-	uint64_t leavecs                      : 1;  /**< Leave SPI_CSn_L asserted.
-                                                         0 = deassert SPI_CSn_L after the transaction is done.
-                                                         1 = leave SPI_CSn_L asserted after the transaction is done. */
+	uint64_t leavecs                      : 1;  /**< If 0, deassert CS after transaction is done        |          NS
+                                                         1, leave CS asserted after transactrion is done */
 	uint64_t reserved_13_15               : 3;
-	uint64_t txnum                        : 5;  /**< Number of bytes to transmit. */
+	uint64_t txnum                        : 5;  /**< Number of bytes to transmit                        |          NS */
 	uint64_t reserved_5_7                 : 3;
-	uint64_t totnum                       : 5;  /**< Total number of bytes to shift (transmit and receive). */
+	uint64_t totnum                       : 5;  /**< Number of bytes to shift (transmit + receive)      |          NS */
 #else
 	uint64_t totnum                       : 5;
 	uint64_t reserved_5_7                 : 3;
@@ -800,7 +795,6 @@ union cvmx_mpi_tx {
 	struct cvmx_mpi_tx_s                  cn78xx;
 	struct cvmx_mpi_tx_s                  cn78xxp2;
 	struct cvmx_mpi_tx_cn61xx             cnf71xx;
-	struct cvmx_mpi_tx_s                  cnf75xx;
 };
 typedef union cvmx_mpi_tx cvmx_mpi_tx_t;
 
@@ -824,7 +818,6 @@ union cvmx_mpi_wide_dat {
 	struct cvmx_mpi_wide_dat_s            cn73xx;
 	struct cvmx_mpi_wide_dat_s            cn78xx;
 	struct cvmx_mpi_wide_dat_s            cn78xxp2;
-	struct cvmx_mpi_wide_dat_s            cnf75xx;
 };
 typedef union cvmx_mpi_wide_dat cvmx_mpi_wide_dat_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index a46d3d1..27927d1 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -696,7 +696,7 @@ union cvmx_oclax_fifo_limit {
                                                          detected. */
 	uint64_t ddr                          : 16; /**< DDR level. When OCLA()_FIFO_DEPTH > [DDR], FIFO entries will be removed, packed into a
                                                          cache line, and overflowed to DDR/L2. All-ones disables overflow to DDR/L2. If non-zero
-                                                         must be at least 28. */
+                                                         must be at least 52. */
 	uint64_t bp                           : 16; /**< Backpressure level. When OCLA()_FIFO_DEPTH > [BP], OCLA will signal backpressure to
                                                          coprocessors. All-ones disables indicating backpressure. */
 	uint64_t wmark                        : 16; /**< Interrupt watermark level. When OCLA()_FIFO_DEPTH > [WMARK], OCLA will set
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index ceeed51..5109c1a 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -1281,7 +1281,7 @@ union cvmx_pcieepvfx_cfg030 {
                                                          receive any of the errors in PCIEEPVF()_CFG068, for example a replay-timer timeout.
                                                          Also, it can be set if we get any of the errors in PCIEEPVF()_CFG066 that has a severity
                                                          set to Nonfatal and meets the Advisory Nonfatal criteria, which most ECRC errors should. */
-	uint32_t i_flr                        : 1;  /**< Initiate function level reset (not supported). */
+	uint32_t i_flr                        : 1;  /**< Initiate function level reset. */
 	uint32_t mrrs                         : 3;  /**< Read-only copy of the associated PF's PCIEP()_CFG030[MRRS]. */
 	uint32_t ns_en                        : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG030[NS_EN]. */
 	uint32_t ap_en                        : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG030[AP_EN]. */
@@ -1706,9 +1706,7 @@ union cvmx_pcieepvfx_cfg044 {
                                                          per-vector mask bits. */
 	uint32_t reserved_27_29               : 3;
 	uint32_t msixts                       : 11; /**< MSI-X table size encoded as (table size - 1).
-                                                         _ PF0:          0x7
-                                                         _ PF1:          0x7
-                                                         _ PF2:          0x10 */
+                                                         This field is writable through PEM()_CFG_WR when PEM()_CFG_WR[ADDR[31]] is set. */
 	uint32_t ncp                          : 8;  /**< Next capability pointer. */
 	uint32_t msixcid                      : 8;  /**< MSI-X Capability ID. */
 #else
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index ad867bf..5eef519 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -4853,10 +4853,8 @@ union cvmx_pcieepx_cfg000 {
 	uint32_t u32;
 	struct cvmx_pcieepx_cfg000_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t devid                        : 16; /**< Device ID for CN73XX, writable through PEM()_CFG_WR. However, the application must not
-                                                         change this field. For EEPROM loads, also see VENDID of this register.
-                                                         SLI PKT (PF0/PF1) DEVID = 0x9700.
-                                                         NQM PKT (PF2)     DEVID = 0x9701. */
+	uint32_t devid                        : 16; /**< Device ID for CNF75XX, writable through PEM()_CFG_WR. However, the application must not
+                                                         change this field. For EEPROM loads, also see VENDID of this register. */
 	uint32_t vendid                       : 16; /**< Cavium's vendor ID, writable through PEM()_CFG_WR. However, the application must not
                                                          change this field. During an EPROM Load, if a value of 0xFFFF is loaded to this field and
                                                          a value of 0xFFFF is loaded to the DEVID field of this register, the value will not be
@@ -4923,7 +4921,7 @@ union cvmx_pcieepx_cfg001 {
                                                          the request is discarded. A interrupt will be generated setting the
                                                          SPEM()_PF()_DBG_INFO[P()_BMD_E bit.
                                                          Transactions are dropped in the Client.  Non-posted transactions returns a SWI_RSP_ERROR
-                                                         to SLI/DPI/NQM soon thereafter.
+                                                         to SLI/DPI soon thereafter.
                                                          Bus master enable mimics the behavor of SPEM()_FLR_PF()_STOPREQ. */
 	uint32_t msae                         : 1;  /**< Memory space access enable. */
 	uint32_t isae                         : 1;  /**< I/O space access enable. */
@@ -4985,19 +4983,10 @@ union cvmx_pcieepx_cfg002 {
 	struct cvmx_pcieepx_cfg002_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t bcc                          : 8;  /**< Base class code,
-                                                         _ PF0:          0x0b  (Processers)
-                                                         _ PF1:          0x0b  (Processors)
-                                                         _ PF2:          0x01  (Mass Storage controller)
                                                          Writable through PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t sc                           : 8;  /**< Subclass code,
-                                                         _ PF0:          0x30 (MIPS)
-                                                         _ PF1:          0x30 (MIPS)
-                                                         _ PF2:          0x08 (Non-volatile)
                                                          Writable through PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t pi                           : 8;  /**< Programming interface.
-                                                         _ PF0:          0x0 (386)
-                                                         _ PF1:          0x0 (386)
-                                                         _ PF2:          0x2 (NVMe)
                                                          Writable through PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t rid                          : 8;  /**< Revision ID, writable through PEM()_CFG_WR. However, the application must not change
                                                          this field. Possible values:
@@ -5942,9 +5931,8 @@ union cvmx_pcieepx_cfg016 {
 	uint32_t pme_clock                    : 1;  /**< PME clock, hardwired to 0. */
 	uint32_t pmsv                         : 3;  /**< Power management specification version, writable through
                                                          PEM()_CFG_WR. However, the application must not change this field. */
-	uint32_t ncp                          : 8;  /**< Next capability pointer. Points to the MSI capabilities (PF0, PF1) or
-                                                         PCIe capabilities list (PF2) by default, writable through
-                                                         PEM()_CFG_WR. However, the application must not change this field. */
+	uint32_t ncp                          : 8;  /**< Next capability pointer. Points to the MSI capabilities by default,
+                                                         writable through PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t pmcid                        : 8;  /**< Power management capability ID. */
 #else
 	uint32_t pmcid                        : 8;
@@ -6524,9 +6512,9 @@ union cvmx_pcieepx_cfg030 {
                                                          SLI_S2M_PORT()_CTL[MRRS] and DPI_SLI_PRT()_CFG[MRRS] must not exceed the desired
                                                          max read request size. */
 	uint32_t ns_en                        : 1;  /**< Enable no snoop. */
-	uint32_t ap_en                        : 1;  /**< AUX power PM enable. */
+	uint32_t ap_en                        : 1;  /**< AUX power PM enable (not suppported). */
 	uint32_t pf_en                        : 1;  /**< Phantom function enable. This bit should never be set; PEM requests never use phantom functions. */
-	uint32_t etf_en                       : 1;  /**< Extended tag field enable. This bit should never be set; PEM requests never use extended tags. */
+	uint32_t etf_en                       : 1;  /**< Extended tag field enable. */
 	uint32_t mps                          : 3;  /**< Max payload size. Legal values: 0x0 = 128 B, 0x1 = 256 B.
                                                          Larger sizes are not supported by CNXXXX.
                                                          DPI_SLI_PRT()_CFG[MPS] must be set to the same value as this field for proper
@@ -7148,15 +7136,9 @@ union cvmx_pcieepx_cfg037 {
 	uint32_t noroprpr                     : 1;  /**< No RO-enabled PR-PR passing. (This bit applies to RCs.) */
 	uint32_t atom128s                     : 1;  /**< 128-bit AtomicOp supported (not supported). */
 	uint32_t atom64s                      : 1;  /**< 64-bit AtomicOp supported.
-                                                         _ PF0:          0x1
-                                                         _ PF1:          0x1
-                                                         _ PF2:          0x0
                                                          Note that inbound AtomicOps targeting BAR0 are not supported and are dropped as an
                                                          unsupported request. */
 	uint32_t atom32s                      : 1;  /**< 32-bit AtomicOp supported.
-                                                         _ PF0:          0x1
-                                                         _ PF1:          0x1
-                                                         _ PF2:          0x0
                                                          Note that inbound AtomicOps targeting BAR0 are not supported and are dropped as an
                                                          unsupported request. */
 	uint32_t atom_ops                     : 1;  /**< AtomicOp routing supported (not applicable for EP). */
@@ -7788,11 +7770,7 @@ union cvmx_pcieepx_cfg044 {
                                                          1 = All vectors associated with the function are masked, regardless of their respective
                                                          per-vector mask bits. */
 	uint32_t reserved_27_29               : 3;
-	uint32_t msixts                       : 11; /**< MSI-X table size encoded as (table size - 1).
-                                                         _ PF0:          0x40
-                                                         _ PF1:          0x40
-                                                         _ PF2:          0x10
-                                                         Writable through PEM()_CFG_WR. However, the application must not change this field. */
+	uint32_t msixts                       : 11; /**< MSI-X table size encoded as (table size - 1). Writable through PEM()_CFG_WR. */
 	uint32_t ncp                          : 8;  /**< Next capability pointer */
 	uint32_t msixcid                      : 8;  /**< MSI-X Capability ID */
 #else
@@ -7823,9 +7801,6 @@ union cvmx_pcieepx_cfg045 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t msixtoffs                    : 29; /**< MSI-X table offset register. Base address of the MSI-X Table, as an offset from the base
                                                          address of the BAR indicated by the Table BIR bits.
-                                                         _ PF0:          0x0
-                                                         _ PF1:          0x0
-                                                         _ PF2:          0x2000
                                                          Writable through PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t msixtbir                     : 3;  /**< MSI-X table BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
                                                          table into memory space.
@@ -7854,9 +7829,6 @@ union cvmx_pcieepx_cfg046 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t msixpoffs                    : 29; /**< MSI-X table offset register. Base address of the MSI-X PBA, as an offset from the base
                                                          address of the BAR indicated by the table PBA bits.
-                                                         _ PF0:          0x200
-                                                         _ PF1:          0x200
-                                                         _ PF2:          0x2040
                                                          Writable through PEM()_CFG_WR. However, the application must not change this field. */
 	uint32_t msixpbir                     : 3;  /**< MSI-X PBA BAR indicator register (BIR). Indicates which BAR is used to map the MSI-X
                                                          pending bit array into memory space.
@@ -9535,14 +9507,15 @@ union cvmx_pcieepx_cfg097 {
 	uint32_t u32;
 	struct cvmx_pcieepx_cfg097_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t tvf                          : 16; /**< Total VFs.  This field is writable through PEM()_CFG_WR.
-                                                         _ PF0:          0x40
-                                                         _ PF1:          0x40
-                                                         _ PF2:          0x403 */
-	uint32_t ivf                          : 16; /**< Initial VFs. This field is writable through PEM()_CFG_WR.
-                                                         _ PF0:          0x40
-                                                         _ PF1:          0x40
-                                                         _ PF2:          0x403 */
+	uint32_t tvf                          : 16; /**< Total VFs.  Read-only copy of PCIEP()_CFG097[IVF]. */
+	uint32_t ivf                          : 16; /**< Initial VFs.
+                                                         There are two InitialVFs registers; one for each ARI Capable
+                                                         and non-ARI Capable Hierarchies.  The PCIEP()_CFG096[ARI] determines which one is
+                                                         being used for SR-IOV, and which one is accessed by a read request.
+                                                         This field is writable through PEM()_CFG_WR, PEM()_CFG_WR[ADDR[31]] determines
+                                                         which IVF register is updated.
+                                                         0 = accesses non-ARI Capable Hieracrhy copy of IVF.
+                                                         1 = accesses ARI Capable Hieracrhy copy of IVF. */
 #else
 	uint32_t ivf                          : 16;
 	uint32_t tvf                          : 16;
@@ -9566,10 +9539,7 @@ union cvmx_pcieepx_cfg098 {
 	struct cvmx_pcieepx_cfg098_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_24_31               : 8;
-	uint32_t fdl                          : 8;  /**< Function dependency link.
-                                                         _ PF0:          0x0
-                                                         _ PF1:          0x1
-                                                         _ PF2:          0x2 */
+	uint32_t fdl                          : 8;  /**< Function dependency link. */
 	uint32_t nvf                          : 16; /**< Number of VFs that are visible. */
 #else
 	uint32_t nvf                          : 16;
@@ -9594,12 +9564,24 @@ union cvmx_pcieepx_cfg099 {
 	uint32_t u32;
 	struct cvmx_pcieepx_cfg099_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t vfs                          : 16; /**< VF stride.  This field is writable through PEM()_CFG_WR. */
-	uint32_t fo                           : 16; /**< First VF offset.  This field is writable through PEM()_CFG_WR.
-                                                         _ PF0 (SPEM):   0x3
-                                                         _ PF0 (PEM):    0x1
-                                                         _ PF1:          0x43
-                                                         _ PF2:          0x83 */
+	uint32_t vfs                          : 16; /**< VF stride.
+                                                         There are two VF Stride registers;  one for each ARI Capable
+                                                         and non-ARI Capable Hierarchies.  The PCIEP()_CFG096[ARI] determines which one is
+                                                         being used for SR-IOV, and which one is accessed by a read request.
+                                                         This field is writable through PEM()_CFG_WR, PEM()_CFG_WR[ADDR[31]] determines
+                                                         which VFS register is updated.
+                                                         0 = accesses non-ARI Capable Hieracrhy copy of VFS.
+                                                         1 = accesses ARI Capable Hieracrhy copy of VFS. */
+	uint32_t fo                           : 16; /**< First VF offset.
+                                                         There are two First VF Offset registers;  one for each ARI Capable
+                                                         and non-ARI Capable Hierarchies.  The PCIEP()_CFG096[ARI] determines which one is
+                                                         being used for SR-IOV, and which one is accessed by a read request.
+                                                         This field is writable through PEM()_CFG_WR, PEM()_CFG_WR[ADDR[31]] determines
+                                                         which FO register is updated.
+                                                         0 = accesses non-ARI Capable Hieracrhy copy of FO.
+                                                         1 = accesses ARI Capable Hieracrhy copy of FO.
+                                                         SPEM_CFG_WR[ADDR[25:24] determines the physical function accessed by the write.
+                                                         0..2 are legal values in EP mode. */
 #else
 	uint32_t fo                           : 16;
 	uint32_t vfs                          : 16;
@@ -9622,10 +9604,7 @@ union cvmx_pcieepx_cfg100 {
 	uint32_t u32;
 	struct cvmx_pcieepx_cfg100_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t vfdev                        : 16; /**< VF device ID.
-                                                         _ PF0:          0x9710
-                                                         _ PF1:          0x9710
-                                                         _ PF2:          0x9711 */
+	uint32_t vfdev                        : 16; /**< VF device ID. */
 	uint32_t reserved_0_15                : 16;
 #else
 	uint32_t reserved_0_15                : 16;
@@ -10364,7 +10343,7 @@ union cvmx_pcieepx_cfg452 {
                                                          0x1 = x1.
                                                          0x3 = x2.
                                                          0x7 = x4.
-                                                         0xF = x8.
+                                                         0xF = x8   (not supported).
                                                          0x1F = x16 (not supported).
                                                          0x3F = x32 (not supported).
                                                          This field indicates the maximum number of lanes supported by the PCIe port. The value can
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index da81ac9..ca0da01 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -5378,7 +5378,7 @@ union cvmx_pciercx_cfg030 {
                                                          SLI_S2M_PORT()_CTL[MRRS] and DPI_SLI_PRT()_CFG[MRRS] must not exceed the desired
                                                          max read request size. */
 	uint32_t ns_en                        : 1;  /**< Enable no snoop. */
-	uint32_t ap_en                        : 1;  /**< AUX power PM enable. */
+	uint32_t ap_en                        : 1;  /**< AUX power PM enable (not supported). */
 	uint32_t pf_en                        : 1;  /**< Phantom function enable. This bit should never be set; CNXXXX requests never use phantom functions. */
 	uint32_t etf_en                       : 1;  /**< Extended tag field enable. Set this bit to enable extended tags. */
 	uint32_t mps                          : 3;  /**< Max payload size. Legal values: 0x0 = 128 B, 0x1 = 256 B.
@@ -8482,7 +8482,7 @@ union cvmx_pciercx_cfg452 {
                                                          0x1 = x1.
                                                          0x3 = x2.
                                                          0x7 = x4.
-                                                         0xF = x8.
+                                                         0xF = x8   (not supported).
                                                          0x1F = x16 (not supported).
                                                          0x3F = x32 (not supported).
                                                          This field indicates the maximum number of lanes supported by the PCIe port. The value can
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index e4da864..df0e2fd 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -61,9 +61,12 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if (((offset <= 15)) && ((block_id <= 1)))
+				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 1) * 0x200000ull) * 8;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if (((offset <= 15)) && ((block_id <= 3)))
+			if (((offset <= 15)) && (((block_id >= 1) && (block_id <= 3))))
 				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -76,7 +79,7 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_BAR1_INDEXX (%lu, %lu) not supported on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
+	return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 1) * 0x200000ull) * 8;
 }
 #else
 static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long block_id)
@@ -85,6 +88,7 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
@@ -107,10 +111,13 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 3) * 0x1000000ull;
+			if (((offset >= 1) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C10000B0ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -121,7 +128,7 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_BAR2_MASK (offset = %lu) not supported on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
 static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
@@ -130,9 +137,10 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C10000B0ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -151,10 +159,13 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 3) * 0x1000000ull;
+			if (((offset >= 1) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C10000A8ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -166,7 +177,7 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_BAR_CTL (offset = %lu) not supported on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
 static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
@@ -175,9 +186,10 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C10000A8ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -205,14 +217,17 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 3) * 0x1000000ull;
+			if (((offset >= 1) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C1000440ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_BIST_STATUS (offset = %lu) not supported on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
 static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
@@ -227,9 +242,10 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000018ull) + (offset) * 0x1000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C1000440ull) + (offset) * 0x1000000ull - 16777216*1;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
 }
@@ -277,7 +293,7 @@ static inline uint64_t CVMX_PEMX_CFG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -296,7 +312,7 @@ static inline uint64_t CVMX_PEMX_CFG_RD(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CFG_RD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000030ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -315,7 +331,7 @@ static inline uint64_t CVMX_PEMX_CFG_WR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CFG_WR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000028ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -329,7 +345,7 @@ static inline uint64_t CVMX_PEMX_CLK_EN(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CLK_EN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000400ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -348,7 +364,7 @@ static inline uint64_t CVMX_PEMX_CPL_LUT_VALID(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CPL_LUT_VALID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000098ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -367,7 +383,7 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CTL_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000000ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -380,7 +396,7 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS2(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CTL_STATUS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -396,10 +412,13 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 3) * 0x1000000ull;
+			if (((offset >= 1) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C10000D0ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -411,7 +430,7 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_DBG_INFO (offset = %lu) not supported on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
 static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
@@ -420,9 +439,10 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C10000D0ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -461,7 +481,7 @@ static inline uint64_t CVMX_PEMX_DIAG_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_DIAG_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000020ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -473,10 +493,13 @@ static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 3) * 0x1000000ull;
+			if (((offset >= 1) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C1000448ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
@@ -484,16 +507,17 @@ static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_ECC_ENA (offset = %lu) not supported on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
 static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C1000448ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + (offset) * 0x1000000ull;
 	}
@@ -505,10 +529,13 @@ static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 3) * 0x1000000ull;
+			if (((offset >= 1) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C1000450ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
@@ -516,16 +543,17 @@ static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_ECC_SYND_CTRL (offset = %lu) not supported on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
 static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C1000450ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + (offset) * 0x1000000ull;
 	}
@@ -537,7 +565,7 @@ static inline uint64_t CVMX_PEMX_ECO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_ECO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000010ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -549,7 +577,7 @@ static inline uint64_t CVMX_PEMX_FLR_GLBLCNT_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_GLBLCNT_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000210ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -561,7 +589,7 @@ static inline uint64_t CVMX_PEMX_FLR_PF0_VF_STOPREQ(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_PF0_VF_STOPREQ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000220ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -573,7 +601,7 @@ static inline uint64_t CVMX_PEMX_FLR_PF_STOPREQ(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_PF_STOPREQ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000218ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -581,11 +609,22 @@ static inline uint64_t CVMX_PEMX_FLR_PF_STOPREQ(unsigned long offset)
 #define CVMX_PEMX_FLR_PF_STOPREQ(offset) (CVMX_ADD_IO_SEG(0x00011800C0000218ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PEMX_FLR_STOPREQ_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_PEMX_FLR_STOPREQ_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800C0000238ull) + ((offset) & 1) * 0x1000000ull;
+}
+#else
+#define CVMX_PEMX_FLR_STOPREQ_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800C0000238ull) + ((offset) & 1) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEMX_FLR_ZOMBIE_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_ZOMBIE_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000230ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -601,10 +640,13 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 3) * 0x1000000ull;
+			if (((offset >= 1) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C10000B8ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -615,7 +657,7 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_INB_READ_CREDITS (offset = %lu) not supported on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
 static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
@@ -624,9 +666,10 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C10000B8ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -717,10 +760,13 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 3) * 0x1000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 1) * 0x1000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 3) * 0x1000000ull;
+			if (((offset >= 1) && (offset <= 3)))
+				return CVMX_ADD_IO_SEG(0x00011800C1000428ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -732,7 +778,7 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PEMX_INT_SUM (offset = %lu) not supported on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 3) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 1) * 0x1000000ull;
 }
 #else
 static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
@@ -741,9 +787,10 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
+			return CVMX_ADD_IO_SEG(0x00011800C1000428ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -761,7 +808,7 @@ static inline uint64_t CVMX_PEMX_ON(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_ON(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -780,7 +827,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR0_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR0_START(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000080ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -799,7 +846,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR1_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR1_START(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000088ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -818,7 +865,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR2_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_P2N_BAR2_START(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000090ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -834,7 +881,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_END(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && (((block_id >= 1) && (block_id <= 3))))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_END(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000048ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16;
 }
@@ -850,7 +897,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_START(unsigned long offset, unsigned l
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && (((block_id >= 1) && (block_id <= 3))))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_START(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800C0000040ull) + (((offset) & 3) + ((block_id) & 3) * 0x100000ull) * 16;
 }
@@ -863,7 +910,7 @@ static inline uint64_t CVMX_PEMX_QLM(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_QLM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -877,7 +924,7 @@ static inline uint64_t CVMX_PEMX_SPI_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_SPI_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000180ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -891,7 +938,7 @@ static inline uint64_t CVMX_PEMX_SPI_DATA(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_SPI_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000188ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -905,7 +952,7 @@ static inline uint64_t CVMX_PEMX_STRAP(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_STRAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -924,7 +971,7 @@ static inline uint64_t CVMX_PEMX_TLP_CREDITS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_TLP_CREDITS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000038ull) + ((offset) & 3) * 0x1000000ull;
 }
@@ -990,7 +1037,8 @@ typedef union cvmx_pemx_bar1_indexx cvmx_pemx_bar1_indexx_t;
  * cvmx_pem#_bar2_mask
  *
  * This register contains the mask pattern that is ANDed with the address from the PCIe core for
- * BAR2 hits.
+ * BAR2 hits. This allows the effective size of RC BAR2 to be shrunk. Must not be changed
+ * from its reset value in EP mode.
  */
 union cvmx_pemx_bar2_mask {
 	uint64_t u64;
@@ -1041,7 +1089,7 @@ union cvmx_pemx_bar_ctl {
 	struct cvmx_pemx_bar_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t bar1_siz                     : 3;  /**< PCIe Port 0 Bar1 Size.
+	uint64_t bar1_siz                     : 3;  /**< PCIe Port 0 Bar1 Size. Must be 0x1 in EP mode.
                                                          0x0 = Reserved.
                                                          0x1 = 64 MB.
                                                          0x2 = 128 MB.
@@ -1423,11 +1471,20 @@ union cvmx_pemx_cfg_rd {
 	uint64_t data                         : 32; /**< Data. */
 	uint64_t addr                         : 32; /**< Address to read. A write to this register starts a read operation.
                                                          Following are the subfields of the ADDR field.
-                                                         <23> When set, indicates a virtual function is active (dbi_vfunc_active on core).
-                                                         <22:18> Reserved.
-                                                         <17:12> The number of the virtual function, when bit 23 is asserted (dbi_vfunc_num on
-                                                         core).
-                                                         <11:0> The offset of the PCIe core CFG register being accessed. */
+                                                         <31:24> Reserved. Must be zero.
+                                                         <23>    When clear, the read accesses the physical function. When set,
+                                                                 the read accesses the virtual function selected by <22:12>.
+                                                                 Must be zero when SR-IOV is not used in the physical function.
+                                                                 Must be zero in RC mode.
+                                                         <22:18> Reserved. Must be zero.
+                                                         <17:12> The selected virtual function. Must be zero when <23> is
+                                                                 clear. Must be zero in RC mode.
+                                                         <11:0>  Selects the PCIe config space register being read in the
+                                                                 function.
+                                                         INTERNAL:
+                                                           <31>    asserts dbi_cs2 at PCIe core.
+                                                           <23>    is dbi_vfunc_active to the core.
+                                                           <22:12> is dbi_vfunc_num to the core. */
 #else
 	uint64_t addr                         : 32;
 	uint64_t data                         : 32;
@@ -1462,12 +1519,24 @@ union cvmx_pemx_cfg_wr {
 	uint64_t data                         : 32; /**< Data to write. A write to this register starts a write operation. */
 	uint64_t addr                         : 32; /**< Address to write. A write to this register starts a write operation.
                                                          Following are the subfields of the ADDR field.
-                                                         <31> When set, asserts dbi_cs2 at PCIe core.
-                                                         <23> When set, indicates a virtual function is active (dbi_vfunc_active on core).
-                                                         <22:18> Reserved.
-                                                         <17:12> The number of the virtual function, when bit 23 is asserted (dbi_vfunc_num on
-                                                         core).
-                                                         <11:0> The offset of the PCIe core CFG register being accessed. */
+                                                         <31>    When clear, the write is the same as a config space write received
+                                                                 from external. When set, the write can modify more fields than
+                                                                 an external write could (i.e. configuration mask register).
+                                                                 Corresponds to the CS2 field in Byte2 of the EEPROM.
+                                                         <30:24> Reserved. Must be zero.
+                                                         <23>    When clear, the write accesses the physical function. When set,
+                                                                 the write accesses the virtual function selected by <22:12>.
+                                                                 Must be zero when SR-IOV is not used in the physical function.
+                                                                 Must be zero in RC mode.
+                                                         <22:18> Reserved. Must be zero.
+                                                         <17:12> The selected virtual function. Must be zero when <23> is
+                                                                 clear. Must be zero in RC mode.
+                                                         <11:0>  Selects the PCIe config space register being written in the
+                                                                 function.
+                                                         INTERNAL:
+                                                           <31>    asserts dbi_cs2 at PCIe core.
+                                                           <23>    is dbi_vfunc_active to the core.
+                                                           <22:12> is dbi_vfunc_num to the core. */
 #else
 	uint64_t addr                         : 32;
 	uint64_t data                         : 32;
@@ -1500,8 +1569,12 @@ union cvmx_pemx_clk_en {
 	struct cvmx_pemx_clk_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t pceclk_gate                  : 1;  /**< When set, PCE_CLK is gated off. When clear, PCE_CLK is enabled. */
-	uint64_t csclk_gate                   : 1;  /**< When set, ECLK is gated off. When clear, ECLK is enabled. */
+	uint64_t pceclk_gate                  : 1;  /**< When set, PCE_CLK is gated off. When clear, PCE_CLK is enabled.
+                                                         Software should set this bit when the PEM is in reset or otherwise not
+                                                         being used in order to reduce power. */
+	uint64_t csclk_gate                   : 1;  /**< When set, CSCLK is gated off. When clear, CSCLK is enabled.
+                                                         Software should set this bit when the PEM is in reset or otherwise not
+                                                         being used in order to reduce power. */
 #else
 	uint64_t csclk_gate                   : 1;
 	uint64_t pceclk_gate                  : 1;
@@ -1577,8 +1650,10 @@ union cvmx_pemx_ctl_status {
                                                          tmost significant Retry Buffer ram block to force
                                                          a parity error when it is later read. */
 	uint64_t auto_sd                      : 1;  /**< Link hardware autonomous speed disable. */
-	uint64_t dnum                         : 5;  /**< Primary bus device number. */
-	uint64_t pbus                         : 8;  /**< Primary bus number. */
+	uint64_t dnum                         : 5;  /**< Not used. */
+	uint64_t pbus                         : 8;  /**< Primary bus number. In RC mode, a RO copy of the corresponding
+                                                         PCIERC(0..3)_CFG006[PBNUM]. In EP mode, the bus number latched
+                                                         on any type 0 configuration write. */
 	uint64_t reserved_32_33               : 2;
 	uint64_t cfg_rtry                     : 16; /**< The time * 0x10000 in coprocessor clocks to wait for a CPL to a configuration read that
                                                          does not carry a retry status. Until such time that the timeout occurs and retry status is
@@ -1693,11 +1768,10 @@ union cvmx_pemx_ctl_status {
                                                          block to force a parity error when it is later read. */
 	uint64_t reserved_48_49               : 2;
 	uint64_t auto_sd                      : 1;  /**< Link hardware autonomous speed disable. */
-	uint64_t dnum                         : 5;  /**< Primary bus device number. In EP mode, the device number latched
-                                                         on a type 0 configuration write to PF0. */
+	uint64_t dnum                         : 5;  /**< Not used. */
 	uint64_t pbus                         : 8;  /**< Primary bus number. In RC mode, a RO copy of the corresponding
                                                          PCIERC(0..3)_CFG006[PBNUM]. In EP mode, the bus number latched
-                                                         on a type 0 configuration write to PF0. */
+                                                         on any type 0 configuration write. */
 	uint64_t reserved_32_33               : 2;
 	uint64_t cfg_rtry                     : 16; /**< The time * 0x10000 in coprocessor clocks to wait for a CPL to a configuration read that
                                                          does not carry a retry status. Until such time that the timeout occurs and retry status is
@@ -1788,64 +1862,137 @@ union cvmx_pemx_dbg_info {
 	struct cvmx_pemx_dbg_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_62_63               : 2;
-	uint64_t m2s_c_dbe                    : 1;  /**< Detected a SLI/NQM M2S FIFO control0/1 double bit error. */
-	uint64_t m2s_c_sbe                    : 1;  /**< Detected a SLI/NQM M2S FIFO control0/1 single bit error. */
-	uint64_t m2s_d_dbe                    : 1;  /**< Detected a SLI/NQM M2S FIFO data0/1 double bit error. */
-	uint64_t m2s_d_sbe                    : 1;  /**< Detected a SLI/NQM M2S FIFO data0/1 single bit error. */
-	uint64_t qhdr_b1_dbe                  : 1;  /**< Detected a core header queue bank1 double bit error. */
-	uint64_t qhdr_b1_sbe                  : 1;  /**< Detected a core header queue bank1 single bit error. */
-	uint64_t qhdr_b0_dbe                  : 1;  /**< Detected a core header queue bank0 double bit error. */
-	uint64_t qhdr_b0_sbe                  : 1;  /**< Detected a core header queue bank0 single bit error. */
-	uint64_t rtry_dbe                     : 1;  /**< Detected a core retry RAM double bit error. */
-	uint64_t rtry_sbe                     : 1;  /**< Detected a core retry RAM single bit error. */
+	uint64_t m2s_c_dbe                    : 1;  /**< Detected a SLI M2S FIFO control0/1 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_M2S_C_DBE. */
+	uint64_t m2s_c_sbe                    : 1;  /**< Detected a SLI M2S FIFO control0/1 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_M2S_C_SBE. */
+	uint64_t m2s_d_dbe                    : 1;  /**< Detected a SLI M2S FIFO data0/1 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_M2S_D_DBE. */
+	uint64_t m2s_d_sbe                    : 1;  /**< Detected a SLI M2S FIFO data0/1 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_M2S_D_SBE. */
+	uint64_t qhdr_b1_dbe                  : 1;  /**< Detected a core header queue bank1 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_QHDR_B1_DBE. */
+	uint64_t qhdr_b1_sbe                  : 1;  /**< Detected a core header queue bank1 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_QHDR_B1_SBE. */
+	uint64_t qhdr_b0_dbe                  : 1;  /**< Detected a core header queue bank0 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_QHDR_B0_DBE. */
+	uint64_t qhdr_b0_sbe                  : 1;  /**< Detected a core header queue bank0 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_QHDR_B0_SBE. */
+	uint64_t rtry_dbe                     : 1;  /**< Detected a core retry RAM double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTRY_DBE. */
+	uint64_t rtry_sbe                     : 1;  /**< Detected a core retry RAM single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTRY_SBE. */
 	uint64_t reserved_50_51               : 2;
-	uint64_t c_d1_dbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data1 double bit error. */
-	uint64_t c_d1_sbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data1 single bit error. */
-	uint64_t c_d0_dbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data0 double bit error. */
-	uint64_t c_d0_sbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data0 single bit error. */
+	uint64_t c_d1_dbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data1 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_D1_DBE. */
+	uint64_t c_d1_sbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data1 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_D1_SBE. */
+	uint64_t c_d0_dbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data0 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_D0_DBE. */
+	uint64_t c_d0_sbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data0 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_D0_SBE. */
 	uint64_t reserved_34_45               : 12;
-	uint64_t datq_pe                      : 1;  /**< Detected a data queue RAM parity error. */
+	uint64_t datq_pe                      : 1;  /**< Detected a data queue RAM parity error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_DATQ_PE. */
 	uint64_t reserved_31_32               : 2;
-	uint64_t ecrc_e                       : 1;  /**< Received an ECRC error. */
-	uint64_t rawwpp                       : 1;  /**< Received a write with poisoned payload. INTERNAL: radm_rcvd_wreq_poisoned. */
-	uint64_t racpp                        : 1;  /**< Received a completion with poisoned payload. INTERNAL: radm_rcvd_cpl_poisoned. */
-	uint64_t ramtlp                       : 1;  /**< Received a malformed TLP. INTERNAL: radm_mlf_tlp_err. */
-	uint64_t rarwdns                      : 1;  /**< Received a request which device does not support. INTERNAL: radm_rcvd_ur_req. */
-	uint64_t caar                         : 1;  /**< Completer aborted a request. radm_rcvd_cpl_ca. */
-	uint64_t racca                        : 1;  /**< Received a completion with CA status. INTERNAL: radm_rcvd_cpl_ca. */
-	uint64_t racur                        : 1;  /**< Received a completion with UR status. INTERNAL: radm_rcvd_cpl_ur. */
-	uint64_t rauc                         : 1;  /**< Received an unexpected completion. INTERNAL: radm_unexp_cpl_err. */
+	uint64_t ecrc_e                       : 1;  /**< Received an ECRC error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_ECRC_E. */
+	uint64_t rawwpp                       : 1;  /**< Received a write with poisoned payload.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAWWPP.
+                                                         INTERNAL: radm_rcvd_wreq_poisoned. */
+	uint64_t racpp                        : 1;  /**< Received a completion with poisoned payload.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACPP.
+                                                         INTERNAL: radm_rcvd_cpl_poisoned. */
+	uint64_t ramtlp                       : 1;  /**< Received a malformed TLP.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAMTLP.
+                                                         INTERNAL: radm_mlf_tlp_err. */
+	uint64_t rarwdns                      : 1;  /**< Received a request which device does not support.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RARWDNS.
+                                                         INTERNAL: radm_rcvd_ur_req. */
+	uint64_t caar                         : 1;  /**< Completer aborted a request.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_CAAR.
+                                                         INTERNAL: radm_rcvd_cpl_ca */
+	uint64_t racca                        : 1;  /**< Received a completion with CA status.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACCA.
+                                                         INTERNAL: radm_rcvd_cpl_ca. */
+	uint64_t racur                        : 1;  /**< Received a completion with UR status.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACUR.
+                                                         INTERNAL: radm_rcvd_cpl_ur. */
+	uint64_t rauc                         : 1;  /**< Received an unexpected completion.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAUC.
+                                                         INTERNAL: radm_unexp_cpl_err. */
 	uint64_t rqo                          : 1;  /**< Receive queue overflow. Normally happens only when flow control advertisements are
-                                                         ignored. INTERNAL: radm_qoverflow. */
-	uint64_t fcuv                         : 1;  /**< Flow control update violation. INTERNAL: (opt. checks) int_xadm_fc_prot_err. */
+                                                         ignored.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RQO.
+                                                         INTERNAL: radm_qoverflow. */
+	uint64_t fcuv                         : 1;  /**< Flow control update violation.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCUV.
+                                                         INTERNAL: (opt. checks) int_xadm_fc_prot_err. */
 	uint64_t rpe                          : 1;  /**< PHY reported an 8B/10B decode error (RxStatus = 0x4) or disparity error (RxStatus =
-                                                         0x7). INTERNAL: rmlh_rcvd_err. */
-	uint64_t fcpvwt                       : 1;  /**< Flow control protocol violation (watchdog timer). INTERNAL: rtlh_fc_prot_err. */
-	uint64_t dpeoosd                      : 1;  /**< DLLP protocol error (out of sequence DLLP). INTERNAL: rdlh_prot_err. */
-	uint64_t rtwdle                       : 1;  /**< Received TLP with datalink layer error. INTERNAL: rdlh_bad_tlp_err. */
-	uint64_t rdwdle                       : 1;  /**< Received DLLP with datalink layer error. INTERNAL: rdlh_bad_dllp_err. */
-	uint64_t mre                          : 1;  /**< Maximum number of retries exceeded. INTERNAL: xdlh_replay_num_rlover_err. */
+                                                         0x7).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPE.
+                                                         INTERNAL: rmlh_rcvd_err. */
+	uint64_t fcpvwt                       : 1;  /**< Flow control protocol violation (watchdog timer).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCPVWT.
+                                                         INTERNAL: rtlh_fc_prot_err. */
+	uint64_t dpeoosd                      : 1;  /**< DLLP protocol error (out of sequence DLLP).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_DPEOOSD.
+                                                         INTERNAL: rdlh_prot_err. */
+	uint64_t rtwdle                       : 1;  /**< Received TLP with datalink layer error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTWDLE.
+                                                         INTERNAL: rdlh_bad_tlp_err. */
+	uint64_t rdwdle                       : 1;  /**< Received DLLP with datalink layer error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RDWDLE.
+                                                         INTERNAL: rdlh_bad_dllp_err. */
+	uint64_t mre                          : 1;  /**< Maximum number of retries exceeded.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_MRE.
+                                                         INTERNAL: xdlh_replay_num_rlover_err. */
 	uint64_t rte                          : 1;  /**< Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                          probability of this bit being set increases with the traffic load.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTE.
                                                          INTERNAL: xdlh_replay_timeout_err. */
-	uint64_t acto                         : 1;  /**< A completion timeout occurred. INTERNAL: pedc_radm_cpl_timeout. */
-	uint64_t rvdm                         : 1;  /**< Received vendor-defined message. INTERNAL: pedc_radm_vendor_msg. */
-	uint64_t rumep                        : 1;  /**< Received unlock message (EP mode only). INTERNAL: pedc_radm_msg_unlock. */
-	uint64_t rptamrc                      : 1;  /**< Received PME turnoff acknowledge message (RC mode only). INTERNAL: pedc_radm_pm_to_ack. */
-	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only). INTERNAL: pedc_radm_pm_pme. */
+	uint64_t acto                         : 1;  /**< A completion timeout occurred.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_ACTO.
+                                                         INTERNAL: pedc_radm_cpl_timeout. */
+	uint64_t rvdm                         : 1;  /**< Received vendor-defined message.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RVDM.
+                                                         INTERNAL: pedc_radm_vendor_msg. */
+	uint64_t rumep                        : 1;  /**< Received unlock message (EP mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RUMEP.
+                                                         INTERNAL: pedc_radm_msg_unlock. */
+	uint64_t rptamrc                      : 1;  /**< Received PME turnoff acknowledge message (RC mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC.
+                                                         INTERNAL: pedc_radm_pm_to_ack. */
+	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPMERC.
+                                                         INTERNAL: pedc_radm_pm_pme. */
 	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
-                                                         is set. INTERNAL: pedc_radm_fatal_err. */
-	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only). INTERNAL: pedc_radm_nonfatal_err. */
-	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only). INTERNAL: pedc_radm_correctable_err. */
-	uint64_t rpoison                      : 1;  /**< Received poisoned TLP. INTERNAL: pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
-	uint64_t recrce                       : 1;  /**< Received ECRC error. INTERNAL: pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
-	uint64_t rtlplle                      : 1;  /**< Received TLP has link layer error. INTERNAL: pedc_radm_trgt1_dllp_abort &
-                                                         pedc__radm_trgt1_eot. */
+                                                         is set.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC.
+                                                         INTERNAL: pedc_radm_fatal_err. */
+	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC.
+                                                         INTERNAL: pedc_radm_nonfatal_err. */
+	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC.
+                                                         INTERNAL: pedc_radm_correctable_err. */
+	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPOISON.
+                                                         INTERNAL: pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
+	uint64_t recrce                       : 1;  /**< Received ECRC error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RECRCE.
+                                                         INTERNAL: pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
+	uint64_t rtlplle                      : 1;  /**< Received TLP has link layer error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPLLE.
+                                                         INTERNAL: pedc_radm_trgt1_dllp_abort & pedc__radm_trgt1_eot. */
 	uint64_t rtlpmal                      : 1;  /**< Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                          if a received AtomicOp viloates address/length rules, this bit is set as well.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPMAL.
                                                          INTERNAL: pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
-	uint64_t spoison                      : 1;  /**< Poisoned TLP sent. Throws PEM_INTSN_E::PEM()_ERROR_SPOISON. peai__client0_tlp_ep &
-                                                         peai__client0_tlp_hv or peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
+	uint64_t spoison                      : 1;  /**< Poisoned TLP sent.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_SPOISON.
+                                                         INTERNAL: peai__client0_tlp_ep & peai__client0_tlp_hv or peai__client1_tlp_ep
+                                                                   & peai__client1_tlp_hv (atomic_op). */
 #else
 	uint64_t spoison                      : 1;
 	uint64_t rtlpmal                      : 1;
@@ -3161,7 +3308,7 @@ typedef union cvmx_pemx_flr_pf0_vf_stopreq cvmx_pemx_flr_pf0_vf_stopreq_t;
  * bit but must not do so prior to hardware taking down the FLR, which could be
  * as long as 100ms.  It may be appropriate for software to wait longer before clearing
  * STOPREQ, software may need to drain deep DPI queues for example.
- * Whenever PEM receives a request mastered by CNXXXX over S2M (i.e. P or NP),
+ * Whenever PEM receives a PF or child VF request mastered by CNXXXX over S2M (i.e. P or NP),
  * when STOPREQ is set for the function, PEM will discard the outgoing request
  * before sending it to the PCIe core.  If a NP, PEM will schedule an immediate
  * SWI_RSP_ERROR completion for the request - no timeout is required.
@@ -3171,6 +3318,10 @@ typedef union cvmx_pemx_flr_pf0_vf_stopreq cvmx_pemx_flr_pf0_vf_stopreq_t;
  *
  * Note that STOPREQ will have no effect on completions returned by CNXXXX over the S2M,
  * nor on M2S traffic.
+ *
+ * Note that when a PF()_STOPREQ is set, none of the associated
+ * PEM()_FLR_PF()_VF_STOPREQ[VF_STOPREQ]
+ * will be set.
  */
 union cvmx_pemx_flr_pf_stopreq {
 	uint64_t u64;
@@ -3189,6 +3340,35 @@ union cvmx_pemx_flr_pf_stopreq {
 typedef union cvmx_pemx_flr_pf_stopreq cvmx_pemx_flr_pf_stopreq_t;
 
 /**
+ * cvmx_pem#_flr_stopreq_ctl
+ *
+ * Function Level Reset STOPREQ Control Register
+ *
+ */
+union cvmx_pemx_flr_stopreq_ctl {
+	uint64_t u64;
+	struct cvmx_pemx_flr_stopreq_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t stopreqclr                   : 1;  /**< When STOPREQCLR is clear, only software (and reset) can clear
+                                                         PEM(0)_FLR_PF_STOPREQ[STOPREQ] and PEM(0)_FLR_PF0_VF_STOPREQ[STOPREQ]
+                                                         bits. When STOPREQCLR is set, PEM hardware
+                                                         also clears the STOPREQ bit when PEM completes an FLR to the PCIe core. In the
+                                                         case of a VF, only one STOPREQ bit gets cleared upon each FLR ack when
+                                                         STOPREQCLR mode bit is set. The srst will assert upon a PF
+                                                         FLR, and srst could be used to reset all STOPREQ bits regardless of
+                                                         STOPREQCLR. Otherwise (e.g. OCTEON), where a PF FLR does not
+                                                         assert srst. */
+#else
+	uint64_t stopreqclr                   : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_pemx_flr_stopreq_ctl_s    cnf75xx;
+};
+typedef union cvmx_pemx_flr_stopreq_ctl cvmx_pemx_flr_stopreq_ctl_t;
+
+/**
  * cvmx_pem#_flr_zombie_ctl
  *
  * Function Level Reset Global Zombie Counter Control Register
@@ -3230,7 +3410,7 @@ union cvmx_pemx_inb_read_credits {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
 	uint64_t num                          : 7;  /**< The number of reads that may be in flight from the PCIe core to the SLI. Minimum number is
-                                                         2; maximum number is 64. */
+                                                         6; maximum number is 64. */
 #else
 	uint64_t num                          : 7;
 	uint64_t reserved_7_63                : 57;
@@ -3407,29 +3587,52 @@ union cvmx_pemx_int_sum {
 	uint64_t u64;
 	struct cvmx_pemx_int_sum_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. This is a level-sensitive interrupt. */
-	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. This is a level-sensitive interrupt. */
-	uint64_t intb                         : 1;  /**< The PCIe controller received an INTB. This is a level-sensitive interrupt. */
-	uint64_t inta                         : 1;  /**< The PCIe controller received an INTA. This is a level-sensitive interrupt. */
+	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. This is a level-sensitive interrupt. This
+                                                         should be ignored in EP mode.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_INTD. */
+	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. This is a level-sensitive interrupt. This
+                                                         should be ignored in EP mode.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_INTC. */
+	uint64_t intb                         : 1;  /**< The PCIe controller received an INTB. This is a level-sensitive interrupt. This
+                                                         should be ignored in EP mode.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_INTB. */
+	uint64_t inta                         : 1;  /**< The PCIe controller received an INTA. This is a level-sensitive interrupt. This
+                                                         should be ignored in EP mode.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_INTA. */
 	uint64_t reserved_14_59               : 46;
-	uint64_t crs_dr                       : 1;  /**< Had a CRS timeout when retries were disabled. */
-	uint64_t crs_er                       : 1;  /**< Had a CRS timeout when retries were enabled. */
-	uint64_t rdlk                         : 1;  /**< Received read lock TLP. */
+	uint64_t crs_dr                       : 1;  /**< Had a CRS timeout when retries were disabled. This should be ignored in EP mode.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_CRS_DR. */
+	uint64_t crs_er                       : 1;  /**< Had a CRS timeout when retries were enabled. This should be ignored in EP mode.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_CRS_ER. */
+	uint64_t rdlk                         : 1;  /**< Received read lock TLP.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_RDLK. */
 	uint64_t exc                          : 1;  /**< Set when the PEM_DBG_INFO register has a bit
                                                          set and its cooresponding PEM_DBG_INFO_EN bit
                                                          is set. */
-	uint64_t un_bx                        : 1;  /**< Received N-TLP for unknown BAR. */
-	uint64_t un_b2                        : 1;  /**< Received N-TLP for BAR2 when BAR2 is disabled. */
-	uint64_t un_b1                        : 1;  /**< Received N-TLP for BAR1 when BAR1 index valid is not set. */
-	uint64_t up_bx                        : 1;  /**< Received P-TLP for an unknown BAR. */
-	uint64_t up_b2                        : 1;  /**< Received P-TLP for BAR2 when BAR2 is disabled. */
-	uint64_t up_b1                        : 1;  /**< Received P-TLP for BAR1 when BAR1 index valid is not set. */
+	uint64_t un_bx                        : 1;  /**< Received N-TLP for unknown BAR.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_UN_BX. */
+	uint64_t un_b2                        : 1;  /**< Received N-TLP for BAR2 when BAR2 is disabled.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_UN_B2. */
+	uint64_t un_b1                        : 1;  /**< Received N-TLP for BAR1 when BAR1 index valid is not set.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_UN_B1. */
+	uint64_t up_bx                        : 1;  /**< Received P-TLP for an unknown BAR.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_UP_BX. */
+	uint64_t up_b2                        : 1;  /**< Received P-TLP for BAR2 when BAR2 is disabled.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_UP_B2. */
+	uint64_t up_b1                        : 1;  /**< Received P-TLP for BAR1 when BAR1 index valid is not set.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_UP_B1. */
 	uint64_t pmem                         : 1;  /**< Recived PME MSG.
                                                          (radm_pm_pme) */
-	uint64_t pmei                         : 1;  /**< PME interrupt (cfg_pme_int). This is a level-sensitive interrupt. */
-	uint64_t se                           : 1;  /**< System error, RC mode only.  (cfg_sys_err_rc) */
-	uint64_t aeri                         : 1;  /**< Advanced error reporting interrupt, RC mode only (cfg_aer_rc_err_int).
-                                                         This is a level-sensitive interrupt. */
+	uint64_t pmei                         : 1;  /**< PME interrupt. This is a level-sensitive interrupt.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_PMEI.
+                                                         INTERNAL: cfg_pme_int */
+	uint64_t se                           : 1;  /**< System error, RC mode only.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_SE.
+                                                         INTERNAL: cfg_sys_err_rc */
+	uint64_t aeri                         : 1;  /**< Advanced error reporting interrupt, RC mode only.
+                                                         This is a level-sensitive interrupt.
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_AERI.
+                                                         INTERNAL: cfg_aer_rc_err_int */
 #else
 	uint64_t aeri                         : 1;
 	uint64_t se                           : 1;
@@ -3838,10 +4041,9 @@ union cvmx_pemx_qlm {
 	struct cvmx_pemx_qlm_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t pemdlmsel                    : 1;  /**< When set, PEM2/PEM3 are configured to send/receive traffic to DLM5. When clear, PEM2/PEM3
-                                                         are
-                                                         configured to send/receive traffic to QLM2/QLM3. Note that this bit can only be set for
-                                                         PEM2/PEM3,
+	uint64_t pemdlmsel                    : 1;  /**< When set, PEM2/PEM3 are configured to send/receive traffic to DLM5/DLM6
+                                                         respectively. When clear, PEM2/PEM3 are configured to send/receive traffic to
+                                                         QLM2/QLM3. Note that this bit can only be set for PEM2/PEM3,
                                                          for all other PEMs it has no function. Note that this bit must only be set when both the
                                                          associated PHYs and PEM2/PEM3 are in reset. These conditions can be assured by setting the
                                                          PEM(2,3)_ON[PEMON] bit after setting this bit. */
@@ -3879,11 +4081,27 @@ union cvmx_pemx_spi_ctl {
 	struct cvmx_pemx_spi_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t start_busy                   : 1;  /**< Start/Busy status. Starts SPI xctn when written; reads 1 when EEPROM busy, 0 when complete. */
-	uint64_t tvalid                       : 1;  /**< Reads 1 if at least one valid entry was read from EEPROM and written to a CSR. Write to
-                                                         clear status. */
-	uint64_t cmd                          : 3;  /**< SPI commands; WREN (110), WRDI (100), READ (011), WRITE (010), RDSR (101), WRSR (001) */
-	uint64_t adr                          : 9;  /**< EEPROM read/write address. */
+	uint64_t start_busy                   : 1;  /**< Start/Busy status. When written with a one, indicates to the controller to
+                                                         start a SPI transaction. The controller clears [START_BUSY] when the
+                                                         write/read operation has completed. If the operation was a read, the
+                                                         contents of PEM()_SPI_DATA are valid once hardware clears this bit. */
+	uint64_t tvalid                       : 1;  /**< Reads 1 if at least one valid entry was read (preamble was valid) from EEPROM
+                                                         and written to corresponding PEM()_SPI_DATA. Write to clear status. */
+	uint64_t cmd                          : 3;  /**< SPI commands. The commands are the following:
+                                                         0x0 = Reserved.
+                                                         0x1 = WRSR: write status register. A single-byte write of
+                                                               corresponding PEM()_SPI_DATA[DATA<7:0>] to the register.
+                                                         0x2 = WRITE: an eight-byte page-mode write of the 64-bits of corresponding
+                                                               PEM()_SPI_DATA to the memory array.
+                                                         0x3 = READ: an eight-byte page-mode read access from the memory array
+                                                               with result in the 64-bits of corresponding PEM()_SPI_DATA.
+                                                         0x4 = WRDI: clear the write-enable latch (i.e. write protect the device).
+                                                         0x5 = RDSR: Read status register. A single-byte read access from
+                                                               the register with result in corresponding PEM()_SPI_DATA[DATA<7:0>].
+                                                         0x6 = WREN: set the write-enable latch (i.e. allow writes to occur)
+                                                         0x7 = Reserved. */
+	uint64_t adr                          : 9;  /**< EEPROM read/write address. the byte address offset for the serial EEPROM access.
+                                                         Since accesses are eight-byte aligned entries, <2:0> must be zero. */
 #else
 	uint64_t adr                          : 9;
 	uint64_t cmd                          : 3;
@@ -3905,17 +4123,32 @@ typedef union cvmx_pemx_spi_ctl cvmx_pemx_spi_ctl_t;
  * cvmx_pem#_spi_data
  *
  * This register contains the most recently read or written SPI data and is unpredictable upon
- * power-up.
+ * power-up. Is valid after a PEM()_SPI_CTL[CMD]=READ/RDSR when HW clears
+ * PEM()_SPI_CTL[START_BUSY]. Is written after a PEM()_SPI_CTL[CMD]=WRITE/WRSR
+ * when HW clears PEM()_SPI_CTL[START_BUSY].
  */
 union cvmx_pemx_spi_data {
 	uint64_t u64;
 	struct cvmx_pemx_spi_data_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t preamble                     : 16; /**< EEPROM PREAMBLE read or write data. */
+	uint64_t preamble                     : 16; /**< EEPROM PREAMBLE read or write data:
+                                                            valid entry  = 0x9DA1
+                                                            end-of-table = 0x6A5D
+                                                            null         = 0xFFFF
+                                                         Unpredictable after a PEM()_SPI_CTL[CMD]=RDSR. */
 	uint64_t reserved_45_47               : 3;
-	uint64_t cs2                          : 1;  /**< EEPROM CS2 read or write data bit. */
-	uint64_t adr                          : 12; /**< EEPROM CFG ADR read or write data. */
-	uint64_t data                         : 32; /**< EEPROM DATA read or write data. */
+	uint64_t cs2                          : 1;  /**< EEPROM CS2 bit. See PEM()_CFG_WR[ADDR<31>]. The [CS2] from
+                                                         a valid EEPROM entry selects the type of write. When clear, an ordinary
+                                                         configuration write. When set, a configuration mask write.
+                                                         Unpredictable after a PEM()_SPI_CTL[CMD]=RDSR. */
+	uint64_t adr                          : 12; /**< EEPROM configuration register address. See PEM()_CFG_WR[ADDR<11:0>].
+                                                         The [ADR] from a valid EEPROM entry selects which configuration register
+                                                         will be written. Note that PEM()_CFG_WR[ADDR<30:12>] of the effective
+                                                         write are all zeroes.
+                                                         Unpredictable after a PEM()_SPI_CTL[CMD]=RDSR. */
+	uint64_t data                         : 32; /**< EEPROM configuration register data. See PEM()_CFG_WR[DATA].
+                                                         HW writes the [DATA] from a valid EEPROM entry to the selected register.
+                                                         [DATA<31:8>] are unpredictable after a PEM()_SPI_CTL[CMD]=RDSR. */
 #else
 	uint64_t data                         : 32;
 	uint64_t adr                          : 12;
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-cluster.h b/arch/mips/include/asm/octeon/cvmx-pki-cluster.h
index 186ec45..a845383 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-cluster.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-cluster.h
@@ -1,5 +1,5 @@
-/* This file is autogenerated from obj/ipemainc.elf */
-const int cvmx_pki_cluster_code_length = 673;
+/* This file is autogenerated from ipemainc.elf */
+const int cvmx_pki_cluster_code_length = 741;
 const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000000000a000000ull,
     0x0000413a68024070ull,
@@ -18,12 +18,12 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x00045cb968030870ull,
     0x0007debd00100010ull,
     0x0000813b80008000ull,
-    0x0004413b68004070ull,
-    0x9001c00000000000ull,
-    0x9021c00000000000ull,
-    0x00044180680100f0ull,
+    0x000441bb68004070ull,
+    0xd001c00000000000ull,
+    0xd021c00000000000ull,
+    0x00045f80680100f0ull,
     0x0004c639ff000200ull,
-    0x0004400372010000ull,
+    0x0004403f72010000ull,
     0x0001c00000000000ull,
     0x0001c00000000000ull,
     0x000041ba68034078ull,
@@ -42,17 +42,32 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000481b800010001ull,
     0x000685b800020002ull,
     0xa006823800010001ull,
-    0x0006c639ff000500ull,
-    0xa0685f3e68010405ull,
-    0x0008418368010800ull,
-    0xa0485f3e68010305ull,
-    0xa4085f3e68010028ull,
-    0xa441c00000000000ull,
-    0x0009418368010030ull,
-    0xa466400172030001ull,
+    0x0006c639ff000400ull,
+    0x00085f3e68010a00ull,
+    0xa0885f3e68010f01ull,
+    0x00085f3e68010405ull,
+    0x00085f3e68010906ull,
+    0xa0485f3e68010e07ull,
+    0xa061c00000000000ull,
+    0xa4085f3e68010b28ull,
+    0xa421c00000000000ull,
+    0x00095f3e68010940ull,
+    0xa066403e72010000ull,
+    0x000941be68034039ull,
+    0x00085f3e68010305ull,
+    0xa4685f3e68010028ull,
     0x00095f3e68030030ull,
     0x00095f3e68010416ull,
+    0x0001c00000000000ull,
+    0x00065cb942080000ull,
+    0xa046552a4e09312dull,
+    0xa446c639ff000500ull,
     0x0006debd00010001ull,
+    0x0006403e72010001ull,
+    0x0001c00000000000ull,
+    0x0001c00000000000ull,
+    0x0001c00000000000ull,
+    0x0001c00000000000ull,
     0x0001c00000000000ull,
     0x0001c00000000000ull,
     0x0001c00000000000ull,
@@ -263,6 +278,10 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x0009010240000004ull,
     0xac29828101000100ull,
     0x000b010240000004ull,
+    0x0006823904000000ull,
+    0x0008d4a907c00200ull,
+    0x0008593268020070ull,
+    0x0008dcb902000200ull,
     0x9000813902000000ull,
     0x0001c00000000000ull,
     0x00040181840005ffull,
@@ -284,7 +303,7 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x0007823d00200020ull,
     0x000685bd00200020ull,
     0x0008d4a907c00140ull,
-    0x0006010240000002ull,
+    0x0004010240000002ull,
     0x0006593268020070ull,
     0x000042a486020000ull,
     0x000a15ab74000124ull,
@@ -337,70 +356,113 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000a593268020870ull,
     0x000ad52a00010001ull,
     0x000a5a3468010078ull,
-    0x000a410244010000ull,
+    0x000a010240000008ull,
     0x0007debd01000100ull,
     0x000481bd01000100ull,
     0x0006c639ff002300ull,
     0x000641aa68034000ull,
     0x000641a968034846ull,
     0x0006403472030001ull,
-    0x0004822902000200ull,
+    0x0004822907000200ull,
     0x000915ab74000341ull,
     0x000082aa00010001ull,
     0x000a86ab00ff0045ull,
     0x000adcb978007800ull,
-    0x0000822902000200ull,
+    0x0000822907000200ull,
     0x00088a3908000000ull,
     0x00065cb942080000ull,
     0x0006552a4e09312dull,
     0x00065cb968082868ull,
     0x0006410246090000ull,
     0x000042a486020000ull,
-    0xa02a15ab74000343ull,
-    0x000881b400ff0011ull,
-    0x00068981ffff2118ull,
-    0x0006593268020870ull,
-    0x0006d4a9f8009800ull,
-    0xa026debd02000200ull,
-    0x0008813400ff002full,
+    0x000a15ab74000343ull,
+    0x982881b400ff0011ull,
+    0x9881c00000000000ull,
+    0x00064180680100f0ull,
+    0x00068283ffff12b5ull,
+    0x000a8a8108000800ull,
+    0x000ad4a9f8009800ull,
+    0x00068303ffff17c1ull,
+    0x000c8b01c0000000ull,
+    0xb0ac5bb768010a58ull,
+    0x000cd4a9f800b800ull,
+    0x000c8281ffff6558ull,
+    0x000adbb701000100ull,
+    0x000c8281ffff86ddull,
+    0x000a8681ffff0800ull,
+    0x000adbb702000200ull,
+    0x000682a9c8009800ull,
+    0x000adebd02000200ull,
+    0x000a593268020870ull,
+    0x000a010240000008ull,
+    0x9c21c00000000000ull,
+    0x9007813400ff002full,
     0x00048901ffff6558ull,
-    0x0004593268020870ull,
-    0x0004d4a9f800a800ull,
-    0x0004debd02000200ull,
-    0x000882bd02000200ull,
-    0xa86ac639ff002800ull,
-    0xa841c00000000000ull,
-    0x000a418368010878ull,
-    0x000a400172030000ull,
+    0x00048281b0002000ull,
+    0x000a593268020870ull,
+    0x000ad4a9f800a800ull,
+    0x000adebd02000200ull,
+    0x000082bd02000200ull,
+    0xa80ac639ff002800ull,
+    0xa861c00000000000ull,
+    0x000a418368010526ull,
+    0xa84a418368010878ull,
     0x000a5bb768030078ull,
+    0x000a400172030000ull,
     0x000a5b00680100f0ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
+    0x000041b468034878ull,
+    0x00005fbf68030878ull,
+    0x00068229c8009800ull,
+    0x0008010248000008ull,
+    0xa001c00000000000ull,
+    0x000843a486020000ull,
+    0x00088101ffff0000ull,
+    0x000415ab74000464ull,
+    0x000e15ab74000461ull,
+    0x0008010240000008ull,
+    0x000c41b76800425aull,
+    0x000c410240030000ull,
+    0x000a010240000008ull,
     0x000a5cb942080000ull,
     0x000a552a4e09312dull,
     0x000a5cb968082868ull,
     0x000a410246090000ull,
-    0x00008129f8009800ull,
-    0x00048529f800a800ull,
-    0x9004893910000000ull,
+    0x0000422486020000ull,
+    0x000815ab74000461ull,
+    0x000081a9f800b800ull,
+    0x000689b701000100ull,
+    0x000685a9f8009800ull,
+    0x000685a9f800a800ull,
+    0x00078229f800b800ull,
+    0x000601024000000cull,
+    0x9801c00000000000ull,
+    0x00088a3702000200ull,
+    0x00068101ffff8100ull,
+    0x0004010240000004ull,
+    0x9801c00000000000ull,
+    0x0009dcb910001000ull,
+    0x00068101ffff86ddull,
+    0x00048501ffff0800ull,
+    0x0005dcb978003800ull,
+    0x0006010240000002ull,
+    0x000081a9f8000000ull,
+    0x9007813910000000ull,
     0x0001c00000000000ull,
     0x00048181f0004000ull,
     0x988658b168020070ull,
     0x0006d428001f0008ull,
-    0xa4068201ff000000ull,
-    0x000815ab74000545ull,
-    0x0009418068010038ull,
-    0xa429028386000005ull,
+    0x00068201ff000000ull,
+    0xa40815ab74000545ull,
     0x0009debd04000400ull,
+    0xa429418068010038ull,
+    0x00095a3468010870ull,
+    0x0009028386000005ull,
     0xac8a068186000014ull,
     0x000a15ab74000543ull,
     0x000b5a3468010070ull,
     0xac6b8303000f0005ull,
     0x000dd428001f0009ull,
-    0x000b830120000000ull,
-    0x000c87011fff0000ull,
+    0x000b83013fff0000ull,
     0x000dd42803e001a0ull,
     0x000d58b168020870ull,
     0x000ddcb960006000ull,
@@ -409,8 +471,9 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x9c01c00000000000ull,
     0x0001c00000000000ull,
     0x00078201f0006000ull,
-    0xa06858b168020070ull,
-    0x0008d428001f000aull,
+    0x000858b168020070ull,
+    0xa068d428001f000aull,
+    0x00085a3468010874ull,
     0x0008818100ff0000ull,
     0x000615ab74000545ull,
     0x00075a3468010078ull,
@@ -432,34 +495,35 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000adcb960006000ull,
     0x000a58b168020870ull,
     0x000a5a3468010078ull,
+    0x000a010240000008ull,
     0x0007debd04000400ull,
     0x000481bd04000400ull,
     0x0006c639ff002b00ull,
-    0x000641aa68034000ull,
+    0x0006832803e001a0ull,
+    0x000dc18300010001ull,
+    0x000cc18300010000ull,
     0x000641a868034840ull,
     0x0006403472030001ull,
-    0x0004822902000200ull,
+    0x00048228001c0008ull,
     0x000915ab74000541ull,
     0x000082ab00ff0045ull,
     0x000adcb960006000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
+    0x00008329ff000200ull,
+    0x000c8728001c0008ull,
     0x00065cb942080000ull,
     0x0006552a4e09312dull,
     0x00065cb968082868ull,
     0x0006410246090000ull,
     0x000042a486020000ull,
     0x000a15ab74000543ull,
-    0x0000813920000000ull,
+    0x000c813920000000ull,
     0x000481b400ff006cull,
     0x0006d42803e001c0ull,
     0x000658b168020870ull,
     0x0007823400ff0032ull,
-    0xa048863400ff0033ull,
+    0x0008863400ff0033ull,
     0x0008d42803e00180ull,
-    0xa0685a80680100f0ull,
     0x000858b168020870ull,
-    0x00085d80680100f0ull,
     0x986981b400ff002full,
     0x0006d42803e00280ull,
     0x00065a80680100f0ull,
@@ -485,10 +549,10 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x0004403472010000ull,
     0xa00858b168020870ull,
     0x00088181ffff0000ull,
-    0x00088281ffff0000ull,
+    0x00068581ffff0000ull,
     0x000615ab74000664ull,
-    0x000a15ab74000664ull,
     0x000081b940004000ull,
+    0x000685a803e00000ull,
     0x00045cb942080000ull,
     0x0004552a4e09312dull,
     0x00045cb968082868ull,
@@ -498,7 +562,6 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000f583068020070ull,
     0x000042a486020000ull,
     0x000a15ab74000661ull,
-    0x000685a803e00000ull,
     0x000782b800100010ull,
     0x000a41b168004078ull,
     0x000a410040030000ull,
@@ -513,8 +576,8 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x0001c00000000000ull,
     0x0001c00000000000ull,
     0x0001c00000000000ull,
-    0x0001c00000000000ull,
-    0x0001c00000000000ull,
+    0x000041bf68034878ull,
+    0x00005a3468030878ull,
     0x000a83891f000000ull,
     0x000f542868090a48ull,
     0x000f583068020070ull,
@@ -588,7 +651,7 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000a8abd00080008ull,
     0x000a41be68004026ull,
     0x0005820807000400ull,
-    0x00088a2902000200ull,
+    0x00088a2907000200ull,
     0x000841b46800405aull,
     0x000556ad40030000ull,
     0x000081bd00100010ull,
@@ -597,7 +660,7 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x00088a0900100010ull,
     0x0008413c68024070ull,
     0xa021c00000000000ull,
-    0x0006832902000200ull,
+    0x0006832907000200ull,
     0x0008c181f0008000ull,
     0x000841834c00ffffull,
     0x0006822a00400040ull,
@@ -616,9 +679,14 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000a41b74c0300ffull,
     0x0000828901000100ull,
     0x000a822803e00180ull,
-    0x00088a3400ff0033ull,
-    0x000841bb4c03ffffull,
-    0x0008862803e00280ull,
+    0x0008413168024078ull,
+    0x0008833400ff0033ull,
+    0x000c010240000004ull,
+    0xa001c00000000000ull,
+    0xa021c00000000000ull,
+    0x000841814c03ffffull,
+    0x000841814c03ffffull,
+    0x000a822803e00280ull,
     0x000841b54c03ffffull,
     0x000682287c005800ull,
     0x00088a0902000200ull,
@@ -635,7 +703,7 @@ const uint64_t cvmx_pki_cluster_code_default[] = {
     0x000dd3260fff0fffull,
     0x0006810900800080ull,
     0x0000003f70000400ull,
-    0x000082a902000200ull,
+    0x000082a907000200ull,
     0x000a413268024070ull,
     0xa50a822902800280ull,
     0x0004893d08000800ull,
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index aa468ec..e185d18 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -3058,7 +3058,7 @@ union cvmx_pki_gen_int {
                                                          bit can be set when the previous reported bit is cleared. Also see PKI_PKT_ERR. Throws
                                                          PKI_INTSN_E::PKI_GEN_SOP. */
 	uint64_t bckprs                       : 1;  /**< PKI asserted backpressure. Set when PKI was unable to accept the next valid data from
-                                                         BGX/DPI/ILK etc. over X2P due to all internal resources being used up, and PKI will
+                                                         BGX/SRIO/DPI/LBK etc. over X2P due to all internal resources being used up, and PKI will
                                                          backpressure X2P. Throws PKI_INTSN_E::PKI_GEN_BCKPRS. */
 	uint64_t crcerr                       : 1;  /**< PKI calculated bad CRC in the L2 frame. Throws PKI_INTSN_E::PKI_GEN_CRCERR. */
 	uint64_t pktdrp                       : 1;  /**< Packet dropped due to QOS. If the QOS algorithm decides to drop a packet, PKI asserts this
@@ -3097,7 +3097,7 @@ union cvmx_pki_gen_int {
                                                          bit can be set when the previous reported bit is cleared. Also see PKI_PKT_ERR. Throws
                                                          PKI_INTSN_E::PKI_GEN_SOP. */
 	uint64_t bckprs                       : 1;  /**< PKI asserted backpressure. Set when PKI was unable to accept the next valid data from
-                                                         BGX/DPI/ILK etc. over X2P due to all internal resources being used up, and PKI will
+                                                         BGX/ILK/DPI/LBK etc. over X2P due to all internal resources being used up, and PKI will
                                                          backpressure X2P. Throws PKI_INTSN_E::PKI_GEN_BCKPRS. */
 	uint64_t crcerr                       : 1;  /**< PKI calculated bad CRC in the L2 frame. Throws PKI_INTSN_E::PKI_GEN_CRCERR. */
 	uint64_t pktdrp                       : 1;  /**< Packet dropped due to QOS. If the QOS algorithm decides to drop a packet, PKI asserts this
@@ -3551,8 +3551,8 @@ typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
 /**
  * cvmx_pki_ptag_avail
  *
- * This register configures tag management. This register may only be written when
- * PKI_BUF_CTL[PKI_EN] is clear.
+ * This register configures tag management. It is suggested that this
+ * register only be written when PKI_BUF_CTL[PKI_EN] is clear.
  * INTERNAL: Therefore do not put other fields into this register unless the same constraint
  * applies.
  */
@@ -3561,11 +3561,11 @@ union cvmx_pki_ptag_avail {
 	struct cvmx_pki_ptag_avail_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t avail                        : 8;  /**< Number of ptags available for use. Decreasing the number of ptags will reduce
-                                                         the number of packets waiting for parsing, which will lead to sooner
-                                                         backpressure/packet drop, but will decrease the small-packet latency of PKI by
-                                                         reducing buffer-bloat.
-                                                         This may only be written when PKI_BUF_CTL[PKI_EN] is clear. */
+	uint64_t avail                        : 8;  /**< Number of ptags available for use. Decreasing the number of ptags will
+                                                         reduce the number of packets waiting for parsing, which will lead to
+                                                         sooner backpressure/packet drop, but will decrease the small-packet
+                                                         latency of PKI by reducing buffer-bloat.  AVAIL must be at least as
+                                                         great as the number of reassembly-IDs used by the system. */
 #else
 	uint64_t avail                        : 8;
 	uint64_t reserved_8_63                : 56;
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 62e0a40..566a87b 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -1492,7 +1492,7 @@ static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 383))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 191)))))
 		cvmx_warn("CVMX_PKO_LUTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000B00000ull) + ((offset) & 1023) * 8;
 }
@@ -3970,7 +3970,7 @@ typedef union cvmx_pko_dqx_shape cvmx_pko_dqx_shape_t;
  * cvmx_pko_dq#_shape_state
  *
  * This register has the same bit fields as PKO_L2_SQ()_SHAPE_STATE.
- *
+ * This register must not be written during normal operation.
  */
 union cvmx_pko_dqx_shape_state {
 	uint64_t u64;
@@ -3978,11 +3978,11 @@ union cvmx_pko_dqx_shape_state {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
-	uint64_t color                        : 2;  /**< Shaper color status. Debug access to the live shaper state.
-                                                         0x0 = Green - operating in 'committed' range.
-                                                         0x1 = Yellow - operating in 'excess/peak' range.
-                                                         0x2 = Red - operating in 'oversubscribed' range.
-                                                         0x3 = Reserved. */
+	uint64_t color                        : 2;  /**< Shaper connection status. Debug access to the live shaper state.
+                                                         0x0 = Green - shaper is connected into the green list.
+                                                         0x1 = Yellow - shaper is connected into the yellow list.
+                                                         0x2 = Red - shaper is connected into the red list.
+                                                         0x3 = Pruned - shaper is disconnected. */
 	uint64_t pir_accum                    : 26; /**< Peak information rate accumulator. Debug access to the live PIR accumulator. */
 	uint64_t cir_accum                    : 26; /**< Committed information rate accumulator. Debug access to the live CIR accumulator. */
 #else
@@ -4874,6 +4874,9 @@ typedef union cvmx_pko_l1_sqx_shape cvmx_pko_l1_sqx_shape_t;
 
 /**
  * cvmx_pko_l1_sq#_shape_state
+ *
+ * This register must not be written during normal operation.
+ *
  */
 union cvmx_pko_l1_sqx_shape_state {
 	uint64_t u64;
@@ -4882,9 +4885,9 @@ union cvmx_pko_l1_sqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
 	uint64_t color2                       : 1;  /**< Same value as COLOR. */
-	uint64_t color                        : 1;  /**< Shaper color status. Debug access to the live shaper state.
-                                                         0 = Green - operating in 'committed' range.
-                                                         1 = Red - operating in 'oversubscribed' range or inactive. */
+	uint64_t color                        : 1;  /**< Shaper connection status. Debug access to the live shaper state.
+                                                         0 = Connected - shaper is connected.
+                                                         1 = Pruned - shaper is disconnected. */
 	uint64_t reserved_26_51               : 26;
 	uint64_t cir_accum                    : 26; /**< Committed information rate accumulator. Debug access to the live CIR accumulator. */
 #else
@@ -4901,9 +4904,9 @@ union cvmx_pko_l1_sqx_shape_state {
 	uint64_t reserved_60_63               : 4;
 	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
 	uint64_t reserved_53_53               : 1;
-	uint64_t color                        : 1;  /**< Shaper color status. Debug access to the live shaper state.
-                                                         0 = Green - operating in 'committed' range.
-                                                         1 = Red - operating in 'oversubscribed' range or inactive. */
+	uint64_t color                        : 1;  /**< Shaper connection status. Debug access to the live shaper state.
+                                                         0 = Connected - shaper is connected.
+                                                         1 = Pruned - shaper is disconnected. */
 	uint64_t reserved_26_51               : 26;
 	uint64_t cir_accum                    : 26; /**< Committed information rate accumulator. Debug access to the live CIR accumulator. */
 #else
@@ -5594,8 +5597,8 @@ union cvmx_pko_l2_sqx_shape {
                                                          transitions when set. Not used by hardware when [RED_ALGO]/PKO_SEND_EXT_S[RA]=0x2/STALL
                                                          nor when corresponding PKO_*_PIR[ENABLE] is clear. */
 	uint64_t red_algo                     : 2;  /**< Shaper red state algorithm when not specified by the PKO SEND. Used by hardware
-                                                         only when the shaper is in RED state. (RED state is when
-                                                         PKO_*_SHAPE_STATE[COLOR]=0x2). When PKO_SEND_EXT_S[RA]!=STD (!=0) for a
+                                                         only when the shaper is in RED state. (A shaper is in RED state when
+                                                         PKO_*_SHAPE_STATE[PIR_ACCUM] is negative.) When PKO_SEND_EXT_S[RA]!=STD (!=0) for a
                                                          packet, this [RED_ALGO] is not used, and PKO_SEND_EXT_S[RA] instead defines
                                                          the shaper red state algorithm used for the packet. The
                                                          encoding for the [RED_ALGO]/PKO_SEND_EXT_S[RA] that is used:
@@ -5644,8 +5647,8 @@ union cvmx_pko_l2_sqx_shape {
                                                          transitions when set. Not used by hardware when [RED_ALGO]/PKO_SEND_EXT_S[RA]=0x2/STALL
                                                          nor when corresponding PKO_*_PIR[ENABLE] is clear. */
 	uint64_t red_algo                     : 2;  /**< Shaper red state algorithm when not specified by the PKO SEND. Used by hardware
-                                                         only when the shaper is in RED state. (RED state is when
-                                                         PKO_*_SHAPE_STATE[COLOR]=0x2). When PKO_SEND_EXT_S[RA]!=STD (!=0) for a
+                                                         only when the shaper is in RED state. (A shaper is in RED state when
+                                                         PKO_*_SHAPE_STATE[PIR_ACCUM] is negative.) When PKO_SEND_EXT_S[RA]!=STD (!=0) for a
                                                          packet, this [RED_ALGO] is not used, and PKO_SEND_EXT_S[RA] instead defines
                                                          the shaper red state algorithm used for the packet. The
                                                          encoding for the [RED_ALGO]/PKO_SEND_EXT_S[RA] that is used:
@@ -5687,6 +5690,9 @@ typedef union cvmx_pko_l2_sqx_shape cvmx_pko_l2_sqx_shape_t;
 
 /**
  * cvmx_pko_l2_sq#_shape_state
+ *
+ * This register must not be written during normal operation.
+ *
  */
 union cvmx_pko_l2_sqx_shape_state {
 	uint64_t u64;
@@ -5694,11 +5700,11 @@ union cvmx_pko_l2_sqx_shape_state {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
-	uint64_t color                        : 2;  /**< Shaper color status. Debug access to the live shaper state.
-                                                         0x0 = Green - operating in 'committed' range.
-                                                         0x1 = Yellow - operating in 'excess/peak' range.
-                                                         0x2 = Red - operating in 'oversubscribed' range.
-                                                         0x3 = Reserved. */
+	uint64_t color                        : 2;  /**< Shaper connection status. Debug access to the live shaper state.
+                                                         0x0 = Green - shaper is connected into the green list.
+                                                         0x1 = Yellow - shaper is connected into the yellow list.
+                                                         0x2 = Red - shaper is connected into the red list.
+                                                         0x3 = Pruned - shaper is disconnected. */
 	uint64_t pir_accum                    : 26; /**< Peak information rate accumulator. Debug access to the live PIR accumulator. */
 	uint64_t cir_accum                    : 26; /**< Committed information rate accumulator. Debug access to the live CIR accumulator. */
 #else
@@ -6386,7 +6392,7 @@ typedef union cvmx_pko_l3_sqx_shape cvmx_pko_l3_sqx_shape_t;
  * cvmx_pko_l3_sq#_shape_state
  *
  * This register has the same bit fields as PKO_L2_SQ()_SHAPE_STATE.
- *
+ * This register must not be written during normal operation.
  */
 union cvmx_pko_l3_sqx_shape_state {
 	uint64_t u64;
@@ -6394,11 +6400,11 @@ union cvmx_pko_l3_sqx_shape_state {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
-	uint64_t color                        : 2;  /**< Shaper color status. Debug access to the live shaper state.
-                                                         0x0 = Green - operating in 'committed' range.
-                                                         0x1 = Yellow - operating in 'excess/peak' range.
-                                                         0x2 = Red - operating in 'oversubscribed' range.
-                                                         0x3 = Reserved. */
+	uint64_t color                        : 2;  /**< Shaper connection status. Debug access to the live shaper state.
+                                                         0x0 = Green - shaper is connected into the green list.
+                                                         0x1 = Yellow - shaper is connected into the yellow list.
+                                                         0x2 = Red - shaper is connected into the red list.
+                                                         0x3 = Pruned - shaper is disconnected. */
 	uint64_t pir_accum                    : 26; /**< Peak information rate accumulator. Debug access to the live PIR accumulator. */
 	uint64_t cir_accum                    : 26; /**< Committed information rate accumulator. Debug access to the live CIR accumulator. */
 #else
@@ -6961,7 +6967,7 @@ typedef union cvmx_pko_l4_sqx_shape cvmx_pko_l4_sqx_shape_t;
  * cvmx_pko_l4_sq#_shape_state
  *
  * This register has the same bit fields as PKO_L2_SQ()_SHAPE_STATE.
- *
+ * This register must not be written during normal operation.
  */
 union cvmx_pko_l4_sqx_shape_state {
 	uint64_t u64;
@@ -6969,11 +6975,11 @@ union cvmx_pko_l4_sqx_shape_state {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
-	uint64_t color                        : 2;  /**< Shaper color status. Debug access to the live shaper state.
-                                                         0x0 = Green - operating in 'committed' range.
-                                                         0x1 = Yellow - operating in 'excess/peak' range.
-                                                         0x2 = Red - operating in 'oversubscribed' range.
-                                                         0x3 = Reserved. */
+	uint64_t color                        : 2;  /**< Shaper connection status. Debug access to the live shaper state.
+                                                         0x0 = Green - shaper is connected into the green list.
+                                                         0x1 = Yellow - shaper is connected into the yellow list.
+                                                         0x2 = Red - shaper is connected into the red list.
+                                                         0x3 = Pruned - shaper is disconnected. */
 	uint64_t pir_accum                    : 26; /**< Peak information rate accumulator. Debug access to the live PIR accumulator. */
 	uint64_t cir_accum                    : 26; /**< Committed information rate accumulator. Debug access to the live CIR accumulator. */
 #else
@@ -7495,7 +7501,7 @@ typedef union cvmx_pko_l5_sqx_shape cvmx_pko_l5_sqx_shape_t;
  * cvmx_pko_l5_sq#_shape_state
  *
  * This register has the same bit fields as PKO_L2_SQ()_SHAPE_STATE.
- *
+ * This register must not be written during normal operation.
  */
 union cvmx_pko_l5_sqx_shape_state {
 	uint64_t u64;
@@ -7503,11 +7509,11 @@ union cvmx_pko_l5_sqx_shape_state {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
 	uint64_t tw_timestamp                 : 6;  /**< Time-wheel timestamp. Debug access to the live time-wheel timestamp. */
-	uint64_t color                        : 2;  /**< Shaper color status. Debug access to the live shaper state.
-                                                         0x0 = Green - operating in 'committed' range.
-                                                         0x1 = Yellow - operating in 'excess/peak' range.
-                                                         0x2 = Red - operating in 'oversubscribed' range.
-                                                         0x3 = Reserved. */
+	uint64_t color                        : 2;  /**< Shaper connection status. Debug access to the live shaper state.
+                                                         0x0 = Green - shaper is connected into the green list.
+                                                         0x1 = Yellow - shaper is connected into the yellow list.
+                                                         0x2 = Red - shaper is connected into the red list.
+                                                         0x3 = Pruned - shaper is disconnected. */
 	uint64_t pir_accum                    : 26; /**< Peak information rate accumulator. Debug access to the live PIR accumulator. */
 	uint64_t cir_accum                    : 26; /**< Committed information rate accumulator. Debug access to the live CIR accumulator. */
 #else
@@ -7695,7 +7701,7 @@ typedef union cvmx_pko_l5_sqb_debug cvmx_pko_l5_sqb_debug_t;
  * MAC_NUM   Range         PKO_LUT index   Description
  * -------   -----------   -------------   -----------------
  *     0     0x000-0x03F   0x040-0x07F     LBK Loopback
- *     1     0x100-0x17F   0x080-0xoFF     DPI packet output
+ *     1     0x100-0x13F   0x080-0x0BF     DPI packet output
  *     2     0x800-0x80F   0x000-0x00F     BGX0 Logical MAC 0
  *     3     0x810-0x81F   0x010-0x01F     BGX0 Logical MAC 1
  *     4     0x820-0x82F   0x020-0x02F     BGX0 Logical MAC 2
@@ -13174,7 +13180,7 @@ union cvmx_pko_peb_err_int {
 	uint64_t peb_trunc_err                : 1;  /**< Asserted when a PD has truncated data. Throws PKO_INTSN_E::PEB_TRUNC_ERR. */
 	uint64_t peb_pad_err                  : 1;  /**< Asserted when a PD has data padded to it (SEND_HDR[TOTAL] < sum(SEND_DATA[size])). Throws
                                                          PKO_INTSN_E::PEB_PAD_ERR. */
-	uint64_t peb_pse_fifo_err             : 1;  /**< Asserted when PSE sends PD information for a nonconfigured FIFO. Throws
+	uint64_t peb_pse_fifo_err             : 1;  /**< Asserted when PSE sends PD information for a nonconfigured LINK. Throws
                                                          PKO_INTSN_E::PEB_PSE_FIFO_ERR. */
 	uint64_t peb_fcs_sop_err              : 1;  /**< Asserted when FCS SOP value greater than packet size detected. Throws
                                                          PKO_INTSN_E::PEB_FCS_SOP_ERR. */
@@ -13379,6 +13385,21 @@ union cvmx_pko_peb_pse_fifo_err_info {
 	uint64_t u64;
 	struct cvmx_pko_peb_pse_fifo_err_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t link                         : 5;  /**< LINK number associated with the captured PEB_PSE_FIFO_ERR. */
+	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_PSE_FIFO_ERR] is set. */
+	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_PSE_FIFO_ERR. */
+	uint64_t chan                         : 12; /**< Channel number associated with the captured PEB_PSE_FIFO_ERR. */
+#else
+	uint64_t chan                         : 12;
+	uint64_t fifo                         : 7;
+	uint64_t val                          : 1;
+	uint64_t link                         : 5;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} s;
+	struct cvmx_pko_peb_pse_fifo_err_info_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t val                          : 1;  /**< Asserted when PKO_PEB_ERR_INT[PEB_PSE_FIFO_ERR] is set. */
 	uint64_t fifo                         : 7;  /**< FIFO number associated with the captured PEB_PSE_FIFO_ERR. */
@@ -13389,9 +13410,8 @@ union cvmx_pko_peb_pse_fifo_err_info {
 	uint64_t val                          : 1;
 	uint64_t reserved_20_63               : 44;
 #endif
-	} s;
-	struct cvmx_pko_peb_pse_fifo_err_info_s cn73xx;
-	struct cvmx_pko_peb_pse_fifo_err_info_s cn78xx;
+	} cn73xx;
+	struct cvmx_pko_peb_pse_fifo_err_info_cn73xx cn78xx;
 	struct cvmx_pko_peb_pse_fifo_err_info_s cn78xxp2;
 	struct cvmx_pko_peb_pse_fifo_err_info_s cnf75xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index 77ec29b..bb60640 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -987,6 +987,8 @@ extern void cvmx_pko3_dq_options(unsigned node, unsigned dq, bool min_pad);
 extern int cvmx_pko3_port_fifo_size(unsigned int xiface, unsigned index);
 extern int cvmx_pko3_channel_credit_level(int node,
 	enum cvmx_pko3_level_e level);
+extern int cvmx_pko3_port_xoff(unsigned int xiface, unsigned index);
+extern int cvmx_pko3_port_xon(unsigned int xiface, unsigned index);
 
 /* Packet descriptor - PKO3 command buffer + internal state */
 typedef struct cvmx_pko3_pdesc_s {
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index d338230..ca47b82 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 118803 $<hr>
+ * <hr>$Revision: 119797 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
@@ -209,7 +209,7 @@ enum cvmx_qlm_mode {
 	CVMX_QLM_MODE_RGMII_XLAUI,
 	CVMX_QLM_MODE_RGMII_40G_KR4,
 	CVMX_QLM_MODE_MIXED,      /* BGX2 is mixed mode, DLM5(SGMII) & DLM6(XFI) */
-	CVMX_QLM_MODE_SGMII_1X2,  /* Configure BGX2 separate for DLM5 & DLM6 */ 
+	CVMX_QLM_MODE_SGMII_2X1,  /* Configure BGX2 separate for DLM5 & DLM6 */ 
 	CVMX_QLM_MODE_10G_KR_1X2, /* Configure BGX2 separate for DLM5 & DLM6 */
 	CVMX_QLM_MODE_XFI_1X2,    /* Configure BGX2 separate for DLM5 & DLM6 */
 	CVMX_QLM_MODE_RGMII_SGMII_1X1, /* Configure BGX2, applies to DLM5 */
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index da6c480..37b6e95 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -135,6 +135,17 @@ static inline uint64_t CVMX_RST_CTLX(unsigned long offset)
 #define CVMX_RST_CTLX(offset) (CVMX_ADD_IO_SEG(0x0001180006001640ull) + ((offset) & 3) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_RST_DEBUG CVMX_RST_DEBUG_FUNC()
+static inline uint64_t CVMX_RST_DEBUG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_RST_DEBUG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800060017B0ull);
+}
+#else
+#define CVMX_RST_DEBUG (CVMX_ADD_IO_SEG(0x00011800060017B0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_RST_DELAY CVMX_RST_DELAY_FUNC()
 static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 {
@@ -303,16 +314,17 @@ union cvmx_rst_boot {
 	struct cvmx_rst_boot_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t chipkill                     : 1;  /**< A 0->1 transition of CHIPKILL starts the CHIPKILL timer. When CHIPKILL=1 and the timer
-                                                         expires, internal chip reset is asserted forever until the next chip reset. The CHIPKILL
-                                                         timer can be stopped only by a chip (cold, warm, soft) reset. The length of the CHIPKILL
-                                                         timer is specified by RST_CKILL[TIMER]. */
+                                                         expires, chip reset is asserted internally. The CHIPKILL timer can be stopped only by
+                                                         a reset (cold, warm, soft). The length of the CHIPKILL timer is specified by
+                                                         RST_CKILL[TIMER].  This bit and timer function as a delayed warm reset. */
 	uint64_t jtcsrdis                     : 1;  /**< When set, internal CSR access via JTAG TAP controller is disabled This field resets to 1
                                                          in Authentik mode, else 0. */
 	uint64_t ejtagdis                     : 1;  /**< When set, external EJTAG access is disabled. This field resets to 1 in Authentik mode, else 0. */
 	uint64_t romen                        : 1;  /**< When set, Authentik/eMMC boot ROM is visible in the boot bus address space. This field
                                                          resets to 1 in an Authentik part or when booting from eMMC/SD or SPI. Else, resets to 0. */
-	uint64_t ckill_ppdis                  : 1;  /**< When set, cores other than 0 are disabled during a CHIPKILL.  Writes have no effect when
-                                                         RST_BOOT[CHIPKILL]=1. */
+	uint64_t ckill_ppdis                  : 1;  /**< Chipkill Core Disable.  When set to 1, cores other than core 0 will immediately be
+                                                         disabled
+                                                         when RST_BOOT[CHIPKILL] is set.  Writes have no effect when RST_BOOT[CHIPKILL]=1. */
 	uint64_t jt_tstmode                   : 1;  /**< JTAG test mode. */
 	uint64_t vrm_err                      : 1;  /**< VRM did not complete operations within 5.25mS of DCOK being asserted. PLLs were released
                                                          automatically. */
@@ -343,8 +355,8 @@ union cvmx_rst_boot {
                                                          <10> = Soft reset due to RST_SOFT_RST write.
                                                          <9> = Warm reset due to Cntl1 link-down or hot-reset.
                                                          <8> = Warm reset due to Cntl0 link-down or hot-reset.
-                                                         <7> = Cntl0 reset due to PERST0_L pin.
-                                                         <6> = Cntl1 reset due to PERST1_L pin.
+                                                         <7> = Cntl1 reset due to PERST1_L pin.
+                                                         <6> = Cntl0 reset due to PERST0_L pin.
                                                          <5> = Warm reset due to PERST1_L pin.
                                                          <4> = Warm reset due to PERST0_L pin.
                                                          <3> = Warm reset due to CHIP_RESET_L pin.
@@ -580,6 +592,28 @@ union cvmx_rst_ctlx {
 typedef union cvmx_rst_ctlx cvmx_rst_ctlx_t;
 
 /**
+ * cvmx_rst_debug
+ *
+ * Added in pass 2.
+ *
+ */
+union cvmx_rst_debug {
+	uint64_t u64;
+	struct cvmx_rst_debug_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t clk_on                       : 1;  /**< Force conditional clock used for interrupt logic to always be on. For diagnostic use only. */
+#else
+	uint64_t clk_on                       : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_rst_debug_s               cn78xxp2;
+	struct cvmx_rst_debug_s               cnf75xx;
+};
+typedef union cvmx_rst_debug cvmx_rst_debug_t;
+
+/**
  * cvmx_rst_delay
  */
 union cvmx_rst_delay {
@@ -612,6 +646,9 @@ typedef union cvmx_rst_delay cvmx_rst_delay_t;
 
 /**
  * cvmx_rst_eco
+ *
+ * Added in pass 2.
+ *
  */
 union cvmx_rst_eco {
 	uint64_t u64;
@@ -625,7 +662,6 @@ union cvmx_rst_eco {
 #endif
 	} s;
 	struct cvmx_rst_eco_s                 cn73xx;
-	struct cvmx_rst_eco_s                 cn78xx;
 	struct cvmx_rst_eco_s                 cn78xxp2;
 	struct cvmx_rst_eco_s                 cnf75xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 6183bba..6e197ca 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -1548,7 +1548,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 #define CVMX_SLI_PKT_IN_JABBER CVMX_SLI_PKT_IN_JABBER_FUNC()
 static inline uint64_t CVMX_SLI_PKT_IN_JABBER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_IN_JABBER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029170ull);
 }
@@ -3021,8 +3021,12 @@ union cvmx_sli_ctl_status {
 	struct cvmx_sli_ctl_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t m2s1_ncbi                    : 4;  /**< Contains the IOBI that traffic from M2S1 is placed on. Values 2-15 are reserved. */
-	uint64_t m2s0_ncbi                    : 4;  /**< Contains the IOBI that traffic from M2S0 is placed on. Values 2-15 are reserved. */
+	uint64_t m2s1_ncbi                    : 4;  /**< Contains the IOBI that traffic (inbound BAR1/BAR2 posted writes, inbound BAR1/BAR2
+                                                         non-posted reads, outbound BAR1/BAR2 completions, and inbound CPU completions)
+                                                         from MAC2 and MAC3 is placed on. Values 2-15 are reserved. */
+	uint64_t m2s0_ncbi                    : 4;  /**< Contains the IOBI that traffic  (inbound BAR1/BAR2 posted writes, inbound BAR1/BAR2
+                                                         non-posted reads, outbound BAR1/BAR2 completions, and inbound CPU completions)
+                                                         from MAC0 and MAC1 is placed on.  Values 2-15 are reserved. */
 	uint64_t oci_id                       : 4;  /**< The CCPI ID. */
 	uint64_t p1_ntags                     : 6;  /**< Number of tags available for MAC port 1.
                                                          In RC mode, one tag is needed for each outbound TLP that requires a CPL TLP.
@@ -6178,9 +6182,7 @@ union cvmx_sli_mem_access_ctl {
 	uint64_t reserved_14_63               : 50;
 	uint64_t max_word                     : 4;  /**< Maximum number of words. Specifies the maximum number of words to merge into a single
                                                          write operation from the cores to the MAC. Legal values are 1 to 16, with 0 treated as 16. */
-	uint64_t timer                        : 10; /**< Merge timer. When the SLI starts a core-to-MAC write, TIMER specifies the maximum wait, in
-                                                         coprocessor-clock cycles, to merge additional write operations from the cores into one
-                                                         large write. The values for this field range from 1 to 1024, with 0 treated as 1024. */
+	uint64_t timer                        : 10; /**< N/A */
 #else
 	uint64_t timer                        : 10;
 	uint64_t max_word                     : 4;
@@ -8767,7 +8769,7 @@ typedef union cvmx_sli_pkt_bist_status cvmx_sli_pkt_bist_status_t;
  *
  * This register specifies which output packet rings are interrupting because of packet counters.
  * A bit set in this interrupt register will set a corresponding bit in SLI_PKT_INT and can
- * also cause SLI_INT_SUM[PCNT] to be set if SLI_PKT()_OUTPUT_CONTROL[CENB] is set.
+ * also cause SLI_MAC()_PF()_INT_SUM[PCNT] to be set if SLI_PKT()_OUTPUT_CONTROL[CENB] is set.
  * When read by a function, this register informs which rings owned by the function (0 to N,
  * N as large as 63) have this interrupt pending.
  */
@@ -9080,33 +9082,7 @@ union cvmx_sli_pkt_gbl_control {
 #endif
 	} s;
 	struct cvmx_sli_pkt_gbl_control_s     cn73xx;
-	struct cvmx_sli_pkt_gbl_control_cnf75xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_32_63               : 32;
-	uint64_t qtime                        : 16; /**< After a packet ring is disabled on the assertion of SLI_PKT()_INPUT_CONTROL[RST],
-                                                         the hardware will set the SLI_PKT()_INPUT_CONTROL[QUIET] bit
-                                                         after at least [QTIME] * 1024 cycles. */
-	uint64_t reserved_14_15               : 2;
-	uint64_t bpkind                       : 6;  /**< PKIND sent to PKI when DPI_PKT_INST_HDR_S[PKIND] corresponding bit in
-                                                         SLI_PKT_PKIND_VALID[ENB] is set to a 0. */
-	uint64_t reserved_3_7                 : 5;
-	uint64_t bpflr_d                      : 1;  /**< Disables clearing SLI_PKT_OUT_BP_EN bit on an FLR. */
-	uint64_t noptr_d                      : 1;  /**< Disables putting a ring into reset when a packet is received from PKO and
-                                                         the associated ring has no doorbells to send the packet out.
-                                                         SLI_PKT_IN_DONE()_CNTS[CNT] when written. */
-	uint64_t picnt_d                      : 1;  /**< Disables the subtraction of SLI_PKT_IN_DONE()_CNTS[CNT] from
-                                                         SLI_PKT_IN_DONE()_CNTS[CNT] when written. */
-#else
-	uint64_t picnt_d                      : 1;
-	uint64_t noptr_d                      : 1;
-	uint64_t bpflr_d                      : 1;
-	uint64_t reserved_3_7                 : 5;
-	uint64_t bpkind                       : 6;
-	uint64_t reserved_14_15               : 2;
-	uint64_t qtime                        : 16;
-	uint64_t reserved_32_63               : 32;
-#endif
-	} cnf75xx;
+	struct cvmx_sli_pkt_gbl_control_s     cnf75xx;
 };
 typedef union cvmx_sli_pkt_gbl_control cvmx_sli_pkt_gbl_control_t;
 
@@ -9335,6 +9311,7 @@ union cvmx_sli_pkt_in_jabber {
 #endif
 	} s;
 	struct cvmx_sli_pkt_in_jabber_s       cn73xx;
+	struct cvmx_sli_pkt_in_jabber_s       cnf75xx;
 };
 typedef union cvmx_sli_pkt_in_jabber cvmx_sli_pkt_in_jabber_t;
 
@@ -10763,14 +10740,16 @@ union cvmx_sli_pp_pkt_csr_control {
 	uint64_t u64;
 	struct cvmx_sli_pp_pkt_csr_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_16_63               : 48;
+	uint64_t reserved_18_63               : 46;
+	uint64_t mac                          : 2;  /**< MAC number to use on a PP register accesses to SLI Packet CSRs. */
 	uint64_t pvf                          : 16; /**< Function number to use on a PP register accesses to SLI Packet CSRs,
                                                          where <15:13> selects the PF the
                                                          VF belongs to, and <12:0> selects the VF within that PF (or 0x0 for the PF
                                                          itself). */
 #else
 	uint64_t pvf                          : 16;
-	uint64_t reserved_16_63               : 48;
+	uint64_t mac                          : 2;
+	uint64_t reserved_18_63               : 46;
 #endif
 	} s;
 	struct cvmx_sli_pp_pkt_csr_control_s  cn73xx;
@@ -10843,7 +10822,6 @@ union cvmx_sli_s2m_portx_ctl {
                                                            SLI_MEM_INT_SUM
                                                            SLI_MEM_CTL
                                                            SLI_CTL_PORT(0..3)
-                                                           SLI_NQM_RSP_ERR_SND_DBG
                                                            SLI_PKT_MEM_CTL */
 	uint64_t reserved_0_2                 : 3;
 #else
diff --git a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
index 0403ae9d..c07def3 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
@@ -4430,8 +4430,8 @@ typedef union cvmx_sriomaintx_m2s_bar0_start0 cvmx_sriomaintx_m2s_bar0_start0_t;
  * has not already been mapped to SRIO Maintenance Space through the SRIOMAINT_LCS_BA[1:0]
  * registers, if ENABLE is set and the address bits match then the SRIO Memory transactions
  * will map to Octeon SLI Registers.  34-bit address transactions require a match in SRIO
- * Address 33:14 and require all the other bits in ADDR48, ADDR64 and ADDR66 fields to be zero.
- * 50-bit address transactions a match of SRIO Address 49:14 and require all the other bits of
+ * Address 33:24 and require all the other bits in ADDR48, ADDR64 and ADDR66 fields to be zero.
+ * 50-bit address transactions a match of SRIO Address 49:24 and require all the other bits of
  * ADDR64 and ADDR66 to be zero.  66-bit address transactions require matches of all valid
  * address
  * field bits.  Reads and  Writes through Bar0 have a size limit of 8 bytes and cannot cross
@@ -4445,21 +4445,43 @@ union cvmx_sriomaintx_m2s_bar0_start1 {
 	uint32_t u32;
 	struct cvmx_sriomaintx_m2s_bar0_start1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t addr32                       : 18; /**< SRIO address 31:14. */
-	uint32_t reserved_3_13                : 11;
+	uint32_t reserved_3_31                : 29;
 	uint32_t addr66                       : 2;  /**< SRIO address 65:64. */
 	uint32_t enable                       : 1;  /**< Enable BAR0 access. */
 #else
 	uint32_t enable                       : 1;
 	uint32_t addr66                       : 2;
+	uint32_t reserved_3_31                : 29;
+#endif
+	} s;
+	struct cvmx_sriomaintx_m2s_bar0_start1_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t addr32                       : 18; /**< SRIO Address 31:14 */
+	uint32_t reserved_3_13                : 11;
+	uint32_t addr66                       : 2;  /**< SRIO Address 65:64 */
+	uint32_t enable                       : 1;  /**< Enable BAR0 Access */
+#else
+	uint32_t enable                       : 1;
+	uint32_t addr66                       : 2;
 	uint32_t reserved_3_13                : 11;
 	uint32_t addr32                       : 18;
 #endif
-	} s;
-	struct cvmx_sriomaintx_m2s_bar0_start1_s cn63xx;
-	struct cvmx_sriomaintx_m2s_bar0_start1_s cn63xxp1;
-	struct cvmx_sriomaintx_m2s_bar0_start1_s cn66xx;
-	struct cvmx_sriomaintx_m2s_bar0_start1_s cnf75xx;
+	} cn63xx;
+	struct cvmx_sriomaintx_m2s_bar0_start1_cn63xx cn63xxp1;
+	struct cvmx_sriomaintx_m2s_bar0_start1_cn63xx cn66xx;
+	struct cvmx_sriomaintx_m2s_bar0_start1_cnf75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t addr32                       : 8;  /**< SRIO address 31:24. */
+	uint32_t reserved_3_23                : 21;
+	uint32_t addr66                       : 2;  /**< SRIO address 65:64. */
+	uint32_t enable                       : 1;  /**< Enable BAR0 access. */
+#else
+	uint32_t enable                       : 1;
+	uint32_t addr66                       : 2;
+	uint32_t reserved_3_23                : 21;
+	uint32_t addr32                       : 8;
+#endif
+	} cnf75xx;
 };
 typedef union cvmx_sriomaintx_m2s_bar0_start1 cvmx_sriomaintx_m2s_bar0_start1_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
index f9ffcf1..8a2c1e5 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
@@ -836,19 +836,19 @@ union cvmx_sriox_acc_ctrl {
 	struct cvmx_sriox_acc_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t deny_adr2                    : 1;  /**< Deny SRIO write access to SRIO address fields in
-                                                         SRIOMAINT()_BAR2* registers. */
-	uint64_t deny_adr1                    : 1;  /**< Deny SRIO write access to SRIO address fields in
-                                                         SRIOMAINT()_BAR1* registers. */
-	uint64_t deny_adr0                    : 1;  /**< Deny SRIO write access to SRIO address fields in
-                                                         SRIOMAINT()_BAR0* registers. */
+	uint64_t deny_adr2                    : 1;  /**< Deny SRIO write access to SRIO address fields in SRIOMAINT()_BAR2* registers. */
+	uint64_t deny_adr1                    : 1;  /**< Deny SRIO write access to SRIO address fields in SRIOMAINT()_BAR1* registers. */
+	uint64_t deny_adr0                    : 1;  /**< Deny SRIO write access to SRIO address fields in SRIOMAINT()_BAR0* registers. */
 	uint64_t reserved_3_3                 : 1;
-	uint64_t deny_bar2                    : 1;  /**< Deny SRIO write access to non-SRIO address fields
-                                                         in the SRIOMAINT_BAR2 registers. */
-	uint64_t deny_bar1                    : 1;  /**< Deny SRIO write access to non-SRIO address fields
-                                                         in the SRIOMAINT_BAR1 registers. */
-	uint64_t deny_bar0                    : 1;  /**< Deny SRIO write access to non-SRIO address fields
-                                                         in the SRIOMAINT_BAR0 registers. */
+	uint64_t deny_bar2                    : 1;  /**< Deny SRIO write access to non-SRIO address fields in the SRIOMAINT_BAR2 registers.
+                                                         This field is set during mac reset while in authentik mode and typically
+                                                         cleared once link partner has been validated. */
+	uint64_t deny_bar1                    : 1;  /**< Deny SRIO write access to non-SRIO address fields in the SRIOMAINT_BAR1 registers.
+                                                         This field is set during mac reset while in authentik mode and typically
+                                                         cleared once link partner has been validated. */
+	uint64_t deny_bar0                    : 1;  /**< Deny SRIO write access to non-SRIO address fields in the SRIOMAINT_BAR0 registers.
+                                                         This field is set during mac reset while in authentik mode and typically
+                                                         cleared once link partner has been validated. */
 #else
 	uint64_t deny_bar0                    : 1;
 	uint64_t deny_bar1                    : 1;
@@ -3888,7 +3888,7 @@ union cvmx_sriox_rx_bell {
                                                          Count must be > 0x0 for entry to be valid. */
 	uint64_t reserved_5_7                 : 3;
 	uint64_t dest_id                      : 1;  /**< Destination device ID. 0=Primary, 1=Secondary. */
-	uint64_t id16                         : 1;  /**< Transaction type, 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t id16                         : 1;  /**< Transaction type. 0=use ID[7:0], 1=use ID[15:0]. */
 	uint64_t reserved_0_2                 : 3;
 #else
 	uint64_t reserved_0_2                 : 3;
@@ -3936,7 +3936,7 @@ union cvmx_sriox_rx_bell {
                                                          Count must be > 0x0 for entry to be valid. */
 	uint64_t reserved_5_7                 : 3;
 	uint64_t dest_id                      : 1;  /**< Destination device ID. 0=Primary, 1=Secondary. */
-	uint64_t id16                         : 1;  /**< Transaction type, 0=use ID[7:0], 1=use ID[15:0]. */
+	uint64_t id16                         : 1;  /**< Transaction type. 0=use ID[7:0], 1=use ID[15:0]. */
 	uint64_t reserved_2_2                 : 1;
 	uint64_t prior                        : 2;  /**< Doorbell priority. */
 #else
@@ -3973,8 +3973,7 @@ union cvmx_sriox_rx_bell_ctrl {
                                                                SRIO()_RX_BELL and SRIO()_RX_BELL_SEQ
                                                          For all other values Doorbell FIFOs can be
                                                          accessed by reading DPI_SRIO_RX_BELL and
-                                                         DPI_SRIO_RX_BELL_SEQ and status can be found in
-                                                         CIU_SRIO_BELL_STATUS.
+                                                         DPI_SRIO_RX_BELL_SEQ.
                                                          0x1 = Single 128 entry FIFO.
                                                          0x2 = Two 64 entry FIFOs.
                                                          0x3 = Four 32 entry FIFOs.
-- 
2.6.2

