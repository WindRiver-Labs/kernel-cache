From 80e3578fd3ae3627ae5a05419f555ea098d4daaf Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Wed, 6 Nov 2013 14:11:10 -0800
Subject: [PATCH 380/974] MIPS: simplify octeon power throttle support

Drop all deadlock-prone CVMX_L2C_COP0_* access,
leaving just the smp_call_function() mechanism.
Drop the clutter of .../state attribute, which exposes too much
volatile implementation detail.
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-power-throttle.c | 118 +++++-------------------
 1 file changed, 21 insertions(+), 97 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-power-throttle.c b/arch/mips/cavium-octeon/octeon-power-throttle.c
index 0bf895d..36e5a2e 100644
--- a/arch/mips/cavium-octeon/octeon-power-throttle.c
+++ b/arch/mips/cavium-octeon/octeon-power-throttle.c
@@ -56,7 +56,7 @@ union octeon_power_throttle_bits {
 	} s;
 };
 
-/* where possible, ask target CPU to access own registers ... */
+/* IPI calls to ask target CPU to access own registers ... */
 static inline void read_my_power_throttle(void *info)
 {
 	*(u64*)info = __read_64bit_c0_register($11, 6);
@@ -69,68 +69,14 @@ static inline void write_my_power_throttle(void *info)
 
 /*
  * Read/Write POW_THROTTLE.
- * Use IPI to owning cpu if possible (always).
- *
- * Includes tested, unused code for cross-core access
- * (by CVMX_L2C_COP0_ADR/CVMX_L2C_COP0_DAT on cn7xxx,
- * or CVMX_L2C_COP0_MAP on older octeons), 
- * but not needed unless for low-power init (when other cpu may be disabled)
- * or broadcast (cpu < 0).
  */
 static void octeon_power_throttle_csr_op(int cpu,
 	union octeon_power_throttle_bits *r, bool write)
 {
-	bool use_ipi;
-
-	get_online_cpus();
-
-	use_ipi = (cpu >= 0 && cpu_online(cpu));
-
-	if (use_ipi) {
-		smp_call_function_single(cpu, 
-			(write ? write_my_power_throttle
-			       : read_my_power_throttle),
-			r, 1);
-	} else if (OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-		cvmx_l2c_cop0_adr_t adr = { .u64 = 0, };
-
-		adr.s.ppid = (cpu < 0) ? -1 : octeon_coreid_for_cpu(cpu);
-		adr.s.root = 1;
-		/* pow_throttle: register 11 select 6 */
-		adr.s.rd = 11;
-		adr.s.sel = 6;
-
-		/*
-		 * Race Alert: clash with other _ADR/_DAT users possible here,
-		 * which is why the ipi method is preferred ...
-		 */
-		cvmx_write_csr(CVMX_L2C_COP0_ADR, adr.u64);
-
-		if (write)
-			cvmx_write_csr(CVMX_L2C_COP0_DAT, r->raw);
-		else
-			r->raw = cvmx_read_csr(CVMX_L2C_COP0_DAT);
-
-		WARN(0x2bad2bad2bad2bad == r->raw,
-			"CVMX_L2C_COP0_DAT bad read cpu=%d\n", cpu);
-	} else {
-		int ppid = (cpu < 0) ? -1 : octeon_coreid_for_cpu(cpu);
-		/* pow_throttle: register 11 select 6 */
-		u64 reg_reg = 11;
-		u64 reg_sel = 6;
-		u64 reg_num = ((ppid & 0x3f) << 8)
-			| ((reg_reg & 0x1f) << 3)
-			| (reg_sel & 0x7);
-
-		/* no race on older octeons ... */
-		u64 csr_addr = CVMX_L2C_COP0_MAPX(reg_num);
-
-		if (write)
-			cvmx_write_csr(csr_addr, r->raw);
-		else
-			r->raw = cvmx_read_csr(csr_addr);
-	}
-	put_online_cpus();
+	smp_call_function_single(cpu, 
+		(write ? write_my_power_throttle
+		       : read_my_power_throttle),
+		r, 1);
 }
 
 /*
@@ -180,48 +126,31 @@ static int octeon_power_throttle_get_powlim(unsigned int cpu)
 static u64 octeon_power_throttle_set_powlim(int cpu, unsigned long percentage)
 {
 	u64 t;
+	u64 ret = 0;
 	union octeon_power_throttle_bits r;
 
 	if (percentage > 100)
 		return -EINVAL;
 
-	octeon_power_throttle_csr_op(cpu, &r, false);
-	t = r.s.maxpow;
-	if (!OCTEON_IS_MODEL(OCTEON_CN63XX)) {
-		if (t < r.s.hrmpowadj)
-			return -EINVAL;
-		t -= r.s.hrmpowadj;
-	}
-	r.s.powlim = percentage > 0 ? percentage * t / 100 : 0;
-	r.s.ovrrd = 0;		/* MBZ */
-	r.s.distag = 0;		/* MBZ */
-	octeon_power_throttle_csr_op(cpu, &r, true);
-
-	return 0;
-}
-
-static ssize_t octeon_power_throttle_show_state(
-	struct device *dev,
-	struct device_attribute *attr,
-	char *buf)
-{
-	unsigned int cpu = dev->id;
-	bool online;
-	union octeon_power_throttle_bits r;
-
 	get_online_cpus();
-	online = cpu_online(cpu);
-	if (online)
+	if (cpu_online(cpu)) {
 		octeon_power_throttle_csr_op(cpu, &r, false);
+		t = r.s.maxpow;
+		if (!OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+			if (t < r.s.hrmpowadj)
+				ret = -EINVAL;
+			else
+				t -= r.s.hrmpowadj;
+		}
+		r.s.powlim = percentage > 0 ? percentage * t / 100 : 0;
+		r.s.ovrrd = 0;		/* MBZ */
+		r.s.distag = 0;		/* MBZ */
+		if (!ret)
+			octeon_power_throttle_csr_op(cpu, &r, true);
+	}
 	put_online_cpus();
 
-	if (!cpu_online(cpu))
-		return 0;
-
-	return sprintf(buf, "maxpow=%d powe=%d thrott=%d hrmpowadj=%d "
-			    "period=%d powlim=%d max=%d min=%d\n",
-			    r.s.maxpow, r.s.powe, r.s.thrott, r.s.hrmpowadj,
-			    r.s.period, r.s.powlim, r.s.maxthr, r.s.minthr);
+	return 0;
 }
 
 static ssize_t octeon_power_throttle_show_percentage(
@@ -269,13 +198,8 @@ static DEVICE_ATTR(percentage, S_IRUGO | S_IWUSR,
 		   octeon_power_throttle_show_percentage,
 		   octeon_power_throttle_store_percentage);
 
-static DEVICE_ATTR(state, S_IRUGO,
-		   octeon_power_throttle_show_state,
-		   NULL);
-
 static struct attribute *octeon_power_throttle_attrs[] = {
 	&dev_attr_percentage.attr,
-	&dev_attr_state.attr,
 	NULL
 };
 
-- 
2.6.2

