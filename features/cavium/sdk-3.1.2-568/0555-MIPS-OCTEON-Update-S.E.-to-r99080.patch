From 5f612e8e87cfbb0bfd04294d78b392a392ae553e Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sun, 23 Feb 2014 13:46:59 -0800
Subject: [PATCH 555/974] MIPS: OCTEON: Update S.E. to r99080.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bch.c       |  43 ++-
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |  56 ++-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |  15 +-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-helper-bgx.h     |   9 +
 arch/mips/include/asm/octeon/cvmx-ila-defs.h       | 172 +++++-----
 arch/mips/include/asm/octeon/cvmx-ilk-defs.h       | 377 ++++++++++-----------
 arch/mips/include/asm/octeon/cvmx-lapx-defs.h      |  85 +++--
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  54 +--
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  41 ++-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |   6 +-
 arch/mips/include/asm/octeon/cvmx-uctlx-defs.h     | 219 ++++++------
 13 files changed, 604 insertions(+), 477 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index c90a78d..5e2b3f4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -53,7 +53,11 @@
 # include <asm/octeon/cvmx-fpa1.h>
 # include <asm/octeon/cvmx-helper-fpa.h>
 # include <asm/octeon/cvmx-cmd-queue.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
 #elif defined(CVMX_BUILD_FOR_UBOOT)
+
 # include <common.h>
 # include <asm/arch/cvmx.h>
 # include <asm/arch/cvmx-bch-defs.h>
@@ -86,6 +90,7 @@ CVMX_SHARED cvmx_bch_app_config_t bch_config = {
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 extern int cvm_oct_mem_fill_fpa(int pool, int elements);
 extern int cvm_oct_alloc_fpa_pool(int pool, int size);
+static uint8_t *bounce_buff;
 #endif
 
 /**
@@ -103,6 +108,7 @@ int cvmx_bch_initialize(void)
 
 	/* Initialize FPA pool for BCH pool buffers */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	int i;
 	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
 	bch_pool_size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE;
 
@@ -115,7 +121,11 @@ int cvmx_bch_initialize(void)
 		pr_err("cvm_oct_alloc_fpa_pool(%d, %lld)\n", bch_pool, bch_pool_size);
 		return -ENOMEM;
 	}
-	cvm_oct_mem_fill_fpa(bch_pool, 128);
+
+	for (i = 0; i < 16; i++) {
+		cvmx_fpa1_free(kmalloc(bch_pool_size, GFP_KERNEL), bch_pool, 0);
+	}
+	bounce_buff = cvmx_fpa1_alloc(bch_pool);
 #else
 	bch_pool = (int)cvmx_fpa_get_bch_pool();
 	bch_pool_size = cvmx_fpa_get_bch_pool_block_size();
@@ -170,6 +180,7 @@ EXPORT_SYMBOL(cvmx_bch_initialize);
 int cvmx_bch_shutdown(void)
 {
 	cvmx_bch_ctl_t bch_ctl;
+	int bch_pool;
 
 	debug("%s: ENTER\n", __func__);
 	bch_ctl.u64 = cvmx_read_csr(CVMX_BCH_CTL);
@@ -177,8 +188,26 @@ int cvmx_bch_shutdown(void)
 	cvmx_write_csr(CVMX_BCH_CTL, bch_ctl.u64);
 	cvmx_wait(4);
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
+#else
+	bch_pool = (int)cvmx_fpa_get_bch_pool();
+#endif
 	cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_BCH);
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	/* FIXME: BCH cleanup in SE : AJ */
+	{
+		int i;
+		for (i = 0; i < 16; i++) {
+			kfree(cvmx_fpa1_alloc(bch_pool));
+		}
+		cvmx_fpa1_free(bounce_buff, bch_pool, 0);
+	}
+#else
+	cvmx_fpa_shutdown_pool(bch_pool);
+#endif
+	/* AJ: Fix for FPA3 */
 	return 0;
 }
 EXPORT_SYMBOL(cvmx_bch_shutdown);
@@ -228,6 +257,14 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 
 	debug("%s(%p, %u, %u, %p, %p) ENTRY\n", __func__, block, block_size,
 	      ecc_level, ecc, response);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	/* there was a problem when the first argument is used directly
+	 * despite of the fact it was 8-byte aligned (maybe not proper
+	 * cvmx_prt_to_phys), so we copy data to dedicated 'bounce_buff'
+	 * and set command.s.iword.prt to cvmx_ptr_to_phys((void *)bounce_buff)
+	 */
+	memcpy(bounce_buff, block, block_size);
+#endif
 	memset(&result, 0, sizeof(result));
 	memset(&command, 0, sizeof(command));
 	command.s.cword.ecc_gen = CVMX_BCH_INST_ECC_GENERATION;
@@ -235,7 +272,11 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 	command.s.cword.size = block_size;
 
 	command.s.oword.ptr = cvmx_ptr_to_phys(ecc);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	command.s.iword.ptr = cvmx_ptr_to_phys((void *)bounce_buff);
+#else
 	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);
+#endif
 	command.s.resp.ptr = cvmx_ptr_to_phys((void *)response);
 	debug("Command: cword: 0x%llx, oword: 0x%llx, iword: 0x%llx, resp: 0x%llx\n",
 	      command.u64[0], command.u64[1], command.u64[2], command.u64[3]);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index beccd5f..dd8fc82 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -859,9 +859,9 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	/* 3e. Program all other relevant BGX configuration while
 	       BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 0. This includes all things
 	       described in this chapter. */
-	/* Don't add a FCS as PKO does that */
+	/* Always add FCS to PAUSE frames */
 	smu_tx_append.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(index, interface));
-	smu_tx_append.s.fcs_d = 0;
+	smu_tx_append.s.fcs_d = 1;
 	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_APPEND(index, interface), smu_tx_append.u64);
 
 	/* 3f. If Forward Error Correction is desired for 10GBASE-R or 40GBASE-R,
@@ -1088,6 +1088,7 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
+	unsigned credit;
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
@@ -1098,14 +1099,18 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 			cvmx_dprintf("Failed to enable XAUI for BGX(%d,%d)\n", interface, index);
 			return res;
 		}
-		smu_tx_thresh.u64 = 0;
+
+		/* Set credit to 1/4 of actual LMAC FIFO size */
 		if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
 		    || mode == CVMX_HELPER_INTERFACE_MODE_XFI)
-			smu_tx_thresh.s.cnt = 0x100;
+			credit = 2 * 1024 * 1;
 		else if (num_ports == 2)
-			smu_tx_thresh.s.cnt = 0x3ff;
+			credit = 2 * 1024 * 2;
 		else
-			smu_tx_thresh.s.cnt = 0x7ff;
+			credit = 2 * 1024 * 4;
+
+		smu_tx_thresh.u64 = 0;
+		smu_tx_thresh.s.cnt = credit / 16;
 		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_THRESH(index, interface),
 					smu_tx_thresh.u64);
 
@@ -1181,16 +1186,18 @@ int __cvmx_helper_bgx_xaui_link_set(int xipd_port, cvmx_helper_link_info_t link_
 	int index = cvmx_helper_get_interface_index_num(xp.port);
 	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
 	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
+	cvmx_bgxx_spux_status1_t spu_status1;
 
 	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface));
 	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, interface));
+	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface));
 
 	/* If the link shouldn't be up, then just return */
 	if (!link_info.s.link_up)
 		return 0;
 
 	/* Do nothing if both RX and TX are happy */
-	if ((smu_tx_ctl.s.ls == 0) && (smu_rx_ctl.s.status == 0))
+	if ((smu_tx_ctl.s.ls == 0) && (smu_rx_ctl.s.status == 0) && spu_status1.s.rcv_lnk)
 		return 0;
 
 	/* Bring the link up */
@@ -1304,3 +1311,38 @@ void cvmx_helper_bgx_rx_adr_ctl(unsigned node, unsigned interface, unsigned port
 
         cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(port, interface), adr_ctl.u64);
 }
+
+/**
+ * Function to control the generation of FCS, padding by the BGX
+ *
+ */
+void cvmx_helper_bgx_tx_options(unsigned node,
+	unsigned interface, unsigned index,
+	bool fcs_enable,
+	bool pad_enable)
+{
+	cvmx_bgxx_cmrx_config_t cmr_config;
+	cvmx_bgxx_gmp_gmi_txx_append_t gmp_txx_append;
+	cvmx_bgxx_smux_tx_append_t  smu_tx_append;
+
+	cmr_config.u64 = cvmx_read_csr_node(node,
+		CVMX_BGXX_CMRX_CONFIG(index, interface));
+	if (cmr_config.s.lmac_type == 0) {
+		gmp_txx_append.u64 = cvmx_read_csr_node(node,
+			CVMX_BGXX_GMP_GMI_TXX_APPEND(index, interface));
+		gmp_txx_append.s.fcs = fcs_enable;
+		gmp_txx_append.s.pad = pad_enable;
+		cvmx_write_csr_node(node,
+			CVMX_BGXX_GMP_GMI_TXX_APPEND(index, interface),
+			gmp_txx_append.u64);
+	} else {
+		smu_tx_append.u64 = cvmx_read_csr_node(node,
+			CVMX_BGXX_SMUX_TX_APPEND(index, interface));
+		smu_tx_append.s.fcs_c = fcs_enable;
+		smu_tx_append.s.pad = pad_enable;
+		cvmx_write_csr_node(node,
+			CVMX_BGXX_SMUX_TX_APPEND(index, interface),
+			smu_tx_append.u64);
+	}
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 853203d..84148a9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -947,9 +947,20 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		/* NPI has only one MAC, subif == 'ring' */
 		if (mode == CVMX_HELPER_INTERFACE_MODE_NPI && subif > 0)
 			continue;
-
+#ifdef	__PKO_MINPAD_FIXED
 		res = cvmx_pko3_interface_options(xiface, subif,
-						  fcs_enable, pad_enable, fcs_sof_off);
+				  fcs_enable, pad_enable, fcs_sof_off);
+#else
+		if (mode == CVMX_HELPER_INTERFACE_MODE_ILK) {
+			res = cvmx_pko3_interface_options(xiface, subif,
+				  fcs_enable, pad_enable, fcs_sof_off);
+		} else {
+			res = cvmx_pko3_interface_options(xiface, subif,
+				  false, false, fcs_sof_off);
+			cvmx_helper_bgx_tx_options(xi.node, xi.interface, subif,
+				fcs_enable, pad_enable);
+		}
+#endif
 		if(res < 0)
 			cvmx_dprintf("%s: WARNING: failed to set options for interface %d subif %d\n",
 				     __func__, xiface, subif);
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index 7f77e36..5011ff4 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -3317,7 +3317,7 @@ union cvmx_fpa_poolx_op_pc {
 	uint64_t u64;
 	struct cvmx_fpa_poolx_op_pc_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of allocations or returns performed to this pool, including those that fail due to RED. */
+	uint64_t count                        : 64; /**< Number of allocations or returns performed to this pool, including those that fail due to RED/DROP. */
 #else
 	uint64_t count                        : 64;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
index 3a1307c..e14cccc 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
@@ -227,4 +227,13 @@ extern void cvmx_helper_bgx_rx_pause_ctl(unsigned node, unsigned interface,
  */
 extern void cvmx_helper_bgx_rx_adr_ctl(unsigned node, unsigned interface, unsigned port,
                                 unsigned cam_accept, unsigned mcast_mode, unsigned bcast_accept);
+
+/**
+ * Function to control the generation of FCS, padding by the BGX
+ *
+ */
+extern void cvmx_helper_bgx_tx_options(unsigned node,
+	unsigned interface, unsigned index,
+	bool fcs_enable, bool pad_enable);
+
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-ila-defs.h b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
index 1d94d4c..98f7f89 100644
--- a/arch/mips/include/asm/octeon/cvmx-ila-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
@@ -754,7 +754,7 @@ union cvmx_ila_rxx_byte_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t rx_bytes                     : 40; /**< Indicates the number of bytes received per channel. Wraps on overflow. On overflow, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t rx_bytes                     : 40;
 	uint64_t reserved_40_63               : 24;
@@ -777,39 +777,39 @@ union cvmx_ila_rxx_cfg0 {
 	uint64_t reserved_60_61               : 2;
 	uint64_t lnk_stats_wrap               : 1;  /**< Enable that upon overflow, statistics should wrap instead of saturating. */
 	uint64_t reserved_56_58               : 3;
-	uint64_t lnk_stats_rdclr              : 1;  /**< Enable that a CSR read operation to ILA_RX(0)_STAT* clears the counter after returning its
-                                                         current value. */
+	uint64_t lnk_stats_rdclr              : 1;  /**< Enable that a CSR read operation to ILA_RX()_STAT0..ILA_RX()_STAT9 clears the counter
+                                                         after returning its current value. */
 	uint64_t lnk_stats_ena                : 1;  /**< Enable link-statistics counters. */
 	uint64_t reserved_52_53               : 2;
 	uint64_t mfrm_len                     : 13; /**< The quantity of data sent on each lane including one sync word, scrambler state,
                                                          diagnostic word, zero or more skip words, and the data payload. Must be larger than
-                                                         ILA_RX(0)_CFG1[SKIP_CNT] + 32.
+                                                         ILA_TX()_CFG1[SKIP_CNT] + 32.
                                                          Supported range:
-                                                         ILA_RX(0)_CFG1[SKIP_CNT] + 32 < MFRM_LEN <= 4096 */
+                                                         _ ILA_TX()_CFG1[SKIP_CNT] + 32 < MFRM_LEN <= 4096 */
 	uint64_t brst_shrt                    : 7;  /**< Minimum interval between burst control words, as a multiple of eight bytes. Supported
                                                          range from 8 to 512 bytes (i.e. 0 < BRST_SHRT <= 64).
-                                                         This field affects the ILA_RX(0)_STAT4[BRST_SHRT_ERR_CNT] counter. It does not affect
+                                                         This field affects the ILA_RX()_STAT4[BRST_SHRT_ERR_CNT] counter. It does not affect
                                                          correct operation of the link. */
 	uint64_t lane_rev                     : 1;  /**< Lane reversal. When enabled, lane destriping is performed from most-significant lane
                                                          enabled to least-significant lane enabled. LANE_ENA must be 0 before changing LANE_REV. */
 	uint64_t brst_max                     : 5;  /**< Maximum size of a data burst, as a multiple of 64-byte blocks. Supported range is from 64
                                                          to 1024 bytes
                                                          (i.e. 0 < BRST_MAX <= 16).
-                                                         This field affects the ILA_RX(0)_STAT2[BRST_NOT_FULL_CNT] and
-                                                         ILA_RX(0)_STAT3[BRST_MAX_ERR_CNT] counters. It does not affect correct operation of the
+                                                         This field affects the ILA_RX()_STAT2[BRST_NOT_FULL_CNT] and
+                                                         ILA_RX()_STAT3[BRST_MAX_ERR_CNT] counters. It does not affect correct operation of the
                                                          link. */
 	uint64_t reserved_8_25                : 18;
 	uint64_t lane_ena                     : 8;  /**< Lane enable mask. The link is enabled if any lane is enabled. The same lane should not be
                                                          enabled in multiple ILA_RXn_CFG0. Each bit of LANE_ENA maps to an RX lane (RLE) and a QLM
                                                          lane. Note that LANE_REV has no effect on this mapping.
-                                                         LANE_ENA[0] = RLE0 =  QLM2 lane 0
-                                                         LANE_ENA[1] = RLE1 =  QLM2 lane 1
-                                                         LANE_ENA[2] = RLE2 =  QLM2 lane 2
-                                                         LANE_ENA[3] = RLE3 =  QLM2 lane 3
-                                                         LANE_ENA[4] = RLE4 =  QLM3 lane 0
-                                                         LANE_ENA[5] = RLE5 =  QLM3 lane 1
-                                                         LANE_ENA[6] = RLE6 =  QLM3 lane 2
-                                                         LANE_ENA[7] = RLE7 =  QLM3 lane 3 */
+                                                         _ LANE_ENA[0] = RLE0 =  QLM2 lane 0
+                                                         _ LANE_ENA[1] = RLE1 =  QLM2 lane 1
+                                                         _ LANE_ENA[2] = RLE2 =  QLM2 lane 2
+                                                         _ LANE_ENA[3] = RLE3 =  QLM2 lane 3
+                                                         _ LANE_ENA[4] = RLE4 =  QLM3 lane 0
+                                                         _ LANE_ENA[5] = RLE5 =  QLM3 lane 1
+                                                         _ LANE_ENA[6] = RLE6 =  QLM3 lane 2
+                                                         _ LANE_ENA[7] = RLE7 =  QLM3 lane 3 */
 #else
 	uint64_t lane_ena                     : 8;
 	uint64_t reserved_8_25                : 18;
@@ -906,7 +906,7 @@ union cvmx_ila_rxx_int {
                                                          alignment may now be enabled. */
 	uint64_t crc24_err                    : 1;  /**< Burst CRC24 error. All open packets receive an error. */
 	uint64_t lane_align_fail              : 1;  /**< Lane alignment fails after four tries. Hardware repeats lane alignment until is succeeds
-                                                         or until ILA_RX(0)_CFG1[RX_ALIGN_ENA] = 0. */
+                                                         or until ILA_RX()_CFG1[RX_ALIGN_ENA] = 0. */
 #else
 	uint64_t lane_align_fail              : 1;
 	uint64_t crc24_err                    : 1;
@@ -930,7 +930,7 @@ union cvmx_ila_rxx_pkt_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t rx_pkt                       : 34; /**< Indicates the number of packets received per channel. Wraps on overflow. On overflow, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t rx_pkt                       : 34;
 	uint64_t reserved_34_63               : 30;
@@ -949,8 +949,8 @@ union cvmx_ila_rxx_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_33_63               : 31;
 	uint64_t crc24_match_cnt              : 33; /**< Indicates the number of CRC24 matches received. Wraps on overflow if
-                                                         ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
+                                                         ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc24_match_cnt              : 33;
 	uint64_t reserved_33_63               : 31;
@@ -969,8 +969,8 @@ union cvmx_ila_rxx_stat1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t crc24_err_cnt                : 18; /**< Indicates the number of bursts with a detected CRC error. Wraps on overflow if
-                                                         ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
+                                                         ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc24_err_cnt                : 18;
 	uint64_t reserved_18_63               : 46;
@@ -989,12 +989,12 @@ union cvmx_ila_rxx_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t brst_not_full_cnt            : 16; /**< Indicates the number of bursts received that terminated without an EOP and contained fewer
-                                                         than BurstMax words. Wraps on overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         than BurstMax words. Wraps on overflow if ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise,
+                                                         saturates. On overflow/saturate, sets ILA_RX()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_28_31               : 4;
 	uint64_t brst_cnt                     : 28; /**< Indicates the number of bursts correctly received (i.e. good CRC24, not in violation of
-                                                         BurstMax or BurstShort). Wraps on overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         BurstMax or BurstShort). Wraps on overflow if ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise,
+                                                         saturates. On overflow/saturate, sets ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_cnt                     : 28;
 	uint64_t reserved_28_31               : 4;
@@ -1015,8 +1015,8 @@ union cvmx_ila_rxx_stat3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t brst_max_err_cnt             : 16; /**< Indicates the number of bursts received longer than the BurstMax parameter. Wraps on
-                                                         overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate,
-                                                         sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         overflow if ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate,
+                                                         sets ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_max_err_cnt             : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1035,8 +1035,8 @@ union cvmx_ila_rxx_stat4 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t brst_shrt_err_cnt            : 16; /**< Indicates the number of bursts received that violate the BurstShort parameter. Wraps on
-                                                         overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate,
-                                                         sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         overflow if ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate,
+                                                         sets ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_shrt_err_cnt            : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1055,8 +1055,8 @@ union cvmx_ila_rxx_stat5 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_23_63               : 41;
 	uint64_t align_cnt                    : 23; /**< Indicates the number of alignment sequences received (i.e. those that do not violate the
-                                                         current alignment). Wraps on overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         current alignment). Wraps on overflow if ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise,
+                                                         saturates. On overflow/saturate, sets ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t align_cnt                    : 23;
 	uint64_t reserved_23_63               : 41;
@@ -1075,8 +1075,8 @@ union cvmx_ila_rxx_stat6 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t align_err_cnt                : 16; /**< Indicates the number of alignment sequences received in error (i.e. those that violate the
-                                                         current alignment). Wraps on overflow if ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         current alignment). Wraps on overflow if ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise,
+                                                         saturates. On overflow/saturate, sets ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t align_err_cnt                : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1095,8 +1095,8 @@ union cvmx_ila_rxx_stat7 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t bad_64b67b_cnt               : 16; /**< Indicates the number of bad 64B/67B code words. Wraps on overflow if
-                                                         ILA_RX(0)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILA_RX(0)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
+                                                         ILA_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bad_64b67b_cnt               : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1157,7 +1157,7 @@ union cvmx_ila_rx_lnex_cfg {
                                                          If the lane is in internal loopback mode, this field is ignored and skip words are always
                                                          discarded in the lane logic. */
 	uint64_t reserved_7_7                 : 1;
-	uint64_t rx_dis_disp_chk              : 1;  /**< Disable the RX disparity check, see ILA_RX_LNE(0..7)_INT[DISP_ERR]. */
+	uint64_t rx_dis_disp_chk              : 1;  /**< Disable the RX disparity check, see ILA_RX_LNE()_INT[DISP_ERR]. */
 	uint64_t rx_scrm_sync                 : 1;  /**< RX scrambler-synchronization status. A 1 means synchronization has been achieved. */
 	uint64_t rx_bdry_sync                 : 1;  /**< RX word-boundary-synchronization status. A 1 means synchronization has been achieved */
 	uint64_t rx_dis_ukwn                  : 1;  /**< Disable normal response to unknown words. Unknown words are still logged but do not cause
@@ -1191,22 +1191,22 @@ union cvmx_ila_rx_lnex_int {
 	struct cvmx_ila_rx_lnex_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t disp_err                     : 1;  /**< RX disparity error encountered. Throws ILA_INTSN_E::ILA_RXLNE(0..7)_DISP_ERR. */
+	uint64_t disp_err                     : 1;  /**< RX disparity error encountered. Throws ILA_INTSN_E::ILA_RXLNE()_DISP_ERR. */
 	uint64_t bad_64b67b                   : 1;  /**< Bad 64B/67B code word encountered. Once the bad word reaches the burst-control unit (as
-                                                         indicated by ILA_RX(0)_INT[LANE_BAD_WORD]) it is discarded and all open packets receive an
-                                                         error. Throws ILA_INTSN_E::ILA_RXLNE(0..7)_BAD_64B67B. */
-	uint64_t stat_cnt_ovfl                : 1;  /**< RX-lane statistic counter overflow. Throws ILA_INTSN_E::ILA_RXLNE(0..7)_STAT_CNT_OVFL. */
+                                                         indicated by ILA_RX()_INT[LANE_BAD_WORD]) it is discarded and all open packets receive an
+                                                         error. Throws ILA_INTSN_E::ILA_RXLNE()_BAD_64B67B. */
+	uint64_t stat_cnt_ovfl                : 1;  /**< RX-lane statistic counter overflow. Throws ILA_INTSN_E::ILA_RXLNE()_STAT_CNT_OVFL. */
 	uint64_t stat_msg                     : 1;  /**< Indicates that status bits for the link or a lane transitioned from a 1 (healthy) to a 0
-                                                         (problem). Throws ILA_INTSN_E::ILA_RXLNE(0..7)_STAT_MSG. */
-	uint64_t dskew_fifo_ovfl              : 1;  /**< RX deskew-FIFO overflow occurred. Throws ILA_INTSN_E::ILA_RXLNE(0..7)_DSKEW_FIFO_OVFL. */
+                                                         (problem). Throws ILA_INTSN_E::ILA_RXLNE()_STAT_MSG. */
+	uint64_t dskew_fifo_ovfl              : 1;  /**< RX deskew-FIFO overflow occurred. Throws ILA_INTSN_E::ILA_RXLNE()_DSKEW_FIFO_OVFL. */
 	uint64_t scrm_sync_loss               : 1;  /**< Indicates that four consecutive bad sync words or three consecutive scramble-state
-                                                         mismatches occurred. Throws ILA_INTSN_E::ILA_RXLNE(0..7)_SCRM_SYNC_LOSS. */
+                                                         mismatches occurred. Throws ILA_INTSN_E::ILA_RXLNE()_SCRM_SYNC_LOSS. */
 	uint64_t ukwn_cntl_word               : 1;  /**< Unknown framing-control word. Block type does not match any of (SYNC,SCRAM,SKIP,DIAG).
-                                                         Throws ILA_INTSN_E::ILA_RXLNE(0..7)_UKWN_CNTL_WORD. */
-	uint64_t crc32_err                    : 1;  /**< Diagnostic CRC32 errors. Throws ILA_INTSN_E::ILA_RXLNE(0..7)_CRC32_ERR. */
+                                                         Throws ILA_INTSN_E::ILA_RXLNE()_UKWN_CNTL_WORD. */
+	uint64_t crc32_err                    : 1;  /**< Diagnostic CRC32 errors. Throws ILA_INTSN_E::ILA_RXLNE()_CRC32_ERR. */
 	uint64_t bdry_sync_loss               : 1;  /**< RX logic loses word-boundary sync (16 tries). Hardware automatically attempts to regain
-                                                         word-boundary sync. Throws ILA_INTSN_E::ILA_RXLNE(0..7)_BDRY_SYNC_LOSS. */
-	uint64_t serdes_lock_loss             : 1;  /**< RX SerDes loses lock. Throws ILA_INTSN_E::ILA_RXLNE(0..7)_SERDES_LOCK_LOSS. */
+                                                         word-boundary sync. Throws ILA_INTSN_E::ILA_RXLNE()_BDRY_SYNC_LOSS. */
+	uint64_t serdes_lock_loss             : 1;  /**< RX SerDes loses lock. Throws ILA_INTSN_E::ILA_RXLNE()_SERDES_LOCK_LOSS. */
 #else
 	uint64_t serdes_lock_loss             : 1;
 	uint64_t bdry_sync_loss               : 1;
@@ -1234,7 +1234,7 @@ union cvmx_ila_rx_lnex_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t ser_lock_loss_cnt            : 18; /**< Indicates the number of times the lane lost clock-data-recovery. On overflow, saturates
-                                                         and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         and sets ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t ser_lock_loss_cnt            : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1253,7 +1253,7 @@ union cvmx_ila_rx_lnex_stat1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bdry_sync_loss_cnt           : 18; /**< Indicates the number of times a lane lost word-boundary synchronization. On overflow,
-                                                         saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         saturates and sets ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bdry_sync_loss_cnt           : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1272,10 +1272,10 @@ union cvmx_ila_rx_lnex_stat10 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_43_63               : 21;
 	uint64_t prbs_bad                     : 11; /**< Indicates the number of training frames with bad PRBS. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_11_31               : 21;
 	uint64_t prbs_good                    : 11; /**< Indicates the number of training frames with correct PRBS. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t prbs_good                    : 11;
 	uint64_t reserved_11_31               : 21;
@@ -1296,10 +1296,10 @@ union cvmx_ila_rx_lnex_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t syncw_good_cnt               : 18; /**< Indicates the number of good synchronization words. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_18_31               : 14;
 	uint64_t syncw_bad_cnt                : 18; /**< Indicates the number of bad synchronization words. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t syncw_bad_cnt                : 18;
 	uint64_t reserved_18_31               : 14;
@@ -1320,7 +1320,7 @@ union cvmx_ila_rx_lnex_stat3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bad_64b67b_cnt               : 18; /**< Indicates the number of bad 64B/67B words, meaning bit <65> or bit <64> has been
-                                                         corrupted. On overflow, saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         corrupted. On overflow, saturates and sets ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bad_64b67b_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1339,10 +1339,10 @@ union cvmx_ila_rx_lnex_stat4 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_59_63               : 5;
 	uint64_t cntl_word_cnt                : 27; /**< Indicates the number of control words received. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t data_word_cnt                : 27; /**< Indicates the number of data words received. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t data_word_cnt                : 27;
 	uint64_t reserved_27_31               : 5;
@@ -1363,7 +1363,7 @@ union cvmx_ila_rx_lnex_stat5 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t unkwn_word_cnt               : 18; /**< Indicates the number of unknown control words. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t unkwn_word_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1383,7 +1383,7 @@ union cvmx_ila_rx_lnex_stat6 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t scrm_sync_loss_cnt           : 18; /**< Indicates the number of times scrambler synchronization was lost (due to either four
                                                          consecutive bad sync words or three consecutive scrambler-state mismatches). On overflow,
-                                                         saturates and sets ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         saturates and sets ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t scrm_sync_loss_cnt           : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1402,7 +1402,7 @@ union cvmx_ila_rx_lnex_stat7 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t scrm_match_cnt               : 18; /**< Indicates the number of scrambler-state matches received. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t scrm_match_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1421,7 +1421,7 @@ union cvmx_ila_rx_lnex_stat8 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t skipw_good_cnt               : 18; /**< Indicates the number of good skip words. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t skipw_good_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -1440,10 +1440,10 @@ union cvmx_ila_rx_lnex_stat9 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t crc32_err_cnt                : 18; /**< Indicates the number of errors in the lane CRC. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t crc32_match_cnt              : 27; /**< Indicates the number of CRC32 matches received. On overflow, saturates and sets
-                                                         ILA_RX_LNE(0..7)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc32_match_cnt              : 27;
 	uint64_t reserved_27_31               : 5;
@@ -1500,7 +1500,7 @@ union cvmx_ila_txx_byte_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t tx_bytes                     : 40; /**< Number of bytes transmitted per channel. Wraps on overflow. On overflow, sets
-                                                         ILA_TX(0)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_TX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t tx_bytes                     : 40;
 	uint64_t reserved_40_63               : 24;
@@ -1519,19 +1519,19 @@ union cvmx_ila_txx_cfg0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_63_63               : 1;
 	uint64_t ext_lpbk                     : 1;  /**< Enable RX-TX data external loopback. Note that with differing transmit and receive clocks,
-                                                         skip word are inserted/deleted. Must set ILA_TX(0)_CFG1[RX_LINK_FC_IGN] whenever enabling
+                                                         skip word are inserted/deleted. Must set ILA_TX()_CFG1[RX_LINK_FC_IGN] whenever enabling
                                                          external loopback. */
 	uint64_t int_lpbk                     : 1;  /**< Enable TX-RX internal loopback. */
 	uint64_t txf_byp_dis                  : 1;  /**< Disable TXF bypass. */
 	uint64_t reserved_56_59               : 4;
-	uint64_t lnk_stats_rdclr              : 1;  /**< CSR read to ILA_TXx_STAT* clears the counter after returning its current value. */
+	uint64_t lnk_stats_rdclr              : 1;  /**< CSR read to ILA_TX(0)_STAT* clears the counter after returning its current value. */
 	uint64_t lnk_stats_ena                : 1;  /**< Enable link statistics counters */
 	uint64_t reserved_52_53               : 2;
 	uint64_t mfrm_len                     : 13; /**< The quantity of data sent on each lane including one sync word, scrambler state, diag
                                                          word, zero or more skip words, and the data payload. Must be larger than
-                                                         ILA_TX(0)_CFG1[SKIP_CNT] + 9.
+                                                         ILA_TX()_CFG1[SKIP_CNT] + 9.
                                                          Supported range:
-                                                         ILA_TX(0)_CFG1[SKIP_CNT] + 9 < MFRM_LEN <= 4096) */
+                                                         _ ILA_TX()_CFG1[SKIP_CNT] + 9 < MFRM_LEN <= 4096) */
 	uint64_t brst_shrt                    : 7;  /**< Minimum interval between burst control words, as a multiple of eight bytes. Supported
                                                          range from eight to 512 bytes
                                                          (i.e. 0 < BRST_SHRT <= 64). */
@@ -1542,16 +1542,16 @@ union cvmx_ila_txx_cfg0 {
                                                          (i.e. 0 < BRST_MAX <= 16). */
 	uint64_t reserved_8_25                : 18;
 	uint64_t lane_ena                     : 8;  /**< Lane enable mask. Link is enabled if any lane is enabled. The same lane should not be
-                                                         enabled in multiple ILA_TX(0)_CFG0. Each bit of LANE_ENA maps to a TX lane (TLE) and a QLM
+                                                         enabled in multiple ILA_TX()_CFG0. Each bit of LANE_ENA maps to a TX lane (TLE) and a QLM
                                                          lane. Note that LANE_REV has no effect on this mapping.
-                                                         LANE_ENA[0] = TLE0  =  QLM2 lane 0
-                                                         LANE_ENA[1] = TLE1  =  QLM2 lane 1
-                                                         LANE_ENA[2] = TLE2  =  QLM2 lane 2
-                                                         LANE_ENA[3] = TLE3  =  QLM2 lane 3
-                                                         LANE_ENA[4] = TLE4  =  QLM3 lane 0
-                                                         LANE_ENA[5] = TLE5  =  QLM3 lane 1
-                                                         LANE_ENA[6] = TLE6  =  QLM3 lane 2
-                                                         LANE_ENA[7] = TLE7  =  QLM3 lane 3 */
+                                                         _ LANE_ENA[0] = TLE0  =  QLM2 lane 0
+                                                         _ LANE_ENA[1] = TLE1  =  QLM2 lane 1
+                                                         _ LANE_ENA[2] = TLE2  =  QLM2 lane 2
+                                                         _ LANE_ENA[3] = TLE3  =  QLM2 lane 3
+                                                         _ LANE_ENA[4] = TLE4  =  QLM3 lane 0
+                                                         _ LANE_ENA[5] = TLE5  =  QLM3 lane 1
+                                                         _ LANE_ENA[6] = TLE6  =  QLM3 lane 2
+                                                         _ LANE_ENA[7] = TLE7  =  QLM3 lane 3 */
 #else
 	uint64_t lane_ena                     : 8;
 	uint64_t reserved_8_25                : 18;
@@ -1584,10 +1584,10 @@ union cvmx_ila_txx_cfg1 {
 	uint64_t reserved_43_59               : 17;
 	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. If 0x0, hardware
                                                          will compute it. Otherwise, SER_LIMIT must be set as follows:
-                                                         SER_LIMIT >= 148 + (BAUD / SCLK) * (12 + NUM_LANES)
+                                                         _ SER_LIMIT >= 148 + (BAUD / SCLK) * (12 + NUM_LANES)
                                                          For instance, for SCLK=1.1GHz,BAUD=10.3125,NUM_LANES=8:
-                                                         SER_LIMIT >= 148 + (10.3125 / 1.1 * (12+ 8))
-                                                         SER_LIMIT >= 336 */
+                                                         _ SER_LIMIT >= 148 + (10.3125 / 1.1 * (12+ 8))
+                                                         _ SER_LIMIT >= 336 */
 	uint64_t pkt_busy                     : 1;  /**< TX-link is transmitting data. */
 	uint64_t reserved_26_31               : 6;
 	uint64_t skip_cnt                     : 4;  /**< Number of skip words to insert after the scrambler state. */
@@ -1708,11 +1708,11 @@ union cvmx_ila_txx_int {
 	struct cvmx_ila_txx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
-	uint64_t txf_dbe                      : 1;  /**< TX FIFO double-bit error. Throws ILA_INTSN_E::ILA_TX(0..1)_TXF_DBE. See also
-                                                         ILA_TX(0..1)_TXF_ERR_ST. */
-	uint64_t txf_sbe                      : 1;  /**< TX FIFO single-bit error. Throws ILA_INTSN_E::ILA_TX(0..1)_TXF_SBE. See also
-                                                         ILA_TX(0..1)_TXF_ERR_ST. */
-	uint64_t stat_cnt_ovfl                : 1;  /**< Statistics counter overflow. Throws ILA_INTSN_E::ILA_TX(0..1)_STAT_CNT_OVFL. */
+	uint64_t txf_dbe                      : 1;  /**< TX FIFO double-bit error. Throws ILA_INTSN_E::ILA_TX()_TXF_DBE. See also
+                                                         ILA_TX()_ERR_CFG. */
+	uint64_t txf_sbe                      : 1;  /**< TX FIFO single-bit error. Throws ILA_INTSN_E::ILA_TX()_TXF_SBE. See also
+                                                         ILA_TX()_ERR_CFG. */
+	uint64_t stat_cnt_ovfl                : 1;  /**< Statistics counter overflow. Throws ILA_INTSN_E::ILA_TX()_STAT_CNT_OVFL. */
 	uint64_t reserved_0_2                 : 3;
 #else
 	uint64_t reserved_0_2                 : 3;
@@ -1735,7 +1735,7 @@ union cvmx_ila_txx_pkt_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
 	uint64_t tx_pkt                       : 28; /**< Number of packets transmitted per channel. Wraps on overflow. On overflow, sets
-                                                         ILA_TX(0)_INT[STAT_CNT_OVFL]. */
+                                                         ILA_TX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t tx_pkt                       : 28;
 	uint64_t reserved_28_63               : 36;
diff --git a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
index 732dd40..aa3b709 100644
--- a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
@@ -1806,16 +1806,16 @@ union cvmx_ilk_rid_cfg {
 	uint64_t max_cnt                      : 7;  /**< Maximum number of reassembly IDs (RIDs) allowed for both links. If
                                                          an SOP arrives and the total number of RIDs already allocated to
                                                          both links is at least MAX_CNT, the packet is dropped.
-                                                         An SOP allocates a RID; an EOP frees a RID. ILK_RX(0..1)_RID can be used to further
+                                                         An SOP allocates a RID; an EOP frees a RID. ILK_RX()_RID can be used to further
                                                          restrict each link individually. */
 	uint64_t reserved_7_31                : 25;
 	uint64_t base                         : 7;  /**< The base RID for ILK. There is a shared pool of 96 RIDs for all MACs.
                                                          ILK can allocate any RID in the range of
-                                                         BASE -> (BASE+(MAX_CNT-1)).
+                                                         _ BASE -> (BASE+(MAX_CNT-1)).
                                                          BASE and MAX_CNT must be constrained such that:
-                                                         1) BASE >= 2.
-                                                         2) BASE + MAX_CNT <= 96.
-                                                         3) BASE..(BASE+(MAX_CNT-1)) does not overlap with any other MAC programming.
+                                                         _ 1) BASE >= 2.
+                                                         _ 2) BASE + MAX_CNT <= 96.
+                                                         _ 3) BASE..(BASE+(MAX_CNT-1)) does not overlap with any other MAC programming.
                                                          The reset value for this CSR has been chosen such that all these conditions are satisfied.
                                                          The reset value supports up to a total of 64 outstanding incomplete packets between ILK0
                                                          and ILK1.
@@ -1841,7 +1841,7 @@ union cvmx_ilk_rxx_byte_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t rx_bytes                     : 40; /**< Number of bytes received per channel. Wraps on overflow. On overflow, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t rx_bytes                     : 40;
 	uint64_t reserved_40_63               : 24;
@@ -1860,10 +1860,10 @@ union cvmx_ilk_rxx_cal_entryx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t ctl                          : 2;  /**< Select source of XON/XOFF for entry (IDX * 8) + 0.
-                                                         0 = PKO backpressure channel
-                                                         1 = link
-                                                         2 = XOFF
-                                                         3 = XON
+                                                         0 = PKO backpressure channel.
+                                                         1 = link.
+                                                         2 = XOFF.
+                                                         3 = XON.
                                                          This field applies to one of bits <55>, <47>, or <31> in the Interlaken control word. */
 	uint64_t reserved_8_31                : 24;
 	uint64_t channel                      : 8;  /**< PKO channel for the calendar table entry. Unused if CTL == 0x1. */
@@ -1894,49 +1894,49 @@ union cvmx_ilk_rxx_cfg0 {
 	uint64_t bcw_push                     : 1;  /**< Reserved. */
 	uint64_t mproto_ign                   : 1;  /**< Reserved. */
 	uint64_t ptrn_mode                    : 1;  /**< Reserved. */
-	uint64_t lnk_stats_rdclr              : 1;  /**< Enable that a CSR read operation to ILK_RX(0..1)_STAT* clears the counter after returning
-                                                         its current value. */
+	uint64_t lnk_stats_rdclr              : 1;  /**< Enable that a CSR read operation to ILK_RX()_STAT0..ILK_RX()_STAT9 clears the counter
+                                                         after returning its current value. */
 	uint64_t lnk_stats_ena                : 1;  /**< Enable link-statistics counters. */
 	uint64_t mltuse_fc_ena                : 1;  /**< Use multiuse field for calendar. */
 	uint64_t cal_ena                      : 1;  /**< Enable the RX calendar. When the calendar table is disabled, all port-pipes receive XON. */
 	uint64_t mfrm_len                     : 13; /**< The quantity of data sent on each lane including one sync word, scrambler state,
                                                          diagnostic word, zero or more skip words, and the data payload. Must be large than
-                                                         ILK_RX(0..1)_CFG1[SKIP_CNT] + 32.
+                                                         _ ILK_TX()_CFG1[SKIP_CNT] + 32.
                                                          Supported range:
-                                                         ILK_RX(0..1)_CFG1[SKIP_CNT] + 32 < MFRM_LEN <= 4096 */
+                                                         _ ILK_TX()_CFG1[SKIP_CNT] + 32 < MFRM_LEN <= 4096 */
 	uint64_t brst_shrt                    : 7;  /**< Minimum interval between burst control words, as a multiple of eight bytes. Supported
                                                          range from 8 to 512 bytes (i.e. 4 <= BRST_SHRT <= 64).
-                                                         This field affects the ILK_RX(0..1)_STAT4[BRST_SHRT_ERR_CNT] counter. It does not affect
+                                                         This field affects the ILK_RX()_STAT4[BRST_SHRT_ERR_CNT] counter. It does not affect
                                                          correct operation of the link. */
 	uint64_t lane_rev                     : 1;  /**< Lane reversal. When enabled, lane destriping is performed from most-significant lane
                                                          enabled to least-significant lane enabled. LANE_ENA must be 0 before changing LANE_REV. */
 	uint64_t brst_max                     : 5;  /**< Maximum size of a data burst, as a multiple of 64-byte blocks. Supported range is from 64
                                                          to 1024 bytes
                                                          (i.e. 0 < BRST_MAX <= 16).
-                                                         This field affects the ILK_RX(0..1)_STAT2[BRST_NOT_FULL_CNT] and
-                                                         ILK_RX(0..1)_STAT3[BRST_MAX_ERR_CNT] counters. It does not affect correct operation of the
+                                                         This field affects the ILK_RX()_STAT2[BRST_NOT_FULL_CNT] and
+                                                         ILK_RX()_STAT3[BRST_MAX_ERR_CNT] counters. It does not affect correct operation of the
                                                          link. */
 	uint64_t reserved_25_25               : 1;
 	uint64_t cal_depth                    : 9;  /**< Indicates the number of valid entries in the calendar.   Supported range from 1 to 288. */
 	uint64_t lane_ena                     : 16; /**< Lane-enable mask. The link is enabled if any lane is enabled. The same lane should not be
                                                          enabled in multiple ILK_RXn_CFG0. Each bit of LANE_ENA maps to an RX lane (RLE) and a QLM
                                                          lane. Note that LANE_REV has no effect on this mapping.
-                                                         LANE_ENA[0] = RLE0 =  QLM4 lane 0
-                                                         LANE_ENA[1] = RLE1 =  QLM4 lane 1
-                                                         LANE_ENA[2] = RLE2 =  QLM4 lane 2
-                                                         LANE_ENA[3] = RLE3 =  QLM4 lane 3
-                                                         LANE_ENA[4] = RLE4 =  QLM5 lane 0
-                                                         LANE_ENA[5] = RLE5 =  QLM5 lane 1
-                                                         LANE_ENA[6] = RLE6 =  QLM5 lane 2
-                                                         LANE_ENA[7] = RLE7 =  QLM5 lane 3
-                                                         LANE_ENA[8] = RLE8 =  QLM6 lane 0
-                                                         LANE_ENA[9] = RLE9 =  QLM6 lane 1
-                                                         LANE_ENA[10] = RLE10 =  QLM6 lane 2
-                                                         LANE_ENA[11] = RLE11 =  QLM6 lane 3
-                                                         LANE_ENA[12] = RLE12 =  QLM7 lane 0
-                                                         LANE_ENA[13] = RLE13 =  QLM7 lane 1
-                                                         LANE_ENA[14] = RLE14 =  QLM7 lane 2
-                                                         LANE_ENA[15] = RLE15 =  QLM7 lane 3 */
+                                                         _ LANE_ENA<0> = RLE0 = QLM4 lane 0.
+                                                         _ LANE_ENA<1> = RLE1 = QLM4 lane 1.
+                                                         _ LANE_ENA<2> = RLE2 = QLM4 lane 2.
+                                                         _ LANE_ENA<3> = RLE3 = QLM4 lane 3.
+                                                         _ LANE_ENA<4> = RLE4 = QLM5 lane 0.
+                                                         _ LANE_ENA<5> = RLE5 = QLM5 lane 1.
+                                                         _ LANE_ENA<6> = RLE6 = QLM5 lane 2.
+                                                         _ LANE_ENA<7> = RLE7 = QLM5 lane 3.
+                                                         _ LANE_ENA<8> = RLE8 = QLM6 lane 0.
+                                                         _ LANE_ENA<9> = RLE9 = QLM6 lane 1.
+                                                         _ LANE_ENA<10> = RLE10 = QLM6 lane 2.
+                                                         _ LANE_ENA<11> = RLE11 = QLM6 lane 3.
+                                                         _ LANE_ENA<12> = RLE12 = QLM7 lane 0.
+                                                         _ LANE_ENA<13> = RLE13 = QLM7 lane 1.
+                                                         _ LANE_ENA<14> = RLE14 = QLM7 lane 2.
+                                                         _ LANE_ENA<15> = RLE15 = QLM7 lane 3. */
 #else
 	uint64_t lane_ena                     : 16;
 	uint64_t cal_depth                    : 9;
@@ -2127,8 +2127,8 @@ union cvmx_ilk_rxx_cfg1 {
                                                          status from XON to XOFF. LSB must be zero. A typical single-link configuration should set
                                                          this to 2048. A typical multi-link configuration should set this to NL*128 where NL is the
                                                          number of lanes enabled for a given link.
-                                                         XON = RX_FIFO_CNT < RX_FIFO_HWM
-                                                         XOFF = RX_FIFO_CNT >= RX_FIFO_HWM. */
+                                                         _ XON = RX_FIFO_CNT < RX_FIFO_HWM
+                                                         _ XOFF = RX_FIFO_CNT >= RX_FIFO_HWM. */
 	uint64_t reserved_35_35               : 1;
 	uint64_t rx_fifo_max                  : 13; /**< Specifies the maximum number of 64-bit words consumed by this link in the RX FIFO. The sum
                                                          of all links should be equal to 4096 (32KB). LSB must be zero. Typically set to
@@ -2246,10 +2246,10 @@ union cvmx_ilk_rxx_cha_xonx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t xon                          : 64; /**< Flow control status for channels 0-255, where a 0 indicates the presence of backpressure
                                                          (i.e. XOFF) and 1 indicates the absence of backpressure (i.e. XON).
-                                                         ILK_RX(0..1)_CHA_XON[0]--Channels 63-0
-                                                         ILK_RX(0..1)_CHA_XON[1]--Channels 127-64
-                                                         ILK_RX(0..1)_CHA_XON[2]--Channels 191-128
-                                                         ILK_RX(0..1)_CHA_XON[3]--Channels 255-192 */
+                                                         _ ILK_RX(0..1)_CHA_XON[0] -- Channels 63-0.
+                                                         _ ILK_RX(0..1)_CHA_XON[1] -- Channels 127-64.
+                                                         _ ILK_RX(0..1)_CHA_XON[2] -- Channels 191-128.
+                                                         _ ILK_RX(0..1)_CHA_XON[3] -- Channels 255-192. */
 #else
 	uint64_t xon                          : 64;
 #endif
@@ -2416,27 +2416,27 @@ union cvmx_ilk_rxx_int {
 	struct cvmx_ilk_rxx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t pmap_dbe                     : 1;  /**< Port-kind map double-bit error. Throws ILK_INTSN_E::ILK_RX(0..1)_PMAP_DBE. */
-	uint64_t pmap_sbe                     : 1;  /**< Port-kind map single-bit error. Throws ILK_INTSN_E::ILK_RX(0..1)_PMAP_SBE. */
-	uint64_t fwc_dbe                      : 1;  /**< Flow control calendar table double-bit error. Throws ILK_INTSN_E::ILK_RX(0..1)_FWC_DBE. */
-	uint64_t fwc_sbe                      : 1;  /**< Flow control calendar table single-bit error. Throws ILK_INTSN_E::ILK_RX(0..1)_FWC_SBE. */
+	uint64_t pmap_dbe                     : 1;  /**< Port-kind map double-bit error. Throws ILK_INTSN_E::ILK_RX()_PMAP_DBE. */
+	uint64_t pmap_sbe                     : 1;  /**< Port-kind map single-bit error. Throws ILK_INTSN_E::ILK_RX()_PMAP_SBE. */
+	uint64_t fwc_dbe                      : 1;  /**< Flow control calendar table double-bit error. Throws ILK_INTSN_E::ILK_RX()_FWC_DBE. */
+	uint64_t fwc_sbe                      : 1;  /**< Flow control calendar table single-bit error. Throws ILK_INTSN_E::ILK_RX()_FWC_SBE. */
 	uint64_t pkt_drop_sop                 : 1;  /**< Entire packet dropped due to RX_FIFO_CNT == RX_FIFO_MAX, lack of reassembly IDs or because
-                                                         ILK_RX(0..1)_CFG1[PKT_ENA]=0. Throws ILK_INTSN_E::ILK_RX(0..1)_PKT_DROP_SOP. */
+                                                         ILK_RX()_CFG1[PKT_ENA]=0. Throws ILK_INTSN_E::ILK_RX()_PKT_DROP_SOP. */
 	uint64_t pkt_drop_rid                 : 1;  /**< Entire packet dropped due to the lack of reassembly IDs or because
-                                                         ILK_RX(0..1)_CFG1[PKT_ENA]=0. Throws ILK_INTSN_E::ILK_RX(0..1)_PKT_DROP_RID. */
+                                                         ILK_RX()_CFG1[PKT_ENA]=0. Throws ILK_INTSN_E::ILK_RX()_PKT_DROP_RID. */
 	uint64_t pkt_drop_rxf                 : 1;  /**< Some/all of a packet dropped due to RX_FIFO_CNT == RX_FIFO_MAX. Throws
-                                                         ILK_INTSN_E::ILK_RX(0..1)_PKT_DROP_RXF. */
+                                                         ILK_INTSN_E::ILK_RX()_PKT_DROP_RXF. */
 	uint64_t lane_bad_word                : 1;  /**< A lane encountered either a bad 64B/67B codeword or an unknown control word type. Throws
-                                                         ILK_INTSN_E::ILK_RX(0..1)_LANE_BAD_WORD. */
-	uint64_t stat_cnt_ovfl                : 1;  /**< Statistics counter overflow. Throws ILK_INTSN_E::ILK_RX(0..1)_STAT_CNT_OVFL. */
-	uint64_t lane_align_done              : 1;  /**< Lane alignment successful. Throws ILK_INTSN_E::ILK_RX(0..1)_LANE_ALIGN_DONE. */
+                                                         ILK_INTSN_E::ILK_RX()_LANE_BAD_WORD. */
+	uint64_t stat_cnt_ovfl                : 1;  /**< Statistics counter overflow. Throws ILK_INTSN_E::ILK_RX()_STAT_CNT_OVFL. */
+	uint64_t lane_align_done              : 1;  /**< Lane alignment successful. Throws ILK_INTSN_E::ILK_RX()_LANE_ALIGN_DONE. */
 	uint64_t word_sync_done               : 1;  /**< All enabled lanes have achieved word boundary lock and scrambler synchronization. Lane
-                                                         alignment may now be enabled. Throws ILK_INTSN_E::ILK_RX(0..1)_WORD_SYNC_DONE. */
+                                                         alignment may now be enabled. Throws ILK_INTSN_E::ILK_RX()_WORD_SYNC_DONE. */
 	uint64_t crc24_err                    : 1;  /**< Burst CRC24 error. All open packets receive an error. Throws
-                                                         ILK_INTSN_E::ILK_RX(0..1)_CRC24_ERR. */
+                                                         ILK_INTSN_E::ILK_RX()_CRC24_ERR. */
 	uint64_t lane_align_fail              : 1;  /**< Lane Alignment fails (4 tries). Hardware repeats lane alignment until is succeeds or until
-                                                         ILK_RX(0..1)_CFG1[RX_ALIGN_ENA] is cleared. Throws
-                                                         ILK_INTSN_E::ILK_RX(0..1)_LANE_ALIGN_FAIL. */
+                                                         ILK_RX()_CFG1[RX_ALIGN_ENA] is cleared. Throws
+                                                         ILK_INTSN_E::ILK_RX()_LANE_ALIGN_FAIL. */
 #else
 	uint64_t lane_align_fail              : 1;
 	uint64_t crc24_err                    : 1;
@@ -2945,7 +2945,7 @@ union cvmx_ilk_rxx_pkt_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t rx_pkt                       : 34; /**< Number of packets received per channel. Wraps on overflow. On overflow, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t rx_pkt                       : 34;
 	uint64_t reserved_34_63               : 30;
@@ -3000,8 +3000,8 @@ union cvmx_ilk_rxx_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_35_63               : 29;
 	uint64_t crc24_match_cnt              : 35; /**< Indicates the number of CRC24 matches received. Wraps on overflow if
-                                                         ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
+                                                         ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc24_match_cnt              : 35;
 	uint64_t reserved_35_63               : 29;
@@ -3040,8 +3040,8 @@ union cvmx_ilk_rxx_stat1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
 	uint64_t crc24_err_cnt                : 20; /**< Indicates the number of bursts with a detected CRC error. Wraps on overflow if
-                                                         ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
+                                                         ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc24_err_cnt                : 20;
 	uint64_t reserved_20_63               : 44;
@@ -3071,12 +3071,12 @@ union cvmx_ilk_rxx_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t brst_not_full_cnt            : 18; /**< Indicates the number of bursts received that terminated without an EOP and contained fewer
-                                                         than BurstMax words. Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         than BurstMax words. Wraps on overflow if ILK_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise,
+                                                         saturates. On overflow/saturate, sets ILK_RX()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_30_31               : 2;
 	uint64_t brst_cnt                     : 30; /**< Indicates the number of bursts correctly received. (i.e. good CRC24, not in violation of
-                                                         BurstMax or BurstShort). Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1.
-                                                         Otherwise, saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         BurstMax or BurstShort). Wraps on overflow if ILK_RX()_CFG0[LNK_STATS_WRAP]=1.
+                                                         Otherwise, saturates. On overflow/saturate, sets ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_cnt                     : 30;
 	uint64_t reserved_30_31               : 2;
@@ -3129,8 +3129,8 @@ union cvmx_ilk_rxx_stat3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t brst_max_err_cnt             : 18; /**< Indicates the number of bursts received longer than the BurstMax parameter. Wraps on
-                                                         overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On
-                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         overflow if ILK_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On
+                                                         overflow/saturate, sets ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_max_err_cnt             : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3159,8 +3159,8 @@ union cvmx_ilk_rxx_stat4 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t brst_shrt_err_cnt            : 18; /**< Indicates the number of bursts received that violate the BurstShort parameter. Wraps on
-                                                         overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On
-                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         overflow if ILK_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On
+                                                         overflow/saturate, sets ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t brst_shrt_err_cnt            : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3191,8 +3191,8 @@ union cvmx_ilk_rxx_stat5 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t align_cnt                    : 25; /**< Indicates the number of alignment sequences received (i.e. those that do not violate the
-                                                         current alignment). Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         current alignment). Wraps on overflow if ILK_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise,
+                                                         saturates. On overflow/saturate, sets ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t align_cnt                    : 25;
 	uint64_t reserved_25_63               : 39;
@@ -3233,8 +3233,8 @@ union cvmx_ilk_rxx_stat6 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t align_err_cnt                : 18; /**< Indicates the number of alignment sequences received in error (i.e. those that violate the
-                                                         current alignment). Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise,
-                                                         saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         current alignment). Wraps on overflow if ILK_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise,
+                                                         saturates. On overflow/saturate, sets ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t align_err_cnt                : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3265,8 +3265,8 @@ union cvmx_ilk_rxx_stat7 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bad_64b67b_cnt               : 18; /**< Indicates the number of bad 64B/67B code words.Wraps on overflow if
-                                                         ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
-                                                         ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX()_CFG0[LNK_STATS_WRAP]=1. Otherwise, saturates. On overflow/saturate, sets
+                                                         ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bad_64b67b_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3296,11 +3296,11 @@ union cvmx_ilk_rxx_stat8 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t pkt_drop_rid_cnt             : 16; /**< Indicates the number of packets dropped due to the lack of reassembly IDs or because
-                                                         ILK_RX(0..1)_CFG1[PKT_ENA] = 0. Wraps on overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1.
-                                                         Otherwise, saturates. On overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX()_CFG1[PKT_ENA] = 0. Wraps on overflow if ILK_RX()_CFG0[LNK_STATS_WRAP]=1.
+                                                         Otherwise, saturates. On overflow/saturate, sets ILK_RX()_INT[STAT_CNT_OVFL]. */
 	uint64_t pkt_drop_rxf_cnt             : 16; /**< Indicates the number of packets dropped due to RX_FIFO_CNT >= RX_FIFO_MAX. Wraps on
-                                                         overflow if ILK_RX(0..1)_CFG0[LNK_STATS_WRAP]=1.Otherwise, saturates. On
-                                                         overflow/saturate, sets ILK_RX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         overflow if ILK_RX()_CFG0[LNK_STATS_WRAP]=1.Otherwise, saturates. On
+                                                         overflow/saturate, sets ILK_RX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t pkt_drop_rxf_cnt             : 16;
 	uint64_t pkt_drop_rid_cnt             : 16;
@@ -3347,7 +3347,7 @@ union cvmx_ilk_rx_lnex_cfg {
                                                          If the lane is in internal loopback mode, this field is ignored and skip words are always
                                                          discarded in the lane logic. */
 	uint64_t reserved_7_7                 : 1;
-	uint64_t rx_dis_disp_chk              : 1;  /**< Disable the RX disparity check, see ILK_RX_LNE(0..15)_INT[DISP_ERR]. */
+	uint64_t rx_dis_disp_chk              : 1;  /**< Disable the RX disparity check, see ILK_RX_LNE()_INT[DISP_ERR]. */
 	uint64_t rx_scrm_sync                 : 1;  /**< RX scrambler-synchronization status. A 1 means synchronization has been achieved. */
 	uint64_t rx_bdry_sync                 : 1;  /**< RX word-boundary-synchronization status. A 1 means synchronization has been achieved */
 	uint64_t rx_dis_ukwn                  : 1;  /**< Disable normal response to unknown words. Unknown words are still logged but do not cause
@@ -3438,22 +3438,22 @@ union cvmx_ilk_rx_lnex_int {
 	struct cvmx_ilk_rx_lnex_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t disp_err                     : 1;  /**< RX disparity error encountered. Throws ILK_INTSN_E::ILK_RXLNE(0..15)_DISP_ERR. */
+	uint64_t disp_err                     : 1;  /**< RX disparity error encountered. Throws ILK_INTSN_E::ILK_RXLNE()_DISP_ERR. */
 	uint64_t bad_64b67b                   : 1;  /**< Bad 64B/67B code word encountered. Once the bad word reaches the burst control unit (as
-                                                         denoted by ILK_RX(0..1)_INT[LANE_BAD_WORD]) it is discarded and all open packets receive
-                                                         an error. Throws ILK_INTSN_E::ILK_RXLNE(0..15)_BAD_64B67B. */
-	uint64_t stat_cnt_ovfl                : 1;  /**< Rx lane statistic counter overflow. Throws ILK_INTSN_E::ILK_RXLNE(0..15)_STAT_CNT_OVFL. */
+                                                         denoted by ILK_RX()_INT[LANE_BAD_WORD]) it is discarded and all open packets receive
+                                                         an error. Throws ILK_INTSN_E::ILK_RXLNE()_BAD_64B67B. */
+	uint64_t stat_cnt_ovfl                : 1;  /**< Rx lane statistic counter overflow. Throws ILK_INTSN_E::ILK_RXLNE()_STAT_CNT_OVFL. */
 	uint64_t stat_msg                     : 1;  /**< Status bits for the link or a lane transitioned from a 1 (healthy) to a 0 (problem).
-                                                         Throws ILK_INTSN_E::ILK_RXLNE(0..15)_STAT_MSG. */
-	uint64_t dskew_fifo_ovfl              : 1;  /**< RX deskew FIFO overflow occurred. Throws ILK_INTSN_E::ILK_RXLNE(0..15)_DSKEW_FIFO_OVFL. */
+                                                         Throws ILK_INTSN_E::ILK_RXLNE()_STAT_MSG. */
+	uint64_t dskew_fifo_ovfl              : 1;  /**< RX deskew FIFO overflow occurred. Throws ILK_INTSN_E::ILK_RXLNE()_DSKEW_FIFO_OVFL. */
 	uint64_t scrm_sync_loss               : 1;  /**< Four consecutive bad sync words or three consecutive scramble state mismatches. Throws
-                                                         ILK_INTSN_E::ILK_RXLNE(0..15)_SCRM_SYNC_LOSS. */
+                                                         ILK_INTSN_E::ILK_RXLNE()_SCRM_SYNC_LOSS. */
 	uint64_t ukwn_cntl_word               : 1;  /**< Unknown framing control word. Block type does not match any of (SYNC,SCRAM,SKIP,DIAG).
-                                                         Throws ILK_INTSN_E::ILK_RXLNE(0..15)_UKWN_CNTL_WORD. */
-	uint64_t crc32_err                    : 1;  /**< Diagnostic CRC32 errors. Throws ILK_INTSN_E::ILK_RXLNE(0..15)_CRC32_ERR. */
+                                                         Throws ILK_INTSN_E::ILK_RXLNE()_UKWN_CNTL_WORD. */
+	uint64_t crc32_err                    : 1;  /**< Diagnostic CRC32 errors. Throws ILK_INTSN_E::ILK_RXLNE()_CRC32_ERR. */
 	uint64_t bdry_sync_loss               : 1;  /**< RX logic loses word boundary sync (16 tries). Hardware will automatically attempt to
-                                                         regain word boundary sync. Throws ILK_INTSN_E::ILK_RXLNE(0..15)_BDRY_SYNC_LOSS. */
-	uint64_t serdes_lock_loss             : 1;  /**< RX SerDes loses lock. Throws ILK_INTSN_E::ILK_RXLNE(0..15)_SERDES_LOCK_LOSS. */
+                                                         regain word boundary sync. Throws ILK_INTSN_E::ILK_RXLNE()_BDRY_SYNC_LOSS. */
+	uint64_t serdes_lock_loss             : 1;  /**< RX SerDes loses lock. Throws ILK_INTSN_E::ILK_RXLNE()_SERDES_LOCK_LOSS. */
 #else
 	uint64_t serdes_lock_loss             : 1;
 	uint64_t bdry_sync_loss               : 1;
@@ -3556,7 +3556,7 @@ union cvmx_ilk_rx_lnex_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t ser_lock_loss_cnt            : 18; /**< Indicates the number of times the lane lost clock-data-recovery. On overflow, saturates
-                                                         and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         and sets ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t ser_lock_loss_cnt            : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3577,7 +3577,7 @@ union cvmx_ilk_rx_lnex_stat1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bdry_sync_loss_cnt           : 18; /**< Indicates the number of times a lane lost word-boundary synchronization. On overflow,
-                                                         saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         saturates and sets ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bdry_sync_loss_cnt           : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3598,10 +3598,10 @@ union cvmx_ilk_rx_lnex_stat10 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_43_63               : 21;
 	uint64_t prbs_bad                     : 11; /**< Indicates the number of training frames with bad PRBS. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_11_31               : 21;
 	uint64_t prbs_good                    : 11; /**< Indicates the number of training frames with correct PRBS. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t prbs_good                    : 11;
 	uint64_t reserved_11_31               : 21;
@@ -3622,10 +3622,10 @@ union cvmx_ilk_rx_lnex_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t syncw_good_cnt               : 18; /**< Indicates the number of good synchronization words. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_18_31               : 14;
 	uint64_t syncw_bad_cnt                : 18; /**< Indicates the number of bad synchronization words. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t syncw_bad_cnt                : 18;
 	uint64_t reserved_18_31               : 14;
@@ -3648,7 +3648,7 @@ union cvmx_ilk_rx_lnex_stat3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t bad_64b67b_cnt               : 18; /**< Indicates the number of bad 64B/67B words, meaning bit <65> or bit <64> has been
-                                                         corrupted. On overflow, saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         corrupted. On overflow, saturates and sets ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t bad_64b67b_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3669,10 +3669,10 @@ union cvmx_ilk_rx_lnex_stat4 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_59_63               : 5;
 	uint64_t cntl_word_cnt                : 27; /**< Indicates the number of control words received. SOn overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t data_word_cnt                : 27; /**< Indicates the number of data words received. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t data_word_cnt                : 27;
 	uint64_t reserved_27_31               : 5;
@@ -3695,7 +3695,7 @@ union cvmx_ilk_rx_lnex_stat5 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t unkwn_word_cnt               : 18; /**< Indicates the number of unknown control words.On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t unkwn_word_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3717,7 +3717,7 @@ union cvmx_ilk_rx_lnex_stat6 {
 	uint64_t reserved_18_63               : 46;
 	uint64_t scrm_sync_loss_cnt           : 18; /**< Indicates the number of times scrambler synchronization was lost (due to either four
                                                          consecutive bad sync words or three consecutive scrambler-state mismatches). On overflow,
-                                                         saturates and sets ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         saturates and sets ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t scrm_sync_loss_cnt           : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3738,7 +3738,7 @@ union cvmx_ilk_rx_lnex_stat7 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t scrm_match_cnt               : 18; /**< Indicates the number of scrambler-state matches received. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t scrm_match_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3759,7 +3759,7 @@ union cvmx_ilk_rx_lnex_stat8 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
 	uint64_t skipw_good_cnt               : 18; /**< Indicates the number of good skip words. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t skipw_good_cnt               : 18;
 	uint64_t reserved_18_63               : 46;
@@ -3780,10 +3780,10 @@ union cvmx_ilk_rx_lnex_stat9 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
 	uint64_t crc32_err_cnt                : 18; /**< Indicates the number of errors in the lane CRC. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 	uint64_t reserved_27_31               : 5;
 	uint64_t crc32_match_cnt              : 27; /**< Indicates the number of CRC32 matches received. On overflow, saturates and sets
-                                                         ILK_RX_LNE(0..15)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_RX_LNE()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t crc32_match_cnt              : 27;
 	uint64_t reserved_27_31               : 5;
@@ -3851,43 +3851,43 @@ union cvmx_ilk_ser_cfg {
 	uint64_t reserved_57_63               : 7;
 	uint64_t ser_rxpol_auto               : 1;  /**< SerDes lane receive polarity auto detection mode. */
 	uint64_t ser_rxpol                    : 16; /**< SerDes lane receive polarity.
-                                                         0 = RX without inversion
-                                                         1 = RX with inversion
-                                                         SER_RXPOL[0]  = QLM4 lane 0
-                                                         SER_RXPOL[1]  = QLM4 lane 1
-                                                         SER_RXPOL[2]  = QLM4 lane 2
-                                                         SER_RXPOL[3]  = QLM4 lane 3
-                                                         SER_RXPOL[4]  = QLM5 lane 0
-                                                         SER_RXPOL[5]  = QLM5 lane 1
-                                                         SER_RXPOL[6]  = QLM5 lane 2
-                                                         SER_RXPOL[7]  = QLM5 lane 3
-                                                         SER_RXPOL[8]  = QLM6 lane 0
-                                                         SER_RXPOL[9]  = QLM6 lane 1
-                                                         SER_RXPOL[10] = QLM6 lane 2
-                                                         SER_RXPOL[11] = QLM6 lane 3
-                                                         SER_RXPOL[12] = QLM7 lane 0
-                                                         SER_RXPOL[13] = QLM7 lane 1
-                                                         SER_RXPOL[14] = QLM7 lane 2
-                                                         SER_RXPOL[15] = QLM7 lane 3 */
+                                                         0 = RX without inversion.
+                                                         1 = RX with inversion.
+                                                         _ SER_RXPOL<0>  = QLM4 lane 0.
+                                                         _ SER_RXPOL<1>  = QLM4 lane 1.
+                                                         _ SER_RXPOL<2>  = QLM4 lane 2.
+                                                         _ SER_RXPOL<3>  = QLM4 lane 3.
+                                                         _ SER_RXPOL<4>  = QLM5 lane 0.
+                                                         _ SER_RXPOL<5>  = QLM5 lane 1.
+                                                         _ SER_RXPOL<6>  = QLM5 lane 2.
+                                                         _ SER_RXPOL<7>  = QLM5 lane 3.
+                                                         _ SER_RXPOL<8>  = QLM6 lane 0.
+                                                         _ SER_RXPOL<9>  = QLM6 lane 1.
+                                                         _ SER_RXPOL<10> = QLM6 lane 2.
+                                                         _ SER_RXPOL<11> = QLM6 lane 3.
+                                                         _ SER_RXPOL<12> = QLM7 lane 0.
+                                                         _ SER_RXPOL<13> = QLM7 lane 1.
+                                                         _ SER_RXPOL<14> = QLM7 lane 2.
+                                                         _ SER_RXPOL<15> = QLM7 lane 3. */
 	uint64_t ser_txpol                    : 16; /**< SerDes lane transmit polarity.
                                                          0 = TX without inversion
                                                          1 = TX with inversion
-                                                         SER_TXPOL[0]  = QLM4 lane 0
-                                                         SER_TXPOL[1]  = QLM4 lane 1
-                                                         SER_TXPOL[2]  = QLM4 lane 2
-                                                         SER_TXPOL[3]  = QLM4 lane 3
-                                                         SER_TXPOL[4]  = QLM5 lane 0
-                                                         SER_TXPOL[5]  = QLM5 lane 1
-                                                         SER_TXPOL[6]  = QLM5 lane 2
-                                                         SER_TXPOL[7]  = QLM5 lane 3
-                                                         SER_TXPOL[8]  = QLM6 lane 0
-                                                         SER_TXPOL[9]  = QLM6 lane 1
-                                                         SER_TXPOL[10] = QLM6 lane 2
-                                                         SER_TXPOL[11] = QLM6 lane 3
-                                                         SER_TXPOL[12] = QLM7 lane 0
-                                                         SER_TXPOL[13] = QLM7 lane 1
-                                                         SER_TXPOL[14] = QLM7 lane 2
-                                                         SER_TXPOL[15] = QLM7 lane 3 */
+                                                         _ SER_TXPOL<0>  = QLM4 lane 0.
+                                                         _ SER_TXPOL<1>  = QLM4 lane 1.
+                                                         _ SER_TXPOL<2>  = QLM4 lane 2.
+                                                         _ SER_TXPOL<3>  = QLM4 lane 3.
+                                                         _ SER_TXPOL<4>  = QLM5 lane 0.
+                                                         _ SER_TXPOL<5>  = QLM5 lane 1.
+                                                         _ SER_TXPOL<6>  = QLM5 lane 2.
+                                                         _ SER_TXPOL<7>  = QLM5 lane 3.
+                                                         _ SER_TXPOL<8>  = QLM6 lane 0.
+                                                         _ SER_TXPOL<9>  = QLM6 lane 1.
+                                                         _ SER_TXPOL<10> = QLM6 lane 2.
+                                                         _ SER_TXPOL<11> = QLM6 lane 3.
+                                                         _ SER_TXPOL<12> = QLM7 lane 0.
+                                                         _ SER_TXPOL<13> = QLM7 lane 1.
+                                                         _ SER_TXPOL<14> = QLM7 lane 2.
+                                                         _ SER_TXPOL<15> = QLM7 lane 3. */
 	uint64_t ser_reset_n                  : 16; /**< SerDes lane reset. */
 	uint64_t ser_pwrup                    : 4;  /**< Reserved. */
 	uint64_t ser_haul                     : 4;  /**< Reserved. */
@@ -3948,7 +3948,7 @@ union cvmx_ilk_txx_byte_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t tx_bytes                     : 40; /**< Number of bytes transmitted per channel. Wraps on overflow. On overflow, sets
-                                                         ILK_TX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_TX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t tx_bytes                     : 40;
 	uint64_t reserved_40_63               : 24;
@@ -3966,11 +3966,11 @@ union cvmx_ilk_txx_cal_entryx {
 	struct cvmx_ilk_txx_cal_entryx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
-	uint64_t ctl                          : 2;  /**< Select source of XON/XOFF for entry (IDX * 8) + 0
-                                                         0 = PKI backpressure channel
-                                                         1 = Link
-                                                         2 = XOFF
-                                                         3 = XON
+	uint64_t ctl                          : 2;  /**< Select source of XON/XOFF for entry (IDX * 8) + 0:
+                                                         0 = PKI backpressure channel.
+                                                         1 = Link.
+                                                         2 = XOFF.
+                                                         3 = XON.
                                                          This field applies to one of bits <55>, <47>, or <31> in the Interlaken control word. */
 	uint64_t reserved_8_31                : 24;
 	uint64_t channel                      : 8;  /**< PKI channel for the calendar table entry. Unused if CTL != 0. */
@@ -4003,34 +4003,33 @@ union cvmx_ilk_txx_cfg0 {
                                                          current value. */
 	uint64_t lnk_stats_ena                : 1;  /**< Enable link statistics counters. */
 	uint64_t mltuse_fc_ena                : 1;  /**< When set, the multiuse field of control words contains flow-control status. Otherwise, the
-                                                         multiuse field contains ILK_TX(0..1)_CFG1[TX_MLTUSE] */
+                                                         multiuse field contains ILK_TX()_CFG1[TX_MLTUSE] */
 	uint64_t cal_ena                      : 1;  /**< Enable TX calendar. When not asserted, the default calendar is used:
                                                          First control word:
-                                                         entry 0 = link
-                                                         entry 1 = backpressure ID 0
-                                                         entry 2 = backpressure ID 1
-                                                         - ...
-                                                         entry 15 = backpressure ID 14
+                                                         _ entry 0 = link
+                                                         _ entry 1 = backpressure ID 0
+                                                         _ entry 2 = backpressure ID 1
+                                                         _ ...
+                                                         _ entry 15 = backpressure ID 14
                                                          Second control word:
-                                                         entry 16 = link
-                                                         entry 17 = backpressure ID 15
-                                                         entry 18 = backpressure ID 16
-                                                         - ...
+                                                         _ entry 16 = link
+                                                         _ entry 17 = backpressure ID 15
+                                                         _ entry 18 = backpressure ID 16
+                                                         _ ...
                                                          This continues until the calendar depth is reached.
                                                          To disable backpressure completely, enable the calendar table and program each calendar
                                                          table entry to transmit XON. */
 	uint64_t mfrm_len                     : 13; /**< The quantity of data sent on each lane including one sync word, scrambler state, diag
                                                          word, zero or more skip words, and the data payload. Must be large than
-                                                         ILK_TX(0..1)_CFG1[SKIP_CNT] + 32.
+                                                         _ ILK_TX()_CFG1[SKIP_CNT] + 32.
                                                          Supported range:
-                                                         ILK_TX(0..1)_CFG1[SKIP_CNT] + 32 < MFRM_LEN <= 4096 */
+                                                         _ ILK_TX()_CFG1[SKIP_CNT] + 32 < MFRM_LEN <= 4096 */
 	uint64_t brst_shrt                    : 7;  /**< Minimum interval between burst control words, as a multiple of eight bytes. Supported
                                                          range from eight to 512 bytes (i.e. 0 < BRST_SHRT <= 64). */
 	uint64_t lane_rev                     : 1;  /**< Lane reversal. When enabled, lane striping is performed from most significant lane enabled
                                                          to least significant lane enabled. LANE_ENA must be zero before changing LANE_REV. */
 	uint64_t brst_max                     : 5;  /**< Maximum size of a data burst, as a multiple of 64-byte blocks. Supported range is from 64
-                                                         to 1024 bytes
-                                                         (i.e. 0 < BRST_MAX <= 16). */
+                                                         to 1024 bytes (i.e. 0 < BRST_MAX <= 16). */
 	uint64_t reserved_25_25               : 1;
 	uint64_t cal_depth                    : 9;  /**< Number of valid entries in the calendar. CAL_DEPTH[2:0] must be zero. Supported range is
                                                          from 0 to 288.
@@ -4040,22 +4039,22 @@ union cvmx_ilk_txx_cfg0 {
                                                          enabled in multiple
                                                          ILK_TX0/1_CFG0. Each bit of LANE_ENA maps to a TX lane (TLE) and a QLM lane. Note that
                                                          LANE_REV has no effect on this mapping.
-                                                         LANE_ENA[0] = TLE0  =  QLM4 lane 0
-                                                         LANE_ENA[1] = TLE1  =  QLM4 lane 1
-                                                         LANE_ENA[2] = TLE2  =  QLM4 lane 2
-                                                         LANE_ENA[3] = TLE3  =  QLM4 lane 3
-                                                         LANE_ENA[4] = TLE4  =  QLM5 lane 0
-                                                         LANE_ENA[5] = TLE5  =  QLM5 lane 1
-                                                         LANE_ENA[6] = TLE6  =  QLM5 lane 2
-                                                         LANE_ENA[7] = TLE7  =  QLM5 lane 3
-                                                         LANE_ENA[8] = TLE8  =  QLM6 lane 0
-                                                         LANE_ENA[9] = TLE9  =  QLM6 lane 1
-                                                         LANE_ENA[10] = TLE10  =  QLM6 lane 2
-                                                         LANE_ENA[11] = TLE11  =  QLM6 lane 3
-                                                         LANE_ENA[12] = TLE12  =  QLM7 lane 0
-                                                         LANE_ENA[13] = TLE13  =  QLM7 lane 1
-                                                         LANE_ENA[14] = TLE14  =  QLM7 lane 2
-                                                         LANE_ENA[15] = TLE15  =  QLM7 lane 3 */
+                                                         _ LANE_ENA<0> = TLE0  =  QLM4 lane 0.
+                                                         _ LANE_ENA<1> = TLE1  =  QLM4 lane 1.
+                                                         _ LANE_ENA<2> = TLE2  =  QLM4 lane 2.
+                                                         _ LANE_ENA<3> = TLE3  =  QLM4 lane 3.
+                                                         _ LANE_ENA<4> = TLE4  =  QLM5 lane 0.
+                                                         _ LANE_ENA<5> = TLE5  =  QLM5 lane 1.
+                                                         _ LANE_ENA<6> = TLE6  =  QLM5 lane 2.
+                                                         _ LANE_ENA<7> = TLE7  =  QLM5 lane 3.
+                                                         _ LANE_ENA<8> = TLE8  =  QLM6 lane 0.
+                                                         _ LANE_ENA<9> = TLE9  =  QLM6 lane 1.
+                                                         _ LANE_ENA<10> = TLE10  =  QLM6 lane 2.
+                                                         _ LANE_ENA<11> = TLE11  =  QLM6 lane 3.
+                                                         _ LANE_ENA<12> = TLE12  =  QLM7 lane 0.
+                                                         _ LANE_ENA<13> = TLE13  =  QLM7 lane 1.
+                                                         _ LANE_ENA<14> = TLE14  =  QLM7 lane 2.
+                                                         _ LANE_ENA<15> = TLE15  =  QLM7 lane 3. */
 #else
 	uint64_t lane_ena                     : 16;
 	uint64_t cal_depth                    : 9;
@@ -4181,14 +4180,14 @@ union cvmx_ilk_txx_cfg1 {
 	uint64_t reserved_53_59               : 7;
 	uint64_t brst_min                     : 5;  /**< Minimum size of a data burst, as a multiple of 32-byte blocks. 0 disables the scheduling
                                                          enhancement. When non-zero, must satisfy:
-                                                         (BRST_SHRT*8) <= (BRST_MIN*32) <= (BRST_MAX*64)/2. */
+                                                         _ (BRST_SHRT*8) <= (BRST_MIN*32) <= (BRST_MAX*64)/2. */
 	uint64_t reserved_43_47               : 5;
 	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. If 0x0, hardware
                                                          will compute it. Otherwise, SER_LIMIT must be set as follows:
-                                                         SER_LIMIT >= 148 + (BAUD / SCLK) * (12 + (NUM_LANES/2))
+                                                         _ SER_LIMIT >= 148 + (BAUD / SCLK) * (12 + (NUM_LANES/2))
                                                          For instance, for sclk=1.1GHz,BAUD=10.3125,NUM_LANES=16 :
-                                                         SER_LIMIT >= 148 + (10.3125 / 1.1 * (12 + (12/2))
-                                                         SER_LIMIT >= 317 */
+                                                         _ SER_LIMIT >= 148 + (10.3125 / 1.1 * (12 + (12/2))
+                                                         _ SER_LIMIT >= 317 */
 	uint64_t pkt_busy                     : 1;  /**< Packet busy. When set to 1, indicates the TX-link is transmitting data. */
 	uint64_t pipe_crd_dis                 : 1;  /**< Disable channel credits. Should be set to 1 when PKO is configured to ignore channel credits. */
 	uint64_t ptp_delay                    : 5;  /**< Reserved. */
@@ -4210,7 +4209,7 @@ union cvmx_ilk_txx_cfg1 {
                                                          the end of a burst. */
 	uint64_t rx_link_fc_ign               : 1;  /**< Ignore the link flow-control status received in burst/idle control words */
 	uint64_t rmatch                       : 1;  /**< Enable rate matching circuitry. */
-	uint64_t tx_mltuse                    : 8;  /**< Multiuse bits are used when ILK_TX(0..1)_CFG0[MLTUSE_FC_ENA] = 0. */
+	uint64_t tx_mltuse                    : 8;  /**< Multiuse bits are used when ILK_TX()_CFG0[MLTUSE_FC_ENA] = 0. */
 #else
 	uint64_t tx_mltuse                    : 8;
 	uint64_t rmatch                       : 1;
@@ -4350,10 +4349,10 @@ union cvmx_ilk_txx_cha_xonx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t status                       : 64; /**< PKI flow control status for backpressure ID 255-0, where a 0 indicates the presence of
                                                          backpressure (i.e. XOFF) and 1 indicates the absence of backpressure (i.e. XON).
-                                                         ILK_TX(0..1)_CHA_XON[0]--Channels 63-0
-                                                         ILK_TX(0..1)_CHA_XON[1]--Channels 127-64
-                                                         ILK_TX(0..1)_CHA_XON[2]--Channels 191-128
-                                                         ILK_TX(0..1)_CHA_XON[3]--Channels 255-192 */
+                                                         _ ILK_TX(0..1)_CHA_XON[0] -- Channels 63-0.
+                                                         _ ILK_TX(0..1)_CHA_XON[1] -- Channels 127-64.
+                                                         _ ILK_TX(0..1)_CHA_XON[2] -- Channels 191-128.
+                                                         _ ILK_TX(0..1)_CHA_XON[3] -- Channels 255-192. */
 #else
 	uint64_t status                       : 64;
 #endif
@@ -4591,14 +4590,14 @@ union cvmx_ilk_txx_int {
 	struct cvmx_ilk_txx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t fwc_dbe                      : 1;  /**< Flow control calendar table double-bit error. Throws ILK_INTSN_E::ILK_TX(0..1)_FWC_DBE. */
-	uint64_t fwc_sbe                      : 1;  /**< Flow control calendar table single-bit error. Throws ILK_INTSN_E::ILK_TX(0..1)_FWC_SBE. */
-	uint64_t txf_dbe                      : 1;  /**< TX FIFO double-bit error. Throws ILK_INTSN_E::ILK_TX(0..1)_TXF_DBE. */
-	uint64_t txf_sbe                      : 1;  /**< TX FIFO single-bit error. Throws ILK_INTSN_E::ILK_TX(0..1)_TXF_SBE. */
-	uint64_t stat_cnt_ovfl                : 1;  /**< Statistics counter overflow. Throws ILK_INTSN_E::ILK_TX(0..1)_STAT_CNT_OVFL. */
+	uint64_t fwc_dbe                      : 1;  /**< Flow control calendar table double-bit error. Throws ILK_INTSN_E::ILK_TX()_FWC_DBE. */
+	uint64_t fwc_sbe                      : 1;  /**< Flow control calendar table single-bit error. Throws ILK_INTSN_E::ILK_TX()_FWC_SBE. */
+	uint64_t txf_dbe                      : 1;  /**< TX FIFO double-bit error. Throws ILK_INTSN_E::ILK_TX()_TXF_DBE. */
+	uint64_t txf_sbe                      : 1;  /**< TX FIFO single-bit error. Throws ILK_INTSN_E::ILK_TX()_TXF_SBE. */
+	uint64_t stat_cnt_ovfl                : 1;  /**< Statistics counter overflow. Throws ILK_INTSN_E::ILK_TX()_STAT_CNT_OVFL. */
 	uint64_t bad_pipe                     : 1;  /**< Reserved. */
 	uint64_t bad_seq                      : 1;  /**< Received sequence is not SOP followed by 0 or more data cycles followed by EOP. Throws
-                                                         ILK_INTSN_E::ILK_TX(0..1)_BAD_SEQ. */
+                                                         ILK_INTSN_E::ILK_TX()_BAD_SEQ. */
 	uint64_t txf_err                      : 1;  /**< Reserved. */
 #else
 	uint64_t txf_err                      : 1;
@@ -4941,7 +4940,7 @@ union cvmx_ilk_txx_pkt_cntx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
 	uint64_t tx_pkt                       : 34; /**< Number of packets transmitted per channel. Wraps on overflow. On overflow, sets
-                                                         ILK_TX(0..1)_INT[STAT_CNT_OVFL]. */
+                                                         ILK_TX()_INT[STAT_CNT_OVFL]. */
 #else
 	uint64_t tx_pkt                       : 34;
 	uint64_t reserved_34_63               : 30;
diff --git a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
index 27f0052..49aa37b 100644
--- a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
@@ -366,10 +366,10 @@ union cvmx_lapx_edat_err_st {
 	struct cvmx_lapx_edat_err_st_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_24_63               : 40;
-	uint64_t fsyn                         : 8;  /**< Syndrome of last Expected Mask Ram ECC error. Latched when LAP(0..1)_GEN_INT[EDAT_SBE] or
+	uint64_t fsyn                         : 8;  /**< Syndrome of last Expected Mask Ram ECC error. Latched when LAP()_GEN_INT[EDAT_SBE] or
                                                          [EDAT_DBE] set */
 	uint64_t reserved_4_15                : 12;
-	uint64_t fadr                         : 4;  /**< Address of last Expected Mask Ram ECC error. Latched when LAP(0..1)_GEN_INT[EDAT_SBE] or
+	uint64_t fadr                         : 4;  /**< Address of last Expected Mask Ram ECC error. Latched when LAP()_GEN_INT[EDAT_SBE] or
                                                          [EDAT_DBE] set. */
 #else
 	uint64_t fadr                         : 4;
@@ -393,10 +393,10 @@ union cvmx_lapx_emsk_err_st {
 	struct cvmx_lapx_emsk_err_st_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_24_63               : 40;
-	uint64_t fsyn                         : 8;  /**< Syndrome of last Expected Data Ram ECC error. Latched when LAP(0..1)_GEN_INT[EMSK_SBE] or
+	uint64_t fsyn                         : 8;  /**< Syndrome of last Expected Data Ram ECC error. Latched when LAP()_GEN_INT[EMSK_SBE] or
                                                          [EMSK_DBE] set */
 	uint64_t reserved_4_15                : 12;
-	uint64_t fadr                         : 4;  /**< Address of last Expected Data Ram ECC error. Latched when LAP(0..1)_GEN_INT[EMSK_SBE] or
+	uint64_t fadr                         : 4;  /**< Address of last Expected Data Ram ECC error. Latched when LAP()_GEN_INT[EMSK_SBE] or
                                                          [EMSK_DBE] set. */
 #else
 	uint64_t fadr                         : 4;
@@ -460,7 +460,7 @@ typedef union cvmx_lapx_err_cfg cvmx_lapx_err_cfg_t;
 /**
  * cvmx_lap#_exp#_data
  *
- * Configures exception error masking; see Errors.
+ * Configures exception error masking.
  *
  */
 union cvmx_lapx_expx_data {
@@ -468,7 +468,7 @@ union cvmx_lapx_expx_data {
 	struct cvmx_lapx_expx_data_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t data                         : 64; /**< Data value expected. The packet must have bits matching this value if the corresponding
-                                                         bits in LAP(0..1)_EXP(0..15)_VALID are set. */
+                                                         bits in LAP()_EXP()_VALID are set. */
 #else
 	uint64_t data                         : 64;
 #endif
@@ -480,18 +480,16 @@ typedef union cvmx_lapx_expx_data cvmx_lapx_expx_data_t;
 /**
  * cvmx_lap#_exp#_valid
  *
- * Configures exception error masking; see Errors.
+ * Configures exception error masking.
  *
  */
 union cvmx_lapx_expx_valid {
 	uint64_t u64;
 	struct cvmx_lapx_expx_valid_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t valid                        : 64; /**< Valid mask. Each bit corresponds to a bit in
-                                                         LAP(0..1)_EXP(0..15)_VALID:
+	uint64_t valid                        : 64; /**< Valid mask. Each bit corresponds to a bit in LAP()_EXP()_VALID:
                                                          0 = Corresponding bit is a don't care.
-                                                         1 = Corresponding bit compared against
-                                                         LAP(0..1)_EXP(0..15)_VALID.
+                                                         1 = Corresponding bit compared against LAP()_EXP()_VALID.
                                                          Note that some response bits indicated by LAP_CTL_RTN_S are for Interlaken control, and
                                                          thus should always be zero (don't care) in LAP(0..1)_EXP_VALID(0). */
 #else
@@ -544,41 +542,41 @@ union cvmx_lapx_gen_int {
 	uint64_t reserved_19_63               : 45;
 	uint64_t xid_bad                      : 1;  /**< A response packet's transaction ID was targeted to an LAB not in PROCESSING state. Not
                                                          reported if packet also has CRC or MISMATCH errors. Typically indicates TCAM or
-                                                         configuration error. Throws LAP_INTSN_E::LAP(0..1)_GEN_XID_BAD. */
+                                                         configuration error. Throws LAP_INTSN_E::LAP()_GEN_XID_BAD. */
 	uint64_t nbr_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the NBR RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_NBR_DBE. */
+                                                         LAP_INTSN_E::LAP()_GEN_NBR_DBE. */
 	uint64_t nbr_sbe                      : 1;  /**< An ECC correctable error has occurred in the NBR RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_NBR_SBE. */
+                                                         LAP_INTSN_E::LAP()_GEN_NBR_SBE. */
 	uint64_t edat_dbe                     : 1;  /**< An ECC uncorrectable error has occurred in the EDAT RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_EDAT_DBE. See also LAP(0..1)_EDAT_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_EDAT_DBE. See also LAP()_EDAT_ERR_ST. */
 	uint64_t edat_sbe                     : 1;  /**< An ECC correctable error has occurred in the EDAT RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_EDAT_SBE. See also LAP(0..1)_EDAT_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_EDAT_SBE. See also LAP()_EDAT_ERR_ST. */
 	uint64_t emsk_dbe                     : 1;  /**< An ECC uncorrectable error has occurred in the EMSK RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_EMSK_DBE. See also LAP(0..1)_EMSK_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_EMSK_DBE. See also LAP()_EMSK_ERR_ST. */
 	uint64_t emsk_sbe                     : 1;  /**< An ECC correctable error has occurred in the EMSK RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_EMSK_SBE. See also LAP(0..1)_EMSK_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_EMSK_SBE. See also LAP()_EMSK_ERR_ST. */
 	uint64_t nxt_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the NXT RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_NXT_DBE. See also LAP(0..1)_NXT_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_NXT_DBE. See also LAP()_NXT_ERR_ST. */
 	uint64_t nxt_sbe                      : 1;  /**< An ECC correctable error has occurred in the NXT RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_NXT_SBE. See also LAP(0..1)_NXT_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_NXT_SBE. See also LAP()_NXT_ERR_ST. */
 	uint64_t sta_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the STA RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_STA_DBE. See also LAP(0..1)_STA_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_STA_DBE. See also LAP()_STA_ERR_ST. */
 	uint64_t sta_sbe                      : 1;  /**< An ECC correctable error has occurred in the STA RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_STA_SBE. See also LAP(0..1)_STA_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_STA_SBE. See also LAP()_STA_ERR_ST. */
 	uint64_t lab_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the LAB RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_LAB_DBE. See also LAP(0..1)_LAB_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_LAB_DBE. See also LAP()_LAB_ERR_ST. */
 	uint64_t lab_sbe                      : 1;  /**< An ECC correctable error has occurred in the LAB RAM. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_LAB_SBE. See also LAP(0..1)_LAB_ERR_ST. */
+                                                         LAP_INTSN_E::LAP()_GEN_LAB_SBE. See also LAP()_LAB_ERR_ST. */
 	uint64_t reserved_4_5                 : 2;
 	uint64_t timeout                      : 1;  /**< Indication timer transitioned an LAB to error state. This interrupt will typically be
-                                                         masked off, as error delivery can be in-band. Throws LAP_INTSN_E::LAP(0..1)_GEN_TIMEOUT. */
+                                                         masked off, as error delivery can be in-band. Throws LAP_INTSN_E::LAP()_GEN_TIMEOUT. */
 	uint64_t new_exc                      : 1;  /**< Indication the exception queue contains any received packet. Software should check the
-                                                         exception queue for new packets. Throws LAP_INTSN_E::LAP(0..1)_GEN_NEW_EXC. */
+                                                         exception queue for new packets. Throws LAP_INTSN_E::LAP()_GEN_NEW_EXC. */
 	uint64_t lost_exc                     : 1;  /**< Error indicating exception packet received with no LABs available on the exception queue;
-                                                         the exception packet was dropped. Throws LAP_INTSN_E::LAP(0..1)_GEN_LOST_EXC. */
+                                                         the exception packet was dropped. Throws LAP_INTSN_E::LAP()_GEN_LOST_EXC. */
 	uint64_t labs_out                     : 1;  /**< Error indicating did push with no free LABs available, or
-                                                         LAP(0..1)_QUE(0..2)_CFG[MAX_LABS] was exceeded. Throws
-                                                         LAP_INTSN_E::LAP(0..1)_GEN_LABS_OUT. */
+                                                         LAP()_QUE()_CFG[MAX_LABS] was exceeded. Throws
+                                                         LAP_INTSN_E::LAP()_GEN_LABS_OUT. */
 #else
 	uint64_t labs_out                     : 1;
 	uint64_t lost_exc                     : 1;
@@ -642,8 +640,8 @@ typedef union cvmx_lapx_labx_state cvmx_lapx_labx_state_t;
 /**
  * cvmx_lap#_lab_data#
  *
- * "This register reads raw data from the LABs. The address is calculated from (LAB#  *
- * words_per_lab_from_table_in_LAP(0..1)_CFG[LAB_SIZE] + offset_in_LAB) * 8."
+ * This register reads raw data from the LABs. The address is calculated from (LAB_number *
+ * words_per_lab_from_table_in_LAP()_CFG[LAB_SIZE] + offset_in_LAB) * 8.
  */
 union cvmx_lapx_lab_datax {
 	uint64_t u64;
@@ -669,7 +667,7 @@ union cvmx_lapx_lab_err_st {
 	struct cvmx_lapx_lab_err_st_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_26_63               : 38;
-	uint64_t fsyn                         : 10; /**< Syndrome of last LAB data ram ECC error. Latched when LAP(0..1)_GEN_INT[LAB_SBE] or [LAB_DBE] set */
+	uint64_t fsyn                         : 10; /**< Syndrome of last LAB data ram ECC error. Latched when LAP()_GEN_INT[LAB_SBE] or [LAB_DBE] set */
 	uint64_t reserved_10_15               : 6;
 	uint64_t fadr                         : 10; /**< Reserved. */
 #else
@@ -694,10 +692,10 @@ union cvmx_lapx_nxt_err_st {
 	struct cvmx_lapx_nxt_err_st_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_21_63               : 43;
-	uint64_t fsyn                         : 5;  /**< Syndrome of last Next Pointer Ram ECC error. Latched when LAP(0..1)_GEN_INT[NXT_SBE] or
+	uint64_t fsyn                         : 5;  /**< Syndrome of last Next Pointer Ram ECC error. Latched when LAP()_GEN_INT[NXT_SBE] or
                                                          [NXT_DBE] set */
 	uint64_t reserved_8_15                : 8;
-	uint64_t fadr                         : 8;  /**< Address of last Next Pointer Ram ECC error. Latched when LAP(0..1)_GEN_INT[NXT_SBE] or
+	uint64_t fadr                         : 8;  /**< Address of last Next Pointer Ram ECC error. Latched when LAP()_GEN_INT[NXT_SBE] or
                                                          [NXT_DBE] set. */
 #else
 	uint64_t fadr                         : 8;
@@ -719,9 +717,9 @@ union cvmx_lapx_quex_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t max_labs                     : 9;  /**< Maximum number of LABS allowed to be assigned to this queue; compared against
-                                                         LAP(0..1)_QUE(0..2)_STATE[LABS_RX] + LAP(0..1)_QUE(0..2)_STATE[LABS_PROC] to generate
+                                                         LAP()_QUE()_STATE[LABS_RX] + LAP()_QUE()_STATE[LABS_PROC] to generate
                                                          errors. The total across all queues' [MAX_LABS] may be over-provisioned, in which case the
-                                                         global LAP(0..1)_SFT_RSTLAP(0..1)_CFG[LAB_SIZE] number of LABs will throttle the
+                                                         global LAP()_CFG[LAB_SIZE] number of LABs will throttle the
                                                          transaction count. */
 #else
 	uint64_t max_labs                     : 9;
@@ -832,9 +830,9 @@ union cvmx_lapx_sta_err_st {
 	struct cvmx_lapx_sta_err_st_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_23_63               : 41;
-	uint64_t fsyn                         : 7;  /**< Syndrome of last LAB state ram ECC error. Latched when LAP(0..1)_GEN_INT[STA_SBE] or [STA_DBE] set */
+	uint64_t fsyn                         : 7;  /**< Syndrome of last LAB state ram ECC error. Latched when LAP()_GEN_INT[STA_SBE] or [STA_DBE] set */
 	uint64_t reserved_8_15                : 8;
-	uint64_t fadr                         : 8;  /**< Address of last LAB state ram ECC error. Latched when LAP(0..1)_GEN_INT[STA_SBE] or [STA_DBE] set. */
+	uint64_t fadr                         : 8;  /**< Address of last LAB state ram ECC error. Latched when LAP()_GEN_INT[STA_SBE] or [STA_DBE] set. */
 #else
 	uint64_t fadr                         : 8;
 	uint64_t reserved_8_15                : 8;
@@ -860,15 +858,15 @@ union cvmx_lapx_timeout {
                                                          0x0 = Timeout between 256 and 511 cycles.
                                                          0x1 = Timeout between 512 and 1023 cycles.
                                                          0x2 = Timeout between 768 and 1535 cycles.
-                                                         etc. */
+                                                         _ etc. */
 	uint64_t reserved_12_15               : 4;
 	uint64_t resp                         : 12; /**< Timeout waiting for a response in number of SCLKs minus one divided by 256. After between
                                                          one and two times this interval an in-flight LAB will be considered lost and marked as
-                                                         RECEIVED with error. RESP must be set to >= (2 * LAP(0..1)_TIMEOUT[IOBDMA] + 1).
+                                                         RECEIVED with error. RESP must be set to >= (2 * LAP()_TIMEOUT[IOBDMA] + 1).
                                                          0x0 = Timeout between 256 and 511 cycles.
                                                          0x1 = Timeout between 512 and 1023 cycles.
                                                          0x2 = Timeout between 768 and 1535 cycles.
-                                                         etc. */
+                                                         _ etc. */
 #else
 	uint64_t resp                         : 12;
 	uint64_t reserved_12_15               : 4;
@@ -883,7 +881,7 @@ typedef union cvmx_lapx_timeout cvmx_lapx_timeout_t;
 /**
  * cvmx_lap#_xid_pos
  *
- * Configures how to insert and extract transaction ids; see Transaction ID Assignment.
+ * Configures how to insert and extract transaction ids.
  *
  */
 union cvmx_lapx_xid_pos {
@@ -893,8 +891,7 @@ union cvmx_lapx_xid_pos {
 	uint64_t reserved_33_63               : 31;
 	uint64_t as_only                      : 1;  /**< Insert/extract in Interlaken-LA application specific AS fields. If set and REQ_WD or
                                                          RTN_WD are zero, the XID field that is inserted or extracted respectively will skip over
-                                                         the non-application specific fields in the Interlaken LA header. See Transaction ID
-                                                         Packing. */
+                                                         the non-application specific fields in the Interlaken LA header. */
 	uint64_t reserved_26_31               : 6;
 	uint64_t rtn_wd                       : 4;  /**< Extract transaction tag from this 64-bit word number of the return packet; typically the
                                                          same value as [REQ_WD]. Word 0 is the Interlaken control word, word 1 is the first word of
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index f6fe814..6e43dce 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -8181,7 +8181,7 @@ typedef union cvmx_lmcx_mr_mpr_ctl cvmx_lmcx_mr_mpr_ctl_t;
  * 0xB: mem_msb = mem_adr[36].
  * 0xC-0xF = Reserved.
  *
- * For example, for a DIMM made of Samsung's K4B1G0846C-ZCF7 1Gb (16M * 8 bit * 8 bank) DDR3
+ * For example, for a DIMM made of Samsung's K4B1G0846C-ZCF7 1Gb (16M * 8 bit * 8 bank)
  * parts, the column address width = 10; so with 10b of col, 3b of bus, 3b of bank, row_lsb = 16.
  * Therefore, row = mem_adr[29:16] and mem_msb = 4.
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index caeb024..8cd2ece 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -4899,10 +4899,10 @@ union cvmx_mio_fus_dat2 {
 	uint64_t nomul                        : 1;  /**< Fuse information - VMUL disable. */
 	uint64_t nocrypto                     : 1;  /**< Fuse information - DORM_CRYPTO and NOCRYPTO together select one of four mutually-exclusive
                                                          modes:
-                                                         DORM_CRYPTO = 0, NOCRYPTO = 0 AES/DES/HASH enabled.
-                                                         DORM_CRYPTO = 0, NOCRYPTO = 1 AES/DES/HASH disabled.
-                                                         DORM_CRYPTO = 1, NOCRYPTO = 0 Dormant encryption enable.
-                                                         DORM_CRYPTO = 1, NOCRYPTO = 1 Authentik mode. */
+                                                         _ DORM_CRYPTO = 0, NOCRYPTO = 0 AES/DES/HASH enabled.
+                                                         _ DORM_CRYPTO = 0, NOCRYPTO = 1 AES/DES/HASH disabled.
+                                                         _ DORM_CRYPTO = 1, NOCRYPTO = 0 Dormant encryption enable.
+                                                         _ DORM_CRYPTO = 1, NOCRYPTO = 1 Authentik mode. */
 	uint64_t reserved_24_25               : 2;
 	uint64_t chip_id                      : 8;  /**< Fuse information - chip ID. */
 	uint64_t reserved_0_15                : 16;
@@ -5142,8 +5142,8 @@ union cvmx_mio_fus_dat3 {
 	struct cvmx_mio_fus_dat3_cn61xx       cn68xxp1;
 	struct cvmx_mio_fus_dat3_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow
-                                                         of these fuses will XOR with this value. */
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
+                                                         will XOR with this value. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
@@ -5152,18 +5152,18 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
 	uint64_t pll_half_dis                 : 1;  /**< Fuse information - Coprocessor-clock PLL control. */
 	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C cripple:
-                                                         0 -- full cache (4-way 512KB)
-                                                         1 -- 3/4 ways   (3-way 384KB)
-                                                         2 -- 1/2 ways   (2-way 256KB)
-                                                         3 -- 1/4 ways   (1-way 128KB)
-                                                         4-7 -- illegal */
+                                                         0x0 = Full cache (4-way 512 KB).
+                                                         0x1 = 3/4 ways (3-way 384 KB).
+                                                         0x2 = 1/2 ways (2-way 256 KB).
+                                                         0x3 = 1/4 ways (1-way 128 KB).
+                                                         0x4-0x7 = Reserved. */
 	uint64_t reserved_31_31               : 1;
-	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information */
+	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information. */
 	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIE specification. */
-	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown */
-	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore */
-	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable */
-	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE) */
+	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
+	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
+	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
 	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: dflt value is 0x11. Soft or hard blow
                                                          of these fuses will XOR with this value. */
 	uint64_t reserved_0_17                : 18;
@@ -5208,7 +5208,7 @@ union cvmx_mio_fus_dat3 {
                                                          0x4-0x7 = Reserved. */
 	uint64_t reserved_31_31               : 1;
 	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information. */
-	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIE specification. */
+	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIe specification. */
 	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
 	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
@@ -5255,7 +5255,7 @@ union cvmx_mio_fus_dat4 {
 	struct cvmx_mio_fus_dat4_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t global_rclk_byp_select       : 1;  /**< Reserved. */
-	uint64_t global_rclk_byp_setting      : 11; /**< Bits 11:1. Reserved. */
+	uint64_t global_rclk_byp_setting      : 11; /**< Bits<11:1>. Reserved. */
 	uint64_t east_rclk_byp_select         : 1;  /**< Reserved. */
 	uint64_t east_rclk_byp_setting        : 12; /**< Reserved. */
 	uint64_t cmb_rclk_byp_select          : 1;  /**< Reserved. */
@@ -5402,9 +5402,9 @@ union cvmx_mio_fus_pll {
 	uint64_t rclk_align_r                 : 8;  /**< RCLK right alignment settings */
 	uint64_t rclk_align_l                 : 8;  /**< RCLK left alignment settings */
 	uint64_t reserved_15_31               : 17;
-	uint64_t core_status                  : 3;  /**< Core clock PLL status information. */
+	uint64_t core_status                  : 3;  /**< Core-clock PLL status information. */
 	uint64_t reserved_11_11               : 1;
-	uint64_t pnr_status                   : 3;  /**< PNR clock PLL status information. */
+	uint64_t pnr_status                   : 3;  /**< Coprocessor-clock PLL status information. */
 	uint64_t c_cout_rst                   : 1;  /**< Core clkout postscaler reset */
 	uint64_t c_cout_sel                   : 2;  /**< Core clkout select
                                                          0=RCLK,1=PS output,2=PLL output,3=undivided RCLK |   $PR
@@ -5512,14 +5512,18 @@ union cvmx_mio_fus_pll {
                                                          least 10 ref-clock cycles prior to changing C_COUT_SEL. The core clockout postscaler
                                                          should remain under reset for at least 10 ref-clock cycles after C_COUT_SEL changes. */
 	uint64_t c_cout_sel                   : 2;  /**< Core clockout select:
-                                                         0x0 = core clock 0x2 = PLL output
-                                                         0x1 = PS output 0x3 = undivided core clock */
+                                                         0x0 = Core clock.
+                                                         0x1 = PS output.
+                                                         0x2 = PLL output.
+                                                         0x3 = Undivided core clock. */
 	uint64_t pnr_cout_rst                 : 1;  /**< PNR clockout postscaler reset. The PNR clockout postscaler should be placed in reset at
                                                          least 10 ref-clock cycles prior to changing PNR_COUT_SEL. The PNR clockout postscaler
                                                          should remain under reset for at least 10 ref-clock cycles after PNR_COUT_SEL changes. */
 	uint64_t pnr_cout_sel                 : 2;  /**< PNR clockout select:
-                                                         0x0 = coprocessor clock 0x2 = PLL output
-                                                         0x1 = PS output 0x3 = undivided core clock */
+                                                         0x0 = Coprocessor clock.
+                                                         0x1 = PS output.
+                                                         0x2 = PLL output.
+                                                         0x3 = Undivided core clock. */
 	uint64_t reserved_0_1                 : 2;
 #else
 	uint64_t reserved_0_1                 : 2;
@@ -5956,7 +5960,7 @@ union cvmx_mio_fus_read_times {
                                                          PLL_REF_CLK of 50 MHz, 20ns at 100MHz. */
 	uint64_t setup                        : 4;  /**< Setup of CSB, PGENB, LOAD to rising edge of STROBE in read and write modes in PLL_REF_CLK
                                                          + 1 cycles. tsu_CS = 16ns, tsu_PG = 14ns, tsu_LD_r = 10ns. Default of 0x0 yields 20 ns
-                                                         plush ASU cycles at PLL_REF_CLK of 50 MHz, 10ns + ASU at 100MHz. */
+                                                         plus ASU cycles at PLL_REF_CLK of 50 MHz, 10ns + ASU at 100MHz. */
 #else
 	uint64_t setup                        : 4;
 	uint64_t asu                          : 4;
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 0d825df..b422e6b 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1510,7 +1510,8 @@ union cvmx_pki_clx_pcamx_actionx {
                                                          _ else = reserved.
                                                          Must be zero for invalid entries. */
 	uint64_t setty                        : 5;  /**< Set pointer type. If non-zero, indicates the layer type to be set as described under
-                                                         PKI_PCAM_TERM_E. Values are enumerated in PKI_LTYPE_E. Must be zero for invalid entries. */
+                                                         PKI_PCAM_TERM_E. Values are enumerated in PKI_LTYPE_E. Must be zero for invalid entries.
+                                                         The PKI_PCAM_TERM_E table enumerates legal/common SETTY values. */
 	uint64_t advance                      : 8;  /**< Relative number of bytes to advance scan pointer when entry matches.
                                                          Must be even. Must be zero for invalid entries and for TERMs that do not allow
                                                          an advance as specified in the PKI_PCAM_TERM_E table. */
@@ -3443,15 +3444,22 @@ union cvmx_pki_stylex_buf {
                                                          transferred and the word will reach memory (FIRST_SKIP is greater than that word number),
                                                          then the final WQE memory word will be zero, not the PIX register contents. */
 	uint64_t wqe_skip                     : 2;  /**< WQE start offset. The number of 128-byte cache lines to skip between the buffer pointer
-                                                         and WORD0 of the work-queue entry. See PKI Hardware Allocating Multiple Buffers. */
+                                                         and WORD0 of the work-queue entry. See PKI Hardware Allocating Multiple Buffers.
+                                                         If [DIS_WQ_DAT]=1, legal values must satisfy:
+                                                           * MB_SIZE >= (PKI_STYLE()_BUF[WQE_SKIP] * (128/8)) + 18
+                                                         If [DIS_WQ_DAT]=0, legal values must satisfy:
+                                                           * (WQE_SKIP * (128/8)) + 4 <= FIRST_SKIP, to insure the minimum of four work-queue entry
+                                                             words will fit within FIRST_SKIP. */
 	uint64_t first_skip                   : 6;  /**< The number of eight-byte words from the top of the first MBUF that the PKI stores the next
-                                                         pointer. If [DIS_WQ_DAT]=1, any value is legal. If [DIS_WQ_DAT]=0, legal values must
-                                                         satisfy:
-                                                         * FIRST_SKIP <= PKI_STYLE()_BUF[MB_SIZE] - 18.
-                                                         * FIRST_SKIP must be at least 0x4, but 0x5 is recommended minimum. 0x4 will drop WQE
-                                                         WORD4, for use in backward compatible applications.
-                                                         * WQE_SKIP * (128/8) + 4 <= FIRST_SKIP, to insure the minimum of four work-queue entry
-                                                         words will fit within FIRST_SKIP. */
+                                                         pointer.
+                                                         If [DIS_WQ_DAT]=1, legal values must satisfy:
+                                                           * FIRST_SKIP <= PKI_STYLE()_BUF[MB_SIZE] - 18.
+                                                         If [DIS_WQ_DAT]=0, legal values must satisfy:
+                                                           * FIRST_SKIP <= PKI_STYLE()_BUF[MB_SIZE] - 18.
+                                                           * (WQE_SKIP * (128/8)) + X <= FIRST_SKIP,
+                                                             X must be at least 0x4 to insure the minimum of four work-queue entry,
+                                                             but 0x5 is recommended minimum. X=0x4 will drop WQE WORD4, for use in
+                                                             backward compatible applications. */
 	uint64_t later_skip                   : 6;  /**< The number of eight-byte words from the top of any MBUF that is not the first MBUF that
                                                          PKI writes the next-pointer to. Legal values are 0 to PKI_STYLE()_BUF[MB_SIZE] - 18. */
 	uint64_t opc_mode                     : 2;  /**< Select the style of write to the L2C.
@@ -3470,9 +3478,18 @@ union cvmx_pki_stylex_buf {
                                                          lines in the buffer will not be modified and will retain stale data (from the buffer's
                                                          previous use). This setting may decrease the peak PKI performance by up to half on small
                                                          packets. */
-	uint64_t mb_size                      : 13; /**< The number of eight-byte words to store into a buffer. This must be even, in the range of
-                                                         32 to 4096. This must be less than or equal to the maximum size of every free page in
-                                                         every FPA pool this style may use. */
+	uint64_t mb_size                      : 13; /**< The number of eight-byte words between the start of a buffer and the last word
+                                                         that PKI may write into that buffer. The total amount of data stored by PKI into
+                                                         the buffer will be MB_SIZE minus FIRST_SKIP or LATER_SKIP.
+                                                         This must be even, in the range of 32 to 4096. This must be less than or equal
+                                                         to the maximum size of every free page in every FPA pool this style may use.
+                                                         If [DIS_WQ_DAT]=1, legal values must satisfy:
+                                                           * MB_SIZE >= (PKI_STYLE()_BUF[WQE_SKIP] * (128/8)) + 18
+                                                           * MB_SIZE >= PKI_STYLE()_BUF[FIRST_SKIP] + 18.
+                                                           * MB_SIZE >= PKI_STYLE()_BUF[LATER_SKIP] + 18.
+                                                         If [DIS_WQ_DAT]=0, legal values must satisfy:
+                                                           * MB_SIZE >= PKI_STYLE()_BUF[FIRST_SKIP] + 18.
+                                                           * MB_SIZE >= PKI_STYLE()_BUF[LATER_SKIP] + 18. */
 #else
 	uint64_t mb_size                      : 13;
 	uint64_t dis_wq_dat                   : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 438d24b..8398ddb 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -423,11 +423,11 @@ union cvmx_rst_int {
 	struct cvmx_rst_int_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_11_63               : 53;
-	uint64_t perst                        : 3;  /**< PERST*_L asserted while RST_CTL*[RST_RCV] = 1 and RST_CTL*[RST_CHIP] = 0. One bit
+	uint64_t perst                        : 3;  /**< PERST*_L asserted while RST_CTL()[RST_RCV] = 1 and RST_CTL()[RST_CHIP] = 0. One bit
                                                          corresponds to each controller. */
 	uint64_t reserved_3_7                 : 5;
-	uint64_t rst_link                     : 3;  /**< A controller link-down/hot-reset occurred while RST_CTL*[RST_LINK] = 0. Software must
-                                                         assert then deassert RST_SOFT_PRST*[SOFT_PRST]. One bit corresponds to each controller. */
+	uint64_t rst_link                     : 3;  /**< A controller link-down/hot-reset occurred while RST_CTL()[RST_LINK] = 0. Software must
+                                                         assert then deassert RST_SOFT_PRST()[SOFT_PRST]. One bit corresponds to each controller. */
 #else
 	uint64_t rst_link                     : 3;
 	uint64_t reserved_3_7                 : 5;
diff --git a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
index dff90bc..59f6e90 100644
--- a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
@@ -627,8 +627,9 @@ typedef union cvmx_uctlx_clk_rst_ctl cvmx_uctlx_clk_rst_ctl_t;
 /**
  * cvmx_uctl#_ctl
  *
- * This register controls clocks, resets, power, and BIST. This register can be reset by IOI reset.
+ * This register controls clocks, resets, power, and BIST.
  *
+ * This register can be reset by IOI reset.
  */
 union cvmx_uctlx_ctl {
 	uint64_t u64;
@@ -642,7 +643,7 @@ union cvmx_uctlx_ctl {
                                                          To avoid race conditions, software must first perform a CSR write operation that puts the
                                                          CLEAR_BIST setting into the correct state and then perform another CSR write operation to
                                                          set the BIST trigger (keeping the CLEAR_BIST state constant).
-                                                         CLEAR BIST completion is indicated by UCTL(0)_BIST_STATUS[NDONE]. A BIST clear operation
+                                                         CLEAR BIST completion is indicated by UCTL()_BIST_STATUS. A BIST clear operation
                                                          takes almost 2,000 controller-clock cycles for the largest RAM. */
 	uint64_t start_bist                   : 1;  /**< Rising edge starts BIST on the memories in USBH.
                                                          To run BIST, the controller clock must be both configured and enabled, and should be
@@ -651,7 +652,7 @@ union cvmx_uctlx_ctl {
                                                          Also, the UCTL, UAHC, and UPHY should be held in software- initiated reset (using
                                                          UPHY_RST, UAHC_RST, UCTL_RST) until BIST is complete.
                                                          BIST defect status can be checked after FULL BIST completion, both of which are indicated
-                                                         in UCTL(0)_BIST_STATUS. The full BIST run takes almost 80,000 controller-clock cycles for
+                                                         in UCTL()_BIST_STATUS. The full BIST run takes almost 80,000 controller-clock cycles for
                                                          the largest RAM. */
 	uint64_t ref_clk_sel                  : 2;  /**< Reference clock select. Choose reference-clock source for the SuperSpeed and high-speed
                                                          PLL blocks.
@@ -692,8 +693,8 @@ union cvmx_uctlx_ctl {
                                                          leave at reset value of 0x0. This value may only be changed during UPHY_RST.
                                                          This value is superseded by the REF_CLK_FSEL<5:3> selection. */
 	uint64_t ref_ssp_en                   : 1;  /**< Enables reference clock to the prescaler for SuperSpeed function. This should always be
-                                                         enabled since this output clock is used to drive the UAHC suspend-mode clock during low-
-                                                         power states.
+                                                         enabled since this output clock is used to drive the UAHC suspend-mode clock during
+                                                         low-power states.
                                                          This value can be changed only during UPHY_RST or during low-power states.
                                                          The reference clock must be running and stable before UPHY_RST is deasserted and before
                                                          REF_SSP_EN is asserted. */
@@ -715,8 +716,8 @@ union cvmx_uctlx_ctl {
                                                          0 = Use the divided coprocessor clock from the H_CLKDIV divider.
                                                          1 = Use the bypass clock from the GPIO pins.
                                                          This signal is just a multiplexer-select signal; it does not enable the controller clock.
-                                                         You must still set H_CLKDIV_EN separately. H_CLK_BYP_SEL select should not be changed
-                                                         unless H_CLKDIV_EN is disabled.
+                                                         You must still set H_CLK_EN separately. H_CLK_BYP_SEL select should not be changed
+                                                         unless H_CLK_EN is disabled.
                                                          The bypass clock can be selected and running even if the controller-clock dividers are not
                                                          running.
                                                          INTERNAL: Generally bypass is only used for scan purposes. */
@@ -759,14 +760,14 @@ union cvmx_uctlx_ctl {
                                                          reporting connect/disconnect events on the port and keeps the port in disabled state. This
                                                          could be used for security reasons where hardware can disable a port regardless of whether
                                                          xHCI driver enables a port or not.
-                                                         UAHC(0)_HCSPARAMS1[MAXPORTS] is not affected by this signal.
+                                                         UAHC()_HCSPARAMS1[MAXPORTS] is not affected by this signal.
                                                          This is a strap signal; it should be modified only when UPHY_RST is asserted. */
 	uint64_t reserved_17_17               : 1;
 	uint64_t usb2_port_disable            : 1;  /**< Disables USB2 (high-speed/full-speed/low-speed) portion of this PHY. When set to 1, this
                                                          signal stops reporting connect/disconnect events on the port and keeps the port in
                                                          disabled state. This could be used for security reasons where hardware can disable a port
                                                          regardless of whether xHCI driver enables a port or not.
-                                                         UAHC(0)_HCSPARAMS1[MAXPORTS] is not affected by this signal.
+                                                         UAHC()_HCSPARAMS1[MAXPORTS] is not affected by this signal.
                                                          This is a strap signal; it should only be modified when UPHY_RST is asserted.
                                                          If Port0 is required to be disabled, ensure that the utmi_clk[0] is running at the normal
                                                          speed. Also, all the enabled USB2.0 ports should have the same clock frequency as Port0. */
@@ -834,7 +835,6 @@ typedef union cvmx_uctlx_ctl cvmx_uctlx_ctl_t;
 /**
  * cvmx_uctl#_ecc
  *
- * Accessible by: only when H_CLKDIV_EN
  * This register can be used to disable ECC correction, insert ECC errors, and debug ECC
  * failures.
  * * The ECC_ERR* fields are captured when there are no outstanding ECC errors indicated in
@@ -845,11 +845,15 @@ typedef union cvmx_uctlx_ctl cvmx_uctlx_ctl_t;
  * *ECC_*_DIS = 0x1, then no data-correction occurs.
  * * The *ECC_FLIP_SYND fields flip the syndrome<1:0> bits to generate single-bit/double-bit
  * error for testing.
- * 0x0 = normal operation
- * 0x1 = SBE on bit[0]
- * 0x2 = SBE on bit[1]
- * 0x3 = DBE on bit[1:0]
- * This register can be reset by IOI reset or with UCTL(0)_CTL[UCTL_RESET].
+ *
+ * 0x0 = normal operation.
+ * 0x1 = SBE on bit[0].
+ * 0x2 = SBE on bit[1].
+ * 0x3 = DBE on bit[1:0].
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
  */
 union cvmx_uctlx_ecc {
 	uint64_t u64;
@@ -1050,10 +1054,12 @@ typedef union cvmx_uctlx_erto_ctl cvmx_uctlx_erto_ctl_t;
 /**
  * cvmx_uctl#_host_cfg
  *
- * Accessible by: only when H_CLKDIV_EN
  * This register allows configuration of various host controller (UAHC) features. Most of these
  * are strap signals and should be modified only while the controller is not running.
- * This register can be reset by IOI reset or with UCTL(0)_CTL[UCTL_RESET].
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
  */
 union cvmx_uctlx_host_cfg {
 	uint64_t u64;
@@ -1086,21 +1092,21 @@ union cvmx_uctlx_host_cfg {
                                                          okay). */
 	uint64_t oci_active_high_en           : 1;  /**< Overcurrent sense selection. The off-chip sense (high/low) is converted to match the
                                                          controller's active-high sense.
-                                                         1 = Overcurrent indication from off-chip source is active-high.
                                                          0 = Overcurrent indication from off-chip source is active-low.
+                                                         1 = Overcurrent indication from off-chip source is active-high.
                                                          This is a strap signal; it should only be modified when UAHC is in reset (soft-reset
                                                          okay). */
 	uint64_t ppc_en                       : 1;  /**< Port-power-control enable.
-                                                         0 = UAHC(0)_HCCPARAMS[PPC] report port-power-control feature is unavailable.
-                                                         1 = UAHC(0)_HCCPARAMS[PPC] reports port-power-control feature is available. PPC output
+                                                         0 = UAHC()_HCCPARAMS[PPC] report port-power-control feature is unavailable.
+                                                         1 = UAHC()_HCCPARAMS[PPC] reports port-power-control feature is available. PPC output
                                                          from UAHC is taken to the GPIO signals and sense-converted based on PPC_ACTIVE_HIGH_EN.
                                                          The MIO GPIO multiplexer must be programmed accordingly.
                                                          This is a strap signal; it should only be modified when either the UCTL_CTL[UAHC] or
                                                          UAHC_GCTL[CoreSoftReset] is asserted. */
 	uint64_t ppc_active_high_en           : 1;  /**< Port power control sense selection. The active-high port-power-control output to off-chip
                                                          source is converted to match the off-chip sense.
-                                                         1 = Port-power control to off-chip source is active-high.
                                                          0 = Port-power control to off-chip source is active-low.
+                                                         1 = Port-power control to off-chip source is active-high.
                                                          This is a strap signal; it should only be modified when either the UCTL_CTL[UAHC] or
                                                          UAHC_GCTL[CoreSoftReset] is asserted. */
 	uint64_t reserved_0_23                : 24;
@@ -1242,7 +1248,7 @@ typedef union cvmx_uctlx_int_reg cvmx_uctlx_int_reg_t;
  * cvmx_uctl#_intstat
  *
  * This register provides a summary of different bits of RSL interrupts. DBEs are detected and
- * SBE are corrected. For debugging output for ECC DBEs/SBEs, see UCTL(0)_ECC. This register can
+ * SBE are corrected. For debugging output for ECC DBEs/SBEs, see UCTL()_ECC. This register can
  * be reset by IOI reset.
  */
 union cvmx_uctlx_intstat {
@@ -1250,40 +1256,28 @@ union cvmx_uctlx_intstat {
 	struct cvmx_uctlx_intstat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_30_63               : 34;
-	uint64_t xm_r_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_XM_R_DBE. */
-	uint64_t xm_r_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster read-data FIFO. Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_XM_R_SBE. */
-	uint64_t xm_w_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster write-data FIFO. Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_XM_W_DBE. */
-	uint64_t xm_w_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster write-data FIFO. Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_XM_W_SBE. */
+	uint64_t xm_r_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_r_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster read-data FIFO. */
+	uint64_t xm_w_dbe                     : 1;  /**< Detected double-bit error on the UCTL AxiMaster write-data FIFO. */
+	uint64_t xm_w_sbe                     : 1;  /**< Detected single-bit error on the UCTL AxiMaster write-data FIFO. */
 	uint64_t reserved_22_25               : 4;
-	uint64_t ram2_dbe                     : 1;  /**< Detected double-bit error on the UAHC RxFIFO RAMs (RAM2). Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_RAM2_DBE. */
-	uint64_t ram2_sbe                     : 1;  /**< Detected single-bit error on the UAHC RxFIFO RAMs (RAM2). Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_RAM2_SBE. */
-	uint64_t ram1_dbe                     : 1;  /**< Detected double-bit error on the UAHC TxFIFO RAMs (RAM1). Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_RAM1_DBE. */
-	uint64_t ram1_sbe                     : 1;  /**< Detected single-bit error on the UAHC TxFIFO RAMs (RAM1). Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_RAM2_SBE. */
-	uint64_t ram0_dbe                     : 1;  /**< Detected double-bit error on the UAHC Desc/Reg Cache (RAM0). Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_RAM0_DBE. */
-	uint64_t ram0_sbe                     : 1;  /**< Detected single-bit error on the UAHC Desc/Reg Cache (RAM0). Throws
-                                                         UCTL_INTSN_E::UCTL(0)_INTSTAT_RAM0_SBE. */
+	uint64_t ram2_dbe                     : 1;  /**< Detected double-bit error on the UAHC RxFIFO RAMs (RAM2). */
+	uint64_t ram2_sbe                     : 1;  /**< Detected single-bit error on the UAHC RxFIFO RAMs (RAM2). */
+	uint64_t ram1_dbe                     : 1;  /**< Detected double-bit error on the UAHC TxFIFO RAMs (RAM1). */
+	uint64_t ram1_sbe                     : 1;  /**< Detected single-bit error on the UAHC TxFIFO RAMs (RAM1). */
+	uint64_t ram0_dbe                     : 1;  /**< Detected double-bit error on the UAHC Desc/Reg Cache (RAM0). */
+	uint64_t ram0_sbe                     : 1;  /**< Detected single-bit error on the UAHC Desc/Reg Cache (RAM0). */
 	uint64_t reserved_3_15                : 13;
 	uint64_t xm_bad_dma                   : 1;  /**< Detected bad DMA access from UAHC to IOI. Error information is logged in
-                                                         UCTL(0)_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates the
+                                                         UCTL()_SHIM_CFG[XM_BAD_DMA_*]. Received a DMA request from UAHC that violates the
                                                          assumptions made by the AXI-to-IOI shim. Such scenarios include: illegal length/size
                                                          combinations and address out-of-bounds.
                                                          For more information on exact failures, see the description in
-                                                         UCTL(0)_SHIM_CFG[XM_BAD_DMA_TYPE]. The hardware does not translate the request correctly
-                                                         and results may violate IOI protocols.
-                                                         Throws UCTL_INTSN_E::UCTL(0)_INTSTAT_XM_BAD_DMA. */
+                                                         UCTL()_SHIM_CFG[XM_BAD_DMA_TYPE]. The hardware does not translate the request correctly
+                                                         and results may violate IOI protocols. */
 	uint64_t xs_ncb_oob                   : 1;  /**< Detected out-of-bound register access to UAHC over IOI. The UAHC defines 1MB of register
                                                          space, starting at offset 0x0. Any accesses outside of this register space cause this bit
-                                                         to be set to 1. Error information is logged in UCTL(0)_SHIM_CFG[XS_NCB_OOB_*].
-                                                         Throws UCTL_INTSN_E::UCTL(0)_INTSTAT_XS_NCB_OOB. */
+                                                         to be set to 1. Error information is logged in UCTL()_SHIM_CFG[XS_NCB_OOB_*]. */
 	uint64_t reserved_0_0                 : 1;
 #else
 	uint64_t reserved_0_0                 : 1;
@@ -1407,9 +1401,13 @@ typedef union cvmx_uctlx_orto_ctl cvmx_uctlx_orto_ctl_t;
 /**
  * cvmx_uctl#_port#_cfg_hs
  *
- * Accessible by: only when H_CLKDIV_EN
- * This register controls configuration and test controls for the high-speed port 0 PHY. This
- * register can be reset by IOI reset or UCTL(0)_CTL[UCTL_RST].
+ * This register controls configuration and test controls for the high-speed port 0 PHY.
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or UCTL()_CTL[UCTL_RST].
+ *
+ * INTERNAL: All these settings are for high-speed functionality, connect on DVDD power domain.
  */
 union cvmx_uctlx_portx_cfg_hs {
 	uint64_t u64;
@@ -1436,18 +1434,18 @@ union cvmx_uctlx_portx_cfg_hs {
 	uint64_t reserved_46_47               : 2;
 	uint64_t tx_hs_xv_tune                : 2;  /**< Transmitter high-speed crossover adjustment. This bus adjusts the voltage at which the DP0
                                                          and DM0 signals cross while transmitting in high-speed mode.
-                                                         0x3 = default setting.
-                                                         0x2 = +15 mV.
+                                                         0x0 = reserved.
                                                          0x1 = -15 mV.
-                                                         0x0 = reserved. */
+                                                         0x2 = +15 mV.
+                                                         0x3 = default setting. */
 	uint64_t tx_preemp_amp_tune           : 2;  /**< High-speed transmitter pre-emphasis current control. Controls the amount of current
                                                          sourced to DP0 and DM0 after a J-to-K or K-to-J transition. The high-speed transmitter
                                                          preemphasis current is defined in terms of unit amounts. One unit amount is approximately
                                                          600 A and is defined as 1* preemphasis current.
-                                                         0x3 = High-speed TX preemphasis circuit sources 3* preemphasis current.
-                                                         0x2 = High-speed TX preemphasis circuit sources 2* preemphasis current.
-                                                         0x1 = High-speed TX preemphasis circuit sources 1* preemphasis current.
                                                          0x0 = High-speed TX preemphasis is disabled.
+                                                         0x1 = High-speed TX preemphasis circuit sources 1* preemphasis current.
+                                                         0x2 = High-speed TX preemphasis circuit sources 2* preemphasis current.
+                                                         0x3 = High-speed TX preemphasis circuit sources 3* preemphasis current.
                                                          If these signals are not used, set them to 0x0. */
 	uint64_t reserved_41_41               : 1;
 	uint64_t tx_preemp_pulse_tune         : 1;  /**< High-speed transmitter preemphasis duration control. Controls the duration for which the
@@ -1455,16 +1453,16 @@ union cvmx_uctlx_portx_cfg_hs {
                                                          preemphasis duration is defined in terms of unit amounts. One unit of preemphasis duration
                                                          is approximately 580 ps and is defined as 1* preemphasis duration. This signal is valid
                                                          only if either TX_PREEMP_AMP_TUNE0[1] or TX_PREEMP_AMP_TUNE0[0] is set to 1.
-                                                         1 = 1*, short preemphasis current duration
                                                          0 = 2*, long preemphasis current duration (design default)
+                                                         1 = 1*, short preemphasis current duration
                                                          If this signal is not used, set it to 0. */
 	uint64_t tx_res_tune                  : 2;  /**< USB source-impedance adjustment. Some applications require additional devices to be added
                                                          on the USB, such as a series switch, which can add significant series resistance. This bus
                                                          adjusts the driver source impedance to compensate for added series resistance on the USB.
-                                                         0x3 = source impedance is decreased by approximately 4 ohm.
-                                                         0x2 = source impedance is decreased by approximately 2 ohm.
-                                                         0x1 = design default.
                                                          0x0 = source impedance is decreased by approximately 1.5 ohm.
+                                                         0x1 = design default.
+                                                         0x2 = source impedance is decreased by approximately 2 ohm.
+                                                         0x3 = source impedance is decreased by approximately 4 ohm.
                                                          Any setting other than the default can result in source-impedance variation across
                                                          process, voltage, and temperature conditions that does not meet USB 2.0 specification
                                                          limits. If this bus is not used, leave it at the default setting. */
@@ -1489,9 +1487,9 @@ union cvmx_uctlx_portx_cfg_hs {
 	uint64_t atereset                     : 1;  /**< Per-PHY ATE reset. When the USB core is powered up (not in suspend mode), an automatic
                                                          tester can use this to disable PHYCLOCK and FREECLK, then re-enable them with an aligned
                                                          phase.
-                                                         1 = PHYCLOCK and FREECLK outputs are disabled.
                                                          0 = PHYCLOCK and FREECLK are available within a specific period after ATERESET is
-                                                         deasserted. */
+                                                         deasserted.
+                                                         1 = PHYCLOCK and FREECLK outputs are disabled. */
 #else
 	uint64_t atereset                     : 1;
 	uint64_t loopback_enable              : 1;
@@ -1518,9 +1516,13 @@ typedef union cvmx_uctlx_portx_cfg_hs cvmx_uctlx_portx_cfg_hs_t;
 /**
  * cvmx_uctl#_port#_cfg_ss
  *
- * Accessible by: only when H_CLKDIV_EN
  * This register controls configuration and test controls for the SS port 0 PHY.
- * This register can be reset by IOI reset or with UCTL(0)_CTL[UCTL_RESET].
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
+ *
+ * INTERNAL: All these settings are for high-speed functionality, connect on DVDD power domain.
  */
 union cvmx_uctlx_portx_cfg_ss {
 	uint64_t u64;
@@ -1560,34 +1562,36 @@ union cvmx_uctlx_portx_cfg_ss {
                                                          clock cycles equal to the value of pcs_rx_los_mask_val<9:0>. This control filters out
                                                          short, non-compliant LFPS glitches sent by a noncompliant host.
                                                          For normal operation, set to a targeted mask interval of 10us (value = 10us / Tref_clk).
-                                                         If the UCTL(0)_CTL[REF_CLK_DIV2] is used, then
+                                                         If the UCTL()_CTL[REF_CLK_DIV2] is used, then
                                                          (value = 10us / (2 * Tref_clk)). These equations are based on the SuperSpeed reference
                                                          clock frequency. The value of PCS_RX_LOS_MASK_VAL should be as follows:
-                                                             Frequency DIV2 LOS_MASK
-                                                              200  MHz    1    0x3E8
-                                                              125  MHz    0    0x4E2
-                                                              104  MHz    0    0x410
-                                                              100  MHz    0    0x3E8
-                                                               96  MHz    0    0x3C0
-                                                               76.8MHz    1    0x180
-                                                               52  MHz    0    0x208
-                                                               50  MHz    0    0x1F4
-                                                               48  MHz    0    0x1E0
-                                                               40  MHz    1    0x0C8
-                                                               38.4MHz    0    0x180
-                                                               26  MHz    0    0x104
-                                                               25  MHz    0    0x0FA
-                                                               24  MHz    0    0x0F0
-                                                               20  MHz    0    0x0C8
-                                                               19.2MHz    0    0x0C0
+                                                         <pre>
+                                                              Frequency   DIV2  LOS_MASK
+                                                              ---------    ---  --------
+                                                              200   MHz      1     0x3E8
+                                                              125   MHz      0     0x4E2
+                                                              104   MHz      0     0x410
+                                                              100   MHz      0     0x3E8
+                                                               96   MHz      0     0x3C0
+                                                               76.8 MHz      1     0x180
+                                                               52   MHz      0     0x208
+                                                               50   MHz      0     0x1F4
+                                                               48   MHz      0     0x1E0
+                                                               40   MHz      1     0x0C8
+                                                               38.4 MHz      0     0x180
+                                                               26   MHz      0     0x104
+                                                               25   MHz      0     0x0FA
+                                                               24   MHz      0     0x0F0
+                                                               20   MHz      0     0x0C8
+                                                               19.2 MHz      0     0x0C0
+                                                         </pre>
                                                          Setting this bus to 0x0 disables masking. The value should be defined when the PHY is in
                                                          reset. Changing this value during operation might disrupt normal operation of the link. */
 	uint64_t pcs_tx_deemph_3p5db          : 6;  /**< Fine-tune transmitter driver deemphasis when set to 3.5db.
                                                          This static value sets the TX driver deemphasis value when pipeP_tx_deemph[1:0] is set to
                                                          0x1 (according to the PIPE3 specification). The values for transmit deemphasis are derived
                                                          from the following equation:
-                                                         TX de-emphasis (db) =
-                                                         20 * log_base_10((128 - 2 * pcs_tx_deemph)/128)
+                                                         _ TX de-emphasis (db) = 20 * log_base_10((128 - 2 * pcs_tx_deemph)/128)
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
@@ -1598,8 +1602,7 @@ union cvmx_uctlx_portx_cfg_ss {
                                                          0x2 (according to the PIPE3 specification). This bus is provided for completeness and as a
                                                          second potential launch amplitude. The values for transmit deemphasis are derived from the
                                                          following equation:
-                                                         TX de-emphasis (db) =
-                                                         20 * log_base_10((128 - 2 * pcs_tx_deemph)/128)
+                                                         _ TX de-emphasis (db) = 20 * log_base_10((128 - 2 * pcs_tx_deemph)/128)
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
@@ -1646,13 +1649,14 @@ typedef union cvmx_uctlx_portx_cfg_ss cvmx_uctlx_portx_cfg_ss_t;
 /**
  * cvmx_uctl#_port#_cr_dbg_cfg
  *
- * Accessible by: only when H_CLKDIV_EN
- *
  * This register allows indirect access to the configuration and test controls for the port 0
- * PHY. For directions to access the PHY registers indirectly through the CR interface, refer to
- * UPHY Registers.
- * This register can be reset by IOI reset or with UCTL(0)_CTL[UCTL_RESET].
+ * PHY.
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
  *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
+ *
+ * INTERNAL: (In body of HRM)
  * To access the PHY registers indirectly through the CR interface, the HCLK must be running,
  * UCTL_RST must be deasserted, and UPHY_RST must be deasserted. Software is responsible for
  * ensuring that only one indirect access is ongoing at a time.
@@ -1735,10 +1739,12 @@ typedef union cvmx_uctlx_portx_cr_dbg_cfg cvmx_uctlx_portx_cr_dbg_cfg_t;
 /**
  * cvmx_uctl#_port#_cr_dbg_status
  *
- * Accessible by: only when H_CLKDIV_EN
  * This register allows indirect access to the configuration and test controls for the port 0
- * PHY. For directions for usage, refer to UPHY Registers.
- * This register can be reset by IOI reset or with UCTL(0)_CTL[UCTL_RESET].
+ * PHY.
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
  */
 union cvmx_uctlx_portx_cr_dbg_status {
 	uint64_t u64;
@@ -1789,28 +1795,28 @@ typedef union cvmx_uctlx_ppaf_wm cvmx_uctlx_ppaf_wm_t;
 /**
  * cvmx_uctl#_shim_cfg
  *
- * Accessible by: only when H_CLKDIV_EN
  * This register allows configuration of various shim (UCTL) features. The fields XS_NCB_OOB_*
  * are captured when there are no outstanding OOB errors indicated in INTSTAT and a new OOB error
  * arrives. The fields XS_BAD_DMA_* are captured when there are no outstanding DMA errors
  * indicated in INTSTAT and a new DMA error arrives.
- * This register can be reset by IOI reset or with UCTL(0)_CTL[UCTL_RESET].
+ *
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
  */
 union cvmx_uctlx_shim_cfg {
 	uint64_t u64;
 	struct cvmx_uctlx_shim_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t xs_ncb_oob_wrn               : 1;  /**< Read/write error log for out-of-bound UAHC register access.
-                                                         0 = read, 1 = write */
+                                                         0 = read, 1 = write. */
 	uint64_t reserved_60_62               : 3;
 	uint64_t xs_ncb_oob_osrc              : 12; /**< SRCID error log for out-of-bound UAHC register access. The IOI outbound SRCID for the OOB
                                                          error.
-                                                         CSR bits Field bits Description
-                                                         [59:58] [11:10] chipID
-                                                         [57] [9] request source: 0 = core, 1 = IOI-device
-                                                         [56:51] [8:3] core/IOI-device number. Note that for
-                                                         IOI devices, [56]/[8] is always 0.
-                                                         [50:48] [2:0] SubID */
+                                                         <59:58> = chipID.
+                                                         <57> = Request source: 0 = core, 1 = IOI-device.
+                                                         <56:51> = Core/IOI-device number. Note that for IOI devices, <56> is always 0.
+                                                         <50:48> = SubID. */
 	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
                                                          0 = read error log, 1 = write error log */
 	uint64_t reserved_44_46               : 3;
@@ -1866,8 +1872,9 @@ typedef union cvmx_uctlx_spare0 cvmx_uctlx_spare0_t;
 /**
  * cvmx_uctl#_spare1
  *
- * Accessible by: only when H_CLKDIV_EN
- * This register can be reset by IOI reset or with UCTL(0)_CTL[UCTL_RESET].
+ * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
+ *
+ * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
  */
 union cvmx_uctlx_spare1 {
 	uint64_t u64;
-- 
2.6.2

