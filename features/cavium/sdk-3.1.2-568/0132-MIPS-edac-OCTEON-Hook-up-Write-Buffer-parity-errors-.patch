From 31cf012359195ff7531fb54fc8e37c6fa328e50a Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 18 Dec 2012 12:03:58 -0800
Subject: [PATCH 132/974] MIPS/edac/OCTEON: Hook up Write Buffer parity errors
 to EDAC.

For OCTEON II CPUs, add a Bus Error handler for the Write Buffer
parity condition.  Then make this log the errors with the EDAC system.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/octeon/octeon.h |  9 ++++++++
 arch/mips/mm/c-octeon.c               | 41 +++++++++++++++++++++++++++++++----
 drivers/edac/octeon_edac-pc.c         | 25 +++++++++++++--------
 3 files changed, 62 insertions(+), 13 deletions(-)

diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index a8b573f..f19b35f 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -402,4 +402,13 @@ static inline int octeon_error_tree_disable(enum cvmx_error_groups group, int un
 
 int octeon_i2c_cvmx2i2c(unsigned int cvmx_twsi_bus_num);
 
+int register_co_cache_error_notifier(struct notifier_block *nb);
+int unregister_co_cache_error_notifier(struct notifier_block *nb);
+#define CO_CACHE_ERROR_RECOVERABLE 0
+#define CO_CACHE_ERROR_UNRECOVERABLE 1
+#define CO_CACHE_ERROR_WB_PARITY 2
+
+extern unsigned long long cache_err_dcache[NR_CPUS];
+
+
 #endif /* __ASM_OCTEON_OCTEON_H */
diff --git a/arch/mips/mm/c-octeon.c b/arch/mips/mm/c-octeon.c
index 25c4bf0..7165aca 100644
--- a/arch/mips/mm/c-octeon.c
+++ b/arch/mips/mm/c-octeon.c
@@ -31,6 +31,8 @@
 unsigned long long cache_err_dcache[NR_CPUS];
 EXPORT_SYMBOL_GPL(cache_err_dcache);
 
+static RAW_NOTIFIER_HEAD(co_cache_error_chain);
+
 /**
  * Octeon automatically flushes the dcache on tlb changes, so
  * from Linux's viewpoint it acts much like a physically
@@ -176,6 +178,37 @@ static void octeon_flush_kernel_vmap_range(unsigned long vaddr, int size)
 	BUG();
 }
 
+/*
+ * Octeon specific bus error handler, as write buffer parity errors
+ * trigger bus errors.  These are fatal since the copy in the write buffer
+ * is the only copy of the data.
+ */
+static int octeon2_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	u64 dcache_err;
+	u64 wbfperr_mask = 1ULL << 1;
+
+	dcache_err = read_octeon_c0_dcacheerr();
+	if (dcache_err & wbfperr_mask) {
+		int rv = raw_notifier_call_chain(&co_cache_error_chain,
+						 CO_CACHE_ERROR_WB_PARITY,
+						 NULL);
+		if ((rv & ~NOTIFY_STOP_MASK) != NOTIFY_OK) {
+			unsigned int coreid = cvmx_get_core_num();
+
+			pr_err("Core%u: Write buffer parity error:\n", coreid);
+			pr_err("CacheErr (Dcache) == %llx\n", dcache_err);
+		}
+
+		write_octeon_c0_dcacheerr(wbfperr_mask);
+		return MIPS_BE_FATAL;
+	}
+	if (is_fixup)
+		return MIPS_BE_FIXUP;
+	else
+		return MIPS_BE_FATAL;
+}
+
 /**
  * Probe Octeon's caches
  *
@@ -222,6 +255,8 @@ static void __cpuinit probe_octeon(void)
 		c->dcache.sets = 8;
 		dcache_size = c->dcache.sets * c->dcache.ways * c->dcache.linesz;
 		c->options |= MIPS_CPU_PREFETCH;
+
+		board_be_handler = octeon2_be_handler;
 		break;
 
 	case CPU_CAVIUM_OCTEON3:
@@ -303,8 +338,6 @@ void __cpuinit octeon_cache_init(void)
 /*
  * Handle a cache error exception
  */
-static RAW_NOTIFIER_HEAD(co_cache_error_chain);
-
 int register_co_cache_error_notifier(struct notifier_block *nb)
 {
 	return raw_notifier_chain_register(&co_cache_error_chain, nb);
@@ -352,7 +385,7 @@ static void co_cache_error_call_notifiers(unsigned long val)
 
 asmlinkage void cache_parity_error_octeon_recoverable(void)
 {
-	co_cache_error_call_notifiers(0);
+	co_cache_error_call_notifiers(CO_CACHE_ERROR_RECOVERABLE);
 }
 
 /**
@@ -361,6 +394,6 @@ asmlinkage void cache_parity_error_octeon_recoverable(void)
 
 asmlinkage void cache_parity_error_octeon_non_recoverable(void)
 {
-	co_cache_error_call_notifiers(1);
+	co_cache_error_call_notifiers(CO_CACHE_ERROR_UNRECOVERABLE);
 	panic("Can't handle cache error: nested exception");
 }
diff --git a/drivers/edac/octeon_edac-pc.c b/drivers/edac/octeon_edac-pc.c
index 2ab6cf2..6706523 100644
--- a/drivers/edac/octeon_edac-pc.c
+++ b/drivers/edac/octeon_edac-pc.c
@@ -18,14 +18,9 @@
 #include "edac_core.h"
 #include "edac_module.h"
 
-#include <asm/octeon/cvmx.h>
+#include <asm/octeon/octeon.h>
 #include <asm/mipsregs.h>
 
-extern int register_co_cache_error_notifier(struct notifier_block *nb);
-extern int unregister_co_cache_error_notifier(struct notifier_block *nb);
-
-extern unsigned long long cache_err_dcache[NR_CPUS];
-
 struct co_cache_error {
 	struct notifier_block notifier;
 	struct edac_device_ctl_info *ed;
@@ -47,11 +42,23 @@ static int  co_cache_error_event(struct notifier_block *this,
 	u64 icache_err = read_octeon_c0_icacheerr();
 	u64 dcache_err;
 
-	if (event) {
+	switch (event) {
+	case CO_CACHE_ERROR_UNRECOVERABLE:
 		dcache_err = cache_err_dcache[core];
 		cache_err_dcache[core] = 0;
-	} else {
+		break;
+	case CO_CACHE_ERROR_RECOVERABLE:
 		dcache_err = read_octeon_c0_dcacheerr();
+		break;
+	case CO_CACHE_ERROR_WB_PARITY:
+		edac_device_printk(p->ed, KERN_ERR,
+				   "CacheErr (WB Parity): core %d/cpu %d\n",
+				   core, cpu);
+		edac_device_handle_ue(p->ed, cpu, 2, "write-buffer");
+		return NOTIFY_STOP;
+	default:
+		WARN(1, "Unknown event: %lu\n", event);
+		return NOTIFY_BAD;
 	}
 
 	if (icache_err & 1) {
@@ -93,7 +100,7 @@ static int co_cache_error_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, p);
 
 	p->ed = edac_device_alloc_ctl_info(0, "cpu", num_possible_cpus(),
-					   "cache", 2, 0, NULL, 0,
+					   "cache", 3, 0, NULL, 0,
 					   edac_device_alloc_index());
 	if (!p->ed)
 		goto err;
-- 
2.6.2

